{
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "0040eb70": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.0040eb70(int32_t param_1, int32_t param_2, uint32_t param_3)\n\n{\n    int32_t arg_ch;\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    if ((param_3 != 0) && (param_2 == 0)) {\n        fcn.0041638e();\n    }\n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        if (param_3 != 0) {\n            while( true ) {\n                uVar3 = param_3;\n                if (0x1ffffffe < param_3) {\n                    uVar3 = 0x1fffffff;\n                }\n                arg_ch = uVar3 * 4;\n                iVar2 = fcn.00438cbd(param_2, arg_ch);\n                if (iVar2 != arg_ch) break;\n                param_3 = param_3 - uVar3;\n                param_2 = param_2 + arg_ch;\n                if (param_3 == 0) {\n                    return;\n                }\n            }\n            fcn.0043f8ce(3, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n    }\n    else if (param_3 != 0) {\n        do {\n            uVar3 = param_3;\n            if (0x1ffffffe < param_3) {\n                uVar3 = 0x1fffffff;\n            }\n            fcn.00439273(param_2, uVar3 * 4);\n            param_3 = param_3 - uVar3;\n            param_2 = param_2 + uVar3 * 4;\n        } while (param_3 != 0);\n    }\n    return;\n}\n",
        "token_count": 403
    },
    "00416627": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00416627(uint32_t arg_8h)\n\n{\n    fcn.004010f0();\n    if ((arg_8h & 1) != 0) {\n        fcn.00414b30();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "0041aa9d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041aa9d(uint32_t arg_8h)\n\n{\n    bool bVar1;\n    bool bVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t arg_8h_00;\n    int32_t iVar6;\n    int32_t *in_ECX;\n    uint hWnd;\n    uint lpMsg;\n    uint var_ch;\n    int32_t lParam;\n    uint var_4h;\n    \n    bVar2 = true;\n    lParam = 0;\n    if ((arg_8h & 4) != 0) {\n        uVar4 = fcn.00418009();\n        bVar1 = true;\n        if ((uVar4 & 0x10000000) == 0) goto code_r0x0041aacd;\n    }\n    bVar1 = false;\ncode_r0x0041aacd:\n    iVar5 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n    in_ECX[0xf] = in_ECX[0xf] | 0x18;\n    arg_8h_00 = fcn.004379bc();\n    pcVar3 = _sym.imp.USER32.dll_UpdateWindow;\ncode_r0x0041ab58:\n    while ((!bVar2 || (iVar6 = (*_sym.imp.USER32.dll_PeekMessageA)(arg_8h_00, 0, 0, 0, 0),  iVar6 != 0))) {\n        do {\n            iVar6 = fcn.00437f42();\n            if (iVar6 == 0) {\n                fcn.0043e2fc(0);\n                return -1;\n            }\n            if ((bVar1) && ((*(arg_8h_00 + 4) == 0x118 || (*(arg_8h_00 + 4) == 0x104)))) {\n                fcn.00418160(1);\n                (*pcVar3)(in_ECX[8]);\n                bVar1 = false;\n            }\n            iVar6 = (**(*in_ECX + 0x88))();\n            if (iVar6 == 0) {\n                in_ECX[0xf] = in_ECX[0xf] & 0xffffffe7;\n                return in_ECX[0x11];\n            }\n            iVar6 = fcn.00437dbf(arg_8h_00);\n            if (iVar6 != 0) {\n                bVar2 = true;\n                lParam = 0;\n            }\n            iVar6 = (*_sym.imp.USER32.dll_PeekMessageA)(arg_8h_00, 0, 0, 0, 0);\n        } while (iVar6 != 0);\n    }\n    if (bVar1) {\n        fcn.00418160(1);\n        (*pcVar3)(in_ECX[8]);\n        bVar1 = false;\n    }\n    if ((((arg_8h & 1) == 0) && (iVar5 != 0)) && (lParam == 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x121, 0, in_ECX[8]);\n    }\n    if ((arg_8h & 2) == 0) goto code_r0x0041ab3c;\n    goto code_r0x0041ab55;\ncode_r0x0041ab3c:\n    iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[8], 0x36a, 0, lParam);\n    lParam = lParam + 1;\n    if (iVar6 == 0) {\ncode_r0x0041ab55:\n        bVar2 = false;\n    }\n    goto code_r0x0041ab58;\n}\n",
        "token_count": 837
    },
    "0041de55": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041de55(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    uint32_t var_34h;\n    uint var_30h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    char *var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.0042052a();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.00458b20(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.0042052a();\n        var_24h = *(iVar1 + 8);\n        var_1ch = *0x49be80;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            var_34h = 0xb;\n            var_10h = \"AfxWnd90s\";\n            iVar1 = fcn.0041db54(&var_34h);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            var_10h = \"AfxOleControl90s\";\n            iVar1 = fcn.0041db54(&var_34h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            var_10h = 0x47a900;\n            var_18h = 0x10;\n            iVar1 = fcn.0041db54(&var_34h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            var_18h = 0;\n            iVar1 = fcn.0041de11(&var_34h, \"AfxMDIFrame90s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            var_18h = 6;\n            iVar1 = fcn.0041de11(&var_34h, \"AfxFrameOrView90s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.0041b628(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.0041b628(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.0041b628(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.0041b628(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.0041b628(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.0041b628(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.0041b628(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.0041b628(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.0041b628(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.0041b628(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.0041b628(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.0041b628(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.0041b628(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x40000) != 0) {\n            var_8h = 0x8000;\n            uVar2 = fcn.0041b628(&var_ch, 0x40000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80000) != 0) {\n            var_8h = 0x1000;\n            uVar2 = fcn.0041b628(&var_ch, 0x80000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n            uVar3 = uVar3 | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 1861
    },
    "00421782": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421782(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if ((*(arg_8h + 4) & 1) == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(*(arg_8h + 8), *(arg_8h + 0xc), 5);\n        if (iVar2 == 0) {\n            fcn.00416f76();\n        }\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(*(arg_8h + 8), iVar2);\n        if (iVar2 == 0) {\n            fcn.00416f76();\n        }\n        iVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        if (iVar2 == 0) {\n            fcn.00416f76();\n        }\n    }\n    else {\n        iVar2 = *(arg_8h + 0xc);\n    }\n    iVar1 = fcn.0042052a();\n    if (*(iVar1 + 0x3c) != 0) {\n        iVar2 = fcn.00420659(iVar2);\n    }\n    iVar1 = fcn.004216a8(iVar2, arg_ch);\n    if (*(in_ECX + 0x5c) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(*(in_ECX + 0x5c));\n        *(in_ECX + 0x5c) = 0;\n    }\n    if (iVar1 != 0) {\n        *(in_ECX + 0x5c) = iVar1;\n        iVar2 = iVar1;\n    }\n    *(arg_8h + 4) = *(arg_8h + 4) | 1;\n    *(arg_8h + 0xc) = iVar2;\n    return;\n}\n",
        "token_count": 435
    },
    "0042335e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042335e(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint32_t wParam;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = &var_8h;\n    iVar1 = *(in_ECX + 0x54);\n    var_10h = 0;\n    var_ch = 0x4223b3;\n    var_8h = arg_8h;\n    var_4h = 0;\n    if (iVar1 == 0) {\n        iVar1 = fcn.0041638e();\n        arg_8h = extraout_ECX;\n    }\n    wParam = (*(iVar1 + 0xec) != 0) + 1;\n    if (arg_ch != 0) {\n        wParam = wParam | 0x8000;\n    }\n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        fcn.00422200(wParam, &var_14h);\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    else {\n        fcn.0042221d(wParam, &var_14h);\n    }\n    if (var_4h != 0) {\n        fcn.0043880a(var_4h, 0xffffffff, 0);\n    }\n    return;\n}\n",
        "token_count": 369
    },
    "004235d9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004235d9(int32_t *arg_8h)\n\n{\n    uint16_t uVar1;\n    int32_t in_ECX;\n    \n    fcn.00422bee();\n    if ((*(in_ECX + 0xb8) & 0x20) == 0) {\n        uVar1 = 2;\n    }\n    else {\n        uVar1 = *(in_ECX + 0xbc) & 1;\n    }\n    (**(*arg_8h + 4))(uVar1);\n    return;\n}\n",
        "token_count": 122
    },
    "00424d7f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424d7f(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(2, *(in_ECX + 0x14));\n    }\n    uVar1 = *(in_ECX + 0x28) + 2;\n    if (*(in_ECX + 0x2c) <= uVar1 && uVar1 != *(in_ECX + 0x2c)) {\n        fcn.00438dee();\n    }\n    **(in_ECX + 0x28) = arg_8h;\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 2;\n    return;\n}\n",
        "token_count": 194
    },
    "00424dbe": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424dbe(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(2, *(in_ECX + 0x14));\n    }\n    uVar1 = *(in_ECX + 0x28) + 4;\n    if (*(in_ECX + 0x2c) <= uVar1 && uVar1 != *(in_ECX + 0x2c)) {\n        fcn.00438dee();\n    }\n    **(in_ECX + 0x28) = arg_8h;\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 4;\n    return;\n}\n",
        "token_count": 192
    },
    "00424dfc": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424dfc(ushort *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(4, *(in_ECX + 0x14));\n    }\n    if (*(in_ECX + 0x2c) < *(in_ECX + 0x28) + 2U) {\n        fcn.00438e66((*(in_ECX + 0x28) - *(in_ECX + 0x2c)) + 2);\n    }\n    *arg_8h = **(in_ECX + 0x28);\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 2;\n    return;\n}\n",
        "token_count": 190
    },
    "00424e44": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424e44(uint *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(4, *(in_ECX + 0x14));\n    }\n    if (*(in_ECX + 0x2c) < *(in_ECX + 0x28) + 4U) {\n        fcn.00438e66((*(in_ECX + 0x28) - *(in_ECX + 0x2c)) + 4);\n    }\n    *arg_8h = **(in_ECX + 0x28);\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 4;\n    return;\n}\n",
        "token_count": 189
    },
    "0042509e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042509e(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    uint arg_8h_00;\n    uint in_stack_ffffffec;\n    \n    if (arg_8h != 0) goto code_r0x004250b9;\n    in_stack_ffffffec = *(in_ECX + 0x14);\n    arg_8h_00 = 6;\n    while( true ) {\n        fcn.0043f8ce(arg_8h_00, in_stack_ffffffec);\ncode_r0x004250b9:\n        if ((~*(in_ECX + 0x18) & 1) != 0) break;\n        arg_8h_00 = 1;\n    }\n    if (*(arg_8h + 8) == 0xffff) {\n        fcn.00416372();\n    }\n    fcn.00424f5f(0);\n    puVar2 = fcn.0044abf4(arg_8h);\n    uVar1 = *puVar2;\n    if (uVar1 == 0) {\n        fcn.00424d7f(0xffff);\n        fcn.0043939f(in_ECX);\n        fcn.00424c7e();\n        puVar3 = fcn.0044abf4(arg_8h);\n        *puVar3 = *(in_ECX + 0x34);\n        *(in_ECX + 0x34) = *(in_ECX + 0x34) + 1;\n    }\n    else if (uVar1 < 0x7fff) {\n        fcn.00424d7f(uVar1 | 0x8000);\n    }\n    else {\n        fcn.00424d7f(0x7fff);\n        fcn.00424dbe(uVar1 | 0x80000000);\n    }\n    return;\n}\n",
        "token_count": 446
    },
    "0042514d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0042514d(int32_t arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    uint32_t uVar4;\n    uint arg_8h_01;\n    uint in_stack_ffffffdc;\n    int32_t var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*(in_ECX + 0x18) & 1) != 0) goto code_r0x0042516a;\n    in_stack_ffffffdc = *(in_ECX + 0x14);\n    arg_8h_01 = 1;\ncode_r0x00425165:\n    do {\n        while( true ) {\n            fcn.0043f8ce(arg_8h_01, in_stack_ffffffdc);\ncode_r0x0042516a:\n            arg_8h_00 = 0xffff;\n            if ((arg_8h != 0) && (*(arg_8h + 8) == 0xffff)) {\n                fcn.00416372();\n            }\n            fcn.00424f5f(0);\n            fcn.00424dfc(&var_4h);\n            if (var_4h == 0x7fff) {\n                fcn.00424e44(&var_ch);\n            }\n            else {\n                var_ch = (var_4h & 0x8000) << 0x10 | var_4h & 0x7fff;\n            }\n            if ((var_ch & 0x80000000) != 0) break;\n            if (arg_10h != NULL) {\n                *arg_10h = var_ch;\n                return 0;\n            }\ncode_r0x004251d5:\n            arg_8h_01 = 5;\n        }\n        if (var_4h != -1) {\n            uVar4 = var_ch & 0x7fffffff;\n            if ((uVar4 == 0) || (*(*(in_ECX + 0x38) + 8) - 1U < uVar4)) goto code_r0x004251d5;\n            var_4h = 0;\n            fcn.0044aa72(1, &var_4h);\n            if (var_4h == 0) {\ncode_r0x0042526d:\n                fcn.0041638e();\n                goto code_r0x00425272;\n            }\n            piVar2 = fcn.00433c4b(uVar4);\n            if (*piVar2 == 2) goto code_r0x004251d5;\n            arg_8h_00 = fcn.00420885(uVar4);\n            var_8h = 0;\n            if ((*(in_ECX + 0x3c) == 0) || (iVar3 = fcn.0044aa72(arg_8h_00, &var_4h),  var_8h = var_4h,  iVar3 == 0)) {\n                var_8h = *(arg_8h_00 + 8) & 0x7fffffff;\n            }\ncode_r0x00425303:\n            if ((arg_8h == 0) || (iVar3 = fcn.00424be7(arg_8h),  iVar3 != 0)) {\n                if (arg_ch == NULL) {\n                    *(in_ECX + 0x10) = var_8h;\n                }\n                else {\n                    *arg_ch = var_8h;\n                }\n                if (arg_10h != NULL) {\n                    *arg_10h = var_ch;\n                }\n                return arg_8h_00;\n            }\ncode_r0x004251ff:\n            arg_8h_01 = 6;\n            goto code_r0x00425165;\n        }\n        arg_8h_00 = fcn.004391ec(in_ECX, &var_8h);\n        if (arg_8h_00 == 0) goto code_r0x004251ff;\n        if ((*(arg_8h_00 + 8) & 0x7fffffff) == var_8h) {\ncode_r0x0042523e:\n            fcn.00424c7e();\n            uVar4 = 1;\n            fcn.0042c207(*(in_ECX + 0x34), arg_8h_00, 1);\n            var_10h = 0;\n            fcn.0044aa72(1, &var_10h);\n            if (var_10h == 0) goto code_r0x0042526d;\ncode_r0x00425272:\n            var_4h = uVar4;\n            fcn.00424ca9(*(in_ECX + 0x34), &var_4h, uVar4);\n            *(in_ECX + 0x34) = *(in_ECX + 0x34) + 1;\n            goto code_r0x00425303;\n        }\n        if ((*(arg_8h_00 + 8) & 0x80000000) != 0) {\n            fcn.00424e8b(0);\n            uVar4 = var_8h;\n            puVar1 = fcn.0044abf4(arg_8h_00);\n            *puVar1 = uVar4;\n            goto code_r0x0042523e;\n        }\n        arg_8h_01 = 7;\n    } while( true );\n}\n",
        "token_count": 1283
    },
    "00425341": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425341(int32_t *arg_8h)\n\n{\n    uint32_t arg_8h_00;\n    uint32_t *puVar1;\n    uint arg_8h_01;\n    uint *puVar2;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(2, *(in_ECX + 0x14));\n    }\n    fcn.00424f5f(0);\n    if (arg_8h == NULL) {\n        fcn.00424d7f(0);\n    }\n    else {\n        puVar1 = fcn.0044abf4(arg_8h);\n        arg_8h_00 = *puVar1;\n        if (arg_8h_00 == 0) {\n            arg_8h_01 = (***arg_8h)();\n            fcn.0042509e(arg_8h_01);\n            fcn.00424c7e();\n            puVar2 = fcn.0044abf4(arg_8h);\n            *puVar2 = *(in_ECX + 0x34);\n            *(in_ECX + 0x34) = *(in_ECX + 0x34) + 1;\n            (**(*arg_8h + 8))();\n        }\n        else if (arg_8h_00 < 0x7fff) {\n            fcn.00424d7f(arg_8h_00);\n        }\n        else {\n            fcn.00424d7f(0x7fff);\n            fcn.00424dbe(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 387
    },
    "004253dd": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.004253dd(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *arg_ch;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint uVar4;\n    uint var_4h;\n    \n    var_4h = 0x4253e9;\n    fcn.0045af6e(0x14);\n    if ((*(extraout_ECX + 0x18) & 1) != 0) goto code_r0x004253fb;\n    var_4h = *(extraout_ECX + 0x14);\n    uVar4 = 4;\ncode_r0x004253f6:\n    do {\n        fcn.0043f8ce(uVar4, var_4h);\ncode_r0x004253fb:\n        iVar2 = fcn.0042514d(*(unaff_EBP + 8), unaff_EBP + -0x1c, unaff_EBP + -0x18);\n        *(unaff_EBP + -0x14) = 0;\n        if (iVar2 == 0) {\n            arg_ch = *(unaff_EBP + -0x18);\n            if (*(*(extraout_ECX + 0x38) + 8) + -1 < arg_ch) {\ncode_r0x00425426:\n                uVar4 = 5;\n                goto code_r0x004253f6;\n            }\n            *(unaff_EBP + -0x14) = 0;\n            iVar2 = fcn.0044aa72(1, unaff_EBP + -0x14);\n            if (iVar2 != 0) {\n                iVar2 = *(unaff_EBP + -0x14);\n                if (iVar2 == 0) goto code_r0x00425449;\n                goto code_r0x0042544e;\n            }\n        }\n        else {\n            *(unaff_EBP + -4) = 0;\n            arg_ch = fcn.00424b9d();\n            *(unaff_EBP + -0x14) = arg_ch;\n            if (arg_ch == NULL) {\n                fcn.00416356();\n            }\n            fcn.00424c7e();\n            fcn.0042c207(*(extraout_ECX + 0x34), arg_ch, 1);\n            *(unaff_EBP + 8) = 0;\n            fcn.0044aa72(1, unaff_EBP + 8);\n            if (*(unaff_EBP + 8) != 0) {\n                uVar4 = *(extraout_ECX + 0x34);\n                *(unaff_EBP + -0x18) = 2;\n                fcn.00424ca9(uVar4, unaff_EBP + -0x18, 1);\n                uVar4 = *(unaff_EBP + -0x1c);\n                uVar1 = *(extraout_ECX + 0x10);\n                *(extraout_ECX + 0x34) = *(extraout_ECX + 0x34) + 1;\n                *(extraout_ECX + 0x10) = uVar4;\n                (**(*arg_ch + 8))(extraout_ECX);\n                *(extraout_ECX + 0x10) = uVar1;\ncode_r0x00425515:\n                fcn.0045b013();\n                return;\n            }\ncode_r0x00425449:\n            fcn.0041638e();\n            iVar2 = extraout_ECX_00;\ncode_r0x0042544e:\n            if (arg_ch <= *(iVar2 + 8) + -1) {\n                piVar3 = fcn.00433c4b(arg_ch);\n                if (*piVar3 == 1) goto code_r0x00425426;\n            }\n        }\n        iVar2 = fcn.00420885(arg_ch);\n        if ((iVar2 == 0) || (*(unaff_EBP + 8) == 0)) goto code_r0x00425515;\n        iVar2 = fcn.00424c12(*(unaff_EBP + 8));\n        if (iVar2 != 0) goto code_r0x00425515;\n        uVar4 = 6;\n    } while( true );\n}\n",
        "token_count": 1061
    },
    "00427405": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427405(int32_t **arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if (((~arg_8h[6] & 1) == 0) && (*(in_ECX + 0x20) == 0)) {\n        (**(**arg_8h + 0xbc))();\n    }\n    return;\n}\n",
        "token_count": 83
    },
    "0042c96f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042c96f(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    uVar1 = param_1[0x21];\n    param_1[0x29] = 0;\n    if (((uVar1 & 1) == 0) || ((uVar1 & 4) == 0)) {\n        if ((uVar1 & 0xa000) == 0) {\n            uVar2 = 0x50;\n        }\n        else {\n            uVar2 = 0x4a;\n        }\n    }\n    else {\n        uVar2 = 0x46;\n    }\n    var_8h = param_1;\n    piStack8 = param_1;\n    (**(*param_1 + 0x140))(&var_8h, 0, uVar2);\n    return;\n}\n",
        "token_count": 219
    },
    "0042c9f1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042c9f1(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint8_t *puVar5;\n    int32_t iVar6;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar3 = 0;\n    iVar6 = 0;\n    var_4h = 0;\n    if (arg_ch < 1) {\ncode_r0x0042cab6:\n        return var_4h + 1;\n    }\ncode_r0x0042ca11:\n    piVar1 = iVar3 * 0x14 + arg_8h;\n    piVar4 = piVar1 + 2;\n    *piVar4 = *piVar4 & 0xdf;\n    if ((*piVar4 & 8) == 0) {\n        if ((*(piVar1 + 9) & 1) == 0) {\n            iVar2 = *(in_ECX + 0xb0);\n        }\n        else {\n            iVar2 = *piVar1;\n        }\n        iVar6 = iVar6 + iVar2;\n        iVar2 = iVar3;\n        if (arg_10h < iVar6) {\n            for (; (-1 < iVar2 && ((*piVar4 & 0x20) == 0)); piVar4 = piVar4 + -5) {\n                if (((*(piVar4 + 1) & 1) != 0) && ((piVar4[-1] == 0 && ((*piVar4 & 8) == 0)))) goto code_r0x0042ca99;\n                iVar2 = iVar2 + -1;\n            }\n            iVar2 = iVar3 + -1;\n            if (-1 < iVar2) {\n                puVar5 = iVar2 * 0x14 + 8 + arg_8h;\n                do {\n                    if ((*puVar5 & 0x20) != 0) break;\n                    if (((*puVar5 & 8) == 0) && (((puVar5[1] & 1) == 0 || (*(puVar5 + -4) == 0))))\n                    goto code_r0x0042ca99;\n                    iVar2 = iVar2 + -1;\n                    puVar5 = puVar5 + -0x14;\n                } while (-1 < iVar2);\n            }\n        }\n    }\n    goto code_r0x0042caaa;\ncode_r0x0042ca99:\n    puVar5 = iVar2 * 0x14 + 8 + arg_8h;\n    *puVar5 = *puVar5 | 0x20;\n    iVar6 = 0;\n    var_4h = var_4h + 1;\n    iVar3 = iVar2;\ncode_r0x0042caaa:\n    iVar3 = iVar3 + 1;\n    if (arg_ch <= iVar3) goto code_r0x0042cab6;\n    goto code_r0x0042ca11;\n}\n",
        "token_count": 702
    },
    "0042cfbd": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042cfbd(uint arg_8h, int32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *in_ECX;\n    uint *puVar4;\n    uint *arg_8h_00;\n    uint var_30h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint8_t var_fh;\n    uint var_eh;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_8h_00 = &var_18h;\n    (**(*in_ECX + 0x118))(0x417, arg_8h);\n    *(arg_ch + 2) = *(arg_ch + 2) ^ 4;\n    var_eh._0_1_ = 0;\n    var_eh._1_1_ = 0;\n    *(arg_ch + 10) = 0;\n    *(arg_ch + 0xb) = 0;\n    iVar2 = fcn.0045b591(arg_ch, &var_18h, 0x14);\n    if (iVar2 != 0) {\n        uVar3 = fcn.00418009();\n        var_20h = uVar3;\n        fcn.0041803d(0x10000000, 0, 0);\n        (**(*in_ECX + 0x118))(0x416, arg_8h, 0);\n        pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n        if (arg_ch[4] < -1) {\n            var_1ch = (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[8], 0x43d, 0, 0);\n            (*pcVar1)(in_ECX[8], 0xb, 0, 0);\n            (*pcVar1)(in_ECX[8], 0x43c, var_1ch + 1, 0);\n            (*pcVar1)(in_ECX[8], 0x43c, var_1ch, 0);\n            (*pcVar1)(in_ECX[8], 0xb, 1, 0);\n            arg_ch[4] = arg_ch[4] + 1000000;\n            uVar3 = var_20h;\n        }\n        (**(*in_ECX + 0x118))(0x415, arg_8h, arg_ch);\n        fcn.0041803d(0, uVar3 & 0x10000000, 0);\n        if ((((*(arg_ch + 9) ^ var_fh) & 1) == 0) && (((*(arg_ch + 9) & 1) == 0 || (*arg_ch == var_18h)))) {\n            iVar2 = (**(*in_ECX + 0x118))(0x41d, arg_8h, &var_30h);\n            if (iVar2 == 0) goto code_r0x0042d112;\n            puVar4 = &var_30h;\n        }\n        else {\n            puVar4 = NULL;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(in_ECX[8], puVar4, 1);\n    }\ncode_r0x0042d112:\n    fcn.0045843c(arg_8h_00);\n    return;\n}\n",
        "token_count": 788
    },
    "0042d1c2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0042d1c2(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint8_t *puVar8;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar7 = *in_ECX;\n    var_ch = 0;\n    var_8h = 0;\n    *arg_8h = 0;\n    arg_8h[1] = 0;\n    uVar2 = (**(iVar7 + 0x118))(0x455, 0, 0);\n    if (0 < arg_10h) {\n        puVar8 = arg_ch + 9;\n        arg_ch = arg_10h;\n        do {\n            arg_10h = *(puVar8 + -9);\n            uVar3 = fcn.00418009();\n            if (((uVar3 & 0x800) == 0) && (*0x49776c != 0x40047)) {\n                arg_10h = (arg_10h * 2) / 3;\n            }\n            if ((puVar8[-1] & 8) == 0) {\n                uVar1 = *puVar8;\n                iVar7 = in_ECX[0x2c];\n                if ((uVar1 & 1) == 0) {\n                    if (((uVar1 & 8) != 0) && ((uVar2 & 1) != 0)) {\n                        iVar7 = iVar7 + *0x497770;\n                    }\n                    iVar4 = var_ch + iVar7;\n                    if (var_ch + iVar7 <= *arg_8h) {\n                        iVar4 = *arg_8h;\n                    }\n                    *arg_8h = iVar4;\n                    iVar4 = in_ECX[0x2d];\n                    iVar6 = var_8h;\ncode_r0x0042d29e:\n                    iVar5 = iVar4 + iVar6;\n                    if (iVar4 + iVar6 <= arg_8h[1]) {\n                        iVar5 = arg_8h[1];\n                    }\n                    arg_8h[1] = iVar5;\n                }\n                else {\n                    if ((puVar8[-1] & 0x20) != 0) {\n                        iVar4 = in_ECX[0x2d] + var_8h;\n                        iVar6 = arg_10h;\n                        goto code_r0x0042d29e;\n                    }\n                    iVar4 = *(puVar8 + -9) + var_ch;\n                    if (*(puVar8 + -9) + var_ch <= *arg_8h) {\n                        iVar4 = *arg_8h;\n                    }\n                    *arg_8h = iVar4;\n                }\n                if ((uVar1 & 1) != 0) {\n                    iVar7 = *(puVar8 + -9);\n                }\n                var_ch = var_ch + iVar7;\n                if ((puVar8[-1] & 0x20) != 0) {\n                    var_8h = var_8h + in_ECX[0x2d];\n                    var_ch = 0;\n                    if ((uVar1 & 1) != 0) {\n                        var_8h = var_8h + arg_10h;\n                    }\n                }\n            }\n            puVar8 = puVar8 + 0x14;\n            arg_ch = arg_ch + -1;\n        } while (arg_ch != 0);\n    }\n    return arg_8h;\n}\n",
        "token_count": 844
    },
    "0042d658": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d658(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    \n    puVar1 = in_ECX + 0x84;\n    uVar2 = *puVar1;\n    *puVar1 = uVar2 & 0xfffff0ff;\n    fcn.0042e84d(arg_8h);\n    *puVar1 = uVar2;\n    if (((uVar2 & 4) != 0) && ((*(arg_8h + 0x18) & 1) == 0)) {\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 181
    },
    "0042d75a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042d75a(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar4 = 0;\n    var_8h = 0;\n    var_4h = 0;\n    if (0x40046 < *0x49776c) {\n        var_8h = fcn.00418009();\n        iVar4 = fcn.0041803d(0, 0x8800, 0);\n        if (0x5ffff < *0x49776c) {\n            if (param_1 == 0) {\n                uVar1 = 0;\n            }\n            else {\n                uVar1 = *(param_1 + 0x20);\n            }\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar2 != 0) {\n                uVar3 = fcn.0042cba2();\n                var_4h = fcn.0042cbb5(uVar3 & 0xfffffffe);\n            }\n        }\n    }\n    uVar1 = fcn.0041ae6e();\n    if (iVar4 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(param_1 + 0x20), 0xfffffff0, var_8h);\n    }\n    if ((var_4h & 1) != 0) {\n        fcn.0042cbb5(var_4h);\n    }\n    return uVar1;\n}\n",
        "token_count": 368
    },
    "0042d953": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042d953(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint arg_8h_00;\n    uint var_40h;\n    uint var_3ch;\n    uint32_t var_38h;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_fh;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0041e777();\n    arg_8h_00 = 0;\n    var_40h = 0x47cc00;\n    var_20h = (**(*in_ECX + 0x118))(0x418, 0, 0);\n    var_38h = 0;\n    if (var_20h != 0) {\n        do {\n            fcn.0042c902(var_38h, &var_18h);\n            var_3ch = var_14h;\n            if ((var_fh & 1) == 0) {\n                iVar1 = fcn.0041e5f9(0, 0xbd11ffff, &var_40h, 0);\n                if (iVar1 == 0) {\n                    iVar1 = fcn.0041e5f9(var_3ch, 0xffffffff, &var_40h, 0);\n                    if (iVar1 == 0) {\n                        fcn.0041e79d(arg_8h, arg_ch);\n                    }\n                }\n            }\n            var_38h = var_38h + 1;\n        } while (var_38h < var_20h);\n    }\n    fcn.0041bb89(arg_8h, arg_ch);\n    fcn.0045843c(arg_8h_00);\n    return;\n}\n",
        "token_count": 443
    },
    "0042db2e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n\nint32_t * __cdecl fcn.0042db2e(int32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t *piVar3;\n    int32_t *in_ECX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t arg_ch_00;\n    uint32_t *puVar6;\n    int32_t iVar7;\n    uint32_t lpRect;\n    uint32_t var_38h;\n    uint32_t var_34h;\n    uint32_t var_30h;\n    int32_t lprc;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    uint32_t *var_18h;\n    int32_t var_14h;\n    uint32_t *var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint32_t *var_4h;\n    \n    iVar5 = *in_ECX;\n    var_4h = NULL;\n    *arg_8h = 0;\n    arg_8h[1] = 0;\n    var_ch = (**(iVar5 + 0x118))(0x418, 0, 0);\n    if (var_ch == 0) goto code_r0x0042de22;\n    puVar2 = fcn.00414af6(-(var_ch * 0x14 >> 0x20 != 0) | var_ch * 0x14);\n    iVar5 = 0;\n    var_4h = puVar2;\n    if (var_ch < 1) goto code_r0x0042de22;\n    do {\n        fcn.0042c902(iVar5, puVar2);\n        arg_ch_00 = var_ch;\n        iVar5 = iVar5 + 1;\n        puVar2 = puVar2 + 5;\n    } while (iVar5 < var_ch);\n    uVar4 = 0;\n    if (var_ch < 1) goto code_r0x0042de22;\n    uVar1 = in_ECX[0x21];\n    if ((uVar1 & 2) == 0) {\n        if ((uVar1 & 4) == 0) {\ncode_r0x0042dc2b:\n            uVar4 = -((arg_ch & 2) != 0) & 0x7fff;\n        }\n        else if ((arg_ch & 4) == 0) {\n            if ((arg_ch & 8) == 0) {\n                if ((arg_ch & 0x10) == 0) {\n                    if (arg_10h == -1) {\n                        if ((uVar1 & 1) == 0) goto code_r0x0042dc2b;\n                        goto code_r0x0042dbc6;\n                    }\n                    (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n                    (**(*in_ECX + 0x148))(&lprc, arg_ch & 2);\n                    lpRect = arg_ch & 0x20;\n                    if (lpRect == 0) {\n                        var_28h = var_24h - lprc;\n                    }\n                    else {\n                        var_28h = var_20h - var_28h;\n                    }\n                    uVar4 = var_28h + arg_10h;\n                }\n                else {\n                    lpRect = 0;\n                }\n            }\n            else {\n                uVar4 = 0x7fff;\n            }\n        }\n        else {\ncode_r0x0042dbc6:\n            uVar4 = in_ECX[0x1c];\n        }\n        fcn.0042d2f4(var_4h, arg_ch_00, uVar4, lpRect);\n    }\n    piVar3 = fcn.0042d1c2(&var_24h, var_4h, arg_ch_00);\n    iVar5 = piVar3[1];\n    *arg_8h = *piVar3;\n    arg_8h[1] = iVar5;\n    if ((arg_ch & 0x40) != 0) {\n        var_20h = in_ECX[0x29];\n        var_14h = 0;\n        arg_10h = 0;\n        in_ECX[0x29] = 0;\n        if (0 < arg_ch_00) {\n            var_18h = var_4h + 1;\n            puVar2 = var_18h;\n            uVar4 = arg_ch_00;\n            do {\n                if (((*(puVar2 + 5) & 1) != 0) && (*puVar2 != 0)) {\n                    arg_10h = arg_10h + 1;\n                }\n                puVar2 = puVar2 + 5;\n                uVar4 = uVar4 - 1;\n            } while (uVar4 != 0);\n            if (0 < arg_10h) {\n                var_14h = fcn.00414af6(-(arg_10h * 0x18 >> 0x20 != 0) | arg_10h * 0x18);\n                var_10h = var_14h + 8;\n                var_1ch = arg_10h;\n                arg_10h = 0;\n                var_8h = 0;\n                puVar2 = var_10h;\n                do {\n                    arg_ch_00 = var_ch;\n                    if (var_1ch <= arg_10h) break;\n                    puVar6 = puVar2;\n                    if (((*(var_18h + 5) & 1) != 0) && (*var_18h != 0)) {\n                        puVar2[-2] = var_8h;\n                        puVar2[-1] = *var_18h;\n                        (**(*in_ECX + 0x184))(var_8h, &lpRect);\n                        fcn.004172e2(&lpRect);\n                        arg_10h = arg_10h + 1;\n                        puVar6 = var_10h + 6;\n                        *puVar2 = lpRect;\n                        puVar2[1] = var_38h;\n                        puVar2[2] = var_34h;\n                        puVar2[3] = var_30h;\n                        var_10h = puVar6;\n                    }\n                    var_8h = var_8h + 1;\n                    var_18h = var_18h + 5;\n                    arg_ch_00 = var_ch;\n                    puVar2 = puVar6;\n                } while (var_8h < var_ch);\n            }\n        }\n        if (((in_ECX[0x21] & 1U) != 0) && ((in_ECX[0x21] & 4U) != 0)) {\n            in_ECX[0x1c] = *arg_8h;\n        }\n        var_8h = 0;\n        if (0 < arg_ch_00) {\n            var_10h = var_4h;\n            do {\n                fcn.0042cfbd(var_8h, var_10h);\n                var_8h = var_8h + 1;\n                var_10h = var_10h + 5;\n            } while (var_8h < arg_ch_00);\n        }\n        if (0 < arg_10h) {\n            puVar2 = var_14h + 8;\n            do {\n                var_10h = puVar2;\n                var_1ch = fcn.00417f55(puVar2[-1]);\n                if (var_1ch != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(*(var_1ch + 0x20), &lpRect);\n                    iVar7 = var_38h - puVar2[1];\n                    iVar5 = lpRect - *puVar2;\n                    (**(*in_ECX + 0x184))(var_10h[-2], &lpRect);\n                    fcn.0041822e(0, iVar5 + lpRect, iVar7 + var_38h, 0, 0, 0x15);\n                    puVar2 = var_10h;\n                }\n                puVar2 = puVar2 + 6;\n                arg_10h = arg_10h - 1;\n            } while (arg_10h != 0);\n            var_10h = puVar2;\n            fcn.00414b30(var_14h);\n        }\n        in_ECX[0x29] = var_20h;\n    }\n    fcn.00414b30(var_4h);\ncode_r0x0042de22:\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&lpRect);\n    (**(*in_ECX + 0x148))(&lpRect, arg_ch & 2);\n    arg_8h[1] = arg_8h[1] + (var_38h - var_30h);\n    *arg_8h = *arg_8h + (lpRect - var_34h);\n    fcn.0042e623(&var_24h, arg_ch & 1, arg_ch & 2);\n    iVar5 = *arg_8h;\n    if (*arg_8h <= var_24h) {\n        iVar5 = var_24h;\n    }\n    *arg_8h = iVar5;\n    iVar5 = arg_8h[1];\n    if (arg_8h[1] <= var_20h) {\n        iVar5 = var_20h;\n    }\n    arg_8h[1] = iVar5;\n    return arg_8h;\n}\n",
        "token_count": 2190
    },
    "0042e84d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e84d(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(in_ECX + 0x20), 0x46, 0, arg_8h);\n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x20), &lpRect);\n        var_4h = *(arg_8h + 0x10);\n        var_ch = var_ch - lpRect;\n        var_8h = var_8h - var_10h;\n        iVar1 = *(arg_8h + 0x14);\n        if ((var_4h != var_ch) && ((*(in_ECX + 0x84) & 0x400) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_4h - *0x49be50, 0, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_ch - *0x49be50, 0, var_ch, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n        }\n        pcVar2 = _sym.imp.USER32.dll_SetRect;\n        if ((iVar1 != var_8h) && ((*(in_ECX + 0x84) & 0x800) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, 0, iVar1 - *0x49be54, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n            (*pcVar2)(&lpRect, 0, var_8h - *0x49be54, var_4h, var_8h);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 579
    },
    "0042ebc7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042ebc7(uint noname_0, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    bool bVar5;\n    int32_t lprcDst;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar1 = (**(*in_ECX + 0x16c))(arg_ch);\n    if (((uVar1 & 0x10000000) != 0) && ((uVar1 & 0xf000) != 0)) {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, arg_ch + 1);\n        iVar4 = var_14h - lprcDst;\n        iVar3 = var_10h - var_18h;\n        bVar5 = arg_ch[7] != 0;\n        if (((var_4h[0x21] & 4U) == 0) || ((var_4h[0x21] & 1U) == 0)) {\n            if ((uVar1 & 0xa000) == 0) {\n                uVar2 = bVar5 | 0x10;\n            }\n            else {\n                uVar2 = bVar5 | 10;\n            }\n        }\n        else {\n            uVar2 = bVar5 | 6;\n        }\n        (**(*var_4h + 0x140))(&var_ch, 0xffffffff, uVar2);\n        if (iVar4 <= var_ch) {\n            var_ch = iVar4;\n        }\n        if (iVar3 <= var_8h) {\n            var_8h = iVar3;\n        }\n        if ((uVar1 & 0xa000) == 0) {\n            if ((uVar1 & 0x5000) != 0) {\n                arg_ch[5] = arg_ch[5] + var_ch;\n                iVar3 = arg_ch[6];\n                if (arg_ch[6] <= var_8h) {\n                    iVar3 = var_8h;\n                }\n                arg_ch[6] = iVar3;\n                if ((uVar1 & 0x1000) == 0) {\n                    if ((uVar1 & 0x4000) != 0) {\n                        lprcDst = var_14h - var_ch;\n                        arg_ch[3] = arg_ch[3] - var_ch;\n                    }\n                }\n                else {\n                    arg_ch[1] = arg_ch[1] + var_ch;\n                }\n            }\n        }\n        else {\n            arg_ch[6] = arg_ch[6] + var_8h;\n            iVar3 = arg_ch[5];\n            if (arg_ch[5] <= var_ch) {\n                iVar3 = var_ch;\n            }\n            arg_ch[5] = iVar3;\n            if ((uVar1 & 0x2000) == 0) {\n                if ((uVar1 & 0x8000) != 0) {\n                    var_18h = var_10h - var_8h;\n                    arg_ch[4] = arg_ch[4] - var_8h;\n                }\n            }\n            else {\n                arg_ch[2] = arg_ch[2] + var_8h;\n            }\n        }\n        var_14h = lprcDst + var_ch;\n        var_10h = var_18h + var_8h;\n        if (*arg_ch != 0) {\n            fcn.00418f77(arg_ch, var_4h[8], &lprcDst);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 867
    },
    "0042f521": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042f521(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint32_t uVar5;\n    \n    uVar1 = fcn.00418009();\n    uVar2 = in_ECX[0x20];\n    uVar5 = 0;\n    if (((uVar2 & 1) == 0) || ((uVar1 & 0x10000000) == 0)) {\n        if (((uVar2 & 2) != 0) && ((uVar1 & 0x10000000) == 0)) {\n            uVar5 = 0x40;\n        }\n    }\n    else {\n        uVar5 = 0x80;\n    }\n    in_ECX[0x20] = uVar2 & 0xfffffffc;\n    if (uVar5 != 0) {\n        fcn.0041822e(0, 0, 0, 0, 0, uVar5 | 0x17);\n    }\n    uVar2 = fcn.00418009();\n    if ((uVar2 & 0x10000000) != 0) {\n        if ((in_ECX[0x24] != 0) && (uVar2 = fcn.00418009(),  (uVar2 & 0x10000000) == 0)) {\n            return 0;\n        }\n        piVar3 = fcn.00405790();\n        if ((piVar3 == NULL) || (iVar4 = (**(*piVar3 + 0x128))(),  iVar4 == 0)) {\n            piVar3 = fcn.0041b98e();\n        }\n        if (piVar3 != NULL) {\n            (**(*in_ECX + 0x144))(piVar3, arg_8h);\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 450
    },
    "0042f736": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.0042f736(uint arg_8h)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint16_t *puVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_194h;\n    uint var_120h;\n    uint var_d8h;\n    uint var_64h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x188);\n    *(unaff_EBP + -0x10) = 0;\n    if ((*(unaff_EBP + 8) == 0) && (*(extraout_ECX + 0x74) != 0)) {\n        puVar4 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(extraout_ECX + 0x74));\n        if (puVar4 == NULL) {\n            fcn.0041638e();\n        }\n        if ((*(puVar4 + 3) & 1) == 0) goto code_r0x0042f96a;\n        fcn.0044775a(1, 0x14000c, 0);\n        *(unaff_EBP + -4) = 0;\n        iVar5 = fcn.00447adf();\n        if (iVar5 != 0) {\n            if (*(*(unaff_EBP + -100) + 0xc) == 0) {\n                if (*(extraout_ECX + 0x70) != 0) {\n                    fcn.0044b044(*(extraout_ECX + 0x70));\n                }\n                fcn.0044b044(*(extraout_ECX + 0x74));\n                *(extraout_ECX + 0x70) = 0;\n                *(extraout_ECX + 0x74) = 0;\n            }\n            else {\n                puVar6 = fcn.00447af2(unaff_EBP + -0x18);\n                pcVar3 = _sym.imp.KERNEL32.dll_lstrcmpA;\n                uVar2 = *puVar6;\n                uVar1 = *puVar4;\n                *(unaff_EBP + -4) = 1;\n                *(unaff_EBP + -0x10) = 1;\n                iVar5 = (*pcVar3)(uVar1 + puVar4, uVar2);\n                if (iVar5 == 0) {\n                    puVar6 = fcn.00447b25(unaff_EBP + -0x14);\n                    uVar2 = *puVar6;\n                    uVar1 = puVar4[1];\n                    *(unaff_EBP + -4) = 2;\n                    *(unaff_EBP + -0x10) = 3;\n                    iVar5 = (*pcVar3)(uVar1 + puVar4, uVar2);\n                    if (iVar5 != 0) goto code_r0x0042f865;\n                    puVar6 = fcn.00447b59(unaff_EBP + -0x1c);\n                    uVar2 = *puVar6;\n                    uVar1 = puVar4[2];\n                    *(unaff_EBP + -0x10) = 7;\n                    iVar5 = (*pcVar3)(uVar1 + puVar4, uVar2);\n                    *(unaff_EBP + 0xb) = 0;\n                    if (iVar5 != 0) goto code_r0x0042f865;\n                }\n                else {\ncode_r0x0042f865:\n                    *(unaff_EBP + 0xb) = 1;\n                }\n                if ((*(unaff_EBP + -0x10) & 4) != 0) {\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffb;\n                    fcn.004010f0();\n                }\n                if ((*(unaff_EBP + -0x10) & 2) != 0) {\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n                    fcn.004010f0();\n                }\n                *(unaff_EBP + -4) = 0;\n                if ((*(unaff_EBP + -0x10) & 1) != 0) {\n                    fcn.004010f0();\n                }\n                if (*(unaff_EBP + 0xb) == '\\0') {\n                    iVar5 = *(*(unaff_EBP + -100) + 8);\n                    if (iVar5 != 0) {\n                        fcn.0044b044(iVar5);\n                    }\n                    iVar5 = *(*(unaff_EBP + -100) + 0xc);\n                    if (iVar5 != 0) {\n                        fcn.0044b044(iVar5);\n                    }\n                }\n                else {\n                    if (*(extraout_ECX + 0x70) != 0) {\n                        fcn.0044b044(*(extraout_ECX + 0x70));\n                    }\n                    fcn.0044b044(*(extraout_ECX + 0x74));\n                    iVar5 = *(unaff_EBP + -100);\n                    *(extraout_ECX + 0x70) = *(iVar5 + 8);\n                    *(extraout_ECX + 0x74) = *(iVar5 + 0xc);\n                }\n            }\n        }\n        *(unaff_EBP + -0xd8) = vtable.CCommonDialog.0;\n    }\n    else {\n        fcn.0044775a(1, 0x14000c, 0);\n        *(unaff_EBP + -4) = 3;\n        fcn.00447adf();\n        if (*(extraout_ECX + 0x70) != 0) {\n            fcn.0044b044(*(extraout_ECX + 0x70));\n        }\n        if (*(extraout_ECX + 0x74) != 0) {\n            fcn.0044b044(*(extraout_ECX + 0x74));\n        }\n        iVar5 = *(unaff_EBP + -0x120);\n        *(extraout_ECX + 0x70) = *(iVar5 + 8);\n        *(extraout_ECX + 0x74) = *(iVar5 + 0xc);\n        *(unaff_EBP + -0x194) = vtable.CCommonDialog.0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041ec27();\ncode_r0x0042f96a:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1590
    },
    "00430973": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430973(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n    }\n    if ((arg_8h[1] == 0x201) || (arg_8h[1] == 0xa1)) {\n        fcn.0044b1eb(*arg_8h);\n    }\n    if ((((*(in_ECX + 0x34) & 4) != 0) && (arg_8h[1] == 0x105)) && (arg_8h[2] == 0x79)) {\n        (**(*in_ECX + 0x160))(1);\n    }\n    if ((*(in_ECX + 0x34) & 2) != 0) {\n        if ((arg_8h[1] == 0x105) && (arg_8h[2] == 0x12)) {\n            (**(*in_ECX + 0x160))((in_ECX[0x35] == 1) + '\\x01');\n        }\n        else if ((arg_8h[1] == 0x106) && (in_ECX[0x35] == 2)) {\n            (**(*in_ECX + 0x160))(1);\n            in_ECX[0x37] = 1;\n        }\n    }\n    if (((*(in_ECX + 0x34) & 1) == 0) &&\n       ((((iVar1 = arg_8h[1],  iVar1 == 0x100 && (arg_8h[2] == 0x1b)) || ((iVar1 == 0x201 || (iVar1 == 0x204)))) ||\n        (((iVar1 == 0xa1 || (iVar1 == 0xa4)) && (arg_8h[2] != 5)))))) {\n        (**(*in_ECX + 0x160))(2);\n    }\n    iVar1 = arg_8h[1];\n    if ((iVar1 == 0xa1) || (iVar1 == 0xa4)) {\n        in_ECX[0x38] = arg_8h[2] == 5;\n    }\n    else if (((iVar1 == 0xa2) || (iVar1 == 0xa5)) || ((iVar1 == 0x202 || (iVar1 == 0x205)))) {\n        in_ECX[0x38] = 0;\n    }\n    iVar1 = fcn.00418d8e(arg_8h);\n    if (iVar1 == 0) {\n        if (in_ECX[0x20] != NULL) {\n            iVar1 = (**(*in_ECX[0x20] + 0x54))(arg_8h);\n            if (iVar1 != 0) goto code_r0x00430ab2;\n        }\n        if ((0xff < arg_8h[1]) && (arg_8h[1] < 0x10a)) {\n            iVar1 = (**(*in_ECX + 0x180))();\n            if (iVar1 != 0) {\n                iVar1 = (*_sym.imp.USER32.dll_TranslateAcceleratorA)(in_ECX[8], iVar1, arg_8h);\n                if (iVar1 != 0) goto code_r0x00430ab2;\n            }\n        }\n        uVar2 = 0;\n    }\n    else {\ncode_r0x00430ab2:\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 807
    },
    "004312f4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004312f4(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    \n    uVar2 = fcn.00418009();\n    iVar3 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        iVar3 = fcn.0041b9cd();\n    }\n    if (iVar3 == 0) {\n        fcn.0041638e();\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if ((arg_8h & 0xc) != 0) {\n        iVar4 = fcn.00418187();\n        if ((((~(arg_8h >> 3) & 1) == 0) || (iVar4 == 0)) || (iVar3 == in_ECX)) {\n            (*pcVar1)(*(iVar3 + 0x20), 0x86, 0, 0);\n        }\n        else {\n            *(in_ECX + 0x3c) = *(in_ECX + 0x3c) | 0x200;\n            (*pcVar1)(*(iVar3 + 0x20), 0x86, 1, 0);\n            *(in_ECX + 0x3c) = *(in_ECX + 0x3c) & 0xfffffdff;\n        }\n    }\n    uVar6 = 5;\n    iVar4 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    while (iVar4 = (*_sym.imp.USER32.dll_GetWindow)(iVar4, uVar6),  iVar4 != 0) {\n        iVar5 = fcn.00430b17(*(iVar3 + 0x20), iVar4);\n        if (iVar5 != 0) {\n            (*pcVar1)(iVar4, 0x36d, arg_8h, 0);\n        }\n        uVar6 = 2;\n    }\n    return;\n}\n",
        "token_count": 478
    },
    "00431876": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431876(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    \n    fcn.0041ae6e();\n    if ((arg_8h == 0) && ((*(in_ECX + 0x34) & 1) == 0)) {\n        (**(*in_ECX + 0x160))(2);\n    }\n    uVar2 = fcn.00418009();\n    piVar3 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        piVar3 = fcn.0041b9cd();\n    }\n    if (piVar3 == NULL) {\n        fcn.0041638e();\n    }\n    if (arg_8h != 0) {\n        arg_ch = in_ECX;\n    }\n    if ((arg_ch == NULL) ||\n       ((piVar3 != arg_ch &&\n        ((piVar4 = fcn.0041b9cd(),  piVar3 != piVar4 ||\n         (iVar5 = (*_sym.imp.USER32.dll_SendMessageA)(arg_ch[8], 0x36d, 0x40, 0),  iVar5 == 0)))))) {\n        bVar1 = false;\n    }\n    else {\n        bVar1 = true;\n    }\n    piVar3[0xf] = piVar3[0xf] & 0xffffffdf;\n    if (bVar1) {\n        piVar3[0xf] = piVar3[0xf] | 0x20;\n    }\n    fcn.004312f4(!bVar1 * 4 + 4);\n    piVar3 = in_ECX[0x2c];\n    if (piVar3 == NULL) {\n        iVar5 = (**(*in_ECX + 0x148))();\n        piVar3 = *(iVar5 + 0xb0);\n        if (piVar3 == NULL) {\n            return;\n        }\n    }\n    if ((arg_8h != 0) && (arg_10h == 0)) {\n        (**(*piVar3 + 0x168))(1, piVar3, piVar3);\n    }\n    (**(*piVar3 + 0x16c))(arg_8h);\n    return;\n}\n",
        "token_count": 559
    },
    "00431ec6": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431ec6(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    int32_t extraout_EDX;\n    uint var_4h;\n    \n    iVar3 = fcn.0041b9cd();\n    iVar5 = iVar3;\n    if (iVar3 == 0) {\n        fcn.0041638e();\n        iVar5 = extraout_EDX;\n    }\n    if ((in_ECX[0x20] != NULL) &&\n       (iVar4 = (**(*in_ECX[0x20] + 0x7c))(arg_8h, arg_ch, arg_10h),  iVar5 = iVar3,  iVar4 != 0)) {\n        return;\n    }\n    if (arg_ch == 0xffff) {\n        in_ECX[0xf] = in_ECX[0xf] & 0xffffffbf;\n        if (*(iVar5 + 0x68) == 0) {\n            in_ECX[0x2a] = 0xe001;\n        }\n        else {\n            in_ECX[0x2a] = 0xe002;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[8], 0x362, in_ECX[0x2a], 0);\n        iVar5 = (**(*in_ECX + 0x16c))();\n        if (iVar5 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar5 + 0x20));\n        }\n        pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n        if (((arg_10h == 0) && ((*(in_ECX + 0x34) & 1) == 0)) &&\n           ((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x79),  -1 < iVar2 &&\n            ((iVar2 = (*pcVar1)(0x12),  -1 < iVar2 && (in_ECX[0x38] == 0)))))) {\n            (**(*in_ECX + 0x160))(2);\n        }\n        goto code_r0x00432031;\n    }\n    if (((in_ECX[0x37] != 0) && (in_ECX[0x37] = 0,  (arg_ch & 0x2000) != 0)) && ((*(in_ECX + 0x34) & 1) == 0)) {\n        (**(*in_ECX + 0x160))(2);\n        iVar5 = iVar3;\n    }\n    if ((arg_8h == 0) || ((arg_ch & 0x810) != 0)) {\n        in_ECX[0x2a] = 0;\n    }\n    else {\n        if (arg_8h - 0xf000 < 0x1f0) {\n            arg_8h = (arg_8h - 0xf000 >> 4) + 0xef00;\n        }\n        else if (0xfeff < arg_8h) {\n            in_ECX[0x2a] = 0xef1f;\n            goto code_r0x0043202d;\n        }\n        in_ECX[0x2a] = arg_8h;\n    }\ncode_r0x0043202d:\n    *(iVar5 + 0x3c) = *(iVar5 + 0x3c) | 0x40;\ncode_r0x00432031:\n    if (in_ECX[0x2a] != in_ECX[0x2b]) {\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n        iVar5 = fcn.0041af14(arg_8h_00);\n        if (iVar5 != 0) {\n            (*_sym.imp.USER32.dll_PostMessageA)(in_ECX[8], 0x36a, 0, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 936
    },
    "0043212c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043212c(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n    }\n    iVar1 = fcn.004320da(arg_8h[1]);\n    if (iVar1 == 0) {\n        arg_8h[7] = 1;\n    }\n    else {\n        iVar1 = *arg_8h;\n        uVar2 = fcn.00418009();\n        (**(iVar1 + 4))(uVar2 >> 0x1c & 1);\n    }\n    return;\n}\n",
        "token_count": 153
    },
    "0043216f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0043216f(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint32_t uVar1;\n    uint arg_10h;\n    \n    arg_8h_00 = fcn.004320da(arg_8h);\n    if (arg_8h_00 != 0) {\n        arg_10h = 0;\n        uVar1 = fcn.00418009();\n        fcn.00431c20(arg_8h_00, ~(uVar1 >> 0x1c) & 1, arg_10h);\n    }\n    return arg_8h_00 != 0;\n}\n",
        "token_count": 149
    },
    "004321ad": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004321ad(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n    }\n    iVar1 = arg_8h[1];\n    if (iVar1 == 0xe701) {\n        uVar4 = 0x14;\n    }\n    else if (iVar1 == 0xe702) {\n        uVar4 = 0x90;\n    }\n    else if (iVar1 == 0xe703) {\n        uVar4 = 0x91;\n    }\n    else {\n        if (iVar1 != 0xe706) {\n            arg_8h[7] = 1;\n            return;\n        }\n        uVar4 = 0x15;\n    }\n    ppcVar2 = *arg_8h;\n    uVar3 = (*_sym.imp.USER32.dll_GetKeyState)(uVar4);\n    (**ppcVar2)(uVar3 & 1);\n    return;\n}\n",
        "token_count": 249
    },
    "004324a9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004324a9(int32_t *param_1)\n\n{\n    if ((param_1[0x39] & 1U) != 0) {\n        param_1[0x39] = param_1[0x39] & 0xfffffffe;\n        (**(*param_1 + 0x17c))(param_1[0x30]);\n    }\n    if ((*(param_1 + 0x39) & 2) != 0) {\n        (**(*param_1 + 0x178))(1);\n    }\n    if ((param_1[0x39] & 8U) != 0) {\n        (**(*param_1 + 0x150))(param_1[0x39] & 4);\n        (*_sym.imp.USER32.dll_UpdateWindow)(param_1[8]);\n    }\n    if (param_1[0x2a] != param_1[0x2b]) {\n        fcn.004320be(param_1[0x2a]);\n    }\n    param_1[0x39] = 0;\n    return;\n}\n",
        "token_count": 248
    },
    "00433db9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433db9(uint32_t arg_8h)\n\n{\n    fcn.00450859();\n    if ((arg_8h & 1) != 0) {\n        fcn.00414b30();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "0043403f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043403f(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *piVar2;\n    \n    iVar1 = arg_8h;\n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        fcn.00424e44(&arg_8h);\n        *in_ECX = arg_8h;\n        fcn.00424e44(&arg_8h);\n        in_ECX[1] = arg_8h;\n        fcn.00424e44(&arg_8h);\n        in_ECX[2] = arg_8h;\n        fcn.00424e44(&arg_8h);\n        in_ECX[3] = arg_8h;\n        fcn.00433c9f(iVar1, in_ECX + 5);\n        if (1 < *(arg_ch + 0x44)) {\n            fcn.00433e19(in_ECX + 5);\n            fcn.00424e44(&arg_8h);\n            in_ECX[7] = arg_8h;\n            fcn.00424e44(&arg_8h);\n            in_ECX[8] = arg_8h;\n            if (arg_8h != 0) {\n                fcn.00424e44(&arg_8h);\n                in_ECX[9] = arg_8h;\n                fcn.00433cb8(iVar1, in_ECX + 10);\n                fcn.00433e71(in_ECX + 10);\n                fcn.00424e44(in_ECX + 0xe);\n                fcn.00433c9f(iVar1, in_ECX + 0xf);\n                fcn.00433e19(in_ECX + 0xf);\n            }\n        }\n        fcn.00424dfc(&arg_ch);\n        fcn.00445b33(arg_ch & 0xffff, 0xffffffff);\n        if (arg_ch == 0) {\n            return;\n        }\n        piVar2 = in_ECX[0x13];\n        if (0 < in_ECX[0x13]) {\n            fcn.0040ea30(in_ECX[0x12], piVar2 << 2);\n            return;\n        }\n    }\n    else {\n        fcn.00424dbe(*in_ECX);\n        fcn.00424dbe(in_ECX[1]);\n        fcn.00424dbe(in_ECX[2]);\n        fcn.00424dbe(in_ECX[3]);\n        fcn.00433c6c(iVar1, in_ECX[5]);\n        if (1 < *(arg_ch + 0x44)) {\n            fcn.00424dbe(in_ECX[7]);\n            fcn.00424dbe(in_ECX[8]);\n            if (in_ECX[8] != 0) {\n                fcn.00424dbe(in_ECX[9]);\n                fcn.00433c86(iVar1, in_ECX + 10);\n                fcn.00424dbe(in_ECX[0xe]);\n                fcn.00433c6c(iVar1, in_ECX[0xf]);\n            }\n        }\n        fcn.00424d7f(*(in_ECX + 0x13));\n        iVar1 = in_ECX[0x13];\n        if (iVar1 == 0) {\n            return;\n        }\n        piVar2 = in_ECX;\n        if (0 < iVar1) goto code_r0x004340f6;\n    }\n    iVar1 = fcn.0041638e();\ncode_r0x004340f6:\n    fcn.00439273(piVar2[0x12], iVar1 << 2);\n    return;\n}\n",
        "token_count": 847
    },
    "00434b64": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00434b64(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    if ((arg_ch & arg_8h) != 0) {\n        return arg_8h;\n    }\n    if (arg_8h == 1) {\n        if ((arg_ch & 2) != 0) {\n            return 2;\n        }\n    }\n    else {\n        if (arg_8h != 2) {\n            return 0;\n        }\n        if ((arg_ch & 1) != 0) {\n            return 1;\n        }\n    }\n    if ((arg_ch & 4) == 0) {\n        return 0;\n    }\n    return 4;\n}\n",
        "token_count": 160
    },
    "00437146": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437146(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t extraout_ECX;\n    uint32_t uVar1;\n    \n    if ((arg_10h != 0) && (arg_ch == 0)) {\n        arg_10h = fcn.0041638e();\n        arg_ch = extraout_ECX;\n    }\n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        for (; arg_10h != 0; arg_10h = arg_10h - uVar1) {\n            uVar1 = 0x1fffffff;\n            if (arg_10h < 0x1fffffff) {\n                uVar1 = arg_10h;\n            }\n            fcn.0040ea30();\n        }\n    }\n    else {\n        for (; arg_10h != 0; arg_10h = arg_10h - uVar1) {\n            uVar1 = 0x1fffffff;\n            if (arg_10h < 0x1fffffff) {\n                uVar1 = arg_10h;\n            }\n            fcn.00439273(arg_ch, uVar1 * 4);\n            arg_ch = arg_ch + uVar1 * 4;\n        }\n    }\n    return;\n}\n",
        "token_count": 303
    },
    "00437343": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00437343(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar2;\n    uint uVar3;\n    uint var_4h;\n    \n    fcn.0045af6e(8);\n    iVar2 = *(unaff_EBP + 8) * 0x14 + extraout_ECX[0x1e];\n    if ((*(iVar2 + 0xc) & 1) == 0) {\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar1 = *(*(iVar2 + 0x10) + -0xc);\n        }\n        else {\n            iVar1 = fcn.00420ff8(*(unaff_EBP + 0xc));\n        }\n        if (iVar1 == 0) goto code_r0x004373e6;\n    }\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.004018d0();\n    }\n    else {\n        fcn.00402830();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) == 0) {\n        *(iVar2 + 0xc) = *(iVar2 + 0xc) | 1;\n    }\n    else {\n        *(iVar2 + 0xc) = *(iVar2 + 0xc) & 0xfffffffe;\n        if ((*(iVar2 + 8) & 0x4000000) == 0) {\n            uVar3 = *(iVar2 + 0x10);\n        }\n        else {\n            uVar3 = 0;\n        }\n        (**(*extraout_ECX + 0x118))(0x401, *(iVar2 + 8) | *(unaff_EBP + 8), uVar3);\n    }\ncode_r0x004373e6:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 489
    },
    "00437438": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: lpRect\n// WARNING: Variable defined which should be unmapped: dy\n\nvoid __cdecl fcn.00437438(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint *puVar7;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint lpRect;\n    uint dy;\n    uint var_28h;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x38);\n    if (*(unaff_EBP + 8) != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(extraout_ECX[8], unaff_EBP + -0x30);\n        (*_sym.imp.USER32.dll_OffsetRect)(unaff_EBP + -0x30, -*(unaff_EBP + -0x30), -*(unaff_EBP + -0x2c));\n        (**(*extraout_ECX + 0x148))(unaff_EBP + -0x30, 1);\n        (**(*extraout_ECX + 0x118))(0x407, 0, unaff_EBP + -0x20);\n        iVar5 = extraout_ECX[0x1d];\n        iVar6 = (*(unaff_EBP + -0x28) - *(unaff_EBP + -0x30)) + *(unaff_EBP + -0x18);\n        iVar3 = extraout_ECX[0x1e];\n        *(unaff_EBP + 8) = 0;\n        if (0 < iVar5) {\n            piVar4 = iVar3 + 4;\n            *(unaff_EBP + -0x14) = iVar5;\n            do {\n                if ((piVar4[1] & 0x8000000U) != 0) {\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + 1;\n                }\n                iVar3 = *piVar4;\n                piVar4 = piVar4 + 5;\n                iVar6 = iVar6 + ((-6 - iVar3) - *(unaff_EBP + -0x18));\n                piVar1 = unaff_EBP + -0x14;\n                *piVar1 = *piVar1 + -1;\n            } while (*piVar1 != 0);\n        }\n        *(unaff_EBP + -0x44) = vtable.CArray_int__int_const__.0;\n        *(unaff_EBP + -0x40) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x3c) = 0;\n        *(unaff_EBP + -4) = 0;\n        fcn.00436fd5(iVar5, 0xffffffff);\n        *(unaff_EBP + -0x10) = 0;\n        iVar5 = *(unaff_EBP + -0x20);\n        if (0 < extraout_ECX[0x1d]) {\n            puVar2 = extraout_ECX[0x1e] + 8;\n            *(unaff_EBP + -0x14) = puVar2;\n            while( true ) {\n                iVar5 = iVar5 + 6 + puVar2[-1];\n                if (((*puVar2 & 0x8000000) != 0) && (0 < iVar6)) {\n                    iVar3 = iVar6 / *(unaff_EBP + 8);\n                    iVar5 = iVar5 + iVar3;\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + -1;\n                    iVar6 = iVar6 - iVar3;\n                }\n                piVar4 = fcn.00433c4b(*(unaff_EBP + -0x10));\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 0x14;\n                *piVar4 = iVar5;\n                iVar5 = iVar5 + *(unaff_EBP + -0x18);\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n                if (extraout_ECX[0x1d] <= *(unaff_EBP + -0x10)) break;\n                puVar2 = *(unaff_EBP + -0x14);\n            }\n        }\n        (**(*extraout_ECX + 0x118))(0x404, extraout_ECX[0x1d], *(unaff_EBP + -0x40));\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00437110();\n    }\n    iVar5 = 0;\n    if ((*(unaff_EBP + 0xc) != 0) && (0 < extraout_ECX[0x1d])) {\n        puVar7 = extraout_ECX[0x1e] + 0x10;\n        do {\n            if ((*(puVar7 + -1) & 1) != 0) {\n                fcn.00437343(iVar5, *puVar7, 1);\n            }\n            puVar7 = puVar7 + 5;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < extraout_ECX[0x1d]);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1462
    },
    "00438cbd": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00438cbd(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        iVar1 = 0;\n    }\n    else {\n        if ((*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0043f8ce(4, *(in_ECX + 0x14));\n        }\n        uVar3 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.00414fcb(arg_8h, arg_ch, *(in_ECX + 0x28), uVar3);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x20);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x24) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if ((uVar3 != 0) && (var_8h == iVar1)) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    if ((*(in_ECX + 0xc) != 0) || (var_4h = *(in_ECX + 0x20),  *(in_ECX + 0x20) < uVar3)) {\n                        var_4h = uVar3;\n                    }\n                    var_8h = *(in_ECX + 0x30);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x24) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x2c) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                    iVar1 = *(in_ECX + 0x30);\n                }\n                uVar4 = *(in_ECX + 0x2c) - iVar1;\n                *(in_ECX + 0x28) = iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.00414fcb(arg_8h, uVar3, iVar1, uVar4);\n                *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 939
    },
    "00438dee": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438dee(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *(param_1 + 0x28);\n    if ((*(param_1 + 0x18) & 1) == 0) {\n        piVar1 = param_1 + 0x30;\n        iVar2 = *piVar1;\n        if (*(param_1 + 8) == 0) {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x38))(iVar2, iVar3 - iVar2);\n            }\n        }\n        else {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x50))(2, iVar3 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x24) + 0x50))(1, *(param_1 + 0x20), piVar1, param_1 + 0x2c);\n        }\n        iVar3 = *piVar1;\n    }\n    else {\n        if (*(param_1 + 0x2c) != iVar3) {\n            iVar3 = iVar3 - *(param_1 + 0x2c);\n            (**(**(param_1 + 0x24) + 0x28))(iVar3, iVar3 >> 0x1f, 1);\n        }\n        iVar3 = *(param_1 + 0x2c);\n    }\n    *(param_1 + 0x28) = iVar3;\n    return;\n}\n",
        "token_count": 375
    },
    "00438e66": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438e66(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_10h;\n    uint32_t uVar2;\n    uint32_t arg_8h_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_8h_01;\n    int32_t in_stack_ffffffe4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar4 = in_ECX;\n    if ((*(in_ECX + 0x18) & 1) != 0) goto code_r0x00438e82;\n    arg_8h_01 = 4;\n    in_stack_ffffffe4 = *(in_ECX + 0x14);\n    do {\n        fcn.0043f8ce(arg_8h_01, in_stack_ffffffe4);\n        iVar4 = in_ECX;\ncode_r0x00438e82:\n        in_ECX = in_stack_ffffffe4;\n        arg_10h = *(iVar4 + 0x28);\n        piVar1 = iVar4 + 0x2c;\n        var_4h = *piVar1 - arg_10h;\n        uVar2 = arg_8h + var_4h;\n        if (*(iVar4 + 8) == 0) {\n            arg_8h_00 = *(iVar4 + 0x30);\n            if (arg_8h_00 < arg_10h) {\n                if (0 < var_4h) {\n                    fcn.004164bd(arg_8h_00, *piVar1 - arg_8h_00, arg_10h, var_4h);\n                    arg_8h_00 = *(iVar4 + 0x30);\n                    *(iVar4 + 0x28) = arg_8h_00;\n                    *piVar1 = arg_8h_00 + var_4h;\n                }\n                if (*(iVar4 + 0xc) == 0) {\n                    arg_8h = *(iVar4 + 0x20);\n                }\n                arg_8h = arg_8h - var_4h;\n                iVar5 = var_4h + arg_8h_00;\n                do {\n                    iVar3 = (**(**(iVar4 + 0x24) + 0x34))(iVar5, arg_8h);\n                    var_4h = var_4h + iVar3;\n                    arg_8h = arg_8h - iVar3;\n                    iVar5 = iVar5 + iVar3;\n                    if ((iVar3 == 0) || (arg_8h == 0)) break;\n                } while (var_4h < uVar2);\n                *(iVar4 + 0x28) = *(iVar4 + 0x30);\n                *piVar1 = *(iVar4 + 0x30) + var_4h;\n            }\n        }\n        else {\n            if (var_4h != 0) {\n                (**(**(iVar4 + 0x24) + 0x28))(-var_4h, -var_4h >> 0x1f, 1);\n            }\n            (**(**(iVar4 + 0x24) + 0x50))(0, *(iVar4 + 0x20), iVar4 + 0x30, piVar1);\n            *(iVar4 + 0x28) = *(iVar4 + 0x30);\n        }\n        if (uVar2 <= *piVar1 - *(iVar4 + 0x28)) {\n            return;\n        }\n        arg_8h_01 = 3;\n        in_stack_ffffffe4 = in_ECX;\n    } while( true );\n}\n",
        "token_count": 844
    },
    "00438f55": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438f55(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(2, *(in_ECX + 0x14));\n    }\n    uVar1 = *(in_ECX + 0x28) + 1;\n    if (*(in_ECX + 0x2c) <= uVar1 && uVar1 != *(in_ECX + 0x2c)) {\n        fcn.00438dee();\n    }\n    **(in_ECX + 0x28) = arg_8h;\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 1;\n    return;\n}\n",
        "token_count": 193
    },
    "00438f90": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438f90(uint arg_8h, uint arg_ch)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(2, *(in_ECX + 0x14));\n    }\n    uVar2 = *(in_ECX + 0x28) + 8;\n    if (*(in_ECX + 0x2c) <= uVar2 && uVar2 != *(in_ECX + 0x2c)) {\n        fcn.00438dee();\n    }\n    puVar1 = *(in_ECX + 0x28);\n    *puVar1 = arg_8h;\n    puVar1[1] = arg_ch;\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 8;\n    return;\n}\n",
        "token_count": 223
    },
    "00438fd4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438fd4(uchar *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(4, *(in_ECX + 0x14));\n    }\n    if (*(in_ECX + 0x2c) < *(in_ECX + 0x28) + 1U) {\n        fcn.00438e66((*(in_ECX + 0x28) - *(in_ECX + 0x2c)) + 1);\n    }\n    *arg_8h = **(in_ECX + 0x28);\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 1;\n    return;\n}\n",
        "token_count": 190
    },
    "00439018": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439018(uint *arg_8h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0043f8ce(4, *(in_ECX + 0x14));\n    }\n    if (*(in_ECX + 0x2c) < *(in_ECX + 0x28) + 8U) {\n        fcn.00438e66((*(in_ECX + 0x28) - *(in_ECX + 0x2c)) + 8);\n    }\n    puVar1 = *(in_ECX + 0x28);\n    *arg_8h = *puVar1;\n    arg_8h[1] = puVar1[1];\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 8;\n    return;\n}\n",
        "token_count": 219
    },
    "00439273": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439273(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t arg_ch_00;\n    int32_t in_ECX;\n    uint32_t arg_14h;\n    int32_t iVar1;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        if ((~*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0043f8ce(2, *(in_ECX + 0x14));\n        }\n        arg_ch_00 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        arg_14h = arg_ch;\n        if (arg_ch_00 <= arg_ch) {\n            arg_14h = arg_ch_00;\n        }\n        fcn.00414fcb(*(in_ECX + 0x28), arg_ch_00, arg_8h, arg_14h);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_14h;\n        arg_ch = arg_ch - arg_14h;\n        if (arg_ch != 0) {\n            fcn.00438dee();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x20);\n            (**(**(in_ECX + 0x24) + 0x38))(arg_8h + arg_14h, iVar1);\n            arg_ch = arg_ch - iVar1;\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x24) + 0x50))(1, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n            }\n            if (arg_ch < *(in_ECX + 0x20)) goto code_r0x0043931a;\n            do {\n                fcn.0041638e();\ncode_r0x0043931a:\n            } while (*(in_ECX + 0x28) != *(in_ECX + 0x30));\n            fcn.00414fcb(*(in_ECX + 0x28), arg_ch, arg_8h + arg_14h + iVar1, arg_ch);\n            *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_ch;\n        }\n    }\n    return;\n}\n",
        "token_count": 572
    },
    "0043941a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0043941a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00401e60();\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 == NULL) {\n        fcn.0041638e();\n    }\n    uVar2 = (**(*piVar1 + 0x18))(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 1;\n    fcn.00407a00(uVar2);\n    *(unaff_EBP + -4) = 0;\n    fcn.004010f0();\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[4] = 0xffffffff;\n    extraout_ECX[6] = uVar2;\n    extraout_ECX[0x10] = (-((~uVar2 & 1) != 0) & 0xffffffd0) + 0x40;\n    uVar2 = *(unaff_EBP + 0x14);\n    extraout_ECX[1] = 1;\n    extraout_ECX[7] = 1;\n    extraout_ECX[9] = piVar1;\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[0x11] = 0x89;\n    extraout_ECX[0xc] = uVar2;\n    extraout_ECX[2] = 0;\n    uVar3 = (**(*piVar1 + 0x50))(3, 0, 0, 0);\n    iVar5 = *(unaff_EBP + 0x10);\n    extraout_ECX[3] = uVar3 & 2;\n    if (iVar5 < 0x80) {\n        extraout_ECX[8] = 0x80;\n        extraout_ECX[0xc] = 0;\n    }\n    else {\n        extraout_ECX[8] = iVar5;\n    }\n    iVar5 = extraout_ECX[8];\n    if (extraout_ECX[0xc] == 0) {\n        uVar3 = (**(*extraout_ECX[9] + 0x50))(3, 0, 0, 0);\n        extraout_ECX[2] = uVar3 & 1;\n        if ((uVar3 & 1) == 0) {\n            uVar2 = fcn.00414af6(extraout_ECX[8]);\n            extraout_ECX[0xc] = uVar2;\n            extraout_ECX[7] = 0;\n        }\n        else {\n            iVar5 = 0;\n        }\n    }\n    iVar5 = extraout_ECX[0xc] + iVar5;\n    extraout_ECX[0xb] = iVar5;\n    iVar4 = extraout_ECX[0xc];\n    if ((*(extraout_ECX + 6) & 1) != 0) {\n        iVar4 = iVar5;\n    }\n    extraout_ECX[10] = iVar4;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 868
    },
    "00440be4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.00440be4(void)\n\n{\n    int32_t *piVar1;\n    int64_t iVar2;\n    uint32_t uVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *arg_8h;\n    int32_t *extraout_ECX;\n    uint uVar7;\n    uint32_t uVar8;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    char *pcVar9;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x18);\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    uVar8 = 1;\n    if (extraout_ECX[0x1e] != 1) {\ncode_r0x00441144:\n        fcn.0045b013();\n        return;\n    }\n    arg_8h_00 = 0;\n    arg_8h = extraout_ECX;\n    if (*(extraout_ECX[0x1d] + 0x30) == 0) goto code_r0x00440c49;\n    fcn.00416242(*(extraout_ECX[0x1d] + 0x30));\n    piVar1 = extraout_ECX[0x20];\n    iVar5 = *piVar1;\n    *(unaff_EBP + -4) = 0;\n    iVar5 = (**(iVar5 + 0x44))(piVar1, *(unaff_EBP + -0x1c));\n    if (-1 < iVar5) goto code_r0x00440c3a;\ncode_r0x00440c35:\n    fcn.0041638e();\ncode_r0x00440c3a:\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004010f0();\ncode_r0x00440c49:\n    if (*(arg_8h[0x1d] + 0x3c) != arg_8h_00) {\n        fcn.00416242(*(arg_8h[0x1d] + 0x3c));\n        piVar1 = arg_8h[0x20];\n        iVar5 = *piVar1;\n        *(unaff_EBP + -4) = uVar8;\n        iVar5 = (**(iVar5 + 0x58))(piVar1, *(unaff_EBP + -0x1c));\n        if (arg_8h_00 <= iVar5 == arg_8h_00) goto code_r0x00440c35;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004010f0();\n    }\n    if (*(arg_8h[0x1d] + 0xc) != arg_8h_00) {\n        pcVar9 = *(arg_8h[0x1d] + 0xc);\n        uVar8 = 0;\n        if (*pcVar9 != '\\0') {\n            do {\n                iVar5 = fcn.0045aeb0(pcVar9);\n                iVar6 = fcn.0045aeb0(pcVar9 + iVar5 + 1);\n                pcVar9 = pcVar9 + iVar5 + 1 + iVar6 + 1;\n                uVar8 = uVar8 + 1;\n            } while (*pcVar9 != '\\0');\n            *(unaff_EBP + -0x1c) = uVar8;\n            if (uVar8 != 0) {\n                arg_8h_00 = fcn.00414af6(-(uVar8 * 8 >> 0x20 != 0) | uVar8 * 8);\n                if (arg_8h_00 != 0) goto code_r0x00440cec;\n                do {\n                    fcn.00416356();\ncode_r0x00440cec:\n                    iVar5 = arg_8h[0x1d];\n                    *(unaff_EBP + -0x18) = 0;\n                    iVar5 = *(iVar5 + 0xc);\n                    if (*(unaff_EBP + -0x1c) == 0) goto code_r0x00440de1;\n                    while( true ) {\n                        fcn.004156cc();\n                        *(unaff_EBP + -4) = 2;\n                        iVar6 = fcn.0045aeb0(iVar5);\n                        iVar2 = (iVar6 + 1U) * 2;\n                        *(unaff_EBP + -0x20) = iVar6 + 1U;\n                        arg_8h = fcn.00414af6(-(iVar2 >> 0x20 != 0) | iVar2);\n                        if (arg_8h == NULL) break;\n                        fcn.00415c7c(iVar5);\n                        iVar6 = *(*(unaff_EBP + -0x14) + -0xc);\n                        fcn.0045850c(arg_8h, iVar6 * 2 + 2, *(unaff_EBP + -0x14), iVar6 * 2 + 2);\n                        iVar5 = iVar5 + *(unaff_EBP + -0x20);\n                        *(arg_8h_00 + *(unaff_EBP + -0x18) * 8) = arg_8h;\n                        iVar6 = fcn.0045aeb0(iVar5);\n                        arg_8h = iVar6 + 1;\n                        iVar6 = fcn.00414af6(-(ZEXT48(arg_8h) * 2 >> 0x20 != 0) | ZEXT48(arg_8h) * 2);\n                        *(unaff_EBP + -0x20) = iVar6;\n                        if (iVar6 == 0) break;\n                        fcn.00415c7c(iVar5);\n                        iVar6 = *(*(unaff_EBP + -0x14) + -0xc);\n                        fcn.0045850c(*(unaff_EBP + -0x20), iVar6 * 2 + 2, *(unaff_EBP + -0x14), iVar6 * 2 + 2);\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        *(arg_8h_00 + 4 + *(unaff_EBP + -0x18) * 8) = *(unaff_EBP + -0x20);\n                        iVar5 = iVar5 + arg_8h;\n                        *(unaff_EBP + -0x18) = *(unaff_EBP + -0x18) + 1;\n                        fcn.004010f0();\n                        if (*(unaff_EBP + -0x1c) <= *(unaff_EBP + -0x18)) {\n                            arg_8h = *(unaff_EBP + -0x24);\n                            goto code_r0x00440de1;\n                        }\n                    }\n                } while( true );\n            }\n        }\n    }\n    goto code_r0x00440e55;\ncode_r0x00440de1:\n    iVar5 = (**(*arg_8h[0x20] + 0x10))(arg_8h[0x20], *(unaff_EBP + -0x1c), arg_8h_00);\n    uVar8 = 0;\n    if (iVar5 < 0) goto code_r0x00440c35;\n    if (*(unaff_EBP + -0x1c) != 0) {\n        do {\n            fcn.00414b30(*(arg_8h_00 + uVar8 * 8));\n            fcn.00414b30(*(arg_8h_00 + 4 + uVar8 * 8));\n            uVar8 = uVar8 + 1;\n        } while (uVar8 < *(unaff_EBP + -0x1c));\n    }\n    fcn.00414b30(arg_8h_00);\n    uVar7 = 1;\n    if (1 < *(arg_8h[0x1d] + 0x18)) {\n        uVar7 = *(arg_8h[0x1d] + 0x18);\n    }\n    iVar5 = (**(*arg_8h[0x20] + 0x14))(arg_8h[0x20], uVar7);\n    if (iVar5 < 0) goto code_r0x00440c35;\ncode_r0x00440e55:\n    if ((*(arg_8h[0x1d] + 0x1c) == 0) && (*(arg_8h[0x1d] + 0x2c) == 0)) goto code_r0x00440fe7;\n    fcn.004156cc();\n    iVar5 = arg_8h[0x1d];\n    *(unaff_EBP + -4) = 3;\n    if (*(iVar5 + 0x1c) == 0) {\n        uVar8 = *(unaff_EBP + -0x14);\n    }\n    else {\n        fcn.00416242(*(iVar5 + 0x1c));\n        *(unaff_EBP + -4) = 4;\n        fcn.0041f854(unaff_EBP + -0x1c);\n        uVar7 = fcn.00440848();\n        (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(uVar7);\n        fcn.00440740(0xffffffff);\n        uVar8 = *(unaff_EBP + -0x14);\n        arg_8h_00 = *(uVar8 - 0xc);\n        iVar4 = fcn.0044071a(arg_8h_00);\n        if (iVar4 == 0x5c) {\n            arg_8h_00 = arg_8h_00 + 1;\n        }\n        iVar5 = (**(*arg_8h[0x20] + 0x3c))(arg_8h[0x20], *(unaff_EBP + -0x1c) + arg_8h_00 * 2);\n        if (iVar5 < 0) goto code_r0x00440c35;\n        *(unaff_EBP + -4) = 3;\n        fcn.004010f0();\n    }\n    arg_8h_00 = 0;\n    if (*(arg_8h[0x1d] + 0x2c) == 0) {\ncode_r0x00440f22:\n        if (*(uVar8 - 0xc) != 0) goto code_r0x00440f2b;\n    }\n    else {\n        if (*(uVar8 - 0xc) == 0) {\n            fcn.00415c7c(*(arg_8h[0x1d] + 0x2c));\n            uVar8 = *(unaff_EBP + -0x14);\n            goto code_r0x00440f22;\n        }\ncode_r0x00440f2b:\n        uVar3 = *0x49bde4 & 1;\n        *(unaff_EBP + -0x18) = 0;\n        if (uVar3 == 0) {\n            *0x49bde4 = *0x49bde4 | 1;\n            *(unaff_EBP + -4) = 5;\n            *0x49bde0 = fcn.004197f3(\"Shell32.dll\");\n            *(unaff_EBP + -4) = 3;\n        }\n        if (*0x49bde0 == 0) goto code_r0x00440c35;\n        if ((*0x49bde4 & 2) == 0) {\n            *0x49bde4 = *0x49bde4 | 2;\n            *0x49bddc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x49bde0, \"SHCreateItemFromParsingName\");\n        }\n        if (*0x49bddc == NULL) goto code_r0x00440c35;\n        iVar5 = (**0x49bddc)(uVar8, 0, 0x47f4bc, unaff_EBP + -0x18);\n        if (-1 < iVar5) {\n            iVar5 = (**(*arg_8h[0x20] + 0x30))(arg_8h[0x20], *(unaff_EBP + -0x18));\n            if (iVar5 < 0) goto code_r0x00440c35;\n            (**(**(unaff_EBP + -0x18) + 8))(*(unaff_EBP + -0x18));\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004010f0();\ncode_r0x00440fe7:\n    arg_8h_00 = 0;\n    piVar1 = arg_8h[0x20];\n    *(unaff_EBP + -0x10) = 0;\n    iVar5 = (**(*piVar1 + 0x28))(piVar1, unaff_EBP + -0x10);\n    if (iVar5 < 0) goto code_r0x00440c35;\n    iVar5 = arg_8h[0x1d];\n    if ((*(iVar5 + 0x34) & 0x200) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffdff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x200;\n    }\n    if ((*(iVar5 + 0x34) & 0x2000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffffdfff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x2000;\n    }\n    if ((*(iVar5 + 0x34) & 0x2000000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfdffffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x2000000;\n    }\n    if ((*(iVar5 + 0x34) & 0x1000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffffefff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x1000;\n    }\n    if ((*(iVar5 + 0x34) & 0x10000000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xefffffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x10000000;\n    }\n    if ((*(iVar5 + 0x34) & 8) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffff7;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 8;\n    }\n    if ((*(iVar5 + 0x34) & 0x100000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffefffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x100000;\n    }\n    if ((*(iVar5 + 0x34) & 0x8000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffff7fff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x8000;\n    }\n    if ((*(iVar5 + 0x34) & 0x10000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffeffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x10000;\n    }\n    if ((*(iVar5 + 0x34) & 0x100) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffeff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x100;\n    }\n    if ((*(iVar5 + 0x34) & 2) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 2;\n    }\n    if ((*(iVar5 + 0x34) & 0x800) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffff7ff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x800;\n    }\n    if ((*(iVar5 + 0x34) & 0x4000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffffbfff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x4000;\n    }\n    if ((*(iVar5 + 0x54) & 1) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffbffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x40000;\n    }\n    arg_8h = arg_8h[0x20];\n    iVar5 = (**(*arg_8h + 0x24))(arg_8h, *(unaff_EBP + -0x10));\n    if (-1 < iVar5) goto code_r0x00441144;\n    goto code_r0x00440c35;\n}\n",
        "token_count": 4429
    },
    "00445f78": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00445f78(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = *(*arg_8h + 0x74);\n    if (*(iVar1 + 0x1e) <= *(iVar1 + 0x1c) && *(iVar1 + 0x1c) != *(iVar1 + 0x1e)) {\n        *(iVar1 + 0x1e) = *(iVar1 + 0x1c);\n    }\n    iVar1 = fcn.0042052a();\n    iVar1 = *(iVar1 + 4);\n    if (((arg_8h[2] == 0) && (arg_8h[3] == 0)) && ((arg_8h[1] == 0 || ((*(arg_8h + 0xf) & 2) != 0)))) {\n        *(*(*arg_8h + 0x74) + 0x18) = *(*(*arg_8h + 0x74) + 0x1c);\n        *(*(*arg_8h + 0x74) + 0x1a) = *(*(*arg_8h + 0x74) + 0x1e);\n        iVar2 = fcn.0042f972(*arg_8h);\n        if (iVar2 != 1) {\n            return 0;\n        }\n    }\n    else {\n        if (*(*(*arg_8h + 0x74) + 0x10) == 0) {\n            iVar2 = fcn.0042fa29(*(*arg_8h + 0x74));\n            if ((iVar2 == 0) &&\n               (((arg_8h[1] == 0 || ((*(arg_8h + 0xf) & 1) != 0)) && (iVar2 = fcn.0042f972(*arg_8h),  iVar2 != 1)))) {\n                return 0;\n            }\n            if ((*(*(*arg_8h + 0x74) + 0x10) == 0) && (iVar2 = fcn.0044786e(),  iVar2 == 0)) {\n                return 0;\n            }\n        }\n        *(*(*arg_8h + 0x74) + 0x18) = *(*(*arg_8h + 0x74) + 0x1c);\n        *(*(*arg_8h + 0x74) + 0x1a) = *(*(*arg_8h + 0x74) + 0x1e);\n    }\n    if (*(*(*arg_8h + 0x74) + 0x10) == 0) {\n        return 0;\n    }\n    arg_8h[6] = *(iVar1 + 0x94);\n    iVar1 = fcn.004024c0(0xf044);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    return 1;\n}\n",
        "token_count": 676
    },
    "00447b8d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447b8d(uint32_t arg_8h)\n\n{\n    fcn.00445e4c();\n    if ((arg_8h & 1) != 0) {\n        fcn.00414b30();\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "004495bd": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004495bd(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint uVar1;\n    uint32_t arg_8h_00;\n    \n    if ((((arg_ch >> 0x1f & 1U) == 0) || ((arg_ch & 0x1fff0000) != 0x30000)) ||\n       (arg_8h_00 = arg_ch & 0xffff,  0xff < arg_8h_00)) {\n        if ((arg_ch == 0x80030100) || (((-0x7ffcff00 < arg_ch && (-0x7ffcfefb < arg_ch)) && (arg_ch == 0x80030106)))) {\n            uVar1 = 0xb;\n        }\n        else {\n            uVar1 = 1;\n        }\n    }\n    else {\n        uVar1 = fcn.004384be(arg_8h_00);\n        arg_ch = arg_8h_00;\n    }\n    *(arg_8h + 8) = uVar1;\n    *(arg_8h + 0xc) = arg_ch;\n    return;\n}\n",
        "token_count": 258
    },
    "0044a3e0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044a3e0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    uint8_t *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint hMem;\n    uint lpCriticalSection;\n    \n    iVar1 = param_1 + 0x1c;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(iVar1);\n    iVar7 = *(param_1 + 4);\n    iVar8 = *(param_1 + 8);\n    if ((iVar7 <= iVar8) || ((*(*(param_1 + 0x10) + iVar8 * 8) & 1) != 0)) {\n        iVar8 = 1;\n        if (1 < iVar7) {\n            puVar3 = *(param_1 + 0x10);\n            do {\n                puVar3 = puVar3 + 8;\n                if ((*puVar3 & 1) == 0) break;\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < iVar7);\n            if (iVar8 < iVar7) goto code_r0x0044a4ce;\n        }\n        iVar7 = iVar7 + 0x20;\n        if (*(param_1 + 0x10) == 0) {\n            uVar4 = fcn.0041650d(iVar7, 8);\n            iVar5 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(2, uVar4);\n        }\n        else {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar4);\n            uVar9 = 0x2002;\n            uVar6 = fcn.0041650d(iVar7, 8);\n            iVar5 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)(uVar4, uVar6, uVar9);\n        }\n        if (iVar5 == 0) {\n            param_1 = *(param_1 + 0x10);\n            if (param_1 != 0) {\n                uVar4 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1);\n                (*_sym.imp.KERNEL32.dll_GlobalLock)(uVar4);\n            }\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(iVar1);\n            iVar5 = fcn.00416356();\n        }\n        iVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar5);\n        fcn.00458b20(iVar5 + *(param_1 + 4) * 8, 0, (iVar7 - *(param_1 + 4)) * 8);\n        *(param_1 + 4) = iVar7;\n        *(param_1 + 0x10) = iVar5;\n    }\ncode_r0x0044a4ce:\n    if (*(param_1 + 0xc) <= iVar8) {\n        *(param_1 + 0xc) = iVar8 + 1;\n    }\n    puVar2 = *(param_1 + 0x10) + iVar8 * 8;\n    *puVar2 = *puVar2 | 1;\n    *(param_1 + 8) = iVar8 + 1;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(iVar1);\n    return iVar8;\n}\n",
        "token_count": 781
    },
    "0044a8fe": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044a8fe(uint32_t arg_8h)\n\n{\n    fcn.0044a8a5();\n    if ((arg_8h & 1) != 0) {\n        fcn.00414b30();\n    }\n    return;\n}\n",
        "token_count": 63
    },
    "0044b3b2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.0044b3b2(void)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint lpvBits;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0044b9be(8);\n    if (*0x49bed0 == 0) {\n        iVar2 = 0;\n        do {\n            uVar1 = iVar2;\n            iVar2 = iVar2 + 1;\n            *(&stack0xffffffe6 + iVar2 * 2) = 0x5555 << (uVar1 & 1);\n        } while (iVar2 < 8);\n        iVar2 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, &lpvBits);\n        if (iVar2 != 0) {\n            *0x49bed0 = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar2);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar2);\n        }\n    }\n    if (*0x49bed4 == '\\0') {\n        iVar2 = fcn.0045a9dc(0x44b267);\n        *0x49bed4 = '\\x01' - (iVar2 != 0);\n    }\n    fcn.0044ba30(8);\n    iVar2 = *0x49bed0;\n    fcn.0041776c();\n    fcn.0045843c(iVar2);\n    return;\n}\n",
        "token_count": 342
    },
    "0044f472": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044f472(uint lpProcName, uint arg_ch)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c0f4 & 1) == 0) {\n        *0x49c0f4 = *0x49c0f4 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c0f0 = fcn.004197f3(\"UxTheme.dll\");\n    }\n    if (*0x49c0f0 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x49c0f0, *(unaff_EBP + 8));\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 205
    },
    "0044f4c6": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0044f4c6(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c0fc & 1) == 0) {\n        *0x49c0fc = *0x49c0fc | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c0f8 = fcn.0044f472(\"IsAppThemed\", method.CStatic.virtual_28);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c0f8)();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 181
    },
    "0044f50c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044f50c(uint arg_8h, uint arg_ch)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c104 & 1) == 0) {\n        *0x49c104 = *0x49c104 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c100 = fcn.0044f472(\"OpenThemeData\", method.CStatic.virtual_28);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c100)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 201
    },
    "0044f558": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044f558(uint arg_8h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c10c & 1) == 0) {\n        *0x49c10c = *0x49c10c | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c108 = fcn.0044f472(\"CloseThemeData\", 0x44f469);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c108)(*(unaff_EBP + 8));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 189
    },
    "0044f5a1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044f5a1(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c114 & 1) == 0) {\n        *0x49c114 = *0x49c114 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c110 = fcn.0044f472(\"DrawThemeBackground\", 0x44f469);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c110)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18), \n                 *(unaff_EBP + 0x1c));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 273
    },
    "0044f5f9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0044f5f9(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c11c & 1) == 0) {\n        *0x49c11c = *0x49c11c | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c118 = fcn.0044f472(\"GetThemePartSize\", 0x44f469);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c118)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18), \n                 *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 294
    },
    "0044f654": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044f654(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c124 & 1) == 0) {\n        *0x49c124 = *0x49c124 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c120 = fcn.0044f472(\"IsThemeBackgroundPartiallyTransparent\", method.CStatic.virtual_28);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c120)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 220
    },
    "0044f6a3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044f6a3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if ((*0x49c12c & 1) == 0) {\n        *0x49c12c = *0x49c12c | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x49c128 = fcn.0044f472(\"DrawThemeParentBackground\", 0x44f469);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x49c128)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 223
    },
    "00450b9d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00450b9d(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    var_4h = 0;\n    uVar1 = fcn.00418009();\n    if (((uVar1 & 0x100) != 0) && ((arg_8h & 0x40) != 0)) {\n        var_4h = 1;\n    }\n    if ((arg_8h & 3) != 0) {\n        fcn.0041822e(0, 0, 0, 0, 0, (-((arg_8h & 1) != 0) & 0xffffffc0) + 0x80 | 0x17);\n    }\n    if ((arg_8h & 0x30) != 0) {\n        fcn.004181a2(arg_8h >> 4 & 1);\n    }\n    if ((arg_8h & 0xc) != 0) {\n        uVar1 = fcn.00418009();\n        if ((uVar1 & 0x100) != 0) {\n            fcn.0041803d(0x100, 0, 0);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0x86, arg_8h >> 2 & 1, 0);\n            fcn.0041803d(0, 0x100, 0);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 359
    },
    "0045253e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045253e(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((arg_8h & 2) == 0) {\n        fcn.004010f0();\n        if ((arg_8h & 1) != 0) {\n            fcn.00414b30();\n        }\n    }\n    else {\n        fcn.004584a9(in_ECX, 4, *(in_ECX + -4), fcn.00401e90);\n        if ((arg_8h & 1) != 0) {\n            fcn.00414b30(in_ECX + -4);\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "00452e0b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00452e0b(uint arg_8h, uint hKey, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    bool bVar5;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.ADVAPI32.dll_RegSetValueA;\n    uVar1 = arg_10h & 1;\n    if ((uVar1 == 0) ||\n       ((iVar3 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)(arg_8h, \"Insertable\", 1, 0x476744, 0),  iVar3 == 0 &&\n        (iVar3 = (*pcVar2)(hKey, \"Insertable\", 1, 0x476744, 0),  iVar3 == 0)))) {\n        pcVar4 = NULL;\n        if ((arg_10h & 2) != 0) {\n            pcVar4 = \"Apartment\";\n        }\n        if ((arg_10h & 4) != 0) {\n            pcVar4 = \"Free\";\n        }\n        if ((arg_10h & 6) == 6) {\n            pcVar4 = \"Both\";\n        }\n        if (pcVar4 != NULL) {\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(hKey, \"InprocServer32\", 0, 0x20006, &arg_10h);\n            bVar5 = iVar3 == 0;\n            if (bVar5) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar4);\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(arg_10h, \"ThreadingModel\", 0, 1, pcVar4, iVar3 + 1);\n                bVar5 = iVar3 == 0;\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(arg_10h);\n            }\n            else {\n                iVar3 = fcn.0042052a();\n                if (*(iVar3 + 0x14) == '\\0') {\n                    bVar5 = true;\n                }\n            }\n            if (bVar5 == false) goto code_r0x00452e4f;\n        }\n        bVar5 = true;\n    }\n    else {\n        bVar5 = false;\ncode_r0x00452e4f:\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegDeleteValueA;\n        if (uVar1 != 0) {\n            (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(hKey, \"Insertable\");\n            (*pcVar2)(arg_8h, \"Insertable\");\n        }\n    }\n    return bVar5;\n}\n",
        "token_count": 622
    },
    "00456f06": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __cdecl\nfcn.00456f06(int32_t *lpSize, int32_t *arg_ch, char *arg_10h, uint32_t *arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            uint32_t *arg_20h, uint arg_24h, char *arg_28h, int32_t *arg_2ch, int32_t *arg_30h)\n\n{\n    char cVar1;\n    char *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    char *arg_8h;\n    int32_t in_ECX;\n    uint32_t uVar6;\n    int32_t *piVar7;\n    uint var_b0h;\n    int32_t var_9ch;\n    int32_t var_90h;\n    uint var_78h;\n    int32_t var_64h;\n    int32_t var_58h;\n    uint var_49h;\n    int32_t var_40h;\n    int32_t lpPoint;\n    uint Y;\n    int32_t var_30h;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    char *cbString;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    int32_t lpBuffer;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    pcVar3 = _sym.imp.GDI32.dll_GetTextMetricsA;\n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(in_ECX + 8), &var_78h);\n    (*pcVar3)(*(in_ECX + 4), &var_b0h);\n    (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)(*(in_ECX + 8), 0x48294c, 1, lpSize);\n    var_28h = (*_sym.imp.GDI32.dll_GetTextAlign)(*(in_ECX + 8));\n    var_24h = var_28h & 1;\n    if (var_24h != 0) {\n        (*_sym.imp.GDI32.dll_GetCurrentPositionEx)(*(in_ECX + 4), &lpPoint);\n        *arg_ch = lpPoint;\n    }\n    iVar4 = *arg_ch;\n    var_ch = 0;\n    var_14h = 0;\n    cbString = arg_10h;\n    var_20h = iVar4;\n    if (arg_18h != 0) {\n        if (arg_1ch == 1) {\n            var_14h = *arg_20h;\n        }\n        else {\n            var_14h = (*_sym.imp.USER32.dll_GetTabbedTextExtentA)(*(in_ECX + 8), 0x480870, 1, 0, 0);\n            var_14h = var_14h & 0xffff;\n        }\n    }\n    var_8h = 0;\n    piVar7 = arg_2ch;\n    if (*arg_14h != 0) {\n        var_4h = 1;\n        arg_8h = arg_10h;\n        arg_10h = iVar4;\n        do {\n            cVar1 = *arg_8h;\n            var_18h = cVar1 == var_49h;\n            if ((var_18h == 0) && ((arg_18h == 0 || (cVar1 != '\\t')))) {\n                iVar4 = fcn.0045cede(cVar1);\n                if ((iVar4 == 0) || (*arg_14h <= var_4h)) {\n                    (*_sym.imp.GDI32.dll_GetCharWidthA)(*(in_ECX + 4), *arg_8h, *arg_8h, &lpBuffer);\n                    iVar5 = (*_sym.imp.GDI32.dll_GetCharWidthA)(*(in_ECX + 8), *arg_8h, *arg_8h, piVar7);\n                    iVar4 = var_64h;\n                    if (iVar5 == 0) goto code_r0x0045707f;\n                }\n                else {\n                    iVar4 = (*_sym.imp.GDI32.dll_GetTextExtentPointA)(*(in_ECX + 4), arg_8h, 2, &var_30h);\n                    lpBuffer = var_9ch;\n                    if (iVar4 != 0) {\n                        lpBuffer = var_30h / 2;\n                    }\n                    iVar5 = (*_sym.imp.GDI32.dll_GetTextExtentPointA)(*(in_ECX + 8), arg_8h, 2, &var_30h);\n                    iVar4 = var_64h;\n                    if (iVar5 != 0) {\n                        iVar4 = var_30h / 2;\n                    }\ncode_r0x0045707f:\n                    *piVar7 = iVar4;\n                }\n                *piVar7 = *piVar7 - var_58h;\n                iVar4 = *piVar7;\n                lpBuffer = lpBuffer - var_90h;\n                arg_10h = arg_10h + iVar4;\n                if (piVar7 != arg_2ch) {\n                    iVar5 = (iVar4 - lpBuffer) / 2;\n                    piVar7[-1] = piVar7[-1] + iVar5;\n                    *piVar7 = iVar4 - iVar5;\n                }\n                pcVar2 = arg_28h + 1;\n                *arg_28h = *arg_8h;\n                iVar4 = fcn.0045cede(*arg_8h);\n                if ((iVar4 != 0) && (var_4h < *arg_14h)) {\n                    *pcVar2 = arg_8h[1];\n                    iVar4 = *piVar7;\n                    arg_10h = arg_10h + iVar4;\n                    piVar7 = piVar7 + 1;\n                    var_8h = var_8h + 1;\n                    var_4h = var_4h + 1;\n                    *piVar7 = iVar4;\n                    pcVar2 = arg_28h + 2;\n                }\n                arg_28h = pcVar2;\n                piVar7 = piVar7 + 1;\n            }\n            else {\n                (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                          (*(in_ECX + 8), cbString, arg_8h + (var_18h - cbString), &var_40h);\n                iVar4 = (var_40h - var_58h) + var_20h;\n                if (var_18h == 0) {\n                    iVar4 = fcn.00456a43(iVar4, arg_1ch, arg_20h, arg_24h, var_14h);\n                }\n                if (piVar7 == arg_2ch) {\n                    var_ch = var_ch + (iVar4 - arg_10h);\n                }\n                else {\n                    piVar7[-1] = piVar7[-1] + (iVar4 - arg_10h);\n                }\n                cbString = arg_8h + 1;\n                arg_10h = iVar4;\n                var_20h = iVar4;\n            }\n            arg_8h = fcn.0045ce2c(arg_8h);\n            var_8h = var_8h + 1;\n            var_4h = var_4h + 1;\n            iVar4 = arg_10h;\n        } while (var_8h < *arg_14h);\n    }\n    *lpSize = iVar4 - *arg_ch;\n    *arg_30h = 0;\n    uVar6 = var_28h & 6;\n    iVar4 = var_ch;\n    if (uVar6 != 0) {\n        if (uVar6 != 6) {\n            if (uVar6 == 2) {\n                *arg_30h = var_ch;\n            }\n            goto code_r0x004571a0;\n        }\n        iVar4 = var_ch / 2;\n    }\n    *arg_ch = *arg_ch + iVar4;\ncode_r0x004571a0:\n    if (var_24h != 0) {\n        (*_sym.imp.GDI32.dll_MoveToEx)(*(in_ECX + 4), *arg_ch, Y, 0);\n    }\n    *arg_14h = piVar7 - arg_2ch >> 2;\n    return lpSize;\n}\n",
        "token_count": 1907
    },
    "00469110": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00469110(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0045b538(0x492ad0, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0045b3c2();\n        *puVar2 = 0;\n        puVar2 = fcn.0045b3af();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x49dca8)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x49dcc0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0046c695(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0045b3af();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0045b3c2();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.004689dd(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.004691e2(0x492ad0);\n                goto code_r0x004691dc;\n            }\n        }\n        puVar2 = fcn.0045b3c2();\n        *puVar2 = 0;\n        puVar2 = fcn.0045b3af();\n        *puVar2 = 9;\n        fcn.0045f989(0, 0, 0, 0, 0);\n    }\ncode_r0x004691dc:\n    fcn.0045b57d();\n    return;\n}\n",
        "token_count": 639
    },
    "0046966a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0046966a(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0045f093();\n    var_4h = 0;\n    if (*0x49cc10 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"USER32.DLL\");\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x484fc0);\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x49cc10 = fcn.0045f021(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, 0x484fb0);\n        *0x49cc14 = fcn.0045f021(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x484f9c);\n        *0x49cc18 = fcn.0045f021(uVar3);\n        uVar3 = (*pcVar4)(iVar2, \"GetUserObjectInformationA\");\n        *0x49cc20 = fcn.0045f021(uVar3);\n        if (*0x49cc20 != 0) {\n            uVar3 = (*pcVar4)(iVar2, \"GetProcessWindowStation\");\n            *0x49cc1c = fcn.0045f021(uVar3);\n        }\n    }\n    if ((*0x49cc1c != iVar1) && (*0x49cc20 != iVar1)) {\n        pcVar4 = fcn.0045f09c(*0x49cc1c);\n        pcVar5 = fcn.0045f09c(*0x49cc20);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x004697ac;\n        }\n    }\n    if ((((*0x49cc14 != iVar1) && (pcVar4 = fcn.0045f09c(*0x49cc14),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x49cc18 != iVar1 && (pcVar4 = fcn.0045f09c(*0x49cc18),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x004697ac:\n    pcVar4 = fcn.0045f09c(*0x49cc10);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 834
    },
    "00469b0f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00469b0f(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.00458c5c(arg_10h);\n    var_14h = fcn.0046ac69(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0046a1e1(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00469b68:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00469ba8;\n        }\n        if (iVar1 != 2) {\ncode_r0x00469b9a:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00469ba8;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00469b9a;\n        goto code_r0x00469b68;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x00469ba8:\n    fcn.0045843c(unaff_EBX);\n    return;\n}\n",
        "token_count": 510
    },
    "00469bb7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00469bb7(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.00458c5c(arg_10h);\n    var_14h = fcn.0046ac69(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0046a725(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00469c10:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00469c50;\n        }\n        if (iVar1 != 2) {\ncode_r0x00469c42:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00469c50;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00469c42;\n        goto code_r0x00469c10;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x00469c50:\n    fcn.0045843c(unaff_EBX);\n    return;\n}\n",
        "token_count": 505
    },
    "004017d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004017d0(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t *extraout_ECX_00;\n    int32_t *extraout_ECX_01;\n    int32_t *arg_ch;\n    \n    if (param_1 == NULL) {\n        fcn.00401000(0x80070057);\n    }\n    arg_ch = param_1;\n    if (param_1 < 0) {\n        fcn.00401000(0x80070057);\n        arg_ch = extraout_ECX;\n    }\n    if (param_2 == 0) {\n        fcn.00401000(0x80070057);\n        arg_ch = extraout_ECX_00;\n    }\n    iVar1 = *param_1;\n    if (iVar1 == param_2) goto code_r0x00401848;\n    if (param_2 < arg_ch) {\n        iVar1 = fcn.004586b4(iVar1, arg_ch, 2);\n        if (iVar1 != 0) goto code_r0x00401859;\n        iVar1 = fcn.00401000(0x8007000e);\n    }\n    fcn.004585e6(iVar1);\n    do {\n        *param_1 = param_2;\n        while( true ) {\n            if (*param_1 != 0) {\n                return;\n            }\n            fcn.00401000(0x8007000e);\n            arg_ch = extraout_ECX_01;\ncode_r0x00401848:\n            if (arg_ch <= param_2) break;\n            iVar1 = fcn.00458674(arg_ch, 2);\ncode_r0x00401859:\n            *param_1 = iVar1;\n        }\n    } while( true );\n}\n",
        "token_count": 416
    },
    "004018d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004018d0(int32_t *param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    \n    iVar4 = *param_1;\n    ppiVar1 = iVar4 + -0x10;\n    piVar3 = *ppiVar1;\n    if (*(iVar4 + -0xc) != 0) {\n        piVar2 = iVar4 + -4;\n        if (*(iVar4 + -4) < 0) {\n            if (*(iVar4 + -8) < 0) {\n                fcn.00401000(0x80070057);\n                iVar4 = extraout_ECX;\n            }\n            *(iVar4 + -0xc) = 0;\n            **param_1 = 0;\n            return;\n        }\n        LOCK();\n        iVar4 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar4 == 1 || iVar4 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1);\n        }\n        iVar4 = (**(*piVar3 + 0xc))();\n        *param_1 = iVar4 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 299
    },
    "004019e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004019e0(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBP;\n    int32_t **ppiVar6;\n    \n    iVar5 = *param_1;\n    if (param_2 < *(iVar5 + -0xc)) {\n        param_2 = *(iVar5 + -0xc);\n    }\n    if (1 < *(iVar5 + -4)) {\n        iVar5 = *param_1;\n        iVar2 = *(iVar5 + -0xc);\n        ppiVar6 = iVar5 + -0x10;\n        puVar3 = (**(**ppiVar6 + 0x10))();\n        iVar4 = (***puVar3)(param_2, 1);\n        if (iVar4 == 0) {\n            fcn.004016c0();\n        }\n        if (iVar2 < param_2) {\n            param_2 = iVar2;\n        }\n        fcn.0045850c(iVar4 + 0x10, param_2 + 1, iVar5, param_2 + 1);\n        *(iVar4 + 4) = iVar2;\n        piVar1 = iVar5 + -4;\n        LOCK();\n        iVar5 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar5 == 1 || iVar5 + -1 < 0) {\n            (**(**ppiVar6 + 4))(ppiVar6);\n        }\n        *unaff_EBP = iVar4 + 0x10;\n        return;\n    }\n    iVar5 = *(iVar5 + -8);\n    if (param_2 <= iVar5) {\n        return;\n    }\n    if (iVar5 < 0x401) {\n        iVar5 = iVar5 * 2;\n    }\n    else {\n        iVar5 = iVar5 + 0x400;\n    }\n    if (iVar5 < param_2) {\n        iVar5 = param_2;\n    }\n    iVar2 = *param_1;\n    if ((*(iVar2 + -8) < iVar5) && (0 < iVar5)) {\n        iVar5 = (**(**(iVar2 + -0x10) + 8))(iVar2 + -0x10, iVar5, 1);\n        if (iVar5 != 0) goto code_r0x004017be;\n    }\n    iVar5 = fcn.004016c0();\ncode_r0x004017be:\n    *param_1 = iVar5 + 0x10;\n    return;\n}\n",
        "token_count": 598
    },
    "00402160": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00402160(int32_t param_1, uint *param_2)\n\n{\n    uint *arg_10h;\n    int32_t iVar1;\n    uchar *unaff_EDI;\n    uint uStack272;\n    \n    *param_2 = 0x90c800c0;\n    if (*0x499e68 != 0) {\n        *param_2 = 0x90c820c0;\n    }\n    *(param_2 + 2) = 0;\n    *(param_2 + 10) = 0;\n    *(param_2 + 3) = 0;\n    param_2[1] = 0;\n    *(param_2 + 0xe) = 100;\n    *(param_2 + 4) = 100;\n    *(param_2 + 0x12) = 0;\n    *(param_2 + 5) = 0;\n    arg_10h = *(param_1 + 0x140);\n    iVar1 = arg_10h[-3];\n    uStack272 = 3;\n    fcn.00401930();\n    fcn.00458a7f(param_2 + 0x16, 0x12, unaff_EDI);\n    if (unaff_EDI != &stack0xfffffef8) {\n        fcn.004585e6(unaff_EDI);\n    }\n    *(param_2 + iVar1 * 2 + 0x18) = 10;\n    fcn.00401930(0x499e1c, 3);\n    fcn.00458a7f(param_2 + iVar1 * 2 + 0x1a, 0x12, arg_10h);\n    if (arg_10h != &uStack272) {\n        fcn.004585e6(arg_10h);\n    }\n    return;\n}\n",
        "token_count": 414
    },
    "00402250": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00402250(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    int32_t *arg_8h;\n    int32_t unaff_EBP;\n    \n    if (*(param_1 + 0x150) == 0) {\n        return -(*(param_1 + 0x84) != 0xffffffff) & *(param_1 + 0x84);\n    }\n    iVar2 = *(*(param_1 + 0x140) + -0xc);\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(0x499e1c);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, (iVar1 + iVar2) * 2 + 0x1c);\n    *(param_1 + 0x88) = iVar2;\n    if (iVar2 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar2);\n        fcn.00402160(uVar3);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(param_1 + 0x88));\n        fcn.0041ecf4(*(param_1 + 0x88), 0);\n        fcn.0045af6e(0x24);\n        *(unaff_EBP + -0x20) = arg_8h;\n        *(unaff_EBP + -0x1c) = arg_8h[0x18];\n        *(unaff_EBP + -0x18) = arg_8h[0x17];\n        iVar2 = fcn.0042052a();\n        uVar3 = *(iVar2 + 0xc);\n        if (arg_8h[0x16] != 0) {\n            iVar2 = fcn.0042052a();\n            uVar3 = *(iVar2 + 0xc);\n            uVar4 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar3, arg_8h[0x16], 5);\n            uVar4 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar3, uVar4);\n            *(unaff_EBP + -0x18) = uVar4;\n        }\n        if (*(unaff_EBP + -0x18) != 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_LockResource)(*(unaff_EBP + -0x18));\n            *(unaff_EBP + -0x1c) = uVar4;\n        }\n        if (*(unaff_EBP + -0x1c) != 0) {\n            uVar4 = fcn.0041ee41();\n            *(unaff_EBP + -0x14) = uVar4;\n            fcn.0041afcd();\n            *(unaff_EBP + -0x28) = 0;\n            *(unaff_EBP + -0x2c) = 0;\n            *(unaff_EBP + -0x24) = 0;\n            if (((*(unaff_EBP + -0x14) != 0) &&\n                (iVar2 = (*_sym.imp.USER32.dll_GetDesktopWindow)(),  *(unaff_EBP + -0x14) != iVar2)) &&\n               (iVar2 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14)),  iVar2 != 0)) {\n                (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n                *(unaff_EBP + -0x2c) = 1;\n                piVar5 = fcn.00409ef0();\n                *(unaff_EBP + -0x24) = piVar5;\n                if (((piVar5 != NULL) && (iVar2 = (**(*piVar5 + 0x128))(),  iVar2 != 0)) &&\n                   (iVar2 = fcn.00418187(),  iVar2 != 0)) {\n                    fcn.004181a2(0);\n                    *(unaff_EBP + -0x28) = 1;\n                }\n            }\n            *(unaff_EBP + -4) = 0;\n            fcn.0041ce25(arg_8h);\n            uVar4 = fcn.0041af14(*(unaff_EBP + -0x14));\n            iVar2 = fcn.0041f111(*(unaff_EBP + -0x1c), uVar4, uVar3);\n            if (iVar2 != 0) {\n                if ((*(arg_8h + 0xf) & 0x10) != 0) {\n                    uVar3 = 4;\n                    uVar6 = fcn.00418009();\n                    if ((uVar6 & 0x100) != 0) {\n                        uVar3 = 5;\n                    }\n                    fcn.0041aa9d(uVar3);\n                }\n                if (arg_8h[8] != 0) {\n                    fcn.0041822e(0, 0, 0, 0, 0, 0x97);\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*(unaff_EBP + -0x28) != 0) {\n                fcn.004181a2(1);\n            }\n            if (*(unaff_EBP + -0x2c) != 0) {\n                (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n            }\n            if ((*(unaff_EBP + -0x14) != 0) && (iVar2 = (*_sym.imp.USER32.dll_GetActiveWindow)(),  iVar2 == arg_8h[8]))\n            {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n            }\n            (**(*arg_8h + 0x60))();\n            fcn.0041ee7d();\n            if (arg_8h[0x16] != 0) {\n                (*_sym.imp.KERNEL32.dll_FreeResource)(*(unaff_EBP + -0x18));\n            }\n        }\n        uVar6 = fcn.0045b013();\n        return uVar6;\n    }\n    return 2;\n}\n",
        "token_count": 1431
    },
    "00402670": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00402670(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t **ppiVar4;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46ece9;\n    piStack12 = *in_FS_OFFSET;\n    uVar3 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = vtable.CButtonDialog.0;\n    piVar1 = param_1[0x25];\n    uStack4 = 6;\n    if (piVar1 != NULL) {\n        if (piVar1[-1] == 0) {\n            fcn.00414b30(piVar1 + -1, uVar3);\n        }\n        else {\n            (**(*piVar1 + 4))(3);\n        }\n    }\n    if (param_1[0x22] != NULL) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1[0x22]);\n    }\n    uStack4._0_1_ = 5;\n    fcn.0041687b();\n    ppiVar4 = param_1[0x51] + -0x10;\n    uStack4._0_1_ = 4;\n    piVar1 = param_1[0x51] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    ppiVar4 = param_1[0x50] + -0x10;\n    uStack4._0_1_ = 3;\n    piVar1 = param_1[0x50] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    uStack4._0_1_ = 2;\n    fcn.0041e1fa();\n    uStack4._0_1_ = 1;\n    fcn.0041e1fa();\n    uStack4 = uStack4._1_3_ << 8;\n    param_1[0x1d] = vtable.CFont.0;\n    fcn.00402550();\n    uStack4 = 0xffffffff;\n    fcn.0041ec27();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 638
    },
    "00403a50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00403a50(int32_t *param_1, uint param_2, int32_t *param_3)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint unaff_EBX;\n    uint uStack120;\n    uchar *puStack104;\n    int32_t *piStack100;\n    uint uStack96;\n    uchar *puStack92;\n    uint uStack88;\n    uchar auStack68 [64];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ &stack0xffffffbc;\n    uStack88 = 0x403a75;\n    uVar1 = fcn.0042a87f(param_2);\n    if (*param_1 == 0) {\n        if (*param_3 != 0x7fffffff) {\n            uStack88 = 2;\n            uStack96 = 0x40;\n            piStack100 = &stack0xffffffb8;\n            puStack104 = 0x403b2d;\n            puStack92 = *param_3;\n            fcn.0040ee30();\n            puStack104 = &stack0xffffffa8;\n            (*_sym.imp.USER32.dll_SetWindowTextA)();\n        }\n        fcn.0045843c(unaff_EBX);\n        return;\n    }\n    uStack88 = 0x40;\n    puStack92 = &stack0xffffffb8;\n    piStack100 = 0x403a8e;\n    uStack96 = uVar1;\n    (*_sym.imp.USER32.dll_GetWindowTextA)();\n    if (param_2 != '\\0') {\n        piStack100 = param_3;\n        puStack104 = &stack0xffffffac;\n        iVar2 = fcn.0040ece0();\n        if (iVar2 == 0) {\n            uStack120 = 0x403ab4;\n            fcn.0041fb58(0x67, 0x40, 0xffffffff);\n            uStack120 = 0x403abb;\n            fcn.0042a5e5();\n        }\n        uStack120 = 2;\n        uVar1 = 0x40;\n        fcn.0040ee30(&stack0xffffff98, 0x40, *param_3);\n        fcn.0040ece0(&stack0xffffff88, param_3);\n        fcn.0045843c(uVar1);\n        return;\n    }\n    *param_3 = 0x7fffffff;\n    uStack88 = 0x403b09;\n    fcn.0045843c(param_2);\n    return;\n}\n",
        "token_count": 572
    },
    "00403b50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00403b50(int32_t *param_1, int32_t param_2, int32_t param_3, int32_t param_4)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t **in_FS_OFFSET;\n    int32_t *in_stack_ffffff6c;\n    uchar *arg_14h;\n    int32_t iStack120;\n    uchar auStack116 [36];\n    uchar auStack80 [28];\n    uchar auStack52 [36];\n    uint32_t uStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46ef1b;\n    piStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ &stack0xffffff6c;\n    *in_FS_OFFSET = &piStack12;\n    if (((param_2 < param_3) || (param_4 < param_2)) && (*param_1 != 0)) {\n        fcn.0040ee30(auStack80, 0x40, param_3, 2);\n        fcn.0040ee30(&stack0xffffff60, 0x40, param_4, 2);\n        piVar2 = fcn.0041f6b5();\n        if (piVar2 == NULL) {\n            piVar2 = fcn.00401000(0x80004005);\n        }\n        iStack120 = (**(*piVar2 + 0xc))();\n        iStack120 = iStack120 + 0x10;\n        arg_14h = auStack116;\n        in_stack_ffffff6c = &iStack120;\n        fcn.0042ab52(in_stack_ffffff6c, 0x77, auStack52, arg_14h);\n        fcn.0041fb0a(arg_14h, 0x30, 0xe000);\n        fcn.004018d0();\n        fcn.0042a5e5();\n        ppiVar3 = in_stack_ffffff6c + -4;\n        uStack4 = 0xffffffff;\n        piVar2 = in_stack_ffffff6c + -1;\n        LOCK();\n        iVar1 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar1 == 1 || iVar1 + -1 < 0) {\n            (**(**ppiVar3 + 4))(ppiVar3);\n        }\n    }\n    *in_FS_OFFSET = piStack12;\n    fcn.0045843c(in_stack_ffffff6c);\n    return;\n}\n",
        "token_count": 603
    },
    "00403ec0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00403ec0(uint32_t param_1, int32_t *param_2, int32_t *param_3)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t *in_FS_OFFSET;\n    int32_t *var_8h;\n    uint var_10h;\n    uint var_ch;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46ef88;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    var_14h = 0;\n    piVar1 = fcn.00414b25(param_1);\n    fcn.0041647b();\n    var_4h = 1;\n    (**(*param_2 + 0x28))(0, 0, 0);\n    fcn.00458b20(piVar1, 0, param_1);\n    (**(*param_2 + 0x34))(piVar1, param_1);\n    piVar2 = piVar1;\n    for (; 3 < param_1; param_1 = param_1 - 4) {\n        if (*piVar2 != *var_8h) goto code_r0x00403f94;\n        var_8h = var_8h + 1;\n        piVar2 = piVar2 + 1;\n    }\n    if ((param_1 == 0) ||\n       ((*var_8h == *piVar2 &&\n        ((param_1 < 2 || ((*(var_8h + 1) == *(piVar2 + 1) && ((param_1 < 3 || (*(var_8h + 2) == *(piVar2 + 2)))))))))))\n    {\n        var_14h = 1;\n    }\ncode_r0x00403f94:\n    var_4h = 0xffffffff;\n    fcn.00416493();\n    fcn.00414b30(piVar1);\n    *in_FS_OFFSET = var_ch_2;\n    return var_14h;\n}\n",
        "token_count": 508
    },
    "00404010": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** fcn.00404010(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    \n    piVar1 = (**(**param_1 + 0x10))();\n    if ((-1 < param_1[3]) && (piVar1 == *param_1)) {\n        LOCK();\n        param_1[3] = param_1[3] + 1;\n        return param_1;\n    }\n    ppiVar2 = (***piVar1)(param_1[1], 1);\n    if (ppiVar2 == NULL) {\n        fcn.004016c0();\n    }\n    ppiVar2[1] = param_1[1];\n    fcn.0045850c(ppiVar2 + 4, param_1[1] + 1, param_1 + 4, param_1[1] + 1);\n    return ppiVar2;\n}\n",
        "token_count": 216
    },
    "004040e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.004040e0(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    fcn.00404080();\n    iVar4 = 0;\n    iVar1 = 0;\n    piVar2 = 0x496358;\n    do {\n        if (piVar2[2] == 0) {\n            if (param_2 == 0) {\n                iVar3 = piVar2[1];\n            }\n            else {\n                iVar3 = *piVar2;\n            }\n            if (iVar3 != 0) {\n                if (iVar4 == param_1) {\n                    return iVar1;\n                }\n                iVar4 = iVar4 + 1;\n            }\n        }\n        piVar2 = piVar2 + 6;\n        iVar1 = iVar1 + 1;\n    } while (piVar2 < 0x496448);\n    return -1;\n}\n",
        "token_count": 228
    },
    "00404130": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00404130(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    fcn.00404080();\n    iVar1 = 0;\n    iVar4 = 0;\n    piVar2 = 0x496358;\n    do {\n        if (piVar2[2] == 0) {\n            if (param_2 == 0) {\n                iVar3 = piVar2[1];\n            }\n            else {\n                iVar3 = *piVar2;\n            }\n            if (iVar3 != 0) {\n                if (iVar4 == param_1) {\n                    return iVar1;\n                }\n                iVar1 = iVar1 + 1;\n            }\n        }\n        piVar2 = piVar2 + 6;\n        iVar4 = iVar4 + 1;\n    } while (piVar2 < 0x496448);\n    return -1;\n}\n",
        "token_count": 227
    },
    "004055d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004055d0(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (param_3 == 0) {\n        uVar3 = *(param_1 + 0x20);\n        uVar4 = 0x14c;\n    }\n    else {\n        uVar3 = *(param_1 + 0x20);\n        uVar4 = 0x158;\n    }\n    iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(uVar3, uVar4, 0xffffffff, param_2);\n    (*pcVar1)(*(param_1 + 0x20), 0x14e, iVar2, 0);\n    if (iVar2 == -1) {\n        fcn.00418095(param_2);\n    }\n    return;\n}\n",
        "token_count": 229
    },
    "004056d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004056d0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint unaff_ESI;\n    uint in_stack_fffffff8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        in_stack_fffffff8 = 0xc;\n        iVar2 = fcn.0042e01d(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar1 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar1 * 0xc;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar3 = *(param_1 + 0x10);\n            *(param_1 + 0x10) = puVar3;\n            puVar3 = puVar3 + -3;\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    if (puVar3 == NULL) {\n        puVar3 = fcn.0041638e();\n    }\n    *(param_1 + 0x10) = *puVar3;\n    puVar3[1] = in_stack_fffffff8;\n    *puVar3 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    return;\n}\n",
        "token_count": 329
    },
    "004057c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004057c0(int32_t param_1, uint param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    uVar6 = 0xffffffff;\n    iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x20), 0x14c, 0xffffffff, param_2);\n    iVar5 = iVar2;\n    if (iVar2 != -1) {\n        do {\n            puVar3 = (*pcVar1)(*(param_1 + 0x20), 0x150, iVar2, 0);\n            if (puVar3 == NULL) {\n                fcn.0041638e();\ncode_r0x00405849:\n                iVar5 = (*pcVar1)(*(param_1 + 0x20), 0x147, 0, 0);\n                if (iVar5 == iVar2) {\n                    return;\n                }\n                (*pcVar1)(*(param_1 + 0x20), 0x14e, iVar2, 0);\n                return;\n            }\n            if (((uVar6 == '\\x01') || (*(puVar3 + 2) == uVar6)) &&\n               (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(param_2, *puVar3),  iVar4 == 0)) goto code_r0x00405849;\n            iVar2 = (*pcVar1)(*(param_1 + 0x20), 0x14c, iVar2, param_2);\n        } while (iVar2 != iVar5);\n    }\n    fcn.004055d0(param_2, 1);\n    return;\n}\n",
        "token_count": 417
    },
    "00405f30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00405f30(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *unaff_ESI;\n    uint uVar3;\n    int32_t **in_FS_OFFSET;\n    float10 fVar4;\n    char *pcStack28;\n    int32_t *apiStack20 [2];\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46ffd8;\n    piStack12 = *in_FS_OFFSET;\n    pcStack28 = *0x4987a4 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00401000(0x80004005);\n    }\n    iVar2 = (**(*piVar1 + 0xc))();\n    apiStack20[0] = iVar2 + 0x10;\n    uStack8 = 0;\n    fcn.00405590(apiStack20);\n    pcStack28 = unaff_ESI;\n    while( true ) {\n        if ((*pcStack28 != ' ') && (*pcStack28 != '\\t')) break;\n        pcStack28 = pcStack28 + 1;\n    }\n    if (*pcStack28 == '\\0') {\n        piStack12 = 0xffffffff;\n        piVar1 = unaff_ESI + -4;\n        LOCK();\n        iVar2 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar2 == 1 || iVar2 + -1 < 0) {\n            (**(**(unaff_ESI + -0x10) + 4))(unaff_ESI + -0x10);\n        }\n        *in_FS_OFFSET = apiStack20[0];\n        return 0xffffffff;\n    }\n    fVar4 = fcn.00458f78(pcStack28, &pcStack28);\n    for (; (*pcStack28 == ' ' || (*pcStack28 == '\\t')); pcStack28 = pcStack28 + 1) {\n    }\n    if (*pcStack28 != '\\0') {\n        piStack12 = 0xffffffff;\n        piVar1 = unaff_ESI + -4;\n        LOCK();\n        iVar2 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar2 == 1 || iVar2 + -1 < 0) {\n            (**(**(unaff_ESI + -0x10) + 4))(unaff_ESI + -0x10);\n        }\n        *in_FS_OFFSET = apiStack20[0];\n        return 0xfffffffe;\n    }\n    if (((0 < fVar4) << 8 | (0 == fVar4) << 0xe) == 0) {\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = fcn.00458f90();\n    }\n    piStack12 = 0xffffffff;\n    piVar1 = unaff_ESI + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**(unaff_ESI + -0x10) + 4))(unaff_ESI + -0x10);\n    }\n    *in_FS_OFFSET = apiStack20[0];\n    return uVar3;\n}\n",
        "token_count": 790
    },
    "00406ff0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __thiscall fcn.00406ff0(int32_t param_1, int32_t param_2)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    uchar *arg_8h;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    int32_t *in_FS_OFFSET;\n    int32_t *piVar9;\n    int32_t iVar10;\n    int32_t iStack172;\n    int32_t *piStack168;\n    uint uStack164;\n    uint uStack160;\n    uchar *puStack156;\n    uint uStack152;\n    int32_t iStack124;\n    uchar auStack104 [23];\n    uchar uStack81;\n    int32_t iStack76;\n    uint32_t uStack68;\n    uchar uStack52;\n    uchar uStack20;\n    uint32_t uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f438;\n    uStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ &stack0xffffff84;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack152 = 0x407039;\n    fcn.0042c352(10);\n    iVar7 = 0;\n    uStack8 = 0;\n    uStack152 = 0x407047;\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        uStack152 = 0x80004005;\n        puStack156 = 0x40705c;\n        piVar3 = fcn.00401000();\n    }\n    puStack156 = 0x407065;\n    iStack124 = (**(*piVar3 + 0xc))();\n    iStack124 = iStack124 + 0x10;\n    puStack156 = &stack0xffffff84;\n    uStack12 = CONCAT31(uStack12._1_3_, 1);\n    uStack160 = 0x407080;\n    fcn.00405590();\n    uStack160 = 0x407087;\n    fcn.00406540();\n    iStack172 = *(param_1 + 0x20);\n    uStack160 = 0;\n    uStack164 = 0;\n    piStack168 = 0x14b;\n    (*_sym.imp.USER32.dll_SendMessageA)();\n    fcn.00458b20(&stack0xffffff98, 0, 0x3c);\n    puVar1 = *(param_2 + 4);\n    uStack81 = uStack20;\n    iVar10 = param_1;\n    if (puVar1 == NULL) {\n        if (*0x499e68 != 0) {\n            arg_8h = &stack0xffffff98;\n            (*_sym.imp.GDI32.dll_EnumFontFamiliesExA)(*0x499df4, arg_8h, 0x406ea0, param_1, 0);\n            goto code_r0x0040710f;\n        }\n        iVar10 = 0x406d80;\n        arg_8h = *0x499df4;\n    }\n    else {\n        if (*0x499e68 != 0) {\n            arg_8h = &stack0xffffff98;\n            (*_sym.imp.GDI32.dll_EnumFontFamiliesExA)(puVar1, arg_8h, 0x406f40, param_1, 0);\n            goto code_r0x0040710f;\n        }\n        iVar10 = 0x406db0;\n        arg_8h = puVar1;\n    }\n    (*_sym.imp.GDI32.dll_EnumFontFamiliesA)(arg_8h, 0, iVar10, param_1);\ncode_r0x0040710f:\n    iVar6 = *(param_1 + 0x5c);\n    puStack156 = iVar6;\n    if (0 < iVar6) {\n        do {\n            if (iVar7 < 0) goto code_r0x00407217;\n            if (*(param_1 + 0x5c) <= iVar7) goto code_r0x00407217;\n            puVar5 = *(*(param_1 + 0x58) + iVar7 * 4);\n            iStack172 = 0;\n            iVar4 = fcn.0042c44f(*puVar5, &stack0xffffff54);\n            if (iVar4 == 0) {\n                puVar5 = fcn.0042c5d5(*puVar5);\n                *puVar5 = 0;\n            }\n            else if (iVar10 == 0) {\n                fcn.0042c543(*puVar5);\n                puVar5 = fcn.0042c5d5(*puVar5);\n                *puVar5 = 1;\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < iVar6);\n    }\n    iStack172 = 0;\n    if (0 < iVar6) {\n        do {\n            while ((iStack172 < 0 || (*(param_1 + 0x5c) <= iStack172))) {\ncode_r0x00407217:\n                fcn.0041638e();\n            }\n            piVar3 = *(*(param_1 + 0x58) + iStack172 * 4);\n            iVar7 = *piVar3;\n            piVar8 = iVar7 + -0x10;\n            puVar5 = (**(**(iVar7 + -0x10) + 0x10))();\n            if ((*(iVar7 + -4) < 0) || (puVar5 != *piVar8)) {\n                piVar8 = (***puVar5)(*(iVar7 + -0xc), 1);\n                if (piVar8 == NULL) {\n                    fcn.004016c0();\n                    pcVar2 = swi(3);\n                    (*pcVar2)();\n                    return;\n                }\n                piVar8[1] = *(iVar7 + -0xc);\n                iVar6 = *(iVar7 + -0xc) + 1;\n                fcn.0045850c(piVar8 + 4, iVar6, iVar7, iVar6);\n            }\n            else {\n                LOCK();\n                *(iVar7 + -4) = *(iVar7 + -4) + 1;\n            }\n            piVar8 = piVar8 + 4;\n            uStack52 = 2;\n            uStack160 = 0;\n            piVar9 = piVar8;\n            piStack168 = piVar8;\n            fcn.0042c44f(piVar8, &stack0xffffff60);\n            if ((piStack168 != NULL) && (*(piVar3[1] + -0xc) != 0)) {\n                fcn.00404480(0x477570, 2);\n                fcn.00404480(piVar3[1], *(piVar3[1] + -0xc));\n                piVar8 = piVar9;\n                fcn.00404480(0x47756c, 1);\n            }\n            pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n            iVar7 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x20), 0x143, 0, piVar8);\n            if (-1 < iVar7) {\n                (*pcVar2)(*(param_1 + 0x20), 0x151, iVar7, piVar3);\n            }\n            uStack52 = 1;\n            piVar3 = piVar8 + -1;\n            LOCK();\n            iVar7 = *piVar3;\n            *piVar3 = *piVar3 + -1;\n            if (iVar7 == 1 || iVar7 + -1 < 0) {\n                (**(*piVar8[-4] + 4))(piVar8 + -4);\n            }\n            iStack172 = iStack172 + 1;\n        } while (iStack172 < puStack156);\n    }\n    fcn.004055d0(uStack164, 0);\n    fcn.00445b33(0, 0xffffffff);\n    uStack68 = uStack68 & 0xffffff00;\n    piVar3 = iVar10 + -4;\n    LOCK();\n    iVar7 = *piVar3;\n    *piVar3 = *piVar3 + -1;\n    if (iVar7 == 1 || iVar7 + -1 < 0) {\n        (**(**(iVar10 + -0x10) + 4))(iVar10 + -0x10);\n    }\n    uStack68 = 0xffffffff;\n    fcn.0042c4ff();\n    *in_FS_OFFSET = iStack76;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 1993
    },
    "004076d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004076d0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t **ppiVar5;\n    \n    iVar3 = *param_2;\n    iVar4 = *param_1;\n    ppiVar1 = iVar3 + -0x10;\n    ppiVar5 = iVar4 + -0x10;\n    if (ppiVar1 == ppiVar5) {\n        return param_1;\n    }\n    piVar2 = iVar4 + -4;\n    if ((-1 < *(iVar4 + -4)) && (*ppiVar1 == *ppiVar5)) {\n        iVar4 = fcn.00404010(ppiVar1);\n        LOCK();\n        iVar3 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**ppiVar5 + 4))(ppiVar5);\n        }\n        *param_1 = iVar4 + 0x10;\n        return param_1;\n    }\n    fcn.004023a0(iVar3, *(iVar3 + -0xc));\n    return param_1;\n}\n",
        "token_count": 301
    },
    "00407f00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00407f00(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    \n    fcn.00407ee0(param_1 + 0x138, 0 < *(param_1 + 0x134));\n    iVar4 = fcn.00418323();\n    bVar1 = 0 < iVar4;\n    fcn.00407ee0(param_1 + 0x18c, bVar1);\n    fcn.00407ee0(param_1 + 0x1e0, bVar1);\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x20), 0x400, 0, 0);\n    if (bVar1) {\n        if (iVar3 != 0x3ed) {\n            (*pcVar2)(*(param_1 + 0x20), 0x401, 0x3ed, 0);\n            return;\n        }\n    }\n    else if (iVar3 != 1) {\n        (*pcVar2)(*(param_1 + 0x20), 0x401, 1, 0);\n    }\n    return;\n}\n",
        "token_count": 297
    },
    "00408810": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00408810(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    int32_t unaff_ESI;\n    \n    if (param_3 != -1) {\n        uVar1 = fcn.0040e650(9, 1);\n        if (unaff_ESI == 0) {\n            fcn.00434486(uVar1);\n            if (*(param_1 + 0x108) == 0) {\n                fcn.0041638e();\n            }\n            uVar1 = fcn.0040e650(9, 0);\n            fcn.00434486(uVar1);\n            return 0;\n        }\n        fcn.00434807(uVar1);\n        uVar1 = fcn.0040e650(9, 0);\n        fcn.00434807(uVar1);\n    }\n    return 0;\n}\n",
        "token_count": 211
    },
    "0040a050": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040a050(int32_t param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    uint arg_8h;\n    uint in_stack_fffffef8;\n    \n    if ((*(param_1 + 0x54) != 0) && (*(param_1 + 0x5c) != 0)) {\n        fcn.00459195(&stack0xfffffef8, 0x104, param_2);\n        (*_sym.imp.USER32.dll_CharToOemA)(&stack0xfffffef8, &stack0xfffffef8);\n        uVar2 = fcn.00409f50(&stack0xfffffef0);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, 0x100);\n        arg_8h = uVar3;\n        (**(param_1 + 0x5c))(uVar2);\n        pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar3);\n        (*pcVar1)(uVar2);\n        fcn.0045843c(arg_8h);\n        return;\n    }\n    fcn.0045843c(in_stack_fffffef8);\n    return;\n}\n",
        "token_count": 295
    },
    "0040a290": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040a290(int32_t param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    uint unaff_ESI;\n    uchar auStack68 [64];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ auStack68;\n    if ((*(param_1 + 0x18) != 0) && (*(param_1 + 0x10) != param_2)) {\n        *(param_1 + 0x10) = param_2;\n        puVar1 = param_1 + 0x20;\n        if (param_2 != 100) {\n            puVar1 = param_1 + 0x1c;\n        }\n        fcn.00458b9a(auStack68, 0x40, *puVar1, param_2);\n        fcn.00409f10(auStack68);\n    }\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 227
    },
    "0040a370": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __fastcall fcn.0040a370(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    *(param_1 + 0x10) = 0xffffffff;\n    *(param_1 + 0x28) = 0;\n    uVar2 = fcn.00409f50(0x476744);\n    uVar3 = fcn.00409f50(0x476744);\n    if (*(param_1 + 0x48) == 0) {\n        iVar4 = (**(param_1 + 100))(*(param_1 + 0x50), 0, *(param_1 + 0x4c), uVar2, 0x40a350);\n    }\n    else {\n        iVar4 = (**(param_1 + 0x60))(*(param_1 + 0x50), 0, *(param_1 + 0x4c), uVar2, uVar3, 0x40a320);\n        fcn.0040a000();\n        (*_sym.imp.KERNEL32.dll_ResetEvent)(*(param_1 + 0x44));\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n    (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    (*pcVar1)(uVar3);\n    if (*(param_1 + 0x3c) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(param_1 + 0x4c));\n    }\n    (*pcVar1)(*(param_1 + 0x4c));\n    if (iVar4 != 0) {\n        *(param_1 + 0x30) = 1;\n    }\n    *(param_1 + 0x2c) = 1;\n    *(param_1 + 0x28) = 100;\n    *(param_1 + 0x10) = 0xffffffff;\n    (*_sym.imp.KERNEL32.dll_SetEvent)(*(param_1 + 0x40));\n    return iVar4 == 0;\n}\n",
        "token_count": 476
    },
    "0040a900": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040a900(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t **ppiVar5;\n    int32_t unaff_ESI;\n    int32_t *in_FS_OFFSET;\n    code *pcStack20;\n    code **ppcStack16;\n    uint uStack12;\n    \n    *param_1 = vtable.CConverter.0;\n    if (param_1[0xb] == NULL) {\n        uStack12 = 0x40a915;\n        fcn.00409fb0();\n        pcVar3 = _sym.imp.KERNEL32.dll_ResetEvent;\n        uStack12 = param_1[0x10];\n        param_1[0xd] = NULL;\n        ppcStack16 = 0x40a928;\n        (*pcVar3)();\n        ppcStack16 = param_1[0x11];\n        param_1[0xd] = NULL;\n        pcStack20 = 0x40a939;\n        (*_sym.imp.KERNEL32.dll_SetEvent)();\n        pcStack20 = 0x40a940;\n        fcn.00409fb0();\n        pcStack20 = param_1[0x10];\n        (*pcVar3)();\n    }\n    pcVar3 = _sym.imp.KERNEL32.dll_CloseHandle;\n    uStack12 = param_1[0x10];\n    if (uStack12 != NULL) {\n        ppcStack16 = 0x40a956;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    uStack12 = param_1[0x11];\n    if (uStack12 != NULL) {\n        ppcStack16 = 0x40a960;\n        (*pcVar3)();\n    }\n    uStack12 = param_1[0x15];\n    if (uStack12 != NULL) {\n        ppcStack16 = 0x40a96e;\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)();\n    }\n    uStack12 = param_1[0x14];\n    if (uStack12 != NULL) {\n        ppcStack16 = 0x40a97c;\n        (*_sym.imp.KERNEL32.dll_GlobalFree)();\n    }\n    pcStack20 = unaff_ESI;\n    uStack12 = *in_FS_OFFSET;\n    uVar4 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    *param_1 = vtable.CTrackFile.0;\n    ppcStack16 = param_1;\n    fcn.0040a290(100, uVar4);\n    if (param_1[6] != NULL) {\n        fcn.004320be(0xe001);\n    }\n    ppiVar5 = param_1[9] + -0x10;\n    uStack12._0_1_ = 2;\n    piVar1 = param_1[9] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**ppiVar5 + 4))(ppiVar5);\n    }\n    ppiVar5 = param_1[8] + -0x10;\n    uStack12._0_1_ = 1;\n    piVar1 = param_1[8] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**ppiVar5 + 4))(ppiVar5);\n    }\n    ppiVar5 = param_1[7] + -0x10;\n    uStack12 = uStack12._1_3_ << 8;\n    piVar1 = param_1[7] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar5 + 4))(ppiVar5);\n    }\n    uStack12 = 0xffffffff;\n    fcn.0042b1bf();\n    *in_FS_OFFSET = pcStack20;\n    return;\n}\n",
        "token_count": 980
    },
    "0040b290": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040b290(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00421345();\n    if (iVar1 == 1) {\n        uVar2 = fcn.0040e650(5, 1);\n        fcn.0040b1f0(param_1 + 0x13c, uVar2);\n        uVar2 = fcn.0040e650(4, 1);\n        fcn.0040b1f0(param_1 + 0x1d8, uVar2);\n        uVar2 = fcn.0040e650(1, 1);\n        fcn.0040b1f0(param_1 + 0x274, uVar2);\n        uVar2 = fcn.0040e650(3, 1);\n        fcn.0040b1f0(param_1 + 0x310, uVar2);\n        uVar2 = fcn.0040e650(9, 1);\n        fcn.0040b1f0(param_1 + 0x3ac, uVar2);\n        uVar2 = fcn.0040e650(9, 0);\n        fcn.0040b1f0(param_1 + 0x3ac, uVar2);\n        *0x49a288 = *(param_1 + 0x134);\n        *0x499e78 = *(param_1 + 0x138);\n        iVar3 = fcn.0040e5e0(5);\n        *(iVar3 + 0x90) = *(param_1 + 0x1c4);\n        iVar3 = fcn.0040e5e0(4);\n        *(iVar3 + 0x90) = *(param_1 + 0x260);\n        iVar3 = fcn.0040e5e0(1);\n        *(iVar3 + 0x90) = *(param_1 + 0x2fc);\n        iVar3 = fcn.0040e5e0(3);\n        *(iVar3 + 0x90) = *(param_1 + 0x398);\n        iVar3 = fcn.0040e5e0(9);\n        *(iVar3 + 0x90) = *(param_1 + 0x434);\n    }\n    return iVar1;\n}\n",
        "token_count": 546
    },
    "0040baa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040baa0(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    uint arg_8h;\n    int32_t arg_8h_00;\n    int32_t *piVar2;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46fa2a;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *(param_1 + 0x20) = param_2;\n    if (*(param_1 + 0x38) != 0) {\n        fcn.0040ba40(uVar1);\n        (**(**(param_1 + 0x38) + 0x20))(0xffffffff);\n        if (*(param_1 + 0x38) != NULL) {\n            (**(**(param_1 + 0x38) + 4))(1);\n        }\n        *(param_1 + 0x38) = 0;\n    }\n    if (*(param_1 + 0x20) != 0) {\n        arg_8h = (*_sym.imp.USER32.dll_GetParent)(*(*(param_1 + 0x24) + 0x20));\n        fcn.0041af14(arg_8h);\n        arg_8h_00 = fcn.00430d6d();\n        if (arg_8h_00 == 0) {\n            fcn.0041638e();\n        }\n        (*_sym.imp.USER32.dll_GetClientRect)(*(arg_8h_00 + 0x20), param_1 + 0x28);\n        piStack12 = fcn.00414af6(0x14);\n        if (piStack12 == NULL) {\n            piVar2 = NULL;\n        }\n        else {\n            piVar2 = fcn.004175d5(arg_8h_00);\n        }\n        *(param_1 + 0x38) = piVar2;\n        (**(*piVar2 + 0x1c))();\n        fcn.004178bb(*(param_1 + 0x24) + 0xad0);\n        fcn.00416c8c(7);\n        fcn.0040ba40();\n    }\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 562
    },
    "0040caa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040caa0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = 0;\n    piVar2 = param_1 + 0x240;\n    do {\n        if (*piVar2 == 0) {\n            return param_1 + 0x228 + iVar1 * 0x44;\n        }\n        iVar1 = iVar1 + 1;\n        piVar2 = piVar2 + 0x11;\n    } while (iVar1 < 0x20);\n    return 0;\n}\n",
        "token_count": 136
    },
    "0040d370": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040d370(int32_t param_1, int32_t param_2)\n\n{\n    if (*(param_1 + 0x18) != param_2) {\n        if (*(param_1 + 0x20) != 0) {\n            fcn.0040ba40();\n        }\n        fcn.0040ce10();\n        *(param_1 + 0x18) = param_2;\n        fcn.0040ce10();\n        if (*(param_1 + 0x20) != 0) {\n            fcn.0040ba40();\n        }\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "0040e650": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040e650(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040e5e0(param_1);\n    if (param_1 == 0) {\n        iVar1 = iVar1 + 0x48;\n    }\n    return iVar1;\n}\n",
        "token_count": 75
    },
    "0040ea60": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040ea60(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t *extraout_ECX_00;\n    int32_t *extraout_ECX_01;\n    int32_t *arg_ch;\n    \n    if (param_1 == NULL) {\n        fcn.00401000(0x80070057);\n    }\n    arg_ch = param_1;\n    if (param_1 < 0) {\n        fcn.00401000(0x80070057);\n        arg_ch = extraout_ECX;\n    }\n    if (param_2 == 0) {\n        fcn.00401000(0x80070057);\n        arg_ch = extraout_ECX_00;\n    }\n    iVar1 = *param_1;\n    if (iVar1 == param_2) goto code_r0x0040ead8;\n    if (param_2 < arg_ch) {\n        iVar1 = fcn.004586b4(iVar1, arg_ch, 1);\n        if (iVar1 != 0) goto code_r0x0040eae9;\n        iVar1 = fcn.00401000(0x8007000e);\n    }\n    fcn.004585e6(iVar1);\n    do {\n        *param_1 = param_2;\n        while( true ) {\n            if (*param_1 != 0) {\n                return;\n            }\n            fcn.00401000(0x8007000e);\n            arg_ch = extraout_ECX_01;\ncode_r0x0040ead8:\n            if (arg_ch <= param_2) break;\n            iVar1 = fcn.00458674(arg_ch, 1);\ncode_r0x0040eae9:\n            *param_1 = iVar1;\n        }\n    } while( true );\n}\n",
        "token_count": 422
    },
    "0040eaf0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040eaf0(uint32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t arg_8h;\n    \n    if (param_1 == 0) {\n        arg_8h = 0;\n    }\n    else {\n        arg_8h = param_1;\n        if (0xffffffff / param_1 == 0) {\n            param_1 = 0;\n            fcn.004592b5(&param_1);\n            fcn.004593a9(&stack0xfffffff0, 0x48b6e8);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n    }\n    fcn.00414af6(arg_8h);\n    return;\n}\n",
        "token_count": 169
    },
    "0040ec40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040ec40(char *param_1)\n\n{\n    uint32_t uVar1;\n    uint arg_8h;\n    uint32_t in_stack_fffffef4;\n    uchar auStack264 [260];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ &stack0xfffffef4;\n    if (*param_1 != '\\0') {\n        fcn.0042b4c9(auStack264, param_1);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&stack0xfffffef0);\n        in_stack_fffffef4 = uVar1 & 0xffff;\n        if (in_stack_fffffef4 != 0) {\n            arg_8h = 0x40e4f0;\n            (*_sym.imp.USER32.dll_EnumWindows)();\n            if (arg_8h == 0) {\n                fcn.0045843c(arg_8h);\n                return;\n            }\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(arg_8h);\n        }\n    }\n    fcn.0045843c(in_stack_fffffef4);\n    return;\n}\n",
        "token_count": 261
    },
    "0040ece0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040ece0(char *param_1, uint *param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *puVar4;\n    float10 fVar5;\n    \n    if (*param_1 == '\\0') {\n        return 0;\n    }\n    fVar5 = fcn.00458f78(param_1, &param_1);\n    iVar2 = fcn.004594c5(*param_1);\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrcmpiA;\n    while (_sym.imp.KERNEL32.dll_lstrcmpiA = pcVar1,  iVar2 != 0) {\n        param_1 = param_1 + 1;\n        iVar2 = fcn.004594c5(*param_1);\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrcmpiA;\n    }\n    if (*param_1 != '\\0') {\n        puVar4 = 0x499c54;\n        do {\n            iVar2 = (*pcVar1)(param_1, *puVar4);\n            if (iVar2 == 0) {\n                if (0.0 <= fVar5) {\n                    uVar3 = fcn.00458f90();\n                    *param_2 = uVar3;\n                    return 1;\n                }\n                uVar3 = fcn.00458f90();\n                *param_2 = uVar3;\n                return 1;\n            }\n            puVar4 = puVar4 + 8;\n        } while (puVar4 < 0x499d34);\n        return 0;\n    }\n    if (0.0 <= fVar5) {\n        uVar3 = fcn.00458f90();\n        *param_2 = uVar3;\n        return 1;\n    }\n    uVar3 = fcn.00458f90();\n    *param_2 = uVar3;\n    return 1;\n}\n",
        "token_count": 433
    },
    "0040ee30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040ee30(int32_t param_1, uint param_2, uint param_3, int32_t param_4, int32_t param_5)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar2 = *(*(param_1 + 0x568) * 0x20 + 0x499c38);\n    iVar3 = fcn.00414b25();\n    if (param_4 < 0) {\n        param_4 = -param_4;\n    }\n    iVar4 = 0;\n    if (-1 < param_5) {\n        do {\n            iVar4 = iVar4 + 1;\n            *(iVar3 + -4 + iVar4 * 4) = param_4 / iVar2;\n            param_4 = (param_4 - (param_4 / iVar2) * iVar2) * 10;\n        } while (iVar4 <= param_5);\n    }\n    iVar4 = iVar4 + -1;\n    if (iVar2 / 2 <= param_4) {\n        piVar1 = iVar3 + iVar4 * 4;\n        *piVar1 = *piVar1 + 1;\n    }\n    iVar2 = *(iVar3 + iVar4 * 4);\n    while ((iVar2 == 10 && (iVar4 != 0))) {\n        *(iVar3 + iVar4 * 4) = 0;\n        piVar1 = iVar3 + -4 + iVar4 * 4;\n        *piVar1 = *piVar1 + 1;\n        iVar4 = iVar4 + -1;\n        iVar2 = *(iVar3 + iVar4 * 4);\n    }\n    if (param_5 != 0) {\n        do {\n            if (*(iVar3 + param_5 * 4) != 0) break;\n            param_5 = param_5 + -1;\n        } while (param_5 != 0);\n    }\n    fcn.00458b9a(param_2, param_3, \"%.*f\", param_5);\n    if (*(*(param_1 + 0x568) * 0x20 + 0x499c50) != 0) {\n        fcn.004594f3(param_2, param_3, 0x4792e8);\n    }\n    fcn.004594f3(param_2, param_3, *(*(param_1 + 0x568) * 0x20 + 0x499c54));\n    fcn.00414b30(iVar3);\n    return;\n}\n",
        "token_count": 582
    },
    "0040ef50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040ef50(int32_t param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    code *pcVar3;\n    \n    if (param_2 != 0) {\n        fcn.0042f736(0);\n    }\n    pcVar3 = _sym.imp.USER32.dll_SendMessageA;\n    puVar2 = *(param_1 + 0x4fc);\n    while (puVar2 != NULL) {\n        puVar1 = puVar2 + 2;\n        puVar2 = *puVar2;\n        (*pcVar3)(*puVar1, *0x499d18, 0, 0);\n    }\n    return;\n}\n",
        "token_count": 165
    },
    "0040f220": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040f220(code **param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46ff04;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = vtable.CWordPadApp.0;\n    uStack4 = 10;\n    if (param_1[0x35] != NULL) {\n        uVar2 = fcn.004174e4(uVar1);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    uStack4._0_1_ = 9;\n    fcn.0043f4fb();\n    uStack4._0_1_ = 8;\n    fcn.0040f050();\n    uStack4._0_1_ = 7;\n    fcn.0040e3a0();\n    uStack4._0_1_ = 6;\n    fcn.0040e3a0();\n    uStack4._0_1_ = 5;\n    fcn.0040e3a0();\n    uStack4._0_1_ = 4;\n    fcn.0040e3a0();\n    uStack4._0_1_ = 3;\n    fcn.0040e3a0();\n    uStack4._0_1_ = 2;\n    fcn.0040e3a0();\n    uStack4._0_1_ = 1;\n    fcn.0041752d();\n    uStack4 = uStack4._1_3_ << 8;\n    fcn.0043ec4b();\n    uStack4 = 0xffffffff;\n    fcn.0043ecd8();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 468
    },
    "0040f420": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040f420(int32_t param_1, char param_2, int32_t param_3)\n\n{\n    uint arg_10h;\n    \n    if ((param_2 != '\\0') && (0xf < *(param_1 + 0x18))) {\n        arg_10h = *(param_1 + 4);\n        if (param_3 != 0) {\n            fcn.0045850c(param_1 + 4, 0x10, arg_10h, param_3);\n        }\n        fcn.00414b30(arg_10h);\n    }\n    *(param_1 + 0x14) = param_3;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4 + param_3) = 0;\n    return;\n}\n",
        "token_count": 190
    },
    "00410ce0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410ce0(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t **in_FS_OFFSET;\n    code *pcStack248;\n    int32_t iStack232;\n    int32_t *piStack24;\n    int32_t iStack20;\n    int32_t *piStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4701f6;\n    piStack12 = *in_FS_OFFSET;\n    pcStack248 = *0x4987a4 ^ &stack0xffffff0c;\n    *in_FS_OFFSET = &piStack12;\n    if (*(param_1 + 0x144) == 0) {\n        if (*(param_1 + 0xcc) == 0) {\n            if (*(*(param_1 + 0xbc) + -0xc) != 0) {\n                fcn.00410530(0, 0xffffffff, 0);\n                iVar3 = fcn.004049e0(*(param_1 + 0xbc), &pcStack248);\n                pcStack248 = vtable.CFileException.0;\n                piVar1 = iStack232 + -4;\n                LOCK();\n                iVar2 = *piVar1;\n                *piVar1 = *piVar1 + -1;\n                if (iVar2 == 1 || iVar2 + -1 < 0) {\n                    (**(**(iStack232 + -0x10) + 4))(iStack232 + -0x10);\n                }\n                if (iVar3 != -1) goto code_r0x00410e3f;\n            }\n            iVar3 = 2;\n        }\n        else {\n            iVar3 = 5;\n        }\n        goto code_r0x00410e3f;\n    }\n    fcn.00404d90(0);\n    uStack8 = 1;\n    iVar3 = fcn.0041f2c7();\n    if (iVar3 == 2) {\n        uStack8 = 0xffffffff;\n        fcn.00404e20();\n        *in_FS_OFFSET = piStack16;\n        return;\n    }\n    if (iStack20 == 0) {\n        iVar3 = 2;\ncode_r0x00410e21:\n        *(param_1 + 0xcc) = 0;\n    }\n    else {\n        iVar3 = (iStack20 != 1) + 4;\n        if (iVar3 != 5) goto code_r0x00410e21;\n    }\n    uStack8 = 0xffffffff;\n    fcn.00404e20();\ncode_r0x00410e3f:\n    *(param_1 + 0x164) = iVar3;\n    fcn.00441bb0(0, 1);\n    *in_FS_OFFSET = piStack24;\n    return;\n}\n",
        "token_count": 659
    },
    "00410e70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00410e70(char **param_1, uint param_2, int32_t param_3)\n\n{\n    char *pcVar1;\n    char cVar2;\n    code *pcVar3;\n    int32_t in_ram_fffffffd;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    char *pcVar10;\n    int32_t iVar11;\n    uint uVar12;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t *piVar13;\n    char **ppcVar14;\n    int32_t *in_FS_OFFSET;\n    int32_t iStack36;\n    uint uStack28;\n    int32_t aiStack20 [2];\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x470250;\n    uStack12 = *in_FS_OFFSET;\n    uVar4 = *0x4987a4 ^ &stack0xffffffc4;\n    *in_FS_OFFSET = &uStack12;\n    piVar13 = NULL;\n    if (param_1 == NULL) {\n        fcn.0041638e(uVar4);\n    }\n    piVar5 = fcn.0041f6b5();\n    ppcVar14 = param_1;\n    if (piVar5 != NULL) goto code_r0x00410ec7;\ncode_r0x00410ebd:\n    uVar4 = 0x80004005;\n    piVar5 = fcn.00401000();\ncode_r0x00410ec7:\n    iVar6 = (**(*piVar5 + 0xc))(uVar4);\n    iVar6 = iVar6 + 0x10;\n    uStack4 = piVar13;\n    piVar5 = fcn.0041f6b5();\n    if ((piVar5 != piVar13) == piVar13) {\n        piVar5 = fcn.00401000(0x80004005);\n    }\n    iVar7 = (**(*piVar5 + 0xc))();\n    uStack4 = CONCAT31(uStack4._1_3_, 1);\n    piVar5 = fcn.0041f6b5();\n    if ((piVar5 != piVar13) == piVar13) {\n        piVar5 = fcn.00401000(0x80004005);\n    }\n    iVar8 = (**(*piVar5 + 0xc))();\n    iVar8 = iVar8 + 0x10;\n    uStack4 = CONCAT31(uStack4._1_3_, 3);\n    fcn.00409000(0x80000000, \"CLSID\");\n    pcVar10 = *ppcVar14;\n    uStack28 = 1;\n    iStack36 = iVar6;\n    do {\n        if (pcVar10 == NULL) goto code_r0x00411170;\n        uStack4 = ppcVar14 + 1;\n        iVar9 = in_ram_fffffffd;\n        if (*pcVar10 != '\\0') {\n            iVar9 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar10);\n            pcVar1 = pcVar10 + iVar9 + 1;\n            (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar1);\n            if ((*(iVar6 + -8) - 0x100U | 1U - *(iVar6 + -4)) < 0) {\n                iVar6 = unaff_ESI;\n                fcn.004019e0(0x100);\n                unaff_ESI = iVar6;\n            }\n            piVar13 = _sym.imp.KERNEL32.dll_FormatMessageA;\n            iVar9 = (*_sym.imp.KERNEL32.dll_FormatMessageA)(0x2400, pcVar10, 0, 0, iVar6, 0x100, uStack8);\n            if (iVar9 == -1) {\n                iVar9 = fcn.0045905c(iVar6, *(iVar6 + -8));\n            }\n            if ((iVar9 < 0) || (*(iVar6 + -8) < iVar9)) {\ncode_r0x00411218:\n                fcn.00401000();\n                pcVar3 = swi(3);\n                uVar12 = (*pcVar3)();\n                return uVar12;\n            }\n            *(iVar6 + -0xc) = iVar9;\n            *(iVar9 + iVar6) = 0;\n            pcVar10 = pcVar1;\n            if (pcVar1 != NULL) {\n                do {\n                    cVar2 = *pcVar10;\n                    pcVar10 = pcVar10 + 1;\n                } while (cVar2 != '\\0');\n            }\n            fcn.004023a0(pcVar1);\n            if ((*(iVar8 + -8) - 0x100U | 1U - *(iVar8 + -4)) < 0) {\n                fcn.004019e0(0x100);\n                iVar8 = iStack36;\n            }\n            ppcVar14 = NULL;\n            iVar9 = (*piVar13)(0x2400, aiStack20[0], 0, 0, iVar8, 0x100, param_1);\n            if (iVar9 == -1) {\n                iVar9 = fcn.0045905c(iVar8, *(iVar8 + -8));\n            }\n            if ((iVar9 < 0) || (*(iVar8 + -8) < iVar9)) goto code_r0x00411218;\n            *(iVar8 + -0xc) = iVar9;\n            *(iVar9 + iVar8) = 0;\n            iVar9 = in_ram_fffffffd;\n            if (*(iVar6 + -0xc) == 0) goto code_r0x00411162;\n            iStack36 = 0;\n            param_1 = 0x4;\n            fcn.00409000(0x80000000);\n            iVar9 = in_ram_fffffffd;\n            if (param_3 == 0) {\n                piVar5 = fcn.0041f6b5();\n                if (piVar5 == NULL) goto code_r0x00410ebd;\n                aiStack20[0] = (**(*piVar5 + 0xc))();\n                aiStack20[0] = aiStack20[0] + 0x10;\n                param_1 = 0x5;\n                iVar9 = fcn.00409110(aiStack20);\n                if ((iVar9 == 0) || (*0xfffffff5 == 0)) {\n                    uStack4 = CONCAT31(uStack4._1_3_, 4);\n                    LOCK();\n                    iVar9 = in_ram_fffffffd + -1;\n                    if (in_ram_fffffffd == 1 || in_ram_fffffffd + -1 < 0) {\n                        (**(**0xfffffff1 + 4))(0xfffffff1);\n                    }\n                    goto code_r0x0041113d;\n                }\n                uStack4 = CONCAT31(uStack4._1_3_, 4);\n                LOCK();\n                iVar9 = in_ram_fffffffd + -1;\n                if (in_ram_fffffffd == 1 || in_ram_fffffffd + -1 < 0) {\n                    (**(**0xfffffff1 + 4))(0xfffffff1);\n                }\n            }\n            else {\ncode_r0x0041113d:\n                iVar11 = fcn.00409040(iVar8, iVar7 + 0x10);\n                if (iVar11 == 0) {\n                    uStack28 = 0;\n                    uStack12 = CONCAT31(uStack12._1_3_, 3);\n                    fcn.00408fe0();\ncode_r0x00411170:\n                    uStack12._0_1_ = 2;\n                    fcn.00408fe0();\n                    uStack12._0_1_ = 1;\n                    piVar13 = iVar8 + -4;\n                    LOCK();\n                    iVar7 = *piVar13;\n                    *piVar13 = *piVar13 + -1;\n                    if (iVar7 == 1 || iVar7 + -1 < 0) {\n                        (**(**(iVar8 + -0x10) + 4))(iVar8 + -0x10);\n                    }\n                    uStack12 = uStack12._1_3_ << 8;\n                    piVar13 = unaff_EBX + -4;\n                    LOCK();\n                    iVar7 = *piVar13;\n                    *piVar13 = *piVar13 + -1;\n                    if (iVar7 + -1 < 1) {\n                        (**(**(unaff_EBX + -0x10) + 4))(unaff_EBX + -0x10);\n                    }\n                    uStack12 = 0xffffffff;\n                    piVar13 = iVar6 + -4;\n                    LOCK();\n                    iVar7 = *piVar13;\n                    *piVar13 = *piVar13 + -1;\n                    if (iVar7 == 1 || iVar7 + -1 < 0) {\n                        (**(**(iVar6 + -0x10) + 4))(iVar6 + -0x10);\n                    }\n                    *in_FS_OFFSET = aiStack20[0];\n                    return uStack28;\n                }\n            }\n            uStack12 = CONCAT31(uStack12._1_3_, 3);\n            fcn.00408fe0();\n        }\ncode_r0x00411162:\n        pcVar10 = *uStack4;\n        ppcVar14 = uStack4;\n        in_ram_fffffffd = iVar9;\n    } while( true );\n}\n",
        "token_count": 2143
    },
    "00411e20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00411e20(int32_t param_1, int32_t param_2)\n\n{\n    if (param_2 == 6) {\n        return 5;\n    }\n    if ((*(param_1 + 0xc4) == 0) && (param_2 == 9)) {\n        param_2 = 4;\n    }\n    return param_2;\n}\n",
        "token_count": 91
    },
    "004120d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004120d0(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    bool bVar1;\n    \n    if (param_2 != *(param_1 + 0xf4)) {\n        if ((param_2 == 5) || (param_2 == 6)) {\n            bVar1 = true;\n        }\n        else {\n            bVar1 = false;\n        }\n        *(param_1 + 0xec) = !bVar1;\n        if (param_3 != 0) {\n            *(param_1 + 0xf4) = param_2;\n            return;\n        }\n        fcn.00411ea0(*(param_1 + 0xf4));\n        *(param_1 + 0xf4) = param_2;\n        fcn.00411f00(param_2);\n    }\n    return;\n}\n",
        "token_count": 200
    },
    "0044ad04": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044ad04(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af6e(8);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((arg_8h_00 != 0) && (iVar1 = fcn.0044aa2d(arg_8h_00),  iVar1 == 0)) {\n        iVar1 = fcn.0044aa2d(arg_8h_00);\n        if (iVar1 == 0) {\n            uVar2 = fcn.00414adf(fcn.0044b07c);\n            *(unaff_EBP + -4) = 0;\n            *(unaff_EBP + 8) = uVar2;\n            iVar1 = fcn.00457c26();\n            if (iVar1 == 0) {\n                fcn.00416356();\n            }\n            (**(extraout_ECX + 0x14))(iVar1);\n            piVar3 = fcn.0044abf4(arg_8h_00);\n            uVar2 = *(unaff_EBP + 8);\n            *(unaff_EBP + -4) = 0xffffffff;\n            *piVar3 = iVar1;\n            fcn.00414adf(uVar2);\n            piVar3 = *(extraout_ECX + 0x58) + iVar1;\n            *piVar3 = arg_8h_00;\n            if (*(extraout_ECX + 0x5c) == 2) {\n                piVar3[1] = arg_8h_00;\n            }\n        }\n        else {\n            piVar3 = *(extraout_ECX + 0x58) + iVar1;\n            *piVar3 = arg_8h_00;\n            if (*(extraout_ECX + 0x5c) == 2) {\n                piVar3[1] = arg_8h_00;\n            }\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 518
    },
    "00412da0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00412da0(int32_t param_1)\n\n{\n    if ((*(param_1 + 0x50) != 3) && (*(param_1 + 0x50) != 4)) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 65
    },
    "004133c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004133c0(int32_t param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t arg_8h;\n    \n    *(param_1 + 0x1c8) = 1;\n    *(param_1 + 0x1c4) = 1;\n    arg_8h = param_1 + 0x2ec;\n    if (param_2 == 0) {\n        arg_8h = param_1 + 0x298;\n    }\n    fcn.0044236b(0, 0xffffffff);\n    fcn.00442447(arg_8h);\n    fcn.0044246a(arg_8h);\n    fcn.004424f6(param_1 + 0x1dc);\n    fcn.0044236b(0, 0);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x20), 0xcd, 0, 0);\n    (*pcVar1)(*(param_1 + 0x20), 0xb9, 0, 0);\n    return;\n}\n",
        "token_count": 272
    },
    "00413690": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00413690(int32_t param_1, int32_t param_2)\n\n{\n    if (*(param_1 + 0x1d0) != param_2) {\n        fcn.0041ae6e();\n        return;\n    }\n    (*_sym.imp.USER32.dll_KillTimer)(*(param_1 + 0x20), *(param_1 + 0x1d0));\n    *(param_1 + 0x1d0) = 0;\n    if (*(param_1 + 0x1d4) != 0) {\n        fcn.0043ad4a(0, 0, 0, 1);\n    }\n    *(param_1 + 0x1d4) = 0;\n    return;\n}\n",
        "token_count": 175
    },
    "00414c52": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.00414c52(int16_t *arg_8h, uint arg_ch, int16_t *arg_10h)\n\n{\n    if (arg_10h == NULL) {\n        arg_10h = fcn.0041638e();\n    }\n    if ((arg_8h == NULL) && (arg_ch != 0)) {\n        *(arg_10h + 2) = 0;\n        *(arg_10h + 6) = 0xffffffff;\n        *(arg_10h + 8) = 0xffffffff;\n        *arg_10h = arg_ch;\n        *(arg_10h + 4) = 1;\n        arg_8h = arg_10h;\n    }\n    return arg_8h;\n}\n",
        "token_count": 172
    },
    "00414d64": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00414d64(int32_t lpString, uint rclsid, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint hKey;\n    uint lplpsz;\n    \n    pcVar1 = _sym.imp.ole32.dll_CoTreatAsClass;\n    iVar2 = (*_sym.imp.ole32.dll_CoTreatAsClass)(rclsid, arg_10h);\n    if ((iVar2 != 0) && (lpString != 0)) {\n        fcn.00449dbb(0x80000000, \"CLSID\", &hKey);\n        lplpsz = 0;\n        (*_sym.imp.ole32.dll_StringFromCLSID)(rclsid, &lplpsz);\n        uVar3 = fcn.00449cd3(lplpsz);\n        uVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueA)(hKey, uVar3, 1, lpString, uVar4);\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(uVar3);\n        iVar2 = (*pcVar1)(rclsid, arg_10h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    }\n    return iVar2;\n}\n",
        "token_count": 317
    },
    "00414df0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00414df0(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar1 = arg_8h;\n    if (arg_8h != NULL) {\n        iVar2 = (**(*arg_8h + 0x58))(arg_8h, &var_8h);\n        if ((iVar2 != 0) || (var_8h != 1)) {\n            (**(*piVar1 + 4))(piVar1);\n            return piVar1;\n        }\n        arg_8h = NULL;\n        iVar2 = (**(*piVar1 + 0x30))(piVar1, 1, &arg_8h);\n        if (iVar2 == 0) {\n            var_4h = NULL;\n            (**(*arg_8h + 0xc))(arg_8h, 1, &var_4h, 0);\n            fcn.004469e6(&arg_8h);\n            return var_4h;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 263
    },
    "00414e59": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414e59(int32_t pv)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t var_ch;\n    int32_t *var_8h;\n    uint ppbc;\n    \n    uVar2 = 0;\n    if (pv == 0) {\n        uVar2 = 0;\n    }\n    else {\n        var_8h = fcn.00414df0(pv);\n        if (var_8h != NULL) {\n            iVar1 = (**(*var_8h + 0x58))(var_8h, &var_ch);\n            if ((iVar1 == 0) && (var_ch == 2)) {\n                ppbc = 0;\n                iVar1 = (*_sym.imp.ole32.dll_CreateBindCtx)(0, &ppbc);\n                if (iVar1 == 0) {\n                    pv = 0;\n                    iVar1 = (**(*var_8h + 0x50))(var_8h, ppbc, 0, &pv);\n                    if ((iVar1 == 0) && (pv != 0)) {\n                        uVar2 = fcn.0045ae91(pv);\n                        (*_sym.imp.ole32.dll_CoTaskMemFree)(pv);\n                    }\n                    fcn.004469e6(&ppbc);\n                }\n            }\n            fcn.004469e6(&var_8h);\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 320
    },
    "004150c6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004150c6(int32_t **param_1)\n\n{\n    int32_t **arg_8h;\n    \n    while (*param_1 != NULL) {\n        arg_8h = *param_1;\n        *param_1 = *arg_8h;\n        fcn.004585e6(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 83
    },
    "0041523b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0041523b(int32_t arg_8h, int32_t noname_1, int32_t noname_2, int32_t noname_3, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h, int32_t arg_2ch, int16_t *arg_30h, int16_t *arg_34h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint unaff_ESI;\n    uint var_24h;\n    uint var_20h;\n    uint hMem;\n    int16_t *var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    var_18h = arg_34h;\n    if (arg_30h == NULL) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_30h);\n        iVar2 = iVar2 + 1;\n    }\n    if ((arg_34h == NULL) || (*arg_34h == 0)) {\n        var_18h = arg_30h;\n        iVar3 = iVar2;\n    }\n    else {\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_34h);\n        iVar3 = iVar3 + 1;\n    }\n    iVar1 = (iVar3 + iVar2) * 2 + 0x34;\n    iVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2042, iVar1);\n    if (iVar4 != 0) {\n        piVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar4);\n        if (arg_30h == NULL) {\n            piVar5[0xb] = 0;\n        }\n        else {\n            piVar5[0xb] = 0x34;\n            fcn.0041500d(piVar5 + 0xd, iVar2, arg_30h);\n        }\n        if (var_18h == NULL) {\n            piVar5[0xc] = 0;\n        }\n        else {\n            iVar2 = iVar2 * 2 + 0x34;\n            piVar5[0xc] = iVar2;\n            fcn.0041500d(iVar2 + piVar5, iVar3, var_18h);\n        }\n        piVar5[1] = arg_8h;\n        piVar5[2] = noname_1;\n        piVar5[3] = noname_2;\n        *piVar5 = iVar1;\n        piVar5[5] = arg_18h;\n        piVar5[4] = noname_3;\n        piVar5[6] = arg_1ch;\n        piVar5[7] = arg_20h;\n        piVar5[8] = arg_24h;\n        piVar5[9] = arg_28h;\n        piVar5[10] = arg_2ch;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar4);\n    }\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 738
    },
    "004157ce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004157ce(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = *in_ECX;\n    if (arg_8h < *(iVar1 + -0xc)) {\n        arg_8h = *(iVar1 + -0xc);\n    }\n    if (*(iVar1 + -4) < 2) {\n        iVar1 = *(iVar1 + -8);\n        if (iVar1 < arg_8h) {\n            if (iVar1 < 0x401) {\n                iVar1 = iVar1 * 2;\n            }\n            else {\n                iVar1 = iVar1 + 0x400;\n            }\n            if (iVar1 < arg_8h) {\n                iVar1 = arg_8h;\n            }\n            fcn.00415783(iVar1);\n        }\n    }\n    else {\n        fcn.00415719(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 215
    },
    "0041584a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041584a(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (arg_8h == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.004150e1(arg_8h);\n    }\n    if (iVar1 < 1) {\n        fcn.004018d0();\n    }\n    else {\n        uVar2 = fcn.00401eb0(iVar1);\n        fcn.00401690(uVar2, iVar1, arg_8h, 0xffffffff);\n        fcn.00401660(iVar1);\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "00415c7c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415c7c(int32_t arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint arg_8h_01;\n    \n    if (arg_8h == 0) {\n        arg_8h_00 = 0;\n    }\n    else {\n        arg_8h_00 = fcn.0041504c(arg_8h);\n    }\n    if (arg_8h_00 < 1) {\n        fcn.004156e2();\n    }\n    else {\n        arg_8h_01 = fcn.0041581c(arg_8h_00);\n        fcn.00415066(arg_8h_01, arg_8h_00, arg_8h, 0xffffffff);\n        fcn.00415667(arg_8h_00);\n    }\n    return;\n}\n",
        "token_count": 192
    },
    "00415d61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00415d61(uint arg_8h, uint hMenu, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t unaff_EBP;\n    uint var_13ch;\n    uint var_138h;\n    uint var_134h;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint lpNewItem;\n    uint uIDNewItem;\n    uint uIDItem;\n    uint var_118h;\n    uint uPosition;\n    uint lpString;\n    uint var_4h;\n    \n    fcn.0045afa4(0x130);\n    puVar2 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x130) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x128) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x138) = 0;\n    *(unaff_EBP + -0x134) = 0;\n    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x13c) = iVar3;\n    *(unaff_EBP + -0x118) = 0;\n    *(unaff_EBP + -0x114) = 0;\n    if (*(unaff_EBP + 0x14) == 1) {\n        *(unaff_EBP + -0x114) = *puVar2;\n    }\n    *(unaff_EBP + -0x11c) = 0;\n    if (0 < iVar3) {\n        do {\n            uVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(*(unaff_EBP + -0x128), *(unaff_EBP + -0x11c));\n            *(unaff_EBP + -0x120) = uVar4;\n            uVar5 = (*_sym.imp.USER32.dll_GetMenuState)(*(unaff_EBP + -0x128), *(unaff_EBP + -0x11c), 0x400);\n            if ((*(unaff_EBP + -0x120) == 0) && ((uVar5 & 0x800) != 0)) {\n                iVar3 = *(unaff_EBP + 0x14);\n                puVar2[iVar3] = *(unaff_EBP + -0x118);\n                *(unaff_EBP + -0x118) = 0;\n                if (iVar3 < 5) {\n                    *(unaff_EBP + -0x114) = *(unaff_EBP + -0x114) + (puVar2 + iVar3)[1];\n                }\n                *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + 2;\n            }\n            else {\n                *(unaff_EBP + -300) = 0;\n                if ((*(unaff_EBP + 0x18) != 0) && ((*(unaff_EBP + 0x14) == 5 && (puVar2[5] == 1)))) {\n                    uVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(*(unaff_EBP + -0x130), *(unaff_EBP + -0x114));\n                    *(unaff_EBP + -300) = uVar4;\n                }\n                iVar3 = (*_sym.imp.USER32.dll_GetMenuStringA)\n                                  (*(unaff_EBP + -0x128), *(unaff_EBP + -0x11c), unaff_EBP + -0x110, 0x100, 0x400);\n                if (*(unaff_EBP + -0x120) == 0) {\n                    if (0 < iVar3) {\n                        iVar3 = unaff_EBP + -0x110;\n                        uVar4 = (*_sym.imp.USER32.dll_GetMenuItemID)\n                                          (*(unaff_EBP + -0x128), *(unaff_EBP + -0x11c), iVar3);\n                        uVar5 = uVar5 | 0x400;\ncode_r0x00415f75:\n                        (*_sym.imp.USER32.dll_InsertMenuA)\n                                  (*(unaff_EBP + -0x130), *(unaff_EBP + -0x114), uVar5, uVar4, iVar3);\n                        *(unaff_EBP + -0x114) = *(unaff_EBP + -0x114) + 1;\n                        *(unaff_EBP + -0x118) = *(unaff_EBP + -0x118) + 1;\n                    }\n                }\n                else if (*(unaff_EBP + -300) == 0) {\n                    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(unaff_EBP + -0x120));\n                    if (iVar3 != 0) {\n                        iVar3 = unaff_EBP + -0x110;\n                        uVar4 = *(unaff_EBP + -0x120);\n                        uVar5 = uVar5 & 0xff | 0x410;\n                        goto code_r0x00415f75;\n                    }\n                }\n                else {\n                    iVar3 = fcn.0042052a();\n                    fcn.00404920(*(iVar3 + 0x10));\n                    *(unaff_EBP + -4) = 0;\n                    if (*(*(unaff_EBP + -0x124) + -0xc) != 0) {\n                        fcn.00404420(0x20);\n                    }\n                    fcn.004061b0(unaff_EBP + -0x110);\n                    uVar4 = *(unaff_EBP + -0x120);\n                    (*_sym.imp.USER32.dll_AppendMenuA)(*(unaff_EBP + -300), 0x10, uVar4, *(unaff_EBP + -0x124));\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    puVar1 = puVar2 + *(unaff_EBP + 0x14);\n                    *puVar1 = 0;\n                    puVar1[-1] = puVar1[-1] + 1;\n                    *(unaff_EBP + -0x138) = 1;\n                    *(unaff_EBP + -0x134) = uVar4;\n                    fcn.004010f0();\n                }\n            }\n            *(unaff_EBP + -0x11c) = *(unaff_EBP + -0x11c) + 1;\n        } while (*(unaff_EBP + -0x11c) < *(unaff_EBP + -0x13c));\n        if (*(unaff_EBP + -0x138) != 0) goto code_r0x00415fc0;\n    }\n    puVar2[*(unaff_EBP + 0x14)] = *(unaff_EBP + -0x118);\ncode_r0x00415fc0:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 1602
    },
    "00416286": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00416286(int32_t *param_1)\n\n{\n    if (0 < param_1[1]) {\n        (**(*param_1 + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 49
    },
    "0041664d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041664d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uStack12;\n    uchar *puStack8;\n    \n    while( true ) {\n        if (arg_ch == 0) {\n            return;\n        }\n        arg_ch = arg_ch + -1;\n        if (arg_8h == 0) break;\n        puStack8 = 0x416665;\n        fcn.00401e60();\n        arg_8h = arg_8h + 4;\n    }\n    uStack12 = 0x496e18;\n    puStack8 = &stack0xfffffffc;\n    fcn.004593a9(&stack0xfffffff4, 0x48c300);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 192
    },
    "004166aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004166aa(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uStack12;\n    uchar *puStack8;\n    \n    puStack8 = &stack0xfffffffc;\n    while( true ) {\n        if (arg_ch == 0) {\n            return;\n        }\n        arg_ch = arg_ch + -1;\n        if (arg_8h == 0) break;\n        uStack12 = 0x4166c4;\n        fcn.00416627(0);\n        arg_8h = arg_8h + 4;\n    }\n    uStack12 = 0x496e18;\n    fcn.004593a9(&stack0xfffffff4, 0x48c300);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 194
    },
    "004169c6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004169c6(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    uint arg_8h_01;\n    int32_t unaff_EBP;\n    uint var_124h;\n    uint var_120h;\n    uint var_11ch;\n    uint var_118h;\n    uint var_114h;\n    uint var_94h;\n    uint var_90h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x118);\n    *(unaff_EBP + -0x120) = arg_8h_01;\n    arg_8h_00 = fcn.00439065(arg_8h_01, unaff_EBP + -0x124);\n    if (*(unaff_EBP + -0x124) == 1) {\n        fcn.00416676(arg_8h_00);\n        *(unaff_EBP + -4) = 0;\n        iVar1 = fcn.00438cbd(*(unaff_EBP + -0x118), arg_8h_00);\n        if (iVar1 != arg_8h_00) goto code_r0x00416a1c;\n    }\n    else {\n        fcn.00416690(arg_8h_00);\n        *(unaff_EBP + -4) = 2;\n        iVar1 = fcn.00438cbd(*(unaff_EBP + -0x94), arg_8h_00 * 2);\n        if (iVar1 == arg_8h_00 * 2) {\n            uVar2 = fcn.0041680b(*(unaff_EBP + -0x94), arg_8h_00);\n            *(unaff_EBP + -4) = 3;\n            fcn.00407a00(uVar2);\n            fcn.004010f0();\n            if (*(unaff_EBP + -0x94) != unaff_EBP + -0x90) {\n                fcn.004164de();\n            }\n            goto code_r0x00416adc;\n        }\ncode_r0x00416a1c:\n        fcn.0043f8ce(3, 0);\n    }\n    uVar2 = fcn.00416605(*(unaff_EBP + -0x118), arg_8h_00);\n    *(unaff_EBP + -4) = 1;\n    fcn.00407a00(uVar2);\n    fcn.004010f0();\n    if (*(unaff_EBP + -0x118) != unaff_EBP + -0x114) {\n        fcn.004164de();\n    }\ncode_r0x00416adc:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 635
    },
    "00417426": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00417426(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    iVar1 = fcn.0042055d();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00414adf(fcn.0044b07c);\n        iVar2 = fcn.00414af6(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.0044ac7b(0x47a560, fcn.004173c9, fcn.00416fae, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar3;\n        fcn.00414adf(arg_8h_00);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 329
    },
    "00417517": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00417517(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.004174e4();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 87
    },
    "0041752d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041752d(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CDC.0;\n    if (param_1[1] != NULL) {\n        uVar1 = fcn.004174e4();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "004176f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004176f8(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    iVar1 = fcn.0042055d();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00414adf(fcn.0044b07c);\n        iVar2 = fcn.00414af6(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.0044ac7b(0x47a5d0, fcn.004173ea, fcn.00416fae, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar3;\n        fcn.00414adf(arg_8h_00);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 329
    },
    "004177d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004177d8(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.004177ac();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 87
    },
    "00417f1e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00417f1e(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) != 0) {\n    // WARNING: Could not recover jumptable at 0x00417f2f. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x4c) + 0x98))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 119
    },
    "00417f3b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00417f3b(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) != 0) {\n    // WARNING: Could not recover jumptable at 0x00417f4c. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x4c) + 0x54))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 119
    },
    "00417f55": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417f55(uint nIDDlgItem)\n\n{\n    uint arg_8h;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        arg_8h = (*_sym.imp.USER32.dll_GetDlgItem)(*(in_ECX + 0x20), nIDDlgItem);\n        fcn.0041af14(arg_8h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00417f7c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x74))();\n    return;\n}\n",
        "token_count": 161
    },
    "00417f7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417f7f(uint nIDDlgItem, uint *arg_ch)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(in_ECX + 0x20), nIDDlgItem);\n        *arg_ch = uVar1;\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00417fa5. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x70))();\n    return;\n}\n",
        "token_count": 160
    },
    "00417fa8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417fa8(uint nIDDlgItem, uint lpString)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_SetDlgItemTextA)(*(in_ECX + 0x20), nIDDlgItem, lpString);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00417fcc. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x88))();\n    return;\n}\n",
        "token_count": 143
    },
    "00418009": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418009(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x20), 0xfffffff0);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00418020. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0x78))();\n    return;\n}\n",
        "token_count": 126
    },
    "00418023": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418023(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x20), 0xffffffec);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0041803a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0x7c))();\n    return;\n}\n",
        "token_count": 127
    },
    "0041803d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041803d(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        fcn.00418ce8(*(in_ECX + 0x20), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00418063. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x80))();\n    return;\n}\n",
        "token_count": 147
    },
    "00418069": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418069(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        fcn.00418d04(*(in_ECX + 0x20), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0041808f. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x84))();\n    return;\n}\n",
        "token_count": 147
    },
    "00418095": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418095(uint lpString)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (in_ECX != 0) goto code_r0x004180a6;\n    while( true ) {\n        fcn.0041638e();\ncode_r0x004180a6:\n        iVar1 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x20));\n        if (iVar1 != 0) break;\n        if (*(in_ECX + 0x50) != 0) {\ncode_r0x004180b8:\n    // WARNING: Could not recover jumptable at 0x004180bf. Too many branches\n    // WARNING: Treating indirect jump as call\n            (**(**(in_ECX + 0x50) + 0x88))();\n            return;\n        }\n    }\n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowTextA)(*(in_ECX + 0x20), lpString);\n        return;\n    }\n    goto code_r0x004180b8;\n}\n",
        "token_count": 255
    },
    "004180dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004180dc(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_1 + 0x20));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004180f1. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0x90))();\n    return;\n}\n",
        "token_count": 121
    },
    "004180f7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004180f7(uint dwNewLong)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(in_ECX + 0x20), 0xfffffff4, dwNewLong);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0041811a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x94))();\n    return;\n}\n",
        "token_count": 139
    },
    "00418120": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418120(uint X, uint Y, uint nWidth, uint nHeight, uint bRepaint)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_MoveWindow)(*(in_ECX + 0x20), X, Y, nWidth, nHeight, bRepaint);\n    }\n    else {\n        (**(**(in_ECX + 0x50) + 0x98))(X, Y, nWidth, nHeight);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00418160": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418160(uint nCmdShow)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(*(in_ECX + 0x20), nCmdShow);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00418181. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0xa0))();\n    return;\n}\n",
        "token_count": 129
    },
    "00418187": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418187(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x20));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0041819c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0xa4))();\n    return;\n}\n",
        "token_count": 120
    },
    "004181a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004181a2(uint bEnable)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(*(in_ECX + 0x20), bEnable);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004181c3. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0xa8))();\n    return;\n}\n",
        "token_count": 129
    },
    "004181c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004181c9(int32_t param_1)\n\n{\n    uint arg_8h;\n    \n    if (*(param_1 + 0x50) == 0) {\n        arg_8h = (*_sym.imp.USER32.dll_SetFocus)(*(param_1 + 0x20));\n        fcn.0041af14(arg_8h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004181e4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0xb0))();\n    return;\n}\n",
        "token_count": 146
    },
    "004181ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004181ea(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x50) == 0) && (*(arg_8h + 0x4c) != 0)) {\n        (**(**(arg_8h + 0x4c) + 0x9c))();\n    }\n    return;\n}\n",
        "token_count": 96
    },
    "0041822e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041822e(int32_t arg_8h, uint X, uint Y, uint cx, uint cy, uint uFlags)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        if (arg_8h != 0) {\n            arg_8h = *(arg_8h + 0x20);\n        }\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(in_ECX + 0x20), arg_8h, X, Y, cx, cy, uFlags);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00418266. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x9c))();\n    return;\n}\n",
        "token_count": 194
    },
    "0041826c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041826c(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((in_ECX != 0) && (*(in_ECX + 0x50) == 0)) {\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        iVar1 = fcn.0044aa2d(arg_8h_00);\n        if ((iVar1 != 0) && (*(iVar1 + 0x4c) != 0)) {\n            (**(**(iVar1 + 0x4c) + 0x9c))();\n        }\n    }\n    return;\n}\n",
        "token_count": 170
    },
    "004182b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.004182b0(uint lpString, uint nMaxCount)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    if (*(extraout_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(extraout_ECX + 0x20), *(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    }\n    else {\n        fcn.00401e60();\n        iVar1 = **(extraout_ECX + 0x50);\n        *(unaff_EBP + -4) = 0;\n        (**(iVar1 + 0x8c))(unaff_EBP + -0x10);\n        fcn.0041502b(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x10), 0xffffffff);\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 319
    },
    "00418323": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00418323(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    if (*(extraout_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(extraout_ECX + 0x20));\n    }\n    else {\n        fcn.00401e60();\n        iVar1 = **(extraout_ECX + 0x50);\n        *(unaff_EBP + -4) = 0;\n        (**(iVar1 + 0x8c))(unaff_EBP + -0x10);\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 211
    },
    "00418373": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00418373(void)\n\n{\n    uint *arg_8h;\n    uint lpVersionInformation;\n    uint var_94h;\n    uint var_88h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.00458b20(&var_94h, 0, 0x90);\n    arg_8h = &lpVersionInformation;\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 143
    },
    "0041861d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.0041861d(int32_t *arg_8h, int32_t arg_ch, uint noname_2, uint noname_3, uint32_t arg_18h, uint32_t *arg_1ch, \n            uint *arg_20h, uint noname_7, uint *arg_28h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    code *pcVar4;\n    int32_t *piVar5;\n    uint32_t *puVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t *piVar10;\n    ushort uVar11;\n    uint var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_34h;\n    uint var_30h;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint var_20h;\n    int32_t pvargDest;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar6 = arg_1ch;\n    piVar5 = arg_8h;\n    iVar9 = 0;\n    var_20h._0_2_ = 0;\n    if (arg_8h == NULL) {\n        return -0x7ff8ffa9;\n    }\n    if (arg_1ch == NULL) {\n        return -0x7ffdfff8;\n    }\n    uVar2 = arg_1ch[2];\n    if (5 < uVar2) {\n        return -0x7ffdfff2;\n    }\n    arg_8h = NULL;\n    if (arg_1ch[3] != 0) {\n        arg_1ch = arg_1ch[1];\n        do {\n            uVar3 = *arg_1ch;\n            if (uVar2 <= uVar3) {\n                return -0x7ffdfff2;\n            }\n            arg_1ch = arg_1ch + 1;\n            arg_8h = arg_8h + 1;\n            (&var_44h)[uVar3] = *puVar6 + iVar9;\n            iVar9 = iVar9 + 0x10;\n        } while (arg_8h < puVar6[3]);\n    }\n    if (arg_8h < uVar2) {\n        iVar9 = arg_8h * 0x10 + *puVar6;\n        iVar8 = uVar2 - arg_8h;\n        piVar10 = &var_48h + (uVar2 - arg_8h);\n        do {\n            *piVar10 = iVar9;\n            iVar9 = iVar9 + 0x10;\n            piVar10 = piVar10 + -1;\n            iVar8 = iVar8 + -1;\n        } while (iVar8 != 0);\n    }\n    iVar9 = -0x7ffdfffd;\n    if (arg_28h == NULL) {\n        arg_28h = &arg_18h;\n    }\n    if (arg_20h == NULL) {\n        arg_20h = &var_20h;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantClear)(&pvargDest);\n    pcVar4 = _sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime;\n    if (0x12 < arg_ch + 0x139aU) goto code_r0x00418b88;\n    // switch table (19 cases) at 0x418b9d\n    switch(*((arg_ch + 0x139aU) * 4 + 0x418b9d)) {\n    case 0x4186fe:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 100))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3]);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x41871f:\n        if (puVar6[2] == 2) {\n            if (*var_44h != 3) {\n                iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_44h, 0, 3);\n                if (iVar9 < 0) goto code_r0x00418923;\n                var_44h = &pvargDest;\n            }\n            arg_18h = var_44h[2];\n            if (*var_40h != 3) {\n                iVar9 = (*pcVar4)(&pvargDest, var_40h, 0, 3);\n                if (iVar9 < 0) {\ncode_r0x00418b0a:\n                    *arg_28h = 1;\n                    goto code_r0x00418b88;\n                }\n                var_40h = &pvargDest;\n            }\n            iVar9 = (**(*piVar5 + 0x60))(piVar5, arg_18h, var_40h[2], arg_20h);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x41878c:\n        if (puVar6[2] == 2) {\n            if (*var_44h != 3) {\n                iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_44h, 0, 3);\n                if (iVar9 < 0) goto code_r0x00418923;\n                var_44h = &pvargDest;\n            }\n            iVar9 = (**(*piVar5 + 0x5c))(piVar5, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x4187d9:\n        if (puVar6[2] == 5) {\n            while ((uVar1 = *var_44h,  (uVar1 & 0x4000) != 0 && ((uVar1 & 0xf) != 0))) {\n                if ((uVar1 & 0xc) == 0) {\n                    pvargDest = var_44h[2];\n                }\n                else {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                    *var_44h[2] = 3;\n                    pvargDest = var_44h[2] + 8;\n                }\n            }\n            *arg_28h = 0;\n            iVar9 = (**(*piVar5 + 0x58))\n                              (piVar5, pvargDest, var_ch, var_8h, var_4h, *var_34h, var_34h[1], var_34h[2], var_34h[3]);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x418844:\n        if (puVar6[2] == 2) {\n            if (*var_44h != 3) {\n                iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_44h, 0, 3);\n                if (iVar9 < 0) goto code_r0x00418923;\n                var_44h = &pvargDest;\n            }\n            iVar9 = (**(*piVar5 + 0x54))(piVar5, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3]);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x41888e:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x50))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\ncode_r0x004188b1:\n            if (iVar9 < 0) goto code_r0x00418b88;\n            uVar11 = 8;\n            goto code_r0x00418b81;\n        }\n        break;\n    case 0x4188c2:\n        iVar9 = (**(*piVar5 + 0x4c))(piVar5, arg_20h);\n        goto code_r0x00418b88;\n    case 0x4188d0:\n        iVar9 = (**(*piVar5 + 0x48))(piVar5, arg_20h);\n        goto code_r0x00418b88;\n    case 0x4188de:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x44))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x004188b1;\n        }\n        break;\n    case 0x418903:\n        if (puVar6[2] == 2) {\n            uVar1 = *var_44h;\n            if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {\n                iVar9 = -0x7ffdfffb;\ncode_r0x00418923:\n                *arg_28h = 0;\n                goto code_r0x00418b88;\n            }\n            if (uVar1 == 0x400c) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                *var_44h[2] = 8;\n                puVar7 = var_44h[2] + 8;\n            }\n            else if (uVar1 == 0x4008) {\n                puVar7 = var_44h[2];\n            }\n            else {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h);\n                puVar7 = var_44h + 2;\n                *var_44h = 8;\n            }\n            iVar9 = (**(*piVar5 + 0x40))(piVar5, puVar7, *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h + 2);\n            goto code_r0x0041898a;\n        }\n        break;\n    case 0x41899b:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x3c))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x004188b1;\n        }\n        break;\n    case 0x4189c3:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x38))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x4189e7:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x34))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00418b88;\n        }\n        break;\n    case 0x418a0b:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x30))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x004188b1;\n        }\n        break;\n    case 0x418a33:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00418ab0;\n            if (puVar6[2] == 2) {\n                var_30h = *var_44h;\n                uStack48 = var_44h[1];\n                uStack44 = var_44h[2];\n                uStack40 = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_40h, 0, 3);\n                    if (iVar9 < 0) goto code_r0x00418b0a;\n                    var_40h = &pvargDest;\n                }\n                iVar9 = (**(*piVar5 + 0x6c))(piVar5, var_30h, uStack48, uStack44, uStack40, var_40h[2]);\n                goto code_r0x00418b88;\n            }\n        }\n        else if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x2c))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x004188b1;\n        }\n        break;\n    case 0x418ab0:\ncode_r0x00418ab0:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00418b32;\n            if (puVar6[2] == 2) {\n                var_30h = *var_44h;\n                uStack48 = var_44h[1];\n                uStack44 = var_44h[2];\n                uStack40 = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_40h, 0, 3);\n                    if (iVar9 < 0) goto code_r0x00418b0a;\n                    var_40h = &pvargDest;\n                }\n                iVar9 = (**(*piVar5 + 0x68))(piVar5, var_30h, uStack48, uStack44, uStack40, var_40h[2]);\n                goto code_r0x00418b88;\n            }\n        }\n        else if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x28))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x004188b1;\n        }\n        break;\n    case 0x418b32:\ncode_r0x00418b32:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x24))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00418b79;\n        }\n        break;\n    case 0x418b5a:\n        iVar9 = (**(*piVar5 + 0x20))(piVar5, arg_20h + 2);\ncode_r0x0041898a:\n        if (iVar9 < 0) goto code_r0x00418b88;\n        uVar11 = 3;\n        goto code_r0x00418b81;\n    case 0x418b6c:\n        iVar9 = (**(*piVar5 + 0x1c))(piVar5, arg_20h + 2);\ncode_r0x00418b79:\n        if (iVar9 < 0) goto code_r0x00418b88;\n        uVar11 = 9;\ncode_r0x00418b81:\n        *arg_20h = uVar11;\n        goto code_r0x00418b88;\n    }\n    iVar9 = -0x7ffdfff2;\ncode_r0x00418b88:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&pvargDest);\n    return iVar9;\n}\n",
        "token_count": 3815
    },
    "00418be9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.00418be9(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint noname_3, int32_t arg_18h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_1h;\n    \n    uVar3 = 0;\n    if (arg_10h != 0) {\n        do {\n            bVar1 = false;\n            uVar4 = 0;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(*(arg_ch + uVar3 * 4), *(uVar4 + 0x497008));\n                if (iVar2 == 0) {\n                    bVar1 = true;\n                    *(arg_18h + uVar3 * 4) = *(uVar4 + 0x496fb8);\n                }\n                uVar4 = uVar4 + 4;\n            } while (uVar4 < 0x4c);\n            if (!bVar1) {\n                return 0x80020006;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < arg_10h);\n    }\n    return 0;\n}\n",
        "token_count": 302
    },
    "00418e3e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00418e3e(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 169
    },
    "00418ef7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00418ef7(int32_t arg_8h, uint *lpsi, uint redraw)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = in_ECX[8];\n    if (arg_8h != 2) {\n        iVar1 = (**(*in_ECX + 0x78))(arg_8h);\n        if (iVar1 != 0) {\n            iVar2 = *(iVar1 + 0x20);\n            arg_8h = 2;\n        }\n    }\n    *lpsi = 0x1c;\n    (*_sym.imp.USER32.dll_SetScrollInfo)(iVar2, arg_8h, lpsi, redraw);\n    return 1;\n}\n",
        "token_count": 172
    },
    "00418f37": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418f37(int32_t arg_8h, uint *lpsi, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = in_ECX[8];\n    if (arg_8h != 2) {\n        iVar1 = (**(*in_ECX + 0x78))(arg_8h);\n        if (iVar1 != 0) {\n            iVar2 = *(iVar1 + 0x20);\n            arg_8h = 2;\n        }\n    }\n    *lpsi = 0x1c;\n    lpsi[1] = arg_10h;\n    (*_sym.imp.USER32.dll_GetScrollInfo)(iVar2, arg_8h, lpsi);\n    return;\n}\n",
        "token_count": 183
    },
    "00418f77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418f77(int32_t *arg_8h, uint hWnd, int32_t *lprc2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint lpRect;\n    uint var_8h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(hWnd);\n    if ((arg_8h == NULL) || (*arg_8h != 0)) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n        pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar2, &lpRect);\n        (*pcVar1)(uVar2, &var_8h);\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprc2);\n        if (iVar3 == 0) {\n            if (arg_8h == NULL) {\n                (*_sym.imp.USER32.dll_SetWindowPos)\n                          (hWnd, 0, *lprc2, lprc2[1], lprc2[2] - *lprc2, lprc2[3] - lprc2[1], 0x14);\n            }\n            else {\n                iVar3 = (*_sym.imp.USER32.dll_DeferWindowPos)(*arg_8h);\n                *arg_8h = iVar3;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 335
    },
    "00419005": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419005(uint lpRect, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    \n    uVar1 = fcn.00418023();\n    if (arg_ch == 0) {\n        uVar1 = uVar1 & 0xfffffdff;\n    }\n    uVar2 = fcn.00418009(0, uVar1);\n    (*_sym.imp.USER32.dll_AdjustWindowRectEx)(lpRect, uVar2);\n    return;\n}\n",
        "token_count": 117
    },
    "0041936d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041936d(int32_t hdc, uint arg_ch, int32_t arg_10h, int32_t hgdiobj, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint lpvObject;\n    uint crColor;\n    \n    if ((((hdc == 0) || (hgdiobj == 0)) || (arg_10h == 1)) || ((arg_10h == 0 || (arg_10h == 5)))) {\ncode_r0x004193de:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.0044b0cf(arg_ch, 2);\n            if (iVar1 == 0) goto code_r0x004193de;\n        }\n        (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0xc, &lpvObject);\n        (*_sym.imp.GDI32.dll_SetBkColor)(hdc, crColor);\n        if (arg_18h == -1) {\n            arg_18h = (*_sym.imp.USER32.dll_GetSysColor)(8);\n        }\n        (*_sym.imp.GDI32.dll_SetTextColor)(hdc, arg_18h);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 304
    },
    "0041954e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0041954e(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "004195e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004195e4(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "00419678": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00419678(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "00419727": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00419727(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "004197be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004197be(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "0041984c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0041984c(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "00419a9d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419a9d(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    \n    iVar4 = fcn.0042055d();\n    if ((*(iVar4 + 0x3c) != 0) && (iVar1 = *(*(iVar4 + 0x3c) + 0x20),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar1, 0x401, 0, 0);\n    }\n    piVar2 = *(iVar4 + 0x50);\n    if ((arg_8h != 0) && (piVar2 != NULL)) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar3) {\n            (**(*piVar2 + 0x178))(0xffffffff);\n        }\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "00419d0b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419d0b(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (arg_8h == 3) {\n        fcn.00419d0b(0, arg_ch);\n        arg_8h = 1;\n    }\n    iVar1 = (**(*in_ECX + 0x78))(arg_8h);\n    if (iVar1 == 0) {\n        fcn.004198a6(arg_8h, arg_ch);\n    }\n    else {\n        fcn.004181a2(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 148
    },
    "00419d98": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419d98(uint XAmount, int32_t YAmount, int32_t arg_10h, int32_t lpClipRect)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint uVar4;\n    uint lpRect;\n    int32_t Y;\n    uint uStack12;\n    \n    iVar3 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x20));\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (((iVar3 == 0) && (arg_10h == 0)) && (lpClipRect == 0)) {\n        uVar4 = 5;\n        iVar3 = *(in_ECX + 0x20);\n        while (iVar3 = (*pcVar1)(iVar3, uVar4),  iVar3 != 0) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar3, &fcn.00419d98::lpRect);\n            uStack12 = 0x419ddf;\n            fcn.004172a1(&fcn.00419d98::lpRect);\n            iVar2 = Y;\n            uStack12 = 0x15;\n            Y = 0;\n            lpRect = 0;\n            (*_sym.imp.USER32.dll_SetWindowPos)(iVar3, 0, XAmount, iVar2 + YAmount);\n            uVar4 = 2;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_ScrollWindow)(*(in_ECX + 0x20), XAmount, YAmount, arg_10h, lpClipRect);\n    }\n    if ((*(in_ECX + 0x4c) != 0) && (arg_10h == 0)) {\n        (**(**(in_ECX + 0x4c) + 0x5c))(XAmount, YAmount);\n    }\n    return;\n}\n",
        "token_count": 434
    },
    "00419e44": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00419e44(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (arg_8h == 0) {\n        iVar1 = fcn.0042055d();\n        if ((*(iVar1 + 0x48) != 0) && ((*(*(iVar1 + 0x48) + 4) & 0x40000000) == 0)) {\n            fcn.00419a9d(1);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 116
    },
    "0041ac5f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041ac5f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(*(param_1 + 0xc));\n        *(param_1 + 4) = iVar1;\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(*(param_1 + 0xc));\n            *(param_1 + 4) = iVar1;\n            *(param_1 + 8) = iVar1 != 0;\n        }\n    }\n    return *(param_1 + 4);\n}\n",
        "token_count": 161
    },
    "0041ac93": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ac93(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        uVar1 = fcn.0041ac5f(\"InitCommonControls\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x10) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x10);\n    return;\n}\n",
        "token_count": 128
    },
    "0041ad25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0041ad25(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) != 2) {\n        fcn.0041fc5e(0, *(unaff_EBP + -0x1c));\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "0041ad36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ad36(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) == 0) {\n        uVar1 = fcn.0041ac5f(\"InitCommonControlsEx\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x14) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x14);\n    return;\n}\n",
        "token_count": 129
    },
    "0041adda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0041adda(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "0041aea0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041aea0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    iVar1 = fcn.0042055d();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00414adf(fcn.0044b07c);\n        iVar2 = fcn.00414af6(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.0044ac7b(0x47a968, 0x41ac38, fcn.00416fae, 0x20, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar3;\n        fcn.00414adf(arg_8h_00);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 329
    },
    "0041afcd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0041afcd(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.0044a7e2(0x4163aa);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    iVar2 = fcn.0042052a();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x28) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x28));\n        *(iVar1 + 0x28) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 193
    },
    "0041b057": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041b057(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    \n    iVar2 = fcn.004379b3();\n    if (iVar2 == 0) goto code_r0x0041b0a4;\n    if (*(iVar2 + 0x20) == param_1) {\n        iVar3 = fcn.0042052a();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.0042052a();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.00441d41();\n                if (iVar3 == 0) goto code_r0x0041b099;\n            }\n            fcn.0043e2fc(0);\n        }\ncode_r0x0041b099:\n        *(iVar2 + 0x20) = 0;\n    }\n    if (*(iVar2 + 0x24) == param_1) {\n        *(iVar2 + 0x24) = 0;\n    }\ncode_r0x0041b0a4:\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 0x50))();\n        param_1[0x12] = 0;\n    }\n    if (param_1[0x13] != NULL) {\n        (**(*param_1[0x13] + 4))(1);\n    }\n    param_1[0x13] = 0;\n    if ((*(param_1 + 0xf) & 1) != 0) {\n        iVar2 = fcn.0042055d();\n        iVar2 = *(iVar2 + 0x3c);\n        if ((iVar2 != 0) && (*(iVar2 + 0x20) != 0)) {\n            fcn.00458b20(&var_30h, 0, 0x30);\n            var_28h = param_1[8];\n            var_30h = 0x2c;\n            var_2ch = 1;\n            var_24h = var_28h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x20), 0x405, 0, &var_30h);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[8], 0xfffffffc);\n    fcn.0041ae6e();\n    iVar3 = (*pcVar1)(param_1[8], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0xf8))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[8], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.0041af9d();\n    (**(*param_1 + 0x11c))();\n    return;\n}\n",
        "token_count": 746
    },
    "0041b2fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0041b2fb(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h, int32_t *lprcDst, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t in_ECX;\n    int32_t hWinPosInfo;\n    int32_t lprcSrc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = arg_20h;\n    var_ch = 0;\n    var_10h = 0;\n    if (arg_1ch == NULL) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lprcSrc);\n    }\n    else {\n        lprcSrc = *arg_1ch;\n        var_1ch = arg_1ch[1];\n        var_18h = arg_1ch[2];\n        var_14h = arg_1ch[3];\n    }\n    uVar2 = arg_14h & 0xffff7fff;\n    if (uVar2 == 1) {\n        hWinPosInfo = 0;\n    }\n    else {\n        hWinPosInfo = (*_sym.imp.USER32.dll_BeginDeferWindowPos)(8);\n    }\n    for (iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(*(in_ECX + 0x20)); iVar3 != 0;\n        iVar3 = (*_sym.imp.USER32.dll_GetWindow)(iVar3, 2)) {\n        uVar4 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar3);\n        iVar5 = fcn.0041af40(iVar3);\n        iVar1 = iVar3;\n        if ((((uVar4 != arg_10h) && (iVar1 = var_4h,  arg_8h <= uVar4)) && (uVar4 <= arg_ch)) && (iVar5 != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageA)(iVar3, 0x361, 0, &hWinPosInfo);\n            iVar1 = var_4h;\n        }\n        var_4h = iVar1;\n    }\n    if (uVar2 == 1) {\n        if (arg_20h == 0) {\n            lprcDst[2] = var_10h;\n            lprcDst[1] = 0;\n            *lprcDst = 0;\n            lprcDst[3] = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_CopyRect)(lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        if ((arg_10h != 0) && (var_4h != 0)) {\n            piVar6 = fcn.0041af14(var_4h);\n            if (uVar2 == 2) {\n                lprcSrc = lprcSrc + *lprcDst;\n                var_1ch = var_1ch + lprcDst[1];\n                var_18h = var_18h - lprcDst[2];\n                var_14h = var_14h - lprcDst[3];\n            }\n            if ((arg_14h & 0x8000) == 0) {\n                (**(*piVar6 + 0x68))(&lprcSrc, 0);\n                fcn.00418f77(&hWinPosInfo, var_4h, &lprcSrc);\n            }\n        }\n        if (hWinPosInfo != 0) {\n            (*_sym.imp.USER32.dll_EndDeferWindowPos)(hWinPosInfo);\n        }\n    }\n    return;\n}\n",
        "token_count": 934
    },
    "00430dd2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00430dd2(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(param_1 + 0xb0) != 0) {\n        fcn.004181c9();\n        return;\n    }\n    if ((*(param_1 + 0x4c) != 0) && (iVar1 = (**(**(param_1 + 0x4c) + 0x90))(),  iVar1 != 0)) {\n        return;\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 128
    },
    "0041b559": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041b559(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 9) != '\\0') {\n        var_4h = NULL;\n        iVar2 = (**(*in_ECX + 0xec))(arg_8h, arg_ch, &var_4h);\n        if (-1 < iVar2) {\n            return var_4h;\n        }\n    }\n    piVar1 = fcn.0041ae6e();\n    return piVar1;\n}\n",
        "token_count": 163
    },
    "0041b723": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.0041b723(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t extraout_EDX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_44h;\n    uint var_28h;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x38);\n    iVar1 = fcn.0044a7e2(0x4163aa);\n    iVar4 = 0;\n    *(unaff_EBP + -0x18) = iVar1;\n    if (iVar1 == 0) {\n        fcn.0041638e();\n        iVar4 = extraout_EDX;\n    }\n    puVar5 = iVar1 + 0x58;\n    puVar6 = unaff_EBP + -0x44;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(iVar1 + 0x58) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x60) = *(unaff_EBP + 0x14);\n    uVar2 = *(unaff_EBP + 0x18);\n    *(iVar1 + 0x5c) = iVar3;\n    *(iVar1 + 100) = uVar2;\n    *(unaff_EBP + -4) = iVar4;\n    if ((iVar3 == 2) && (arg_8h_00[0x13] != iVar4)) {\n        (**(*arg_8h_00[0x13] + 0x60))(iVar4);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.004199c4(arg_8h_00, unaff_EBP + -0x28, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h_00 + 0x110))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.0041b6ad(arg_8h_00, unaff_EBP + -0x28, *(unaff_EBP + 8));\n    }\n    puVar5 = unaff_EBP + -0x44;\n    puVar6 = iVar1 + 0x58;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 808
    },
    "0041b863": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041b863(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[8] != NULL) && (extraout_ECX != 0x49bc00)) && (extraout_ECX != 0x49bc58)) &&\n       ((extraout_ECX != 0x49bcb0 && (extraout_ECX != 0x49bd08)))) {\n        fcn.0041b16a();\n    }\n    if (extraout_ECX[0x13] != NULL) {\n        (**(*extraout_ECX[0x13] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0x14];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x28) == extraout_ECX)) {\n        *(pcVar1 + 0x28) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041e889();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 339
    },
    "0041b905": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b905(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    \n    if (*arg_ch == 1) {\n        iVar1 = fcn.0044a7e2(0x4163aa);\n        if (iVar1 != 0) goto code_r0x0041b92e;\n        do {\n            iVar1 = fcn.0041638e();\ncode_r0x0041b92e:\n            if (*(iVar1 + 0x74) == in_ECX[8]) {\n                iVar1 = fcn.00429dc9();\n            }\n            else {\n                iVar1 = (**(*in_ECX + 0x6c))();\n            }\n        } while (iVar1 == 0);\n        piVar2 = fcn.00419b49(iVar1, arg_ch[2]);\n        if (piVar2 != NULL) {\n            (**(*piVar2 + 0x10))(arg_ch);\n        }\n    }\n    else {\n        iVar1 = fcn.0041b282(in_ECX[8], arg_ch[1], 1);\n        if ((iVar1 != 0) && (iVar1 = fcn.0041b48d(0),  iVar1 != 0)) {\n            return;\n        }\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 323
    },
    "0041b9cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0041b9cd(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[8] != 0)) {\n        iVar2 = (**(*param_1 + 0x128))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.0041b98e();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.0041b98e();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 189
    },
    "0041ba0e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ba0e(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.0041af40(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0041b723(iVar2, *(iVar2 + 0x20), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0041ba0e(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 331
    },
    "0041bb2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041bb2d(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    \n    if (((arg_8h == 1) || (arg_8h == 2)) && (iVar1 = fcn.0041ba8d(arg_ch, 0),  iVar1 != 0)) {\n        return;\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 98
    },
    "0041bb89": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0041bb89(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_8ch;\n    uint hWnd;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x80);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0041e777();\n    fcn.0041997f();\n    uVar2 = *(extraout_ECX + 0x20);\n    *(unaff_EBP + -4) = 0;\n    iVar1 = (*_sym.imp.USER32.dll_GetTopWindow)(uVar2);\n    do {\n        if (iVar1 == 0) {\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(unaff_EBP + -0x6c) = 0;\n            fcn.0041b863();\n            fcn.0045b013();\n            return;\n        }\n        *(unaff_EBP + -0x6c) = iVar1;\n        uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar1);\n        *(unaff_EBP + -0x34) = uVar2;\n        *(unaff_EBP + -0x24) = unaff_EBP + -0x8c;\n        iVar3 = fcn.0041af40(iVar1);\n        if (iVar3 == 0) {\ncode_r0x0041bbf9:\n            iVar3 = fcn.0041e5f9(*(unaff_EBP + -0x34), 0xffffffff, unaff_EBP + -0x38, 0);\n            if (iVar3 == 0) {\n                iVar3 = *(unaff_EBP + 0xc);\n                if (iVar3 != 0) {\n                    uVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(unaff_EBP + -0x6c), 0x87, 0, 0);\n                    if ((uVar4 & 0x2000) != 0) {\n                        uVar4 = fcn.00418009();\n                        uVar4 = uVar4 & 0xf;\n                        if ((((uVar4 != 3) && (uVar4 != 6)) && (uVar4 != 7)) && (uVar4 != 9)) goto code_r0x0041bc51;\n                    }\n                    iVar3 = 0;\n                }\ncode_r0x0041bc51:\n                fcn.0041e79d(*(unaff_EBP + 8), iVar3);\n            }\n        }\n        else {\n            iVar3 = fcn.0041e5f9(0, 0xbd11ffff, unaff_EBP + -0x38, 0);\n            if (iVar3 == 0) goto code_r0x0041bbf9;\n        }\n        iVar1 = (*_sym.imp.USER32.dll_GetWindow)(iVar1, 2);\n    } while( true );\n}\n",
        "token_count": 811
    },
    "0041bc8a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041bc8a(uint hWnd)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.0041af61(hWnd);\n    if (iVar1 != 0) {\n        (**(*in_ECX + 0x50))();\n        piVar2 = (**(*in_ECX + 0xf8))();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(hWnd, 0xfffffffc, fcn.0041b816);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 166
    },
    "0041bcd0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041bcd0(uint nIDDlgItem, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(arg_ch + 0x20), nIDDlgItem);\n    if (iVar1 == 0) {\n        if ((*(arg_ch + 0x4c) == 0) || (iVar1 = (**(**(arg_ch + 0x4c) + 0x54))(nIDDlgItem),  iVar1 == 0)) {\n            uVar2 = 0;\n        }\n        else {\n            fcn.0041bc8a(*(iVar1 + 0x24));\n            iVar1 = (*_sym.imp.USER32.dll_GetParent)(*(iVar1 + 0x24));\n            if (*(arg_ch + 0x20) != iVar1) {\n                fcn.004181ea(arg_ch, 0);\n            }\n            uVar2 = 1;\n        }\n    }\n    else {\n        uVar2 = fcn.0041bc8a(iVar1);\n    }\n    return uVar2;\n}\n",
        "token_count": 255
    },
    "0041c2d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c2d9(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(in_ECX + 0x20));\n        uVar2 = fcn.004090c0(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(in_ECX + 0x20), uVar2);\n        fcn.00409070(0xffffffff);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0041c31d. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x8c))();\n    return;\n}\n",
        "token_count": 209
    },
    "0041c323": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c323(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    if ((*arg_ch == 1) && (piVar1 = fcn.00429ddd(arg_ch[5]),  piVar1 != NULL)) {\n        (**(*piVar1 + 0xc))(arg_ch);\n        return;\n    }\n    iVar2 = fcn.0041ba8d(arg_ch[5], 0);\n    if (iVar2 == 0) {\n        fcn.0041ae6e();\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "0041c3b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c3b6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    fcn.0044b9be(0xc);\n    iVar1 = fcn.0044a2be(0x41b698);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    if (*(iVar1 + 8) == 0) {\n        iVar2 = fcn.004197f3(\"hhctrl.ocx\");\n        *(iVar1 + 4) = iVar2;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"HtmlHelpA\");\n            *(iVar1 + 8) = iVar2;\n            if (iVar2 != 0) goto code_r0x0041c41b;\n            (*_sym.imp.KERNEL32.dll_FreeLibrary)(*(iVar1 + 4));\n            *(iVar1 + 4) = 0;\n        }\n        uVar3 = 0;\n    }\n    else {\ncode_r0x0041c41b:\n        fcn.0044ba30(0xc);\n        uVar3 = (**(iVar1 + 8))(arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    return uVar3;\n}\n",
        "token_count": 326
    },
    "0041c5c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c5c3(uint32_t wParam, int32_t lParam)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint arg_8h;\n    int32_t in_ECX;\n    uint32_t uVar6;\n    uint hWnd;\n    \n    iVar4 = fcn.0041c59b();\n    uVar6 = wParam & 0xfff0;\n    if ((uVar6 == 0xf040) || (uVar6 == 0xf050)) {\n        if (lParam != 0x75) {\n            return 0;\n        }\n        if (iVar4 == 0) {\n            return 0;\n        }\n        fcn.004181c9();\n    }\n    else {\n        if ((uVar6 != 0xf060) && (uVar6 != 0xf100)) {\n            return 0;\n        }\n        if (((uVar6 == 0xf060) || (lParam != 0)) && (iVar4 != 0)) {\n            uVar1 = *(in_ECX + 0x20);\n            uVar5 = (*_sym.imp.USER32.dll_GetFocus)();\n            pcVar2 = _sym.imp.USER32.dll_SetActiveWindow;\n            arg_8h = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar4 + 0x20));\n            fcn.0041af14(arg_8h);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x20), 0x112, wParam, lParam);\n            pcVar3 = _sym.imp.USER32.dll_IsWindow;\n            iVar4 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar4 != 0) {\n                (*pcVar2)(uVar1);\n            }\n            iVar4 = (*pcVar3)(uVar5);\n            if (iVar4 != 0) {\n                (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 462
    },
    "0041c7c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041c7c5(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    uVar1 = (**(**(param_1 + 0xc) + 0xc))(*(param_1 + 0xc), 0);\n    return uVar1;\n}\n",
        "token_count": 91
    },
    "0041c7da": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c7da(int32_t *arg_8h)\n\n{\n    uint uVar1;\n    \n    if ((((*arg_8h == 0) && (arg_8h[1] == 0)) && (arg_8h[2] == 0xc0)) && (arg_8h[3] == 0x46000000)) {\n        uVar1 = 1;\n    }\n    else {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 117
    },
    "0041c80a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041c80a(int32_t arg_8h, int32_t *arg_ch, uint arg_10h, int32_t **arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if ((arg_8h == 0) || (arg_ch == NULL)) {\n        iVar2 = -0x7ff8ffa9;\n    }\n    else if (arg_14h == NULL) {\n        iVar2 = -0x7fffbffd;\n    }\n    else {\n        *arg_14h = NULL;\n        iVar2 = fcn.0041c7da(arg_10h);\n        if (iVar2 == 0) {\n            for (; pcVar1 = arg_ch[2],  pcVar1 != NULL; arg_ch = arg_ch + 3) {\n                iVar2 = *arg_ch;\n                if ((iVar2 == 0) || (iVar3 = fcn.0041c793(iVar2, arg_10h),  iVar3 != 0)) {\n                    if (pcVar1 == 0x1) goto code_r0x0041c840;\n                    iVar3 = (*pcVar1)(arg_8h, arg_10h, arg_14h, arg_ch[1]);\n                    if (iVar3 == 0) {\n                        return 0;\n                    }\n                    if ((iVar2 != 0) && (iVar3 < 0)) {\n                        return iVar3;\n                    }\n                }\n            }\n            iVar2 = -0x7fffbffe;\n        }\n        else {\ncode_r0x0041c840:\n            piVar4 = arg_ch[1] + arg_8h;\n            (**(*piVar4 + 4))(piVar4);\n            *arg_14h = piVar4;\n            iVar2 = 0;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 431
    },
    "00441dca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00441dca(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.0042052a();\n    iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(iVar2 + 0x2c);\n    if (iVar2 != 0) {\n        return;\n    }\n    iVar2 = fcn.0042052a();\n    if (*(iVar2 + 0x30) == 0) {\n        fcn.00441d61(1);\n        iVar2 = fcn.0042052a();\n        iVar2 = *(iVar2 + 4);\n        if ((iVar2 == 0) || (*(iVar2 + 0x20) == 0)) {\n            iVar2 = fcn.0042052a();\n            if (*(iVar2 + 0x14) == '\\0') {\n                fcn.0043e2fc(0);\n            }\n        }\n        else {\n            iVar1 = fcn.00418187();\n            if (iVar1 != 0) {\n    // WARNING: Could not recover jumptable at 0x00441db3. Too many branches\n    // WARNING: Treating indirect jump as call\n                (**(**(iVar2 + 0x20) + 0x60))();\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 300
    },
    "0041ce25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ce25(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.0044a7e2(0x4163aa);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    if (*(iVar1 + 0x14) != arg_8h) {\n        if (*(iVar1 + 0x28) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, 0x41cbd2, 0, uVar2);\n            *(iVar1 + 0x28) = iVar3;\n            if (iVar3 == 0) {\n                fcn.00416356();\n            }\n        }\n        *(iVar1 + 0x14) = arg_8h;\n    }\n    return;\n}\n",
        "token_count": 224
    },
    "0041cfdc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0041cfdc(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    code **ppcVar6;\n    uint32_t uVar7;\n    int32_t *arg_8h_00;\n    code *pcVar8;\n    int32_t unaff_EBP;\n    int16_t iVar9;\n    int16_t iVar10;\n    uint var_7ch;\n    uint var_5ch;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint *var_24h;\n    uint *var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x70);\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = 0x7fffffff;\n    uVar7 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    if (uVar7 == 0x111) {\n        iVar3 = (**(*arg_8h_00 + 0xf0))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar3 == 0) goto code_r0x0041d1ec;\n        goto code_r0x0041d01a;\n    }\n    if (uVar7 == 0x4e) {\n        if (**(unaff_EBP + 0x10) != 0) {\n            iVar3 = (**(*arg_8h_00 + 0xf4))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\n            goto joined_r0x0041d4c5;\n        }\n        goto code_r0x0041d1ec;\n    }\n    var_24h = *(unaff_EBP + 0x10);\n    if (uVar7 == 6) {\n        uVar4 = fcn.0041af14(var_24h);\n        fcn.0041c995(arg_8h_00, *(unaff_EBP + 0xc), uVar4);\n    }\n    iVar9 = var_24h;\n    if ((uVar7 == 0x20) && (iVar3 = fcn.0041ca0d(arg_8h_00, iVar9, var_24h >> 0x10),  iVar3 != 0))\n    goto code_r0x0041d01a;\n    if ((((arg_8h_00[0x13] != 0) && (0 < *(arg_8h_00[0x13] + 0x74))) &&\n        ((((0x1ff < uVar7 && (uVar7 < 0x20a)) || ((0xff < uVar7 && (uVar7 < 0x110)))) || (uVar7 - 0x281 < 0x11)))) &&\n       (iVar3 = (**(*arg_8h_00[0x13] + 0x94))(uVar7, *(unaff_EBP + 0xc), var_24h, unaff_EBP + -0x10),  iVar3 != 0))\n    goto code_r0x0041d57e;\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    uVar7 = *(unaff_EBP + 8);\n    *(unaff_EBP + 0x10) = uVar5;\n    fcn.0041992f(7);\n    iVar3 = ((uVar5 ^ uVar7) & 0x1ff) * 0xc;\n    *(unaff_EBP + -0x18) = iVar3 + 0x49a3d0;\n    if ((*(unaff_EBP + 8) != *(iVar3 + 0x49a3d0)) || (*(unaff_EBP + 0x10) != *(iVar3 + 0x49a3d8))) {\n        puVar1 = *(unaff_EBP + -0x18);\n        ppcVar6 = *(unaff_EBP + 0x10);\n        *puVar1 = *(unaff_EBP + 8);\n        puVar1[2] = ppcVar6;\n        while (*ppcVar6 != NULL) {\n            if (*(unaff_EBP + 8) < 0xc000) {\n                iVar3 = fcn.00418e3e(ppcVar6[1], *(unaff_EBP + 8), 0, 0);\n                *(unaff_EBP + 0x10) = iVar3;\n                if (iVar3 != 0) {\n                    *(*(unaff_EBP + -0x18) + 4) = iVar3;\n                    fcn.00419963();\n                    goto code_r0x0041d17a;\n                }\n            }\n            else {\n                iVar3 = *(*(unaff_EBP + 0x10) + 4);\n                uVar4 = 0xc000;\n                while (iVar3 = fcn.00418e3e(iVar3, uVar4, 0, 0),  iVar3 != 0) {\n                    if (**(iVar3 + 0x10) == *(unaff_EBP + 8)) {\n                        *(*(unaff_EBP + -0x18) + 4) = iVar3;\n                        fcn.00419963();\n                        goto code_r0x0041d570;\n                    }\n                    iVar3 = iVar3 + 0x18;\n                }\n                ppcVar6 = *(unaff_EBP + 0x10);\n            }\n            ppcVar6 = (**ppcVar6)();\n            *(unaff_EBP + 0x10) = ppcVar6;\n        }\n        *(*(unaff_EBP + -0x18) + 4) = 0;\n        fcn.00419963();\n        goto code_r0x0041d1ec;\n    }\n    iVar3 = *(iVar3 + 0x49a3d4);\n    *(unaff_EBP + 0x10) = iVar3;\n    fcn.00419963();\n    if (iVar3 == 0) goto code_r0x0041d1ec;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x0041d570:\n        pcVar8 = *(iVar3 + 0x14);\n        goto code_r0x0041d574;\n    }\ncode_r0x0041d17a:\n    pcVar8 = *(*(unaff_EBP + 0x10) + 0x14);\n    iVar3 = *(*(unaff_EBP + 0x10) + 0x10);\n    iVar10 = var_24h >> 0x10;\n    var_14h = var_24h;\n    // switch table (84 cases) at 0x41d5a0\n    switch(iVar3) {\n    case 1:\n        var_14h = *(unaff_EBP + 0xc);\n        fcn.0041749a(var_14h);\n        goto code_r0x0041d21b;\n    case 2:\n    case 3:\n    case 4:\n    case 0x1b:\n    case 0x1c:\n        var_14h = *(unaff_EBP + 0xc);\n        goto code_r0x0041d21b;\n    case 5:\n    case 0xc:\n        var_14h = var_24h >> 0x10;\n        var_18h = var_24h & 0xffff;\n        uVar7 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.0041af14(uVar7);\n        goto code_r0x0041d250;\n    case 6:\n    case 0x47:\n        var_24h = *(unaff_EBP + 0xc);\n        var_28h = fcn.0041af14(var_24h);\n        goto code_r0x0041d577;\n    case 7:\n    case 0xd:\n    case 0x4a:\ncode_r0x0041d21b:\n        uVar4 = (*pcVar8)(var_14h);\n        goto code_r0x0041d57b;\n    case 8:\n        fcn.00417038();\n        uVar4 = var_24h[1];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x24) = uVar4;\n        fcn.0041997f();\n        uVar4 = *var_24h;\n        uVar2 = var_24h[2];\n        *(unaff_EBP + -4) = 2;\n        *(unaff_EBP + -0x5c) = uVar4;\n        iVar3 = fcn.0041af40(uVar4);\n        if (iVar3 == 0) {\n            if ((arg_8h_00[0x13] != 0) && (iVar3 = fcn.0044aa2d(*(unaff_EBP + -0x5c)),  iVar3 != 0)) {\n                *(unaff_EBP + -0x2c) = iVar3;\n            }\n            iVar3 = unaff_EBP + -0x7c;\n        }\n        uVar4 = (*pcVar8)(unaff_EBP + -0x28, iVar3, uVar2);\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x5c) = 0;\n        *(unaff_EBP + -0x10) = uVar4;\n        *(unaff_EBP + -4) = 1;\n        fcn.0041b863();\n        goto code_r0x0041d2d5;\n    case 9:\n        fcn.00417038();\n        uVar4 = var_24h[2];\n        *(unaff_EBP + -0x24) = var_24h[1];\n        *(unaff_EBP + -4) = 3;\n        uVar4 = (*pcVar8)(unaff_EBP + -0x28, uVar4);\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x10) = uVar4;\ncode_r0x0041d2d5:\n        *(unaff_EBP + -4) = 0;\n        fcn.0041752d();\n        break;\n    case 10:\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = fcn.0041af14(var_24h);\n        var_18h = var_24h;\n        goto code_r0x0041d319;\n    case 0xb:\n        var_24h = *(unaff_EBP + 0xc) >> 0x10;\n        var_28h = *(unaff_EBP + 0xc);\n        goto code_r0x0041d577;\n    case 0xe:\n    case 0x2f:\n    case 0x4f:\n        goto code_r0x0041d574;\n    case 0xf:\n        var_18h = fcn.00429dc9(var_24h);\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0041d319:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x0041d250:\n        uVar4 = (*pcVar8)(uVar5, uVar7, var_18h, var_14h);\n        goto code_r0x0041d57b;\n    case 0x10:\n    case 0x12:\n    case 0x15:\n    case 0x1e:\n    case 0x2d:\n    case 0x32:\n    case 0x4c:\n    case 0x53:\n        goto code_r0x0041d559;\n    case 0x11:\n    case 0x14:\n    case 0x54:\n        var_14h = *(unaff_EBP + 0xc);\n        goto code_r0x0041d345;\n    case 0x13:\n        (*pcVar8)();\n        break;\n    case 0x16:\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        var_18h = *(unaff_EBP + 0xc);\n        goto code_r0x0041d55c;\n    case 0x17:\n        var_14h = iVar10;\n        var_18h = iVar9;\n        goto code_r0x0041d55c;\n    case 0x18:\n    case 0x19:\n        var_14h = var_24h >> 0x10;\n        var_18h = var_24h & 0xffff;\n        goto code_r0x0041d37d;\n    case 0x1a:\n        fcn.0041af14(var_24h);\n        goto code_r0x0041d559;\n    case 0x1d:\n    case 0x28:\n    case 0x31:\n        uVar4 = (*pcVar8)();\n        goto code_r0x0041d57b;\n    case 0x1f:\n        var_14h = *(unaff_EBP + 0xc);\n        var_18h = fcn.0041af14(var_14h);\n        fcn.0041af14(var_24h);\n        uVar7 = arg_8h_00[8] == var_24h;\n        goto code_r0x0041d381;\n    case 0x20:\n        var_14h = *(unaff_EBP + 0xc);\n        fcn.0041749a(var_14h);\n        goto code_r0x0041d345;\n    case 0x21:\n        var_14h = *(unaff_EBP + 0xc);\n        fcn.00429dc9(var_14h);\n        goto code_r0x0041d345;\n    case 0x22:\n        var_14h = iVar10;\n        var_18h = iVar9;\n        uVar7 = fcn.00429dc9(*(unaff_EBP + 0xc), var_18h, var_14h);\n        goto code_r0x0041d381;\n    case 0x23:\n        var_14h = *(unaff_EBP + 0xc);\n        goto code_r0x0041d3d2;\n    case 0x24:\ncode_r0x0041d3d2:\n        fcn.0041af14(var_14h);\n        goto code_r0x0041d345;\n    case 0x25:\n        var_14h = var_24h >> 0x10;\n        var_18h = var_24h & 0xffff;\n        goto code_r0x0041d3e5;\n    case 0x26:\n        var_18h = iVar9;\n        var_14h = iVar10;\ncode_r0x0041d3e5:\n        uVar7 = fcn.0041af14(*(unaff_EBP + 0xc));\n        goto code_r0x0041d381;\n    case 0x27:\n        var_18h = fcn.0041af14(*(unaff_EBP + 0xc));\n        goto code_r0x0041d55c;\n    case 0x29:\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        var_18h = fcn.0041af14(var_24h);\n        goto code_r0x0041d417;\n    case 0x2a:\n    case 0x2b:\n        var_18h = *(unaff_EBP + 0xc);\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        *(unaff_EBP + 8) = var_18h;\n        *(unaff_EBP + 0xc) = var_14h;\n        if (iVar3 == 0x2a) {\n            var_18h = fcn.0041af14(var_24h);\n            uVar7 = *(unaff_EBP + 0xc);\n            var_14h = var_24h;\n            goto code_r0x0041d381;\n        }\n        goto code_r0x0041d55c;\n    case 0x2c:\n    case 0x33:\ncode_r0x0041d345:\n        (*pcVar8)(var_14h);\n        break;\n    case 0x2e:\n    case 0x36:\n    case 0x52:\n        (*pcVar8)(*(unaff_EBP + 0xc), var_24h);\n        goto code_r0x0041d01a;\n    case 0x30:\n    case 0x46:\n        var_28h = iVar9;\n        var_24h = iVar10;\n        goto code_r0x0041d577;\n    case 0x34:\n        var_18h = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0041d417:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0041d381;\n    case 0x35:\n        var_18h = iVar9;\n        var_14h = iVar10;\ncode_r0x0041d37d:\n        uVar7 = *(unaff_EBP + 0xc);\ncode_r0x0041d381:\n        (*pcVar8)(uVar7, var_18h, var_14h);\n        break;\n    case 0x37:\n        iVar3 = (*pcVar8)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, iVar9, iVar10);\n        *(unaff_EBP + -0x10) = iVar3;\n        goto joined_r0x0041d4c5;\n    case 0x38:\n        (*pcVar8)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, iVar9, iVar10);\n        break;\n    case 0x45:\n        iVar3 = (*pcVar8)();\n        *(unaff_EBP + -0x10) = iVar3;\njoined_r0x0041d4c5:\n        if (iVar3 != 0) {\ncode_r0x0041d1ec:\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00419963();\n            goto code_r0x0041d1fa;\n        }\n        break;\n    case 0x48:\n        fcn.00429dc9(var_24h);\ncode_r0x0041d559:\n        var_18h = *(unaff_EBP + 0xc);\n        goto code_r0x0041d55c;\n    case 0x49:\n        var_24h = fcn.00429dc9(var_24h);\n        goto code_r0x0041d574;\n    case 0x4b:\n        var_18h = fcn.00429dc9(*(unaff_EBP + 0xc), var_24h);\n        goto code_r0x0041d55c;\n    case 0x4d:\n        var_14h = var_24h & 0xffff;\n        var_18h = var_24h >> 0x10 & 0xf000;\n        uVar5 = var_24h >> 0x10 & 0xfff;\n        uVar7 = fcn.0041af14(*(unaff_EBP + 0xc));\n        goto code_r0x0041d516;\n    case 0x4e:\n        var_18h = *(unaff_EBP + 0xc);\ncode_r0x0041d55c:\n        (*pcVar8)(var_18h, var_14h);\n        break;\n    case 0x50:\n        var_18h = iVar9;\n        var_14h = iVar10;\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0041d516;\n    case 0x51:\n        var_18h = iVar9;\n        var_14h = iVar10;\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\ncode_r0x0041d516:\n        (*pcVar8)(uVar7, uVar5, var_18h, var_14h);\ncode_r0x0041d01a:\n        *(unaff_EBP + -0x10) = 1;\n    }\ncode_r0x0041d57e:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00419963();\ncode_r0x0041d1fa:\n    fcn.0045b013();\n    return;\ncode_r0x0041d574:\n    var_28h = *(unaff_EBP + 0xc);\ncode_r0x0041d577:\n    uVar4 = (*pcVar8)(var_28h, var_24h);\ncode_r0x0041d57b:\n    *(unaff_EBP + -0x10) = uVar4;\n    goto code_r0x0041d57e;\n}\n",
        "token_count": 5041
    },
    "0041d85a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041d85a(int32_t param_1)\n\n{\n    *0x49a3c8 = 0;\n    if (*(param_1 + 0x4c) != 0) {\n        (**(**(param_1 + 0x4c) + 0x50))(0xfffffd3f);\n    }\n    fcn.0041c71b(0, 0);\n    return;\n}\n",
        "token_count": 98
    },
    "0041dae0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041dae0(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    \n    fcn.004024f0(0x476744);\n    if (*(in_ECX + 0x4c) == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(in_ECX + 0x20));\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(iVar1);\n            uVar3 = fcn.004090c0(iVar2, iVar2 + 1);\n            (*_sym.imp.USER32.dll_GetWindowTextA)(iVar1, uVar3);\n            fcn.00409070(0xffffffff);\n        }\n    }\n    else {\n        iVar1 = fcn.00417f55(arg_8h);\n        if (iVar1 != 0) {\n            fcn.0041c2d9(arg_ch);\n        }\n    }\n    return *(*arg_ch + -0xc);\n}\n",
        "token_count": 252
    },
    "0041db54": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041db54(uint arg_8h)\n\n{\n    int32_t lpWndClass;\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_38h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x30);\n    lpWndClass = *(unaff_EBP + 8);\n    iVar2 = fcn.00419585(*(lpWndClass + 0x10), *(lpWndClass + 0x24), unaff_EBP + -0x38);\n    if (((iVar2 == 0) && (iVar1 = fcn.004194f3(lpWndClass),  iVar1 != 0)) &&\n       (iVar2 = fcn.0042052a(),  *(iVar2 + 0x14) != '\\0')) {\n        fcn.0044b9be(1);\n        *(unaff_EBP + -4) = 0;\n        fcn.0042052a();\n        fcn.00406b70(*(lpWndClass + 0x24));\n        fcn.00404420(10);\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0044ba30(1);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 313
    },
    "0041e147": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041e147(int32_t arg_8h)\n\n{\n    if (*(arg_8h + 0x28) == 0) {\n        fcn.0041de55(1);\n        *(arg_8h + 0x28) = \"AfxWnd90s\";\n    }\n    return 1;\n}\n",
        "token_count": 77
    },
    "0041e5f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041e5f9(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    code **ppcVar5;\n    int32_t *in_ECX;\n    int32_t *piVar6;\n    uint32_t arg_ch_00;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.0042052a();\n        if (*(iVar1 + 0x3c) != 0) goto code_r0x0041e619;\n    }\n    else {\n        if (arg_ch != 0xfffffffd) {\n            if (arg_ch != 0xffffffff) {\n                uVar4 = arg_ch & 0xffff;\n                arg_ch_00 = arg_ch >> 0x10;\n                arg_ch = uVar4;\n                if (arg_ch_00 != 0) goto code_r0x0041e6d1;\n            }\n            arg_ch_00 = 0x111;\ncode_r0x0041e6d1:\n            ppcVar5 = (**(*in_ECX + 0x28))();\n            while( true ) {\n                if (*ppcVar5 == NULL) {\n                    return 0;\n                }\n                iVar1 = fcn.00418e3e(ppcVar5[1], arg_ch_00, arg_ch, arg_8h);\n                if (iVar1 != 0) break;\n                ppcVar5 = (**ppcVar5)();\n            }\n            iVar1 = fcn.0041e4c1(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n            return iVar1;\n        }\n        arg_ch = 0;\n        if (arg_10h != 0) {\n            iVar1 = *(arg_10h + 0x30);\n            puVar2 = (**(*in_ECX + 0x2c))();\n            do {\n                if (puVar2 == NULL) {\n                    return arg_ch;\n                }\n                if (arg_ch != 0) {\n                    return arg_ch;\n                }\n                piVar6 = puVar2[1];\n                while (((piVar6[1] != 0 && (piVar6[2] != 0)) && (arg_ch == 0))) {\n                    if (arg_8h == piVar6[1]) {\n                        if (iVar1 == 0) {\n                            if (*piVar6 == 0) {\ncode_r0x0041e696:\n                                *(arg_10h + 4) = piVar6[2];\n                                arg_ch = 1;\n                            }\n                        }\n                        else if ((*piVar6 != 0) && (iVar3 = fcn.00412cb0(iVar1, *piVar6),  iVar3 != 0))\n                        goto code_r0x0041e696;\n                    }\n                    piVar6 = piVar6 + 3;\n                }\n                puVar2 = *puVar2;\n            } while( true );\n        }\n    }\n    fcn.0041638e();\ncode_r0x0041e619:\n    iVar1 = fcn.0042052a();\n    iVar1 = (**(**(iVar1 + 0x3c) + 4))();\n    return iVar1;\n}\n",
        "token_count": 776
    },
    "0041ec27": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0041ec27(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[8] != NULL) {\n        fcn.0041b16a();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b863();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 165
    },
    "0041ecf4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041ecf4(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x68) == 0) {\n        *(in_ECX + 0x68) = arg_ch;\n    }\n    *(in_ECX + 0x5c) = arg_8h;\n    return 1;\n}\n",
        "token_count": 90
    },
    "0041f557": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041f557(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x58) = arg_8h;\n    if (((arg_8h & 0xffff0000) == 0) && (*(in_ECX + 0x54) == 0)) {\n        *(in_ECX + 0x54) = arg_8h & 0xffff;\n    }\n    iVar1 = fcn.0042052a();\n    uVar3 = *(iVar1 + 0xc);\n    uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar3, arg_8h, 5);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar3, uVar2);\n    uVar3 = fcn.0041f518(uVar2, arg_ch, uVar3);\n    (*_sym.imp.KERNEL32.dll_FreeResource)(uVar2);\n    return uVar3;\n}\n",
        "token_count": 250
    },
    "0041f630": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041f630(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t arg_10h_00;\n    int32_t iVar3;\n    \n    if (arg_ch == 0) {\n        uVar1 = 0;\n    }\n    else {\n        if (arg_10h != 0) {\n            do {\n                arg_10h = arg_10h + -1;\n                arg_ch = fcn.0045aaaf(arg_ch, arg_14h);\n                if (arg_ch == 0) {\n                    fcn.004018d0();\n                    return 0;\n                }\n                arg_ch = arg_ch + 1;\n            } while (arg_10h != 0);\n        }\n        iVar2 = fcn.0045aaaf(arg_ch, arg_14h);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n        }\n        else {\n            iVar2 = iVar2 - arg_ch;\n        }\n        arg_10h_00 = iVar2;\n        iVar3 = iVar2;\n        uVar1 = fcn.004090c0();\n        fcn.00414fcb(uVar1, iVar2, arg_10h_00, arg_ch);\n        fcn.00409070(0xffffffff, iVar3);\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 343
    },
    "0041f781": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** __cdecl fcn.0041f781(int32_t **arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    \n    piVar1 = (**(**arg_8h + 0x10))();\n    ppiVar2 = arg_8h + 3;\n    if ((*ppiVar2 < 0) || (piVar1 != *arg_8h)) {\n        ppiVar2 = (***piVar1)(arg_8h[1], 2);\n        if (ppiVar2 == NULL) {\n            fcn.00415694();\n        }\n        ppiVar2[1] = arg_8h[1];\n        fcn.00414faa(ppiVar2 + 4, arg_8h[1] + 1, arg_8h + 4, arg_8h[1] + 1);\n    }\n    else {\n        LOCK();\n        *ppiVar2 = *ppiVar2 + 1;\n        ppiVar2 = arg_8h;\n    }\n    return ppiVar2;\n}\n",
        "token_count": 244
    },
    "0041f7e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f7e1(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t arg_8h_00;\n    int32_t *in_ECX;\n    uint32_t uVar2;\n    \n    if (arg_ch == 0) {\n        fcn.004156e2();\n    }\n    else {\n        if (arg_8h == 0) {\n            fcn.00401000(0x80070057);\n        }\n        uVar1 = *(*in_ECX + -0xc);\n        uVar2 = arg_8h - *in_ECX >> 1;\n        arg_8h_00 = fcn.0041581c(arg_ch);\n        if (uVar1 < uVar2) {\n            fcn.00414faa(arg_8h_00, *(*in_ECX + -8), arg_8h, arg_ch);\n        }\n        else {\n            fcn.0041f72f(arg_8h_00, *(*in_ECX + -8), arg_8h_00 + uVar2 * 2, arg_ch);\n        }\n        fcn.00415667(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 274
    },
    "0041f854": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f854(int32_t *arg_8h)\n\n{\n    int32_t *arg_8h_00;\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *piVar2;\n    \n    iVar1 = *arg_8h;\n    arg_8h_00 = iVar1 + -0x10;\n    piVar2 = *in_ECX + -0x10;\n    if (arg_8h_00 != piVar2) {\n        if ((*(*in_ECX + -4) < 0) || (*arg_8h_00 != *piVar2)) {\n            fcn.0041f7e1(iVar1, *(iVar1 + -0xc));\n        }\n        else {\n            iVar1 = fcn.0041f781(arg_8h_00);\n            fcn.004010f0();\n            *in_ECX = iVar1 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 221
    },
    "0041f8be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f8be(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.00409ef0();\n    if (piVar1 != NULL) {\n        iVar2 = (**(*piVar1 + 0x128))();\n        if ((iVar2 != 0) && (piVar1[0x20] != NULL)) {\n            (**(*piVar1[0x20] + 100))(arg_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 126
    },
    "0041f8f7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041f8f7(int32_t arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = arg_8h;\n    if (arg_8h != 0) goto code_r0x0041f927;\n    iVar3 = fcn.0041f8b2();\n    if ((iVar3 == 0) && (iVar3 = fcn.00409ef0(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar5 = iVar3;\n        iVar6 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x20); iVar5 = iVar3,  iVar6 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x0041f927:\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            iVar5 = iVar3;\n            iVar6 = iVar3;\n            if ((uVar4 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar5,  iVar1 != 0) {\n        iVar5 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((arg_8h == 0) && (iVar6 != 0)) {\n        iVar6 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar6);\n    }\n    if (arg_ch != NULL) {\n        if (((iVar3 == 0) || (iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar5 == 0)) || (iVar3 == iVar6))\n        {\n            *arg_ch = 0;\n        }\n        else {\n            *arg_ch = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 490
    },
    "0041f9a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041f9a9(int32_t arg_8h, uint arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t hWnd_00;\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *lpCaption;\n    uint *arg_ch_00;\n    uint var_11ch;\n    uint var_118h;\n    int32_t lpdwProcessId;\n    int32_t var_110h;\n    int32_t hWnd;\n    uint var_108h;\n    uchar var_5h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0041f8be(0);\n    arg_ch_00 = &hWnd;\n    hWnd_00 = fcn.0041f8f7(0, arg_ch_00);\n    if (hWnd_00 != hWnd) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd_00, 1);\n    }\n    lpdwProcessId = 0;\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(hWnd_00, &lpdwProcessId);\n    if ((((hWnd_00 == 0) || (iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(),  lpdwProcessId != iVar1)) ||\n        (piVar2 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd_00, 0x376, 0, 0),  piVar2 == NULL)) &&\n       (piVar2 = NULL,  arg_8h != 0)) {\n        piVar2 = arg_8h + 0x78;\n    }\n    var_110h = 0;\n    if ((piVar2 != NULL) && (var_110h = *piVar2,  arg_14h != 0)) {\n        *piVar2 = arg_14h + 0x30000;\n    }\n    if ((arg_10h & 0xf0) == 0) {\n        if ((arg_10h & 0xf) < 2) {\n            arg_10h = arg_10h | 0x30;\n        }\n        else if ((arg_10h & 0xf) - 3 < 2) {\n            arg_10h = arg_10h | 0x20;\n        }\n    }\n    var_108h._0_1_ = 0;\n    if (arg_8h == 0) {\n        lpCaption = &var_108h;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, lpCaption, 0x104);\n        if (iVar1 == 0x104) {\n            var_5h = 0;\n        }\n    }\n    else {\n        lpCaption = *(arg_8h + 0x50);\n    }\n    fcn.0041975c(hWnd_00, arg_ch, lpCaption, arg_10h);\n    if (piVar2 != NULL) {\n        *piVar2 = var_110h;\n    }\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    fcn.0041f8be(1);\n    fcn.0045843c(arg_ch_00);\n    return;\n}\n",
        "token_count": 766
    },
    "0041fbac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nvoid fcn.0041fbac(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (*0x49bd90 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"KERNEL32\");\n        *0x49bd90 = iVar2;\n        if (iVar2 == 0) {\n            iVar2 = fcn.0041638e();\n        }\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        *0x49bd7c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"CreateActCtxW\");\n        *0x49bd80 = (*pcVar1)(*0x49bd90, \"ReleaseActCtx\");\n        *0x49bd84 = (*pcVar1)(*0x49bd90, \"ActivateActCtx\");\n        *0x49bd88 = (*pcVar1)(*0x49bd90, \"DeactivateActCtx\");\n    }\n    return;\n}\n",
        "token_count": 218
    },
    "0041fc75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar __cdecl fcn.0041fc75(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uchar uVar2;\n    \n    if (arg_ch == 0) {\n        fcn.0041638e();\n    }\n    if (*0x49bd84 == 0) {\n        uVar2 = 2;\n    }\n    else {\n        iVar1 = fcn.0041fc47(arg_8h, arg_ch);\n        uVar2 = iVar1 != 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 124
    },
    "0041fca8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041fca8(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint arg_8h;\n    uint var_230h;\n    uint var_22ch;\n    uint *var_228h;\n    uint var_21ch;\n    uint var_214h;\n    uint lpFilename;\n    int16_t var_8h;\n    ushort var_6h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0041fbac();\n    uVar2 = *(param_1 + 8);\n    var_6h = 0;\n    var_8h = 0;\n    arg_8h = 0x105;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(uVar2, &lpFilename);\n    if (iVar1 != 0) {\n        if (var_8h == 0) {\n            var_228h = &lpFilename;\n            puVar3 = &var_230h;\n            var_230h = 0x20;\n            var_22ch = 0x88;\n            var_21ch = 2;\n            var_214h = uVar2;\n            iVar1 = fcn.0041fc1a(puVar3);\n            *(param_1 + 0x80) = iVar1;\n            if (iVar1 == -1) {\n                var_21ch = 3;\n                uVar2 = fcn.0041fc1a(&var_230h);\n                *(param_1 + 0x80) = uVar2;\n            }\n            if (*(param_1 + 0x80) == -1) {\n                var_21ch = 1;\n                iVar1 = fcn.0041fc1a(puVar3, &var_230h);\n                *(param_1 + 0x80) = iVar1;\n                if (iVar1 == -1) {\n                    *(param_1 + 0x80) = 0;\n                }\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x6f);\n        }\n    }\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 518
    },
    "0041fe31": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041fe31(code **param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.AFX_MODULE_THREAD_STATE.0;\n    if (param_1[0xf] != NULL) {\n        (**(*param_1[0xf] + 0x144))();\n    }\n    fcn.00414b30(param_1[0x12]);\n    if (param_1[5] != NULL) {\n        (***param_1[5])(1);\n    }\n    if (param_1[6] != NULL) {\n        (***param_1[6])(1);\n    }\n    if (param_1[7] != NULL) {\n        (***param_1[7])(1);\n    }\n    if (param_1[8] != NULL) {\n        (***param_1[8])(1);\n    }\n    if (param_1[9] != NULL) {\n        (***param_1[9])(1);\n    }\n    pcVar2 = param_1[0xe];\n    if (pcVar2 != NULL) {\n        while (*(pcVar2 + 0xc) != 0) {\n            uVar1 = fcn.0044b7d1();\n            fcn.00414b30(uVar1);\n            pcVar2 = param_1[0xe];\n        }\n    }\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 4))(1);\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    if (param_1[0xe] != NULL) {\n        (**(*param_1[0xe] + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 408
    },
    "00420056": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420056(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    \n    *param_1 = vtable.CDllIsolationWrapperBase.0;\n    if (*(param_1 + 2) != '\\0') {\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(param_1[1]);\n    }\n    ppiVar3 = param_1[3] + -0x10;\n    piVar1 = param_1[3] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar3 + 4))(ppiVar3);\n    }\n    return;\n}\n",
        "token_count": 193
    },
    "00420576": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420576(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.0042052a();\n    if ((*(iVar1 + 0x7c) == 0) || (*(arg_8h + 0x80) == -1)) {\n        *(in_ECX + 4) = 0;\n    }\n    else {\n        uVar2 = fcn.0041fc47(*(arg_8h + 0x80));\n        *(in_ECX + 4) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 148
    },
    "0042083b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042083b(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        fcn.0041638e();\n    }\n    iVar1 = fcn.0041b48d(&var_4h);\n    if (iVar1 == 0) {\n        var_4h = fcn.0041b5ff(arg_8h, arg_ch);\n    }\n    return var_4h;\n}\n",
        "token_count": 126
    },
    "00420dc9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00420dc9(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uStack8;\n    \n    if (*(param_1 + 0x20) == 0) {\n        return *(param_1 + 0x70);\n    }\n    iVar3 = fcn.004208c6();\n    if (iVar3 == 0) {\n        uStack8 = 0x496e18;\n        fcn.004593a9(&uStack8, 0x48c300);\n        pcVar1 = swi(3);\n        uVar2 = (*pcVar1)();\n        return uVar2;\n    }\n    uStack8 = 0;\n    uVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x20), 0x130b);\n    return uVar2;\n}\n",
        "token_count": 205
    },
    "00420ff8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420ff8(int32_t arg_8h)\n\n{\n    uint *in_ECX;\n    uint *extraout_ECX;\n    \n    if (arg_8h == 0) {\n        fcn.00401000(0x80004005);\n        in_ECX = extraout_ECX;\n    }\n    fcn.0045b51f(*in_ECX, arg_8h);\n    return;\n}\n",
        "token_count": 97
    },
    "0042101e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042101e(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    piVar1 = in_ECX + 0x174;\n    if (*piVar1 == 0) {\n        uVar2 = fcn.0041ac5f(\"CreatePropertySheetPageA\");\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        *piVar1 = iVar3;\n    }\n    *arg_8h = *piVar1;\n    return;\n}\n",
        "token_count": 143
    },
    "004210c6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004210c6(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "004210fc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004210fc(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    piVar1 = in_ECX + 0x17c;\n    if (*piVar1 == 0) {\n        uVar2 = fcn.0041ac5f(\"DestroyPropertySheetPage\");\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        *piVar1 = iVar3;\n    }\n    *arg_8h = *piVar1;\n    return;\n}\n",
        "token_count": 142
    },
    "004211a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004211a4(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "004211da": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004211da(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    piVar1 = in_ECX + 0x180;\n    if (*piVar1 == 0) {\n        uVar2 = fcn.0041ac5f(\"PropertySheetA\");\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        *piVar1 = iVar3;\n    }\n    *arg_8h = *piVar1;\n    return;\n}\n",
        "token_count": 140
    },
    "00421284": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00421284(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != -1;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "00421345": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00421345(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_ch;\n    int32_t hWnd;\n    int32_t var_4h;\n    \n    fcn.0041de55(0x10);\n    fcn.0041de55(0x3c000);\n    (**(*param_1 + 0x148))();\n    iVar1 = fcn.0042052a();\n    iVar1 = *(iVar1 + 4);\n    if (iVar1 != 0) {\n        fcn.0041f997(0);\n    }\n    if (param_1[0x28] == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = *(param_1[0x28] + 0x20);\n    }\n    iVar3 = fcn.0041f8f7(uVar2, &hWnd);\n    param_1[0x17] = iVar3;\n    var_4h = 0;\n    if (iVar3 != 0) {\n        iVar4 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3);\n        if (iVar4 != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n            var_4h = 1;\n        }\n    }\n    iVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar4 != 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x1f, 0, 0);\n    }\n    param_1[0x11] = 0;\n    if ((param_1[0x16] & 0x4000U) == 0) {\n        param_1[0xf] = param_1[0xf] | 0x10;\n    }\n    fcn.0041ce25(param_1);\n    if ((param_1[0x16] & 0x4000U) == 0) {\n        param_1[0x16] = param_1[0x16] | 0x400;\n        iVar4 = fcn.004212f1(param_1 + 0x15);\n        param_1[0x16] = param_1[0x16] & 0xfffffbff;\n        fcn.0041afcd();\n        if ((iVar4 == 0) || (iVar4 == -1)) {\n            param_1[0xf] = param_1[0xf] & 0xffffffef;\n        }\n        iVar4 = param_1[0x11];\n        iVar6 = (**(*param_1 + 0x88))();\n        if (iVar6 != 0) {\n            uVar2 = 4;\n            uVar5 = fcn.00418009();\n            if ((uVar5 & 0x100) != 0) {\n                uVar2 = 5;\n            }\n            iVar4 = fcn.0041aa9d(uVar2);\n        }\n        if (param_1[8] != 0) {\n            fcn.0041822e(0, 0, 0, 0, 0, 0x97);\n        }\n    }\n    else {\n        iVar4 = fcn.004212f1(param_1 + 0x15);\n        fcn.0041afcd();\n        param_1[8] = 0;\n    }\n    if (var_4h != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 1);\n    }\n    if (iVar3 != 0) {\n        iVar6 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar6 == param_1[8]) {\n            (*_sym.imp.USER32.dll_SetActiveWindow)(iVar3);\n        }\n    }\n    if ((param_1[0x16] & 0x4000U) == 0) {\n        (**(*param_1 + 0x60))();\n    }\n    if (iVar1 != 0) {\n        fcn.0041f997(1);\n    }\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    return iVar4;\n}\n",
        "token_count": 982
    },
    "00421974": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421974(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t var_4h;\n    \n    if (arg_8h == 0) {\n        fcn.0041638e();\n    }\n    fcn.00405010(arg_8h);\n    if (*(in_ECX + 0x20) == 0) {\n        return;\n    }\n    uVar2 = 0;\n    var_4h = 0;\n    piVar4 = *(in_ECX + 0x74);\n    if (*(in_ECX + 0x6c) != 0) {\n        do {\n            iVar1 = *piVar4;\n            iVar3 = var_4h + iVar1;\n            if ((iVar3 < var_4h) || (iVar3 < iVar1)) goto code_r0x00421a8e;\n            piVar4 = piVar4 + iVar1;\n            uVar2 = uVar2 + 1;\n            var_4h = iVar3;\n        } while (uVar2 < *(in_ECX + 0x6c));\n    }\n    iVar1 = **(arg_8h + 0x74) + var_4h;\n    if (((var_4h <= iVar1) && (**(arg_8h + 0x74) <= iVar1)) &&\n       (iVar3 = fcn.0045cc11(*(in_ECX + 0x74), iVar1),  iVar3 != 0)) {\n        *(in_ECX + 0x74) = iVar3;\n        iVar3 = iVar3 + var_4h;\n        fcn.00414fcb(iVar3, iVar1 - var_4h, *(arg_8h + 0x74), **(arg_8h + 0x74));\n        fcn.00421782(iVar3, (*(in_ECX + 0x58) & 0x1000020) != 0);\n        iVar1 = *(arg_8h + 0x80);\n        if (*(iVar1 + -0xc) != 0) {\n            *(iVar3 + 4) = *(iVar3 + 4) | 0x1000;\n            *(iVar3 + 0x28) = iVar1;\n        }\n        iVar1 = *(arg_8h + 0x84);\n        if (*(iVar1 + -0xc) != 0) {\n            *(iVar3 + 4) = *(iVar3 + 4) | 0x2000;\n            *(iVar3 + 0x2c) = iVar1;\n        }\n        iVar1 = fcn.004212bb(iVar3);\n        if (iVar1 != 0) {\n            iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0x467, 0, iVar1);\n            if (iVar3 != 0) goto code_r0x00421a93;\n            fcn.004212d6(iVar1);\n        }\n    }\ncode_r0x00421a8e:\n    fcn.00416356();\ncode_r0x00421a93:\n    *(in_ECX + 0x6c) = *(in_ECX + 0x6c) + 1;\n    return;\n}\n",
        "token_count": 763
    },
    "00421adf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421adf(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    *(*(in_ECX + 0x74) + 4) = 0x80;\n    if (arg_8h != 0) {\n        iVar2 = fcn.0042052a();\n        *(*(in_ECX + 0x74) + 8) = *(iVar2 + 0xc);\n    }\n    *(*(in_ECX + 0x74) + 0xc) = arg_8h;\n    *(*(in_ECX + 0x74) + 0x18) = fcn.0041ebc5;\n    *(*(in_ECX + 0x74) + 0x1c) = in_ECX;\n    *(*(in_ECX + 0x74) + 0x20) = 0x4205ae;\n    if (arg_ch != 0) {\n        iVar2 = fcn.004024c0(arg_ch);\n        if (iVar2 == 0) {\n            fcn.0041638e();\n        }\n        *(*(in_ECX + 0x74) + 0x14) = *(in_ECX + 0x78);\n        puVar1 = *(in_ECX + 0x74) + 4;\n        *puVar1 = *puVar1 | 8;\n    }\n    iVar2 = fcn.0041ef70();\n    if (iVar2 != 0) {\n        puVar1 = *(in_ECX + 0x74) + 4;\n        *puVar1 = *puVar1 | 0x20;\n    }\n    if ((arg_8h & 0xffff0000) == 0) {\n        *(in_ECX + 0x54) = arg_8h & 0xffff;\n    }\n    *(in_ECX + 0x58) = *(*(in_ECX + 0x74) + 0xc);\n    *(in_ECX + 0x7c) = 1;\n    return;\n}\n",
        "token_count": 482
    },
    "00421c72": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00421c72(int32_t param_1)\n\n{\n    if (*(param_1 + 0x18) != 0) {\n        (**(**(param_1 + 0x18) + 8))(*(param_1 + 0x18));\n    }\n    if (*(param_1 + 0x1c) != 0) {\n        (**(**(param_1 + 0x1c) + 8))(*(param_1 + 0x1c));\n    }\n    if (*(param_1 + 0x20) != 0) {\n        (**(**(param_1 + 0x20) + 8))(*(param_1 + 0x20));\n    }\n    return;\n}\n",
        "token_count": 164
    },
    "00421d9e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00421d9e(uint arg_8h)\n\n{\n    if (((arg_8h != *0x49be18) && (arg_8h != *0x49be1c)) && (arg_8h != 1)) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 73
    },
    "00442f96": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00442f96(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint arg_8h_00;\n    uint var_208h;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if (arg_8h == 0) {\n        fcn.0041638e();\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h);\n    if (iVar1 < 0x104) goto code_r0x00442fd4;\n    do {\n        fcn.0043880a(3, 0xffffffff, 0);\ncode_r0x00442fd4:\n        iVar1 = fcn.0042b4c9(&var_108h, arg_8h);\n    } while (iVar1 == 0);\n    fcn.004024f0(&var_108h);\n    in_ECX[0x14] = 0;\n    arg_8h_00 = 0x100;\n    iVar1 = fcn.0042af5e(&var_108h, &var_208h, 0x100);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0x50))(&var_208h);\n    }\n    if (arg_ch != 0) {\n        iVar1 = fcn.0042052a();\n        (**(**(iVar1 + 4) + 0x8c))(in_ECX[9]);\n    }\n    fcn.0045843c(arg_8h_00);\n    return;\n}\n",
        "token_count": 389
    },
    "00421e5c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00421e5c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t var_4h;\n    \n    var_4h = fcn.00427356();\n    do {\n        if (var_4h == 0) {\n            return 0;\n        }\n        iVar1 = fcn.0042735a(&var_4h);\n        iVar2 = fcn.00424c12();\n    } while ((iVar2 == 0) || (*(iVar1 + 0x24) != arg_8h));\n    return iVar1;\n}\n",
        "token_count": 143
    },
    "00421f78": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00421f78(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x8c))();\n    if (iVar1 == 0) {\n        uVar2 = 0x80004001;\n    }\n    else {\n        if (arg_8h == 0) {\n            (**(*in_ECX + 0x90))();\n            (**(*in_ECX + 0x94))();\n        }\n        else {\n            (**(*in_ECX + 0x80))(0);\n            (**(*in_ECX + 0x98))();\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 176
    },
    "00422bc5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00422bc5(int32_t param_1)\n\n{\n    if (*(param_1 + 0x1c4) != 0) {\n        fcn.004424b0(param_1 + 0x170);\n        *(param_1 + 0x1c4) = 0;\n    }\n    return param_1 + 0x170;\n}\n",
        "token_count": 88
    },
    "00422bee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00422bee(int32_t param_1)\n\n{\n    if (*(param_1 + 0x1c8) != 0) {\n        fcn.004424d3(param_1 + 0xb4);\n        *(param_1 + 0x1c8) = 0;\n    }\n    return param_1 + 0xb4;\n}\n",
        "token_count": 87
    },
    "00422e06": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00422e06(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint in_ECX;\n    \n    iVar1 = fcn.00422c17();\n    if (iVar1 == 0) {\n        iVar2 = -0x7fffbffb;\n    }\n    else {\n        if (arg_8h != 0) {\n            *(iVar1 + 0x58) = in_ECX;\n        }\n        iVar2 = fcn.00421f78(arg_8h);\n        if ((iVar2 < 0) || (arg_8h == 0)) {\n            *(iVar1 + 0x58) = 0;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 171
    },
    "00422f6f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00422f6f(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t var_4h;\n    \n    var_4h = fcn.00427356();\n    while (var_4h != 0) {\n        iVar1 = fcn.0042735a(&var_4h);\n        iVar2 = fcn.00424c12();\n        if (iVar2 != 0) {\n            *(iVar1 + 0x80) = *(iVar1 + 0x24) == 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "00422fba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00422fba(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t var_4h;\n    \n    var_4h = fcn.00427356();\n    while (var_4h != 0) {\n        piVar1 = fcn.0042735a(&var_4h);\n        iVar2 = fcn.00424c12(0x497424);\n        if (((iVar2 != 0) && (iVar2 = fcn.0042229b(),  iVar2 == 0)) && (piVar1 != NULL)) {\n            (**(*piVar1 + 4))(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "004230ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004230ee(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    bool bVar5;\n    uint var_4h;\n    \n    iVar2 = arg_8h;\n    uVar3 = fcn.00418009();\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    bVar5 = (uVar3 & 0x10000000) != 0;\n    if (bVar5) {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x20), 0xb, 0, 0);\n    }\n    iVar4 = (**(*in_ECX + 0x144))();\n    (**(**(iVar4 + 0x68) + 0x3c))(*(iVar4 + 0x68));\n    arg_8h = (**(*in_ECX + 0xb4))();\n    while ((arg_8h != 0 && (iVar4 = fcn.004270c5(&arg_8h),  iVar4 != 0))) {\n        fcn.00425b5c(0);\n    }\n    if (bVar5) {\n        (*pcVar1)(*(iVar2 + 0x20), 0xb, 1, 0);\n    }\n    return;\n}\n",
        "token_count": 320
    },
    "004239d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004239d9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0044a2be(0x423332);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    if (*(iVar1 + 4) != 0) {\n        iVar2 = fcn.0042052a();\n        iVar2 = *(iVar2 + 4);\n        if (*(iVar2 + 0x58) != 0) {\n            var_ch = (**(**(iVar2 + 0x58) + 0x10))();\n            while (var_ch != 0) {\n                piVar3 = (**(**(iVar2 + 0x58) + 0x14))(&var_ch);\n                var_8h = (**(*piVar3 + 0x54))();\n                while (var_8h != 0) {\n                    piVar4 = (**(*piVar3 + 0x58))(&var_8h);\n                    var_4h = (**(*piVar4 + 0x60))();\n                    while (var_4h != 0) {\n                        iVar5 = (**(*piVar4 + 100))(&var_4h);\n                        iVar6 = fcn.00424c12(0x47bc70);\n                        if ((iVar6 != 0) && (iVar5 != param_1)) {\n                            if (iVar5 != 0) {\n                                iVar5 = *(iVar5 + 0x20);\n                            }\n                            iVar5 = (*_sym.imp.USER32.dll_IsWindow)(iVar5);\n                            if (iVar5 != 0) goto code_r0x00423ae1;\n                        }\n                    }\n                }\n            }\n        }\n        iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(*(iVar1 + 4) + 0x20));\n        if (iVar2 != 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(*(*(iVar1 + 4) + 0x20), 0x10, 0, 0);\n        }\n        *(iVar1 + 4) = 0;\n    }\ncode_r0x00423ae1:\n    if (*(param_1 + 0x68) != 0) {\n        (**(**(param_1 + 0x68) + 8))(*(param_1 + 0x68));\n    }\n    fcn.004453cf();\n    return;\n}\n",
        "token_count": 627
    },
    "00424939": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424939(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint arg_8h_00;\n    uint var_11ch;\n    uint var_118h;\n    uint var_114h;\n    uint var_110h;\n    uint32_t var_10ch;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.SHELL32.dll_DragQueryFileA;\n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_8h_00 = arg_8h;\n    uVar2 = (*_sym.imp.SHELL32.dll_DragQueryFileA)(arg_8h, 0xffffffff, 0, 0);\n    fcn.00412e50(&var_114h);\n    var_10ch = 0;\n    if (uVar2 != 0) {\n        do {\n            (*pcVar1)(arg_8h, var_10ch, &var_108h, 0x104);\n            fcn.004245d3(&var_108h);\n            fcn.00412e50(&var_114h);\n            var_114h = var_110h;\n            fcn.00412e70(&var_114h);\n            (*_sym.imp.USER32.dll_UpdateWindow)(*(in_ECX + 0x20));\n            var_10ch = var_10ch + 1;\n        } while (var_10ch < uVar2);\n    }\n    fcn.00412e70(&var_114h);\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    fcn.0045843c(arg_8h_00);\n    return;\n}\n",
        "token_count": 406
    },
    "00424be7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00424be7(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if (in_ECX != 0) goto code_r0x00424bf7;\n    do {\n        in_ECX = fcn.0041638e();\ncode_r0x00424bf7:\n    } while (arg_8h == 0);\n    do {\n        if (in_ECX == arg_8h) {\n            return 1;\n        }\n        in_ECX = *(in_ECX + 0x10);\n    } while (in_ECX != 0);\n    return 0;\n}\n",
        "token_count": 141
    },
    "00424c30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00424c30(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    \n    if (arg_ch != 0) {\n        iVar1 = fcn.00424c12(arg_8h);\n        if (iVar1 != 0) {\n            return arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 85
    },
    "004259cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004259cc(uint *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint *arg_8h_00;\n    uint var_20h;\n    int32_t *var_1ch;\n    int32_t *var_18h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    var_1ch = NULL;\n    piVar1 = fcn.004469c0(in_ECX[9], 0x47a2e0);\n    if (piVar1 == NULL) {\n        piVar1 = (**(*in_ECX + 0xc0))();\n        arg_8h_00 = &var_1ch;\n        iVar2 = (**(*piVar1 + 0x10))(piVar1, 4, 3);\n    }\n    else {\n        arg_8h_00 = &var_1ch;\n        iVar2 = (**(*piVar1 + 0x18))(piVar1);\n        (**(*piVar1 + 8))(piVar1);\n    }\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ole32.dll_CreateStreamOnHGlobal)(0, 1, &var_18h);\n        if (iVar2 != 0) {\n            (**(*var_1ch + 8))(var_1ch);\n            fcn.00416356();\n        }\n        piVar1 = (*_sym.imp.ole32.dll_OleSaveToStream)(var_1ch, var_18h);\n        (**(*var_1ch + 8))(var_1ch);\n        if (piVar1 == NULL) goto code_r0x00425a83;\n        (**(*var_18h + 8))(var_18h);\n        while( true ) {\n            fcn.00415123(piVar1);\ncode_r0x00425a83:\n            in_ECX = (**(*in_ECX[9] + 0x3c))(in_ECX[9], &var_14h);\n            if ((in_ECX == NULL) && (in_ECX = (*_sym.imp.ole32.dll_WriteClassStm)(var_18h, &var_14h),  in_ECX == NULL))\n            break;\n            (**(*var_18h + 8))(var_18h);\n            piVar1 = in_ECX;\n        }\n        arg_8h[2] = 0;\n        arg_8h[1] = var_18h;\n        *arg_8h = 4;\n    }\n    fcn.0045843c(arg_8h_00);\n    return;\n}\n",
        "token_count": 618
    },
    "00425b5c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425b5c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (*(in_ECX + 0x12) == '\\0') {\n        *(in_ECX + 0x12) = 1;\n        iVar1 = (**(*in_ECX[9] + 0x18))(in_ECX[9], arg_8h);\n        in_ECX[0xd] = iVar1;\n        if (*(in_ECX + 0x46) != '\\0') {\n            (*_sym.imp.ole32.dll_OleLockRunning)(in_ECX[9], 0, 1);\n            *(in_ECX + 0x46) = 0;\n        }\n        if (in_ECX[0x14] != 1) {\n            if (in_ECX[0x14] == 4) {\n                (**(*in_ECX + 0x80))(0);\n            }\n            if (in_ECX[0x14] == 3) {\n                (**(*in_ECX + 0x98))();\n            }\n            if (in_ECX[0x14] != 1) {\n                (**(*in_ECX + 0x6c))(4, 1);\n                in_ECX[0x14] = 1;\n            }\n        }\n        *(in_ECX + 0x12) = 0;\n    }\n    return;\n}\n",
        "token_count": 320
    },
    "0042604d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042604d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t arg_8h_00;\n    int32_t *in_ECX;\n    int32_t **ppiVar4;\n    int32_t **ppiStack72;\n    int32_t *var_8h;\n    int32_t *dwBytes;\n    \n    var_8h = in_ECX;\n    dwBytes = in_ECX;\n    fcn.00424e44(&dwBytes);\n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, dwBytes);\n    if (iVar1 == 0) {\n        fcn.00416356();\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n    piVar3 = fcn.00438cbd(uVar2, dwBytes);\n    (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar1);\n    if (piVar3 != dwBytes) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(iVar1);\n        fcn.0043f8ce(3, 0);\n    }\n    ppiVar4 = in_ECX + 0xf;\n    arg_8h_00 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(iVar1, 1, ppiVar4);\n    if (arg_8h_00 == 0) goto code_r0x004260d2;\n    (*_sym.imp.KERNEL32.dll_GlobalFree)(iVar1);\n    while( true ) {\n        while( true ) {\n            fcn.00415123(arg_8h_00);\ncode_r0x004260d2:\n            ppiStack72 = NULL;\n            piVar3 = in_ECX + 0xe;\n            arg_8h_00 = (*_sym.imp.ole32.dll_StgOpenStorageOnILockBytes)(*ppiVar4, 0, 0x12, 0);\n            if (arg_8h_00 == 0) break;\n            (**(**ppiVar4 + 8))(*ppiVar4);\n            *ppiVar4 = NULL;\n        }\n        var_8h = NULL;\n        uVar2 = (**(*in_ECX + 0xc0))(&var_8h);\n        uVar2 = (*_sym.imp.ole32.dll_OleLoad)(in_ECX[0xe], 0x4850a0, uVar2);\n        (**(*in_ECX + 200))(uVar2);\n        iVar1 = fcn.004469c0(var_8h, 0x485100);\n        in_ECX[9] = iVar1;\n        (**(*var_8h + 8))(var_8h);\n        if (in_ECX[9] != 0) break;\n        arg_8h_00 = -0x7ff8fff2;\n        in_ECX = piVar3;\n        ppiVar4 = ppiStack72;\n    }\n    return;\n}\n",
        "token_count": 676
    },
    "00426151": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00426151(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    uint var_54h;\n    uint hMem;\n    uint var_4ch;\n    uint var_44h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    piVar1 = fcn.004469c0(in_ECX[9], 0x485050);\n    if (*(in_ECX[8] + 0x78) == 0) {\n        iVar2 = (**(*piVar1 + 0x10))(piVar1);\n        if (iVar2 != 0) goto code_r0x004261ad;\n    }\n    (*_sym.imp.ole32.dll_OleSave)(piVar1, in_ECX[0xe], *(in_ECX[8] + 0x78) == 0);\n    (**(*piVar1 + 0x20))(piVar1, 0);\ncode_r0x004261ad:\n    (**(*piVar1 + 8))(piVar1);\n    (**(*in_ECX[0xe] + 0x24))(in_ECX[0xe], 1);\n    iVar2 = (*_sym.imp.ole32.dll_GetHGlobalFromILockBytes)(in_ECX[0xf], &hMem);\n    if (iVar2 == 0) goto code_r0x004261d5;\n    do {\n        fcn.00415123(iVar2);\ncode_r0x004261d5:\n        in_ECX = in_ECX[0xf];\n        iVar2 = (**(*in_ECX + 0x24))(in_ECX, &var_4ch, 1);\n    } while (iVar2 != 0);\n    fcn.00424dbe(var_44h);\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(hMem);\n    fcn.00439273(arg_8h_00, var_44h);\n    (*_sym.imp.KERNEL32.dll_GlobalUnlock)(hMem);\n    fcn.0045843c(var_44h);\n    return;\n}\n",
        "token_count": 506
    },
    "00426b9c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00426b9c(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_150h;\n    uint var_14ch;\n    uint var_148h;\n    uint var_144h;\n    uint var_140h;\n    uint var_13ch;\n    uint var_138h;\n    uint var_134h;\n    uint var_130h;\n    uint pv;\n    uint var_128h;\n    uint var_124h;\n    uint var_114h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x144);\n    piVar1 = fcn.004469c0(*(extraout_ECX + 0x24), 0x485080);\n    *(unaff_EBP + -0x144) = 0xffffffff;\n    *(unaff_EBP + -0x150) = 3;\n    *(unaff_EBP + -0x14c) = 0;\n    *(unaff_EBP + -0x148) = 4;\n    *(unaff_EBP + -0x140) = 0x20;\n    iVar2 = (**(*piVar1 + 0xc))(piVar1, unaff_EBP + -0x150, unaff_EBP + -0x13c);\n    if (iVar2 == 0) {\n        (**(*piVar1 + 8))(piVar1);\n        if (*(unaff_EBP + -0x134) != 0) {\n            (*_sym.imp.ole32.dll_ReleaseStgMedium)(unaff_EBP + -0x13c);\n        }\n        goto code_r0x00426d5b;\n    }\n    (**(*piVar1 + 8))();\n    iVar2 = (**(**(extraout_ECX + 0x24) + 0x3c))(*(extraout_ECX + 0x24), unaff_EBP + -0x124);\n    if (iVar2 != 0) goto code_r0x00426d5b;\n    iVar2 = *(extraout_ECX + 0x54);\n    *(unaff_EBP + -0x128) = 0;\n    if ((iVar2 == 1) && (piVar1 = fcn.004469c0(*(extraout_ECX + 0x24), 0x47a2e0),  piVar1 != NULL)) {\n        iVar2 = *piVar1;\n        *(unaff_EBP + -300) = 0;\n        (**(iVar2 + 0x20))(piVar1, unaff_EBP + -300);\n        if (*(unaff_EBP + -300) != 0) {\n            *(unaff_EBP + -0x114) = 0;\n            fcn.0041589a(*(unaff_EBP + -300));\n            *(unaff_EBP + -4) = 0;\n            fcn.0042af5e(*(unaff_EBP + -0x130), unaff_EBP + -0x114, 0x104);\n            if (*(unaff_EBP + -0x114) != '\\0') {\n                *(unaff_EBP + -0x128) = unaff_EBP + -0x114;\n            }\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -300));\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004010f0();\n        }\n        (**(*piVar1 + 8))(piVar1);\n        if (*(unaff_EBP + -0x128) == 0) goto code_r0x00426d12;\n        fcn.00416242(*(unaff_EBP + -0x128));\n        iVar2 = (*_sym.imp.ole32.dll_OleGetIconOfClass)(unaff_EBP + -0x124, *(unaff_EBP + -0x128), 0);\n        fcn.004010f0();\n    }\n    else {\ncode_r0x00426d12:\n        iVar2 = (*_sym.imp.ole32.dll_OleGetIconOfClass)(unaff_EBP + -0x124, 0, 1);\n    }\n    if (iVar2 != 0) {\n        fcn.004257c9(iVar2);\n    }\ncode_r0x00426d5b:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 1008
    },
    "00427089": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427089(int32_t *arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    do {\n        if (*arg_8h == 0) {\n            return 0;\n        }\n        uVar1 = (**(*in_ECX + 0xb8))(arg_8h);\n        iVar2 = fcn.00424c12(arg_ch);\n    } while (iVar2 == 0);\n    return uVar1;\n}\n",
        "token_count": 121
    },
    "004270f1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004270f1(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        piVar1 = fcn.004270c5(&var_4h);\n        if (piVar1 == NULL) break;\n        if (piVar1[9] != 0) {\n            (**(*piVar1 + 0x58))(1);\n            (**(*param_1 + 0xc0))(piVar1);\n            fcn.00446b65();\n        }\n    }\n    return;\n}\n",
        "token_count": 164
    },
    "0042713e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042713e(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    piVar2 = fcn.004270c5(&var_4h);\n    while (piVar2 != NULL) {\n        if ((*(piVar2 + 0x47) != '\\0') && (arg_ch != NULL)) {\n            piVar1 = piVar2[0x13];\n            if (piVar1 != NULL) {\n                (**(*piVar1 + 8))(piVar1);\n            }\n            (**(*arg_ch + 4))(arg_ch);\n            piVar2[0x13] = arg_ch;\n        }\n        (**(*piVar2 + 0xdc))(arg_8h);\n        piVar2 = fcn.004270c5(&var_4h);\n    }\n    return;\n}\n",
        "token_count": 237
    },
    "00427243": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00427243(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t var_4h;\n    \n    var_4h = param_1;\n    iVar1 = fcn.00442be1();\n    if (iVar1 == 0) {\ncode_r0x00427255:\n        uVar2 = 0;\n    }\n    else {\n        if ((*(param_1 + 0x78) != 0) && (*(param_1 + 0x50) == 0)) {\n            fcn.004469e6(param_1 + 0x7c);\n            iVar1 = (*_sym.imp.ole32.dll_StgCreateDocfile)(0, 0x4011012, 0, &var_4h);\n            if (iVar1 != 0) goto code_r0x00427255;\n            *(param_1 + 0x7c) = var_4h;\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 236
    },
    "0042735a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042735a(int32_t *arg_8h)\n\n{\n    uint uVar1;\n    \n    if (*arg_8h == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = fcn.0042730e(arg_8h);\n    }\n    return uVar1;\n}\n",
        "token_count": 79
    },
    "0042745b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042745b(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(8);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *extraout_ECX = vtable.COleDocument.0;\n    pcVar1 = extraout_ECX[0x16];\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        piVar2 = fcn.0042735a(unaff_EBP + -0x10);\n        if (piVar2 != NULL) {\n            (**(*piVar2 + 4))(1);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    fcn.004469e6(extraout_ECX + 0x1f);\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(extraout_ECX[0x22]);\n    fcn.00441dca();\n    *(unaff_EBP + -4) = 0;\n    fcn.0044e590();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00442c54();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 359
    },
    "0042767e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl fcn.0042767e(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_88h;\n    uint var_84h;\n    int32_t var_40h;\n    uint in_stack_ffffffcc;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x80);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    fcn.004497ef(0);\n    *(unaff_EBP + -4) = 0;\n    fcn.00410530(0, 0xffffffff, 0);\n    iVar1 = extraout_ECX[0x1f];\n    *(unaff_EBP + -4) = 1;\n    iVar1 = fcn.00449b74(iVar1, \"Contents\", 0x1012, unaff_EBP + -0x28);\n    if (iVar1 == 0) {\n        if (*(unaff_EBP + -0x20) == 2) {\n            var_28h = 7;\n            fcn.0043f8ce(7, 0);\n        }\n        in_stack_ffffffcc = *(unaff_EBP + -0x20);\n        fcn.0043880a(in_stack_ffffffcc, *(unaff_EBP + -0x1c), var_28h);\n    }\n    fcn.0043941a(unaff_EBP + -0x40, 2, 0x1000, in_stack_ffffffcc);\n    *(unaff_EBP + -0x88) = extraout_ECX;\n    *(unaff_EBP + -0x84) = 0;\n    *(unaff_EBP + -4) = 3;\n    if (*(unaff_EBP + 8) == NULL) {\n        iVar1 = *extraout_ECX;\n    }\n    else {\n        iVar1 = **(unaff_EBP + 8);\n    }\n    var_40h = unaff_EBP + -0x88;\n    (**(iVar1 + 8))(var_40h);\n    fcn.00439263();\n    fcn.00449689();\n    iVar1 = (**(*extraout_ECX[0x1f] + 0x24))(extraout_ECX[0x1f], 2);\n    if (iVar1 != 0) {\n        fcn.00415123(iVar1);\n    }\n    *(unaff_EBP + -4) = 1;\n    fcn.004393dc();\n    *(unaff_EBP + -0x28) = vtable.CFileException.0;\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004496c9();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 790
    },
    "0042796a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0042796a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t ppmk;\n    int32_t lpszPathName;\n    \n    if (*(*(param_1 + 0x24) + -0xc) == 0) {\n        iVar1 = 0;\n    }\n    else {\n        ppmk = param_1;\n        lpszPathName = param_1;\n        fcn.00416242(*(param_1 + 0x24));\n        (*_sym.imp.ole32.dll_CreateFileMoniker)(lpszPathName, &ppmk);\n        iVar1 = ppmk;\n        fcn.004010f0();\n    }\n    return iVar1;\n}\n",
        "token_count": 162
    },
    "004279aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.004279aa(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar3;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x20);\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    if ((extraout_ECX[0x1e] == 0) && (extraout_ECX[0x1f] == 0)) {\n        fcn.0044349a(*(unaff_EBP + 8));\n    }\n    else {\n        (**(*extraout_ECX + 0x58))();\n        iVar2 = *(unaff_EBP + 8);\n        if (iVar2 != 0) {\n            (**(*extraout_ECX + 0x6c))();\n            fcn.004469e6(extraout_ECX + 0x1f);\n        }\n        (**(*extraout_ECX + 0x5c))(1);\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -4) = 0;\n        if (extraout_ECX[0x1f] == 0) {\n            fcn.00416242(iVar2);\n            uVar3 = -(iVar2 != 0) & *(unaff_EBP + -0x18);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x20) = uVar3;\n            *(unaff_EBP + -0x14) = 0;\n            iVar2 = (*_sym.imp.ole32.dll_StgIsStorageFile)(uVar3);\n            pcVar1 = _sym.imp.ole32.dll_StgOpenStorage;\n            if (iVar2 == 1) {\n                iVar2 = (*_sym.imp.ole32.dll_StgCreateDocfile)(uVar3, 0x30022);\n            }\n            else {\n                iVar2 = (*_sym.imp.ole32.dll_StgOpenStorage)(uVar3, 0, 0x10022, 0, 0, unaff_EBP + -0x14);\n                if ((iVar2 < 0) || (*(unaff_EBP + -0x14) == 0)) {\n                    iVar2 = (*pcVar1)(*(unaff_EBP + -0x20), 0, 0x10000, 0, 0, unaff_EBP + -0x14);\n                }\n            }\n            if (iVar2 < 0) {\n                fcn.00415123(iVar2);\n            }\n            extraout_ECX[0x1f] = *(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 0;\n            fcn.004010f0();\n        }\n        (**(*extraout_ECX + 0xd8))();\n        (**(*extraout_ECX + 0x5c))(0);\n        *(unaff_EBP + -0x1c) = 1;\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 841
    },
    "00428376": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428376(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint lprc;\n    uint var_8h;\n    uint *var_4h;\n    \n    if (in_ECX[0x16] == 0) {\n        in_ECX[0x16] = arg_ch;\n    }\n    iVar2 = fcn.0044a2be(0x428119);\n    if (iVar2 == 0) {\n        fcn.0041638e();\n    }\n    uVar1 = *(iVar2 + 4);\n    *(iVar2 + 4) = 0;\n    var_4h = NULL;\n    if (arg_ch != 0) {\n        (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n        (**(*in_ECX + 0x70))(&lprc);\n        iVar3 = (*_sym.imp.USER32.dll_IsRectEmpty)(&lprc);\n        if (iVar3 == 0) {\n            var_4h = &lprc;\n            *(iVar2 + 4) = arg_ch;\n        }\n    }\n    var_8h = (**(*in_ECX + 0xc0))();\n    if (arg_ch == 0) {\n        arg_ch = 0;\n    }\n    else {\n        arg_ch = *(arg_ch + 0x20);\n    }\n    iVar3 = (**(*in_ECX[9] + 0x2c))(in_ECX[9], arg_8h, arg_10h, var_8h, 0xffffffff, arg_ch, var_4h);\n    *(iVar2 + 4) = uVar1;\n    iVar2 = fcn.00412da0();\n    if (iVar2 == 0) {\n        in_ECX[0x16] = 0;\n    }\n    *(in_ECX + 0x11) = iVar3 < 0;\n    (**(*in_ECX + 200))(iVar3);\n    return;\n}\n",
        "token_count": 475
    },
    "0042855e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042855e(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = *(in_ECX + 0x3c);\n    if (arg_8h == 0) {\n        *(in_ECX + 0x3c) = iVar1 + 1;\n        if (iVar1 != 0) {\n            return 1;\n        }\n    }\n    else {\n        if (iVar1 == 0) {\n            return 1;\n        }\n        *(in_ECX + 0x3c) = iVar1 + -1;\n        if (iVar1 + -1 != 0) {\n            return 1;\n        }\n        iVar1 = 1;\n    }\n    (**(**(in_ECX + 0x24) + 0x24))(*(in_ECX + 0x24), iVar1);\n    return 1;\n}\n",
        "token_count": 207
    },
    "00428728": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428728(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    \n    piVar1 = fcn.004469c0(*(param_1 + 0x24), 0x485150);\n    if (piVar1 != NULL) {\n        uVar2 = (**(*piVar1 + 0x14))(piVar1);\n        *(param_1 + 0x34) = uVar2;\n        (**(*piVar1 + 8))(piVar1);\n        if (-1 < *(param_1 + 0x34)) {\n            *(param_1 + 0x50) = 1;\n            return;\n        }\n    }\n    fcn.00425b5c(0);\n    return;\n}\n",
        "token_count": 176
    },
    "0042899e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042899e(uint arg_8h, code *arg_ch)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = *(in_ECX + 0x2c);\n    iVar1 = fcn.0042052a();\n    iVar1 = *(iVar1 + 4);\n    if (*(iVar1 + 0x58) != 0) {\n        var_ch = (**(**(iVar1 + 0x58) + 0x10))();\n        while (var_ch != 0) {\n            piVar2 = (**(**(iVar1 + 0x58) + 0x14))(&var_ch);\n            var_8h = (**(*piVar2 + 0x54))();\n            while (var_8h != 0) {\n                piVar3 = (**(*piVar2 + 0x58))(&var_8h);\n                iVar4 = fcn.00424c12(0x47c584);\n                if (iVar4 != 0) {\n                    var_4h = (**(*piVar3 + 0xb4))();\n                    while (iVar4 = fcn.004270c5(&var_4h),  iVar4 != 0) {\n                        if ((((*(iVar4 + 0x60) != 0) && (*(*(iVar4 + 0x60) + 0x24) != 0)) && (*(iVar4 + 0x58) != 0)) &&\n                           ((iVar4 = fcn.00430b17(arg_8h_00, *(*(iVar4 + 0x58) + 0x20)),  iVar4 != 0 &&\n                            (iVar4 = (*arg_ch)(arg_8h),  iVar4 == 0)))) {\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 490
    },
    "00428bdc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428bdc(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    code *pcVar3;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    pcVar3 = 0x3;\n    var_8h = param_1;\n    var_4h = param_1;\n    if (param_1[0x14] != 3) {\n        (**(*param_1 + 0x6c))(4, 3);\n        param_1[0x14] = 3;\n    }\n    if ((param_1[0x16] != 0) && (iVar1 = (**(*param_1[8] + 0x60))(),  iVar1 != 0)) {\n        fcn.0041803d(0x2000000, param_1[0x17] & 0x2000000, 0);\n    }\n    var_8h = NULL;\n    iVar1 = (**(*param_1 + 0x9c))(&var_4h, &var_8h, 0);\n    if (iVar1 == 0) goto code_r0x00428cae;\n    iVar1 = (**(*var_4h + 0x15c))();\n    if (iVar1 == 1) goto code_r0x00428c52;\n    while( true ) {\n        fcn.0041638e();\ncode_r0x00428c52:\n        (**(*var_4h + 0x158))(param_1[0x1b]);\n        var_4h[0x39] = var_4h[0x39] | 2;\n        iVar1 = (**(*var_4h + 0x170))(pcVar3, 0);\n        if (iVar1 != 0) {\n            var_4h[0x39] = var_4h[0x39] | 0xc;\n        }\n        if (var_8h != NULL) {\n            var_8h[0x39] = var_8h[0x39] | 2;\n            iVar1 = (**(*var_8h + 0x170))(pcVar3, 0);\n            if (iVar1 != 0) {\n                var_8h[0x39] = var_8h[0x39] | 0xc;\n            }\n        }\ncode_r0x00428cae:\n        if (param_1[0x18] != 0) {\n            (**(*param_1 + 0xb4))(*(param_1[0x18] + 0x20), 1);\n            pcVar3 = _sym.imp.ole32.dll_OleSetMenuDescriptor;\n            (*_sym.imp.ole32.dll_OleSetMenuDescriptor)(0, *(*(param_1[0x18] + 0x20) + 0x20), 0, 0, 0);\n            if (param_1[0x19] != 0) {\n                (*pcVar3)(0, *(*(param_1[0x19] + 0x20) + 0x20), 0, 0, 0);\n            }\n            (**(**(param_1[0x18] + 0x20) + 0x184))(0);\n            piVar2 = *(param_1[0x18] + 0x20) + 0x80;\n            if (*piVar2 == param_1[0x18]) {\n                *piVar2 = 0;\n            }\n            if (param_1[0x19] != 0) {\n                (**(*param_1 + 0xb4))(*(param_1[0x19] + 0x20), 1);\n                piVar2 = *(param_1[0x19] + 0x20) + 0x80;\n                if (*piVar2 == param_1[0x19]) {\n                    *piVar2 = 0;\n                }\n            }\n        }\n        param_1[0x1a] = 0;\n        iVar1 = fcn.00409ef0();\n        if (iVar1 == 0) break;\n        param_1 = fcn.0041c59b();\n        if (param_1 != NULL) {\n            iVar1 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar1 == param_1[8]) {\n                fcn.004181c9();\n            }\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 1013
    },
    "00429d55": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00429d55(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    iVar1 = fcn.0042055d();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00414adf(fcn.0044b07c);\n        iVar2 = fcn.00414af6(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.0044ac7b(0x47c840, fcn.00429d3b, fcn.00416fae, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar3;\n        fcn.00414adf(arg_8h_00);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 329
    },
    "00429e56": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00429e56(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.00429e2a();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 88
    },
    "0042a5a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042a5a4(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    fcn.00417f7f(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        iVar2 = fcn.00417f3b(iVar1);\n        if (iVar2 == 0) {\n            fcn.00416372();\n        }\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = iVar1;\n    return arg_8h;\n}\n",
        "token_count": 161
    },
    "0042a5e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a5e5(int32_t *param_1)\n\n{\n    int32_t *hWnd;\n    \n    hWnd = param_1;\n    if ((*param_1 != 0) && (param_1[2] != 0)) {\n        fcn.00417f7f(param_1[2], &hWnd);\n        if (hWnd != NULL) {\n            (*_sym.imp.USER32.dll_SetFocus)(hWnd);\n            if (param_1[3] != 0) {\n                (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xb1, 0, 0xffffffff);\n            }\n        }\n    }\n    fcn.00416f92();\n    return;\n}\n",
        "token_count": 163
    },
    "0042a636": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a636(int32_t *hWnd, uint arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = hWnd;\n    fcn.0042a5a4(arg_ch);\n    fcn.00417f7f(arg_ch, &hWnd);\n    if (*piVar1 == 0) {\n        if ((*arg_10h < 0) || (2 < *arg_10h)) {\n            *arg_10h = 0;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xf1, *arg_10h, 0);\n    }\n    else {\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xf0, 0, 0);\n        *arg_10h = iVar2;\n    }\n    return;\n}\n",
        "token_count": 209
    },
    "0042a7f4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a7f4(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = arg_10h;\n    if (*(arg_10h + 0x20) != 0) {\n        return;\n    }\n    iVar1 = fcn.00417f12();\n    if (iVar1 != 0) {\n        return;\n    }\n    fcn.0042a5a4(arg_ch);\n    fcn.00417f7f(arg_ch, &arg_10h);\n    if (arg_10h != 0) {\n        iVar1 = fcn.0041bc8a(arg_10h);\n        if (iVar1 == 0) {\n            fcn.00416372();\n        }\n        if (arg_10h != 0) {\n            iVar1 = *(arg_8h + 4);\n            iVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar2 + 0x20));\n            if (*(iVar1 + 0x20) == iVar2) {\n                return;\n            }\n            arg_ch = 0;\n            goto code_r0x0042a871;\n        }\n    }\n    iVar2 = fcn.00417f3b(arg_ch);\n    if (iVar2 == 0) {\n        return;\n    }\n    iVar1 = *(arg_8h + 4);\ncode_r0x0042a871:\n    fcn.004181ea(iVar1, arg_ch);\n    return;\n}\n",
        "token_count": 349
    },
    "0042a89b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a89b(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    \n    arg_8h_00 = fcn.0042a87f(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.0044af85(arg_8h_00, *arg_10h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(arg_8h_00);\n        uVar2 = fcn.004090c0(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(arg_8h_00, uVar2);\n        fcn.00409070(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "0042a8ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a8ef(int32_t *hWnd, uint arg_ch, uint *lParam)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    piVar2 = hWnd;\n    fcn.0042a5a4(arg_ch);\n    fcn.00417f7f(arg_ch, &hWnd);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*piVar2 == 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x18c, 0xffffffff, *lParam);\n    }\n    else {\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x188, 0, 0);\n        if (iVar3 == -1) {\n            fcn.004018d0();\n        }\n        else {\n            uVar4 = (*pcVar1)(hWnd, 0x18a, iVar3, 0);\n            uVar4 = fcn.004090c0(uVar4);\n            (*pcVar1)(hWnd, 0x189, iVar3, uVar4);\n        }\n        fcn.00409070(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 289
    },
    "0042a9a3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a9a3(int32_t *arg_8h, char *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint var_4h;\n    \n    pcVar4 = arg_ch;\n    if (arg_ch != NULL) goto code_r0x0042a9b8;\n    do {\n        fcn.0041638e();\ncode_r0x0042a9b8:\n    } while (arg_10h == 0);\n    arg_ch = NULL;\n    cVar2 = *pcVar4;\n    pcVar5 = pcVar4;\n    while (cVar2 != '\\0') {\n        if (*pcVar5 == '%') {\n            cVar2 = pcVar5[1];\n            if ((cVar2 < '1') || ('9' < cVar2)) {\n                if ((cVar2 < 'A') || ('Z' < cVar2)) goto code_r0x0042aa10;\n                if (cVar2 < ':') goto code_r0x0042a9f0;\n                iVar3 = cVar2 + -0x38;\n            }\n            else {\ncode_r0x0042a9f0:\n                iVar3 = cVar2 + -0x31;\n            }\n            pcVar5 = pcVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x0042aa23;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                arg_ch = arg_ch + iVar3;\n            }\n        }\n        else {\ncode_r0x0042aa10:\n            iVar3 = fcn.0045cede(*pcVar5);\n            if (iVar3 != 0) {\n                arg_ch = arg_ch + 1;\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = pcVar5 + 1;\ncode_r0x0042aa23:\n            arg_ch = arg_ch + 1;\n        }\n        cVar2 = *pcVar5;\n    }\n    pcVar5 = fcn.00401eb0(arg_ch);\n    cVar2 = *pcVar4;\n    do {\n        if (cVar2 == '\\0') {\n            fcn.00409070(pcVar5 - *arg_8h);\n            return;\n        }\n        if (*pcVar4 == '%') {\n            cVar2 = pcVar4[1];\n            if ((cVar2 < '1') || ('9' < cVar2)) {\n                if ((cVar2 < 'A') || ('Z' < cVar2)) goto code_r0x0042aaac;\n                if (cVar2 < ':') goto code_r0x0042aa69;\n                iVar3 = cVar2 + -0x38;\n            }\n            else {\ncode_r0x0042aa69:\n                iVar3 = cVar2 + -0x31;\n            }\n            pcVar4 = pcVar4 + 2;\n            if (arg_14h <= iVar3) {\n                *pcVar5 = '?';\n                goto code_r0x0042aac9;\n            }\n            piVar1 = arg_10h + iVar3 * 4;\n            iVar3 = *piVar1;\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                fcn.0042a985(pcVar5, arg_ch + 1, *piVar1);\n                arg_ch = arg_ch - iVar3;\n                pcVar5 = pcVar5 + iVar3;\n            }\n        }\n        else {\ncode_r0x0042aaac:\n            iVar3 = fcn.0045cede(*pcVar4);\n            if (iVar3 != 0) {\n                *pcVar5 = *pcVar4;\n                pcVar5 = pcVar5 + 1;\n                pcVar4 = pcVar4 + 1;\n                arg_ch = arg_ch + -1;\n            }\n            *pcVar5 = *pcVar4;\n            pcVar4 = pcVar4 + 1;\ncode_r0x0042aac9:\n            pcVar5 = pcVar5 + 1;\n            arg_ch = arg_ch + -1;\n        }\n        cVar2 = *pcVar4;\n    } while( true );\n}\n",
        "token_count": 1017
    },
    "0042abf7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042abf7(char *lpString1, uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint unaff_EDI;\n    uint var_624h;\n    uint var_620h;\n    uint var_61ch;\n    uint var_414h;\n    uint var_20ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString2);\n    if ((iVar2 == 0) &&\n       (iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a),  pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA,  iVar2 != 0)) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString1);\n        iVar3 = (*pcVar1)(lpString2);\n        if (iVar2 == iVar3) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n            pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeExA;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExA)(uVar4, 1, lpString1, 0xffffffff, &var_61ch);\n            (*pcVar1)(uVar4, 4, lpString1, 0xffffffff, &var_20ch);\n            (*pcVar1)(uVar4, 1, lpString2, 0xffffffff, &var_414h);\n            if (*lpString1 != '\\0') {\n                iVar2 = 0;\n                do {\n                    if (((*(&var_20ch + iVar2) & 0x80) != 0) && (*(&var_61ch + iVar2) != *(&var_414h + iVar2))) break;\n                    iVar2 = iVar2 + 2;\n                    lpString1 = fcn.0045ce2c(lpString1);\n                } while (*lpString1 != '\\0');\n            }\n        }\n    }\n    fcn.0045843c(unaff_EDI);\n    return;\n}\n",
        "token_count": 500
    },
    "0042ad26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042ad26(uint lpBuffer, int32_t nNumberOfBytesToRead)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    int32_t in_ECX;\n    uint arg_ch;\n    \n    if (nNumberOfBytesToRead == 0) {\n        nNumberOfBytesToRead = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                          (*(in_ECX + 4), lpBuffer, nNumberOfBytesToRead, &nNumberOfBytesToRead, 0);\n        if (iVar1 == 0) {\n            arg_ch = *(in_ECX + 0xc);\n            arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.00438850(arg_8h, arg_ch);\n        }\n    }\n    return nNumberOfBytesToRead;\n}\n",
        "token_count": 194
    },
    "0042b30a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042b30a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t arg_8h_00;\n    int32_t arg_8h_01;\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint var_164h;\n    uint var_160h;\n    uint lpFilePart;\n    uint lpFileName;\n    uint lpRootPathName;\n    uint lpFindFileData;\n    uint lpString;\n    uint var_4h;\n    \n    fcn.0045afa4(0x158);\n    arg_8h_00 = *(unaff_EBP + 8);\n    iVar2 = *(unaff_EBP + 0xc);\n    arg_8h_01 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x158) = iVar2;\n    if (arg_8h_00 != 0) goto code_r0x0042b338;\n    do {\n        iVar2 = fcn.0041638e();\ncode_r0x0042b338:\n    } while (iVar2 == 0);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(iVar2, 0x104, arg_8h_00, unaff_EBP + -0x15c);\n    if (uVar3 == 0) {\n        fcn.0041502b(arg_8h_00, 0x104, *(unaff_EBP + -0x158), 0xffffffff);\n        fcn.0042b2db(arg_8h_01, *(unaff_EBP + -0x158));\n        goto code_r0x0042b49f;\n    }\n    if (0x103 < uVar3) {\n        if (arg_8h_01 != 0) {\n            uVar1 = *(unaff_EBP + -0x158);\n            *(arg_8h_01 + 8) = 3;\n            fcn.00402830(uVar1);\n        }\n        goto code_r0x0042b49f;\n    }\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042b179(arg_8h_00, unaff_EBP + -0x154);\n    iVar2 = (*_sym.imp.SHLWAPI.dll_PathIsUNCA)(*(unaff_EBP + -0x154));\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                          (*(unaff_EBP + -0x154), 0, 0, 0, unaff_EBP + -0x164, unaff_EBP + -0x160, 0, 0);\n        if (iVar2 == 0) {\ncode_r0x0042b3f3:\n            fcn.0042b2db(arg_8h_01, *(unaff_EBP + -0x158));\n        }\n        else {\n            if ((*(unaff_EBP + -0x160) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(arg_8h_00);\n            }\n            if (((*(unaff_EBP + -0x160) & 4) != 0) ||\n               (iVar2 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + -0x158), unaff_EBP + -0x150),  iVar2 == -1\n               )) goto code_r0x0042b48e;\n            (*_sym.imp.KERNEL32.dll_FindClose)(iVar2);\n            if ((*(unaff_EBP + -0x15c) == 0) ||\n               (*(unaff_EBP + -0x15c) < arg_8h_00 || *(unaff_EBP + -0x15c) == arg_8h_00)) goto code_r0x0042b3f3;\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(unaff_EBP + -0x124);\n            iVar4 = *(unaff_EBP + -0x15c) - arg_8h_00;\n            if (iVar2 + iVar4 < 0x104) {\n                fcn.0042a985(*(unaff_EBP + -0x15c), 0x104 - iVar4, unaff_EBP + -0x124);\n                goto code_r0x0042b48e;\n            }\n            if (arg_8h_01 != 0) {\n                uVar1 = *(unaff_EBP + -0x158);\n                *(arg_8h_01 + 8) = 3;\n                fcn.00402830(uVar1);\n            }\n        }\n        fcn.004010f0();\n    }\n    else {\ncode_r0x0042b48e:\n        fcn.004010f0();\n    }\ncode_r0x0042b49f:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 1162
    },
    "0042b552": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b552(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    uint uVar4;\n    int32_t in_stack_fffffec4;\n    uint lpSecurityAttributes;\n    uint var_11ch;\n    uint32_t var_118h;\n    int32_t var_114h;\n    uint dwDesiredAccess;\n    int32_t lpFileName;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    *(in_ECX + 8) = 0;\n    *(in_ECX + 4) = 0xffffffff;\n    lpFileName = arg_8h;\n    var_114h = arg_10h;\n    fcn.004018d0();\n    if ((lpFileName == 0) || (in_stack_fffffec4 = lpFileName,  iVar2 = fcn.0042acef(lpFileName, 0x104, 0),  iVar2 < 0))\n    {\n        if (var_114h != 0) {\n            *(var_114h + 8) = 3;\n            fcn.00402830();\n        }\n        goto code_r0x0042b72b;\n    }\n    iVar2 = fcn.0042b30a(&var_108h, lpFileName, var_114h);\n    if (iVar2 == 0) goto code_r0x0042b72b;\n    fcn.004024f0(&var_108h);\n    uVar3 = arg_ch & 3;\n    dwDesiredAccess = 0;\n    if (uVar3 == 0) {\n        dwDesiredAccess = 0x80000000;\n    }\n    else if (uVar3 == 1) {\n        dwDesiredAccess = 0x40000000;\n    }\n    else if (uVar3 == 2) {\n        dwDesiredAccess = 0xc0000000;\n    }\n    uVar3 = arg_ch & 0x70;\n    uVar4 = 1;\n    if ((uVar3 == 0) || (uVar3 == 0x10)) {\ncode_r0x0042b647:\n        uVar4 = 0;\n    }\n    else if (uVar3 != 0x20) {\n        if (uVar3 == 0x30) {\n            uVar4 = 2;\n        }\n        else {\n            uVar4 = 3;\n            if (uVar3 != 0x40) goto code_r0x0042b647;\n        }\n    }\n    var_118h = ~((arg_ch & 0xffff7fff) >> 7) & 1;\n    lpSecurityAttributes = 0xc;\n    var_11ch = 0;\n    if ((arg_ch & 0x1000) == 0) {\n        cVar1 = '\\x03';\n    }\n    else {\n        cVar1 = (-((arg_ch & 0x2000) != 0) & 2U) + 2;\n    }\n    uVar3 = 0x80;\n    if ((arg_ch & 0x10000) != 0) {\n        uVar3 = 0x20000080;\n    }\n    if ((arg_ch & 0x20000) != 0) {\n        uVar3 = uVar3 | 0x80000000;\n    }\n    if ((arg_ch & 0x40000) != 0) {\n        uVar3 = uVar3 | 0x10000000;\n    }\n    if ((arg_ch & 0x80000) != 0) {\n        uVar3 = uVar3 | 0x8000000;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileA)\n                      (lpFileName, dwDesiredAccess, uVar4, &lpSecurityAttributes, cVar1, uVar3, 0);\n    if (iVar2 == -1) {\n        fcn.0042b2db(var_114h, lpFileName);\n    }\n    else {\n        *(in_ECX + 4) = iVar2;\n        *(in_ECX + 8) = 1;\n    }\ncode_r0x0042b72b:\n    fcn.0045843c(in_stack_fffffec4);\n    return;\n}\n",
        "token_count": 1002
    },
    "0042bbc8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0042bbc8(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    uint extraout_ECX;\n    uint *puVar2;\n    uint *puVar3;\n    uint var_24h;\n    \n    if (arg_8h == NULL) {\n        fcn.00401000(0x80004005);\n        in_ECX = extraout_ECX;\n    }\n    iVar1 = fcn.0045d1bd(&var_24h, in_ECX);\n    if (iVar1 == 0) {\n        puVar2 = &var_24h;\n        puVar3 = arg_8h;\n        for (iVar1 = 9; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = *puVar2;\n            puVar2 = puVar2 + 1;\n            puVar3 = puVar3 + 1;\n        }\n    }\n    else {\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 237
    },
    "0042be42": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042be42(uint arg_8h, int32_t lpFileTime)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uchar *arg_ch;\n    uint lpSystemTime;\n    uint var_12h;\n    ushort var_eh;\n    ushort var_ch;\n    ushort var_ah;\n    uchar lpLocalFileTime [8];\n    \n    if (lpFileTime == 0) {\n        fcn.0041638e();\n    }\n    lpSystemTime._0_2_ = fcn.0042bc0a();\n    lpSystemTime._2_2_ = fcn.0042bc2d();\n    var_12h._0_2_ = fcn.0042bc4c();\n    var_12h._2_2_ = fcn.0042bc6a();\n    var_eh = fcn.0042bc89();\n    var_ch = fcn.0042bca8();\n    var_ah = 0;\n    arg_ch = lpLocalFileTime;\n    iVar2 = (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.00438850(uVar3, arg_ch);\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalFileTimeToFileTime)(lpLocalFileTime, lpFileTime);\n    if (iVar2 == 0) {\n        uVar3 = (*pcVar1)();\n        fcn.00438850(uVar3, iVar2);\n    }\n    return;\n}\n",
        "token_count": 392
    },
    "0042bee0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042bee0(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t *puVar3;\n    int32_t in_ECX;\n    uint var_28h;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    uint32_t lpFileSize;\n    uint32_t var_4h;\n    \n    fcn.00458b20(arg_8h, 0, 0x128);\n    fcn.0041502b(arg_8h + 0x22, 0x104, *(in_ECX + 0xc), 0xffffffff);\n    if (*(in_ECX + 4) == *0x47c89c) {\ncode_r0x0042c037:\n        uVar2 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetFileSizeEx)(*(in_ECX + 4), &lpFileSize);\n            if (iVar1 != 0) {\n                arg_8h[6] = lpFileSize;\n                arg_8h[7] = var_4h;\n                if (*(*(in_ECX + 0xc) + -0xc) == 0) {\n                    *(arg_8h + 8) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    *(arg_8h + 8) = (iVar1 == -1) - 1U & iVar1;\n                }\n                iVar1 = fcn.0042ba45(&lpCreationTime);\n                if (iVar1 == 0) {\n                    *arg_8h = 0;\n                    arg_8h[1] = 0;\n                }\n                else {\n                    puVar3 = fcn.0042bb68(&lpCreationTime, 0xffffffff);\n                    *arg_8h = *puVar3;\n                    arg_8h[1] = puVar3[1];\n                }\n                iVar1 = fcn.0042ba45(&lpLastAccessTime);\n                if (iVar1 == 0) {\n                    arg_8h[4] = 0;\n                    arg_8h[5] = 0;\n                }\n                else {\n                    puVar3 = fcn.0042bb68(&lpLastAccessTime, 0xffffffff);\n                    arg_8h[4] = *puVar3;\n                    arg_8h[5] = puVar3[1];\n                }\n                iVar1 = fcn.0042ba45(&lpLastWriteTime);\n                if (iVar1 == 0) {\n                    arg_8h[2] = 0;\n                    arg_8h[3] = 0;\n                }\n                else {\n                    puVar3 = fcn.0042bb68(&lpLastWriteTime, 0xffffffff);\n                    arg_8h[2] = *puVar3;\n                    arg_8h[3] = puVar3[1];\n                }\n                if ((*arg_8h | arg_8h[1]) == 0) {\n                    *arg_8h = arg_8h[2];\n                    arg_8h[1] = arg_8h[3];\n                }\n                if ((arg_8h[4] | arg_8h[5]) == 0) {\n                    arg_8h[4] = arg_8h[2];\n                    arg_8h[5] = arg_8h[3];\n                }\n                goto code_r0x0042c037;\n            }\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 867
    },
    "0042c39c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.0042c39c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar3 = fcn.0042e01d(param_1 + 0x14, *(param_1 + 0x18), 0x10);\n        iVar1 = *(param_1 + 0x18);\n        puVar4 = iVar3 + -0xc + iVar1 * 0x10;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar4 = *(param_1 + 0x10);\n            *(param_1 + 0x10) = puVar4;\n            puVar4 = puVar4 + -4;\n        }\n    }\n    puVar4 = *(param_1 + 0x10);\n    uVar2 = *puVar4;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar2;\n    if (puVar4 != 0xfffffff8) {\n        fcn.00401e60();\n    }\n    puVar4[3] = 0;\n    return puVar4;\n}\n",
        "token_count": 312
    },
    "0042c543": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042c543(uint arg_8h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint *puVar3;\n    uint *arg_8h_00;\n    uint var_4h;\n    \n    if (*(in_ECX + 4) != 0) {\n        uVar2 = fcn.0042c326(arg_8h);\n        puVar3 = *(in_ECX + 4) + (uVar2 % *(in_ECX + 8)) * 4;\n        for (arg_8h_00 = *puVar3; arg_8h_00 != NULL; arg_8h_00 = *arg_8h_00) {\n            if ((arg_8h_00[1] == uVar2) && (cVar1 = fcn.0042c385(arg_8h_00 + 2, arg_8h),  cVar1 != '\\0')) {\n                *puVar3 = *arg_8h_00;\n                fcn.0042c50a(arg_8h_00);\n                return 1;\n            }\n            puVar3 = arg_8h_00;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 281
    },
    "0042ce7b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ce7b(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t *in_ECX;\n    \n    if (in_ECX[8] != 0) {\n        if (arg_8h == 0) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = *(arg_8h + 0x20);\n        }\n        (**(*in_ECX + 0x118))(0x425, uVar1, 0);\n    }\n    fcn.00408480(arg_8h);\n    return;\n}\n",
        "token_count": 135
    },
    "0042d69f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042d69f(int32_t *arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint dwNewLong;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    dwNewLong = 0;\n    var_4h = 0;\n    if (0x40046 < *0x49776c) {\n        dwNewLong = fcn.00418009();\n        iVar4 = fcn.0041803d(0, 0x8800, 0);\n        if (0x5ffff < *0x49776c) {\n            if (in_ECX == 0) {\n                uVar1 = 0;\n            }\n            else {\n                uVar1 = *(in_ECX + 0x20);\n            }\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar2 != 0) {\n                uVar3 = fcn.0042cba2();\n                var_4h = fcn.0042cbb5(uVar3 & 0xfffffffe);\n            }\n        }\n    }\n    iVar2 = fcn.0041ae6e();\n    if (iVar2 != 0) {\n        *arg_8h = arg_ch;\n        arg_8h[1] = arg_ch >> 0x10;\n    }\n    if (iVar4 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(in_ECX + 0x20), 0xfffffff0, dwNewLong);\n    }\n    if (var_4h != 0) {\n        fcn.0042cbb5(var_4h);\n    }\n    return iVar2;\n}\n",
        "token_count": 413
    },
    "0042d8c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d8c9(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_ch;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x18) = 1;\n    uVar1 = fcn.0042c9b8(*(in_ECX + 8));\n    arg_ch = uVar1 & 0xfffbffff;\n    if (arg_8h == 0) {\n        arg_ch = uVar1 & 0xfff9ffff | 0x40000;\n    }\n    fcn.0042d15f(*(in_ECX + 8), arg_ch);\n    return;\n}\n",
        "token_count": 155
    },
    "0042d90c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d90c(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    uVar1 = fcn.0042c9b8(*(in_ECX + 8));\n    uVar1 = uVar1 & 0xffeeffff;\n    if (arg_8h == 1) {\n        uVar1 = uVar1 | 0x10000;\n    }\n    else if (arg_8h == 2) {\n        uVar1 = uVar1 | 0x100000;\n    }\n    fcn.0042d15f(*(in_ECX + 8), uVar1 | 2);\n    return;\n}\n",
        "token_count": 162
    },
    "0042e01d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e01d(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    if ((arg_ch != 0) && (arg_10h != 0)) {\n        puVar2 = fcn.00414af6(arg_ch * arg_10h + 4);\n        *puVar2 = *arg_8h;\n        *arg_8h = puVar2;\n        return;\n    }\n    fcn.0041638e();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 149
    },
    "0042e2f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042e2f0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    \n    if ((*(param_1 + 0x20) != 0) && (iVar1 = fcn.00430eac(),  iVar1 != 0)) {\n        piVar2 = fcn.00430e96();\n    // WARNING: Could not recover jumptable at 0x0042e310. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar3 = (**(*piVar2 + 0x60))();\n        return uVar3;\n    }\n    uVar3 = 0;\n    if (*(param_1 + 0x20) == 0) {\n        if (*(param_1 + 0x50) == 0) {\n            return 0;\n        }\n    }\n    else {\n        iVar1 = fcn.0041aea0(0);\n        if (iVar1 == 0) {\n            fcn.0041638e();\n        }\n        fcn.0044aa2d(*(param_1 + 0x20));\n    }\n    if ((*(param_1 + 0x20) != 0) || (*(param_1 + 0x50) != 0)) {\n        if (*(param_1 + 0x50) == 0) {\n            uVar3 = (*_sym.imp.USER32.dll_DestroyWindow)(*(param_1 + 0x20));\n        }\n        else {\n            uVar3 = (**(**(param_1 + 0x50) + 0x58))();\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 379
    },
    "0042e4ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e4ea(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    uVar1 = *(in_ECX + 0x84);\n    if ((uVar1 & 0x100) != 0) {\n        *arg_8h = *arg_8h + *0x49be50;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        arg_8h[1] = arg_8h[1] + *0x49be54;\n    }\n    if ((uVar1 & 0x400) != 0) {\n        arg_8h[2] = arg_8h[2] - *0x49be50;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        arg_8h[3] = arg_8h[3] - *0x49be54;\n    }\n    if (arg_ch == 0) {\n        *arg_8h = *arg_8h + *(in_ECX + 100);\n        arg_8h[1] = arg_8h[1] + *(in_ECX + 0x5c);\n        arg_8h[2] = arg_8h[2] - *(in_ECX + 0x68);\n        arg_8h[3] = arg_8h[3] - *(in_ECX + 0x60);\n        if ((*(in_ECX + 0x84) & 0x400001) == 0x400000) {\n            arg_8h[1] = arg_8h[1] + 7;\n        }\n    }\n    else {\n        *arg_8h = *arg_8h + *(in_ECX + 0x5c);\n        arg_8h[1] = arg_8h[1] + *(in_ECX + 100);\n        arg_8h[2] = arg_8h[2] - *(in_ECX + 0x60);\n        arg_8h[3] = arg_8h[3] - *(in_ECX + 0x68);\n        if ((*(in_ECX + 0x84) & 0x400001) == 0x400000) {\n            *arg_8h = *arg_8h + 7;\n        }\n    }\n    return;\n}\n",
        "token_count": 551
    },
    "0042e623": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e623(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    if ((arg_ch == 0) || (arg_10h == 0)) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 0x7fff;\n    }\n    *arg_8h = uVar1;\n    if ((arg_ch == 0) || (arg_10h != 0)) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 0x7fff;\n    }\n    arg_8h[1] = uVar1;\n    return;\n}\n",
        "token_count": 160
    },
    "0042e697": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e697(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_8h_00;\n    int32_t *piVar6;\n    int32_t *in_ECX;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar2 < 0) {\n        return;\n    }\n    iVar3 = fcn.0042055d();\n    var_8h = iVar3;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[8], &var_10h);\n    var_4h = (**(*in_ECX + 0x74))(var_10h, var_ch, 0);\n    if (var_4h < 0) {\n        *(iVar3 + 0x4c) = 0xffffffff;\n    }\n    else {\n        iVar4 = fcn.0041c59b();\n        iVar5 = fcn.0041d6f0();\n        if (iVar5 == 0) {\ncode_r0x0042e714:\n            var_4h = -1;\n        }\n        else {\n            if (iVar4 == 0) {\n                fcn.0041638e();\n            }\n            iVar5 = fcn.00418187();\n            if (iVar5 == 0) goto code_r0x0042e714;\n        }\n        if (*(iVar3 + 0x3c) == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *(*(iVar3 + 0x3c) + 0x20);\n        }\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetCapture)();\n        piVar6 = fcn.0041af14(arg_8h_00);\n        if (piVar6 != in_ECX) {\n            if (piVar6 == NULL) {\n                iVar5 = 0;\n            }\n            else {\n                iVar5 = piVar6[8];\n            }\n            if ((iVar5 != iVar3) && (iVar3 = fcn.0041c59b(),  iVar3 == iVar4)) {\n                var_4h = -1;\n            }\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_KillTimer;\n    if (-1 < var_4h) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[8], &var_10h);\n        iVar3 = (*_sym.imp.USER32.dll_WindowFromPoint)(var_10h, var_ch);\n        if (iVar3 == 0) {\ncode_r0x0042e7a9:\n            var_4h = -1;\n            *(var_8h + 0x4c) = 0xffffffff;\n        }\n        else if ((iVar3 != in_ECX[8]) && (iVar4 = (*_sym.imp.USER32.dll_IsChild)(in_ECX[8], iVar3),  iVar4 == 0)) {\n            iVar4 = *(var_8h + 0x3c);\n            if (iVar4 != 0) {\n                iVar4 = *(iVar4 + 0x20);\n            }\n            if (iVar4 != iVar3) goto code_r0x0042e7a9;\n        }\n        if (-1 < var_4h) goto code_r0x0042e7d9;\n    }\n    if (*(var_8h + 0x4c) == -1) {\n        (*pcVar1)(in_ECX[8], 0xe001);\n    }\n    (**(*in_ECX + 0x178))(0xffffffff);\ncode_r0x0042e7d9:\n    if ((arg_8h == 0xe000) && ((*pcVar1)(in_ECX[8], 0xe000),  -1 < var_4h)) {\n        (**(*in_ECX + 0x178))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 947
    },
    "0042eb3d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042eb3d(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x24] != 0) && (iVar1 = (**(*in_ECX + 0x74))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[8], &arg_ch);\n        (***in_ECX[0x25])(arg_ch, arg_10h);\n        return;\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 156
    },
    "0042eb8b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042eb8b(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x24] != 0) && (iVar1 = (**(*in_ECX + 0x74))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (**(*in_ECX[0x25] + 8))();\n        return;\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 131
    },
    "0042f5e7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f5e7(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    iVar1 = *(in_ECX + 0x74);\n    if (iVar1 != arg_8h) {\n        if ((iVar1 != 0) && (arg_10h != 0)) {\n            fcn.0044b044(iVar1);\n        }\n        *(in_ECX + 0x74) = arg_8h;\n    }\n    iVar1 = *(in_ECX + 0x70);\n    if (iVar1 != arg_ch) {\n        if ((iVar1 != 0) && (arg_10h != 0)) {\n            fcn.0044b044(iVar1);\n        }\n        *(in_ECX + 0x70) = arg_ch;\n    }\n    return;\n}\n",
        "token_count": 210
    },
    "0042f661": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f661(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        uVar1 = fcn.0041ac5f(0x47cf80);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x50) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x50);\n    return;\n}\n",
        "token_count": 130
    },
    "0042f700": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0042f700(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "0042f972": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042f972(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n    }\n    fcn.0042f736(0);\n    *(arg_8h[0x1d] + 8) = *(in_ECX + 0x70);\n    *(arg_8h[0x1d] + 0xc) = *(in_ECX + 0x74);\n    while( true ) {\n        iVar2 = (**(*arg_8h + 0x14c))();\n        if ((iVar2 == 1) || (iVar2 == 2)) {\n            *(in_ECX + 0x70) = *(arg_8h[0x1d] + 8);\n            *(in_ECX + 0x74) = *(arg_8h[0x1d] + 0xc);\n            return iVar2;\n        }\n        fcn.0042052a();\n        iVar1 = fcn.0042f690();\n        if ((iVar1 != 0x1009) && (1 < iVar1 - 0x100bU)) break;\n        if (*(arg_8h[0x1d] + 0xc) != 0) {\n            fcn.0044b044(*(arg_8h[0x1d] + 0xc));\n            *(arg_8h[0x1d] + 0xc) = 0;\n            *(in_ECX + 0x74) = 0;\n        }\n        if (*(arg_8h[0x1d] + 8) != 0) {\n            fcn.0044b044(*(arg_8h[0x1d] + 8));\n            *(arg_8h[0x1d] + 8) = 0;\n            *(in_ECX + 0x70) = 0;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 462
    },
    "0042fa29": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042fa29(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    fcn.0042f736(*(in_ECX + 0x74) == 0);\n    if (*(in_ECX + 0x74) == 0) {\n        uVar2 = 0;\n    }\n    else {\n        if (arg_8h == 0) {\n            arg_8h = fcn.0041638e();\n        }\n        *(arg_8h + 0xc) = *(in_ECX + 0x74);\n        pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n        *(arg_8h + 8) = *(in_ECX + 0x70);\n        (*pcVar1)(*(in_ECX + 0x74));\n        (*pcVar1)(*(in_ECX + 0x70));\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 229
    },
    "0042ff14": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.0042ff14(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *var_4h;\n    \n    if ((param_1[0x39] & 8U) != 0) {\n        var_4h = param_1;\n        (**(*param_1 + 0x150))(param_1[0x39] & 4);\n    }\n    var_4h = param_1[0x22];\n    while (var_4h != NULL) {\n        piVar1 = fcn.00411a80(&var_4h);\n        fcn.0041b723(*piVar1, *(*piVar1 + 0x20), 0x363, 1, 0);\n    }\n    return;\n}\n",
        "token_count": 196
    },
    "00430354": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430354(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    \n    pcVar1 = _sym.imp.USER32.dll_CopyRect;\n    if (in_ECX[0x54] == 0) {\n        in_ECX[0x54] = 1;\n        (*pcVar1)(in_ECX + 0x4c, arg_8h);\n        (*pcVar1)(in_ECX + 0x50, arg_ch);\n        (**(*in_ECX + 0x150))(1);\n        in_ECX[0x54] = 0;\n    }\n    return;\n}\n",
        "token_count": 153
    },
    "00430630": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430630(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (*arg_ch != 0) {\n        fcn.00418f77(arg_ch, *(in_ECX + 0x20), arg_ch + 1);\n    }\n    (*_sym.imp.USER32.dll_InflateRect)(arg_ch + 1, -*(in_ECX + 0xb8), -*(in_ECX + 0xb8));\n    return 0;\n}\n",
        "token_count": 118
    },
    "00430853": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430853(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    iVar2 = fcn.0041b98e();\n    if (iVar2 == 0) {\n        fcn.0041638e();\n    }\n    uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar2 + 0x20));\n    iVar4 = fcn.0041af14(uVar3);\n    pcVar1 = _sym.imp.USER32.dll_UpdateWindow;\n    var_4h = iVar4;\n    (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar2 + 0x20));\n    if (iVar4 != 0) {\n        (*pcVar1)(*(iVar4 + 0x20));\n        (*_sym.imp.USER32.dll_GetClientRect)(*(iVar4 + 0x20), &var_24h);\n        fcn.004172e2(&var_24h);\n        (*_sym.imp.USER32.dll_ClipCursor)(&var_24h);\n    }\n    var_24h = *(in_ECX + 0xa0);\n    uStack36 = *(in_ECX + 0xa4);\n    uStack32 = *(in_ECX + 0xa8);\n    uStack28 = *(in_ECX + 0xac);\n    var_4h = fcn.00450453(in_ECX, arg_ch, arg_10h, 0, var_4h);\n    var_14h = *(in_ECX + 0xa0);\n    uStack20 = *(in_ECX + 0xa4);\n    uStack16 = *(in_ECX + 0xa8);\n    uStack12 = *(in_ECX + 0xac);\n    *(in_ECX + 0xa0) = var_24h;\n    *(in_ECX + 0xa4) = uStack36;\n    *(in_ECX + 0xa8) = uStack32;\n    *(in_ECX + 0xac) = uStack28;\n    (*_sym.imp.USER32.dll_ClipCursor)(0);\n    if (var_4h != 0) {\n        iVar2 = fcn.00405790();\n        fcn.004172e2(&var_14h);\n        fcn.004172a1(&var_14h);\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(in_ECX + 0x20));\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x20), 0x369, uVar3, &var_14h);\n    }\n    return;\n}\n",
        "token_count": 673
    },
    "00430bb0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430bb0(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_ch;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    arg_ch = (*_sym.imp.USER32.dll_GetWindow)(uVar2);\n    pcVar1 = _sym.imp.USER32.dll_ShowWindow;\n    for (; arg_ch != 0; arg_ch = (*_sym.imp.USER32.dll_GetWindow)(arg_ch, 2)) {\n        iVar3 = fcn.0041af40(arg_ch);\n        if (((iVar3 != 0) && (*(in_ECX + 0x20) != arg_ch)) &&\n           (iVar4 = fcn.00430b17(*(in_ECX + 0x20), arg_ch),  iVar4 != 0)) {\n            uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffff0);\n            if (arg_8h == 0) {\n                if ((uVar5 & 0x18000000) == 0x10000000) {\n                    (*pcVar1)(arg_ch, 0);\n                    *(iVar3 + 0x3c) = *(iVar3 + 0x3c) | 2;\n                }\n            }\n            else if ((((uVar5 & 0x18000000) == 0) && ((*(iVar3 + 0x3c) & 2) != 0)) && (*(in_ECX + 0xb4) == 0)) {\n                (*pcVar1)(arg_ch, 4);\n                *(iVar3 + 0x3c) = *(iVar3 + 0x3c) & 0xfffffffd;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 437
    },
    "00430c5a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430c5a(int32_t arg_8h)\n\n{\n    if (*(arg_8h + 0x28) == 0) {\n        fcn.0041de55(8);\n        *(arg_8h + 0x28) = \"AfxFrameOrView90s\";\n    }\n    if ((*(arg_8h + 0x20) & 0x8000) != 0) {\n        *(arg_8h + 0x20) = *(arg_8h + 0x20) | 0x4000;\n    }\n    *(arg_8h + 0x2c) = *(arg_8h + 0x2c) | 0x200;\n    return 1;\n}\n",
        "token_count": 171
    },
    "00430d74": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430d74(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    \n    piVar1 = *(in_ECX + 0xb0);\n    if (arg_8h != piVar1) {\n        *(in_ECX + 0xb0) = 0;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0x168))(0, arg_8h, piVar1);\n        }\n        if (((*(in_ECX + 0xb0) == 0) && (*(in_ECX + 0xb0) = arg_8h,  arg_8h != NULL)) && (arg_ch != 0)) {\n            (**(*arg_8h + 0x168))(1, arg_8h, piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 206
    },
    "00430df2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430df2(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x80) != NULL) {\n        (**(**(in_ECX + 0x80) + 0x78))(arg_8h);\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 83
    },
    "00430eac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00430eac(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_1 + 0x170))();\n    if (iVar1 != 0) {\n        return param_1[0x26];\n    }\n    if ((param_1[0x24] != 0) && (*(param_1[0x24] + 0x98) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 117
    },
    "00431118": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00431118(int32_t param_1)\n\n{\n    fcn.0041ae6e();\n    if (*(param_1 + 0x80) != NULL) {\n    // WARNING: Could not recover jumptable at 0x00431138. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x80) + 0x6c))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 107
    },
    "004314a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004314a8(uint arg_8h, uint lpIconName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_58h;\n    uint var_38h;\n    int32_t var_30h;\n    uint var_28h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar1 = fcn.0042052a();\n    iVar1 = (*_sym.imp.USER32.dll_LoadIconA)(*(iVar1 + 0xc), lpIconName);\n    if (iVar1 != 0) {\n        fcn.00458b20(&var_58h, 0, 0x30);\n        var_38h = arg_8h;\n        (**(*in_ECX + 100))(&var_58h);\n        if (var_30h != 0) {\n            iVar2 = fcn.0042052a();\n            iVar2 = fcn.00419585(*(iVar2 + 8), var_30h, &var_28h);\n            if ((iVar2 != 0) && (var_14h != iVar1)) {\n                uVar3 = fcn.0041dbe1(var_28h, var_10h, var_ch, iVar1);\n                return uVar3;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 320
    },
    "004315f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004315f8(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if (param_1[0x2d] != NULL) {\n        (*param_1[0x2d])(param_1);\n    }\n    piVar1 = (**(*param_1 + 0x144))();\n    if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x8c))(param_1),  iVar2 == 0)) {\n        return;\n    }\n    iVar2 = fcn.0042052a();\n    piVar3 = *(iVar2 + 4);\n    if ((piVar3 != NULL) && (piVar3[8] == param_1)) {\n        if ((piVar1 == NULL) && (iVar2 = (**(*piVar3 + 0x94))(),  iVar2 == 0)) {\n            return;\n        }\n        fcn.00437921();\n        fcn.00437889();\n        iVar2 = fcn.00441d41();\n        if (iVar2 == 0) {\n            fcn.00441d61(0);\n            return;\n        }\n        iVar2 = fcn.0042052a();\n        if ((*(iVar2 + 0x14) == '\\0') && (piVar3[8] == 0)) {\n            fcn.0043e2fc(0);\n            return;\n        }\n    }\n    if ((piVar1 != NULL) && (piVar1[0x13] != 0)) {\n        var_4h = (**(*piVar1 + 0x60))();\n        do {\n            if (var_4h == NULL) {\n                (**(*piVar1 + 0x7c))();\n                return;\n            }\n            iVar2 = (**(*piVar1 + 100))(&var_4h);\n            if (iVar2 == 0) {\n                fcn.0041638e();\n                break;\n            }\n            piVar3 = fcn.0041b98e();\n        } while (piVar3 == param_1);\n        (**(*piVar1 + 0x94))(param_1);\n    }\n    (**(*param_1 + 0x60))();\n    return;\n}\n",
        "token_count": 538
    },
    "004317e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004317e0(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *piVar3;\n    \n    uVar1 = arg_8h;\n    fcn.00419e44(arg_8h);\n    (**(*in_ECX + 0x188))(uVar1, arg_ch);\n    if (in_ECX[0x20] != 0) {\n        if ((arg_8h == 0) || (arg_8h >> 0x10 != 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        (**(*in_ECX[0x20] + 0x58))(uVar1);\n    }\n    iVar2 = fcn.004379b3();\n    if (*(iVar2 + 0x20) == in_ECX) {\n        piVar3 = in_ECX[0x2c];\n        if (piVar3 == NULL) {\n            iVar2 = (**(*in_ECX + 0x148))();\n            piVar3 = *(iVar2 + 0xb0);\n            if (piVar3 == NULL) goto code_r0x0043185c;\n        }\n        (**(*piVar3 + 0x168))(0, piVar3, piVar3);\n    }\ncode_r0x0043185c:\n    (*_sym.imp.USER32.dll_PostMessageA)(in_ECX[8], 0x36a, 0, 0);\n    return 0;\n}\n",
        "token_count": 358
    },
    "00431973": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431973(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar2 = fcn.0041b9cd();\n    if (iVar2 == 0) {\n        iVar2 = fcn.0041638e();\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    arg_8h = arg_8h & 0xfff0;\n    if (*(iVar2 + 0x68) == 0) {\ncode_r0x004319bc:\n        fcn.0041ae6e();\n    }\n    else {\n        if (arg_8h < 0xf041) {\n            if (((arg_8h != 0xf040) && (arg_8h != 0xf000)) && (arg_8h != 0xf010)) {\n                iVar2 = arg_8h - 0xf020;\ncode_r0x004319b5:\n                if ((iVar2 != 0) && (iVar2 != 0x10)) goto code_r0x004319bc;\n            }\n        }\n        else if ((arg_8h != 0xf050) && (arg_8h != 0xf060)) {\n            iVar2 = arg_8h - 0xf120;\n            goto code_r0x004319b5;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0x365, 0, (arg_8h - 0xf000 >> 4) + 0x1ef00);\n        if (iVar2 == 0) {\n            (*pcVar1)(*(in_ECX + 0x20), 0x111, 0xe147, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 412
    },
    "00431a16": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431a16(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_110h;\n    uint32_t var_10ch;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    uVar3 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(in_ECX + 0x20));\n    fcn.0041af14(uVar3);\n    pcVar2 = _sym.imp.SHELL32.dll_DragQueryFileA;\n    uVar3 = 0;\n    uVar4 = (*_sym.imp.SHELL32.dll_DragQueryFileA)(arg_8h, 0xffffffff, 0, 0);\n    iVar5 = fcn.0042052a();\n    var_10ch = 0;\n    piVar1 = *(iVar5 + 4);\n    if (uVar4 != 0) {\n        do {\n            (*pcVar2)(arg_8h, var_10ch, &var_108h, 0x104);\n            (**(*piVar1 + 0x88))(&var_108h);\n            var_10ch = var_10ch + 1;\n        } while (var_10ch < uVar4);\n    }\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    fcn.0045843c(uVar3);\n    return;\n}\n",
        "token_count": 369
    },
    "00431ae7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431ae7(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_8h != 0) {\n        iVar2 = fcn.0042052a();\n        piVar1 = *(iVar2 + 4);\n        if ((piVar1 != NULL) && (piVar1[8] == in_ECX)) {\n            fcn.00441d61(1);\n            fcn.00437889(1);\n            (**(*piVar1 + 0x68))();\n        }\n    }\n    return;\n}\n",
        "token_count": 146
    },
    "00431b24": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_110h\n\nvoid __cdecl fcn.00431b24(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int16_t iVar4;\n    int32_t in_ECX;\n    uint var_110h;\n    uint var_10ch;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    iVar3 = fcn.0042052a();\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalGetAtomNameA;\n    iVar3 = *(iVar3 + 4);\n    if ((((iVar3 != 0) && (arg_ch != 0)) && (iVar4 = arg_ch >> 0x10,  iVar4 != 0)) &&\n       ((arg_ch == *(iVar3 + 0x90) && (iVar4 == *(iVar3 + 0x92))))) {\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(*(iVar3 + 0x90), &var_108h, 0x103);\n        pcVar1 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&var_108h);\n        (*pcVar2)(*(iVar3 + 0x92), &var_108h, 0x103);\n        (*pcVar1)(&var_108h);\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x3e4, *(in_ECX + 0x20), *(iVar3 + 0x90));\n    }\n    fcn.0045843c(in_ECX);\n    return;\n}\n",
        "token_count": 405
    },
    "00431c20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431c20(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint nCmdShow;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n    }\n    piVar1 = fcn.00430e96();\n    if (arg_10h == 0) {\n        fcn.0041822e(0, 0, 0, 0, 0, (-(arg_ch != 0) & 0xffffffc0) + 0x80 | 0x17);\n        (**(*arg_8h + 0x164))(arg_ch);\n        if ((arg_ch != 0) || (iVar2 = fcn.00430eac(),  iVar2 == 0)) {\n            (**(*piVar1 + 0x150))(0);\n        }\n    }\n    else {\n        (**(*arg_8h + 0x164))(arg_ch);\n        piVar1[0x39] = piVar1[0x39] | 0xc;\n    }\n    iVar2 = fcn.00430eac();\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_8h[0x24] == NULL) {\n        uVar3 = arg_ch != 0;\n    }\n    else {\n        uVar3 = (**(*arg_8h[0x24] + 0x180))();\n    }\n    if (uVar3 == 1) {\n        if (arg_ch != 0) {\n            piVar1[0x28] = -1;\n            if (arg_10h == 0) {\n                nCmdShow = 8;\n                goto code_r0x00431d07;\n            }\n            piVar1[0x28] = 8;\n            goto code_r0x00431d15;\n        }\n    }\n    else if (uVar3 == 0) {\n        piVar1[0x28] = -1;\n        if (arg_10h != 0) {\n            piVar1[0x28] = 0;\n            return;\n        }\n        nCmdShow = 0;\ncode_r0x00431d07:\n        fcn.00418160(nCmdShow);\n        return;\n    }\n    if (arg_10h != 0) {\n        return;\n    }\ncode_r0x00431d15:\n    (**(*piVar1 + 0x150))(0);\n    return;\n}\n",
        "token_count": 581
    },
    "00431d25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431d25(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t in_ECX;\n    int32_t iVar8;\n    uint arg_ch_00;\n    int32_t iVar9;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0044b1eb(*(in_ECX + 0x20));\n    if ((arg_10h == 0) &&\n       ((*(in_ECX + 0x80) == NULL || (iVar2 = (**(**(in_ECX + 0x80) + 0x74))(arg_8h, arg_ch, 0),  iVar2 == 0)))) {\n        if (arg_8h == 0) {\n            fcn.0041638e();\n        }\n        fcn.0041e777();\n        iVar2 = fcn.0041ff5e();\n        if (*(iVar2 + 0x78) != *(arg_8h + 4)) {\n            if (*(in_ECX + 0xd4) == 1) {\n                iVar2 = (*_sym.imp.USER32.dll_GetMenu)(*(in_ECX + 0x20));\n            }\n            else {\n                iVar2 = *(in_ECX + 0xd8);\n            }\n            if ((((iVar2 != 0) && (piVar3 = fcn.0041c59b(),  piVar3 != NULL)) &&\n                (iVar2 = (**(*piVar3 + 0x6c))(),  iVar2 != 0)) && (iVar2 = *(iVar2 + 4),  iVar2 != 0)) {\n                iVar4 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar2);\n                iVar8 = 0;\n                if (0 < iVar4) {\n                    do {\n                        iVar9 = iVar8;\n                        iVar5 = (*_sym.imp.USER32.dll_GetSubMenu)(iVar2, iVar8);\n                        if (iVar5 == *(arg_8h + 4)) {\n                            fcn.00429dc9(iVar9, iVar2);\n                            break;\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < iVar4);\n                }\n            }\n        }\n        pcVar1 = _sym.imp.USER32.dll_GetMenuItemCount;\n        var_ch = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n        var_24h = 0;\n        if (var_ch != 0) {\n            do {\n                var_28h = fcn.00419891(var_24h);\n                uVar6 = var_ch;\n                if (var_28h != 0) {\n                    if (var_28h == 0xffffffff) {\n                        iVar2 = fcn.00412d20(var_24h);\n                        if (((iVar2 == 0) ||\n                            (var_28h = (*_sym.imp.USER32.dll_GetMenuItemID)(*(iVar2 + 4), 0),  var_28h == 0)) ||\n                           (var_28h == 0xffffffff)) goto code_r0x00431eb0;\n                        arg_ch_00 = 0;\n                    }\n                    else if ((*(in_ECX + 0x54) == 0) || (0xefff < var_28h)) {\n                        arg_ch_00 = 0;\n                    }\n                    else {\n                        arg_ch_00 = 1;\n                    }\n                    fcn.0041e79d(in_ECX, arg_ch_00);\n                    uVar6 = (*pcVar1)(*(arg_8h + 4));\n                    if (uVar6 < var_ch) {\n                        var_24h = var_24h + (uVar6 - var_ch);\n                        while ((var_24h < uVar6 && (uVar7 = fcn.00419891(var_24h),  uVar7 == var_28h))) {\n                            var_24h = var_24h + 1;\n                        }\n                    }\n                }\ncode_r0x00431eb0:\n                var_ch = uVar6;\n                var_24h = var_24h + 1;\n            } while (var_24h < var_ch);\n        }\n    }\n    return;\n}\n",
        "token_count": 1034
    },
    "004320da": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004320da(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    if (arg_8h == 0) {\n        iVar1 = 0;\n    }\n    else {\n        var_4h = *(in_ECX + 0x88);\n        do {\n            if (var_4h == 0) {\n                return 0;\n            }\n            piVar2 = fcn.00411a80(&var_4h);\n            iVar1 = *piVar2;\n            iVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar1 + 0x20));\n        } while (iVar3 != arg_8h);\n    }\n    return iVar1;\n}\n",
        "token_count": 196
    },
    "0043267e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043267e(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    fcn.0041ae6e();\n    if (arg_8h != 1) {\n        (**(*in_ECX + 0x150))(1);\n    }\n    return;\n}\n",
        "token_count": 72
    },
    "004327f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004327f6(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x3c) == 0) {\n        uVar1 = fcn.0041ac5f(\"ImageList_Draw\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x3c) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x3c);\n    return;\n}\n",
        "token_count": 131
    },
    "004328a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004328a9(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "004328df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004328df(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    piVar1 = in_ECX + 0x9c;\n    if (*piVar1 == 0) {\n        uVar2 = fcn.0041ac5f(\"ImageList_GetImageInfo\");\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        *piVar1 = iVar3;\n    }\n    *arg_8h = *piVar1;\n    return;\n}\n",
        "token_count": 143
    },
    "0043298d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0043298d(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "00432c61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432c61(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    fcn.0041b5bd(arg_8h, arg_ch);\n    if ((arg_8h == 2) && (*(in_ECX + 0xa8) != *(in_ECX + 0xac))) {\n        fcn.004320be(*(in_ECX + 0xa8));\n    }\n    return;\n}\n",
        "token_count": 106
    },
    "00432cd7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00432cd7(int32_t *param_1)\n\n{\n    if (1 < *(*param_1 + -4)) {\n        fcn.00401710(*(*param_1 + -0xc));\n    }\n    return *param_1;\n}\n",
        "token_count": 63
    },
    "00432de9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.00432de9(void)\n\n{\n    int32_t iVar1;\n    int32_t **ppiVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    uint var_48h;\n    uint var_44h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_10h;\n    int32_t iVar6;\n    uint var_4h;\n    \n    fcn.0045af3b(0x3c);\n    fcn.0040ea00(10);\n    *(unaff_EBP + -4) = 0;\n    iVar6 = 10;\n    fcn.0040ea00(10);\n    iVar1 = *(extraout_ECX + 0x88);\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = iVar1;\n    while (iVar1 != 0) {\n        ppiVar2 = fcn.00411a80(unaff_EBP + -0x10);\n        piVar4 = *ppiVar2;\n        (**(*piVar4 + 0x170))();\n        iVar6 = piVar4[8];\n        fcn.00405a60(iVar6);\n        iVar1 = *(unaff_EBP + -0x10);\n    }\n    puVar5 = *(unaff_EBP + -0x44);\n    while( true ) {\n        while( true ) {\n            do {\n                if (puVar5 == NULL) {\n                    puVar5 = *(unaff_EBP + -0x28);\n                    goto code_r0x00432ecb;\n                }\n                iVar6 = puVar5[2];\n                puVar5 = *puVar5;\n                uVar3 = fcn.0041af40();\n                piVar4 = fcn.00424c30(0x47dfd8, uVar3);\n            } while (piVar4 == NULL);\n            if (piVar4[0x26] != 0) break;\n            (**(*piVar4 + 0x60))();\n        }\n        piVar4 = fcn.0041b98e();\n        if (piVar4 == NULL) break;\n        (**(*piVar4 + 0x60))();\n    }\n    fcn.0041638e();\n    do {\n        iVar6 = puVar5[2];\n        puVar5 = *puVar5;\n        uVar3 = fcn.0041af40();\n        piVar4 = fcn.00424c30(0x47d780, uVar3);\n        if (piVar4 != NULL) {\n            (**(*piVar4 + 0x60))();\n        }\ncode_r0x00432ecb:\n    } while (puVar5 != NULL);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x2c) = vtable.CList_struct_HWND_____struct_HWND____.0;\n    fcn.004056a0(iVar6);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x48) = vtable.CList_struct_HWND_____struct_HWND____.0;\n    fcn.004056a0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 788
    },
    "00433e19": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433e19(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x18) != 0) {\n        iVar3 = *(in_ECX + 0x28);\n        iVar1 = *(in_ECX + 0x20);\n        iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, *(in_ECX + 0x24) - *(in_ECX + 0x1c), *(in_ECX + 0x3c));\n        *arg_8h = iVar2;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_8h[1], iVar3 - iVar1, *(in_ECX + 0x40));\n        arg_8h[1] = iVar3;\n    }\n    iVar3 = *(in_ECX + 0x34);\n    if (*arg_8h != iVar3 && iVar3 <= *arg_8h) {\n        *arg_8h = iVar3;\n    }\n    iVar3 = *(in_ECX + 0x38);\n    if (arg_8h[1] != iVar3 && iVar3 <= arg_8h[1]) {\n        arg_8h[1] = iVar3;\n    }\n    return;\n}\n",
        "token_count": 317
    },
    "00433e71": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433e71(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint nNumber;\n    \n    if (*(in_ECX + 0x18) != 0) {\n        iVar2 = arg_8h[1];\n        iVar3 = *(in_ECX + 0x28);\n        iVar5 = *(in_ECX + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, *(in_ECX + 0x24) - *(in_ECX + 0x1c), *(in_ECX + 0x3c));\n        iVar4 = *arg_8h;\n        iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar2, iVar3 - iVar5, *(in_ECX + 0x40));\n        fcn.00431038(iVar1 - iVar4, iVar2 - arg_8h[1]);\n    }\n    iVar2 = *arg_8h;\n    iVar3 = *(in_ECX + 0x34);\n    iVar4 = 0;\n    iVar5 = 0;\n    if ((iVar3 < iVar2) || (iVar3 = *(in_ECX + 0x2c),  iVar2 < iVar3)) {\n        iVar5 = iVar3 - iVar2;\n    }\n    iVar2 = arg_8h[1];\n    if (*(in_ECX + 0x38) < iVar2) {\n        iVar4 = *(in_ECX + 0x38) - iVar2;\n    }\n    else if (iVar2 < *(in_ECX + 0x30)) {\n        iVar4 = *(in_ECX + 0x30) - iVar2;\n    }\n    if ((iVar5 != 0) || (iVar4 != 0)) {\n        fcn.00431038(iVar5, iVar4);\n    }\n    return;\n}\n",
        "token_count": 465
    },
    "0043438f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043438f(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint lpRect;\n    uint var_10h;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(in_ECX[8]);\n    *arg_8h = uVar1;\n    arg_8h[0x16] = in_ECX;\n    uVar1 = (**(*in_ECX + 0x168))();\n    arg_8h[1] = uVar1;\n    arg_8h[7] = in_ECX[0x1c];\n    if (in_ECX[0x24] != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(in_ECX[8], &lpRect);\n        fcn.004172a1(&lpRect);\n        arg_8h[5] = lpRect;\n        arg_8h[6] = var_10h;\n        arg_8h[8] = 1;\n        arg_8h[9] = *(in_ECX[0x25] + 0x90);\n        iVar2 = in_ECX[0x25];\n        arg_8h[10] = *(iVar2 + 0x94);\n        arg_8h[0xb] = *(iVar2 + 0x98);\n        arg_8h[0xc] = *(iVar2 + 0x9c);\n        arg_8h[0xd] = *(iVar2 + 0xa0);\n        arg_8h[0xe] = *(var_4h[0x25] + 0xa4);\n        iVar2 = var_4h[0x25];\n        arg_8h[0xf] = *(iVar2 + 0xa8);\n        arg_8h[0x10] = *(iVar2 + 0xac);\n        in_ECX = var_4h;\n    }\n    iVar2 = (**(*in_ECX + 0x170))();\n    if (iVar2 != 0) {\n        fcn.00433f5e(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 506
    },
    "00434486": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00434486(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uint uVar2;\n    \n    uVar2 = 8;\n    fcn.0045af3b(8);\n    fcn.00433ddd();\n    iVar1 = *(extraout_ECX + 0x88);\n    *(unaff_EBP + 8) = iVar1;\n    while (iVar1 != 0) {\n        uVar2 = fcn.0042730e(unaff_EBP + 8);\n        *(unaff_EBP + -0x10) = uVar2;\n        iVar1 = fcn.00414af6(0x5c);\n        *(unaff_EBP + -0x14) = iVar1;\n        uVar2 = 0;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 != 0) {\n            uVar2 = fcn.00433cf4();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0043438f(uVar2);\n        fcn.00405010();\n        iVar1 = *(unaff_EBP + 8);\n    }\n    fcn.0045b013(uVar2);\n    return;\n}\n",
        "token_count": 336
    },
    "00434502": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00434502(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint32_t *puVar3;\n    uint *puVar4;\n    uint32_t arg_8h_00;\n    uint32_t uVar5;\n    uint16_t *puVar6;\n    int32_t arg_8h_01;\n    int32_t iVar7;\n    int32_t unaff_EBP;\n    int32_t iVar8;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    iVar7 = *(*(unaff_EBP + 8) + 0x4c);\n    *(unaff_EBP + -0x18) = iVar7;\n    iVar8 = iVar7;\n    while (iVar7 != 0) {\n        iVar8 = iVar8 + -1;\n        piVar2 = fcn.00433c4b(iVar8);\n        if ((*piVar2 != 0) && (piVar2 = fcn.00433c4b(iVar8),  *piVar2 != 0x10000)) break;\n        iVar7 = iVar7 + -1;\n        *(unaff_EBP + -0x18) = iVar7;\n    }\n    *(unaff_EBP + -0x10) = 1;\n    if (1 < iVar7) {\n        *(unaff_EBP + -0x14) = *(unaff_EBP + 8) + 0x44;\n        do {\n            puVar3 = fcn.00433c4b(*(unaff_EBP + -0x10));\n            if (*puVar3 < 0x10000) {\n                puVar4 = fcn.00433c4b(*(unaff_EBP + -0x10));\n                arg_8h_00 = fcn.004320da(*puVar4);\n                if (arg_8h_00 != 0) {\n                    (*_sym.imp.USER32.dll_GetParent)(*(arg_8h_00 + 0x20));\n                    iVar7 = fcn.0041af14(0x4345aa);\n                    if (iVar7 != arg_8h_01) {\n                        fcn.00433cd1(arg_8h_01);\n                    }\n                    if (*(arg_8h_00 + 0x90) != 0) {\n                        fcn.00435e36(arg_8h_00, 0xffffffff, 0xffffffff);\n                    }\n                    fcn.00435dcd(arg_8h_00);\n                    *(arg_8h_00 + 0x90) = arg_8h_01;\n                    uVar5 = (*(arg_8h_00 + 0x84) ^ *(arg_8h_01 + 0x84)) & 0xf000 ^ *(arg_8h_00 + 0x84);\n                    if (*(arg_8h_01 + 0x98) == 0) {\n                        uVar5 = uVar5 & 0xfffffffe | 0xf00;\n                    }\n                    else {\n                        uVar5 = uVar5 | 0xf01;\n                    }\n                    fcn.0042e179(uVar5);\n                    if (*(arg_8h_01 + 0x98) != 0) {\n                        if ((*(arg_8h_00 + 0x88) & 0x40) != 0) {\n                            *(arg_8h_01 + 0x84) = *(arg_8h_01 + 0x84) | 0x40;\n                        }\n                        iVar7 = fcn.0041b98e();\n                        if (iVar7 == 0) {\n                            fcn.0041638e();\n                            pcVar1 = swi(3);\n                            (*pcVar1)();\n                            return;\n                        }\n                        if (*(iVar7 + 0x38) == 0) {\n                            *(iVar7 + 0x38) = *(arg_8h_00 + 0x20);\n                        }\n                        if ((*(arg_8h_00 + 0x84) & 4) != 0) {\n                            fcn.0041803d(0x800, 0, 0);\n                        }\n                    }\n                    if ((*(unaff_EBP + -0x10) == 1) && ((*(arg_8h_01 + 0x84) & 0x40) == 0)) {\n                        fcn.00401e60();\n                        *(unaff_EBP + -4) = 0;\n                        fcn.0041c2d9(unaff_EBP + 8);\n                        fcn.0044af85(*(arg_8h_01 + 0x20), *(unaff_EBP + 8));\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.004010f0();\n                    }\n                    iVar7 = *(unaff_EBP + -0x18);\n                }\n            }\n            else {\n                puVar6 = fcn.00433c4b(*(unaff_EBP + -0x10));\n                arg_8h_00 = *puVar6;\n                fcn.00435dcd(arg_8h_00);\n            }\n            fcn.0042c207(*(unaff_EBP + -0x10), arg_8h_00, 1);\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n        } while (*(unaff_EBP + -0x10) < iVar7);\n    }\n    iVar8 = *(arg_8h_01 + 0xa4);\n    if ((iVar7 < iVar8) && (piVar2 = fcn.00404ff0(iVar7),  *piVar2 != 0)) {\n        fcn.0042c207(iVar7, 0, 1);\n        iVar8 = iVar8 + 1;\n    }\n    piVar2 = fcn.00404ff0(iVar8 + -1);\n    if (*piVar2 != 0) {\n        fcn.0042c207(iVar8, 0, 1);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1435
    },
    "00434807": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00434807(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    int32_t iVar6;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_8h = 0;\n    if (0 < *(arg_8h + 0xc)) {\n        do {\n            puVar2 = fcn.00420885(var_8h);\n            if (puVar2[2] == 0) {\n                iVar6 = fcn.004320da(*puVar2);\n                puVar2[0x16] = iVar6;\n                if ((*(iVar6 + 0x90) != 0) && (*(*(iVar6 + 0x90) + 0x98) != 0)) {\n                    fcn.0043546d(iVar6, 0, 0);\n                }\n            }\n            else {\n                piVar3 = fcn.004352a9((-(puVar2[3] != 0) & 0x1000) + 0x1000);\n                fcn.0040b870(puVar2[5], puVar2[6], 10, 10);\n                (**(*piVar3 + 0x68))(&var_18h, 0);\n                var_14h = 0;\n                var_18h = 0;\n                fcn.0041822e(0, 0, 0, 0, 0, 0x15);\n                uVar4 = fcn.00417f55(0xe81f);\n                puVar2[0x16] = uVar4;\n            }\n            if (puVar2[0x16] != 0) {\n                *(puVar2[0x16] + 0x70) = puVar2[7];\n            }\n            var_8h = var_8h + 1;\n        } while (var_8h < *(arg_8h + 0xc));\n    }\n    iVar6 = 0;\n    if (0 < *(arg_8h + 0xc)) {\n        do {\n            iVar5 = fcn.00420885(iVar6);\n            if (*(iVar5 + 0x58) != 0) {\n                fcn.00434729(iVar5, in_ECX);\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < *(arg_8h + 0xc));\n    }\n    iVar6 = 0;\n    if (0 < *(arg_8h + 0xc)) {\n        do {\n            iVar5 = fcn.00420885(iVar6);\n            if (((*(iVar5 + 0x58) != NULL) && (*(iVar5 + 8) != 0)) &&\n               (iVar5 = (**(**(iVar5 + 0x58) + 0x180))(),  0 < iVar5)) {\n                piVar3 = fcn.0041b98e();\n                if (piVar3 == NULL) {\n                    fcn.0041638e();\n                    pcVar1 = swi(3);\n                    (*pcVar1)();\n                    return;\n                }\n                (**(*piVar3 + 0x150))(1);\n                fcn.00418160(8);\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < *(arg_8h + 0xc));\n    }\n    *(in_ECX + 0xe4) = *(in_ECX + 0xe4) | 0xc;\n    return;\n}\n",
        "token_count": 865
    },
    "00435497": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435497(int32_t arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint var_4h;\n    \n    if (arg_8h != 0) goto code_r0x004354b1;\ncode_r0x004354ac:\n    do {\n        fcn.0041638e();\ncode_r0x004354b1:\n        if (((*(arg_8h + 0x8c) != 0) && (iVar3 = *(arg_8h + 0x90),  iVar3 != 0)) && (*(iVar3 + 0x98) != 0)) {\n            iVar1 = fcn.00435d61();\n            if ((iVar1 == 1) && ((*(iVar3 + 0x84) & arg_14h & 0xf000) != 0)) {\n                arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(*(iVar3 + 0x20));\n                piVar2 = fcn.0041af14(arg_8h_00);\n                if (piVar2 != NULL) {\n                    fcn.0041822e(0, arg_ch, arg_10h, 0, 0, 0x15);\n                    (**(*piVar2 + 0x150))(1);\n                    goto code_r0x004355bb;\n                }\n                goto code_r0x004354ac;\n            }\n        }\n        uVar4 = arg_14h;\n        if (((*(arg_8h + 0x84) & 4) != 0) && (uVar4 = arg_14h | 4,  (arg_14h & 0x5000) != 0)) {\n            uVar4 = arg_14h & 0xffff2fff | 0x2004;\n        }\n        arg_14h = uVar4;\n        piVar2 = fcn.004352a9(arg_14h);\n        if (piVar2 != NULL) {\n            fcn.0041822e(0, arg_ch, arg_10h, 0, 0, 0x15);\n            if (piVar2[0xe] == 0) {\n                piVar2[0xe] = *(arg_8h + 0x20);\n            }\n            iVar3 = fcn.00417f55(0xe81f);\n            if (iVar3 != 0) {\n                fcn.00436570(arg_8h, 0);\n                (**(*piVar2 + 0x150))(1);\n                uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_8h + 0x20), 0xfffffff0);\n                if ((uVar4 & 0x10000000) != 0) {\n                    fcn.00418160(8);\ncode_r0x004355bb:\n                    (*_sym.imp.USER32.dll_UpdateWindow)(piVar2[8]);\n                }\n                return;\n            }\n        }\n    } while( true );\n}\n",
        "token_count": 718
    },
    "004355cb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.004355cb(uint lprcSrc2, uint noname_1, uint noname_2, uint noname_3, uint32_t arg_18h, int32_t **arg_1ch)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t lprcSrc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar2 = arg_1ch;\n    arg_18h = arg_18h & 0xf040;\n    if (arg_1ch != NULL) {\n        *arg_1ch = NULL;\n    }\n    arg_1ch = *(in_ECX + 0x88);\n    do {\n        do {\n            if (arg_1ch == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.00411a80(&arg_1ch);\n            piVar1 = *ppiVar3;\n            iVar4 = (**(*piVar1 + 0x170))();\n        } while ((((iVar4 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowVisible)(piVar1[8]),  iVar4 == 0)) ||\n                 ((piVar1[0x21] & arg_18h & 0xf000) == 0)) ||\n                ((piVar1[0x26] != 0 && ((piVar1[0x21] & arg_18h & 0x40) == 0))));\n        (*_sym.imp.USER32.dll_GetWindowRect)(piVar1[8], &lprcSrc1);\n        if (var_8h == lprcSrc1) {\n            var_8h = var_8h + 1;\n        }\n        if (var_4h == var_ch) {\n            var_4h = var_4h + 1;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcSrc1, &lprcSrc1, &lprcSrc2);\n    } while (iVar4 == 0);\n    if (ppiVar2 != NULL) {\n        *ppiVar2 = piVar1;\n    }\n    return piVar1[0x21] & arg_18h;\n}\n",
        "token_count": 540
    },
    "00435bd4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435bd4(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    if (arg_8h == 2) {\n        fcn.0041d72d();\n        if ((*(in_ECX + 0x17c) & 0x40) != 0) {\ncode_r0x00435c84:\n            fcn.0041ae6e();\n            return;\n        }\n        iVar2 = 1;\n        iVar1 = 0;\n        do {\n            if (*(in_ECX + 0x19c) <= iVar2) break;\n            iVar1 = fcn.00435a42(iVar2);\n            iVar2 = iVar2 + 1;\n        } while (iVar1 == 0);\n        if (iVar1 != 0) goto code_r0x00435c1f;\n    }\n    else {\n        if (7 < arg_8h - 10U) goto code_r0x00435c84;\n        fcn.0041d72d();\n        iVar2 = 1;\n        iVar1 = 0;\n        do {\n            if (*(in_ECX + 0x19c) <= iVar2) break;\n            iVar1 = fcn.00435a42(iVar2);\n            iVar2 = iVar2 + 1;\n        } while (iVar1 == 0);\n        if ((iVar1 != 0) && (*(iVar1 + 0x94) != NULL)) {\n            (**(**(iVar1 + 0x94) + 4))(arg_8h, arg_ch, arg_10h);\n            return;\n        }\n    }\n    do {\n        iVar1 = fcn.0041638e();\ncode_r0x00435c1f:\n    } while (*(iVar1 + 0x94) == 0);\n    (****(iVar1 + 0x94))(arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 449
    },
    "00435c92": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435c92(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    \n    if ((arg_8h != 2) || (fcn.0041d72d(),  (*(in_ECX + 0x17c) & 0x40) != 0)) {\n        fcn.0041ae6e();\n        return;\n    }\n    arg_8h_00 = 1;\n    iVar1 = 0;\n    do {\n        if (*(in_ECX + 0x19c) <= arg_8h_00) break;\n        iVar1 = fcn.00435a42(arg_8h_00);\n        arg_8h_00 = arg_8h_00 + 1;\n    } while (iVar1 == 0);\n    if (iVar1 != 0) goto code_r0x00435cd7;\n    do {\n        iVar1 = fcn.0041638e();\ncode_r0x00435cd7:\n    } while (*(iVar1 + 0x94) == NULL);\n    (**(**(iVar1 + 0x94) + 8))();\n    return;\n}\n",
        "token_count": 275
    },
    "00435dcd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435dcd(uint32_t arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t *piVar1;\n    \n    if (0xffff < arg_8h) {\n        arg_8h = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x20));\n    }\n    arg_8h_00 = fcn.00435a01(arg_8h, 0xffffffff);\n    if (0 < arg_8h_00) {\n        fcn.0042c2ad(arg_8h_00, 1);\n        piVar1 = fcn.00404ff0(arg_8h_00 + -1);\n        if (*piVar1 == 0) {\n            piVar1 = fcn.00404ff0(arg_8h_00);\n            if (*piVar1 == 0) {\n                fcn.0042c2ad(arg_8h_00, 1);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 232
    },
    "00435e36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00435e36(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    if (in_ECX != NULL) goto code_r0x00435e48;\n    do {\n        fcn.0041638e();\ncode_r0x00435e48:\n    } while ((arg_8h == 0) || (iVar1 = fcn.00435a01(arg_8h, arg_ch),  iVar1 < 1));\n    if (arg_10h == 1) {\n        puVar2 = fcn.00404ff0(iVar1);\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x20));\n        *puVar2 = uVar3;\n        puVar2 = fcn.00404ff0(iVar1);\n        iVar4 = fcn.00435a01(*puVar2, iVar1);\n        if (0 < iVar4) {\n            fcn.0042c2ad(iVar1, 1);\n            piVar5 = fcn.00404ff0();\n            if ((*piVar5 == 0) && (piVar5 = fcn.00404ff0(),  *piVar5 == 0)) {\n                fcn.0042c2ad(iVar1, 1);\n            }\n        }\n    }\n    else {\n        fcn.0042c2ad(iVar1, 1);\n        piVar5 = fcn.00404ff0(iVar1 + -1);\n        if ((*piVar5 == 0) && (piVar5 = fcn.00404ff0(iVar1),  *piVar5 == 0)) {\n            fcn.0042c2ad(iVar1, 1);\n        }\n        if (arg_10h != -1) {\n            fcn.00435dcd(arg_8h);\n        }\n    }\n    if (*(arg_8h + 0x94) != 0) {\n        piVar5 = fcn.00430e96();\n        if ((in_ECX[0x26] == 0) || (iVar1 = (**(*in_ECX + 0x180))(),  iVar1 != 0)) {\n            piVar5[0x39] = piVar5[0x39] | 0xc;\n        }\n        else {\n            iVar1 = fcn.00435d61();\n            if (iVar1 == 0) {\n                (**(*piVar5 + 0x60))();\n                return 1;\n            }\n            fcn.00418160(0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 635
    },
    "00436844": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00436844(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint arg_8h_00;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint unaff_ESI;\n    uint uVar4;\n    uint lpRect;\n    int32_t var_120h;\n    int32_t var_11ch;\n    int32_t var_118h;\n    int32_t var_114h;\n    int32_t var_110h;\n    int32_t var_10ch;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    var_11ch = arg_8h;\n    var_120h = arg_ch;\n    if (in_ECX != 0) goto code_r0x00436879;\n    do {\n        fcn.0041638e();\ncode_r0x00436879:\n    } while (arg_8h == 0);\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x20), &fcn.00436844::lpRect);\n    if (*(arg_8h + 0x90) == in_ECX) {\n        if (arg_ch == 0) goto code_r0x00436aa2;\n        iVar1 = (*_sym.imp.USER32.dll_EqualRect)(&fcn.00436844::lpRect, arg_ch);\n        if (iVar1 != 0) goto code_r0x00436aa2;\n    }\n    if ((*(in_ECX + 0x98) != 0) && ((*(arg_8h + 0x88) & 0x40) != 0)) {\n        *(in_ECX + 0x84) = *(in_ECX + 0x84) | 0x40;\n    }\n    *(in_ECX + 0x84) = *(in_ECX + 0x84) & 0xfffffff9;\n    uVar2 = *(in_ECX + 0x84);\n    *(in_ECX + 0x84) = *(arg_8h + 0x84) & 6 | uVar2;\n    if ((uVar2 & 0x40) == 0) {\n        fcn.004182b0(&fcn.00436844::var_108h, 0x104);\n        fcn.0044af85(*(in_ECX + 0x20), &fcn.00436844::var_108h);\n    }\n    uVar2 = (*(arg_8h + 0x84) ^ *(in_ECX + 0x84)) & 0xf000 ^ *(arg_8h + 0x84);\n    if (*(in_ECX + 0x98) == 0) {\n        uVar2 = uVar2 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar2 = uVar2 | 0xf01;\n    }\n    fcn.0042e179(uVar2);\n    uVar4 = *(arg_8h + 0x20);\n    arg_8h_00 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar4, 0xffffffff);\n    iVar1 = fcn.00435a01(arg_8h_00, uVar4);\n    if (0 < iVar1) {\n        piVar3 = fcn.00404ff0(iVar1);\n        *piVar3 = arg_8h;\n    }\n    if (var_120h == 0) {\n        if (iVar1 < 1) {\n            fcn.00405010(arg_8h);\n            fcn.00405010(0);\n        }\n        uVar4 = 0x115;\n        var_10ch = 0;\n        var_110h = 0;\n        var_114h = -*0x49be54;\n        var_118h = -*0x49be50;\n    }\n    else {\n        fcn.004030d0(var_120h);\n        fcn.004172a1(&fcn.00436844::var_118h);\n        if (iVar1 < 1) {\n            fcn.00435a66(var_11ch, var_118h, var_114h, var_110h, var_10ch, (var_110h - var_118h) / 2 + var_118h, \n                         (var_10ch - var_114h) / 2 + var_114h);\n            arg_8h = var_11ch;\n        }\n        var_10ch = var_10ch - var_114h;\n        uVar4 = 0x114;\n        var_110h = var_110h - var_118h;\n    }\n    fcn.0041822e(0, var_118h, var_114h, var_110h, var_10ch, uVar4);\n    (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x20));\n    iVar1 = fcn.0041af14(0x436a6e);\n    if (iVar1 != in_ECX) {\n        fcn.00433cd1(in_ECX);\n    }\n    if (*(arg_8h + 0x90) != 0) {\n        fcn.00435e36(arg_8h, 0xffffffff, 0);\n    }\n    *(arg_8h + 0x90) = in_ECX;\n    iVar1 = fcn.00430e96();\n    *(iVar1 + 0xe4) = *(iVar1 + 0xe4) | 0xc;\ncode_r0x00436aa2:\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 1304
    },
    "00437621": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437621(int32_t arg_8h)\n\n{\n    uint32_t arg_ch;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x18) = 1;\n    arg_ch = *(*(in_ECX + 8) * 0x14 + 8 + *(*(in_ECX + 0x14) + 0x78)) & 0xfbffffff;\n    if (arg_8h == 0) {\n        arg_ch = arg_ch | 0x4000000;\n    }\n    fcn.004375a3(*(in_ECX + 8), arg_ch);\n    return;\n}\n",
        "token_count": 146
    },
    "0043765e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043765e(int32_t arg_8h)\n\n{\n    uint32_t arg_ch;\n    int32_t in_ECX;\n    \n    arg_ch = *(*(in_ECX + 8) * 0x14 + 8 + *(*(in_ECX + 0x14) + 0x78)) & 0xfffffdff;\n    if (arg_8h != 0) {\n        arg_ch = arg_ch | 0x200;\n    }\n    fcn.004375a3(*(in_ECX + 8), arg_ch);\n    return;\n}\n",
        "token_count": 131
    },
    "00437870": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00437870(int32_t param_1)\n\n{\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 0x58) == 0) {\n        fcn.0041638e();\n        param_1 = extraout_ECX;\n    }\n    // WARNING: Could not recover jumptable at 0x00437886. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x58) + 0x1c))();\n    return;\n}\n",
        "token_count": 124
    },
    "00437889": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00437889(int32_t param_1)\n\n{\n    if (*(param_1 + 0x58) != 0) {\n    // WARNING: Could not recover jumptable at 0x0043789a. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x58) + 0x24))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "004378a1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004378a1(uint *arg_8h)\n\n{\n    int32_t in_ECX;\n    uint *extraout_ECX;\n    \n    if (arg_8h == NULL) {\n        in_ECX = fcn.0041638e();\n        arg_8h = extraout_ECX;\n    }\n    if (*(in_ECX + 0x88) == NULL) {\n        (***arg_8h)(0);\n    }\n    else {\n        (**(**(in_ECX + 0x88) + 0xc))(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "004379ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004379ef(uint noname_0, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_EBP;\n    \n    iVar1 = fcn.0042055d();\n    if (*(iVar1 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x00437a03. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar2 = (**(**(iVar1 + 4) + 0x6c))();\n        return uVar2;\n    }\n    if (arg_ch[1] == 1) {\n        uVar2 = 0xffffffff;\n    }\n    else {\n        if (arg_ch[1] == 0xf) {\n            (*_sym.imp.USER32.dll_ValidateRect)(*arg_ch, 0, unaff_EBP);\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 215
    },
    "00437a0c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00437a0c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af6e(0x10);\n    *(unaff_EBP + -4) = 0;\n    fcn.0044ac72();\n    fcn.0044ae8a(0xffffffff);\n    *(unaff_EBP + -4) = 2;\n    if (*(unaff_EBP + 8) == 0) {\n        iVar1 = fcn.0042055d();\n        if ((iVar1 != 0) && (*(iVar1 + 0x3c) != NULL)) {\n            (**(**(iVar1 + 0x3c) + 0x60))();\n            if (*(iVar1 + 0x3c) != NULL) {\n                (**(**(iVar1 + 0x3c) + 4))(1);\n            }\n            *(iVar1 + 0x3c) = 0;\n        }\n    }\n    iVar1 = *0x49be94;\n    *(unaff_EBP + -4) = 4;\n    if (iVar1 != 0) {\n        fcn.0044a786(*(unaff_EBP + 8), 0);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 321
    },
    "00437cba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00437cba(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    \n    iVar1 = fcn.0042055d();\n    if (((*(iVar1 + 4) == 0) || (*arg_8h != 0)) || (iVar1 = fcn.00437bd7(arg_8h),  iVar1 == 0)) {\n        piVar3 = fcn.00409ef0();\n        piVar4 = piVar3;\n        if (piVar3 != NULL) {\n            piVar4 = piVar3[8];\n        }\n        iVar1 = fcn.0041b447(piVar4, arg_8h);\n        if (iVar1 == 0) {\n            if (piVar3 != NULL) {\n                fcn.0041af14(*arg_8h);\n                piVar4 = fcn.0041c59b();\n                if (piVar4 != piVar3) {\n                    uVar2 = (**(*piVar3 + 0x108))(arg_8h);\n                    return uVar2;\n                }\n            }\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = 1;\n        }\n    }\n    else {\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 314
    },
    "00437de0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437de0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.0042055d();\n    piVar1 = *(iVar2 + 4);\n    if (piVar1 != NULL) {\n        if (piVar1[0xf] != NULL) {\n            (*piVar1[0xf])(1, 0);\n        }\n        if (arg_ch != 0) {\n            (**(*piVar1 + 0x78))();\n        }\n        *(iVar2 + 4) = 0;\n    }\n    fcn.00437a0c(0);\n    fcn.0045d49f(arg_8h);\n    return;\n}\n",
        "token_count": 174
    },
    "00437f58": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437f58(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042052a();\n    if ((*(iVar1 + 0x14) == '\\0') && ((-1 < arg_8h || (arg_8h == 0x8001)))) {\n        iVar1 = fcn.0042055d();\n        if (*(iVar1 + 4) != NULL) {\n            (**(**(iVar1 + 4) + 0x70))(arg_8h, arg_10h);\n            return;\n        }\n    }\n    iVar1 = fcn.0044a7e2(0x4163aa);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0041638e();\n    }\n    (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar1 + 0x2c), arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 231
    },
    "004380f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004380f0(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0042052a();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.0041ff5e();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, fcn.00437f58, 0, uVar2);\n        *(iVar1 + 0x2c) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 142
    },
    "0043811e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0043811e(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    if (arg_8h < 1) {\n        iVar3 = *(in_ECX + 0x20);\n        if (((iVar3 != 0) && (*(iVar3 + 0x20) != 0)) &&\n           (iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x20)),  iVar1 != 0)) {\n            fcn.0041b723(iVar3, *(iVar3 + 0x20), 0x363, 1, 0);\n            fcn.0041ba0e(*(iVar3 + 0x20), 0x363, 1, 0, 1, 1);\n        }\n        fcn.0042052a();\n        iVar1 = fcn.0042001a();\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x6c)) {\n            if ((*(iVar1 + 0x20) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0xa0) == 0) {\n                    fcn.00418160(0);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x20));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0xa0))) {\n                    fcn.0041b723(iVar1, *(iVar1 + 0x20), 0x363, 1, 0);\n                    fcn.0041ba0e(*(iVar1 + 0x20), 0x363, 1, 0, 1, 1);\n                }\n                if (0 < *(iVar1 + 0xa0)) {\n                    fcn.00418160(*(iVar1 + 0xa0));\n                }\n                *(iVar1 + 0xa0) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.0042052a();\n        iVar3 = fcn.0042001a();\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.0044ac72();\n            fcn.0044ae8a(1);\n        }\n    }\n    return arg_8h < 1;\n}\n",
        "token_count": 555
    },
    "00438850": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438850(int32_t arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    int32_t arg_10h;\n    \n    if (arg_8h != 0) {\n        arg_10h = arg_8h;\n        arg_8h_00 = fcn.004384be(arg_8h);\n        fcn.0043880a(arg_8h_00, arg_8h, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 115
    },
    "00438987": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00438987(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    \n    if (arg_ch != 0) {\n        if (arg_8h == 0) {\n            fcn.0041638e();\n        }\n        uVar1 = in_ECX[5];\n        uVar2 = in_ECX[7];\n        if (uVar1 <= uVar2) {\n            if ((uVar2 < uVar1 + arg_ch) || (uVar1 + arg_ch < uVar1)) {\n                arg_ch = uVar2 - uVar1;\n            }\n            (**(*in_ECX + 0x5c))(arg_8h, in_ECX[8] + uVar1, arg_ch);\n            in_ECX[5] = in_ECX[5] + arg_ch;\n            return arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 227
    },
    "004389db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004389db(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    \n    if (arg_ch != 0) {\n        if (arg_8h != 0) goto code_r0x004389f6;\n        do {\n            do {\n                fcn.0041638e();\ncode_r0x004389f6:\n                uVar1 = in_ECX[5] + arg_ch;\n            } while (uVar1 < in_ECX[5]);\n            if (in_ECX[6] <= uVar1 && uVar1 != in_ECX[6]) {\n                (**(*in_ECX + 100))(uVar1);\n            }\n            uVar1 = in_ECX[5] + arg_ch;\n        } while (in_ECX[6] <= uVar1 && uVar1 != in_ECX[6]);\n        (**(*in_ECX + 0x5c))(in_ECX[8] + in_ECX[5], arg_8h, arg_ch);\n        in_ECX[5] = in_ECX[5] + arg_ch;\n        uVar1 = in_ECX[5];\n        if (in_ECX[7] <= uVar1 && uVar1 != in_ECX[7]) {\n            in_ECX[7] = uVar1;\n        }\n    }\n    return;\n}\n",
        "token_count": 316
    },
    "00439065": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00439065(uint32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uint *var_8h;\n    int32_t var_4h;\n    \n    puVar2 = arg_ch;\n    *arg_ch = 1;\n    fcn.00438fd4(&arg_ch + 3);\n    if (arg_ch._3_1_ == -1) {\n        fcn.00424dfc(&arg_8h);\n        if (arg_8h == -2) {\n            *puVar2 = 2;\n            fcn.00438fd4(&arg_ch + 3);\n            if (arg_ch._3_1_ != -1) goto code_r0x0043908b;\n            fcn.00424dfc(&arg_8h);\n        }\n        if (arg_8h < 0xffff) {\n            puVar2 = arg_8h & 0xffff;\n        }\n        else {\n            fcn.00424e44(&arg_ch);\n            puVar2 = arg_ch;\n            if (arg_ch == 0xffffffff) {\n                fcn.00439018(&var_8h);\n                if ((var_4h != 0) || (puVar2 = var_8h,  0x7fffffff < var_8h)) {\n                    fcn.0043f8ce(1, 0);\n                    pcVar1 = swi(3);\n                    puVar2 = (*pcVar1)();\n                    return puVar2;\n                }\n            }\n        }\n    }\n    else {\ncode_r0x0043908b:\n        puVar2 = arg_ch >> 0x18;\n    }\n    return puVar2;\n}\n",
        "token_count": 387
    },
    "00439116": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439116(uint arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    if (arg_10h != 0) {\n        fcn.00438f55(0xff);\n        fcn.00424d7f(0xfffe);\n    }\n    if (arg_ch < 0xff) {\n        fcn.00438f55(arg_ch);\n    }\n    else {\n        fcn.00438f55(0xff);\n        if (arg_ch < 0xfffe) {\n            fcn.00424d7f(arg_ch);\n        }\n        else {\n            fcn.00424d7f(0xffff);\n            if (arg_ch == 0xffffffff) {\n                fcn.00424dbe(0xffffffff);\n                fcn.00438f90(0xffffffff, 0);\n            }\n            else {\n                fcn.00424dbe(arg_ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 214
    },
    "0043919a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0043919a(int32_t lpString1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    \n    if (lpString1 == 0) {\n        fcn.0041638e();\n    }\n    iVar1 = fcn.0042052a();\n    fcn.0044b9be(0);\n    puVar2 = *(iVar1 + 0x1c);\n    while( true ) {\n        if (puVar2 == NULL) {\n            fcn.0044ba30(0);\n            return NULL;\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(lpString1, *puVar2);\n        if (iVar1 == 0) break;\n        puVar2 = puVar2[5];\n    }\n    fcn.0044ba30(0);\n    return puVar2;\n}\n",
        "token_count": 196
    },
    "004393dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004393dc(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x24) != 0) && ((*(extraout_ECX + 0x18) & 2) == 0)) {\n        fcn.00439263();\n    }\n    fcn.00438c50();\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 169
    },
    "00439634": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00439634(uint lpAppName, uint lpValueName, int32_t nDefault)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x54) == 0) {\n        nDefault = (*_sym.imp.KERNEL32.dll_GetPrivateProfileIntA)(lpAppName, lpValueName, nDefault, *(in_ECX + 0x68));\n    }\n    else {\n        var_4h = in_ECX;\n        iVar1 = fcn.004395ec(lpAppName);\n        if (iVar1 != 0) {\n            lpAppName = 4;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(iVar1, lpValueName, 0, &var_8h, &var_4h, &lpAppName);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            if (iVar2 == 0) {\n                return var_4h;\n            }\n        }\n    }\n    return nDefault;\n}\n",
        "token_count": 258
    },
    "0043969f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043969f(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    uint lpString;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if (*(in_ECX + 0x54) == 0) {\n        fcn.00458b9a(&lpString, 0x10, 0x4771fc, arg_10h);\n        (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(arg_8h, arg_ch, &lpString, *(in_ECX + 0x68));\n    }\n    else {\n        iVar1 = fcn.004395ec(arg_8h);\n        if (iVar1 != 0) {\n            (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, arg_ch, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n        }\n    }\n    fcn.0045843c(unaff_EBX);\n    return;\n}\n",
        "token_count": 273
    },
    "00439728": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00439728(uint lpAppName, int32_t lpValueName, int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x54) == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, lpString, *(in_ECX + 0x68));\n        return uVar3;\n    }\n    if (lpValueName == 0) {\n        iVar1 = fcn.00439559();\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(iVar1, lpAppName);\n            goto code_r0x00439796;\n        }\n    }\n    else {\n        iVar1 = fcn.004395ec(lpAppName);\n        if (lpString == 0) {\n            if (iVar1 != 0) {\n                iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(iVar1, lpValueName);\ncode_r0x00439796:\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n                return iVar2 == 0;\n            }\n        }\n        else if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 1, lpString, iVar2 + 1);\n            goto code_r0x00439796;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 383
    },
    "004397c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004397c0(uint arg_8h, uint lpValueName, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x54) == 0) {\n        iVar2 = fcn.00414af6(arg_14h * 2 + 1);\n        uVar1 = 0;\n        if (arg_14h != 0) {\n            do {\n                *(iVar2 + uVar1 * 2) = (*(arg_10h + uVar1) & 0xf) + 0x41;\n                *(iVar2 + 1 + uVar1 * 2) = (*(arg_10h + uVar1) >> 4) + 0x41;\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < arg_14h);\n        }\n        *(iVar2 + uVar1 * 2) = 0;\n        uVar1 = fcn.00439728(arg_8h, lpValueName, iVar2);\n        fcn.00414b30(iVar2);\n    }\n    else {\n        uVar1 = fcn.004395ec(arg_8h);\n        if (uVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(uVar1, lpValueName, 0, 3, arg_10h, arg_14h);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uVar1);\n            uVar1 = iVar2 == 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 389
    },
    "0043ac8c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0043ac8c(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = param_1 + 0x30;\n    if (*piVar1 == 0) {\n        iVar2 = (**(*param_1 + 0xf0))();\n        *piVar1 = iVar2;\n        fcn.00446b4a();\n    }\n    return *piVar1;\n}\n",
        "token_count": 110
    },
    "0043adb6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043adb6(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    if (*(param_1 + 0xb0) != NULL) {\n        iVar2 = (*_sym.imp.USER32.dll_InSendMessage)();\n        if (iVar2 == 0) {\n            piVar1 = *(param_1 + 0xb0);\n            iVar2 = (**(*piVar1 + 0xc))(piVar1);\n            if (iVar2 != 0) {\n                fcn.00415123(iVar2);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 140
    },
    "0043b5d7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043b5d7(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    fcn.004270f1();\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        iVar1 = fcn.004270db(&var_4h);\n        if (iVar1 == 0) break;\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 4);\n    }\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        piVar2 = fcn.004270db(&var_4h);\n        if (piVar2 == NULL) break;\n        if (piVar2[0xc] != 0) {\n            (**(*piVar2 + 4))(1);\n        }\n    }\n    var_4h = (**(*param_1 + 0xb4))();\n    while( true ) {\n        iVar1 = fcn.004270db(&var_4h);\n        if (iVar1 == 0) break;\n        fcn.00446b65();\n    }\n    return;\n}\n",
        "token_count": 289
    },
    "0043d707": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043d707(void)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    if (extraout_ECX[0x2c] == 0) {\n        (**(*extraout_ECX + 0x90))();\n    }\n    else {\n        (**(*extraout_ECX + 0xc4))();\n        iVar1 = (**(*extraout_ECX + 0x58))();\n        if (iVar1 != 0) {\n            fcn.00401e60();\n            iVar1 = extraout_ECX[8];\n            *(unaff_EBP + -4) = 0;\n            fcn.0042ab38(unaff_EBP + -0x10, 0xf187, iVar1);\n            iVar1 = fcn.0041fb0a(*(unaff_EBP + -0x10), 3, 0xf187);\n            if (iVar1 == 2) {\n                fcn.004010f0();\n            }\n            else {\n                if (iVar1 == 6) {\n                    (**(*extraout_ECX + 0xec))();\n                }\n                fcn.004010f0();\n            }\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 311
    },
    "0043d7c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043d7c7(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_10h;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    if (*(extraout_ECX + 0xb0) != 0) {\n        fcn.00401e60();\n        arg_10h = *(extraout_ECX + 0xb4);\n        *(unaff_EBP + -4) = 0;\n        fcn.0042ab38(unaff_EBP + -0x10, *(unaff_EBP + 8), arg_10h);\n        if (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n            (**(**(unaff_EBP + 0xc) + 0xc))(*(unaff_EBP + -0x10));\n        }\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 277
    },
    "0043d98a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: lprcSrc\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: lprc\n\nvoid fcn.0043d98a(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t *arg_8h;\n    int32_t iVar5;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint lprc;\n    uint lprcSrc;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x38);\n    piVar3 = extraout_ECX[0x2c];\n    if (piVar3 == NULL) goto code_r0x0043ddac;\n    if (extraout_ECX[0x31] != 0) {\n        if (*(extraout_ECX[0x31] + 0xe8) != 0) {\n            (**(*piVar3 + 0x18))(piVar3);\n            goto code_r0x0043ddac;\n        }\n        (**(*extraout_ECX + 0x108))();\n    }\n    iVar2 = fcn.00427217();\n    if (iVar2 == 0) {\n        iVar2 = fcn.0041638e();\n    }\n    iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar2 + 0x20));\n    if (iVar2 != 0) goto code_r0x0043ddac;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    fcn.00401e60();\n    fcn.004156cc();\n    iVar2 = *extraout_ECX;\n    *(unaff_EBP + -4) = 2;\n    iVar2 = (**(iVar2 + 0x130))(unaff_EBP + -0x1c);\n    if (iVar2 != 0) {\n        uVar4 = *(unaff_EBP + -0x1c);\n        iVar2 = fcn.0042052a();\n        fcn.0042ab52(unaff_EBP + -0x18, 0xe005, *(iVar2 + 0x10), uVar4);\n        piVar3 = fcn.004469c0(extraout_ECX[0x2c], 0x485160);\n        if (piVar3 != NULL) {\n            iVar2 = (**(*piVar3 + 0x14))(piVar3);\n            if ((iVar2 == 0) && (iVar2 = (**(*piVar3 + 0x18))(piVar3),  iVar2 == 0)) {\n                (**(*piVar3 + 0xc))(piVar3, unaff_EBP + -0x14);\n                uVar4 = fcn.0041af14(*(unaff_EBP + -0x14));\n                arg_8h = (**(*extraout_ECX + 0x124))(uVar4);\n                if (arg_8h != NULL) {\n                    extraout_ECX[0x31] = arg_8h;\n                    iVar2 = (**(*piVar3 + 0x1c))(piVar3);\n                    if (iVar2 == 0) {\n                        iVar2 = (**(*piVar3 + 0x20))\n                                          (piVar3, arg_8h + 0x40, arg_8h + 0x41, unaff_EBP + -0x44, unaff_EBP + -0x34, \n                                           arg_8h + 0x3b);\n                        if ((iVar2 == 0) && (iVar2 = (**(*arg_8h + 0x1a4))(),  iVar2 != 0)) {\n                            (**(*arg_8h[0x40] + 0xc))(arg_8h[0x40], unaff_EBP + -0x14);\n                            uVar4 = fcn.0043af83(*(unaff_EBP + -0x14));\n                            *(unaff_EBP + -0x14) = uVar4;\n                            iVar2 = fcn.00414af6(0xec);\n                            *(unaff_EBP + -0x20) = iVar2;\n                            *(unaff_EBP + -4) = 3;\n                            if (iVar2 == 0) {\n                                iVar2 = 0;\n                            }\n                            else {\n                                iVar2 = fcn.0042fa7b(arg_8h);\n                            }\n                            arg_8h[0x42] = iVar2;\n                            *(unaff_EBP + -4) = 2;\n                            fcn.0041af61(*(unaff_EBP + -0x14));\n                            piVar1 = arg_8h[0x41];\n                            if (piVar1 != NULL) {\n                                (**(*piVar1 + 0xc))(piVar1, unaff_EBP + -0x20);\n                                if (*(unaff_EBP + -0x20) == *(unaff_EBP + -0x14)) {\n                                    fcn.004469e6(arg_8h + 0x41);\n                                    arg_8h[0x41] = 0;\n                                }\n                                else {\n                                    iVar2 = fcn.00414af6(0xec);\n                                    *(unaff_EBP + -0x24) = iVar2;\n                                    *(unaff_EBP + -4) = 4;\n                                    if (iVar2 == 0) {\n                                        iVar2 = 0;\n                                    }\n                                    else {\n                                        iVar2 = fcn.0042fa7b(arg_8h);\n                                    }\n                                    uVar4 = *(unaff_EBP + -0x20);\n                                    *(unaff_EBP + -4) = 2;\n                                    arg_8h[0x43] = iVar2;\n                                    fcn.0041af61(uVar4);\n                                }\n                            }\n                            iVar5 = (*_sym.imp.USER32.dll_IsRectEmpty)(unaff_EBP + -0x44);\n                            iVar2 = unaff_EBP + -0x34;\n                            if (iVar5 == 0) {\n                                iVar2 = unaff_EBP + -0x44;\n                            }\n                            (*_sym.imp.USER32.dll_CopyRect)(arg_8h + 0x4c, iVar2);\n                            (*_sym.imp.USER32.dll_CopyRect)(arg_8h + 0x50, unaff_EBP + -0x34);\n                            iVar2 = (**(*arg_8h + 0x194))(arg_8h[0x42], arg_8h[0x43]);\n                            if (iVar2 != 0) {\n                                iVar5 = (*_sym.imp.USER32.dll_IsRectEmpty)(unaff_EBP + -0x44);\n                                iVar2 = unaff_EBP + -0x34;\n                                if (iVar5 == 0) {\n                                    iVar2 = unaff_EBP + -0x44;\n                                }\n                                (**(*extraout_ECX + 0x118))(iVar2, unaff_EBP + -0x34);\n                                uVar4 = fcn.00446a07(0x485130);\n                                *(unaff_EBP + -0x20) = uVar4;\n                                fcn.00415c7c(*(unaff_EBP + -0x18));\n                                (**(*arg_8h[0x40] + 0x20))(arg_8h[0x40], *(unaff_EBP + -0x20), *(unaff_EBP + -0x10));\n                                piVar1 = arg_8h[0x41];\n                                if (piVar1 != NULL) {\n                                    (**(*piVar1 + 0x20))(piVar1, *(unaff_EBP + -0x20), *(unaff_EBP + -0x10));\n                                }\n                                (**(*extraout_ECX + 0x114))(*(extraout_ECX[0x31] + 0x108), 1);\n                                if (*(extraout_ECX[0x31] + 0x104) != 0) {\n                                    (**(*extraout_ECX + 0x114))(*(extraout_ECX[0x31] + 0x10c), 1);\n                                }\n                                fcn.00430bb0(1);\n                                (**(*extraout_ECX + 300))(0, arg_8h[0x40], 1);\n                                if (arg_8h[0x41] != 0) {\n                                    (**(*extraout_ECX + 300))(0, arg_8h[0x41], 0);\n                                }\n                                (**(*arg_8h[0x40] + 0x28))(arg_8h[0x40], arg_8h[0x44], arg_8h[0x4b], arg_8h[8]);\n                                (**(*extraout_ECX[0x2c] + 0x18))(extraout_ECX[0x2c]);\n                                fcn.00418160(5);\n                                fcn.004181c9();\n                                (*_sym.imp.USER32.dll_UpdateWindow)(arg_8h[8]);\n                                fcn.004444df(1, 0);\n                                (**(*extraout_ECX + 0x120))(1);\n                                arg_8h[0x3a] = 1;\n                                (**(*piVar3 + 8))(piVar3);\n                                fcn.004010f0();\n                                fcn.004010f0();\n                                fcn.004010f0();\n                                goto code_r0x0043ddac;\n                            }\n                        }\n                        (**(*piVar3 + 0x28))(piVar3, 0);\n                    }\n                    if (extraout_ECX[0x31] == 0) goto code_r0x0043dc43;\n                    (**(*extraout_ECX + 0x128))(arg_8h);\n                    extraout_ECX[0x31] = 0;\n                }\n                (**(*piVar3 + 0x2c))(piVar3);\n            }\ncode_r0x0043dc43:\n            (**(*piVar3 + 8))(piVar3);\n        }\n    }\n    fcn.004010f0();\n    fcn.004010f0();\n    fcn.004010f0();\ncode_r0x0043ddac:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 2416
    },
    "0043dfce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0043dfce(int32_t arg_8h)\n\n{\n    unkuint3 Var2;\n    uint32_t uVar1;\n    uint32_t *in_ECX;\n    \n    Var2 = *0x49bdc4 >> 8;\n    if (*0x49bdc4 == NULL) {\n        uVar1 = CONCAT31(Var2, 1);\n    }\n    else if ((arg_8h == 0) || (*in_ECX != 0xffffffff)) {\n        uVar1 = Var2 << 8;\n    }\n    else {\n        uVar1 = (**0x49bdc4)(arg_8h);\n        *in_ECX = uVar1;\n        uVar1 = uVar1 & 0xffffff00 | uVar1 != 0xffffffff;\n    }\n    return uVar1;\n}\n",
        "token_count": 189
    },
    "0043e008": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __fastcall fcn.0043e008(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*0x49bdcc == NULL) {\n        return true;\n    }\n    if ((*param_1 != -1) && (param_1[1] == 0)) {\n        iVar1 = (**0x49bdcc)(*param_1, param_1 + 1);\n        return iVar1 == 1;\n    }\n    return false;\n}\n",
        "token_count": 106
    },
    "0043e262": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043e262(int32_t param_1)\n\n{\n    if (*(param_1 + 0x88) != NULL) {\n        (**(**(param_1 + 0x88) + 0x14))();\n    }\n    if (*(param_1 + 0x94) != 0) {\n        fcn.0043969f(\"Settings\", \"PreviewPages\", *(param_1 + 0x94));\n    }\n    return;\n}\n",
        "token_count": 105
    },
    "0043e407": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e407(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x74) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x74));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if ((iVar2 == 0) && (iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0),  iVar2 != 0)) {\n            if (*(in_ECX + 0x70) != 0) {\n                fcn.0044b044(*(in_ECX + 0x70));\n            }\n            uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n            *(in_ECX + 0x70) = uVar3;\n            uVar3 = (*pcVar1)(uVar3);\n            iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n            if (iVar2 != 1) {\n                fcn.0044b044(*(in_ECX + 0x70));\n                *(in_ECX + 0x70) = 0;\n            }\n            sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 427
    },
    "0043e4c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_11ch\n\nvoid __cdecl fcn.0043e4c1(int32_t Locale)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    uint in_ECX;\n    uint in_EDX;\n    uint var_11ch;\n    uint lpLibFileName;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if (Locale == 0x800) {\n        uVar1 = fcn.00459195(&var_11ch, 4, 0x47ee28);\n        fcn.00409e60(uVar1);\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 3, &var_11ch, 4);\n        if (iVar2 == 0) goto code_r0x0043e585;\n    }\n    puVar3 = fcn.0045b3af();\n    uVar1 = *puVar3;\n    puVar3 = fcn.0045b3af();\n    *puVar3 = 0;\n    uVar4 = fcn.00458bb8(&lpLibFileName, 0x112, 0x111, in_ECX, in_EDX);\n    piVar5 = fcn.0045b3af();\n    if (*piVar5 == 0) {\n        puVar3 = fcn.0045b3af();\n        *puVar3 = uVar1;\n    }\n    else {\n        puVar3 = fcn.0045b3af();\n        fcn.00415526(*puVar3);\n    }\n    if ((uVar4 != 0xffffffff) && (uVar4 < 0x112)) {\n        (*_sym.imp.KERNEL32.dll_LoadLibraryA)(&lpLibFileName);\n    }\ncode_r0x0043e585:\n    fcn.0045843c(var_11ch);\n    return;\n}\n",
        "token_count": 467
    },
    "0043e593": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043e593(int32_t *param_1)\n\n{\n    if ((*0x49bdc8 != NULL) && (*param_1 != -1)) {\n        fcn.0043e035();\n        (**0x49bdc8)(*param_1);\n    }\n    return;\n}\n",
        "token_count": 70
    },
    "0043eed0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** __thiscall fcn.0043eed0(int32_t *param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    int32_t **ppiVar3;\n    uint unaff_EDI;\n    \n    ppiVar3 = param_1 + 6;\n    if ((*ppiVar3)[-3] != 0) {\n        if (param_1[5] != 3) {\n            return param_1;\n        }\n        ppiVar3 = param_1 + 7;\n        if (((*ppiVar3)[-3] != 0) && (ppiVar3 = param_1 + 8,  (*ppiVar3)[-3] != 0)) {\n            ppiVar3 = param_1 + 9;\n            if ((*ppiVar3)[-3] != 0) {\n                return *ppiVar3;\n            }\n        }\n    }\n    if (param_2 == NULL) {\n        fcn.004023a0(0, 0, unaff_EDI);\n        return ppiVar3;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004023a0(param_2, pcVar2 - (param_2 + 1), unaff_EDI);\n    return ppiVar3;\n}\n",
        "token_count": 322
    },
    "0043ef23": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043ef23(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.0043eed0(*(unaff_EBP + 8));\n    }\n    else {\n        fcn.00404920();\n        *(unaff_EBP + -4) = 0;\n        fcn.0043e5ec(*(unaff_EBP + 8));\n        fcn.004010f0();\n    }\n    fcn.0043ec83(*(unaff_EBP + 0x10));\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 195
    },
    "0043efb7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043efb7(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4a) != '\\0') {\n        if (*(param_1 + 0x24) != 0) {\n            (*_sym.imp.ole32.dll_CoRevokeClassObject)(*(param_1 + 0x24));\n            *(param_1 + 0x24) = 0;\n        }\n        *(param_1 + 0x4a) = 0;\n    }\n    return;\n}\n",
        "token_count": 120
    },
    "0043f005": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar __fastcall fcn.0043f005(int32_t *param_1)\n\n{\n    uchar uVar1;\n    \n    if (*(param_1 + 0x12) == '\\0') {\n        uVar1 = (**(*param_1 + 0x60))();\n        *(param_1 + 0x49) = uVar1;\n        *(param_1 + 0x12) = 1;\n    }\n    return *(param_1 + 0x49);\n}\n",
        "token_count": 107
    },
    "0043f9b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.0043f9b6(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    iVar1 = fcn.0041e767();\n    if (iVar1 != 0) {\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 0;\n        fcn.00401e60();\n        fcn.00401e60();\n        iVar1 = **(extraout_ECX + 0x50);\n        *(unaff_EBP + -4) = 2;\n        iVar1 = (**(iVar1 + 100))(unaff_EBP + -0x14, 5);\n        if ((iVar1 == 0) || (*(*(unaff_EBP + -0x14) + -0xc) == 0)) {\n            fcn.004010f0();\n            fcn.004010f0();\n            fcn.004010f0();\n        }\n        else {\n            iVar1 = (**(**(extraout_ECX + 0x50) + 100))(unaff_EBP + -0x10, 6);\n            if (iVar1 == 0) {\n                fcn.004076d0(unaff_EBP + -0x14);\n            }\n            iVar1 = (**(**(extraout_ECX + 0x50) + 100))(unaff_EBP + -0x18, 2);\n            if (iVar1 == 0) {\n                fcn.004076d0();\n            }\n            fcn.00453468(extraout_ECX + 0x28, *(unaff_EBP + -0x14), *(unaff_EBP + -0x18), *(unaff_EBP + -0x10), \n                         *(extraout_ECX + 0x4b), 0, 0);\n            fcn.004010f0();\n            fcn.004010f0();\n            fcn.004010f0();\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 528
    },
    "0043faec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043faec(int32_t param_1)\n\n{\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 0x58) == 0) {\n        fcn.0041638e();\n        param_1 = extraout_ECX;\n    }\n    // WARNING: Could not recover jumptable at 0x0043fb02. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x58) + 0x14))();\n    return;\n}\n",
        "token_count": 125
    },
    "0043fb05": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043fb05(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    uint arg_8h_00;\n    \n    arg_8h_00 = 4;\n    fcn.0045af3b();\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 0x14);\n    *(unaff_EBP + -0x10) = 1;\n    if (iVar2 == 0) {\n        iVar1 = fcn.0042052a();\n        iVar1 = (**(**(iVar1 + 4) + 0xc))(0xe100, 0, 0, 0);\n        if (iVar1 == 0) {\n            fcn.00454c3c();\n        }\n        iVar1 = extraout_ECX[8];\ncode_r0x0043fc73:\n        if (iVar1 != 0) goto code_r0x0043fc78;\n    }\n    else {\n        if (iVar2 == 1) {\n            iVar1 = (**(*extraout_ECX + 0x88))(*(iVar1 + 0x18));\n            goto code_r0x0043fc73;\n        }\n        if (iVar2 < 2) goto code_r0x0043fc78;\n        if (3 < iVar2) {\n            if (iVar2 == 4) {\n                extraout_ECX[0x23] = extraout_ECX[0x13];\n                extraout_ECX[0x13] = 0;\n                goto code_r0x0043fc78;\n            }\n            if (iVar2 == 5) {\n                (**(*extraout_ECX + 0x80))();\n                *(unaff_EBP + -0x10) = 0;\n                if (extraout_ECX[0x23] != 0) goto code_r0x0043fc78;\n                iVar1 = fcn.00414af6(0x28);\n                *(unaff_EBP + 8) = iVar1;\n                *(unaff_EBP + -4) = 0;\n            }\n            else {\n                if (iVar2 != 6) goto code_r0x0043fc78;\n                (**(*extraout_ECX + 0x84))();\n                if (*(iVar1 + 8) == 0) {\n                    fcn.0041fb58(arg_8h_00, 0, 0xffffffff);\n                }\n                *(unaff_EBP + -0x10) = 0;\n                if (extraout_ECX[0x23] != 0) goto code_r0x0043fc78;\n                iVar1 = fcn.00414af6(0x28);\n                *(unaff_EBP + 8) = iVar1;\n                *(unaff_EBP + -4) = 1;\n            }\n            if (iVar1 == 0) {\n                iVar1 = 0;\n            }\n            else {\n                iVar1 = fcn.0043ec07();\n            }\n            extraout_ECX[0x23] = iVar1;\n            *(iVar1 + 0x14) = 6;\n            goto code_r0x0043fc78;\n        }\n        extraout_ECX[0x13] = 0;\n        iVar2 = (**(*extraout_ECX + 0x88))(*(iVar1 + 0x18));\n        if (iVar2 != 0) {\n            iVar2 = extraout_ECX[8];\n            extraout_ECX[0x23] = iVar1;\n            if (iVar2 == 0) {\n                iVar2 = fcn.0041638e();\n            }\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x20), 0x111, 0xe108, 0);\n            extraout_ECX[0x23] = 0;\n        }\n    }\n    *(unaff_EBP + -0x10) = 0;\ncode_r0x0043fc78:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 961
    },
    "0043fd8d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043fd8d(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint hKey;\n    uint phkResult;\n    uint lpSubKey;\n    uint var_120h;\n    uint lpName;\n    uint var_4h;\n    \n    fcn.0045afda(0x124);\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -300) = iVar1;\n    fcn.004041b0(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (iVar1 == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + -0x120, \"Software\\\\Classes\\\\\", unaff_EBP + -0x124);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            *(unaff_EBP + -4) = 0;\n            fcn.004010f0();\n            *(unaff_EBP + -300) = 0x80000001;\n        }\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(*(unaff_EBP + -300), *(unaff_EBP + -0x124), unaff_EBP + -0x128);\n    if (iVar1 == 0) {\n        while( true ) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(*(unaff_EBP + -0x128), 0, unaff_EBP + -0x11c, 0x104);\n            if (iVar1 != 0) break;\n            *(unaff_EBP + -4) = 2;\n            fcn.00404920(unaff_EBP + -0x11c);\n            *(unaff_EBP + -4) = 3;\n            iVar1 = fcn.0043fd8d(*(unaff_EBP + -0x128), unaff_EBP + -0x120);\n            *(unaff_EBP + -4) = 2;\n            fcn.004010f0();\n            if (iVar1 != 0) break;\n            *(unaff_EBP + -4) = 0;\n        }\n        if ((iVar1 == 0x103) || (iVar1 == 0x3f2)) {\n            (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(*(unaff_EBP + -300), *(unaff_EBP + -0x124));\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x128));\n    }\n    fcn.004010f0();\n    fcn.0045b036();\n    return;\n}\n",
        "token_count": 677
    },
    "0044052e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044052e(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        uVar1 = fcn.0041ac5f(0x47f2ac);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x10) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x10);\n    return;\n}\n",
        "token_count": 131
    },
    "004405d2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004405d2(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "00440608": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00440608(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x18) == 0) {\n        uVar1 = fcn.0041ac5f(\"GetSaveFileNameA\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x18) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x18);\n    return;\n}\n",
        "token_count": 128
    },
    "004406ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004406ac(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "0044076a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.0044076a(void)\n\n{\n    code *arg_8h;\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFileDialog.0;\n    arg_8h = extraout_ECX[0x1d];\n    *(unaff_EBP + -4) = 1;\n    fcn.004585e6(arg_8h);\n    if (extraout_ECX[0x1e] == 0x1) {\n        iVar1 = (**(*extraout_ECX[0x20] + 0x20))(extraout_ECX[0x20], extraout_ECX[0x1f]);\n        if (-1 < iVar1) goto code_r0x004407b8;\n        do {\n            fcn.0041638e();\ncode_r0x004407b8:\n            (**(*extraout_ECX[0x21] + 8))(extraout_ECX[0x21]);\n            iVar1 = (**(*extraout_ECX[0x20] + 8))(extraout_ECX[0x20]);\n        } while (iVar1 != 0);\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    *extraout_ECX = vtable.CCommonDialog.0;\n    fcn.0041ec27();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 417
    },
    "00440848": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00440848(int32_t *param_1)\n\n{\n    if (1 < *(*param_1 + -4)) {\n        fcn.00415719(*(*param_1 + -0xc));\n    }\n    return *param_1;\n}\n",
        "token_count": 62
    },
    "00440962": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.00440962(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code **arg_8h_00;\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint lpVersionInformation;\n    uint var_a0h;\n    uint uVar5;\n    uint var_4h;\n    \n    fcn.0045afa4(0xac);\n    *(unaff_EBP + -0xb0) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0xac) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0xb8) = extraout_ECX;\n    fcn.004400c1(*(unaff_EBP + 0x1c));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CFileDialog.0;\n    fcn.00401e60();\n    extraout_ECX[0x76] = NULL;\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[0x77] = NULL;\n    if (*(unaff_EBP + 0x20) == 0) {\n        fcn.00458b20(unaff_EBP + -0xa4, 0, 0x94);\n        *(unaff_EBP + -0xa4) = 0x94;\n        (*_sym.imp.KERNEL32.dll_GetVersionExA)(unaff_EBP + -0xa4);\n        *(unaff_EBP + 0x20) = 0x58;\n        extraout_ECX[0x1e] = ~-(*(unaff_EBP + -0xa0) < 6) & *(unaff_EBP + 0x24);\n    }\n    pcVar2 = fcn.0045adaa(*(unaff_EBP + 0x20));\n    extraout_ECX[0x1d] = pcVar2;\n    if (pcVar2 == NULL) {\n        pcVar2 = fcn.00416356();\n    }\n    fcn.00458b20(pcVar2, 0, *(unaff_EBP + 0x20));\n    pcVar2 = *(unaff_EBP + 8);\n    uVar5 = *(unaff_EBP + 0x20);\n    extraout_ECX[0x22] = pcVar2;\n    extraout_ECX[0x15] = 0x7005 - (pcVar2 != NULL);\n    extraout_ECX[0x75] = NULL;\n    *(extraout_ECX + 0x24) = 0;\n    arg_8h_00 = extraout_ECX + 0x34;\n    *arg_8h_00 = 0;\n    *extraout_ECX[0x1d] = uVar5;\n    uVar5 = *(unaff_EBP + 0xc);\n    *(extraout_ECX[0x1d] + 0x1c) = arg_8h_00;\n    *(extraout_ECX[0x1d] + 0x20) = 0x104;\n    *(extraout_ECX[0x1d] + 0x3c) = uVar5;\n    uVar1 = *(unaff_EBP + 0x14);\n    *(extraout_ECX[0x1d] + 0x24) = extraout_ECX + 0x24;\n    *(extraout_ECX[0x1d] + 0x28) = 0x40;\n    *(extraout_ECX[0x1d] + 0x34) = *(extraout_ECX[0x1d] + 0x34) | uVar1 | 0x80020;\n    if ((*(unaff_EBP + 0x14) & 0x40) != 0) {\n        *(extraout_ECX[0x1d] + 0x34) = *(extraout_ECX[0x1d] + 0x34) & 0xff7fffff;\n    }\n    iVar3 = fcn.0042052a();\n    *(extraout_ECX[0x1d] + 8) = *(iVar3 + 0xc);\n    *(extraout_ECX[0x1d] + 0x44) = fcn.00445036;\n    if (*(unaff_EBP + -0xb0) != 0) {\n        fcn.0041502b(arg_8h_00, 0x104, *(unaff_EBP + -0xb0), 0xffffffff);\n    }\n    if (*(unaff_EBP + -0xac) != 0) {\n        fcn.00402830(*(unaff_EBP + -0xac));\n        puVar4 = fcn.00401eb0(0);\n        while( true ) {\n            puVar4 = fcn.0045aaaf(puVar4, 0x7c);\n            if (puVar4 == NULL) break;\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *(extraout_ECX[0x1d] + 0xc) = extraout_ECX[0x23];\n    }\n    if (extraout_ECX[0x1e] == 0x1) {\n        iVar3 = (*_sym.imp.ole32.dll_CoInitializeEx)(0, 2);\n        if (-1 < iVar3) {\n            extraout_ECX[0x76] = vtable.CFileDialog::XFileDialogEvents.0;\n            extraout_ECX[0x77] = vtable.CFileDialog::XFileDialogControlEvents.0;\n            if (extraout_ECX[0x22] == NULL) {\n                uVar5 = 0x497d7c;\n            }\n            else {\n                uVar5 = 0x497d6c;\n            }\n            iVar3 = (*_sym.imp.ole32.dll_CoCreateInstance)(uVar5, 0, 1, 0x47f4ac, unaff_EBP + -0xa8);\n            if (-1 < iVar3) {\n                iVar3 = (****(unaff_EBP + -0xa8))(*(unaff_EBP + -0xa8), 0x47f29c, unaff_EBP + -0xb4);\n                if (-1 < iVar3) goto code_r0x00440b91;\n                do {\n                    fcn.0041638e();\ncode_r0x00440b91:\n                    iVar3 = (**(**(unaff_EBP + -0xa8) + 0x1c))\n                                      (*(unaff_EBP + -0xa8), extraout_ECX + 0x76, extraout_ECX + 0x1f);\n                } while (iVar3 < 0);\n                extraout_ECX[0x20] = *(unaff_EBP + -0xa8);\n                extraout_ECX[0x21] = *(unaff_EBP + -0xb4);\n                goto code_r0x00440bc3;\n            }\n        }\n        extraout_ECX[0x1e] = NULL;\n    }\ncode_r0x00440bc3:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 1730
    },
    "0044114a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044114a(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_ch;\n    uint hWnd;\n    uint var_4h;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(*(param_1 + 0x74) + 0x1c));\n    fcn.00458b20(*(*(param_1 + 0x74) + 0x1c) + iVar3 + 1, 0, *(*(param_1 + 0x74) + 0x20) - (iVar3 + 1));\n    uVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n    iVar3 = *(param_1 + 0x74);\n    bVar1 = false;\n    uVar5 = fcn.0041ee41();\n    *(iVar3 + 4) = uVar5;\n    fcn.0041afcd();\n    pcVar2 = _sym.imp.USER32.dll_EnableWindow;\n    if ((*(*(param_1 + 0x74) + 4) != 0) &&\n       (iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(*(param_1 + 0x74) + 4)),  iVar3 != 0)) {\n        bVar1 = true;\n        (*pcVar2)(*(*(param_1 + 0x74) + 4), 0);\n    }\n    iVar3 = fcn.0041ff5e();\n    if ((*(param_1 + 0x78) == 1) || ((*(*(param_1 + 0x74) + 0x34) & 0x80000) == 0)) {\n        fcn.0041ce25(param_1);\n    }\n    else {\n        *(iVar3 + 0x18) = param_1;\n    }\n    if (*(param_1 + 0x78) == 1) {\n        fcn.00440be4();\n        iVar6 = (**(**(param_1 + 0x80) + 0xc))(*(param_1 + 0x80), *(*(param_1 + 0x74) + 4));\n        iVar6 = (iVar6 != 0) + 1;\n    }\n    else if (*(param_1 + 0x88) == 0) {\n        iVar6 = fcn.004406fe(*(param_1 + 0x74));\n    }\n    else {\n        iVar6 = fcn.004406e2(*(param_1 + 0x74));\n    }\n    *(iVar3 + 0x18) = 0;\n    if (bVar1) {\n        (*pcVar2)(*(*(param_1 + 0x74) + 4), 1);\n    }\n    iVar3 = (*_sym.imp.USER32.dll_IsWindow)(uVar4);\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetFocus)(uVar4);\n    }\n    fcn.0041ee7d();\n    if (iVar6 == 0) {\n        iVar6 = 2;\n    }\n    return iVar6;\n}\n",
        "token_count": 724
    },
    "00441276": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: pv\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00441276(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint lParam;\n    uint pv;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x10);\n    *(unaff_EBP + -0x1c) = 0;\n    if (*(extraout_ECX + 0x78) == 1) {\n        if (*(extraout_ECX + 0x20) != 0) {\n            fcn.00401e60();\n            piVar1 = *(extraout_ECX + 0x80);\n            iVar3 = *piVar1;\n            *(unaff_EBP + -4) = 0;\n            iVar3 = (**(iVar3 + 0x38))(piVar1, unaff_EBP + -0x10);\n            if (-1 < iVar3) {\n                iVar3 = (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), 0x400000, unaff_EBP + -0x1c);\n                if (iVar3 == 1) {\n                    iVar3 = (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), 0x20000000, unaff_EBP + -0x1c);\n                    if (iVar3 != 0) goto code_r0x004412e9;\n                }\n                else {\ncode_r0x004412e9:\n                    *(unaff_EBP + -0x18) = 0;\n                    iVar3 = (**(**(unaff_EBP + -0x10) + 0x14))(*(unaff_EBP + -0x10), 0x80058000, unaff_EBP + -0x18);\n                    if (-1 < iVar3) {\n                        fcn.0041584a(*(unaff_EBP + -0x18));\n                        fcn.00409070(0xffffffff);\n                        (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x18));\n                    }\n                }\n                (**(**(unaff_EBP + -0x10) + 8))(*(unaff_EBP + -0x10));\n            }\n            fcn.004041b0(unaff_EBP + -0x14);\ncode_r0x00441338:\n            fcn.004010f0();\n            goto code_r0x0044140d;\n        }\n    }\n    else {\n        if (((*(*(extraout_ECX + 0x74) + 0x34) & 0x80000) == 0) || (*(extraout_ECX + 0x20) == 0)) goto code_r0x004413ff;\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 1;\n        uVar4 = fcn.00401eb0(0x104);\n        pcVar2 = _sym.imp.USER32.dll_GetParent;\n        uVar5 = *(extraout_ECX + 0x20);\n        *(unaff_EBP + -0x1c) = uVar4;\n        uVar5 = (*pcVar2)(uVar5);\n        iVar3 = fcn.0041af14(uVar5);\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x20), 0x464, 0x104, *(unaff_EBP + -0x1c));\n        if (iVar3 < 0) {\n            fcn.004018d0();\n        }\n        else {\n            fcn.00409070(0x104, 0xffffffff);\n        }\n        if (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n            uVar4 = fcn.00401eb0(0x104);\n            uVar5 = *(extraout_ECX + 0x20);\n            *(unaff_EBP + -0x1c) = uVar4;\n            uVar5 = (*pcVar2)(uVar5);\n            iVar3 = fcn.0041af14(uVar5);\n            iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x20), 0x465, 0x104, *(unaff_EBP + -0x1c));\n            if (-1 < iVar3) {\n                fcn.00409070(0xffffffff);\n                fcn.004041b0(unaff_EBP + -0x10);\n                goto code_r0x00441338;\n            }\n            fcn.004018d0();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004010f0();\n    }\ncode_r0x004413ff:\n    fcn.00404920(*(*(extraout_ECX + 0x74) + 0x1c));\ncode_r0x0044140d:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1247
    },
    "00441526": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: pszPath\n\nvoid __cdecl fcn.00441526(uint arg_8h)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint lParam;\n    uint pszPath;\n    int32_t var_4h;\n    \n    fcn.0045af3b(8);\n    *(unaff_EBP + -0x14) = 0;\n    if (*(extraout_ECX + 0x78) == 1) {\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 0;\n        if (*(extraout_ECX + 0x20) == 0) {\n            uVar1 = fcn.00441276(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 2;\n        }\n        else {\n            uVar1 = fcn.00441433(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 1;\n        }\n        fcn.004076d0(uVar1);\n        *(unaff_EBP + -4) = 0;\n        fcn.004010f0();\n        fcn.00409070(0xffffffff);\ncode_r0x0044158e:\n        pcVar2 = (*_sym.imp.SHLWAPI.dll_PathFindExtensionA)(*(unaff_EBP + -0x10));\n        if ((pcVar2 == NULL) || (*pcVar2 != '.')) goto code_r0x004415b8;\n        fcn.00404920(pcVar2 + 1);\n    }\n    else {\n        iVar4 = *(extraout_ECX + 0x74);\n        if (((*(iVar4 + 0x34) & 0x80000) == 0) || (*(extraout_ECX + 0x20) == 0)) {\n            iVar5 = *(extraout_ECX + 0x1d4);\n            if (iVar5 == 0) {\n                iVar5 = iVar4;\n                if (*(iVar4 + 0x3a) != 0) goto code_r0x0044166e;\n                var_4h = 0x476744;\n            }\n            else if (*(iVar5 + 0x3a) == 0) {\n                var_4h = 0x476744;\n            }\n            else {\ncode_r0x0044166e:\n                var_4h = *(iVar5 + 0x3a) + *(iVar5 + 0x1c);\n            }\n            fcn.00404920(var_4h);\n            goto code_r0x0044167b;\n        }\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 3;\n        uVar3 = fcn.00401eb0(0x104);\n        uVar1 = *(extraout_ECX + 0x20);\n        *(unaff_EBP + -0x14) = uVar3;\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(uVar1);\n        iVar4 = fcn.0041af14(uVar1);\n        iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x20), 0x464, 0x104, *(unaff_EBP + -0x14));\n        fcn.00409070(0xffffffff);\n        if (-1 < iVar4) goto code_r0x0044158e;\ncode_r0x004415b8:\n        fcn.004018d0();\n        fcn.004041b0(unaff_EBP + -0x10);\n    }\n    fcn.004010f0();\ncode_r0x0044167b:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 902
    },
    "00441de3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00441de3(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t *in_ECX;\n    \n    in_ECX[0x17] = arg_10h;\n    in_ECX[0x18] = arg_14h;\n    in_ECX[0x12] = arg_8h;\n    in_ECX[0x11] = arg_ch;\n    if (*0x497c10 == 0) {\n        (**(*in_ECX + 0x50))();\n    }\n    return;\n}\n",
        "token_count": 142
    },
    "00441e12": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00441e12(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    in_ECX[0x13] = arg_8h;\n    if (*0x497c10 == 0) {\n        (**(*in_ECX + 0x50))();\n    }\n    return;\n}\n",
        "token_count": 77
    },
    "00442011": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00442011(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00441f7e();\n    var_4h = 0;\n    var_10h = arg_ch;\n    if (arg_10h == 0) {\n        var_14h = 0;\n    }\n    else {\n        var_14h = *(in_ECX + 0x60);\n    }\n    if (*(in_ECX + 0x5c) == 0) {\n        piVar1 = NULL;\n    }\n    else {\n        piVar1 = fcn.00424b9d();\n        if (piVar1 != NULL) {\n            iVar2 = (**(*piVar1 + 0x140))(*(in_ECX + 0x44), 0x44000000, arg_8h, &var_14h);\n            piVar1 = -(iVar2 != 0) & piVar1;\n        }\n    }\n    return piVar1;\n}\n",
        "token_count": 280
    },
    "0044218c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044218c(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    uint var_4h;\n    \n    if (*(*(param_1 + 100) + -0xc) == 0) {\n        fcn.004024c0(*(param_1 + 0x40));\n    }\n    pcVar2 = _sym.imp.USER32.dll_LoadMenuA;\n    pcVar1 = _sym.imp.USER32.dll_LoadAcceleratorsA;\n    if ((*(param_1 + 0x48) != 0) && (*(param_1 + 0x30) == 0)) {\n        iVar3 = fcn.0042052a();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x30) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x34) = uVar5;\n    }\n    if ((*(param_1 + 0x44) != 0) && (*(param_1 + 0x38) == 0)) {\n        iVar3 = fcn.0042052a();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x38) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x3c) = uVar5;\n    }\n    if ((*(param_1 + 0x4c) != 0) && (*(param_1 + 0x28) == 0)) {\n        iVar3 = fcn.0042052a();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x4c));\n        *(param_1 + 0x28) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x4c));\n        *(param_1 + 0x2c) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 561
    },
    "0044255d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool fcn.0044255d(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0044a2be(0x423332);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    if (*(iVar1 + 0x20) == 0) {\n        uVar2 = fcn.004197f3(\"RICHED32.DLL\");\n        *(iVar1 + 0x20) = uVar2;\n    }\n    return *(iVar1 + 0x20) != 0;\n}\n",
        "token_count": 134
    },
    "00442598": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool fcn.00442598(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0044a2be(0x423332);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    if (*(iVar1 + 0x24) == 0) {\n        uVar2 = fcn.004197f3(\"RICHED20.DLL\");\n        *(iVar1 + 0x24) = uVar2;\n    }\n    return *(iVar1 + 0x24) != 0;\n}\n",
        "token_count": 133
    },
    "004426de": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004426de(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    fcn.004475a6();\n    fcn.0043f480();\n    fcn.00454c64();\n    if (arg_8h == 0) {\n        iVar1 = fcn.004379b3();\n        if (iVar1 != 0) {\n            if (*(iVar1 + 0x40) != NULL) {\n                (**(**(iVar1 + 0x40) + 4))(1);\n            }\n            *(iVar1 + 0x40) = 0;\n        }\n        iVar1 = fcn.0041ff5e();\n        if (*(iVar1 + 0x100) == 1) {\n            (*_sym.imp.ole32.dll_CoFreeUnusedLibraries)();\n            (*_sym.imp.ole32.dll_OleUninitialize)();\n            *(iVar1 + 0x100) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "0044273a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044273a(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetTickCount;\n    if (arg_8h == 0) {\n        if (*0x49bdec == 0) {\n            *0x497eb0 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n            *0x49bdec = *0x49bdec + 1;\n        }\n        iVar2 = (*pcVar1)();\n        if (60000 < iVar2 - *0x497eb0) {\n            (*_sym.imp.ole32.dll_CoFreeUnusedLibraries)();\n            *0x497eb0 = (*pcVar1)();\n        }\n    }\n    else {\n        fcn.004426de(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 196
    },
    "00442826": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00442826(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    do {\n        if (var_4h == NULL) {\n            uVar2 = (**(*param_1 + 0x90))();\n            return uVar2;\n        }\n        (**(*param_1 + 100))(&var_4h);\n        iVar1 = fcn.0041b98e();\n    } while ((iVar1 == 0) || (*(iVar1 + 0x58) < 1));\n    return 1;\n}\n",
        "token_count": 169
    },
    "00442923": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00442923(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        piVar1 = (**(*param_1 + 100))(&var_4h);\n        (**(*piVar1 + 0x164))();\n    }\n    return;\n}\n",
        "token_count": 117
    },
    "00442956": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00442956(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.0041e5f9(arg_8h, arg_ch, arg_10h, arg_14h);\n    if (iVar1 == 0) {\n        if (*(in_ECX + 0x28) != 0) {\n            iVar1 = (**(**(in_ECX + 0x28) + 0xc))(arg_8h, arg_ch, arg_10h, arg_14h);\n            if (iVar1 != 0) goto code_r0x00442973;\n        }\n        uVar2 = 0;\n    }\n    else {\ncode_r0x00442973:\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 210
    },
    "004429c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004429c5(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x38);\n    while (iVar1 != 0) {\n        iVar1 = fcn.0044b7d1();\n        *(iVar1 + 0x54) = 0;\n        iVar1 = *(param_1 + 0x38);\n    }\n    return;\n}\n",
        "token_count": 99
    },
    "00442b29": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00442b29(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t *piVar4;\n    uint var_4h;\n    \n    iVar1 = param_1[0x13];\n    param_1[0x13] = 0;\n    iVar2 = param_1[0xe];\n    while( true ) {\n        if (iVar2 == 0) {\n            param_1[0x13] = iVar1;\n            (**(*param_1 + 0x6c))();\n            if (param_1[0x13] != 0) {\n                (**(*param_1 + 4))(1);\n            }\n            return;\n        }\n        piVar4 = fcn.0041b98e();\n        if (piVar4 == NULL) break;\n        (**(*param_1 + 0x94))(piVar4);\n        (**(*piVar4 + 0x60))();\n        iVar2 = param_1[0xe];\n    }\n    fcn.0041638e();\n    pcVar3 = swi(3);\n    (*pcVar3)();\n    return;\n}\n",
        "token_count": 268
    },
    "00442c54": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00442c54(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 3;\n    fcn.004429c5();\n    if (*(extraout_ECX + 0x28) != 0) {\n        (**(**(extraout_ECX + 0x28) + 0x60))(extraout_ECX);\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.0044b898();\n    fcn.004010f0();\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041e889();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 237
    },
    "00442d7a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00442d7a(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    if (arg_10h < 0) {\n        arg_10h = 0;\n    }\n    iVar1 = *(*in_ECX + -0xc);\n    iVar2 = fcn.00442bb4(arg_ch, arg_10h);\n    if (iVar1 < iVar2) {\n        arg_10h = *(*in_ECX + -0xc) - arg_ch;\n    }\n    iVar1 = *in_ECX;\n    iVar2 = *(iVar1 + -0xc);\n    if (iVar2 < arg_ch) {\n        arg_10h = 0;\n    }\n    if ((arg_ch == 0) && (arg_10h == iVar2)) {\n        fcn.004041b0();\n    }\n    else {\n        uVar3 = fcn.00404180();\n        fcn.00404260(iVar1 + arg_ch, arg_10h, uVar3);\n    }\n    return arg_8h;\n}\n",
        "token_count": 296
    },
    "00442e73": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.00442e73(void)\n\n{\n    int32_t iVar1;\n    uint arg_ch;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t *arg_10h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    iVar1 = (**(*extraout_ECX + 0x58))();\n    if (iVar1 == 0) goto code_r0x00442f6e;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    arg_10h = extraout_ECX + 9;\n    if (*(*arg_10h + -0xc) == 0) {\n        fcn.004076d0(extraout_ECX + 8);\n        arg_10h = *(unaff_EBP + -0x10);\n        if (arg_10h[-3] == 0) {\n            iVar1 = fcn.004024c0(0xf003);\n            if (iVar1 == 0) {\n                fcn.0041638e();\n                goto code_r0x00442ed8;\n            }\n            goto code_r0x00442f00;\n        }\n    }\n    else {\ncode_r0x00442ed8:\n        fcn.004076d0(arg_10h);\n        arg_ch = fcn.00401eb0(0x104);\n        fcn.0042af5e(*arg_10h, arg_ch, 0x104);\n        fcn.00409070(0xffffffff);\ncode_r0x00442f00:\n        arg_10h = *(unaff_EBP + -0x10);\n    }\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 1;\n    fcn.0042ab38(unaff_EBP + -0x14, 0xf103, arg_10h);\n    iVar1 = fcn.0041fb0a(*(unaff_EBP + -0x14), 3, 0xf103);\n    if ((iVar1 == 2) || ((iVar1 == 6 && (iVar1 = (**(*extraout_ECX + 0x9c))(),  iVar1 == 0)))) {\n        fcn.004010f0();\n        fcn.004010f0();\n    }\n    else {\n        fcn.004010f0();\n        fcn.004010f0();\n    }\ncode_r0x00442f6e:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 633
    },
    "004437bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004437bd(uint arg_8h, char *arg_ch, int32_t *arg_10h)\n\n{\n    uint32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_10h_00;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint32_t uVar4;\n    ulong uVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *arg_10h;\n    if (iVar2 < 0) {\n        uVar5 = fcn.00401000(0x80070057);\n        iVar2 = uVar5 >> 0x20;\n        in_ECX = uVar5;\n    }\n    if ((arg_ch == NULL) || (*arg_ch == '\\0')) {\n        iVar1 = *in_ECX;\n        if (iVar2 < *(iVar1 + -0xc)) {\n            uVar3 = fcn.00404180();\n            fcn.0044345b(*arg_10h + iVar1, uVar3);\n            return arg_8h;\n        }\n    }\n    else {\n        iVar1 = *in_ECX;\n        arg_8h_00 = iVar1 + iVar2;\n        uVar4 = *(iVar1 + -0xc) + iVar1;\n        if (arg_8h_00 < uVar4) {\n            iVar2 = fcn.0045dac3(arg_8h_00, arg_ch);\n            if (arg_8h_00 + iVar2 < uVar4) {\n                arg_10h_00 = fcn.0045dba1(arg_8h_00 + iVar2, arg_ch);\n                iVar1 = *arg_10h;\n                *arg_10h = iVar1 + iVar2 + 1 + arg_10h_00;\n                fcn.00442d7a(arg_8h, iVar1 + iVar2, arg_10h_00);\n                return arg_8h;\n            }\n        }\n    }\n    *arg_10h = -1;\n    uVar3 = fcn.00404180();\n    fcn.0043fc83(uVar3);\n    return arg_8h;\n}\n",
        "token_count": 498
    },
    "00443a96": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00443a96(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint arg_8h_00;\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t unaff_EBP;\n    uint var_120h;\n    uint var_11ch;\n    uint var_118h;\n    uint var_114h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x90) != 0) {\n        if (arg_ch != 0) {\n            *(arg_ch + 4) = *(arg_ch + 4) + -1;\n        }\n        *(in_ECX + 0x94) = arg_ch;\n        return;\n    }\n    fcn.0045afa4(0x114);\n    arg_8h_00 = *(unaff_EBP + 8);\n    piVar1 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x11c) = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x120) = *(unaff_EBP + 0x14);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        iVar2 = fcn.00424c12(0x47a544);\n        if (iVar2 != 0) goto code_r0x004431bc;\n        iVar2 = fcn.00424c12(0x47f178);\n        if (iVar2 == 0) {\n            iVar2 = fcn.00424c12(0x47e828);\n            if (iVar2 != 0) {\n                if (*(piVar1[4] + -0xc) == 0) {\n                    fcn.00402830(arg_8h_00);\n                }\n                uVar3 = fcn.00401eb0(0xff);\n                iVar2 = (**(*piVar1 + 0xc))(uVar3, 0x100, unaff_EBP + -0x120);\n                if ((iVar2 == 0) && (iVar2 = piVar1[2],  1 < iVar2)) {\n                    if (iVar2 < 4) {\n                        *(unaff_EBP + -0x11c) = 0xf121;\n                    }\n                    else if (iVar2 == 5) {\n                        *(unaff_EBP + -0x11c) = (*(unaff_EBP + 0x10) != 0) + 0xf123;\n                    }\n                    else if (iVar2 == 0xd) {\n                        *(unaff_EBP + -0x11c) = 0xf122;\n                    }\n                }\n                fcn.00409070(0xffffffff);\n            }\n        }\n        else {\n            iVar2 = piVar1[2];\n            if ((iVar2 == 3) || ((4 < iVar2 && (iVar2 < 8)))) {\n                *(unaff_EBP + -0x11c) = 0xf120;\n            }\n        }\n    }\n    if (*(*(unaff_EBP + -0x118) + -0xc) == 0) {\n        fcn.0042af5e(arg_8h_00, unaff_EBP + -0x114, 0x104);\n        fcn.0042ab38(unaff_EBP + -0x118, *(unaff_EBP + -0x11c), unaff_EBP + -0x114);\n    }\n    fcn.0041fb0a(*(unaff_EBP + -0x118), 0x30, *(unaff_EBP + -0x120));\ncode_r0x004431bc:\n    fcn.004010f0();\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 890
    },
    "00443abe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00443abe(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x90) = *(in_ECX + 0x90) + -1;\n    if (*(in_ECX + 0x94) != 0) {\n        if (arg_8h == 0) {\n            arg_8h = fcn.00414b3b(*(in_ECX + 0x94));\n        }\n        piVar1 = *(in_ECX + 0x94) + 4;\n        *piVar1 = *piVar1 + 1;\n        fcn.00416286();\n        *(in_ECX + 0x94) = 0;\n    }\n    return arg_8h;\n}\n",
        "token_count": 186
    },
    "00443bb8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00443bb8(int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    if (lpString == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar2 = fcn.00414f41(iVar1 + 1, 2);\n    if (iVar2 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpString, 0xffffffff, iVar2, iVar1 + 1);\n        if (iVar1 == 0) {\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(iVar2);\n            iVar2 = 0;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 187
    },
    "00444122": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00444122(int32_t *param_1)\n\n{\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if (param_1[0x26] != 0) {\n        var_4h = NULL;\n        (*_sym.imp.ole32.dll_GetRunningObjectTable)(0, &var_4h);\n        if (var_4h != NULL) {\n            (**(*var_4h + 0x10))(var_4h, param_1[0x26]);\n            (**(*var_4h + 8))(var_4h);\n        }\n        param_1[0x26] = 0;\n    }\n    fcn.004469e6(param_1 + 0x27);\n    fcn.004024f0(0x476744);\n    return;\n}\n",
        "token_count": 191
    },
    "004441b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004441b6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    \n    fcn.00444122();\n    (**(*in_ECX + 0xe8))(arg_8h, 0);\n    iVar1 = fcn.004279aa(arg_8h);\n    if (iVar1 == 0) {\n        fcn.00444122();\n        uVar2 = 0;\n    }\n    else {\n        iVar1 = fcn.0042052a();\n        iVar1 = *(*(iVar1 + 4) + 0x8c);\n        if ((iVar1 == 0) || ((iVar1 = *(iVar1 + 0x14),  iVar1 != 4 && (iVar1 != 2)))) {\n            fcn.00441d61(1);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 214
    },
    "0044426c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044426c(int32_t arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t *in_ECX;\n    uint uVar2;\n    int32_t iVar3;\n    \n    uVar2 = 0x4850a0;\n    iVar3 = arg_8h;\n    uVar1 = fcn.00446a07(0x4850a0);\n    (*_sym.imp.ole32.dll_CoLockObjectExternal)(uVar1, uVar2, iVar3, arg_ch);\n    if ((arg_8h != 0) && (*(in_ECX[9] + -0xc) != 0)) {\n        fcn.00444122();\n        (**(*in_ECX + 0xe8))(in_ECX[9], 0);\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "00444555": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00444555(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    int32_t ppmk;\n    \n    if (*(*(in_ECX + 0xa0) + -0xc) == 0) {\n        ppmk = fcn.0042796a(arg_8h);\n    }\n    else {\n        ppmk = in_ECX;\n        puVar1 = fcn.00416242(*(in_ECX + 0xa0));\n        (*_sym.imp.ole32.dll_CreateFileMoniker)(*puVar1, &ppmk);\n        fcn.004010f0();\n    }\n    return ppmk;\n}\n",
        "token_count": 154
    },
    "00444598": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00444598(int32_t *pprot, int32_t arg_ch)\n\n{\n    int32_t *arg_8h;\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h = in_ECX + 0x27;\n    in_ECX[0x23] = pprot;\n    var_4h = 1;\n    fcn.004469e6(arg_8h);\n    fcn.004018d0();\n    if (arg_ch != 0) {\n        puVar1 = fcn.00416242(arg_ch);\n        iVar2 = (*_sym.imp.ole32.dll_CreateFileMoniker)(*puVar1, arg_8h);\n        pprot = pprot & 0xffffff | (iVar2 != 0) << 0x18;\n        fcn.004010f0();\n        if (pprot._3_1_ != '\\0') {\n            var_4h = 0;\n        }\n    }\n    if (*arg_8h != 0) {\n        pprot = NULL;\n        (*_sym.imp.ole32.dll_GetRunningObjectTable)(0, &pprot);\n        iVar2 = (**(*pprot + 0x18))(pprot, *arg_8h, &var_ch);\n        if (iVar2 == 0) {\n            (**(*var_ch + 8))(var_ch);\n            fcn.004469e6(arg_8h);\n            return 0;\n        }\n        iVar2 = *pprot;\n        piVar6 = in_ECX + 0x26;\n        iVar5 = *arg_8h;\n        uVar4 = 0x4850a0;\n        uVar3 = fcn.00446a07(0x4850a0);\n        iVar2 = (**(iVar2 + 0xc))(pprot, 0, uVar3, uVar4, iVar5, piVar6);\n        (**(*pprot + 8))(pprot);\n        fcn.00402830(arg_ch);\n        if (iVar2 != 0) {\n            var_4h = 0;\n        }\n    }\n    var_8h = (**(*in_ECX + 0xb4))();\n    while (iVar2 = fcn.004270c5(&var_8h),  iVar2 != 0) {\n        if (*(iVar2 + 0x45) != '\\0') {\n            (**(**(iVar2 + 0x24) + 0x1c))(*(iVar2 + 0x24), 1, *arg_8h);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 639
    },
    "00444a21": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444a21(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    do {\n        iVar1 = fcn.004270c5(&var_4h);\n        if (iVar1 == 0) goto code_r0x00444a4d;\n    } while (*(iVar1 + 0x54) != 1);\n    iVar1 = 1;\ncode_r0x00444a4d:\n    (***arg_8h)(iVar1);\n    return;\n}\n",
        "token_count": 149
    },
    "00444a5d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444a5d(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint arg_ch;\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    uint arg_10h;\n    uint arg_18h;\n    uint arg_1ch;\n    uint var_8h;\n    \n    if ((arg_8h[3] == 0) || (arg_8h[9] == 0)) {\n        arg_8h[7] = 1;\n    }\n    else {\n        iVar2 = *in_ECX;\n        uVar1 = fcn.0041f8a6();\n        iVar2 = (**(iVar2 + 200))(uVar1);\n        if ((iVar2 == 0) || (*(iVar2 + 0x54) == 3)) {\n            (***arg_8h)(0);\n        }\n        (**(*in_ECX + 0xc))(0xe202, 0, 0, &var_8h);\n        iVar2 = *in_ECX;\n        arg_1ch = 0xe21f;\n        arg_18h = 0xe210;\n        uVar1 = arg_8h[2];\n        arg_10h = arg_8h[3];\n        arg_ch = fcn.0041f8a6();\n        arg_8h_00 = (**(iVar2 + 200))();\n        fcn.00444972(arg_8h_00, arg_ch, arg_10h, uVar1, arg_18h, arg_1ch);\n    }\n    return;\n}\n",
        "token_count": 363
    },
    "004451f2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004451f2(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    fcn.004469e6(param_1 + 1);\n    piVar1 = *param_1;\n    if (piVar1 != NULL) {\n        if (param_1[3] != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n        *param_1 = NULL;\n    }\n    param_1[2] = NULL;\n    return;\n}\n",
        "token_count": 118
    },
    "0044521b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0044521b(uint32_t format, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t **in_ECX;\n    uint var_14h;\n    \n    if (in_ECX[2] == NULL) {\n        uVar2 = fcn.00414c52(arg_ch, format, &var_14h);\n        iVar3 = (**(**in_ECX + 0x14))(*in_ECX, uVar2);\n        uVar1 = iVar3 == 0;\n    }\n    else {\n        uVar1 = (*_sym.imp.USER32.dll_IsClipboardFormatAvailable)(format & 0xffff);\n    }\n    return uVar1;\n}\n",
        "token_count": 169
    },
    "0044527f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044527f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *var_4h;\n    \n    if ((param_1[2] != 0) && (*param_1 == 0)) {\n        var_4h = param_1;\n        iVar1 = (*_sym.imp.ole32.dll_OleGetClipboard)(&var_4h);\n        if (iVar1 == 0) {\n            fcn.00445262(var_4h, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 127
    },
    "004452b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004452b0(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t **in_ECX;\n    \n    fcn.0044527f();\n    piVar1 = *in_ECX;\n    if ((arg_8h != 0) && (piVar1 != NULL)) {\n        (**(*piVar1 + 4))(piVar1);\n    }\n    return piVar1;\n}\n",
        "token_count": 104
    },
    "004452d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004452d6(uint arg_8h, int32_t arg_ch)\n\n{\n    uint16_t *puVar1;\n    int32_t iVar2;\n    int32_t **in_ECX;\n    uint var_2ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.0044527f();\n    if (*in_ECX == NULL) {\n        return 0;\n    }\n    puVar1 = fcn.00414c52(arg_ch, arg_8h, &var_2ch);\n    if (arg_ch == 0) {\n        *(puVar1 + 8) = 0x21;\n    }\n    iVar2 = (**(**in_ECX + 0xc))(*in_ECX, puVar1, &var_ch);\n    if (-1 < iVar2) {\n        if ((var_ch == 1) || (var_ch == 0x20)) {\n            if (var_4h == 0) {\n                return var_8h;\n            }\n            var_18h = 0;\n            var_10h = 0;\n            iVar2 = fcn.004158de(*puVar1, &var_18h, &var_ch);\n            if (iVar2 != 0) {\n                (*_sym.imp.ole32.dll_ReleaseStgMedium)(&var_ch);\n                return var_14h;\n            }\n        }\n        (*_sym.imp.ole32.dll_ReleaseStgMedium)();\n    }\n    return 0;\n}\n",
        "token_count": 361
    },
    "00445391": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00445391(int32_t arg_8h)\n\n{\n    if (*(arg_8h + 0x28) == 0) {\n        fcn.0041de55(8);\n        *(arg_8h + 0x28) = \"AfxFrameOrView90s\";\n    }\n    if ((*(arg_8h + 0x20) & 0x800000) != 0) {\n        *(arg_8h + 0x2c) = *(arg_8h + 0x2c) | 0x200;\n        *(arg_8h + 0x20) = *(arg_8h + 0x20) & 0xff7fffff;\n    }\n    return 1;\n}\n",
        "token_count": 170
    },
    "004453ff": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004453ff(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    \n    if (arg_8h == 0) {\n        fcn.0041638e();\n    }\n    if (arg_ch == 0) {\n        fcn.00419005(arg_8h, 0);\n    }\n    else {\n        uVar1 = fcn.00418023();\n        (*_sym.imp.USER32.dll_AdjustWindowRectEx)(arg_8h, 0, 0, uVar1);\n        uVar2 = fcn.00418009();\n        if ((uVar2 & 0x200000) != 0) {\n            iVar3 = *0x49be40;\n            if ((uVar2 & 0x800000) != 0) {\n                iVar3 = *0x49be40 + -1;\n            }\n            *(arg_8h + 8) = *(arg_8h + 8) + iVar3;\n        }\n        if ((uVar2 & 0x100000) != 0) {\n            iVar3 = *0x49be44;\n            if ((uVar2 & 0x800000) != 0) {\n                iVar3 = *0x49be44 + -1;\n            }\n            *(arg_8h + 0xc) = *(arg_8h + 0xc) + iVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 338
    },
    "004454de": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004454de(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (arg_8h != 0) {\n        iVar1 = fcn.0041d6f0();\n        if (iVar1 != 0) {\n            fcn.004181c9();\n        }\n    }\n    return;\n}\n",
        "token_count": 80
    },
    "00445626": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00445626(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.0041ae6e();\n    if (((iVar1 != 3) && (iVar1 != 4)) && (iVar2 = fcn.0041b98e(),  iVar2 != 0)) {\n        piVar3 = fcn.00430d6d();\n        iVar2 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (((piVar3 == param_1) && (param_1[8] != iVar2)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_IsChild)(param_1[8], iVar2),  iVar2 == 0)) {\n            (**(*param_1 + 0x168))(1, param_1, param_1);\n        }\n        else {\n            fcn.00430d74(param_1, 1);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 240
    },
    "0044569a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044569a(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint arg_8h_00;\n    \n    if (arg_8h == 0) {\n        fcn.0041638e();\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x20));\n    uVar2 = fcn.0041af14(uVar2);\n    iVar3 = fcn.00424c12(0x47fa80);\n    if (iVar3 != 0) {\n        if (arg_ch != 0) {\n            return uVar2;\n        }\n        do {\n            arg_8h_00 = (*pcVar1)(*(arg_8h + 0x20));\n            arg_8h = fcn.0041af14(arg_8h_00);\n            if (arg_8h == 0) {\n                return uVar2;\n            }\n            iVar3 = (*_sym.imp.USER32.dll_IsIconic)(*(arg_8h + 0x20));\n        } while (iVar3 == 0);\n    }\n    return 0;\n}\n",
        "token_count": 292
    },
    "0044577e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044577e(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint in_ECX;\n    uint extraout_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n        in_ECX = extraout_ECX;\n    }\n    iVar1 = fcn.0044569a(in_ECX, 0);\n    if ((iVar1 == 0) || (*(iVar1 + 0x98) != 0)) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = 1;\n    }\n    (***arg_8h)(uVar2);\n    return;\n}\n",
        "token_count": 159
    },
    "00446078": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_60h\n\nvoid fcn.00446078(void)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    int32_t *piVar10;\n    uint uVar11;\n    int32_t iVar12;\n    int32_t *arg_8h;\n    uint32_t uVar13;\n    int32_t unaff_EBP;\n    uint32_t uVar14;\n    uint var_350h;\n    uint hWnd;\n    uint var_2dch;\n    uint pDocInfo;\n    uint var_2d4h;\n    uint var_2d0h;\n    uint var_2c4h;\n    uint var_2c0h;\n    uint var_2bch;\n    uint var_2b8h;\n    uint var_2b4h;\n    uint var_2ach;\n    uint var_2a8h;\n    uint var_2a4h;\n    uint lpPoints;\n    uint var_284h;\n    uint var_278h;\n    uint var_274h;\n    uint var_270h;\n    uint var_26ch;\n    uint hdc;\n    uint var_264h;\n    uint var_260h;\n    uint var_25ch;\n    uint var_258h;\n    uint var_254h;\n    uint var_250h;\n    uint var_24ch;\n    uint var_248h;\n    uint var_244h;\n    uint var_240h;\n    uint var_60h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x344);\n    fcn.00445dc7();\n    *(unaff_EBP + -4) = 0;\n    iVar6 = fcn.0041ae30();\n    if (*(iVar6 + 8) == -0x1ef8) {\n        iVar6 = fcn.0042052a();\n        iVar6 = *(*(iVar6 + 4) + 0x8c);\n        if ((iVar6 != 0) && (*(iVar6 + 0x14) == 3)) {\n            uVar7 = (*_sym.imp.GDI32.dll_CreateDCA)(*(iVar6 + 0x20), *(iVar6 + 0x1c), *(iVar6 + 0x24), 0);\n            *(*(*(unaff_EBP + -0x2b8) + 0x74) + 0x10) = uVar7;\n            if (*(*(*(unaff_EBP + -0x2b8) + 0x74) + 0x10) == 0) {\n                fcn.0041fb58(0xf106, 0, 0xffffffff);\n                goto code_r0x004469ab;\n            }\n        }\n        *(unaff_EBP + -0x2ac) = 1;\n    }\n    iVar6 = (**(*arg_8h + 0x178))(unaff_EBP + -0x2b8);\n    if (iVar6 == 0) goto code_r0x004469ab;\n    fcn.00401e60();\n    uVar1 = *(*(*(unaff_EBP + -0x2b8) + 0x74) + 0x14);\n    *(unaff_EBP + -4) = 1;\n    if (((uVar1 & 0x20) == 0) || (*(unaff_EBP + -0x2b4) != 0)) {\ncode_r0x004462a2:\n        fcn.00401e60();\n        iVar6 = arg_8h[0x15];\n        *(unaff_EBP + -4) = 8;\n        if (iVar6 == 0) {\n            iVar6 = fcn.0041b98e();\n            if (iVar6 == 0) {\n                fcn.0041638e();\n            }\n            fcn.0041c2d9(unaff_EBP + -600);\n        }\n        else {\n            fcn.004076d0(iVar6 + 0x20);\n        }\n        fcn.00458b20(unaff_EBP + -0x2d8, 0, 0x14);\n        *(unaff_EBP + -0x2d8) = 0x14;\n        *(unaff_EBP + -0x2d4) = *(unaff_EBP + -600);\n        fcn.00401e60();\n        iVar6 = *(*(unaff_EBP + -0x254) + -0xc);\n        *(unaff_EBP + -4) = 9;\n        if (iVar6 == 0) {\n            *(unaff_EBP + -0x2d0) = 0;\n            uVar7 = fcn.00447b59(unaff_EBP + -0x25c);\n            *(unaff_EBP + -4) = 10;\n            fcn.004076d0(uVar7);\n            *(unaff_EBP + -4) = 9;\n            fcn.004010f0();\n        }\n        else {\n            *(unaff_EBP + -0x2d0) = *(unaff_EBP + -0x254);\n            uVar7 = fcn.00401eb0(0x104);\n            fcn.0042af5e(*(unaff_EBP + -0x254), uVar7, 0x104);\n        }\n        fcn.00417038();\n        *(unaff_EBP + -4) = 0xb;\n        if (*(unaff_EBP + -0x2b4) == 0) {\n            fcn.004174ae(*(*(*(unaff_EBP + -0x2b8) + 0x74) + 0x10));\n            *(unaff_EBP + -0x260) = 1;\n        }\n        (**(*arg_8h + 0x17c))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n        if (*(unaff_EBP + -0x2b4) == 0) {\n            (*_sym.imp.GDI32.dll_SetAbortProc)(*(unaff_EBP + -0x268), fcn.00445ef4);\n        }\n        uVar7 = fcn.00409ef0();\n        *(unaff_EBP + -0x25c) = uVar7;\n        fcn.004181a2(0);\n        fcn.00445e9f(arg_8h);\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 0xd;\n        fcn.00417fa8(0xc9, *(unaff_EBP + -600));\n        puVar8 = fcn.00447b25(unaff_EBP + -0x274);\n        uVar7 = *puVar8;\n        *(unaff_EBP + -4) = 0xe;\n        fcn.00417fa8(0xca, uVar7);\n        *(unaff_EBP + -4) = 0xd;\n        fcn.004010f0();\n        fcn.00417fa8(0xcb, *(unaff_EBP + -0x24c));\n        fcn.00418160(5);\n        (*_sym.imp.USER32.dll_UpdateWindow)(*(unaff_EBP + -0x330));\n        if (*(unaff_EBP + -0x2b4) != 0) {\ncode_r0x00446575:\n            iVar6 = *(unaff_EBP + -0x2b8);\n            iVar12 = *(iVar6 + 0x74);\n            uVar2 = *(iVar12 + 0x1a);\n            uVar3 = *(iVar12 + 0x18);\n            uVar4 = *(iVar12 + 0x1c);\n            *(unaff_EBP + -0x244) = uVar2;\n            if (uVar2 < uVar4) {\n                *(unaff_EBP + -0x244) = *(*(iVar6 + 0x74) + 0x1c);\n            }\n            iVar6 = *(iVar6 + 0x74);\n            uVar13 = *(iVar6 + 0x1e);\n            if (uVar13 <= *(unaff_EBP + -0x244) && *(unaff_EBP + -0x244) != uVar13) {\n                *(unaff_EBP + -0x244) = uVar13;\n            }\n            uVar9 = *(iVar6 + 0x1c);\n            uVar14 = uVar3;\n            if (uVar3 < uVar9) {\n                uVar14 = uVar9;\n            }\n            if (uVar13 < uVar14) {\n                uVar14 = uVar13;\n            }\n            iVar6 = (-(*(unaff_EBP + -0x244) < uVar14) & 0xfffffffe) + 1;\n            *(unaff_EBP + -0x2c4) = iVar6;\n            if (*(unaff_EBP + -0x244) == 0xffff) {\n                *(unaff_EBP + -0x244) = 0xffff;\n            }\n            else {\n                *(unaff_EBP + -0x244) = *(unaff_EBP + -0x244) + iVar6;\n            }\n            uVar7 = 0xf043;\n            fcn.004024c0(0xf043);\n            *(unaff_EBP + -0x248) = 0;\n            if (*(unaff_EBP + -0x2b4) == 0) {\n                *(unaff_EBP + -0x2a4) = uVar14;\n                pcVar5 = _sym.imp.GDI32.dll_GetDeviceCaps;\n                if (uVar14 != *(unaff_EBP + -0x244)) {\ncode_r0x00446660:\n                    (**(*arg_8h + 0x160))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n                    if (*(unaff_EBP + -0x2a8) == 0) goto code_r0x004468e4;\n                    puVar8 = fcn.0045b3af();\n                    *(unaff_EBP + -0x270) = *puVar8;\n                    puVar8 = fcn.0045b3af();\n                    *puVar8 = 0;\n                    fcn.00458bb8(unaff_EBP + -0x60, 0x50, 0x4f, *(unaff_EBP + -0x250), *(unaff_EBP + -0x2a4));\n                    piVar10 = fcn.0045b3af();\n                    if (*piVar10 == 0) {\n                        puVar8 = fcn.0045b3af();\n                        *puVar8 = *(unaff_EBP + -0x270);\n                    }\n                    else {\n                        puVar8 = fcn.0045b3af();\n                        fcn.00415526(*puVar8);\n                    }\n                    fcn.00417fa8(0xcc, unaff_EBP + -0x60);\n                    uVar11 = (*pcVar5)(*(unaff_EBP + -0x264), 10);\n                    *(unaff_EBP + -0x270) = uVar11;\n                    uVar11 = (*pcVar5)(*(unaff_EBP + -0x264), 8);\n                    (*_sym.imp.USER32.dll_SetRect)(unaff_EBP + -0x294, 0, 0, uVar11, *(unaff_EBP + -0x270));\n                    (*_sym.imp.GDI32.dll_DPtoLP)(*(unaff_EBP + -0x264), unaff_EBP + -0x294, 2);\n                    iVar12 = (*_sym.imp.GDI32.dll_StartPage)(*(unaff_EBP + -0x268));\n                    if (-1 < iVar12) {\n                        (**(*arg_8h + 0x160))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n                        (**(*arg_8h + 0x180))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n                        if ((0 < iVar6) &&\n                           (uVar13 = *(*(*(unaff_EBP + -0x2b8) + 0x74) + 0x1e) + iVar6, \n                           uVar13 <= *(unaff_EBP + -0x244) && *(unaff_EBP + -0x244) != uVar13)) {\n                            *(unaff_EBP + -0x244) = uVar13;\n                        }\n                        iVar12 = (*_sym.imp.GDI32.dll_EndPage)(*(unaff_EBP + -0x268));\n                        if ((-1 < iVar12) || (iVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar12 == 0)) {\ncode_r0x004468a7:\n                            uVar7 = *(unaff_EBP + -0x268);\n                            iVar12 = fcn.00445ef4();\n                            if (iVar12 == 0) goto code_r0x004468da;\n                            *(unaff_EBP + -0x2a4) = *(unaff_EBP + -0x2a4) + iVar6;\n                            if (*(unaff_EBP + -0x2a4) == *(unaff_EBP + -0x244)) goto code_r0x004468e4;\n                            goto code_r0x00446660;\n                        }\n                        fcn.00447b25(unaff_EBP + -0x2c0);\n                        *(unaff_EBP + -4) = 0xf;\n                        uVar11 = fcn.00432cd7(unaff_EBP + -0x274, 0);\n                        iVar6 = sub.WINSPOOL.DRV_OpenPrinterA(uVar11);\n                        *(unaff_EBP + -4) = 0xd;\n                        fcn.004010f0();\n                        if (iVar6 == 0) goto code_r0x004468da;\n                        uVar7 = *(unaff_EBP + -0x274);\n                        iVar6 = sub.WINSPOOL.DRV_GetJobA();\n                        if ((iVar6 == 0) && (iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar6 != 0x7a)) {\n                            *(unaff_EBP + -0x248) = 1;\n                            goto code_r0x004468e4;\n                        }\n                        iVar6 = fcn.0045adaa(*(unaff_EBP + -0x278));\n                        if (iVar6 != 0) {\n                            uVar11 = sub.WINSPOOL.DRV_GetJobA\n                                               (*(unaff_EBP + -0x274), *(unaff_EBP + -0x284), 1, iVar6, \n                                                *(unaff_EBP + -0x278), unaff_EBP + -0x2dc, uVar7);\n                            *(unaff_EBP + -0x270) = uVar11;\n                            *(unaff_EBP + -700) = *(iVar6 + 0x1c);\n                            fcn.004585e6(iVar6);\n                            if ((*(unaff_EBP + -0x270) != 0) && ((*(unaff_EBP + -700) & 0x800) != 0)) {\n                                iVar6 = *(unaff_EBP + -0x2c4);\n                                goto code_r0x004468a7;\n                            }\n                        }\n                    }\ncode_r0x004468da:\n                    *(unaff_EBP + -0x248) = 1;\n                    goto code_r0x004468e4;\n                }\ncode_r0x004468f6:\n                (*_sym.imp.GDI32.dll_EndDoc)(*(unaff_EBP + -0x268));\n            }\n            else {\n                (**(*arg_8h + 0x160))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n                (**(*arg_8h + 0x180))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\ncode_r0x004468e4:\n                if (*(unaff_EBP + -0x2b4) == 0) {\n                    if (*(unaff_EBP + -0x248) == 0) goto code_r0x004468f6;\n                    (*_sym.imp.GDI32.dll_AbortDoc)(*(unaff_EBP + -0x268), uVar7);\n                }\n            }\n            fcn.004181a2(1);\n            (**(*arg_8h + 0x184))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n            fcn.0041b16a();\n            fcn.004174e4();\n            fcn.004010f0();\n            *(unaff_EBP + -4) = 0xb;\n            *(unaff_EBP + -0x350) = vtable.CPrintingDialog.0;\n            fcn.0041ec27();\n            *(unaff_EBP + -4) = 9;\n            fcn.0041752d();\n            fcn.004010f0();\n            goto code_r0x00446995;\n        }\n        iVar6 = (*_sym.imp.GDI32.dll_StartDocA)(*(unaff_EBP + -0x268), unaff_EBP + -0x2d8);\n        *(unaff_EBP + -0x284) = iVar6;\n        if (iVar6 != -1) goto code_r0x00446575;\n        fcn.004181a2(1);\n        (**(*arg_8h + 0x184))(unaff_EBP + -0x26c, unaff_EBP + -0x2b8);\n        fcn.0041b16a();\n        fcn.004174e4();\n        fcn.0041fb58(0xf106, 0, 0xffffffff);\n        fcn.004010f0();\n        *(unaff_EBP + -4) = 0xb;\n        *(unaff_EBP + -0x350) = vtable.CPrintingDialog.0;\n        fcn.0041ec27();\n        *(unaff_EBP + -4) = 9;\n        fcn.0041752d();\n        fcn.004010f0();\n        fcn.004010f0();\n    }\n    else {\n        fcn.00404920(0xf045);\n        *(unaff_EBP + -4) = 2;\n        fcn.00404920(0xf046);\n        *(unaff_EBP + -4) = 3;\n        fcn.00404920(0xf047);\n        *(unaff_EBP + -4) = 4;\n        fcn.00404920(0xf048);\n        *(unaff_EBP + -4) = 5;\n        fcn.00440962(0, *(unaff_EBP + -0x244), *(unaff_EBP + -0x248), 6, *(unaff_EBP + -0x24c), 0, 0, 1);\n        uVar7 = *(unaff_EBP + -0x250);\n        *(unaff_EBP + -4) = 6;\n        iVar6 = fcn.0044007e();\n        *(iVar6 + 0x30) = uVar7;\n        iVar6 = fcn.0044114a();\n        if (iVar6 == 1) {\n            uVar7 = fcn.00441276(unaff_EBP + -0x25c);\n            *(unaff_EBP + -4) = 7;\n            fcn.004076d0(uVar7);\n            fcn.004010f0();\n            *(unaff_EBP + -4) = 5;\n            fcn.0044076a();\n            fcn.004010f0();\n            fcn.004010f0();\n            fcn.004010f0();\n            fcn.004010f0();\n            goto code_r0x004462a2;\n        }\n        *(unaff_EBP + -4) = 5;\n        fcn.0044076a();\n        fcn.004010f0();\n        fcn.004010f0();\n        fcn.004010f0();\ncode_r0x00446995:\n        fcn.004010f0();\n    }\n    fcn.004010f0();\ncode_r0x004469ab:\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00445e4c();\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 4669
    },
    "00446a07": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00446a07(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t *in_ECX;\n    int32_t **ppiVar3;\n    \n    piVar1 = (**(*in_ECX + 0x44))(arg_8h);\n    if (piVar1 == NULL) {\n        ppiVar2 = (**(*in_ECX + 0x38))();\n        if ((((*0x4850a0 == *arg_8h) && (arg_8h[1] == *0x4850a4)) && (arg_8h[2] == *0x4850a8)) &&\n           (arg_8h[3] == *0x4850ac)) {\n            do {\n                for (piVar1 = ppiVar2[1]; *piVar1 != 0; piVar1 = piVar1 + 2) {\n                    if (*(piVar1[1] + in_ECX) != 0) {\n                        return piVar1[1] + in_ECX;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        else {\n            do {\n                for (ppiVar3 = ppiVar2[1]; piVar1 = *ppiVar3,  piVar1 != NULL; ppiVar3 = ppiVar3 + 2) {\n                    if (((*piVar1 == *arg_8h) && (piVar1[1] == arg_8h[1])) &&\n                       ((piVar1[2] == arg_8h[2] && ((piVar1[3] == arg_8h[3] && (*(ppiVar3[1] + in_ECX) != 0)))))) {\n                        return ppiVar3[1] + in_ECX;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        piVar1 = NULL;\n    }\n    return piVar1;\n}\n",
        "token_count": 467
    },
    "00446aba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00446aba(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(in_ECX + *piVar3);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 292
    },
    "00446b1c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00446b1c(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    \n    piVar1 = param_1 + 4;\n    if (*piVar1 != 0) {\n        uVar2 = fcn.00446a07(0x4850a0);\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(piVar1);\n        (*_sym.imp.ole32.dll_CoDisconnectObject)(uVar2, 0);\n        *piVar1 = 0;\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "00446b4a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00446b4a(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != 0) {\n        (**(**(param_1 + 8) + 4))(*(param_1 + 8));\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(param_1 + 4);\n    return;\n}\n",
        "token_count": 87
    },
    "00446b65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00446b65(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    int32_t iVar3;\n    \n    iVar3 = 8;\n    fcn.0045af3b(8);\n    if ((extraout_ECX[1] != 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(extraout_ECX + 1),  iVar2 == 0)\n       ) {\n        fcn.00420576(extraout_ECX[7]);\n        iVar1 = *extraout_ECX;\n        *(unaff_EBP + -4) = 0;\n        (**(iVar1 + 0x10))();\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x10) != 0) {\n            fcn.0041fc5e();\n            iVar3 = iVar2;\n        }\n    }\n    fcn.0045b013(iVar3);\n    return;\n}\n",
        "token_count": 279
    },
    "00446bbb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00446bbb(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    \n    if (*(param_1 + 8) == 0) {\n        iVar3 = 8;\n        fcn.0045af3b(8);\n        if ((extraout_ECX[1] != 0) &&\n           (iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(extraout_ECX + 1),  iVar2 == 0)) {\n            fcn.00420576(extraout_ECX[7]);\n            iVar1 = *extraout_ECX;\n            *(unaff_EBP + -4) = 0;\n            (**(iVar1 + 0x10))();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*(unaff_EBP + -0x10) != 0) {\n                fcn.0041fc5e();\n                iVar3 = iVar2;\n            }\n        }\n        fcn.0045b013(iVar3);\n        return;\n    }\n    (**(**(param_1 + 8) + 8))(*(param_1 + 8));\n    return;\n}\n",
        "token_count": 290
    },
    "00446c13": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00446c13(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 8) != 0) {\n        iVar1 = (****(in_ECX + 8))(*(in_ECX + 8), arg_8h, arg_ch);\n        return iVar1;\n    }\n    iVar1 = fcn.00446a07(arg_8h);\n    *arg_ch = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.00446aba(arg_8h);\n        *arg_ch = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.00446b4a();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 211
    },
    "00446c87": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.00446c87(int16_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *arg_8h_00;\n    int16_t *piVar4;\n    int32_t *arg_ch_00;\n    int32_t in_ECX;\n    int16_t *var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = NULL;\n    var_8h = 0;\n    if (*(in_ECX + 0x28) != 0) {\n        var_4h = 0;\n        do {\n            piVar4 = *(in_ECX + 0x20) + var_4h;\n            if ((*piVar4 == *arg_8h) && ((*(arg_8h + 8) & *(piVar4 + 8)) != 0)) {\n                iVar1 = *(piVar4 + 4);\n                if ((iVar1 != 2) && ((iVar1 != 4 && (*(piVar4 + 10) != 0)))) {\n                    iVar2 = *(piVar4 + 6);\n                    iVar3 = *(arg_8h + 6);\n                    if ((iVar2 != iVar3) && (((iVar2 != 0 || (iVar3 != -1)) && ((iVar2 != -1 || (iVar3 != 0))))))\n                    goto code_r0x00446d2a;\n                }\n                if ((iVar1 == *(arg_8h + 4)) && (*(piVar4 + 0x10) == arg_ch)) {\n                    arg_ch_00 = *(arg_8h + 2);\n                    arg_8h_00 = *(piVar4 + 2);\n                    var_ch = piVar4;\n                    if (arg_8h_00 != NULL) {\n                        if ((arg_ch_00 == NULL) || (*arg_8h_00 != *arg_ch_00)) goto code_r0x00446d2a;\n                        arg_ch_00 = fcn.0045b591(arg_8h_00, arg_ch_00, *arg_8h_00);\n                    }\n                    if (arg_ch_00 == NULL) {\n                        return piVar4;\n                    }\n                }\n            }\ncode_r0x00446d2a:\n            var_8h = var_8h + 1;\n            var_4h = var_4h + 0x24;\n        } while (var_8h < *(in_ECX + 0x28));\n    }\n    return var_ch;\n}\n",
        "token_count": 585
    },
    "00455243": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00455243(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[9];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.00446b65();\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        fcn.00414b30(extraout_ECX[10]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041e889();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 227
    },
    "00446fc2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00446fc2(uint *arg_8h, uint arg_ch)\n\n{\n    int64_t iVar1;\n    uint *puVar2;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    puVar2 = fcn.00446c87(arg_8h, arg_ch);\n    if (puVar2 == NULL) {\n        if ((*(in_ECX + 0x20) == 0) || (*(in_ECX + 0x28) == *(in_ECX + 0x24))) {\n            iVar1 = (*(in_ECX + 0x24) + *(in_ECX + 0x2c)) * 0x24;\n            arg_8h_00 = fcn.00414af6(-(iVar1 >> 0x20 != 0) | iVar1);\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) + *(in_ECX + 0x2c);\n            if (*(in_ECX + 0x20) != 0) {\n                fcn.00414fcb(arg_8h_00, (*(in_ECX + 0x24) + *(in_ECX + 0x2c)) * 0x24, *(in_ECX + 0x20), \n                             *(in_ECX + 0x28) * 0x24);\n                fcn.00414b30(*(in_ECX + 0x20));\n            }\n            *(in_ECX + 0x20) = arg_8h_00;\n        }\n        puVar2 = *(in_ECX + 0x28) * 0x24 + *(in_ECX + 0x20);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + 1;\n    }\n    else {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(puVar2[1]);\n        (*_sym.imp.ole32.dll_ReleaseStgMedium)(puVar2 + 5);\n    }\n    puVar2[8] = arg_ch;\n    puVar4 = puVar2;\n    for (iVar3 = 5; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = *arg_8h;\n        arg_8h = arg_8h + 1;\n        puVar4 = puVar4 + 1;\n    }\n    return puVar2;\n}\n",
        "token_count": 564
    },
    "004475b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004475b6(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    \n    if (arg_8h == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(arg_8h);\n    uVar2 = fcn.0041af40(uVar2);\n    piVar3 = fcn.00424c30(0x47ff4c, uVar2);\n    if (piVar3 != NULL) {\n        if (arg_ch == 0x400) {\n            uVar2 = (**(*piVar3 + 0x164))(arg_10h, arg_10h >> 0x10, arg_14h);\n            return uVar2;\n        }\n        if ((0x400 < arg_ch) && (arg_ch < 0x407)) {\n            iVar1 = *piVar3;\n            uVar2 = fcn.0041749a(arg_10h, arg_ch, arg_14h);\n            uVar2 = (**(iVar1 + 0x168))(uVar2);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 298
    },
    "0044766b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044766b(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint16_t *puVar3;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (arg_8h == 0) {\n        uVar2 = 0;\n    }\n    else {\n        puVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(arg_8h);\n        if (arg_ch == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*pcVar1)(arg_ch);\n        }\n        if (puVar3 == NULL) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.GDI32.dll_CreateDCA)(*puVar3 + puVar3, puVar3[1] + puVar3, puVar3[2] + puVar3, uVar2);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(arg_8h);\n            if (arg_ch != 0) {\n                (*pcVar1)(arg_ch);\n            }\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 286
    },
    "0044775a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044775a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.004400c1(*(unaff_EBP + 0x10));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CPrintDialog.0;\n    extraout_ECX[0x1d] = extraout_ECX + 0x1e;\n    fcn.00458b20(extraout_ECX + 0x1e, 0, 0x42);\n    *extraout_ECX[0x1d] = 0x42;\n    *(extraout_ECX[0x1d] + 0x14) = *(unaff_EBP + 0xc) | 0x3000;\n    iVar2 = fcn.0041ef70();\n    if (iVar2 != 0) {\n        *(extraout_ECX[0x1d] + 0x14) = *(extraout_ECX[0x1d] + 0x14) | 0x800;\n    }\n    iVar2 = *(unaff_EBP + 8);\n    *(extraout_ECX[0x1d] + 0x2a) = fcn.00445036;\n    *(extraout_ECX[0x1d] + 0x2e) = fcn.00445036;\n    if (iVar2 == 0) {\n        extraout_ECX[0x15] = 0x7008;\n        puVar1 = extraout_ECX[0x1d] + 0x14;\n        *puVar1 = *puVar1 | 0x100;\n    }\n    else {\n        extraout_ECX[0x15] = 0x7009;\n        puVar1 = extraout_ECX[0x1d] + 0x14;\n        *puVar1 = *puVar1 | 0x40;\n    }\n    *(extraout_ECX[0x1d] + 0x14) = *(extraout_ECX[0x1d] + 0x14) & 0xfffffdff;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 604
    },
    "0044788f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044788f(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x48) == 0) {\n        uVar1 = fcn.0041ac5f(\"PrintDlgA\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x48) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x48);\n    return;\n}\n",
        "token_count": 128
    },
    "00447933": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00447933(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "00447969": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447969(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x54) == 0) {\n        uVar1 = fcn.0041ac5f(\"PageSetupDlgA\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x54) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x54);\n    return;\n}\n",
        "token_count": 128
    },
    "00447a0d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00447a0d(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "00447c04": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447c04(uint32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (in_ECX[0x43] == 0) {\n        return;\n    }\n    if ((arg_10h != 0) && (iVar1 = fcn.0041b48d(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x78))(0);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0x140))(arg_8h & 0xff | 0xff00, arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 177
    },
    "00447c1c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447c1c(uint *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    (***arg_8h)(*(in_ECX + 0x10c) != 2);\n    return;\n}\n",
        "token_count": 56
    },
    "00447cc7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00447cc7(uint arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    uVar2 = 0x8000ffff;\n    if ((*(in_ECX + 0x108) != 0) && (*(in_ECX + 0x100) != 0)) {\n        puVar1 = *(in_ECX + 0x100);\n        uVar2 = (***puVar1)(puVar1, 0x485120, arg_8h);\n    }\n    return uVar2;\n}\n",
        "token_count": 135
    },
    "00447cf8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00447cf8(uint arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    uVar2 = 0x8000ffff;\n    if ((*(in_ECX + 0x10c) != 0) && (*(in_ECX + 0x104) != 0)) {\n        puVar1 = *(in_ECX + 0x104);\n        uVar2 = (***puVar1)(puVar1, 0x485120, arg_8h);\n    }\n    return uVar2;\n}\n",
        "token_count": 136
    },
    "00447d29": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00447d29(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CPreviewView.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.004174e4();\n    if (extraout_ECX[0x4d] != NULL) {\n        fcn.00447b8d(1);\n    }\n    fcn.00414b30(extraout_ECX[0x2a]);\n    if (extraout_ECX[0x24] != NULL) {\n        (**(*extraout_ECX[0x24] + 4))(1);\n    }\n    if (extraout_ECX[0x48] != NULL) {\n        uVar1 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n        (*_sym.imp.USER32.dll_SetCursor)(uVar1);\n        (*_sym.imp.USER32.dll_DestroyCursor)(extraout_ECX[0x48]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0041752d();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004555cf();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 372
    },
    "00447fa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00447fa0(int32_t *arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t var_8h;\n    \n    var_8h = in_ECX;\n    fcn.00455c17(arg_8h, &var_8h);\n    if (*(in_ECX + 0x10c) == 0) {\n        iVar2 = *(**(in_ECX + 0x134) + 0x74);\n        iVar1 = *(iVar2 + 0x1e);\n        if ((iVar1 != -1) && (iVar1 != *(iVar2 + 0x1c))) {\n            *arg_8h = *arg_8h - var_8h;\n        }\n    }\n    *(in_ECX + 0x11c) = (*arg_8h + -8) / 2;\n    if (*(in_ECX + 0x118) == 2) {\n        iVar2 = (*arg_8h + -0x18) / 2;\n    }\n    else {\n        iVar2 = *arg_8h + -0x10;\n    }\n    arg_8h[1] = arg_8h[1] + -0x10;\n    *arg_8h = iVar2;\n    return arg_8h;\n}\n",
        "token_count": 309
    },
    "00448020": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00448020(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    int32_t *piVar7;\n    uint xRight;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar6 = arg_8h * 0x28 + *(in_ECX + 0xb0);\n    fcn.00447fa0(&var_8h);\n    iVar5 = *(iVar6 + 0x24);\n    iVar1 = *(in_ECX + 0x10c);\n    bVar2 = iVar5 <= *(iVar6 + 0x20);\n    if (iVar1 == 0) {\n        *(iVar6 + 0x18) = *(iVar6 + 0x20);\n        iVar4 = *(iVar6 + 0x24);\ncode_r0x004480a0:\n        *(iVar6 + 0x1c) = iVar4;\n    }\n    else {\n        iVar4 = iVar1 + -1;\n        if (iVar4 == 0) {\n            *(iVar6 + 0x1c) = iVar5;\n            if (bVar2) {\n                iVar5 = *(iVar6 + 0x20) * 3 - iVar5;\n            }\n            else {\n                iVar5 = *(iVar6 + 0x20) + iVar5;\n            }\n            iVar5 = iVar5 / 2;\n        }\n        else {\n            if (iVar1 != 2) goto code_r0x004480a3;\n            if (!bVar2) {\n                *(iVar6 + 0x18) = iVar4;\n                goto code_r0x004480a0;\n            }\n            *(iVar6 + 0x1c) = iVar5;\n            iVar5 = *(iVar6 + 0x20) * 2 - *(iVar6 + 0x24);\n        }\n        *(iVar6 + 0x18) = iVar5;\n    }\ncode_r0x004480a3:\n    iVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x10), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    iVar6 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x14), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    piVar7 = *(in_ECX + 0xb0) + arg_8h * 0x28;\n    (*_sym.imp.USER32.dll_SetRect)(piVar7, 8, 8, iVar5 + 0xb, iVar6 + 0xb);\n    pcVar3 = _sym.imp.USER32.dll_OffsetRect;\n    if (*(in_ECX + 0x10c) == 0) {\n        (*_sym.imp.USER32.dll_OffsetRect)\n                  (piVar7, ((*piVar7 - piVar7[2]) + var_8h) / 2 + -1, ((piVar7[1] - piVar7[3]) + var_4h) / 2 + -1);\n        if (arg_8h == 1) {\n            (*pcVar3)(piVar7, *(in_ECX + 0x11c), 0);\n        }\n    }\n    else {\n        fcn.00456452(1, (piVar7[2] - *piVar7) + 0x10, (piVar7[3] - piVar7[1]) + 0x10, &var_8h, 0x4824c0);\n    }\n    return;\n}\n",
        "token_count": 841
    },
    "004481a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004481a8(int32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t lpRect;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t lprc;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 0x10c) != 0) {\n        piVar1 = fcn.00455b0c(&var_ch);\n        iVar3 = piVar1[1];\n        *arg_8h = *arg_8h + *piVar1;\n        arg_8h[1] = arg_8h[1] + iVar3;\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n    *arg_ch = 0;\n    if (*(in_ECX + 0x118) != 0) {\n        do {\n            iVar3 = var_4h;\n            piVar1 = *arg_ch * 0x28 + *(in_ECX + 0xb0);\n            lprc = *piVar1;\n            var_10h = piVar1[1];\n            var_ch = piVar1[2];\n            var_8h = piVar1[3];\n            if (*(var_4h + 0x10c) != 0) {\n                iVar4 = (((var_1ch - var_ch) - lpRect) + -0x10 + lprc) / 2 + -1;\n                iVar2 = (((var_18h - var_8h) - var_20h) + -0x10 + var_10h) / 2 + -1;\n                if (iVar4 < 0) {\n                    iVar4 = 0;\n                }\n                if (iVar2 < 0) {\n                    iVar2 = 0;\n                }\n                (*_sym.imp.USER32.dll_OffsetRect)(&lprc, iVar4, iVar2);\n            }\n            iVar2 = (*_sym.imp.USER32.dll_PtInRect)(&lprc, *arg_8h, arg_8h[1]);\n            if (iVar2 != 0) {\n                iVar2 = *(*arg_ch * 0x28 + *(iVar3 + 0xb0));\n                arg_8h[1] = arg_8h[1] - *(*arg_ch * 0x28 + 4 + *(iVar3 + 0xb0));\n                *arg_8h = *arg_8h - iVar2;\n                iVar2 = *arg_ch * 0x28 + *(iVar3 + 0xb0);\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, *(iVar2 + 0x1c), *(iVar2 + 0x18));\n                *arg_8h = iVar2;\n                iVar3 = *arg_ch * 0x28 + *(iVar3 + 0xb0);\n                iVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_8h[1], *(iVar3 + 0x1c), *(iVar3 + 0x18));\n                arg_8h[1] = iVar3;\n                return 1;\n            }\n            *arg_ch = *arg_ch + 1;\n            in_ECX = iVar3;\n        } while (*arg_ch < *(iVar3 + 0x118));\n    }\n    return 0;\n}\n",
        "token_count": 841
    },
    "004483ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004483ee(uint noname_0, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    uint var_8h;\n    \n    if (arg_ch == 1) {\n        (*_sym.imp.USER32.dll_GetCursorPos)(&var_8h);\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x20), &var_8h);\n        if ((*(in_ECX + 0x10c) == 2) || (iVar2 = fcn.004481a8(&var_8h, &arg_ch),  iVar2 == 0)) {\n            iVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n        }\n        else {\n            piVar3 = in_ECX + 0x120;\n            if (*piVar3 == 0) {\n                iVar2 = fcn.0042052a();\n                iVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(*(iVar2 + 0xc), 0x7902);\n                *piVar3 = iVar2;\n            }\n            iVar2 = *piVar3;\n        }\n        (*_sym.imp.USER32.dll_SetCursor)(iVar2);\n        return 0;\n    }\n    uVar1 = fcn.0041ae6e();\n    return uVar1;\n}\n",
        "token_count": 325
    },
    "0044884b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044884b(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (in_ECX[0x43] != 0) {\n        if (((arg_10h == 0) || (iVar1 = fcn.0041b48d(0),  iVar1 == 0)) &&\n           (iVar1 = (**(*in_ECX + 0x78))(1),  arg_10h == iVar1)) {\n            (**(*in_ECX + 0x140))((arg_8h & 0xff) << 8 | 0xff, arg_ch, 1);\n        }\n        return;\n    }\n    if (arg_8h == 0) {\n        arg_ch = in_ECX[0x45] - 1;\n    }\n    else if (arg_8h == 1) {\n        arg_ch = in_ECX[0x45] + 1;\n    }\n    else if (arg_8h == 2) {\n        arg_ch = in_ECX[0x45] - ((*(*(*in_ECX[0x4d] + 0x74) + 0x1e) - *(*(*in_ECX[0x4d] + 0x74) + 0x1c)) + 9) / 10;\n    }\n    else if (arg_8h == 3) {\n        arg_ch = ((*(*(*in_ECX[0x4d] + 0x74) + 0x1e) - *(*(*in_ECX[0x4d] + 0x74) + 0x1c)) + 9) / 10 + in_ECX[0x45];\n    }\n    else if (arg_8h != 4) {\n        if (arg_8h == 6) {\n            arg_ch = *(*(*in_ECX[0x4d] + 0x74) + 0x1c);\n        }\n        else {\n            if (arg_8h != 7) {\n                return;\n            }\n            arg_ch = *(*(*in_ECX[0x4d] + 0x74) + 0x1e);\n        }\n    }\n    fcn.004482ee(arg_ch, 1);\n    return;\n}\n",
        "token_count": 529
    },
    "00448fb1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00448fb1(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = fcn.004481a8(&arg_ch, &var_4h);\n    if (iVar1 != 0) {\n        if (*(in_ECX + 0x10c) == 2) {\n            iVar1 = 0;\n        }\n        else {\n            iVar1 = *(in_ECX + 0x10c) + 1;\n        }\n        fcn.00448e30(iVar1, var_4h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 176
    },
    "00449628": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00449628(int32_t arg_8h)\n\n{\n    int32_t arg_ch;\n    int32_t in_ECX;\n    \n    arg_ch = (*_sym.imp.ole32.dll_CreateStreamOnHGlobal)(0, 1, in_ECX + 0x10);\n    if ((arg_ch < 0) && (arg_8h != 0)) {\n        fcn.004495bd(arg_8h, arg_ch);\n    }\n    return -1 < arg_ch;\n}\n",
        "token_count": 113
    },
    "00449689": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00449689(int32_t *param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uint unaff_ESI;\n    int32_t *unaff_EDI;\n    int32_t *piVar4;\n    \n    piVar4 = param_1 + 4;\n    if (*piVar4 != 0) {\n        (**(*param_1 + 0x48))();\n        fcn.004469e6(piVar4);\n        unaff_EDI = piVar4;\n    }\n    param_1 = param_1 + 5;\n    iVar3 = *param_1;\n    ppiVar1 = iVar3 + -0x10;\n    piVar4 = *ppiVar1;\n    if (*(iVar3 + -0xc) != 0) {\n        piVar2 = iVar3 + -4;\n        if (*(iVar3 + -4) < 0) {\n            if (*(iVar3 + -8) < 0) {\n                fcn.00401000(0x80070057);\n                iVar3 = extraout_ECX;\n            }\n            *(iVar3 + -0xc) = 0;\n            **param_1 = 0;\n            return;\n        }\n        LOCK();\n        iVar3 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1, unaff_EDI, unaff_ESI);\n        }\n        iVar3 = (**(*piVar4 + 0xc))();\n        *param_1 = iVar3 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 397
    },
    "00449d33": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449d33(uint hKey, uint lpSubKey, uint phkResult)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    fcn.00404920(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + 8, \"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            fcn.004010f0();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 316
    },
    "00449dbb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449dbb(uint hKey, uint lpSubKey, uint phkResult)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    fcn.00404920(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + 8, \"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            fcn.004010f0();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 316
    },
    "00449e43": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449e43(uint hKey, uint lpSubKey, uint ulOptions, uint samDesired, uint phkResult)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    fcn.00404920(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + 8, \"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            fcn.004010f0();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)\n              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 349
    },
    "00449ed1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449ed1(uint hKey, uint lpSubKey, uint lpData, uint lpcbData)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    fcn.00404920(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + 8, \"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            fcn.004010f0();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegQueryValueA)\n              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 332
    },
    "00449f5c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449f5c(uint hKey, uint lpSubKey, uint dwType, uint lpData, uint cbData)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    fcn.00404920(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + 8, \"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            fcn.004010f0();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegSetValueA)\n              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 346
    },
    "00449fea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449fea(uint hKey, uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    fcn.00404920(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.0041fddb();\n        if (iVar1 == 1) {\n            uVar2 = fcn.0043fd38(unaff_EBP + 8, \"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.004076d0(uVar2);\n            fcn.004010f0();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 299
    },
    "0044a337": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044a337(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    \n    if (arg_8h == 0) {\n        fcn.0041638e();\n        in_ECX = extraout_ECX;\n    }\n    return *(in_ECX + 4) + arg_8h;\n}\n",
        "token_count": 90
    },
    "0044a6ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044a6ef(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.0044a36f(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    (***arg_8h)(1);\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 363
    },
    "0044a786": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044a786(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_ECX;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    if (arg_ch == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX);\n        if (iVar2 != 0) {\n            fcn.0044a6ef(iVar2, arg_8h);\n        }\n    }\n    else {\n        iVar2 = in_ECX[5];\n        while (iVar2 != 0) {\n            iVar1 = *(iVar2 + 4);\n            fcn.0044a6ef(iVar2, arg_8h);\n            iVar2 = iVar1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    return;\n}\n",
        "token_count": 214
    },
    "0044a7e2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044a7e2(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_ch;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    if (*(unaff_EBP + 8) != 0) goto code_r0x0044a801;\ncode_r0x0044a7fc:\n    do {\n        fcn.0041638e();\ncode_r0x0044a801:\n        if (*extraout_ECX != 0) goto code_r0x0044a83c;\n        if (*0x49be94 == 0) {\n            *(unaff_EBP + -0x10) = 0x49be98;\n            *(unaff_EBP + -4) = 0;\n            *0x49be94 = fcn.0044a4f8();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x49be94 == 0) goto code_r0x0044a7fc;\n        }\n        iVar1 = fcn.0044a3e0();\n        *extraout_ECX = iVar1;\n        if (iVar1 != 0) {\ncode_r0x0044a83c:\n            iVar1 = fcn.0044a252(*extraout_ECX);\n            if (iVar1 == 0) {\n                arg_ch = (**(unaff_EBP + 8))();\n                fcn.0044a59f(*extraout_ECX, arg_ch);\n            }\n            fcn.0045b013();\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 404
    },
    "0044a949": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044a949(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == 0) {\n        arg_8h = 0x11;\n    }\n    if (*(in_ECX + 4) != 0) {\n        fcn.00414b30(*(in_ECX + 4));\n        *(in_ECX + 4) = 0;\n    }\n    if (arg_ch != 0) {\n        uVar1 = fcn.00414af6(-(arg_8h * 4 >> 0x20 != 0) | arg_8h * 4);\n        *(in_ECX + 4) = uVar1;\n        fcn.00458b20(uVar1, 0, arg_8h << 2);\n    }\n    *(in_ECX + 8) = arg_8h;\n    return;\n}\n",
        "token_count": 218
    },
    "0044aba4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044aba4(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar3 = fcn.0042e01d(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar1 = *(param_1 + 0x18);\n        puVar4 = iVar3 + -8 + iVar1 * 0xc;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar4 = *(param_1 + 0x10);\n            *(param_1 + 0x10) = puVar4;\n            puVar4 = puVar4 + -3;\n        }\n    }\n    puVar4 = *(param_1 + 0x10);\n    uVar2 = *puVar4;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar2;\n    puVar4[1] = 0;\n    puVar4[2] = 0;\n    return;\n}\n",
        "token_count": 290
    },
    "0044adb7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044adb7(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x44) != 0);\n        while (var_8h != 0) {\n            fcn.0044aae3(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x58) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x5c) == 2) {\n                puVar1[1] = 0;\n            }\n            (**(param_1 + 0x18))(var_4h);\n        }\n        fcn.0044a9a7();\n        fcn.00457c0a();\n    }\n    return;\n}\n",
        "token_count": 226
    },
    "0044ae8a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0044ae8a(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.0042055d();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (((arg_8h != -1) && (iVar2 = fcn.004379b3(),  iVar2 != 0)) && (*(iVar2 + 0x3c) != NULL)) {\n                (**(iVar2 + 0x3c))(0, 0);\n            }\n            fcn.0044adb7();\n            fcn.0044adb7();\n            fcn.0044adb7();\n            fcn.0044adb7();\n            fcn.0044adb7();\n        }\n        iVar2 = fcn.0042052a();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.0044a2a4();\n        if ((((iVar3 != 0) && (iVar2 != 0)) &&\n            ((*(iVar3 + 0xc) == 0 || (uVar4 = fcn.0045dcbf(*(iVar3 + 0xc)),  uVar4 < *(iVar2 + 0x98))))) &&\n           (*(iVar2 + 0x98) != 0)) {\n            arg_8h = 0;\n            if (*(iVar3 + 0xc) != 0) {\n                arg_8h = fcn.0045dcbf(*(iVar3 + 0xc));\n                fcn.004585e6(*(iVar3 + 0xc));\n            }\n            iVar2 = fcn.0045adaa(*(iVar2 + 0x98));\n            *(iVar3 + 0xc) = iVar2;\n            if ((iVar2 == 0) && (arg_8h != 0)) {\n                uVar5 = fcn.0045adaa(arg_8h);\n                *(iVar3 + 0xc) = uVar5;\n            }\n        }\n    }\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 540
    },
    "0044b322": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b322(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x49be5c;\n    uVar3 = *0x49be58;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.00417323(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, 0x9ec, uVar3);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], 0x9ec, uVar4);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 354
    },
    "0044b8a3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b8a3(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        iVar2 = fcn.0042e01d(in_ECX + 0x14, *(in_ECX + 0x18), 0xc);\n        iVar1 = *(in_ECX + 0x18);\n        puVar3 = iVar2 + -8 + iVar1 * 0xc;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar3 = *(in_ECX + 0x10);\n            *(in_ECX + 0x10) = puVar3;\n            puVar3 = puVar3 + -3;\n        }\n    }\n    puVar3 = *(in_ECX + 0x10);\n    *(in_ECX + 0x10) = *puVar3;\n    puVar3[1] = arg_8h;\n    *puVar3 = arg_ch;\n    *(in_ECX + 0xc) = *(in_ECX + 0xc) + 1;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 299
    },
    "0044b955": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0044b955(void)\n\n{\n    if (*0x49bed8 == 0) {\n        *0x49bed8 = 1;\n        (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x49c078);\n    }\n    return *0x49bed8;\n}\n",
        "token_count": 69
    },
    "0044b9be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b9be(uint32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (0x10 < arg_8h) {\n        fcn.0041638e();\n    }\n    if (*0x49bed8 == 0) {\n        fcn.0044b955();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    piVar1 = arg_8h * 4 + 0x49c090;\n    if (*piVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x49c078);\n        if (*piVar1 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(arg_8h * 0x18 + 0x49bee0);\n            *piVar1 = *piVar1 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x49c078);\n    }\n    (*pcVar2)(arg_8h * 0x18 + 0x49bee0);\n    return;\n}\n",
        "token_count": 255
    },
    "0044bb48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044bb48(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int16_t *piVar4;\n    uint16_t *puVar5;\n    uint16_t uVar6;\n    bool bVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar7 = *(arg_8h + 2) == -1;\n    iVar2 = fcn.0044baf7(arg_8h);\n    iVar3 = fcn.0044bab0(arg_8h);\n    if (iVar3 != 0) {\n        iVar2 = iVar2 + (bVar7 * 2 + 1) * 2;\n        iVar3 = fcn.0045ae91(iVar2);\n        iVar2 = iVar2 + 2 + iVar3 * 2;\n    }\n    if (bVar7) {\n        iVar1 = *(arg_8h + 0x10);\n    }\n    else {\n        iVar1 = *(arg_8h + 8);\n    }\n    if (iVar1 != 0) {\n        do {\n            piVar4 = (iVar2 + 3U & 0xfffffffc) + (-bVar7 & 6) + 0x12;\n            if (*piVar4 == -1) {\n                piVar4 = piVar4 + 2;\n            }\n            else {\n                piVar4 = fcn.0044bae3(piVar4);\n            }\n            if (*piVar4 == -1) {\n                puVar5 = piVar4 + 2;\n            }\n            else {\n                puVar5 = fcn.0044bae3(piVar4);\n            }\n            uVar6 = *puVar5;\n            if ((uVar6 != 0) && (!bVar7)) {\n                uVar6 = uVar6 - 2;\n            }\n            iVar1 = iVar1 + -1;\n            iVar2 = puVar5 + uVar6 + 2;\n        } while (iVar1 != 0);\n    }\n    return iVar2 - arg_8h;\n}\n",
        "token_count": 478
    },
    "0044bc7c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n\nvoid __cdecl fcn.0044bc7c(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *arg_8h_00;\n    int32_t iVar2;\n    int32_t iVar3;\n    ushort *puVar4;\n    uint32_t arg_10h;\n    uint *in_ECX;\n    int32_t iVar5;\n    uint32_t arg_ch_00;\n    int16_t iVar6;\n    uint32_t arg_8h_01;\n    bool bVar7;\n    int32_t var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint lpString;\n    uint var_44h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if (in_ECX[1] != 0) {\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        bVar7 = *(arg_8h_00 + 2) == -1;\n        iVar2 = fcn.0044bab0(arg_8h_00);\n        iVar1 = bVar7 * 2 + 1;\n        var_58h = iVar1 * 2;\n        if (bVar7) {\n            arg_8h_00[3] = arg_8h_00[3] | 0x40;\n        }\n        else {\n            *arg_8h_00 = *arg_8h_00 | 0x40;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h);\n        if (iVar3 < 0x20) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, arg_8h, 0xffffffff, &var_44h, 0x20);\n            iVar3 = var_58h + iVar3 * 2;\n            if (var_58h <= iVar3) {\n                puVar4 = fcn.0044baf7(arg_8h_00);\n                iVar5 = 0;\n                if (iVar2 != 0) {\n                    iVar2 = fcn.0045ae91(puVar4 + iVar1);\n                    iVar5 = var_58h + 2 + iVar2 * 2;\n                }\n                arg_10h = iVar5 + 3 + puVar4 & 0xfffffffc;\n                arg_8h_01 = puVar4 + iVar3 + 3 & 0xfffffffc;\n                if (bVar7) {\n                    iVar6 = *(arg_8h_00 + 4);\n                }\n                else {\n                    iVar6 = *(arg_8h_00 + 2);\n                }\n                if ((iVar3 != iVar5) && (iVar6 != 0)) {\n                    arg_ch_00 = (in_ECX[1] - arg_10h) + arg_8h_00;\n                    if (in_ECX[1] < arg_ch_00) goto code_r0x0044bdc1;\n                    fcn.004164bd(arg_8h_01, arg_ch_00, arg_10h, arg_ch_00);\n                }\n                *puVar4 = arg_ch;\n                iVar3 = iVar3 + iVar1 * -2;\n                fcn.004164bd(puVar4 + iVar1, iVar3, &var_44h, iVar3);\n                in_ECX[1] = in_ECX[1] + (arg_8h_01 - arg_10h);\n                (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n                in_ECX[2] = 0;\n            }\n        }\n    }\ncode_r0x0044bdc1:\n    fcn.0045843c(var_58h);\n    return;\n}\n",
        "token_count": 879
    },
    "0044bdd0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044bdd0(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *arg_8h_00;\n    uint unaff_EDI;\n    uint32_t uVar5;\n    uint var_44h;\n    int32_t lpvObject;\n    uint var_24h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    uVar5 = 10;\n    arg_8h_00 = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x0044be4e;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        arg_8h_00 = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        uVar5 = uVar5 & 0xffff;\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x0044be4e:\n    if (arg_8h == 0) {\n        arg_8h = uVar5;\n    }\n    fcn.0044bc7c(arg_8h_00, arg_8h);\n    fcn.0045843c(unaff_EDI);\n    return;\n}\n",
        "token_count": 477
    },
    "0044c34f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0044c34f(int32_t *arg_8h, int16_t *arg_ch, int32_t arg_10h)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint hModule;\n    \n    iVar3 = fcn.0044a2be(0x44c330);\n    if (iVar3 == 0) {\n        fcn.0041638e();\n    }\n    if (*(iVar3 + 8) == 0) {\n        fcn.0042052a();\n        iVar4 = fcn.0041ac5f();\n        if (iVar4 != 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0x480858);\n            pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5, \"GetUserDefaultUILanguage\");\n            if ((((((pcVar6 != NULL) && (uVar2 = (*pcVar6)(),  (uVar2 & 0x3ff) == 0x11)) &&\n                  (iVar7 = fcn.0044c2a5(),  iVar7 != 0)) &&\n                 (iVar7 = (*_sym.imp.KERNEL32.dll_FindResourceExA)(iVar4, 5, (-(arg_10h != 0) & 0xe) + 0x3ee, 0xfc11), \n                 iVar7 != 0)) ||\n                (iVar7 = (*_sym.imp.KERNEL32.dll_FindResourceA)(iVar4, (-(arg_10h != 0) & 0xe) + 0x3ee, 5),  iVar7 != 0)\n                ) && (iVar4 = (*_sym.imp.KERNEL32.dll_LoadResource)(iVar4, iVar7),  iVar4 != 0)) {\n                fcn.0044beb0(iVar4, arg_8h, arg_ch);\n            }\n        }\n        uVar5 = fcn.0041650d(*(*arg_8h + -0xc) + 1, 1);\n        iVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, uVar5);\n        *(iVar3 + 4) = iVar4;\n        if (iVar4 == 0) {\n            iVar4 = fcn.00416356();\n        }\n        fcn.0042a985(iVar4, *(*arg_8h + -0xc) + 1, *arg_8h);\n        *(iVar3 + 8) = *arg_ch;\n    }\n    fcn.00402830(*(iVar3 + 4));\n    iVar1 = *(iVar3 + 8);\n    *arg_ch = iVar1;\n    return iVar1 != -1;\n}\n",
        "token_count": 637
    },
    "0044c5ef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044c5ef(int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    \n    if (lpString == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar1 = iVar1 + 1;\n    arg_8h = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(iVar1);\n    if (arg_8h != 0) {\n        iVar1 = fcn.0045850c(arg_8h, iVar1, lpString, iVar1);\n        if (iVar1 == 0) {\n            return arg_8h;\n        }\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(arg_8h);\n    }\n    return 0;\n}\n",
        "token_count": 191
    },
    "0044ce50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044ce50(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x9c) == 0) {\n        return 0xffffffff;\n    }\n    uVar1 = fcn.0041ee41();\n    *(param_1 + 0x80) = uVar1;\n    uVar1 = sub.oledlg.dll_OleUIPasteSpecialA(param_1 + 0x78);\n    uVar1 = fcn.00457eab(uVar1);\n    fcn.0041ee7d();\n    return uVar1;\n}\n",
        "token_count": 139
    },
    "0044ce8e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044ce8e(int32_t param_1)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    \n    uVar2 = *(*(param_1 + 0xb8) * 0x24 + *(param_1 + 0xa0));\n    uVar1 = 4;\n    if ((*(param_1 + 0x7c) & 4) != 0) {\n        return 1;\n    }\n    if (((uVar2 == *0x49be00) || (uVar2 == *0x49bdfc)) || (uVar2 == *0x49be04)) {\n        uVar1 = 2;\n    }\n    else if (((uVar2 == 3) || (uVar2 == 8)) || (uVar2 == 2)) {\n        return 3;\n    }\n    return uVar1;\n}\n",
        "token_count": 201
    },
    "0044cf34": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044cf34(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t in_ECX;\n    ushort *puVar5;\n    uint arg_8h_00;\n    uint var_104h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_8h_00 = 0x100;\n    iVar1 = fcn.0041f5cb(arg_10h, &var_104h, 0x100);\n    if (iVar1 == 0) {\n        fcn.00416f76();\n    }\n    puVar2 = fcn.0045aaaf(&var_104h, 10);\n    if (puVar2 == NULL) {\n        fcn.0041638e();\n    }\n    *puVar2 = 0;\n    iVar1 = *(in_ECX + 0xa4);\n    if ((iVar1 <= iVar1 + 1U) && (iVar1 + 1U < 0x38e38e4)) {\n        iVar1 = fcn.0045cc11(*(in_ECX + 0xa0), (iVar1 + 1) * 0x24);\n        if (iVar1 != 0) goto code_r0x0044cfb9;\n    }\n    iVar1 = fcn.00416356();\ncode_r0x0044cfb9:\n    *(in_ECX + 0xa0) = iVar1;\n    puVar5 = *(in_ECX + 0xa4) * 0x24 + iVar1;\n    *(puVar5 + 2) = 0;\n    *(puVar5 + 6) = 0xffffffff;\n    *puVar5 = arg_8h;\n    *(puVar5 + 8) = arg_ch;\n    *(puVar5 + 4) = 1;\n    uVar3 = fcn.0045d650(&var_104h);\n    *(puVar5 + 10) = uVar3;\n    uVar3 = fcn.0045d650(puVar2 + 1);\n    *(puVar5 + 0xc) = uVar3;\n    *(puVar5 + 0xe) = 0x200;\n    if (arg_14h != 0) {\n        *(puVar5 + 0xe) = 0xa00;\n    }\n    if (arg_18h != 0) {\n        uVar4 = fcn.0044cedc(arg_8h);\n        *(puVar5 + 0xe) = *(puVar5 + 0xe) | uVar4;\n    }\n    if (*(puVar5 + 0xe) == 0x200) {\n        *(puVar5 + 0xe) = 0;\n    }\n    *(puVar5 + 0x10) = 0;\n    *(in_ECX + 0xa4) = *(in_ECX + 0xa4) + 1;\n    fcn.0045843c(arg_8h_00);\n    return;\n}\n",
        "token_count": 735
    },
    "0044d827": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0044d827(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    char *arg_8h_00;\n    char *pcVar5;\n    uint var_124h;\n    uint var_120h;\n    uint lpszItem;\n    uint ppmk;\n    uint var_114h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x118);\n    iVar4 = *(unaff_EBP + 0xc);\n    piVar2 = *(unaff_EBP + 8);\n    arg_8h_00 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x124) = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x118) = *(unaff_EBP + 0x18);\n    if (iVar4 == 0) {\n        iVar4 = 0;\n        cVar1 = *arg_8h_00;\n        while ((cVar1 != '\\0' &&\n               ((((cVar1 = *arg_8h_00,  cVar1 == '\\\\' || (cVar1 == '/')) || (cVar1 == ':')) ||\n                ((cVar1 == '!' || (cVar1 == '['))))))) {\n            iVar3 = fcn.0045cede(cVar1);\n            if (iVar3 != 0) {\n                arg_8h_00 = arg_8h_00 + 1;\n                iVar4 = iVar4 + 1;\n            }\n            arg_8h_00 = arg_8h_00 + 1;\n            iVar4 = iVar4 + 1;\n            cVar1 = *arg_8h_00;\n        }\n        pcVar5 = unaff_EBP + -0x114;\n        for (; (((cVar1 = *arg_8h_00,  cVar1 != '\\0' && (cVar1 != '\\\\')) &&\n                ((cVar1 != '/' && (((cVar1 != ':' && (cVar1 != '!')) && (cVar1 != '[')))))) && (iVar4 < 0x103));\n            iVar4 = iVar4 + 1) {\n            iVar3 = fcn.0045cede(cVar1);\n            if (iVar3 != 0) {\n                *pcVar5 = *arg_8h_00;\n                pcVar5 = pcVar5 + 1;\n                arg_8h_00 = arg_8h_00 + 1;\n                iVar4 = iVar4 + 1;\n            }\n            *pcVar5 = *arg_8h_00;\n            pcVar5 = pcVar5 + 1;\n            arg_8h_00 = arg_8h_00 + 1;\n        }\n        **(unaff_EBP + -0x124) = iVar4;\n        fcn.00416242(unaff_EBP + -0x114);\n        (*_sym.imp.ole32.dll_CreateItemMoniker)(0x47c544, *(unaff_EBP + -0x11c), *(unaff_EBP + -0x118));\n    }\n    else {\n        fcn.00416242(arg_8h_00);\n        iVar3 = *piVar2;\n        *(unaff_EBP + -4) = 0;\n        (**(iVar3 + 0x54))(piVar2, iVar4, 0, *(unaff_EBP + -0x120), *(unaff_EBP + -0x124), *(unaff_EBP + -0x118));\n    }\n    fcn.004010f0();\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 875
    },
    "0044dcda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044dcda(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x30) == 0) {\n        uVar1 = fcn.0041ac5f(\"FindTextA\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x30) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x30);\n    return;\n}\n",
        "token_count": 128
    },
    "0044dd7e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0044dd7e(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "0044ddb4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044ddb4(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x38) == 0) {\n        uVar1 = fcn.0041ac5f(\"ReplaceTextA\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x38) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x38);\n    return;\n}\n",
        "token_count": 128
    },
    "0044de58": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0044de58(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "0044df94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044df94(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x40) == 0) {\n        uVar1 = fcn.0041ac5f(\"ChooseFontA\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x40) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x40);\n    return;\n}\n",
        "token_count": 128
    },
    "0044e038": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0044e038(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "0044e81c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0044e81c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *arg_8h_00;\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x40);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 != NULL) {\n        fcn.0044e7aa(unaff_EBP + -0x14, 1, *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x44) = 0;\n        *(unaff_EBP + -0x10) = 0;\n        *(unaff_EBP + -0x14) = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x48) = *(unaff_EBP + 0x10);\n        if (((*(unaff_EBP + 0x14) != 3) && (iVar1 = fcn.0044e6d4(arg_8h_00, 1),  iVar1 != 0)) &&\n           ((*(unaff_EBP + -0x10) & 2) != 0)) {\n            (**(*arg_8h_00 + 0xc))(*(unaff_EBP + -0x48), 0, 0, 0);\n        }\n        *(unaff_EBP + -0x4c) = vtable.COleCmdUI.0;\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 502
    },
    "0044e9f2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044e9f2(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    pcVar1 = _sym.imp.USER32.dll_LoadCursorA;\n    var_8h = param_1;\n    piStack8 = param_1;\n    if ((*0x49be84 == 0) && (*0x49be84 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f8b),  *0x49be84 == 0)) {\n        iVar2 = fcn.0042052a();\n        *0x49be84 = (*pcVar1)(*(iVar2 + 0xc), 0x7901);\n        if (*0x49be84 == 0) {\n            return;\n        }\n    }\n    (**(*param_1 + 0xc))(0xe145, 0, 0, &var_8h);\n    return;\n}\n",
        "token_count": 233
    },
    "0044ea4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044ea4f(int32_t pszPath, int32_t arg_ch, uint arg_10h)\n\n{\n    uint arg_10h_00;\n    int32_t iVar1;\n    \n    if (pszPath == 0) {\n        fcn.0041638e();\n    }\n    arg_10h_00 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameA)(pszPath);\n    if (arg_ch == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_10h_00);\n        iVar1 = iVar1 + 1;\n    }\n    else {\n        fcn.0041502b(arg_ch, arg_10h, arg_10h_00, 0xffffffff);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 186
    },
    "0044ea8f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044ea8f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *arg_8h;\n    uint uVar3;\n    uint *arg_8h_00;\n    char *arg_10h;\n    uint *arg_8h_01;\n    uint var_310h;\n    uint var_30ch;\n    uint var_20ch;\n    uint lpFilename;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    iVar1 = fcn.0042052a();\n    *(iVar1 + 8) = *(param_1 + 0x44);\n    *(iVar1 + 0xc) = *(param_1 + 0x44);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x44), &lpFilename, 0x104);\n    if ((iVar2 == 0) || (iVar2 == 0x104)) {\n        fcn.00416f92();\n    }\n    arg_8h_01 = &lpFilename;\n    arg_8h = (*_sym.imp.SHLWAPI.dll_PathFindExtensionA)();\n    if (arg_8h == NULL) {\n        fcn.00416f92();\n    }\n    *arg_8h = 0;\n    iVar2 = fcn.0044ea4f(&lpFilename, &var_20ch, 0x104);\n    if (iVar2 != 0) {\n        fcn.00416f92();\n    }\n    if (*(param_1 + 0x60) != 0) goto code_r0x0044eb40;\n    iVar2 = fcn.0045d650(&var_20ch);\n    *(param_1 + 0x60) = iVar2;\n    if (iVar2 != 0) goto code_r0x0044eb40;\ncode_r0x0044eb3b:\n    do {\n        fcn.00416356();\ncode_r0x0044eb40:\n        iVar2 = *(param_1 + 0x50);\n        if (iVar2 == 0) {\n            iVar2 = fcn.0041f5cb(0xe000, &var_30ch, 0x100);\n            if (iVar2 == 0) {\n                arg_8h_00 = *(param_1 + 0x60);\n            }\n            else {\n                arg_8h_00 = &var_30ch;\n            }\n            iVar2 = fcn.0045d650(arg_8h_00);\n            *(param_1 + 0x50) = iVar2;\n            if (iVar2 == 0) goto code_r0x0044eb3b;\n        }\n        *(iVar1 + 0x10) = iVar2;\n        if (*(param_1 + 100) == 0) {\n            if (*(param_1 + 0x6c) == 1) {\n                arg_10h = \".CHM\";\n            }\n            else {\n                arg_10h = \".HLP\";\n            }\n            fcn.0042a985(arg_8h, &var_4h - arg_8h, arg_10h);\n            iVar2 = fcn.0045d650(&lpFilename);\n            *(param_1 + 100) = iVar2;\n            if (iVar2 == 0) goto code_r0x0044eb3b;\n            *arg_8h = 0;\n        }\n        if (*(param_1 + 0x68) != 0) goto code_r0x0044ec06;\n        uVar3 = fcn.004594f3(&var_20ch, 0x104, \".INI\");\n        fcn.00409e60(uVar3);\n        iVar2 = fcn.0045d650(&var_20ch);\n        *(param_1 + 0x68) = iVar2;\n        if (iVar2 != 0) {\ncode_r0x0044ec06:\n            fcn.0045843c(arg_8h_01);\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 930
    },
    "0044ec15": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044ec15(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.0042052a();\n    *(iVar3 + 8) = arg_8h;\n    *(iVar3 + 0xc) = arg_8h;\n    fcn.0041fca8();\n    iVar3 = fcn.0042052a();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x48) = arg_10h;\n        *(iVar3 + 0x4c) = arg_14h;\n        *(iVar3 + 0x44) = arg_8h;\n        fcn.0044ea8f();\n    }\n    iVar3 = fcn.0042052a();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.004380f0();\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"user32.dll\");\n    if (iVar3 != 0) {\n        *0x49bbf4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"NotifyWinEvent\");\n    }\n    return 1;\n}\n",
        "token_count": 361
    },
    "0044ef85": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.0044ef85(uint arg_8h)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t *extraout_ECX;\n    uint32_t uVar7;\n    int32_t unaff_EBP;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint *puVar10;\n    uint lParam;\n    uint var_84h;\n    uint var_58h;\n    uint var_54h;\n    uint var_38h;\n    uint var_34h;\n    uint lpPoint;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uint uVar11;\n    \n    uVar11 = 0x7c;\n    fcn.0045af3b();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    puVar9 = *(unaff_EBP + 8);\n    uVar7 = puVar9[1];\n    *(unaff_EBP + -0x1c) = uVar7;\n    pcVar2 = _sym.imp.USER32.dll_GetKeyState;\n    if ((((uVar7 == 0x200) || (uVar7 == 0xa0)) || (uVar7 == 0x202)) || ((uVar7 == 0x205 || (uVar7 == 0x208)))) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if ((-1 < iVar3) && ((iVar3 = (*pcVar2)(2),  -1 < iVar3 && (iVar3 = (*pcVar2)(4),  -1 < iVar3)))) {\n            iVar4 = fcn.0042055d();\n            uVar11 = *puVar9;\n            *(unaff_EBP + -0x18) = iVar4;\n            while ((piVar5 = fcn.0041af14(uVar11),  piVar5 != NULL && ((piVar5[0xf] & 0x401U) == 0))) {\n                uVar11 = (*_sym.imp.USER32.dll_GetParent)(piVar5[8]);\n            }\n            if (piVar5 != extraout_ECX) {\n                if (piVar5 == NULL) {\n                    *(iVar4 + 0x40) = 0;\n                    *(iVar4 + 0x44) = 0xffffffff;\n                }\n                goto code_r0x0044f398;\n            }\n            piVar5 = *(iVar4 + 0x3c);\n            uVar11 = fcn.0041b21a();\n            *(unaff_EBP + -0x14) = uVar11;\n            if (piVar5 == NULL) {\ncode_r0x0044f070:\n                iVar6 = fcn.00414af6(0x70);\n                *(unaff_EBP + -0x1c) = iVar6;\n                piVar5 = NULL;\n                *(unaff_EBP + -4) = 0;\n                if (iVar6 != 0) {\n                    piVar5 = fcn.0044ec9c();\n                }\n                iVar6 = *piVar5;\n                *(unaff_EBP + -4) = 0xffffffff;\n                iVar6 = (**(iVar6 + 0x13c))(*(unaff_EBP + -0x14), 1);\n                if (iVar6 == 0) {\n                    (**(*piVar5 + 4))(1);\n                    goto code_r0x0044f398;\n                }\n                (*_sym.imp.USER32.dll_SendMessageA)(piVar5[8], 0x401, 0, 0);\n                piVar8 = *(unaff_EBP + -0x10);\n                *(iVar4 + 0x3c) = piVar5;\n            }\n            else {\n                iVar6 = fcn.00405790();\n                if (iVar6 != *(unaff_EBP + -0x14)) {\n                    (**(*piVar5 + 0x60))();\n                    (**(*piVar5 + 4))(1);\n                    piVar5 = NULL;\n                    *(iVar4 + 0x3c) = 0;\n                }\n                piVar8 = extraout_ECX;\n                if (piVar5 == NULL) goto code_r0x0044f070;\n            }\n            fcn.00458b20(unaff_EBP + -0x88, 0, 0x30);\n            uVar11 = *(*(unaff_EBP + 8) + 0x14);\n            *(unaff_EBP + -0x24) = *(*(unaff_EBP + 8) + 0x18);\n            iVar6 = piVar8[8];\n            *(unaff_EBP + -0x28) = uVar11;\n            (*_sym.imp.USER32.dll_ScreenToClient)(iVar6, unaff_EBP + -0x28);\n            fcn.00458b20(unaff_EBP + -0x58, 0, 0x30);\n            iVar6 = *piVar8;\n            *(unaff_EBP + -0x58) = 0x2c;\n            iVar6 = (**(iVar6 + 0x74))(*(unaff_EBP + -0x28), *(unaff_EBP + -0x24), unaff_EBP + -0x58);\n            uVar7 = -(iVar6 != -1) & piVar8;\n            *(unaff_EBP + -0x1c) = iVar6;\n            *(unaff_EBP + -0x14) = uVar7;\n            if ((*(iVar4 + 0x44) == iVar6) && (*(iVar4 + 0x40) == uVar7)) {\n                if ((piVar8[0xf] & 0x400U) == 0) {\n                    if (iVar6 != -1) {\n                        fcn.0044ef05(piVar5, *(unaff_EBP + 8));\n                    }\n                }\n                else {\n                    (*_sym.imp.USER32.dll_GetCursorPos)(unaff_EBP + -0x20);\n                    (*_sym.imp.USER32.dll_SendMessageA)\n                              (piVar5[8], 0x412, 0, CONCAT22(*(unaff_EBP + -0x1c), *(unaff_EBP + -0x20)));\n                }\n            }\n            else {\n                if (iVar6 == -1) {\n                    (*_sym.imp.USER32.dll_SendMessageA)(piVar5[8], 0x401, 0, 0);\n                }\n                else {\n                    uVar7 = *(unaff_EBP + -0x54);\n                    puVar9 = unaff_EBP + -0x58;\n                    puVar10 = unaff_EBP + -0x88;\n                    for (iVar4 = 0xc; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar10 = *puVar9;\n                        puVar9 = puVar9 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    uVar7 = uVar7 & 0x3fffffff;\n                    *(unaff_EBP + -0x84) = uVar7;\n                    if ((*(*(unaff_EBP + -0x10) + 0x3c) & 0x400) != 0) {\n                        *(unaff_EBP + -0x84) = uVar7 | 0x20;\n                    }\n                    (*_sym.imp.USER32.dll_SendMessageA)(piVar5[8], 0x404, 0, unaff_EBP + -0x88);\n                    if (((*(unaff_EBP + -0x54) & 0x40000000) != 0) || (iVar4 = fcn.0041d6f0(),  iVar4 != 0)) {\n                        (*_sym.imp.USER32.dll_SendMessageA)(piVar5[8], 0x401, 1);\n                        if ((*(*(unaff_EBP + -0x10) + 0x3c) & 0x400) != 0) {\n                            (*_sym.imp.USER32.dll_SendMessageA)(piVar5[8], 0x411, 1, unaff_EBP + -0x88);\n                        }\n                        (*_sym.imp.USER32.dll_SetWindowPos)(piVar5[8], 0, 0, 0, 0, 0, 0x213);\n                    }\n                    iVar4 = *(unaff_EBP + -0x18);\n                }\n                fcn.0044ef05(piVar5, *(unaff_EBP + 8));\n                puVar1 = *(iVar4 + 0x48);\n                if ((puVar1 != NULL) && (0x2b < *puVar1)) {\n                    (*_sym.imp.USER32.dll_SendMessageA)(piVar5[8], 0x405, 0, puVar1);\n                }\n                *(iVar4 + 0x40) = *(unaff_EBP + -0x14);\n                *(iVar4 + 0x44) = *(unaff_EBP + -0x1c);\n                if (*(iVar4 + 0x48) == 0) {\n                    uVar11 = fcn.00414af6(0x30);\n                    *(iVar4 + 0x48) = uVar11;\n                    fcn.00458b20(uVar11, 0, 0x30);\n                }\n                puVar9 = unaff_EBP + -0x58;\n                puVar10 = *(iVar4 + 0x48);\n                for (iVar6 = 0xc; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar10 = *puVar9;\n                    puVar9 = puVar9 + 1;\n                    puVar10 = puVar10 + 1;\n                }\n            }\n            if ((*(unaff_EBP + -0x34) != -1) && (*(unaff_EBP + -0x38) == 0)) {\n                fcn.004585e6(*(unaff_EBP + -0x34));\n            }\n            goto code_r0x0044f398;\n        }\n        uVar7 = *(unaff_EBP + -0x1c);\n    }\n    if ((extraout_ECX[0xf] & 0x401U) != 0) {\n        while (piVar5 = fcn.0041af14(uVar11),  piVar5 != NULL) {\n            if (piVar5 == extraout_ECX) goto code_r0x0044f303;\n            if ((piVar5[0xf] & 0x401U) != 0) break;\n            uVar11 = (*_sym.imp.USER32.dll_GetParent)(piVar5[8]);\n        }\n        if (piVar5 == extraout_ECX) {\ncode_r0x0044f303:\n            if (((uVar7 < 0x100) || (0x109 < uVar7)) && (3 < uVar7 - 0x104)) {\n                iVar4 = 0;\n            }\n            else {\n                iVar4 = 1;\n            }\n            if (((extraout_ECX[0xf] & 0x400U) == 0) &&\n               (((((iVar4 != 0 || (uVar7 == 0x201)) || ((uVar7 == 0x203 || ((uVar7 == 0x204 || (uVar7 == 0x206)))))) ||\n                 (uVar7 == 0x207)) ||\n                (((((uVar7 == 0x209 || (uVar7 == 0xa1)) || (uVar7 == 0xa3)) || ((uVar7 == 0xa4 || (uVar7 == 0xa6)))) ||\n                 ((uVar7 == 0xa7 || (uVar7 == 0xa9)))))))) {\n                fcn.00419a9d(iVar4);\n            }\n        }\n    }\ncode_r0x0044f398:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 2845
    },
    "0044f3ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044f3ba(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    \n    iVar1 = fcn.0042055d();\n    iVar2 = *(iVar1 + 0x3c);\n    if (arg_8h == 0) {\n        if ((*(in_ECX + 0x3c) & arg_ch) != 0) {\n            if (*(iVar1 + 0x40) == in_ECX) {\n                fcn.00419a9d(1);\n            }\n            if ((iVar2 != 0) && (*(iVar2 + 0x20) != 0)) {\n                fcn.00458b20(&var_30h, 0, 0x30);\n                var_28h = *(in_ECX + 0x20);\n                var_30h = 0x2c;\n                var_2ch = 1;\n                var_24h = var_28h;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x20), 0x405, 0, &var_30h);\n            }\n            *(in_ECX + 0x3c) = *(in_ECX + 0x3c) & ~arg_ch;\n        }\n    }\n    else if ((*(in_ECX + 0x3c) & arg_ch) == 0) {\n        iVar2 = fcn.0042052a();\n        *(iVar2 + 0x38) = fcn.0044f3a6;\n        *(in_ECX + 0x3c) = *(in_ECX + 0x3c) | arg_ch;\n    }\n    return 1;\n}\n",
        "token_count": 427
    },
    "0044f76b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044f76b(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint arg_8h;\n    uint lpvBits;\n    int16_t aiStack16 [4];\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_8h = 5;\n    fcn.0044b9be(5);\n    if (*0x49c168 == 0) {\n        if (*0x49c158 == 0) {\n            iVar3 = 0x1111;\n            iVar4 = 0;\n            do {\n                *(&lpvBits + iVar4 * 2) = iVar3;\n                aiStack16[iVar4] = iVar3;\n                iVar3 = iVar3 * 2;\n                iVar4 = iVar4 + 1;\n            } while (iVar4 < 4);\n            iVar4 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, &lpvBits);\n            if (iVar4 == 0) {\n                fcn.0044ba30(5);\n                fcn.00416f76();\n            }\n            *0x49c158 = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar4);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar4);\n            if (*0x49c158 == 0) {\n                fcn.0044ba30(5);\n                fcn.00416f76();\n            }\n        }\n        if (*0x49c15c == 0) {\n            *0x49c15c = (*_sym.imp.GDI32.dll_CreatePen)(2, 0, 0);\n            if (*0x49c15c == 0) {\n                fcn.0044ba30(5);\n                fcn.00416f76();\n            }\n        }\n        iVar4 = fcn.0042052a();\n        pcVar2 = _sym.imp.USER32.dll_LoadCursorA;\n        uVar1 = *(iVar4 + 0xc);\n        *0x49c130 = (*_sym.imp.USER32.dll_LoadCursorA)(uVar1, 0x7907);\n        *0x49c134 = (*pcVar2)(uVar1, 0x7908);\n        *0x49c138 = *0x49c130;\n        *0x49c13c = *0x49c134;\n        *0x49c140 = (*pcVar2)(uVar1, 0x7909);\n        *0x49c144 = (*pcVar2)(uVar1, 0x790a);\n        *0x49c148 = *0x49c140;\n        *0x49c14c = *0x49c144;\n        *0x49c150 = (*pcVar2)(uVar1, 0x790b);\n        *0x49c154 = (*pcVar2)(uVar1, 0x790c);\n        *0x49c160 = (*_sym.imp.KERNEL32.dll_GetProfileIntA)(\"windows\", \"oleinplaceborderwidth\", 4);\n        *0x49c168 = 1;\n    }\n    if (*0x49c164 == '\\0') {\n        iVar4 = fcn.0045a9dc(0x44f6f2);\n        *0x49c164 = '\\x01' - (iVar4 != 0);\n    }\n    fcn.0044ba30(5);\n    *(param_1 + 4) = 0;\n    iVar4 = *0x49c160;\n    *(param_1 + 0x20) = *0x49c160;\n    *(param_1 + 0x18) = iVar4 * 2;\n    *(param_1 + 0x1c) = iVar4 * 2;\n    (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0x28);\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x38) = 0;\n    *(param_1 + 0x40) = 0;\n    *(param_1 + 0x44) = 0;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 981
    },
    "0044fda5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044fda5(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    int32_t *piVar4;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t lprc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    piVar1 = arg_8h;\n    var_8h = in_ECX;\n    (**(*arg_8h + 0x1c))();\n    (**(*arg_8h + 0x34))(1);\n    (**(*arg_8h + 0x38))(&var_10h, 0, 0);\n    fcn.00417154(&var_10h, 0, 0);\n    lprc = in_ECX[2];\n    var_1ch = in_ECX[3];\n    var_18h = in_ECX[4];\n    var_14h = in_ECX[5];\n    fcn.0044f70e();\n    piVar4 = var_8h;\n    var_4h = 0;\n    arg_8h = NULL;\n    if ((var_8h[1] & 3U) != 0) {\n        if ((var_8h[1] & 2U) == 0) {\n            var_4h = (**(*piVar1 + 0x24))(7);\n        }\n        else {\n            uVar2 = fcn.0041776c(*0x49c15c);\n            var_4h = fcn.004178bb(uVar2);\n        }\n        arg_8h = (**(*piVar1 + 0x24))(5);\n        uVar2 = fcn.00416c8c(0xd);\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 1, 1);\n        fcn.0040db10(lprc, var_1ch, var_18h, var_14h);\n        fcn.00416c8c(uVar2);\n    }\n    if ((*(piVar4 + 1) & 0x24) != 0) {\n        (*_sym.imp.GDI32.dll_UnrealizeObject)(*0x49c158);\n    }\n    if ((*(piVar4 + 1) & 0x20) != 0) {\n        iVar3 = (**(*piVar1 + 0x24))(8);\n        if (var_4h == 0) {\n            var_4h = iVar3;\n        }\n        uVar2 = fcn.0041776c(*0x49c158);\n        iVar3 = fcn.004178bb(uVar2);\n        if (arg_8h == NULL) {\n            arg_8h = iVar3;\n        }\n        fcn.00416c28(1);\n        uVar2 = fcn.00416c8c(3);\n        fcn.0040db10(lprc + 1, var_1ch + 1, var_18h, var_14h);\n        fcn.00416c8c(uVar2);\n    }\n    if ((*(piVar4 + 1) & 4) != 0) {\n        uVar2 = fcn.0041776c(*0x49c158);\n        iVar3 = fcn.004178bb(uVar2);\n        if (arg_8h == NULL) {\n            arg_8h = iVar3;\n        }\n        fcn.00416c28(2);\n        fcn.0044fa5e(&var_30h);\n        var_ch = var_28h - var_30h;\n        fcn.00447c89(var_30h, var_2ch, var_ch, var_1ch - var_2ch, 0xf0001);\n        fcn.00447c89(var_30h, var_14h, var_ch, var_24h - var_14h, 0xf0001);\n        fcn.00447c89(var_30h, var_1ch, lprc - var_30h, var_14h - var_1ch, 0xf0001);\n        fcn.00447c89(var_18h, var_1ch, var_28h - var_18h, var_14h - var_1ch, 0xf0001);\n        piVar4 = var_8h;\n    }\n    if ((*(piVar4 + 1) & 0x18) != 0) {\n        var_ch = (**(*piVar4 + 0xc))();\n        iVar3 = 0;\n        do {\n            if ((var_ch & 1 << (iVar3 & 0x1f)) != 0) {\n                fcn.0044fab2(iVar3, &lprc);\n                fcn.0044b272(&lprc, 0);\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 8);\n    }\n    if (var_4h != 0) {\n        fcn.004178bb(var_4h);\n    }\n    if (arg_8h != NULL) {\n        fcn.004178bb(arg_8h);\n    }\n    (**(*piVar1 + 0x20))(0xffffffff);\n    return;\n}\n",
        "token_count": 1270
    },
    "00450005": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00450005(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    int32_t lpPoint;\n    int32_t var_4h;\n    \n    if (arg_ch != 1) {\n        return 0;\n    }\n    lpPoint = in_ECX;\n    var_4h = in_ECX;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&lpPoint);\n    (*_sym.imp.USER32.dll_ScreenToClient)(*(arg_8h + 0x20), &lpPoint);\n    iVar1 = fcn.0044fbe5(lpPoint, var_4h);\n    if (iVar1 < 0) {\n        return 0;\n    }\n    uVar2 = fcn.0044f929(iVar1);\n    if (uVar2 == 8) {\n        iVar1 = fcn.004091e0(lpPoint, var_4h);\n        if ((iVar1 != 0) || ((*(in_ECX + 4) & 4) == 0)) goto code_r0x00450079;\n        uVar2 = 9;\n    }\n    if (9 < uVar2) {\n        fcn.0041638e();\n    }\ncode_r0x00450079:\n    (*_sym.imp.USER32.dll_SetCursor)(*(uVar2 * 4 + 0x49c130));\n    return 1;\n}\n",
        "token_count": 333
    },
    "00450592": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00450592(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x1c) == 0) {\n        uVar1 = fcn.0041ac5f(\"ImageList_Destroy\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x1c) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 130
    },
    "00450636": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00450636(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.0041fc5e(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "00450687": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00450687(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    iVar1 = fcn.0042055d();\n    if ((*(iVar1 + 0x24) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00414adf(fcn.0044b07c);\n        iVar2 = fcn.00414af6(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.0044ac7b(0x48175c, fcn.00450578, fcn.00416fae, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x24) = uVar3;\n        fcn.00414adf(arg_8h_00);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 326
    },
    "00450727": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00450727(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.004506fb();\n    uVar1 = fcn.0045066c(uVar1);\n    return uVar1;\n}\n",
        "token_count": 82
    },
    "00450aa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00450aa0(uint noname_0, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.00418009();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x20), &var_14h);\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n    iVar4 = (*pcVar1)(0x20);\n    iVar5 = fcn.0041ae6e();\n    if ((var_4h & 0x1000) != 0) {\n        if (iVar5 == 3) {\n            iVar5 = 2;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(2);\n        if (iVar2 < 0) {\n            return 0;\n        }\n    }\n    if (((9 < iVar5) && (iVar5 < 0x12)) || (iVar5 == 4)) {\n        if ((var_4h & 0x800) == 0) {\n            (*_sym.imp.USER32.dll_InflateRect)(&var_14h, -iVar4, -iVar3);\n            if ((var_4h & 0x200) != 0) {\n                if (iVar5 != 4) {\n                    if (iVar5 == 0xd) {\n                        return (arg_ch < var_10h) * 2 + 10;\n                    }\n                    if (iVar5 == 0xe) {\n                        return (arg_ch < var_10h) + 0xb;\n                    }\n                    if (iVar5 == 0x10) {\n                        return ((arg_ch <= var_8h) - 1 & 5) + 10;\n                    }\n                    if (iVar5 != 0x11) {\n                        return iVar5;\n                    }\n                }\n                iVar5 = (var_8h < arg_ch) * 4 + 0xb;\n            }\n        }\n        else {\n            iVar5 = 2;\n        }\n    }\n    return iVar5;\n}\n",
        "token_count": 540
    },
    "00450da5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00450da5(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint var_4h;\n    \n    uVar1 = 0;\n    uVar2 = *(param_1 + 0x78) & 0xa000;\n    if (*(param_1 + 0x7c) != 0) {\n        uVar2 = uVar2 == 0;\n    }\n    if ((uVar2 == 0) || ((*(param_1 + 0x70) & 0xa000) == 0)) {\n        if ((*(param_1 + 0x70) & 0x5000) == 0) goto code_r0x00450e07;\n        uVar1 = *(param_1 + 0x70) & 0xffff5fff;\n        puVar3 = param_1 + 0x38;\n    }\n    else {\n        uVar1 = *(param_1 + 0x70) & 0xffffafff;\n        puVar3 = param_1 + 0x28;\n    }\n    uVar1 = fcn.004355cb(*puVar3, puVar3[1], puVar3[2], puVar3[3], uVar1, 0);\ncode_r0x00450e07:\n    if ((*(param_1 + 0x7c) == 0) && (uVar1 == 0)) {\n        if ((*(param_1 + 0x70) & 0xa000) != 0) {\n            uVar2 = fcn.004355cb(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), \n                                 *(param_1 + 0x70) & 0xffffafff, 0);\n            uVar1 = fcn.004355cb(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), \n                                 *(param_1 + 0x70) & 0xffffafff, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n            if (uVar1 != 0) {\n                return uVar1;\n            }\n        }\n        if ((*(param_1 + 0x70) & 0x5000) != 0) {\n            uVar2 = fcn.004355cb(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), \n                                 *(param_1 + 0x70) & 0xffff5fff, 0);\n            uVar1 = fcn.004355cb(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), \n                                 *(param_1 + 0x70) & 0xffff5fff, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 754
    },
    "00451176": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451176(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_24h;\n    int32_t in_ECX;\n    uint *puVar3;\n    uint lprc;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 1;\n    var_10h = 1;\n    uVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0);\n    var_8h = fcn.0041776c(uVar2);\n    var_ch = var_8h;\n    var_4h = fcn.0044b3b2();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if ((*(in_ECX + 0x74) & 0xa000) == 0) {\n        if ((*(in_ECX + 0x74) & 0x5000) == 0) {\n            var_14h = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x20);\n            var_14h = var_14h + -1;\n            var_10h = (*pcVar1)(0x21);\n            var_10h = var_10h + -1;\n            if ((((*(in_ECX + 0x78) & 0xa000) == 0) || (*(in_ECX + 0x7c) != 0)) &&\n               (((*(in_ECX + 0x78) & 0x5000) == 0 || (*(in_ECX + 0x7c) == 0)))) {\n                puVar3 = in_ECX + 0x58;\n            }\n            else {\n                puVar3 = in_ECX + 0x48;\n            }\n            var_8h = var_4h;\n        }\n        else {\n            puVar3 = in_ECX + 0x38;\n        }\n    }\n    else {\n        puVar3 = in_ECX + 0x28;\n    }\n    lprc = *puVar3;\n    uStack36 = puVar3[1];\n    uStack32 = puVar3[2];\n    uStack28 = puVar3[3];\n    if (arg_8h != 0) {\n        var_10h = 0;\n        var_14h = 0;\n    }\n    if ((*(in_ECX + 0x74) & 0xf000) != 0) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 0xffffffff, 0xffffffff);\n    }\n    arg_24h = var_4h;\n    if (*(in_ECX + 0x24) == 0) {\n        arg_24h = var_ch;\n    }\n    fcn.0044b51c(&lprc, var_14h, var_10h, in_ECX + 0xc, *(in_ECX + 0x1c), *(in_ECX + 0x20), var_8h, arg_24h);\n    *(in_ECX + 0xc) = lprc;\n    *(in_ECX + 0x1c) = var_14h;\n    *(in_ECX + 0x10) = uStack36;\n    *(in_ECX + 0x20) = var_10h;\n    *(in_ECX + 0x14) = uStack32;\n    *(in_ECX + 0x18) = uStack28;\n    *(in_ECX + 0x24) = var_8h == var_4h;\n    return;\n}\n",
        "token_count": 850
    },
    "00451286": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451286(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*arg_8h != arg_ch) {\n        *arg_8h = arg_ch;\n        if ((((*(in_ECX + 0x70) & 0xa000) == 0) || ((*(in_ECX + 0x70) & 0x5000) == 0)) || (*(in_ECX + 0x7c) == 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        *(in_ECX + 0x7c) = uVar1;\n        if (*(in_ECX + 0x80) == 0) {\n            uVar1 = fcn.00450da5();\n        }\n        else {\n            uVar1 = 0;\n        }\n        *(in_ECX + 0x74) = uVar1;\n        fcn.00451176(0);\n    }\n    return;\n}\n",
        "token_count": 243
    },
    "004512e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004512e0(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    int32_t dy;\n    int32_t dx;\n    \n    dy = arg_ch - *(in_ECX + 8);\n    dx = arg_8h - *(in_ECX + 4);\n    fcn.00431038(dx, dy);\n    fcn.00431038(dx, dy);\n    fcn.00431038(dx, dy);\n    fcn.00431038(dx, dy);\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    if (*(in_ECX + 0x80) == 0) {\n        uVar1 = fcn.00450da5();\n    }\n    else {\n        uVar1 = 0;\n    }\n    *(in_ECX + 0x74) = uVar1;\n    fcn.00451176(0);\n    return;\n}\n",
        "token_count": 230
    },
    "00451544": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00451544(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint arg_10h;\n    uint *puVar3;\n    uint arg_ch;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    fcn.00451501();\n    if (*(param_1 + 0x74) == 0) {\n        uVar2 = *(param_1 + 0x78);\n        if ((((uVar2 & 4) == 0) && (((uVar2 & 0xa000) == 0 || (*(param_1 + 0x7c) != 0)))) &&\n           (((uVar2 & 0x5000) == 0 || (*(param_1 + 0x7c) == 0)))) {\n            uVar2 = *(param_1 + 0x70) & 0x40 | 0x1000;\n            *(param_1 + 0xa8) = *(param_1 + 0x58);\n            arg_10h = *(param_1 + 0x5c);\n            arg_ch = *(param_1 + 0x58);\n        }\n        else {\n            uVar2 = *(param_1 + 0x70) & 0x40 | 0x2000;\n            *(param_1 + 0xa8) = *(param_1 + 0x48);\n            arg_10h = *(param_1 + 0x4c);\n            arg_ch = *(param_1 + 0x48);\n        }\n        *(param_1 + 0xac) = arg_10h;\n        *(param_1 + 0xa4) = uVar2;\n        fcn.00435497(*(param_1 + 0x68), arg_ch, arg_10h, uVar2);\n    }\n    else {\n        var_4h = fcn.00450ecd(*(param_1 + 0x74));\n        puVar3 = param_1 + 0x38;\n        if ((*(param_1 + 0x74) & 0x5000) == 0) {\n            puVar3 = param_1 + 0x28;\n        }\n        var_14h = *puVar3;\n        uStack20 = puVar3[1];\n        uStack16 = puVar3[2];\n        uStack12 = puVar3[3];\n        iVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(var_4h + 0x20));\n        if (iVar1 - 0xe81bU < 4) {\n            *(param_1 + 0x90) = iVar1;\n            *(param_1 + 0x94) = var_14h;\n            *(param_1 + 0x98) = uStack20;\n            *(param_1 + 0x9c) = uStack16;\n            *(param_1 + 0xa0) = uStack12;\n            fcn.004172a1(param_1 + 0x94);\n        }\n        fcn.004352e7(*(param_1 + 0x68), var_4h, &var_14h);\n        (**(**(param_1 + 0x6c) + 0x150))(1);\n    }\n    return;\n}\n",
        "token_count": 759
    },
    "00451e9d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00451e9d(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CMetaFileDC.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != NULL) {\n        uVar1 = fcn.004174e4();\n        uVar1 = (*_sym.imp.GDI32.dll_CloseMetaFile)(uVar1);\n        (*_sym.imp.GDI32.dll_DeleteMetaFile)(uVar1);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041752d();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 231
    },
    "00451ee2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451ee2(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t var_8h;\n    int32_t Y;\n    \n    if (*(in_ECX + 8) != 0) {\n        var_8h = in_ECX;\n        Y = in_ECX;\n        uVar1 = (*_sym.imp.GDI32.dll_GetTextAlign)(*(in_ECX + 8));\n        if ((uVar1 & 6) != 6) {\n            if ((uVar1 & 6) == 2) {\n                arg_8h = -arg_8h;\n            }\n            fcn.00451e77(&var_8h);\n            (*_sym.imp.GDI32.dll_MoveToEx)(*(in_ECX + 8), var_8h + arg_8h, Y, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 211
    },
    "0045241d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045241d(char *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    char *arg_8h_00;\n    int32_t iVar2;\n    int32_t iVar3;\n    char *arg_8h_01;\n    int32_t iVar4;\n    char *pcVar5;\n    uint uVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = arg_8h;\n    uVar6 = 0xffffffff;\n    pcVar5 = arg_8h;\n    iVar2 = fcn.0044ba8e(arg_8h);\n    if (iVar2 == 0) {\n        fcn.0041638e(pcVar5, uVar6);\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h);\n    iVar3 = fcn.0044ea4f(arg_8h, 0, 0);\n    iVar3 = iVar3 + -1;\n    pcVar5 = arg_8h + (iVar2 - iVar3);\n    if (arg_ch < iVar2) {\n        if (arg_ch < iVar3) {\n            if (arg_10h == 0) {\n                *arg_8h = '\\0';\n                return;\n            }\n        }\n        else {\n            arg_8h_01 = arg_8h + 2;\n            if ((*arg_8h == '\\\\') && (arg_8h[1] == '\\\\')) {\n                for (; *arg_8h_01 != '\\\\'; arg_8h_01 = fcn.0045ce2c(arg_8h_01)) {\n                }\n            }\n            arg_8h = arg_8h_01;\n            if (3 < iVar2 - iVar3) {\n                do {\n                    arg_8h = fcn.0045ce2c(arg_8h);\n                } while (*arg_8h != '\\\\');\n            }\n            pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n            iVar4 = arg_8h - arg_8h_00;\n            if (iVar4 + 5 + iVar3 <= arg_ch) {\n                while (iVar3 = (*pcVar1)(arg_8h),  arg_ch < iVar3 + 4 + iVar4) {\n                    do {\n                        arg_8h = fcn.0045ce2c(arg_8h);\n                    } while (*arg_8h != '\\\\');\n                }\n                if ((iVar4 < 0) || (arg_ch <= iVar4)) {\n                    iVar4 = arg_ch;\n                }\n                fcn.00414fcb(arg_8h_00 + iVar4, (iVar2 - iVar4) + 1, \"\\\\...\", 5);\n                fcn.00444af1(arg_8h_00, iVar2 + 1, arg_8h);\n                return;\n            }\n        }\n        fcn.0042a985(arg_8h_00, iVar2 + 1, pcVar5);\n    }\n    return;\n}\n",
        "token_count": 686
    },
    "00452fbc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00452fbc(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    char **ppcVar1;\n    char *arg_ch_00;\n    uint lpData;\n    code *pcVar2;\n    int32_t iVar3;\n    uint cbData;\n    int32_t unaff_EBP;\n    uint var_138h;\n    uint var_134h;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_120h;\n    uint var_11ch;\n    uint var_118h;\n    uint var_114h;\n    uint var_110h;\n    uint var_4h;\n    \n    fcn.0045afa4(300);\n    ppcVar1 = *(unaff_EBP + 8);\n    iVar3 = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x120) = ppcVar1;\n    *(unaff_EBP + -0x130) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x11c) = iVar3;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    fcn.00401e60();\n    *(unaff_EBP + -0x128) = 0;\n    *(unaff_EBP + -4) = 1;\n    if (iVar3 == -0x80000000) {\n        fcn.00449e43(0x80000000, \"CLSID\", 0, 0x20019, unaff_EBP + -0x128);\n    }\n    *(unaff_EBP + -0x134) = 0;\n    *(unaff_EBP + -0x138) = *(unaff_EBP + -0x128);\n    arg_ch_00 = *ppcVar1;\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -300) = 1;\n    pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n    do {\n        if (arg_ch_00 == NULL) {\ncode_r0x00453142:\n            fcn.0043985f();\n            fcn.004010f0();\n            fcn.004010f0();\n            fcn.0045b027();\n            return;\n        }\n        *(unaff_EBP + -0x120) = *(unaff_EBP + -0x120) + 4;\n        if ((*(unaff_EBP + -0x11c) != -0x80000000) || (*arg_ch_00 != '\\0')) {\n            iVar3 = (*pcVar2)(arg_ch_00);\n            *(unaff_EBP + -0x114) = arg_ch_00 + iVar3 + 1;\n            fcn.0042a9a3(unaff_EBP + -0x118, arg_ch_00, *(unaff_EBP + -0x130), *(unaff_EBP + 0x10));\n            fcn.0042a9a3(unaff_EBP + -0x124, *(unaff_EBP + -0x114), *(unaff_EBP + -0x130), *(unaff_EBP + 0x10));\n            iVar3 = *(unaff_EBP + -0x118);\n            if ((*(unaff_EBP + -0x11c) != -0x80000000) || (*(iVar3 + -0xc) != 0)) {\n                if (*(unaff_EBP + 0x14) == 0) {\n                    *(unaff_EBP + -0x114) = 0x100;\n                    iVar3 = fcn.00449ed1(*(unaff_EBP + -0x11c), iVar3, unaff_EBP + -0x110, unaff_EBP + -0x114);\n                    if (iVar3 == 0) goto code_r0x00453124;\n                    iVar3 = *(unaff_EBP + -0x118);\n                }\n                lpData = *(unaff_EBP + -0x124);\n                *(unaff_EBP + -0x114) = iVar3;\n                cbData = (*pcVar2)(lpData);\n                iVar3 = fcn.00449f5c(*(unaff_EBP + -0x11c), *(unaff_EBP + -0x114), 1, lpData, cbData);\n                if (iVar3 != 0) {\n                    if (iVar3 != 5) {\n                        *(unaff_EBP + -300) = 0;\n                    }\n                    goto code_r0x00453142;\n                }\n            }\n        }\ncode_r0x00453124:\n        arg_ch_00 = **(unaff_EBP + -0x120);\n    } while( true );\n}\n",
        "token_count": 1105
    },
    "004533b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl\nfcn.004533b5(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af3b(8);\n    iVar3 = *(unaff_EBP + 0x1c);\n    iVar2 = *(unaff_EBP + 0x18);\n    if (iVar3 == 0) {\n        iVar3 = *(iVar2 * 8 + 0x481f38);\n    }\n    iVar1 = *(unaff_EBP + 0x20);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0042052a();\n        if (*(iVar1 + 0x14) == '\\0') {\n            iVar1 = *(iVar2 * 8 + 0x481f3c);\n        }\n        else {\n            iVar1 = *(iVar2 * 8 + 0x481f64);\n        }\n    }\n    fcn.00452d6d(10);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0045319c(unaff_EBP + -0x14, *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), \n                         *(unaff_EBP + 0x14), *(unaff_EBP + 0x24), *(unaff_EBP + 0x28), *(unaff_EBP + 0x2c));\n    if (((iVar2 != 0) && (iVar3 = fcn.00452fbc(iVar3, *(unaff_EBP + -0x14), 10, 0, 0x80000000),  iVar3 != 0)) &&\n       (iVar1 != 0)) {\n        fcn.00452fbc(iVar1, *(unaff_EBP + -0x14), 10, 1, 0x80000000);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00452dad();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 585
    },
    "00453468": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl\nfcn.00453468(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af3b(8);\n    iVar3 = *(unaff_EBP + 0x1c);\n    iVar2 = *(unaff_EBP + 0x18);\n    if (iVar3 == 0) {\n        iVar3 = *(iVar2 * 8 + 0x481f38);\n    }\n    iVar1 = *(unaff_EBP + 0x20);\n    if (iVar1 == 0) {\n        iVar1 = fcn.0042052a();\n        if (*(iVar1 + 0x14) == '\\0') {\n            iVar1 = *(iVar2 * 8 + 0x481f3c);\n        }\n        else {\n            iVar1 = *(iVar2 * 8 + 0x481f64);\n        }\n    }\n    fcn.00452d6d(10);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0045319c(unaff_EBP + -0x14, *(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), \n                         *(unaff_EBP + 0x14), 0, 0, 0);\n    if (((iVar2 != 0) && (iVar3 = fcn.00452f05(iVar3, *(unaff_EBP + -0x14), 10, 0x80000000),  iVar3 != 0)) &&\n       (iVar1 != 0)) {\n        fcn.00452f05(iVar1, *(unaff_EBP + -0x14), 10, 0x80000000);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00452dad();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 533
    },
    "0045353c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0045353c(uint hKey, uint lpString, int32_t lpValueName)\n\n{\n    uint cbData;\n    int32_t iVar1;\n    int32_t iVar2;\n    bool bVar3;\n    \n    if (lpValueName == 0) {\n        cbData = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar1 = fcn.00449f5c(0x80000000, hKey, 1, lpString, cbData);\n        bVar3 = iVar1 == 0;\n    }\n    else {\n        iVar1 = fcn.00449d33(0x80000000, hKey, &hKey);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, lpValueName, 0, 1, lpString, iVar1 + 1);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            if ((iVar2 == 0) && (iVar1 == 0)) {\n                return true;\n            }\n        }\n        bVar3 = false;\n    }\n    return bVar3;\n}\n",
        "token_count": 286
    },
    "00453861": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00453861(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t iVar3;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = *(param_1 + 8);\n    iVar3 = 0;\n    var_4h = param_1;\n    while (var_8h != 0) {\n        ppiVar2 = fcn.00411a80(&var_8h);\n        piVar1 = *ppiVar2;\n        var_4h = (**(*piVar1 + 0x54))();\n        while (var_4h != 0) {\n            (**(*piVar1 + 0x58))(&var_4h);\n            iVar3 = iVar3 + 1;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 204
    },
    "00453b6b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00453b6b(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    int32_t iVar4;\n    \n    iVar4 = 0xc;\n    fcn.0045af3b(0xc);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.CDocManager.0;\n    pcVar1 = extraout_ECX[2];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        *(unaff_EBP + -0x14) = pcVar1;\n        iVar4 = unaff_EBP + -0x10;\n        ppiVar3 = fcn.00411a80();\n        piVar2 = *ppiVar3;\n        if (piVar2[8] != 0) {\n            fcn.0044b802(*(unaff_EBP + -0x14));\n            (**(*piVar2 + 4))(1);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0044b898(iVar4);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 358
    },
    "00454c3c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00454c3c(int32_t param_1)\n\n{\n    if (*(param_1 + 0x58) != 0) {\n    // WARNING: Could not recover jumptable at 0x00454c47. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x58) + 0x34))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "00454c4b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00454c4b(int32_t param_1)\n\n{\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 0x58) == 0) {\n        fcn.0041638e();\n        param_1 = extraout_ECX;\n    }\n    // WARNING: Could not recover jumptable at 0x00454c61. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x58) + 0x2c))();\n    return;\n}\n",
        "token_count": 127
    },
    "00454cce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00454cce(int32_t param_1)\n\n{\n    if (*(param_1 + 0x20) != 0) {\n        (*_sym.imp.ole32.dll_CoRegisterMessageFilter)(0, 0);\n        *(param_1 + 0x20) = 0;\n    }\n    return;\n}\n",
        "token_count": 76
    },
    "0045510b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0045510b(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CSharedFile.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[8] != NULL) {\n        fcn.00438ab7();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438bcc();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 164
    },
    "00455d52": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00455d52(int32_t param_1)\n\n{\n    uint arg_8h;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t lParam;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    uint lpRect;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (*(param_1 + 0x84) == 0) {\n        *(param_1 + 0x84) = 1;\n        var_4h = 1;\n        arg_8h = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x20));\n        iVar1 = fcn.0041af14(arg_8h);\n        if ((iVar1 == 0) ||\n           (iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar1 + 0x20), 0x368, 0, &fcn.00455d52::lParam),  iVar1 == 0))\n        {\n            iVar2 = fcn.00455c17(&fcn.00455d52::var_18h, &fcn.00455d52::var_10h);\n            iVar1 = var_14h;\n            iVar3 = var_18h;\n            if (iVar2 == 0) {\n                (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x20), &fcn.00455d52::lpRect);\n                if ((0 < var_20h) && (0 < var_1ch)) {\n                    fcn.00419d0b(3, 0);\n                }\n                *(param_1 + 0x84) = 0;\n                return;\n            }\n        }\n        else {\n            var_4h = 0;\n            fcn.00455669(0x455db1);\n            iVar1 = var_2ch - var_34h;\n            iVar3 = var_30h - lParam;\n        }\n        fcn.00455c94(iVar3, iVar1, &fcn.00455d52::var_8h, &fcn.00455d52::var_20h, &fcn.00455d52::var_18h, var_4h);\n        if (var_8h != 0) {\n            iVar1 = iVar1 - var_ch;\n        }\n        if (var_4h != 0) {\n            iVar3 = iVar3 - var_10h;\n        }\n        fcn.00455615(var_18h, var_14h);\n        var_4ch = 0;\n        var_50h = 3;\n        fcn.00419d0b(0, var_8h);\n        if (var_8h != 0) {\n            var_48h = *(param_1 + 0x68) + -1;\n            var_44h = iVar3;\n            iVar3 = fcn.00418ef7(0, &fcn.00455d52::var_54h, 1);\n            if (iVar3 == 0) {\n                fcn.00419ca0(0, 0, var_20h, 1);\n            }\n        }\n        fcn.00419d0b(1, var_4h);\n        if (var_4h != 0) {\n            var_48h = *(param_1 + 0x6c) + -1;\n            var_44h = iVar1;\n            iVar1 = fcn.00418ef7(1, &fcn.00455d52::var_54h, 1);\n            if (iVar1 == 0) {\n                fcn.00419ca0(1, 0, var_1ch, 1);\n            }\n        }\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 964
    },
    "004560e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004560e9(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_GetWindowRect)(param_1[8], &var_28h);\n    iVar1 = param_1[0x1c];\n    uVar6 = 0;\n    if ((iVar1 == 0x7923) || (iVar1 == 0x7922)) {\n        if (var_ch < var_24h) {\n            uVar6 = 30999;\n        }\n        else if (var_1ch < var_ch) {\n            uVar6 = 0x791d;\n        }\n    }\n    if ((iVar1 == 0x7923) || (iVar1 == 0x7921)) {\n        if (var_10h < var_28h) {\n            if (uVar6 == 0) {\n                uVar6 = 0x7919;\n            }\n            else if (iVar1 == 0x7923) {\n                uVar6 = uVar6 - 1;\n            }\n        }\n        else if (var_20h < var_10h) {\n            if (uVar6 == 0) {\n                uVar6 = 0x791b;\n            }\n            else if (iVar1 == 0x7923) {\n                uVar6 = uVar6 + 1;\n            }\n        }\n    }\n    if (param_1[0x1b] == 0) {\n        if (uVar6 == 0) {\n            (*_sym.imp.USER32.dll_SetCursor)(param_1[0x1d]);\n        }\n        else {\n            iVar1 = fcn.0042052a();\n            uVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(*(iVar1 + 0xc), uVar6 & 0xffff);\n            (*_sym.imp.USER32.dll_SetCursor)(uVar2);\n            if ((var_20h < var_10h) || (var_20h = var_28h,  var_10h < var_28h)) {\n                var_8h = var_10h - var_20h;\n            }\n            else {\n                var_8h = 0;\n            }\n            if ((var_1ch < var_ch) || (var_1ch = var_24h,  var_ch < var_24h)) {\n                var_4h = var_ch - var_1ch;\n            }\n            else {\n                var_4h = 0;\n            }\n            piVar3 = fcn.00405790();\n            iVar1 = param_1[0x1c];\n            if ((iVar1 == 0x7923) || (iVar1 == 0x7922)) {\n                uVar2 = 1;\n            }\n            else {\n                uVar2 = 0;\n            }\n            if ((iVar1 == 0x7923) || (iVar1 == 0x7921)) {\n                uVar4 = 1;\n            }\n            else {\n                uVar4 = 0;\n            }\n            (**(*piVar3 + 0x18c))(&var_18h, var_8h, var_4h, uVar4, uVar2);\n            fcn.00418160(0);\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(piVar3[8]);\n            uVar2 = fcn.0041af14(uVar2);\n            piVar5 = fcn.00424c30(0x47fa80, uVar2);\n            if (piVar5 == NULL) {\n                (**(*piVar3 + 0x144))();\n            }\n            else {\n                (**(*piVar5 + 0x184))(piVar3, var_18h, var_14h, 1);\n            }\n            (*_sym.imp.USER32.dll_UpdateWindow)(param_1[8]);\n            fcn.0041822e(0x49bc00, param_1[0x19] + -0x10, param_1[0x1a] + -0x10, 0, 0, 0x51);\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_KillTimer)(param_1[8], 0xe000);\n        (*_sym.imp.USER32.dll_ReleaseCapture)();\n        (*_sym.imp.USER32.dll_SetCursor)(0);\n        iVar1 = fcn.00405790();\n        (**(*param_1 + 0x60))();\n        if (*(iVar1 + 0x58) != NULL) {\n            (**(**(iVar1 + 0x58) + 4))(1);\n        }\n        *(iVar1 + 0x58) = 0;\n    }\n    return;\n}\n",
        "token_count": 1185
    },
    "00456452": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00456452(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x18);\n    *(unaff_EBP + -0x10) = *(extraout_ECX + 0x5c);\n    *(extraout_ECX + 0x5c) = *(unaff_EBP + 8);\n    *(extraout_ECX + 0x60) = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 100) = *(unaff_EBP + 0x10);\n    fcn.004175d5(0);\n    uVar2 = *(extraout_ECX + 0x5c);\n    *(unaff_EBP + -4) = 0;\n    fcn.00416d23(uVar2);\n    pcVar5 = _sym.imp.GDI32.dll_LPtoDP;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x68) = *(extraout_ECX + 0x60);\n    *(extraout_ECX + 0x6c) = *(extraout_ECX + 100);\n    (*pcVar5)(uVar2, extraout_ECX + 0x68, 1);\n    iVar3 = (*(unaff_EBP + 0x14))[1];\n    piVar1 = extraout_ECX + 0x70;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *piVar1 = **(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x74) = iVar3;\n    (*pcVar5)(uVar2, piVar1, 1);\n    uVar2 = (*(unaff_EBP + 0x18))[1];\n    uVar4 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x78) = **(unaff_EBP + 0x18);\n    *(extraout_ECX + 0x7c) = uVar2;\n    (*pcVar5)(uVar4, extraout_ECX + 0x78, 1);\n    if (*(extraout_ECX + 0x6c) < 0) {\n        *(extraout_ECX + 0x6c) = -*(extraout_ECX + 0x6c);\n    }\n    if (*(extraout_ECX + 0x74) < 0) {\n        *(extraout_ECX + 0x74) = -*(extraout_ECX + 0x74);\n    }\n    if (*(extraout_ECX + 0x7c) < 0) {\n        *(extraout_ECX + 0x7c) = -*(extraout_ECX + 0x7c);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00417629();\n    if (*piVar1 == 0) {\n        *piVar1 = *(extraout_ECX + 0x68) / 10;\n    }\n    if (*(extraout_ECX + 0x74) == 0) {\n        *(extraout_ECX + 0x74) = *(extraout_ECX + 0x6c) / 10;\n    }\n    if (*(extraout_ECX + 0x78) == 0) {\n        *(extraout_ECX + 0x78) = *piVar1 / 10;\n    }\n    if (*(extraout_ECX + 0x7c) == 0) {\n        *(extraout_ECX + 0x7c) = *(extraout_ECX + 0x74) / 10;\n    }\n    if (*(extraout_ECX + 0x20) != 0) {\n        fcn.00455d52();\n        if (*(unaff_EBP + -0x10) != *(extraout_ECX + 0x5c)) {\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(extraout_ECX + 0x20), 0, 1);\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1088
    },
    "00456c51": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00456c51(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    uint var_4h;\n    \n    pcVar3 = _sym.imp.GDI32.dll_GetStockObject;\n    if (param_1[1] != 0) {\n        uVar4 = (*_sym.imp.GDI32.dll_GetStockObject)(7);\n        pcVar2 = _sym.imp.GDI32.dll_SelectObject;\n        uVar4 = (*_sym.imp.GDI32.dll_SelectObject)(param_1[2], uVar4);\n        (*pcVar2)(param_1[2], uVar4);\n        (*pcVar2)(param_1[1], uVar4);\n        uVar4 = (*pcVar3)(4);\n        uVar4 = (*pcVar2)(param_1[2], uVar4);\n        (*pcVar2)(param_1[2], uVar4);\n        (*pcVar2)(param_1[1], uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetROP2)(param_1[2]);\n        fcn.00416c8c(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetBkMode)(param_1[2]);\n        fcn.00416c28(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetTextAlign)(param_1[2]);\n        fcn.00416e73(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetPolyFillMode)(param_1[2]);\n        fcn.00416c5a(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetStretchBltMode)(param_1[2]);\n        fcn.00416cbe(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetTextColor)(param_1[2]);\n        iVar1 = *param_1;\n        uVar4 = fcn.00456bed(uVar4);\n        (**(iVar1 + 0x30))(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetBkColor)(param_1[2]);\n        iVar1 = *param_1;\n        uVar4 = fcn.00456bed(uVar4);\n        (**(iVar1 + 0x2c))(uVar4);\n    }\n    return;\n}\n",
        "token_count": 553
    },
    "00456d31": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_94h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00456d31(int32_t *param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t var_94h;\n    int32_t var_88h;\n    uint var_80h;\n    uint var_78h;\n    uint var_64h;\n    uchar var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    uint lpSize;\n    int32_t var_44h;\n    int32_t lpvObject;\n    uint var_3ch;\n    uint var_30h;\n    uint var_2ch;\n    uint8_t var_25h;\n    uint lpFaceName;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if (param_1[2] != 0) {\n        if (param_1[0xb] == 0) {\n            (**(*param_1 + 0x24))(0xe);\n        }\n        else if (param_1[1] != 0) {\n            (*_sym.imp.GDI32.dll_GetObjectA)(param_1[0xb], 0x3c, &lpvObject);\n            (*_sym.imp.GDI32.dll_GetTextFaceA)(param_1[2], 0x20, &lpFaceName);\n            pcVar2 = _sym.imp.GDI32.dll_GetTextMetricsA;\n            (*_sym.imp.GDI32.dll_GetTextMetricsA)(param_1[2], &var_94h);\n            pcVar1 = _sym.imp.GDI32.dll_CreateFontIndirectA;\n            if (var_94h < 0) {\n                lpvObject = var_94h;\n            }\n            else {\n                lpvObject = var_88h - var_94h;\n            }\n            var_3ch = var_80h;\n            var_30h = var_78h;\n            var_2ch._0_1_ = var_64h;\n            var_2ch._1_1_ = var_64h._1_1_;\n            var_2ch._2_1_ = var_64h._2_1_;\n            var_2ch._3_1_ = var_60h;\n            var_25h = var_64h._3_1_;\n            var_54h = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&lpvObject);\n            (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], var_54h);\n            (*pcVar2)(param_1[1], &var_94h);\n            iVar4 = -lpvObject;\n            if (var_94h < 0) {\n                var_58h = -var_94h;\n            }\n            else {\n                var_58h = var_94h - var_88h;\n            }\n            (*_sym.imp.GDI32.dll_GetWindowExtEx)(param_1[1], &lpSize);\n            (*_sym.imp.GDI32.dll_GetViewportExtEx)(param_1[1], &var_50h);\n            pcVar2 = _sym.imp.KERNEL32.dll_MulDiv;\n            if (var_44h < 0) {\n                var_44h = -var_44h;\n            }\n            if (var_4ch < 0) {\n                var_4ch = -var_4ch;\n            }\n            var_5ch = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar4, var_4ch, var_44h);\n            iVar3 = (*pcVar2)(var_58h, var_4ch, var_44h);\n            iVar4 = var_54h;\n            if (var_5ch < iVar3) {\n                var_25h = ((var_25h & 0xf0) != 0x50) - 1U & 0x50;\n                lpFaceName._0_1_ = 0;\n                iVar4 = (*pcVar1)(&lpvObject);\n                (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], iVar4);\n                (*_sym.imp.GDI32.dll_DeleteObject)(var_54h);\n            }\n            fcn.0044b01d(param_1 + 10);\n            param_1[10] = iVar4;\n        }\n    }\n    fcn.0045843c(var_94h);\n    return;\n}\n",
        "token_count": 1051
    },
    "004575a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004575a8(int32_t param_1)\n\n{\n    uint X;\n    uint var_ch;\n    int32_t lpPoint;\n    int32_t Y;\n    \n    if ((*(param_1 + 8) != 0) && (*(param_1 + 4) != 0)) {\n        (*_sym.imp.GDI32.dll_GetViewportOrgEx)(*(param_1 + 8), &lpPoint);\n        fcn.0045725d(&lpPoint);\n        Y = Y + *(param_1 + 0x24);\n        lpPoint = lpPoint + *(param_1 + 0x20);\n        (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), lpPoint, Y, 0);\n        (*_sym.imp.GDI32.dll_GetWindowOrgEx)(*(param_1 + 8), &X);\n        (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), X, var_ch, 0);\n    }\n    return;\n}\n",
        "token_count": 232
    },
    "00457680": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00457680(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    \n    if (arg_8h != 0) {\n        piVar1 = in_ECX + 0x38;\n        (*_sym.imp.GDI32.dll_GetViewportExtEx)(*(in_ECX + 8), piVar1);\n        piVar2 = in_ECX + 0x30;\n        (*_sym.imp.GDI32.dll_GetWindowExtEx)(*(in_ECX + 8), piVar2);\n        iVar6 = *piVar2;\n        while ((((-0x4000 < iVar6 && (*piVar2 < 0x4000)) && (iVar3 = *piVar1,  -0x4000 < iVar3)) && (iVar3 < 0x4000))) {\n            iVar6 = *piVar2 * 2;\n            *piVar2 = iVar6;\n            *piVar1 = iVar3 * 2;\n        }\n        iVar6 = *(in_ECX + 0x34);\n        pcVar4 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        while (((_sym.imp.GDI32.dll_GetDeviceCaps = pcVar4,  -0x4000 < iVar6 && (*(in_ECX + 0x34) < 0x4000)) &&\n               ((iVar3 = *(in_ECX + 0x3c),  -0x4000 < iVar3 && (iVar3 < 0x4000))))) {\n            iVar6 = *(in_ECX + 0x34) * 2;\n            *(in_ECX + 0x34) = iVar6;\n            *(in_ECX + 0x3c) = iVar3 * 2;\n            pcVar4 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        }\n        uVar5 = (*pcVar4)(*(in_ECX + 8), 0x58);\n        iVar6 = fcn.004567d4(*piVar1, *(in_ECX + 0x10), *0x49be58, *(in_ECX + 0x14), uVar5);\n        *piVar1 = iVar6;\n        uVar5 = (*pcVar4)(*(in_ECX + 8), 0x5a);\n        uVar5 = fcn.004567d4(*(in_ECX + 0x3c), *(in_ECX + 0x10), *0x49be5c, *(in_ECX + 0x14), uVar5);\n        *(in_ECX + 0x3c) = uVar5;\n    }\n    if (*(in_ECX + 4) != 0) {\n        (*_sym.imp.GDI32.dll_SetMapMode)(*(in_ECX + 4), 8);\n        (*_sym.imp.GDI32.dll_SetWindowExtEx)(*(in_ECX + 4), *(in_ECX + 0x30), *(in_ECX + 0x34), 0);\n        (*_sym.imp.GDI32.dll_SetViewportExtEx)(*(in_ECX + 4), *(in_ECX + 0x38), *(in_ECX + 0x3c), 0);\n        fcn.004575a8();\n    }\n    return;\n}\n",
        "token_count": 770
    },
    "00457882": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00457882(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x10) = arg_8h;\n    *(in_ECX + 0x14) = arg_ch;\n    if (*(in_ECX + 8) != 0) {\n        fcn.00457680(1);\n        fcn.00456d31();\n    }\n    return;\n}\n",
        "token_count": 102
    },
    "00457bdc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00457bdc(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t *in_ECX;\n    \n    if (arg_8h < 4) {\n        arg_8h = 4;\n    }\n    if (arg_ch < 2) {\n        arg_ch = 0x40;\n    }\n    in_ECX[3] = 0;\n    in_ECX[2] = 0;\n    *in_ECX = arg_8h;\n    in_ECX[1] = arg_ch;\n    return;\n}\n",
        "token_count": 128
    },
    "00457c26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00457c26(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1[3] == 0) {\n        iVar1 = fcn.0042e01d(param_1 + 2, param_1[1], *param_1);\n        iVar3 = param_1[1] + -1;\n        piVar2 = iVar1 + 4 + *param_1 * iVar3;\n        for (; -1 < iVar3; iVar3 = iVar3 + -1) {\n            *piVar2 = param_1[3];\n            param_1[3] = piVar2;\n            piVar2 = piVar2 - *param_1;\n        }\n    }\n    param_1[3] = *param_1[3];\n    return;\n}\n",
        "token_count": 201
    },
    "00457eab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00457eab(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x74) = arg_8h;\n    if (arg_8h != 1) {\n        arg_8h = ((arg_8h != 2) - 1 & 3) - 1;\n    }\n    return arg_8h;\n}\n",
        "token_count": 96
    },
    "00457eef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00457eef(code *arg_8h, int32_t arg_ch, code *arg_10h, uint arg_14h)\n\n{\n    code **in_ECX;\n    \n    fcn.00457ed4(arg_14h);\n    *in_ECX = vtable.COleBusyDialog.0;\n    fcn.00458b20(in_ECX + 0x1e, 0, 0x2c);\n    in_ECX[0x1e] = 0x2c;\n    in_ECX[0x1f] = arg_10h;\n    if (arg_ch != 0) {\n        in_ECX[0x1f] = arg_10h | 8;\n    }\n    in_ECX[0x27] = arg_8h;\n    in_ECX[0x22] = fcn.00457e5e;\n    return;\n}\n",
        "token_count": 203
    },
    "00457f49": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00457f49(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t hWnd;\n    \n    iVar2 = *(param_1 + 0x68);\n    if (iVar2 != 0) {\n        iVar2 = *(iVar2 + 0x20);\n    }\n    hWnd = param_1;\n    uVar1 = fcn.0041f8f7(iVar2, &hWnd);\n    *(param_1 + 0x80) = uVar1;\n    fcn.0041ce25(param_1);\n    iVar2 = sub.oledlg.dll_OleUIBusyA(param_1 + 0x78);\n    fcn.0041afcd();\n    fcn.0041af9d();\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    uVar1 = 2;\n    if (iVar2 != 2) {\n        if (iVar2 == 0x75) {\n            *(param_1 + 0xa4) = 1;\n        }\n        else {\n            if (iVar2 != 0x76) {\n                if (iVar2 == 0x77) {\n                    *(param_1 + 0xa4) = 3;\n                    return 1;\n                }\n                uVar1 = fcn.00457eab(iVar2);\n            }\n            *(param_1 + 0xa4) = uVar1;\n        }\n        return 1;\n    }\n    return 2;\n}\n",
        "token_count": 351
    },
    "0045814c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0045814c(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x4581f7;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.00458223;\n        uStack36 = *0x4987a4 ^ &fcn.0045814c::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0045814c::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.0045f325();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.0045814c::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 724
    },
    "0045843c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045843c(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x4987a4) {\n        return;\n    }\n    *0x49c300 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x49c304 = &arg_8h;\n    *0x49c240 = 0x10001;\n    *0x49c1e8 = 0xc0000409;\n    *0x49c1ec = 1;\n    var_328h = *0x4987a4;\n    var_324h = *0x4987a8;\n    *0x49c1f4 = unaff_retaddr;\n    *0x49c2cc = in_GS;\n    *0x49c2d0 = in_FS;\n    *0x49c2d4 = in_ES;\n    *0x49c2d8 = in_DS;\n    *0x49c2dc = unaff_EDI;\n    *0x49c2e0 = unaff_ESI;\n    *0x49c2e4 = unaff_EBX;\n    *0x49c2e8 = in_EDX;\n    *0x49c2ec = in_ECX;\n    *0x49c2f0 = in_EAX;\n    *0x49c2f4 = unaff_EBP;\n    *0x49c2f8 = unaff_retaddr;\n    *0x49c2fc = in_CS;\n    *0x49c308 = in_SS;\n    *0x49c238 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.00468837(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x482f80);\n    if (*0x49c238 == 0) {\n        fcn.00468837(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 854
    },
    "004584f4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004584f4(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.0045844b(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "00458a67": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00458a67(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint arg_18h)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) == 0) {\n        fcn.0045844b(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + 0x18));\n    }\n    return;\n}\n",
        "token_count": 138
    },
    "00459365": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00459365(code **param_1)\n\n{\n    *param_1 = vtable.std::exception.0;\n    if (param_1[2] != NULL) {\n        fcn.004585e6(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 64
    },
    "0045d819": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x0045d90c: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x0045d911)\n// WARNING: Removing unreachable block (ram,0x0045d93f)\n// WARNING: Removing unreachable block (ram,0x0045d917)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0045d819(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0045b538(0x4926e0, 0x18);\n    fcn.0045fec1(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x49c1c0 != 1) {\n        *0x49c1bc = 1;\n        *0x49c1b8 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.0045f09c(*0x49dde8);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.0045f09c(*0x49dde4);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.0045f093();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.0045f09c(*piVar2);\n                        iVar3 = fcn.0045f093();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.0045f09c(*0x49dde8);\n                        piVar1 = fcn.0045f09c(*0x49dde4);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.0045d753(0x475984);\n        }\n        fcn.0045d753(0x47598c);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0045fde7(8);\n    }\n    return;\n}\n",
        "token_count": 811
    },
    "0045e526": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0045e526(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0045f325();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.0045f325();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "0045e7ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045e7ee(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.0045838a(*(unaff_EBP + -0x28));\n    iVar1 = fcn.0045f325();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.0045f325();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.00458363(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0045e586(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 382
    },
    "00468508": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00468508(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.0045fde7(0);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "0046a1e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0046a1e1(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0046a6e2;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = str.5_v_[0] + L'\\xffffffff';\n        iVar4 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        uVar9 = str.5_v_[0] & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x0046a316;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x0046a31d;\ncode_r0x0046a316:\n                        do {\n                            var_4h = 1;\ncode_r0x0046a31d:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x0046a32b;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x0046a32b:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x4996e4 - str.5_v_[0]) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x4996e4 < iVar12) {\n                if (iVar12 < *0x4996e0) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + str.5_v_[3];\n                    iVar4 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = str.5_v_[3] + *0x4996e0;\n                    uVar5 = 1;\n                }\n                goto code_r0x0046a6e2;\n            }\n            var_10h = *0x4996e4 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = str.5_v_[0] + L'\\xffffffff';\n            iVar12 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar10 = str.5_v_[0] & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x0046a4ce;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x0046a4ce:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = str.5_v_[1] + L'\\x01';\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0046a6e2:\n    var_20h = iVar12 << (0x1fU - str.5_v_[1] & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3683
    },
    "0046a725": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0046a725(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0046ac26;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = *0x499700 - 1;\n        iVar4 = *0x499700 + (*0x499700 >> 0x1f & 0x1fU) >> 5;\n        uVar9 = *0x499700 & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x0046a85a;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x0046a861;\ncode_r0x0046a85a:\n                        do {\n                            var_4h = 1;\ncode_r0x0046a861:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x0046a86f;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x0046a86f:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x4996fc - *0x499700) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x4996fc < iVar12) {\n                if (iVar12 < *0x4996f8) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + *0x49970c;\n                    iVar4 = *0x499704 + (*0x499704 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x499704 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = *0x499704 + (*0x499704 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x499704 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = *0x49970c + *0x4996f8;\n                    uVar5 = 1;\n                }\n                goto code_r0x0046ac26;\n            }\n            var_10h = *0x4996fc - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = *0x499700 - 1;\n            iVar12 = *0x499700 + (*0x499700 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = *0x499700 & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x0046aa12;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x0046aa12:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = *0x499704 + 1;\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0046ac26:\n    var_20h = iVar12 << (0x1fU - *0x499704 & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (*0x499708 == 0x40) {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (*0x499708 == 0x20) {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3625
    },
    "00402870": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402870(void)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t unaff_EDI;\n    uint32_t *in_FS_OFFSET;\n    char *unaff_retaddr;\n    uint32_t uStack48;\n    int32_t iStack44;\n    uint32_t uStack40;\n    uint32_t uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46ed20;\n    uStack12 = *in_FS_OFFSET;\n    uStack40 = *0x4987a4 ^ &stack0xffffffdc;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    iStack44 = 0x40289f;\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        iStack44 = -0x7fffbffb;\n        uStack48 = 0x4028b4;\n        piVar3 = fcn.00401000();\n    }\n    uStack48 = 0x4028bd;\n    (**(*piVar3 + 0xc))();\n    uStack8 = 0;\n    uStack48 = 0x4028d1;\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        uStack48 = 0x80004005;\n        piVar3 = fcn.00401000();\n    }\n    uStack48 = 0x4028ef;\n    iVar4 = (**(*piVar3 + 0xc))();\n    iVar4 = iVar4 + 0x10;\n    iVar7 = 0;\n    uStack8 = CONCAT31(uStack8._1_3_, 1);\n    if (unaff_retaddr >> 0x10 == 0) {\n        uStack48 = unaff_retaddr & 0xffff;\n        iVar5 = fcn.0041f625();\n        if (iVar5 != 0) {\n            iVar4 = unaff_EDI;\n            fcn.004022e0();\n        }\n    }\n    else {\n        if (unaff_retaddr == NULL) {\n            uStack48 = 0;\n        }\n        else {\n            pcVar1 = unaff_retaddr + 1;\n            do {\n                cVar2 = *unaff_retaddr;\n                unaff_retaddr = unaff_retaddr + 1;\n            } while (cVar2 != '\\0');\n            uStack48 = unaff_retaddr - pcVar1;\n        }\n        iVar4 = unaff_EDI;\n        fcn.004023a0();\n    }\n    iVar6 = fcn.0041f630(&stack0xffffffe0, iVar4, 0, 10);\n    iVar5 = iStack44;\n    while (iVar6 != 0) {\n        iVar7 = iVar7 + 1;\n        fcn.00416974(*(iVar5 + 0x150), &stack0xffffffd0);\n        iVar6 = fcn.0041f630(&stack0xffffffc8, iVar4, iVar7, 10);\n    }\n    piVar3 = iVar4 + -4;\n    LOCK();\n    iVar7 = *piVar3;\n    *piVar3 = *piVar3 + -1;\n    if (iVar7 + -1 < 1) {\n        (**(**(iVar4 + -0x10) + 4))(iVar4 + -0x10);\n    }\n    piVar3 = uStack48 - 4;\n    LOCK();\n    iVar4 = *piVar3;\n    *piVar3 = *piVar3 + -1;\n    if (iVar4 == 1 || iVar4 + -1 < 0) {\n        (**(**(uStack48 - 0x10) + 4))(uStack48 - 0x10);\n    }\n    *in_FS_OFFSET = uStack40;\n    return;\n}\n",
        "token_count": 914
    },
    "004029f0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __thiscall fcn.004029f0(code **param_1, code *param_2, uint param_3, uint param_4)\n\n{\n    code cVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint32_t arg_8h;\n    code *pcVar6;\n    char *pcVar7;\n    uint arg_8h_00;\n    char *unaff_EBP;\n    int32_t **in_FS_OFFSET;\n    uint uStack88;\n    uint uStack84;\n    code **ppcStack80;\n    int32_t *piStack40;\n    uint32_t uStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46ed99;\n    piStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ &uStack88;\n    uVar3 = *0x4987a4 ^ &stack0xffffff98;\n    *in_FS_OFFSET = &piStack12;\n    uStack88 = param_4;\n    uStack84 = param_3;\n    ppcStack80 = param_1;\n    fcn.00402d60();\n    *param_1 = vtable.CButtonDialog.0;\n    param_1[0x1e] = NULL;\n    param_1[0x1d] = vtable.CFont.0;\n    uStack4._0_1_ = 1;\n    uStack4._1_3_ = 0;\n    fcn.0041997f();\n    param_1[0x26] = vtable.CStatic.0;\n    uStack4._0_1_ = 2;\n    fcn.0041997f();\n    param_1[0x3b] = vtable.CStatic.0;\n    uStack4 = CONCAT31(uStack4._1_3_, 3);\n    piVar4 = fcn.0041f6b5();\n    if (piVar4 == NULL) {\n        piVar4 = fcn.00401000(0x80004005);\n    }\n    iVar5 = (**(*piVar4 + 0xc))();\n    param_1[0x50] = iVar5 + 0x10;\n    uStack8 = CONCAT31(uStack8._1_3_, 4);\n    piVar4 = fcn.0041f6b5();\n    if (piVar4 == NULL) {\n        piVar4 = fcn.00401000(0x80004005);\n    }\n    iVar5 = (**(*piVar4 + 0xc))();\n    param_1[0x51] = iVar5 + 0x10;\n    uStack8._0_1_ = 5;\n    fcn.00416534();\n    uStack8 = CONCAT31(uStack8._1_3_, 6);\n    if (param_2 >> 0x10 == 0) {\n        arg_8h = param_2 & 0xffff;\n        iVar5 = fcn.0041f625();\n        if (iVar5 != 0) {\n            fcn.004022e0(iVar5, param_2 & 0xffff);\n        }\n    }\n    else {\n        if (param_2 == NULL) {\n            arg_8h = 0;\n        }\n        else {\n            pcVar6 = param_2;\n            do {\n                cVar1 = *pcVar6;\n                pcVar6 = pcVar6 + 1;\n            } while (cVar1 != 0x0);\n            arg_8h = pcVar6 - (param_2 + 1);\n        }\n        fcn.004023a0(param_2);\n    }\n    if (unaff_EBP >> 0x10 == 0) {\n        iVar5 = fcn.0041f625(unaff_EBP & 0xffff);\n        if (iVar5 != 0) {\n            fcn.004022e0(iVar5, unaff_EBP & 0xffff);\n        }\n    }\n    else {\n        if (unaff_EBP == NULL) {\n            iVar5 = 0;\n        }\n        else {\n            pcVar7 = unaff_EBP;\n            do {\n                cVar2 = *pcVar7;\n                pcVar7 = pcVar7 + 1;\n            } while (cVar2 != '\\0');\n            iVar5 = pcVar7 - (unaff_EBP + 1);\n        }\n        fcn.004023a0(unaff_EBP, iVar5);\n    }\n    if (uVar3 != 0) {\n        fcn.00402870(uVar3);\n    }\n    param_1[0x1a] = param_2;\n    param_1[0x20] = NULL;\n    param_1[0x21] = 0xffffffff;\n    param_1[0x25] = NULL;\n    *(param_1 + 0x24) = uStack4;\n    param_1[0x23] = 0xa;\n    param_1[0x22] = NULL;\n    fcn.0045850c(&stack0xffffffa0, 0x3c, 0x499e00, 0x3c);\n    ppcStack80 = 0x190;\n    arg_8h_00 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&stack0xffffffa0);\n    fcn.00417780(arg_8h_00);\n    param_1[0x1f] = uStack8;\n    *in_FS_OFFSET = piStack40;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 1287
    },
    "0041ae30": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.0041ae30(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0044a7e2(0x4163aa);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x68) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x70) = uVar2 >> 0x10;\n    *(iVar1 + 0x6c) = uVar2;\n    return iVar1 + 0x58;\n}\n",
        "token_count": 163
    },
    "0041c436": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041c436(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == 0) {\n        if (uVar3 == 0) {\n            return 0;\n        }\n        fcn.00418ec6();\n        var_28h = uVar3;\n        (**(*in_ECX + 0xc))(uVar3, 0xffffffff, &var_2ch, 0);\n        if (var_4h != 0) {\n            arg_8h = 0;\ncode_r0x0041c4bb:\n            uVar2 = (**(*in_ECX + 0xc))(uVar3, arg_8h, 0, 0);\n            return uVar2;\n        }\n    }\n    else {\n        iVar1 = fcn.0044a7e2(0x4163aa);\n        if (iVar1 == 0) {\n            iVar1 = fcn.0041638e();\n        }\n        if ((*(iVar1 + 0xdc) != in_ECX[8]) && (iVar1 = fcn.0041ba8d(arg_ch, 0),  iVar1 == 0)) {\n            if (uVar3 == 0) {\n                return 0;\n            }\n            goto code_r0x0041c4bb;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 390
    },
    "0041d773": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041d773(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0x112) {\n        if (arg_8h == 0x111) {\n            iVar2 = fcn.0041e5f9(0, arg_ch >> 0x10 | 0xbd110000, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 1;\n                return 1;\n            }\n            return 1;\n        }\n        if (0x2a < arg_8h) {\n            if ((arg_8h < 0x30) || (arg_8h == 0x39)) goto code_r0x0041d809;\n            if (arg_8h == 0x4e) {\n                var_8h = arg_14h;\n                var_4h = arg_10h;\n                uVar1 = fcn.0041e5f9(0, *(arg_10h + 8) & 0xffff | 0xbc4e0000, &var_8h, 0);\n                return uVar1;\n            }\n        }\n    }\n    else if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) {\ncode_r0x0041d809:\n        uVar1 = fcn.0041cfdc(arg_8h + 0xbc00, arg_ch, arg_10h, arg_14h);\n        return uVar1;\n    }\n    if (arg_8h - 0x132 < 7) {\n        var_4h = arg_8h - 0x132;\n        var_8h = arg_ch;\n        uVar1 = fcn.0041cfdc(0xbc19, 0, &var_ch, arg_14h);\n        if (*arg_14h != 0) {\n            return uVar1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 531
    },
    "0041ea3b": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.0041ea3b(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t extraout_ECX;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    uint16_t uVar6;\n    int32_t iVar7;\n    int32_t var_90h;\n    int32_t nWidth;\n    int32_t nHeight;\n    uint lpvBits;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    nWidth = uVar2;\n    nHeight = uVar2 >> 0x10;\n    if ((nWidth < 5) || (iVar4 = nWidth,  nHeight < 6)) {\n        fcn.0041638e();\n        iVar4 = extraout_ECX;\n    }\n    if (0x20 < iVar4) {\n        iVar4 = 0x20;\n        nWidth = 0x20;\n    }\n    iVar7 = iVar4 + 0xf >> 4;\n    iVar4 = ((iVar4 + -4) / 2 + iVar7 * 0x10) - iVar4;\n    if (0xc < iVar4) {\n        iVar4 = 0xc;\n    }\n    if (0x20 < nHeight) {\n        nHeight = 0x20;\n    }\n    fcn.00458b20(&lpvBits, 0xff, 0x80);\n    puVar3 = &lpvBits + (nHeight + -6 >> 1) * iVar7 * 2;\n    puVar5 = 0x47b3c0;\n    var_90h = 5;\n    do {\n        uVar1 = *puVar5;\n        puVar5 = puVar5 + 1;\n        uVar6 = ~(uVar1 << (iVar4 & 0x1f));\n        *puVar3 = uVar6 >> 8;\n        puVar3[1] = uVar6;\n        puVar3 = puVar3 + iVar7 * 2;\n        var_90h = var_90h + -1;\n    } while (var_90h != 0);\n    uVar2 = 1;\n    *0x49be90 = (*_sym.imp.GDI32.dll_CreateBitmap)(nWidth, nHeight, 1, 1, &lpvBits);\n    if (*0x49be90 == 0) {\n        *0x49be90 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    fcn.0045843c(uVar2);\n    return;\n}\n",
        "token_count": 617
    },
    "0042cbd1": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042cbd1(uint hModule, int32_t hResInfo, int32_t arg_10h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *arg_10h_00;\n    int32_t *arg_8h;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint uVar11;\n    uint32_t uVar12;\n    int32_t iVar13;\n    uint hResData;\n    uint var_10h;\n    uint var_ch;\n    uint hDC;\n    uint var_4h;\n    \n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if ((iVar5 == 0) || (arg_10h_00 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar5),  arg_10h_00 == NULL)) {\n        iVar6 = 0;\n    }\n    else {\n        iVar13 = *arg_10h_00 + 0x40;\n        arg_8h = fcn.0045adaa(iVar13);\n        if (arg_8h == NULL) {\n            iVar6 = 0;\n        }\n        else {\n            fcn.00414fcb(arg_8h, iVar13, arg_10h_00, iVar13);\n            iVar13 = *arg_8h;\n            hResInfo = 0;\n            do {\n                pcVar4 = _sym.imp.USER32.dll_GetSysColor;\n                puVar1 = arg_8h + hResInfo * 4 + iVar13;\n                uVar12 = 0;\n                do {\n                    if (*puVar1 == *(uVar12 * 8 + 0x47ca28)) {\n                        if (arg_10h == 0) {\n                            puVar2 = uVar12 * 8 + 0x47ca2c;\n                            uVar12 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar2);\n                            uVar7 = (*pcVar4)(*puVar2);\n                            uVar8 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar2);\n                            *puVar1 = uVar8 >> 0x10 & 0xff | ((uVar7 & 0xff) << 8 | uVar12 >> 8 & 0xff) << 8;\n                        }\n                        else if (*(uVar12 * 8 + 0x47ca2c) != 0x12) {\n                            *puVar1 = 0xffffff;\n                        }\n                        break;\n                    }\n                    uVar12 = uVar12 + 1;\n                } while (uVar12 < 4);\n                hResInfo = hResInfo + 1;\n            } while (hResInfo < 0x10);\n            iVar13 = arg_8h[1];\n            iVar3 = arg_8h[2];\n            uVar9 = (*_sym.imp.USER32.dll_GetDC)(0);\n            iVar6 = (*_sym.imp.GDI32.dll_CreateCompatibleBitmap)(uVar9, iVar13, iVar3);\n            if (iVar6 != 0) {\n                uVar10 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(uVar9);\n                pcVar4 = _sym.imp.GDI32.dll_SelectObject;\n                uVar11 = (*_sym.imp.GDI32.dll_SelectObject)(uVar10, iVar6);\n                (*_sym.imp.GDI32.dll_StretchDIBits)\n                          (uVar10, 0, 0, iVar13, iVar3, 0, 0, iVar13, iVar3, \n                           arg_10h_00 + (1 << (*(arg_8h + 0xe) & 0x1f)) + 10, arg_8h, 0, 0xcc0020);\n                (*pcVar4)(uVar10, uVar11);\n                (*_sym.imp.GDI32.dll_DeleteDC)(uVar10);\n            }\n            (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar9);\n            fcn.004585e6(arg_8h);\n            (*_sym.imp.KERNEL32.dll_FreeResource)(iVar5);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 969
    },
    "0042ceb6": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ceb6(uint32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x20));\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (iVar2 == 0) {\n        *(in_ECX + 0xb0) = arg_8h;\n        *(in_ECX + 0xb4) = arg_ch;\n        *(in_ECX + 0xa8) = arg_10h;\n        *(in_ECX + 0xac) = arg_14h;\n    }\n    else {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0x420, 0, arg_10h & 0xffff | arg_14h << 0x10);\n        (*pcVar1)(*(in_ECX + 0x20), 0x41f, 0, arg_8h & 0xffff | arg_ch << 0x10);\n        if (0x5ffff < *0x49776c) {\n            uVar3 = (*pcVar1)(*(in_ECX + 0x20), 0x43a, 0, 0);\n            *(in_ECX + 0xb0) = uVar3 & 0xffff;\n            *(in_ECX + 0xb4) = uVar3 >> 0x10;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 408
    },
    "0042d15f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042d15f(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint *arg_ch_00;\n    uint var_18h;\n    char var_10h;\n    uint var_fh;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_ch_00 = 0x42d180;\n    fcn.0042c902(arg_8h, &fcn.0042d15f::var_18h);\n    cVar1 = arg_ch >> 0x10;\n    if ((var_fh != arg_ch) || (var_10h != cVar1)) {\n        arg_ch_00 = &fcn.0042d15f::var_18h;\n        var_10h = cVar1;\n        var_fh._0_1_ = arg_ch;\n        fcn.0042cfbd(arg_8h, arg_ch_00);\n        *(in_ECX + 0xa4) = 1;\n    }\n    fcn.0045843c(arg_ch_00);\n    return;\n}\n",
        "token_count": 272
    },
    "0042d480": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042d480(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint *arg_ch_00;\n    uint var_2ch;\n    uint var_18h;\n    uint var_14h;\n    uchar var_10h;\n    uint var_fh;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0042c902(arg_8h, &var_18h);\n    arg_ch_00 = 0x14;\n    uVar1 = fcn.0045850c(&var_2ch, 0x14, &var_18h, 0x14);\n    fcn.00409e60(uVar1);\n    var_14h = arg_ch;\n    var_18h = arg_14h;\n    var_fh._0_1_ = arg_10h;\n    var_10h = arg_10h >> 0x10;\n    iVar2 = fcn.0045b591(&var_2ch, &var_18h, 0x14);\n    if (iVar2 != 0) {\n        arg_ch_00 = &var_18h;\n        fcn.0042cfbd(arg_8h, arg_ch_00);\n        *(in_ECX + 0xa4) = 1;\n    }\n    fcn.0045843c(arg_ch_00);\n    return;\n}\n",
        "token_count": 364
    },
    "0042e803": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0042e803(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x74))(arg_ch, arg_ch >> 0x10, 0);\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(in_ECX[8]);\n        uVar2 = -(iVar1 != 0) & iVar1 + 0x50000U;\n    }\n    else {\n        uVar2 = iVar1 + 0x10000;\n    }\n    return uVar2;\n}\n",
        "token_count": 161
    },
    "00445036": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00445036(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    \n    if (arg_8h == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar3 = fcn.0044a7e2(0x4163aa);\n        if (iVar3 == 0) {\n            fcn.0041638e();\n        }\n        if ((*(iVar3 + 0x18) != 0) && (iVar4 = fcn.0041af40(arg_8h),  iVar4 == 0)) {\n            fcn.0041bc8a(arg_8h);\n            *(iVar3 + 0x18) = 0;\n        }\n        pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n        if (arg_ch == 0x110) {\n            *0x49be24 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"commdlg_LBSelChangedNotify\");\n            *0x49be28 = (*pcVar1)(\"commdlg_ShareViolation\");\n            *0x49be2c = (*pcVar1)(\"commdlg_FileNameOK\");\n            *0x49be30 = (*pcVar1)(\"commdlg_ColorOK\");\n            *0x49be34 = (*pcVar1)(\"commdlg_help\");\n            *0x49be38 = (*pcVar1)(\"commdlg_SetRGBColor\");\n            uVar2 = fcn.0041ebc5(arg_8h, 0x110);\n        }\n        else if ((arg_ch == *0x49be34) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x111, 0xe146, 0);\n            uVar2 = 1;\n        }\n        else {\n            if (((0xbfff < arg_ch) && (piVar5 = fcn.0041af40(arg_8h),  piVar5 != NULL)) &&\n               ((iVar3 = fcn.00424c12(0x47f270),  iVar3 == 0 ||\n                (iVar3 = fcn.0044007e(),  (*(iVar3 + 0x34) & 0x80000) == 0)))) {\n                if (arg_ch == *0x49be28) {\n                    uVar2 = (**(*piVar5 + 0x164))(arg_14h);\n                    return uVar2;\n                }\n                if (arg_ch == *0x49be2c) {\n                    piVar5[0x75] = arg_14h;\n                    uVar2 = (**(*piVar5 + 0x168))();\n                    piVar5[0x75] = 0;\n                    return uVar2;\n                }\n                if (arg_ch == *0x49be24) {\n                    (**(*piVar5 + 0x16c))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                }\n                else if (arg_ch == *0x49be30) {\n                    uVar2 = (**(*piVar5 + 0x164))();\n                    return uVar2;\n                }\n            }\n            uVar2 = 0;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 795
    },
    "004501d3": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __cdecl fcn.004501d3(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    bool bVar5;\n    uint lpMsg;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_44h;\n    int32_t iStack68;\n    int32_t iStack64;\n    int32_t iStack60;\n    int32_t lprc1;\n    int32_t iStack52;\n    int32_t iStack48;\n    int32_t iStack44;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t *var_1ch;\n    int32_t *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *lprc2;\n    \n    iVar3 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar3 == 0) {\n        fcn.0044ac72();\n        piVar1 = in_ECX + 2;\n        var_20h = in_ECX[4] - *piVar1;\n        var_24h = in_ECX[5] - in_ECX[3];\n        lprc2 = piVar1;\n        uVar4 = (*_sym.imp.USER32.dll_SetCapture)(*(arg_ch + 0x20));\n        fcn.0041af14(uVar4);\n        pcVar2 = _sym.imp.USER32.dll_UpdateWindow;\n        (*_sym.imp.USER32.dll_UpdateWindow)(*(arg_ch + 0x20));\n        if (arg_18h != 0) {\n            (*pcVar2)(*(arg_18h + 0x20));\n        }\n        var_44h = *piVar1;\n        iStack68 = in_ECX[3];\n        iStack64 = in_ECX[4];\n        iStack60 = in_ECX[5];\n        fcn.0044fcae(arg_8h, &var_18h, &var_1ch, &var_10h, &var_14h);\n        var_10h = arg_10h - var_10h;\n        var_14h = arg_14h - var_14h;\n        if (arg_18h == 0) {\n            uVar4 = (*_sym.imp.USER32.dll_GetDC)(*(arg_ch + 0x20));\n            var_8h = fcn.0041749a(uVar4);\n        }\n        else {\n            var_8h = fcn.0044f745(0, 2);\n        }\n        if (var_8h == 0) {\n            fcn.0041638e();\n        }\n        var_ch = 0;\n        do {\n            while( true ) {\n                (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                uVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n                iVar3 = fcn.0041af14(uVar4);\n                if (iVar3 != arg_ch) goto code_r0x00450405;\n                if (var_5ch == 0x100) break;\n                if ((var_5ch == 0x200) || (var_5ch == 0x202)) {\n                    lprc1 = *lprc2;\n                    iStack52 = lprc2[1];\n                    iStack48 = lprc2[2];\n                    iStack44 = lprc2[3];\n                    if (var_18h != NULL) {\n                        *var_18h = var_54h - var_10h;\n                    }\n                    if (var_1ch != NULL) {\n                        *var_1ch = (var_54h >> 0x10) - var_14h;\n                    }\n                    if (arg_8h == 8) {\n                        in_ECX[4] = *lprc2 + var_20h;\n                        in_ECX[5] = in_ECX[3] + var_24h;\n                    }\n                    (**(*in_ECX + 4))(arg_8h, lprc2);\n                    in_ECX[0x11] = var_5ch == 0x202;\n                    iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lprc1, lprc2);\n                    if ((iVar3 == 0) || (in_ECX[0x11] != 0)) {\n                        if (var_ch != 0) {\n                            in_ECX[0x10] = 1;\n                            (***in_ECX)(&lprc1, arg_18h, var_8h, arg_ch);\n                        }\n                        (**(*in_ECX + 8))(&lprc1);\n                        if (var_5ch != 0x202) {\n                            var_ch = 1;\n                        }\n                        if (in_ECX[0x11] != 0) goto code_r0x00450405;\n                    }\n                    iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lprc1, lprc2);\n                    if (iVar3 == 0) {\n                        in_ECX[0x10] = 0;\n                        (***in_ECX)(lprc2, arg_18h, var_8h, arg_ch);\n                    }\n                }\n                else {\n                    if (var_5ch == 0x204) goto code_r0x004503d9;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n            }\n        } while (var_58h != 0x1b);\ncode_r0x004503d9:\n        if (var_ch != 0) {\n            in_ECX[0x11] = 1;\n            in_ECX[0x10] = 1;\n            (***in_ECX)(lprc2, arg_18h, var_8h, arg_ch);\n        }\n        *lprc2 = var_44h;\n        lprc2[1] = iStack68;\n        lprc2[2] = iStack64;\n        lprc2[3] = iStack60;\ncode_r0x00450405:\n        fcn.0044f72d(var_8h);\n        (*_sym.imp.USER32.dll_ReleaseCapture)();\n        fcn.0044ae8a(0);\n        if (var_ch == 0) {\n            *lprc2 = var_44h;\n            lprc2[1] = iStack68;\n            lprc2[2] = iStack64;\n            lprc2[3] = iStack60;\n        }\n        in_ECX[0x11] = 0;\n        in_ECX[0x10] = 0;\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&var_44h, lprc2);\n        bVar5 = iVar3 == 0;\n    }\n    else {\n        bVar5 = false;\n    }\n    return bVar5;\n}\n",
        "token_count": 1650
    },
    "00466640": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t * fcn.00466640(uint32_t *param_1, char param_2)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar1 = param_1 & 3;\n    while (uVar1 != 0) {\n        if (*param_1 == param_2) {\n            return param_1;\n        }\n        if (*param_1 == '\\0') {\n            return NULL;\n        }\n        uVar1 = param_1 + 1 & 3;\n        param_1 = param_1 + 1;\n    }\n    while( true ) {\n        while( true ) {\n            uVar1 = *param_1;\n            uVar4 = uVar1 ^ CONCAT22(CONCAT11(param_2, param_2), CONCAT11(param_2, param_2));\n            uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;\n            puVar5 = param_1 + 1;\n            if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;\n            param_1 = puVar5;\n            if ((uVar3 & 0x81010100) != 0) {\n                if ((uVar3 & 0x1010100) != 0) {\n                    return NULL;\n                }\n                if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {\n                    return NULL;\n                }\n            }\n        }\n        uVar1 = *param_1;\n        if (uVar1 == param_2) {\n            return param_1;\n        }\n        if (uVar1 == '\\0') {\n            return NULL;\n        }\n        cVar2 = uVar1 >> 8;\n        if (cVar2 == param_2) {\n            return param_1 + 1;\n        }\n        if (cVar2 == '\\0') break;\n        cVar2 = uVar1 >> 0x10;\n        if (cVar2 == param_2) {\n            return param_1 + 2;\n        }\n        if (cVar2 == '\\0') {\n            return NULL;\n        }\n        cVar2 = uVar1 >> 0x18;\n        if (cVar2 == param_2) {\n            return param_1 + 3;\n        }\n        param_1 = puVar5;\n        if (cVar2 == '\\0') {\n            return NULL;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 590
    },
    "004031f0": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint32_t fcn.004031f0(uint32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar uVar4;\n    \n    if (param_1 < 0x800e) {\n        fcn.0041638e();\n    }\n    uVar4 = param_1 == 0x801e;\n    if (0x801e < param_1) {\n        fcn.0041638e();\n    }\n    if (!uVar4) {\n        uVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0xf);\n        iVar3 = fcn.0041776c(uVar2);\n        if (iVar3 == 0) {\n            iVar3 = fcn.0041638e();\n        }\n        iVar3 = (*_sym.imp.GDI32.dll_GetPaletteEntries)(*(iVar3 + 4), *(param_1 * 4 + 0x476218), 1, &stack0xfffffffc);\n        if (iVar3 != 0) {\n            return ((param_1 >> 0x10 & 0xff) << 8 | param_1 >> 8 & 0xff) << 8 | param_1 & 0xff;\n        }\n    }\n    uVar1 = (*_sym.imp.USER32.dll_GetSysColor)(8);\n    return uVar1;\n}\n",
        "token_count": 306
    },
    "00412cb0": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool fcn.00412cb0(int32_t *param_1, int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    uVar1 = 0x10;\n    do {\n        if (*param_1 != *param_2) {\n            iVar2 = *param_1 - *param_2;\n            if (((iVar2 == 0) && (iVar2 = *(param_1 + 1) - *(param_2 + 1),  iVar2 == 0)) &&\n               (iVar2 = *(param_1 + 2) - *(param_2 + 2),  iVar2 == 0)) {\n                iVar2 = *(param_1 + 3) - *(param_2 + 3);\n            }\n            return (iVar2 >> 0x1f | 1U) == 0;\n        }\n        uVar1 = uVar1 - 4;\n        param_2 = param_2 + 1;\n        param_1 = param_1 + 1;\n    } while (3 < uVar1);\n    return true;\n}\n",
        "token_count": 247
    },
    "004158de": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004158de(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    uint var_64h;\n    uint lpExistingFileName;\n    uint lpNewFileName;\n    uint var_58h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_4h;\n    \n    fcn.0045afa4(0x5c);\n    piVar1 = *(unaff_EBP + 0xc);\n    piVar2 = *(unaff_EBP + 0x10);\n    if (*piVar1 == 0) {\n        iVar4 = *piVar2;\n        if (iVar4 == 1) {\ncode_r0x00415928:\n            *piVar1 = iVar4;\n        }\n        else {\n            if (iVar4 == 2) {\n                *piVar1 = 2;\n                iVar4 = piVar2[1];\n                if (iVar4 == 0) {\n                    iVar4 = fcn.0041638e();\n                }\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4);\n                *(unaff_EBP + -0x60) = iVar4;\n                iVar4 = fcn.00414f41(iVar4 + 1, 2);\n                piVar1[1] = iVar4;\n                if (iVar4 != 0) {\n                    iVar5 = *(unaff_EBP + -0x60) * 2 + 2;\n                    fcn.00414fcb(iVar4, iVar5, piVar2[1], iVar5);\n                }\n                goto code_r0x00415b57;\n            }\n            if (iVar4 == 4) {\n                piVar2 = piVar2[1];\n                piVar1[1] = piVar2;\n                (**(*piVar2 + 4))(piVar2);\n                *piVar1 = 4;\n                goto code_r0x00415b57;\n            }\n            if (iVar4 == 8) {\n                piVar2 = piVar2[1];\n                piVar1[1] = piVar2;\n                (**(*piVar2 + 4))(piVar2);\n                *piVar1 = 8;\n                goto code_r0x00415b57;\n            }\n            if (iVar4 != 0x10) {\n                if (iVar4 == 0x20) {\n                    iVar4 = fcn.004151c2(0, piVar2[1]);\n                    *(unaff_EBP + -0x5c) = iVar4;\n                    if (iVar4 != 0) {\n                        iVar4 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar4);\n                        iVar5 = (*_sym.imp.GDI32.dll_CopyMetaFileA)(*(iVar4 + 0xc), 0);\n                        *(iVar4 + 0xc) = iVar5;\n                        if (iVar5 == 0) {\n                            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x5c));\n                            (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x5c));\n                        }\n                        else {\n                            iVar4 = *(unaff_EBP + -0x5c);\n                            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar4);\n                            piVar1[1] = iVar4;\n                            *piVar1 = 0x20;\n                        }\n                    }\n                    goto code_r0x00415b57;\n                }\n                if (iVar4 != 0x40) goto code_r0x00415b57;\n                goto code_r0x00415928;\n            }\n            *piVar1 = 0x10;\n        }\n        piVar1[1] = 0;\n    }\n    iVar4 = *piVar2;\n    if (iVar4 == 1) {\n        iVar4 = fcn.004151c2(piVar1[1], piVar2[1]);\n        if (iVar4 != 0) {\n            piVar1[1] = iVar4;\n        }\n    }\n    else if (iVar4 == 2) {\n        fcn.0041589a(piVar1[1]);\n        iVar4 = piVar1[1];\n        *(unaff_EBP + -4) = 0;\n        fcn.0041589a(iVar4);\n        (*_sym.imp.KERNEL32.dll_CopyFileA)\n                  (-(piVar2[1] != 0) & *(unaff_EBP + -0x60), -(piVar1[1] != 0) & *(unaff_EBP + -0x5c), 0);\n        fcn.004010f0();\n        fcn.004010f0();\n    }\n    else if (iVar4 == 4) {\n        iVar4 = (**(*piVar2[1] + 0x30))(piVar2[1], unaff_EBP + -0x58, 1);\n        if (iVar4 == 0) {\n            piVar3 = piVar1[1];\n            iVar4 = *piVar3;\n            *(unaff_EBP + -100) = 0;\n            (**(iVar4 + 0x14))(piVar3, 0, 0, 0, 0);\n            (**(*piVar2[1] + 0x14))(piVar2[1], 0, 0, 0, 0);\n            iVar4 = (**(*piVar2[1] + 0x1c))(piVar2[1], piVar1[1], *(unaff_EBP + -0x50), *(unaff_EBP + -0x4c), 0, 0);\n            if (iVar4 == 0) {\n                (**(*piVar1[1] + 0x14))(piVar1[1], 0, 0, 0, 0);\n                (**(*piVar2[1] + 0x14))(piVar2[1], 0, 0, 0, 0);\n            }\n        }\n    }\n    else if (iVar4 == 8) {\n        (**(*piVar2[1] + 0x1c))(piVar2[1], 0, 0, 0, piVar1[1]);\n    }\n    else if (((iVar4 == 0x10) || (iVar4 == 0x40)) && (piVar1[1] == 0)) {\n        iVar4 = (*_sym.imp.ole32.dll_OleDuplicateData)(piVar2[1], *(unaff_EBP + 8), 0);\n        piVar1[1] = iVar4;\n    }\ncode_r0x00415b57:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 1551
    },
    "0044b07c": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044b07c(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.0041ff5e();\n    if ((iVar2 != 0) && (*(iVar2 + 0xc) != 0)) {\n        uVar3 = fcn.0045dcbf(*(iVar2 + 0xc));\n        if (arg_8h + 4U < uVar3) {\n            fcn.0045dde1(*(iVar2 + 0xc), (uVar3 - arg_8h) + -4);\n        }\n        else {\n            fcn.004585e6(*(iVar2 + 0xc));\n            *(iVar2 + 0xc) = 0;\n        }\n        return 1;\n    }\n    fcn.00416356();\n    pcVar1 = swi(3);\n    uVar4 = (*pcVar1)();\n    return uVar4;\n}\n",
        "token_count": 232
    },
    "00403fc0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00403fc0(uint param_1)\n\n{\n    uchar auStack140 [136];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ auStack140;\n    (*_sym.imp.KERNEL32.dll_OpenFile)(param_1, auStack140, 0x4000);\n    fcn.0045843c(param_1);\n    return;\n}\n",
        "token_count": 91
    },
    "004054d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004054d0(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uint arg_8h;\n    uchar auStack16 [12];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ auStack16;\n    fcn.00405450();\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    arg_8h = 0xffffffff;\n    iVar2 = (*_sym.imp.USER32.dll_SendMessageA)();\n    if (iVar2 == -1) {\n        iVar2 = 0;\n        puVar3 = (*pcVar1)(*(param_1 + 0x20), 0x150, 0, 0);\n        while ((iVar4 = -1,  puVar3 != 0xffffffff && (iVar4 = iVar2,  puVar3 <= &stack0xffffffe8))) {\n            iVar2 = iVar2 + 1;\n            puVar3 = (*pcVar1)(*(param_1 + 0x20), 0x150, iVar2, 0);\n        }\n        iVar2 = (*pcVar1)(*(param_1 + 0x20), 0x14a, iVar4, &stack0xffffffc8);\n        if (iVar2 != -1) {\n            (*pcVar1)(*(param_1 + 0x20), 0x151);\n        }\n    }\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 352
    },
    "00405590": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405590(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    uint arg_ch;\n    \n    arg_ch = 0;\n    arg_8h = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x20), 0x147, 0, 0);\n    if (arg_8h == -1) {\n        fcn.0041c2d9(arg_ch);\n        return;\n    }\n    fcn.0041e48e(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 129
    },
    "00409070": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00409070(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    \n    if (param_2 == -1) {\n        param_2 = *param_1;\n        if (param_2 != 0) {\n            param_2 = fcn.0045905c(param_2, *(param_2 + -8));\n            goto code_r0x0040908f;\n        }\n    }\n    else {\ncode_r0x0040908f:\n        if (param_2 < 0) goto code_r0x004090a7;\n    }\n    if (param_2 <= *(*param_1 + -8)) {\n        *(*param_1 + -0xc) = param_2;\n        *(param_2 + *param_1) = 0;\n        return;\n    }\ncode_r0x004090a7:\n    fcn.00401000(0x80070057);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 234
    },
    "0040abc0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040abc0(code **param_1, uint param_2, uint param_3)\n\n{\n    uint32_t arg_8h;\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t **in_FS_OFFSET;\n    uchar auStack160 [4];\n    code **appcStack156 [32];\n    int32_t *piStack28;\n    uchar uStack24;\n    uchar uStack20;\n    uint32_t uStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f8c6;\n    piStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ auStack160;\n    arg_8h = *0x4987a4 ^ &stack0xffffff54;\n    *in_FS_OFFSET = &piStack12;\n    appcStack156[0] = param_1;\n    fcn.0040aa30(param_3);\n    uStack8 = 0;\n    *param_1 = vtable.CConverter.0;\n    param_1[0x13] = NULL;\n    param_1[0xf] = NULL;\n    param_1[0xd] = NULL;\n    param_1[0xe] = NULL;\n    param_1[10] = NULL;\n    param_1[0x10] = NULL;\n    param_1[0x11] = NULL;\n    param_1[0xb] = 0x1;\n    param_1[0xc] = NULL;\n    param_1[0x14] = NULL;\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenFile)(param_2, appcStack156, 0x4000);\n    if (iVar1 != -1) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(param_2);\n        param_1[0x15] = pcVar2;\n        if (0x1f < pcVar2) {\n            fcn.0040a1a0();\n            if (param_1[0x16] == NULL) goto code_r0x0040acf0;\n            iVar1 = fcn.0042052a();\n            fcn.00404920(*(iVar1 + 0x10));\n            uStack24 = 1;\n            fcn.0040a9d0();\n            piVar3 = fcn.004379b3();\n            if (piVar3 == NULL) {\ncode_r0x0040acbb:\n                uVar4 = 0;\n            }\n            else {\n                iVar1 = (**(*piVar3 + 0x74))();\n                if (iVar1 == 0) goto code_r0x0040acbb;\n                uVar4 = *(iVar1 + 0x20);\n            }\n            (*param_1[0x16])(uVar4, param_3);\n            uStack20 = 0;\n            piVar3 = arg_8h - 4;\n            LOCK();\n            iVar1 = *piVar3;\n            *piVar3 = *piVar3 + -1;\n            if (iVar1 == 1 || iVar1 + -1 < 0) {\n                (**(**(arg_8h - 0x10) + 4))(arg_8h - 0x10);\n            }\n            goto code_r0x0040acf0;\n        }\n    }\n    param_1[0x15] = NULL;\ncode_r0x0040acf0:\n    *in_FS_OFFSET = piStack28;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 831
    },
    "0040ff10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040ff10(int32_t *param_1, uint param_2, uint param_3, int32_t param_4, uint param_5)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t **in_FS_OFFSET;\n    uint *puVar6;\n    uint *arg_8h;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint auStack516 [114];\n    int32_t *piStack60;\n    uint uStack52;\n    uchar uStack40;\n    uint32_t uStack36;\n    uint uStack28;\n    uint32_t uStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x47002c;\n    piStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ auStack516;\n    *in_FS_OFFSET = &piStack12;\n    auStack516[0] = param_5;\n    fcn.00404080();\n    iVar10 = 0;\n    iVar9 = 0;\n    iVar8 = 6;\n    iVar7 = 0;\n    puVar6 = NULL;\n    fcn.00440962(param_4, 0, 0, 6, 0, 0, 0, 1);\n    uStack36 = 0;\n    piVar2 = fcn.0041f6b5();\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar2 + 0xc))();\n    iVar3 = iVar3 + 0x10;\n    uStack40 = 1;\n    iVar4 = fcn.0041f625(uStack28);\n    if (iVar4 != 0) {\n        iVar3 = iVar10;\n        fcn.004022e0(iVar4, uStack28);\n    }\n    iVar10 = fcn.0044007e();\n    *(iVar10 + 0x34) = *(iVar10 + 0x34) | uStack36;\n    iVar10 = *(iVar8 + 0x160);\n    if (param_4 == 0) {\n        if (puVar6 == NULL) {\n            uVar5 = 2;\n        }\n        else {\n            uVar5 = *puVar6;\n        }\n        iVar10 = fcn.00404130(uVar5, 0);\n        if (iVar10 == -1) {\n            iVar10 = fcn.00404130(2, 0);\n            if (iVar10 == -1) {\n                iVar10 = fcn.00404130(4, 0);\n            }\n        }\n        iVar10 = iVar10 + 1;\n    }\n    iVar4 = fcn.0044007e();\n    *(iVar4 + 0x18) = iVar10;\n    uVar5 = fcn.004040e0(iVar10 + -1, param_4);\n    fcn.00404680(&stack0xfffffdd8, uVar5);\n    uStack52._0_1_ = 2;\n    iVar10 = iVar9;\n    iVar4 = fcn.0044007e();\n    *(iVar4 + 0x3c) = iVar9;\n    fcn.00404740(&stack0xfffffdd0, param_4);\n    uStack52 = CONCAT31(uStack52._1_3_, 3);\n    iVar9 = iVar7;\n    iVar4 = fcn.0044007e();\n    *(iVar4 + 0xc) = iVar7;\n    iVar7 = fcn.0044007e();\n    *(iVar7 + 0x30) = iVar3;\n    if ((*(*param_1 + -8) - 0x104U | 1U - *(*param_1 + -4)) < 0) {\n        fcn.004019e0(0x104);\n    }\n    iVar7 = *param_1;\n    iVar4 = fcn.0044007e();\n    *(iVar4 + 0x1c) = iVar7;\n    iVar4 = fcn.0044114a();\n    iVar7 = *param_1;\n    if (iVar7 != 0) {\n        iVar7 = fcn.0045905c(iVar7, *(iVar7 + -8));\n        if (iVar7 < 0) goto code_r0x0041021d;\n    }\n    if (iVar7 <= *(*param_1 + -8)) {\n        *(*param_1 + -0xc) = iVar7;\n        *(iVar7 + *param_1) = 0;\n        arg_8h = puVar6;\n        if (iVar4 == 1) {\n            if (param_4 != 0) {\n                iVar7 = fcn.0044007e();\n                *(iVar8 + 0x160) = *(iVar7 + 0x18);\n            }\n            arg_8h = puVar6;\n            if (puVar6 != NULL) {\n                iVar7 = fcn.0044007e();\n                uVar5 = fcn.004040e0(*(iVar7 + 0x18) + -1, param_4);\n                *puVar6 = uVar5;\n            }\n        }\n        uStack52._0_1_ = 2;\n        piVar2 = iVar9 + -4;\n        LOCK();\n        iVar7 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar7 == 1 || iVar7 + -1 < 0) {\n            (**(**(iVar9 + -0x10) + 4))(iVar9 + -0x10);\n        }\n        uStack52._0_1_ = 1;\n        piVar2 = iVar10 + -4;\n        LOCK();\n        iVar7 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar7 + -1 < 1) {\n            (**(**(iVar10 + -0x10) + 4))(iVar10 + -0x10);\n        }\n        uStack52 = uStack52._1_3_ << 8;\n        piVar2 = iVar3 + -4;\n        LOCK();\n        iVar7 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar7 == 1 || iVar7 + -1 < 0) {\n            (**(**(iVar3 + -0x10) + 4))(iVar3 + -0x10);\n        }\n        uStack52 = 0xffffffff;\n        fcn.0044076a();\n        *in_FS_OFFSET = piStack60;\n        fcn.0045843c(arg_8h);\n        return;\n    }\ncode_r0x0041021d:\n    fcn.00401000(0x80070057);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 1601
    },
    "00411ea0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00411ea0(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (param_1 != -1) {\n        uVar1 = fcn.00411e20(param_1);\n        iVar2 = fcn.00411bb0();\n        if (iVar2 != 0) {\n            iVar3 = fcn.0041b98e();\n            if (iVar3 == 0) {\n                iVar3 = fcn.0041638e();\n            }\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x20), 0x400, 0, uVar1);\n            iVar3 = fcn.0040e5e0(uVar1);\n            *(iVar3 + 0x90) = *(iVar2 + 0x60);\n        }\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "00411f00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00411f00(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1 != -1) {\n        uVar1 = fcn.00411e20(param_1);\n        piVar2 = fcn.00411bb0();\n        if (piVar2 != NULL) {\n            iVar3 = fcn.0041b98e();\n            if (iVar3 == 0) {\n                iVar3 = fcn.0041638e();\n            }\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x20), 0x400, 1, uVar1);\n            iVar3 = fcn.0040e5e0(uVar1);\n            if (piVar2[0x18] != *(iVar3 + 0x90)) {\n                piVar2[0x18] = *(iVar3 + 0x90);\n                (**(*piVar2 + 0x1a0))();\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 243
    },
    "00414f1d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414f1d(uint *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    if (arg_ch * arg_10h >> 0x20 != 0) {\n        return 0x80070057;\n    }\n    *arg_8h = arg_ch * arg_10h;\n    return 0;\n}\n",
        "token_count": 86
    },
    "00415083": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415083(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    if (arg_14h == -1) {\n        arg_14h = fcn.0045ae91(arg_10h);\n        arg_14h = arg_14h + 1;\n    }\n    fcn.00414fec(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 110
    },
    "0041dce6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041dce6(uint16_t *arg_8h)\n\n{\n    code *pcVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint16_t *puVar4;\n    uint *puVar5;\n    uint var_34h;\n    uint var_30h;\n    uint16_t *var_2ch;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendDlgItemMessageA;\n    var_4h = 1;\n    puVar4 = arg_8h;\n    var_8h = in_ECX;\n    if (arg_8h != NULL) {\n        do {\n            if (*puVar4 == 0) break;\n            var_ch = *puVar4;\n            uVar2 = puVar4[1];\n            var_10h = *(puVar4 + 2);\n            puVar4 = puVar4 + 4;\n            if (uVar2 == 0x1234) {\ncode_r0x0041dd60:\n                puVar5 = &var_30h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                var_30h = 0xffffffff;\n                var_34h = 1;\n                fcn.00404920(puVar4);\n                var_2ch = arg_8h;\n                iVar3 = (*pcVar1)(*(var_8h + 0x20), var_ch & 0xffff, 0x401, 0, &var_34h);\n                if (iVar3 == -1) {\n                    var_4h = 0;\n                }\n                fcn.004010f0();\n            }\n            else if (uVar2 == 0x401) {\n                uVar2 = 0x180;\ncode_r0x0041ddc4:\n                iVar3 = (*pcVar1)(*(var_8h + 0x20), var_ch, uVar2, 0, puVar4);\n                if (iVar3 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                if (uVar2 == 0x403) {\n                    uVar2 = 0x143;\n                }\n                if (uVar2 == 0x401) goto code_r0x0041dd60;\n                if ((uVar2 == 0x180) || (uVar2 == 0x143)) goto code_r0x0041ddc4;\n            }\n            puVar4 = puVar4 + var_10h;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.0041ba0e(*(var_8h + 0x20), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 712
    },
    "0041fb58": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0041fb58(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    fcn.004024c0(*(unaff_EBP + 8));\n    arg_10h_00 = *(unaff_EBP + 0x10);\n    if (arg_10h_00 == -1) {\n        arg_10h_00 = *(unaff_EBP + 8);\n    }\n    fcn.0041fb0a(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), arg_10h_00);\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 258
    },
    "0041ff77": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041ff77(void)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_STATE.0;\n    puVar1 = extraout_ECX[0x12];\n    *(unaff_EBP + -4) = 1;\n    if (puVar1 != NULL) {\n        (***puVar1)(1);\n    }\n    if (extraout_ECX[0x1c] != NULL) {\n        (**(*extraout_ECX[0x1c] + 0xc))(extraout_ECX + 0x13);\n        if (extraout_ECX[0x1c] != NULL) {\n            (**(*extraout_ECX[0x1c] + 4))(1);\n        }\n    }\n    if (*extraout_ECX[0x1e] != NULL) {\n        (****extraout_ECX[0x1e])(1);\n    }\n    if (*(extraout_ECX[0x1e] + 4) != NULL) {\n        (****(extraout_ECX[0x1e] + 4))(1);\n    }\n    fcn.00414b30(extraout_ECX[0x1e]);\n    pcVar2 = extraout_ECX[0x20];\n    if ((pcVar2 != NULL) && (pcVar2 != 0xffffffff)) {\n        fcn.0041fc32(pcVar2);\n        extraout_ECX[0x20] = 0xffffffff;\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0044a86c();\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 458
    },
    "0042094a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042094a(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    int32_t *piVar4;\n    \n    if ((arg_8h != -1) && (arg_8h_00 = 0,  arg_8h != 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        uVar1 = fcn.0041af14(uVar1);\n        iVar2 = fcn.00424c30(0x47b7a8, uVar1);\n        if ((iVar2 != 0) && (piVar4 = *(iVar2 + 0x74),  0 < *(iVar2 + 0x90))) {\n            do {\n                iVar3 = fcn.004208a6(arg_8h_00);\n                if (*(*(iVar3 + 0x74) + 0xc) == arg_8h) {\n                    return piVar4[3];\n                }\n                piVar4 = piVar4 + *piVar4;\n                arg_8h_00 = arg_8h_00 + 1;\n            } while (arg_8h_00 < *(iVar2 + 0x90));\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 326
    },
    "00422ef1": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00422ef1(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00422151(arg_8h, arg_ch);\n    if (iVar1 != -1) {\n        fcn.00412e70(arg_ch + 0xc);\n    }\n    return iVar1;\n}\n",
        "token_count": 85
    },
    "00423660": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00423660(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t arg_8h_00;\n    bool bVar3;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    \n    fcn.00412e50(&var_14h);\n    if (*(in_ECX + 0x84) != 0) {\n        if (arg_14h == 0) {\n            *(in_ECX + 0x7c) = var_10h;\n        }\n        else {\n            *(in_ECX + 0x7c) = var_14h;\n        }\n        *(in_ECX + 0x84) = 0;\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    var_ch = arg_8h;\n    if (var_14h != var_10h) {\n        if (arg_14h == 0) {\n            if (var_14h < 1) {\n                var_14h = 0;\n            }\n        }\n        else {\n            var_14h = var_14h + 1;\n        }\n    }\n    arg_8h_00 = -(arg_ch != 0) & 4 | -(arg_10h != 0) & 2;\n    var_10h = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0xe, 0, 0);\n    iVar2 = *(in_ECX + 0x7c);\n    var_10h = var_10h + iVar2;\n    if (arg_14h == 0) {\n        if (-1 < iVar2) {\n            var_10h = 0;\n        }\n    }\n    else {\n        if (-1 < iVar2) {\n            var_10h = (*pcVar1)(*(in_ECX + 0x20), 0xe, 0, 0);\n        }\n        arg_8h_00 = arg_8h_00 | 1;\n    }\n    iVar2 = fcn.00422ef1(arg_8h_00, &var_14h);\n    if (iVar2 == -1) {\n        if (*(in_ECX + 0x7c) < 1) {\n            bVar3 = false;\n        }\n        else {\n            if (arg_14h == 0) {\n                var_14h = (*pcVar1)(*(in_ECX + 0x20), 0xe, 0, 0);\n                var_10h = *(in_ECX + 0x7c);\n            }\n            else {\n                var_14h = 0;\n                var_10h = *(in_ECX + 0x7c);\n            }\n            iVar2 = (*pcVar1)(*(in_ECX + 0x20), 0xe, 0, 0);\n            *(in_ECX + 0x7c) = *(in_ECX + 0x7c) - iVar2;\n            iVar2 = fcn.00422ef1(arg_8h_00, &var_14h);\n            bVar3 = iVar2 != -1;\n        }\n    }\n    else {\n        bVar3 = true;\n    }\n    return bVar3;\n}\n",
        "token_count": 770
    },
    "0042afcc": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042afcc(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    bool bVar2;\n    uint arg_ch;\n    \n    bVar2 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar2 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.004018d0();\n    if (bVar2) {\n        arg_ch = *(param_1 + 0xc);\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.00438850(arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "0042b011": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042b011(int32_t param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 4) != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        *(param_1 + 4) = 0xffffffff;\n    }\n    piVar3 = param_1 + 0xc;\n    iVar5 = *piVar3;\n    ppiVar1 = iVar5 + -0x10;\n    piVar4 = *ppiVar1;\n    if (*(iVar5 + -0xc) != 0) {\n        piVar2 = iVar5 + -4;\n        if (*(iVar5 + -4) < 0) {\n            if (*(iVar5 + -8) < 0) {\n                fcn.00401000(0x80070057);\n                iVar5 = extraout_ECX;\n            }\n            *(iVar5 + -0xc) = 0;\n            **piVar3 = 0;\n            return;\n        }\n        LOCK();\n        iVar5 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar5 == 1 || iVar5 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1);\n        }\n        iVar5 = (**(*piVar4 + 0xc))();\n        *piVar3 = iVar5 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 371
    },
    "0042b1bf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.0042b1bf(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_21ch;\n    uint var_4h;\n    \n    fcn.0045afda(0x214);\n    *(unaff_EBP + -0x21c) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    pcVar1 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    if ((pcVar1 != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.0042afcc();\n    }\n    fcn.004010f0();\n    fcn.0045b036();\n    return;\n}\n",
        "token_count": 195
    },
    "0042ba76": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0042ba76(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, uint32_t arg_18h, uint32_t arg_1ch, \n            uint arg_20h)\n\n{\n    uint *in_ECX;\n    int64_t iVar1;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    if (0x76b < arg_8h) goto code_r0x0042ba94;\n    do {\n        do {\n            fcn.00401000();\ncode_r0x0042ba94:\n        } while ((((0xb < arg_ch - 1U) || (0x1e < arg_10h - 1U)) || (0x17 < arg_14h)) ||\n                ((0x3b < arg_18h || (0x3b < arg_1ch))));\n        var_24h = arg_1ch;\n        var_10h = arg_8h + -0x76c;\n        var_4h = arg_20h;\n        var_14h = arg_ch + -1;\n        var_20h = arg_18h;\n        var_1ch = arg_14h;\n        var_18h = arg_10h;\n        iVar1 = fcn.0045d1ab(&var_24h);\n        *in_ECX = iVar1;\n        in_ECX[1] = iVar1 >> 0x20;\n    } while (iVar1 == -1);\n    return;\n}\n",
        "token_count": 394
    },
    "0042c63e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.0042c63e(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_8h;\n    uint hDC;\n    \n    if (*0x497770 == -1) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n        var_8h = 0;\n        uVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x48, 0, 0, 0, 400, 0, 0, 0, 2, 0, 0, 0, 0, \"Marlett\");\n        iVar4 = (*_sym.imp.GDI32.dll_CreateFontA)(uVar3);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        if (iVar4 != 0) {\n            var_8h = (*_sym.imp.GDI32.dll_SelectObject)(uVar2, iVar4);\n        }\n        (*_sym.imp.GDI32.dll_GetCharWidthA)(uVar2, 0x36, 0x36, 0x497770);\n        if (iVar4 != 0) {\n            (*pcVar1)(uVar2, var_8h);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar4);\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    return *0x497770;\n}\n",
        "token_count": 327
    },
    "0042da14": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0042da14(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar4 = *0x49776c;\n    if (*0x49776c == -1) {\n        fcn.0042052a();\n        uVar1 = fcn.0041ac5f();\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"DllGetVersion\");\n        iVar4 = 0x40000;\n        if (pcVar2 != NULL) {\n            fcn.00458b20(&var_14h, 0, 0x14);\n            var_14h = 0x14;\n            iVar3 = (*pcVar2)(&var_14h);\n            if (-1 < iVar3) {\n                iVar4 = CONCAT22(var_10h, var_ch);\n            }\n        }\n    }\n    *0x49776c = iVar4;\n    return iVar4;\n}\n",
        "token_count": 257
    },
    "0042e95c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0042e95c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    \n    iVar1 = fcn.0041ae6e();\n    if (iVar1 != -1) {\n        if ((*(param_1 + 0x84) & 0x10) != 0) {\n            fcn.0044f456(1);\n        }\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x20));\n        piVar3 = fcn.0041af14(uVar2);\n        iVar1 = (**(*piVar3 + 0x128))();\n        if (iVar1 != 0) {\n            *(param_1 + 0x8c) = piVar3;\n            fcn.0044b900(param_1);\n        }\n        iVar1 = fcn.00424c12(0x47ca48);\n        if (((iVar1 != 0) || (iVar1 = fcn.00424c12(0x47dfd8),  iVar1 != 0)) && (iVar1 = fcn.0044f4c6(),  iVar1 != 0)) {\n            uVar2 = fcn.0044f50c(*(param_1 + 0x20), L\"REBAR\");\n            *(param_1 + 0x7c) = uVar2;\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 341
    },
    "00431455": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00431455(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.0041ae6e();\n    if ((iVar1 != -1) && (iVar1 = (**(*in_ECX + 0x174))(arg_8h, arg_ch),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_PostMessageA)(in_ECX[8], 0x362, 0xe001, 0);\n        (**(*in_ECX + 0x150))(1);\n        return 0;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 151
    },
    "004326d9": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004326d9(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == -1) {\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x20));\n        if (iVar1 == 0) {\n            arg_8h = 1;\n        }\n        else {\n            iVar1 = (*_sym.imp.USER32.dll_IsIconic)(*(in_ECX + 0x20));\n            if (iVar1 != 0) {\n                arg_8h = 9;\n            }\n        }\n    }\n    fcn.00430e62(arg_8h);\n    if (arg_8h != -1) {\n        fcn.00418160(arg_8h);\n        fcn.00430e62(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "00440740": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00440740(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    if (arg_8h == -1) {\n        arg_8h = fcn.00440097(*in_ECX, *(*in_ECX + -8));\n    }\n    fcn.00415667(arg_8h);\n    return;\n}\n",
        "token_count": 84
    },
    "00444b44": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444b44(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint var_4h;\n    \n    if (*0x497fa4 == -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetProfileIntA)(\"MAIL\", \"MAPI\", 0);\n        if (iVar1 != 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_SearchPathA)(0, \"MAPI32.DLL\", 0, 0, 0, 0);\n            *0x497fa4 = 1;\n            if (iVar1 != 0) goto code_r0x00444b91;\n        }\n        *0x497fa4 = 0;\n    }\ncode_r0x00444b91:\n    (***arg_8h)(*0x497fa4);\n    iVar1 = arg_8h[3];\n    if ((*0x497fa4 == 0) && (iVar1 != 0)) {\n        uVar2 = (*_sym.imp.USER32.dll_GetMenuState)(*(iVar1 + 4), arg_8h[2] + -1, 0x400);\n        uVar3 = (*_sym.imp.USER32.dll_GetMenuState)(*(iVar1 + 4), arg_8h[2] + 1, 0x400);\n        (*_sym.imp.USER32.dll_RemoveMenu)(*(iVar1 + 4), arg_8h[2], 0x400);\n        if ((uVar3 & uVar2 & 0x800) != 0) {\n            if (uVar2 == 0xffffffff) {\n                if (uVar3 == 0xffffffff) {\n                    return;\n                }\n                iVar4 = arg_8h[2];\n            }\n            else {\n                iVar4 = arg_8h[2] + -1;\n            }\n            (*_sym.imp.USER32.dll_RemoveMenu)(*(iVar1 + 4), iVar4, 0x400);\n        }\n    }\n    return;\n}\n",
        "token_count": 468
    },
    "0044557a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044557a(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    \n    iVar1 = fcn.0041ae6e();\n    if (iVar1 != -1) {\n        if ((*arg_8h != 0) && (*(*arg_8h + 4) != 0)) {\n            fcn.004428ca(in_ECX);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 115
    },
    "00447bae": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00447bae(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.0044557a(arg_8h);\n    if (iVar1 != -1) {\n        *(in_ECX + 0x88) = *(*arg_8h + 0xc);\n    }\n    return iVar1;\n}\n",
        "token_count": 95
    },
    "0044a4f8": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0044a4f8(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    param_1[5] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar1;\n    if (iVar1 == -1) {\n        fcn.00416356();\n    }\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 + 7);\n    return param_1;\n}\n",
        "token_count": 171
    },
    "0044a8a5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044a8a5(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.0044a6ef(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 233
    },
    "0044aae3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044aae3(int32_t **arg_8h, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    int32_t **ppiVar1;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *arg_8h;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(in_ECX + 8) != 0) {\n                ppiVar1 = *(in_ECX + 4);\n                do {\n                    piVar3 = *ppiVar1;\n                    if (piVar3 != NULL) goto code_r0x0044ab17;\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar4 < *(in_ECX + 8));\n                fcn.0041638e();\n                in_ECX = extraout_ECX;\n            }\n        }\ncode_r0x0044ab17:\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(in_ECX + 8);\n            uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(in_ECX + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *arg_8h = piVar5;\n        *arg_ch = piVar3[1];\n        *arg_10h = piVar3[2];\n    }\n    return;\n}\n",
        "token_count": 473
    },
    "0044edde": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044edde(uint arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_34h;\n    int32_t var_14h;\n    uint *var_10h;\n    uint var_4h;\n    \n    puVar1 = arg_ch;\n    puVar3 = &var_34h;\n    for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    if (((var_14h == 0) && (var_10h != 0xffffffff)) && (var_10h != NULL)) {\n        iVar2 = fcn.0042c44f(var_10h, &var_4h);\n        if (iVar2 == 0) {\n            puVar1 = fcn.0042c5d5(var_10h);\n            *puVar1 = 0;\n        }\n        arg_ch = NULL;\n        fcn.0042c478(var_10h, &arg_ch);\n        var_10h = arg_ch;\n    }\n    (**(*in_ECX + 0x118))(0x404, arg_8h, &var_34h);\n    return;\n}\n",
        "token_count": 327
    },
    "0044f929": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0044f929(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    int32_t iVar1;\n    \n    if (arg_8h + 1 < 10) goto code_r0x0044f93e;\n    do {\n        do {\n            arg_8h = fcn.0041638e();\n            in_ECX = extraout_ECX;\ncode_r0x0044f93e:\n            if (arg_8h == 8) {\n                return 8;\n            }\n            if (arg_8h == 0xffffffff) {\n                return 0xffffffff;\n            }\n        } while ((arg_8h < 0) || (7 < arg_8h));\n        iVar1 = arg_8h * 0x20;\n        if (-1 < *(in_ECX + 0x10) - *(in_ECX + 8)) goto code_r0x0044f97a;\n        arg_8h = *(iVar1 + 0x481610);\n    } while ((arg_8h < 0) || (7 < arg_8h));\n    iVar1 = arg_8h << 5;\ncode_r0x0044f97a:\n    if (*(in_ECX + 0x14) - *(in_ECX + 0xc) < 0) {\n        arg_8h = *(iVar1 + 0x481614);\n    }\n    return arg_8h;\n}\n",
        "token_count": 334
    },
    "0045319c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: lplpsz\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl\nfcn.0045319c(uint arg_8h, uint pszExeFileName, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint lplpsz;\n    uint var_10h;\n    uint uVar3;\n    uint arg_ch;\n    char *var_4h;\n    \n    fcn.0045af3b(8);\n    var_4h = unaff_EBP + -0x14;\n    (*_sym.imp.ole32.dll_StringFromCLSID)(*(unaff_EBP + 0xc), var_4h);\n    iVar2 = fcn.00449cd3(*(unaff_EBP + -0x14));\n    if (iVar2 == 0) goto code_r0x004533ad;\n    fcn.00452dd6(0, iVar2);\n    fcn.00452dd6(1, *(unaff_EBP + 0x10));\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(iVar2);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.0042052a();\n    fcn.0042b4df(*(iVar2 + 8), unaff_EBP + -0x10);\n    fcn.00452dd6(2, *(unaff_EBP + -0x10));\n    fcn.00452dd6(3, *(unaff_EBP + 0x14));\n    fcn.00452dd6(4, *(unaff_EBP + 0x18));\n    iVar2 = fcn.0042052a();\n    fcn.00452dd6(5, *(iVar2 + 0x10));\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 1;\n    if (*(unaff_EBP + 0x1c) != 0) {\n        *(unaff_EBP + 0xc) = *(unaff_EBP + -0x10);\n        fcn.0042052a();\n        iVar2 = (*_sym.imp.SHELL32.dll_ExtractIconA)();\n        if (iVar2 != 0) {\n            (*_sym.imp.USER32.dll_DestroyIcon)();\n        }\n    }\n    fcn.00402530();\n    fcn.00452dd6(6, *(unaff_EBP + 8));\n    fcn.00452dd6(7, *(unaff_EBP + 0x20));\n    fcn.00401e60();\n    pcVar1 = *(unaff_EBP + 0x24);\n    *(unaff_EBP + -4) = 2;\n    if ((pcVar1 == NULL) || (*pcVar1 == '\\0')) {\n        fcn.004024f0();\n        iVar2 = fcn.00412210();\n        if (iVar2 != -1) {\n            fcn.00453177(unaff_EBP + 0x20, iVar2 + 1);\n            *(unaff_EBP + -4) = 3;\n            fcn.004076d0();\n            *(unaff_EBP + -4) = 2;\n            fcn.004010f0();\n            iVar2 = fcn.00412210();\n            if (iVar2 != -1) {\n                fcn.00453177(unaff_EBP + 0x20, iVar2);\n                *(unaff_EBP + -4) = 4;\n                fcn.004076d0();\n                *(unaff_EBP + -4) = 2;\n                fcn.004010f0();\n                iVar2 = fcn.00412210();\n                if (iVar2 != -1) {\n                    var_4h = fcn.00440808(unaff_EBP + 0x20, iVar2);\n                    *(unaff_EBP + -4) = 5;\n                    fcn.004076d0(var_4h);\n                    fcn.004010f0();\n                    goto code_r0x00453382;\n                }\n            }\n        }\n        fcn.004018d0();\n    }\n    else {\n        fcn.004024f0();\n        var_4h = pcVar1;\n    }\ncode_r0x00453382:\n    arg_ch = *(unaff_EBP + 0xc);\n    uVar3 = 8;\n    fcn.00452dd6(8, arg_ch);\n    fcn.004010f0(uVar3, arg_ch, var_4h);\n    fcn.004010f0();\n    fcn.004010f0();\ncode_r0x004533ad:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1121
    },
    "00455f54": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00455f54(uint noname_0, uint nNumber)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.00455763(&var_8h, &var_4h);\n    if ((var_4h == NULL) && (var_8h == NULL)) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.0045559c();\n        iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar1, 0x78);\n        if (var_4h == NULL) {\n            if (var_8h == NULL) {\n                return 0;\n            }\n            if (iVar1 == -1) {\n                iVar1 = in_ECX[0x1c];\n                if (0 < nNumber) {\n                    iVar1 = -in_ECX[0x1c];\n                }\n            }\n            else {\n                iVar1 = in_ECX[0x1e] * iVar2;\n                if (in_ECX[0x1c] <= in_ECX[0x1e] * iVar2) {\n                    iVar1 = in_ECX[0x1c];\n                }\n            }\n            iVar3 = 0;\n        }\n        else {\n            if (iVar1 == -1) {\n                iVar3 = in_ECX[0x1d];\n                if (0 < nNumber) {\n                    iVar3 = -in_ECX[0x1d];\n                }\n            }\n            else {\n                iVar3 = in_ECX[0x1f] * iVar2;\n                if (in_ECX[0x1d] <= in_ECX[0x1f] * iVar2) {\n                    iVar3 = in_ECX[0x1d];\n                }\n            }\n            iVar1 = 0;\n        }\n        iVar1 = (**(*in_ECX + 0x144))(iVar1, iVar3, 1);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(in_ECX[8]);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 525
    },
    "00456577": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00456577(int32_t param_1)\n\n{\n    fcn.0041ae6e();\n    if (*(param_1 + 0x5c) == -1) {\n        fcn.004563c5(*(param_1 + 0x60), *(param_1 + 100));\n    }\n    else {\n        fcn.00455d52();\n    }\n    return;\n}\n",
        "token_count": 92
    },
    "00457c95": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00457c95(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    \n    arg_8h_00 = arg_8h;\n    iVar3 = 0;\n    if (-1 < arg_8h) goto code_r0x00457cad;\n    do {\n        fcn.0041638e();\ncode_r0x00457cad:\n        if (iVar3 <= arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h_00 == iVar3) {\n            fcn.00414b30(*(in_ECX + 4));\n            *(in_ECX + 0xc) = iVar3;\n            *(in_ECX + 8) = iVar3;\n            goto code_r0x00457d9d;\n        }\n        if (*(in_ECX + 4) == iVar3) {\n            uVar1 = fcn.00414af6(arg_8h_00);\n            *(in_ECX + 4) = uVar1;\n            fcn.00458b20(uVar1, iVar3, arg_8h_00);\n            *(in_ECX + 0xc) = arg_8h_00;\ncode_r0x00457d14:\n            *(in_ECX + 8) = arg_8h_00;\n            return;\n        }\n        iVar3 = *(in_ECX + 0xc);\n        if (arg_8h_00 <= iVar3) {\n            iVar3 = *(in_ECX + 8);\n            if (iVar3 < arg_8h_00) {\n                fcn.00458b20(iVar3 + *(in_ECX + 4), 0, arg_8h_00 - iVar3);\n            }\n            goto code_r0x00457d14;\n        }\n        iVar2 = *(in_ECX + 0x10);\n        if (iVar2 == 0) {\n            iVar2 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar2 < 4) {\ncode_r0x00457d46:\n                iVar2 = 4;\n            }\n            else if (iVar2 < 0x401) {\n                if (iVar2 < 4) goto code_r0x00457d46;\n            }\n            else {\n                iVar2 = 0x400;\n            }\n        }\n        arg_8h = iVar2 + iVar3;\n        if (iVar2 + iVar3 <= arg_8h_00) {\n            arg_8h = arg_8h_00;\n        }\n    } while (arg_8h < iVar3);\n    iVar3 = fcn.00414af6(arg_8h);\n    fcn.00414fcb(iVar3, arg_8h, *(in_ECX + 4), *(in_ECX + 8));\n    fcn.00458b20(*(in_ECX + 8) + iVar3, 0, arg_8h_00 - *(in_ECX + 8));\n    fcn.00414b30(*(in_ECX + 4));\n    *(in_ECX + 8) = arg_8h_00;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00457d9d:\n    *(in_ECX + 4) = iVar3;\n    return;\n}\n",
        "token_count": 800
    },
    "0044ef05": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23",
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044ef05(int32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint var_24h;\n    int32_t var_20h;\n    uint32_t var_18h;\n    uint var_10h;\n    uint32_t lpPoint;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    puVar3 = arg_ch;\n    puVar4 = &var_24h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    var_24h = (*_sym.imp.USER32.dll_SendMessageA)(*(arg_8h + 0x20), 0x410, 0, &var_10h);\n    lpPoint = arg_ch[5];\n    var_4h = arg_ch[6];\n    if (var_20h - 0x200U < 10) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(var_24h, &lpPoint);\n    }\n    var_18h = lpPoint & 0xffff | var_4h << 0x10;\n    (*pcVar1)(*(arg_8h + 0x20), 0x407, 0, &var_24h);\n    return;\n}\n",
        "token_count": 360
    },
    "00409fb0": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409fb0(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    \n    pcVar2 = _sym.imp.USER32.dll_MsgWaitForMultipleObjects;\n    uStack40 = 0x40;\n    uStack44 = 0xffffffff;\n    uStack48 = 0;\n    iVar3 = (*_sym.imp.USER32.dll_MsgWaitForMultipleObjects)(1, param_1 + 0x40);\n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while (iVar3 != 0) {\n        (*pcVar1)(&uStack48, 0, 0, 0, 0);\n        iVar3 = (*pcVar2)(1, param_1 + 0x40, 0, 0xffffffff, 0x40);\n    }\n    return;\n}\n",
        "token_count": 219
    },
    "00411410": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00411410(int32_t param_1)\n\n{\n    uchar *arg_8h;\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    int32_t unaff_EDI;\n    int32_t *in_FS_OFFSET;\n    uchar *puVar5;\n    uint uVar6;\n    uint uVar7;\n    uchar *puVar8;\n    uchar *puStack768;\n    uchar *puStack764;\n    uchar *puStack760;\n    uchar *puStack756;\n    uchar *puStack752;\n    uchar *puStack748;\n    int32_t **ppiStack744;\n    uchar *puStack740;\n    uchar *puStack736;\n    uint uStack732;\n    int32_t iStack716;\n    int32_t iStack712;\n    uint uStack704;\n    uchar auStack584 [12];\n    uchar auStack572 [228];\n    uchar auStack344 [20];\n    uchar auStack324 [300];\n    int32_t iStack24;\n    uint uStack16;\n    int32_t iStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4702d1;\n    iStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ &stack0xfffffd34;\n    arg_8h = *0x4987a4 ^ &stack0xfffffd2c;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack704 = 0;\n    uStack732 = 0x411456;\n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        uStack732 = 0x80004005;\n        puStack736 = 0x41146b;\n        piVar1 = fcn.00401000();\n    }\n    puStack736 = 0x411474;\n    iVar2 = (**(*piVar1 + 0xc))();\n    iVar2 = iVar2 + 0x10;\n    uStack8 = 0;\n    puStack736 = 0x411487;\n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        puStack736 = 0x80004005;\n        puStack740 = 0x41149c;\n        piVar1 = fcn.00401000();\n    }\n    puStack736 = 0x4114a5;\n    iStack716 = (**(*piVar1 + 0xc))();\n    iStack716 = iStack716 + 0x10;\n    uStack8 = CONCAT31(uStack8._1_3_, 1);\n    puStack736 = 0x4114b9;\n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        puStack736 = 0x80004005;\n        puStack740 = 0x4114ce;\n        piVar1 = fcn.00401000();\n    }\n    puStack736 = 0x4114d7;\n    iStack712 = (**(*piVar1 + 0xc))();\n    iStack712 = iStack712 + 0x10;\n    puStack736 = 0x5;\n    puStack740 = &stack0xfffffd30;\n    uStack8 = CONCAT31(uStack8._1_3_, 2);\n    ppiStack744 = 0x4114fd;\n    iVar3 = (**(*0x499bc8 + 100))();\n    if ((iVar3 != 0) && (*(arg_8h + -0xc) != 0)) {\n        ppiStack744 = 0x6;\n        puStack748 = &stack0xfffffd2c;\n        puStack752 = 0x411528;\n        iVar3 = (**(*0x499bc8 + 100))();\n        if (iVar3 == 0) {\n            puStack752 = &stack0xfffffd20;\n            puStack756 = 0x41153a;\n            fcn.004076d0();\n        }\n        puStack752 = 0x2;\n        puStack756 = &stack0xfffffd28;\n        puStack760 = 0x411551;\n        iVar3 = (**(*0x499bc8 + 100))();\n        if (iVar3 == 0) {\n            puStack760 = &stack0xfffffd1c;\n            puStack764 = 0x411563;\n            fcn.004076d0();\n        }\n        puStack760 = &stack0xfffffd24;\n        puStack764 = 0x478f18;\n        puStack768 = 0x411573;\n        (*_sym.imp.ole32.dll_StringFromCLSID)();\n        puStack768 = 0x411578;\n        iVar3 = fcn.0042052a();\n        uVar7 = *(iVar3 + 8);\n        puStack768 = 0x104;\n        puVar8 = &stack0xfffffdc4;\n        (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(uVar7, puVar8);\n        uVar6 = 0x104;\n        puVar5 = &stack0xfffffebc;\n        (*_sym.imp.KERNEL32.dll_GetShortPathNameA)(&stack0xfffffdb8, puVar5, 0x104);\n        arg_8h = &stack0xfffffd2c;\n        fcn.0040ef90(puStack764, 3);\n        puStack768 = puStack736;\n        if (puStack736 != &stack0xfffffd24) {\n            fcn.004585e6(puStack736);\n        }\n        puStack760 = &stack0xfffffea8;\n        puStack748 = *(param_1 + 0x50);\n        ppiStack744 = NULL;\n        puStack764 = puVar5;\n        puStack756 = uVar7;\n        puStack752 = uVar6;\n        iVar3 = fcn.00410e70(0x47919c, &stack0xfffffd00, 0);\n        if (iVar3 != 0) {\n            fcn.00410e70(0x4791c0, &stack0xfffffd00, 1);\n        }\n        fcn.00411240(\"rtffile\", 0x82, 0x479214, 1);\n        fcn.00411240(\"wrifile\", 0x83, 0x4791f0, 2);\n        fcn.00411240(\"WordPad.Document.1\", 0x85, 0x47923c, 1);\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(puVar8);\n    }\n    piVar1 = iVar2 + -4;\n    uStack16._0_1_ = 1;\n    LOCK();\n    iVar3 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar3 + -1 < 1) {\n        puStack748 = 0x4116ce;\n        ppiStack744 = iVar2 + -0x10;\n        (**(**(iVar2 + -0x10) + 4))();\n    }\n    piVar1 = unaff_EDI + -4;\n    uStack16 = uStack16._1_3_ << 8;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        puStack748 = 0x4116f6;\n        ppiStack744 = unaff_EDI + -0x10;\n        (**(**(unaff_EDI + -0x10) + 4))();\n    }\n    ppiVar4 = arg_8h + -0x10;\n    piVar1 = arg_8h + -4;\n    uStack16 = 0xffffffff;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        puStack748 = 0x41171d;\n        ppiStack744 = ppiVar4;\n        (**(**ppiVar4 + 4))();\n    }\n    *in_FS_OFFSET = iStack24;\n    uStack732 = 0x41173c;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 1893
    },
    "0041546a": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041546a(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        fcn.00414f70(arg_8h, arg_ch, 0x20, 3);\n        iVar1 = fcn.0045850c(arg_8h + 0x20, 0x26, arg_ch + 0x40, 0x26);\n        if (iVar1 == 0) {\n            fcn.00414f70(arg_8h + 0x46, arg_ch + 0x66, 0x20, 3);\n            iVar1 = fcn.0045850c(arg_8h + 0x66, 0x36, arg_ch + 0xa6, 0x36);\n            if ((iVar1 == 0) &&\n               ((*(arg_ch + 0x46) == 0 ||\n                (iVar1 = fcn.0045850c(arg_8h + 0x9c, *(arg_ch + 0x46), arg_ch + 0xdc, *(arg_ch + 0x46)),  iVar1 == 0))))\n            {\n                *(arg_8h + 0x24) = 0x9c;\n                fcn.004150c6();\n                return arg_8h;\n            }\n        }\n    }\n    fcn.004150c6();\n    return 0;\n}\n",
        "token_count": 347
    },
    "00429a64": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429a64(code *arg_8h, code *arg_ch)\n\n{\n    code **in_ECX;\n    \n    fcn.0041e861();\n    *in_ECX = vtable.COleFrameHook.0;\n    fcn.00401e60();\n    in_ECX[0x11] = vtable.COleFrameHook::XOleInPlaceFrame.0;\n    in_ECX[0x12] = vtable.COleFrameHook::XOleCommandTarget.0;\n    in_ECX[10] = arg_ch;\n    in_ECX[8] = arg_8h;\n    in_ECX[9] = NULL;\n    in_ECX[0xb] = *(arg_8h + 0x20);\n    in_ECX[0xd] = NULL;\n    in_ECX[0xe] = NULL;\n    in_ECX[0xc] = NULL;\n    in_ECX[0xf] = NULL;\n    *(arg_8h + 0x80) = in_ECX;\n    return;\n}\n",
        "token_count": 235
    },
    "0043a9d5": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043a9d5(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x18);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.004272bb();\n    *(unaff_EBP + -4) = 0;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 1;\n    fcn.00439b40();\n    uVar1 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x18) = 0xffffffff;\n    *(extraout_ECX + 0x74) = vtable.COleServerItem::XOleObject.0;\n    *(extraout_ECX + 0x78) = vtable.COleServerItem::XDataObject.0;\n    *(extraout_ECX + 0x30) = uVar1;\n    *(unaff_EBP + -0x24) = 3;\n    *(unaff_EBP + -4) = 2;\n    *(extraout_ECX + 4) = 0;\n    *(extraout_ECX + 0x2c) = 0;\n    *(extraout_ECX + 0x24) = 0;\n    *(extraout_ECX + 0x28) = 0;\n    *(extraout_ECX + 0x38) = 0;\n    *(extraout_ECX + 0x3c) = 0;\n    *(extraout_ECX + 0x6c) = 1;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -0x1c) = 1;\n    *(unaff_EBP + -0x14) = 0x20;\n    fcn.004470b9(0, unaff_EBP + -0x24);\n    piVar2 = *(unaff_EBP + 8);\n    *(extraout_ECX + 0x20) = 0;\n    if (piVar2 != NULL) {\n        (**(*piVar2 + 0xbc))(extraout_ECX);\n    }\n    fcn.00441d51();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 606
    },
    "0043aa7a": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.0043aa7a(void)\n\n{\n    int32_t *piVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 2;\n    *(extraout_ECX + 0x30) = 0;\n    fcn.004469e6(extraout_ECX + 0x38);\n    fcn.004469e6(extraout_ECX + 0x3c);\n    fcn.00446b1c();\n    piVar1 = *(extraout_ECX + 0x20);\n    if (piVar1 != NULL) {\n        if (*(extraout_ECX + 0x2c) != 0) {\n            fcn.0044426c(0, 1);\n            *(extraout_ECX + 0x2c) = 0;\n        }\n        if (piVar1[0x30] == extraout_ECX) {\n            piVar1[0x30] = 0;\n        }\n        (**(*piVar1 + 0xc0))(extraout_ECX);\n    }\n    fcn.00441dca();\n    *(unaff_EBP + -4) = 1;\n    fcn.00447503();\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004272d3();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 401
    },
    "0044bc1a": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044bc1a(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    \n    in_ECX[1] = arg_ch;\n    if (arg_ch <= arg_ch + 0x40) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, arg_ch + 0x40);\n        *in_ECX = iVar1;\n        if (iVar1 != 0) {\n            arg_8h_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n            fcn.00414fcb(arg_8h_00, in_ECX[1], arg_8h, in_ECX[1]);\n            iVar1 = fcn.0044bab0(arg_8h_00);\n            in_ECX[2] = iVar1 == 0;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 240
    },
    "00454c64": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.00454c64(void)\n\n{\n    uint *arg_8h;\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042052a();\n    fcn.0044b9be(0xb);\n    while (arg_8h = *(iVar1 + 0x40),  arg_8h != NULL) {\n        fcn.0044a36f(arg_8h);\n        if (arg_8h != NULL) {\n            (***arg_8h)(1);\n        }\n    }\n    fcn.0044ba30(0xb);\n    return;\n}\n",
        "token_count": 134
    },
    "00454caf": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00454caf(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ole32.dll_CoRegisterMessageFilter)(param_1 + 0x40, 0);\n    if (iVar1 == 0) {\n        *(param_1 + 0x20) = 1;\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 94
    },
    "0040b1f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid fcn.0040b1f0(int32_t param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    char *pcVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    char extraout_DH;\n    int32_t iVar5;\n    \n    iVar5 = 0;\n    if (0 < *(param_2 + 0xc)) {\n        do {\n            if (((iVar5 < 0) || (*(param_2 + 0xc) <= iVar5)) ||\n               (puVar1 = *(*(param_2 + 8) + iVar5 * 4),  puVar1 == NULL)) {\n                iVar5 = fcn.0041638e();\n                *(extraout_ECX + -0x4e) = *(extraout_ECX + -0x4e) + extraout_ECX;\n                *(extraout_ECX + -0x4e) = *(extraout_ECX + -0x4e) + extraout_ECX;\n                pcVar3 = iVar5 + 3;\n                *pcVar3 = *pcVar3 + (extraout_ECX >> 8);\n                *pcVar3 = *pcVar3 + extraout_DH;\n                pcVar2 = swi(3);\n                (*pcVar2)();\n                return;\n            }\n    // switch table (6 cases) at 0x40b25c\n            switch(*puVar1) {\n            case 0xe800:\n                uVar4 = *(param_1 + 0x98);\n                break;\n            case 0xe801:\n                uVar4 = *(param_1 + 0x94);\n                break;\n            default:\n                goto code_r0x0040b249;\n            case 0xe804:\n                uVar4 = *(param_1 + 0x8c);\n                break;\n            case 0xe805:\n                uVar4 = *(param_1 + 0x90);\n            }\n            puVar1[1] = uVar4;\ncode_r0x0040b249:\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < *(param_2 + 0xc));\n    }\n    return;\n}\n",
        "token_count": 490
    },
    "00422589": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422589(int32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 0x71);\n    iVar3 = (*pcVar1)(arg_8h[2], 0x70);\n    (**(*arg_8h + 0x38))(&var_ch, -iVar3, -iVar2);\n    iVar2 = (*pcVar1)(arg_8h[1], 2);\n    if ((iVar2 != 5) && (arg_8h[2] != 0)) {\n        uVar4 = (*pcVar1)(arg_8h[2], 0x5a, 0);\n        uVar4 = (*pcVar1)(arg_8h[1], 0x5a, uVar4);\n        uVar4 = (*pcVar1)(arg_8h[2], 0x58, uVar4);\n        uVar4 = (*pcVar1)(arg_8h[1], 0x58, uVar4);\n        (*_sym.imp.GDI32.dll_ScaleWindowExtEx)(arg_8h[1], uVar4);\n    }\n    var_40h = arg_8h[2];\n    var_44h = arg_8h[1];\n    puVar5 = fcn.00422275(&var_14h);\n    var_2ch = *puVar5;\n    uStack44 = puVar5[1];\n    uStack40 = puVar5[2];\n    uStack36 = puVar5[3];\n    puVar5 = fcn.0042223a(&var_14h);\n    var_3ch = *puVar5;\n    uStack60 = puVar5[1];\n    uStack56 = puVar5[2];\n    uStack52 = puVar5[3];\n    var_1ch = arg_ch;\n    var_18h = arg_10h;\n    fcn.0042216e(&var_44h, 1);\n    return;\n}\n",
        "token_count": 621
    },
    "00422654": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00422654(int32_t arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint var_1ch;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(arg_8h + 4), 2);\n    if ((iVar2 != 5) && (*(arg_8h + 8) != 0)) {\n        uVar3 = (*pcVar1)(*(arg_8h + 8), 0x5a, 0);\n        uVar3 = (*pcVar1)(*(arg_8h + 4), 0x5a, uVar3);\n        uVar3 = (*pcVar1)(*(arg_8h + 8), 0x58, uVar3);\n        uVar3 = (*pcVar1)(*(arg_8h + 4), 0x58, uVar3);\n        (*_sym.imp.GDI32.dll_ScaleWindowExtEx)(*(arg_8h + 4), uVar3);\n    }\n    var_30h = *(arg_8h + 8);\n    var_34h = *(arg_8h + 4);\n    var_1ch = *arg_ch;\n    uStack28 = arg_ch[1];\n    uStack24 = arg_ch[2];\n    uStack20 = arg_ch[3];\n    var_2ch = *arg_ch;\n    uStack44 = arg_ch[1];\n    uStack40 = arg_ch[2];\n    uStack36 = arg_ch[3];\n    var_ch = arg_10h;\n    var_8h = arg_14h;\n    fcn.0042216e(0, 0);\n    uVar3 = fcn.0042216e(&var_34h, arg_18h);\n    fcn.0042216e(0, 0);\n    *arg_ch = var_2ch;\n    arg_ch[1] = uStack44;\n    arg_ch[2] = uStack40;\n    arg_ch[3] = uStack36;\n    return uVar3;\n}\n",
        "token_count": 588
    },
    "0040bbb0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040bbb0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *unaff_EDI;\n    \n    iVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(param_1 + 0x18), *(*(param_1 + 0x24) + 0xac4), 0x5a0);\n    if (*(param_1 + 0x1c) == 6) {\n        iVar4 = iVar4 - *(param_1 + 0xc) / 2;\n    }\n    else if (*(param_1 + 0x1c) != 0) {\n        iVar4 = iVar4 - *(param_1 + 0xc);\n    }\n    iVar1 = *(param_1 + 0xc);\n    iVar2 = *(param_1 + 0x10);\n    iVar3 = *(param_1 + 0x14);\n    *unaff_EDI = iVar4;\n    unaff_EDI[3] = iVar2 + iVar3;\n    unaff_EDI[1] = iVar3;\n    unaff_EDI[2] = iVar4 + iVar1;\n    return;\n}\n",
        "token_count": 282
    },
    "00430e62": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430e62(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if ((((arg_8h != 0) && (arg_8h != 6)) && (arg_8h != 7)) && ((arg_8h != 8 && (arg_8h != 4)))) {\n        uVar1 = (*_sym.imp.USER32.dll_GetLastActivePopup)(*(in_ECX + 0x20));\n        (*_sym.imp.USER32.dll_BringWindowToTop)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "0040cf30": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040cf30(int32_t param_1, int32_t param_2, int32_t param_3, uint *param_4)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_InvalidateRect;\n    if ((param_2 == *(param_1 + 0xaa8)) && (param_3 == *(param_1 + 0xaac))) {\n        iVar2 = (*_sym.imp.USER32.dll_EqualRect)(param_4, param_1 + 0xab0);\n        if (iVar2 != 0) goto code_r0x0040cfaa;\n    }\n    *(param_1 + 0xaa8) = param_2;\n    *(param_1 + 0xaac) = param_3;\n    *(param_1 + 0xab0) = *param_4;\n    *(param_1 + 0xab4) = param_4[1];\n    *(param_1 + 0xab8) = param_4[2];\n    *(param_1 + 0xabc) = param_4[3];\n    (*pcVar1)(*(param_1 + 0x20), 0, 1);\ncode_r0x0040cfaa:\n    if (*(param_1 + 0xa0) != *(*0x49a288 * 0x20 + 0x499c38)) {\n        fcn.0040b050(*0x49a288 * 0x20 + 0x499c38);\n        (*pcVar1)(*(param_1 + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 377
    },
    "0044fab2": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044fab2(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lprc;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lprc = in_ECX[2];\n    var_ch = in_ECX[3];\n    var_8h = in_ECX[4];\n    var_4h = in_ECX[5];\n    fcn.0044f70e();\n    if ((*(in_ECX + 1) & 3) != 0) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 1, 1);\n    }\n    iVar1 = fcn.0044f929(arg_8h);\n    iVar2 = (**(*in_ECX + 0x14))(0);\n    if ((*(in_ECX + 1) & 0x10) != 0) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, iVar2 + -1, iVar2 + -1);\n    }\n    iVar1 = iVar1 * 0x20;\n    iVar3 = *(&lprc + *(iVar1 + 0x4815f8)) + *(iVar1 + 0x481608) * iVar2 +\n            (((var_8h - lprc) - iVar2) * *(iVar1 + 0x481600)) / 2;\n    iVar1 = *(&lprc + *(iVar1 + 0x4815fc)) + *(iVar1 + 0x48160c) * iVar2 +\n            (((var_4h - var_ch) - iVar2) * *(iVar1 + 0x481604)) / 2;\n    *arg_ch = iVar3;\n    arg_ch[1] = iVar1;\n    arg_ch[2] = iVar3 + iVar2;\n    arg_ch[3] = iVar1 + iVar2;\n    return;\n}\n",
        "token_count": 496
    },
    "0044fcae": {
        "rules": [
            "hash data using djb2/86fcf1c18148478ab58e8c52ba43c8d5",
            "hash data using jshash/2d43aa00ef9c47beadbc2522c99f9e7b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044fcae(int32_t arg_8h, int32_t **arg_ch, int32_t **arg_10h, int32_t *arg_14h, int32_t *arg_18h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    int32_t *extraout_EDX;\n    int32_t iVar4;\n    \n    piVar3 = NULL;\n    if (-1 < arg_8h) goto code_r0x0044fcc6;\n    do {\n        fcn.0041638e();\n        piVar3 = extraout_EDX;\ncode_r0x0044fcc6:\n    } while (8 < arg_8h);\n    if (arg_8h == 8) {\n        arg_8h = 0;\n    }\n    iVar4 = arg_8h * 0x20;\n    *arg_ch = piVar3;\n    *arg_10h = piVar3;\n    if (*(iVar4 + 0x481610) == arg_8h) {\n        if (arg_14h == piVar3) goto code_r0x0044fd1b;\n        iVar2 = fcn.0045e15d(*(in_ECX + 0x10) - *(in_ECX + 8));\n        iVar2 = iVar2 / 2 + *(in_ECX + 8);\n    }\n    else {\n        piVar1 = *(iVar4 + 0x4815f8) + 8 + in_ECX;\n        *arg_ch = piVar1;\n        if (arg_14h == piVar3) goto code_r0x0044fd1b;\n        iVar2 = *piVar1;\n    }\n    *arg_14h = iVar2;\ncode_r0x0044fd1b:\n    if (*(iVar4 + 0x481614) == arg_8h) {\n        if (arg_18h != NULL) {\n            iVar4 = fcn.0045e15d(*(in_ECX + 0x14) - *(in_ECX + 0xc));\n            *arg_18h = iVar4 / 2 + *(in_ECX + 0xc);\n        }\n    }\n    else {\n        piVar3 = *(iVar4 + 0x4815fc) + 8 + in_ECX;\n        *arg_10h = piVar3;\n        if (arg_18h != NULL) {\n            *arg_18h = *piVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 572
    },
    "0040e740": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040e740(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t nDefault;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uchar *arg_10h;\n    char *arg_10h_00;\n    uint arg_ch;\n    int32_t iVar7;\n    uint uStack104;\n    uint uStack100;\n    uchar *puStack96;\n    uint uStack92;\n    char cVar8;\n    uint32_t uStack72;\n    int32_t iStack68;\n    uint uStack64;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uStack64 = 0x11;\n    iStack68 = 0x40e75d;\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)();\n    if (iVar2 == 0) {\n        iStack68 = 0xc;\n        uStack72 = 0x40e765;\n        (*pcVar1)();\n    }\n    iStack68 = param_1 + 0xe0;\n    uStack72 = 0x3c;\n    (*_sym.imp.GDI32.dll_GetObjectA)();\n    cVar8 = -0x34;\n    uStack92 = 0x40e788;\n    uVar3 = fcn.00439634(0x478ccc, \"WordSel\", 1);\n    uStack92 = 2;\n    puStack96 = &stack0xffffffb8;\n    uStack100 = 0xd;\n    *(param_1 + 0x158) = uVar3;\n    uStack72 = uStack72 & 0xffffff00;\n    uStack104 = 0x40e7a1;\n    uStack104 = (*_sym.imp.KERNEL32.dll_GetUserDefaultLCID)();\n    (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)();\n    nDefault = cVar8 != '1';\n    uVar3 = fcn.00439634(0x478ccc, \"Units\", nDefault);\n    arg_ch = 0;\n    arg_10h_00 = \"Maximized\";\n    *(param_1 + 0x568) = uVar3;\n    uVar3 = fcn.00439634(0x478ccc, \"Maximized\", 0);\n    *(param_1 + 0x140) = uVar3;\n    iVar4 = fcn.00439a19(0x478ccc, \"FrameRect\", &stack0xffffff94, &stack0xffffff98);\n    iVar2 = param_1 + 0x130;\n    if (iVar4 == 0) {\n        (*_sym.imp.USER32.dll_SetRect)(iVar2, 0, 0, 0, 0);\n    }\n    else {\n        fcn.0045850c(iVar2, arg_ch, arg_10h_00, 0x10);\n        fcn.00414b30(arg_10h_00);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar5 = (*_sym.imp.USER32.dll_GetSystemMetrics)(1);\n    iVar6 = (*pcVar1)(0);\n    arg_10h = &stack0xffffff84;\n    iVar7 = 0;\n    iVar4 = iVar2;\n    (*_sym.imp.USER32.dll_IntersectRect)(&stack0xffffff94);\n    if ((iVar5 - iVar7 < 10) || (nDefault - iVar6 < 10)) {\n        (*_sym.imp.USER32.dll_SetRect)(iVar2, 0, 0, 0, 0);\n    }\n    iVar2 = fcn.00439a19(0x478ccc, \"PageMargin\", &stack0xffffff70, &stack0xffffff74);\n    if (iVar2 == 0) {\n        (*_sym.imp.USER32.dll_SetRect)(param_1 + 0x120, 0x708, 0x5a0, 0x708, 0x5a0);\n    }\n    else {\n        fcn.0045850c(param_1 + 0x120, iVar4, arg_10h, 0x10);\n        fcn.00414b30(arg_10h);\n    }\n    fcn.0040afa0(\"Text\");\n    fcn.0040afa0(0x478ca0);\n    fcn.0040afa0(\"Word6\");\n    fcn.0040afa0(\"Write\");\n    fcn.0040afa0(0x478cb4);\n    return;\n}\n",
        "token_count": 1019
    },
    "0045138b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045138b(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint uVar5;\n    uint lprcDst;\n    int32_t lprcSrc1;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcSrc2;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = arg_8h - *(in_ECX + 4);\n    iVar4 = arg_ch - *(in_ECX + 8);\n    iVar3 = *(in_ECX + 0x8c);\n    uVar5 = 2;\n    if (iVar3 == 10) {\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + iVar2;\n    }\n    else {\n        if (iVar3 != 0xb) {\n            uVar5 = 0x22;\n            if (iVar3 == 0xc) {\n                *(in_ECX + 0x2c) = *(in_ECX + 0x2c) + iVar4;\n            }\n            else {\n                *(in_ECX + 0x34) = *(in_ECX + 0x34) + iVar4;\n            }\n            iVar3 = *(in_ECX + 0x34) - *(in_ECX + 0x2c);\n            goto code_r0x004513e5;\n        }\n        *(in_ECX + 0x30) = *(in_ECX + 0x30) + iVar2;\n    }\n    iVar3 = *(in_ECX + 0x30) - *(in_ECX + 0x28);\ncode_r0x004513e5:\n    if (iVar3 < 0) {\n        iVar3 = 0;\n    }\n    (**(**(in_ECX + 0x68) + 0x140))(&var_8h, iVar3, uVar5);\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    lprcSrc1 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x4c);\n    var_24h = (*pcVar1)(0x4d);\n    var_20h = (*pcVar1)(0x4e);\n    var_20h = var_20h + lprcSrc1;\n    var_1ch = (*pcVar1)(0x4f);\n    var_1ch = var_1ch + var_24h;\n    lprcSrc2 = *(in_ECX + 0x48);\n    var_14h = *(in_ECX + 0x4c);\n    var_10h = *(in_ECX + 0x50);\n    var_ch = *(in_ECX + 0x54);\n    if ((*(in_ECX + 0x8c) == 10) || (*(in_ECX + 0x8c) == 0xc)) {\n        lprcSrc2 = ((*(in_ECX + 0x58) - *(in_ECX + 0x60)) - var_8h) + var_10h;\n        var_14h = ((*(in_ECX + 0x5c) - *(in_ECX + 100)) - var_4h) + var_ch;\n        iVar3 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar3 != 0) {\n            *(in_ECX + 0x38) = *(in_ECX + 0x40) - var_8h;\n            *(in_ECX + 0x3c) = *(in_ECX + 0x44) - var_4h;\n            *(in_ECX + 0x48) = lprcSrc2;\n            *(in_ECX + 0x4c) = var_14h;\n        }\n    }\n    else {\n        var_10h = (*(in_ECX + 0x60) - *(in_ECX + 0x58)) + lprcSrc2 + var_8h;\n        var_ch = (*(in_ECX + 100) - *(in_ECX + 0x5c)) + var_14h + var_4h;\n        iVar3 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar3 != 0) {\n            *(in_ECX + 0x40) = *(in_ECX + 0x38) + var_8h;\n            *(in_ECX + 0x44) = *(in_ECX + 0x3c) + var_4h;\n            *(in_ECX + 0x50) = var_10h;\n            *(in_ECX + 0x54) = var_ch;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    fcn.00451176(0);\n    return;\n}\n",
        "token_count": 1203
    },
    "0040f500": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040f500(int32_t param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint *arg_8h;\n    int32_t arg_10h;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t *in_FS_OFFSET;\n    uint32_t var_8h;\n    int32_t var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint var_14h;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x46ff20;\n    var_ch_3 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_3;\n    uVar4 = var_8h | 0xf;\n    if (uVar4 != 0xffffffff) {\n        uVar1 = *(param_1 + 0x18);\n        uVar3 = uVar1 >> 1;\n        var_8h = uVar4;\n        if ((uVar4 / 3 < uVar3) && (uVar1 <= -uVar3 - 2)) {\n            var_8h = uVar3 + uVar1;\n        }\n    }\n    var_4h = 0;\n    arg_8h = fcn.0040eaf0(var_8h + 1, 0);\n    if (var_ch_2 != 0) {\n        if (*(param_1 + 0x18) < 0x10) {\n            arg_10h = param_1 + 4;\n        }\n        else {\n            arg_10h = *(param_1 + 4);\n        }\n        fcn.0045850c(arg_8h, var_8h + 1, arg_10h, var_ch_2);\n    }\n    if (0xf < *(param_1 + 0x18)) {\n        fcn.00414b30(*(param_1 + 4));\n    }\n    puVar2 = param_1 + 4;\n    *puVar2 = 0;\n    *puVar2 = arg_8h;\n    *(param_1 + 0x18) = var_8h;\n    *(param_1 + 0x14) = var_ch_2;\n    if (0xf < var_8h) {\n        puVar2 = arg_8h;\n    }\n    *(puVar2 + var_ch_2) = 0;\n    *in_FS_OFFSET = var_ch_3;\n    return;\n}\n",
        "token_count": 583
    },
    "00439a19": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00439a19(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    uint arg_8h_00;\n    uint32_t uVar4;\n    code *pcVar5;\n    char cVar6;\n    char cVar7;\n    int32_t iVar8;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    piVar2 = *(unaff_EBP + 0x10);\n    puVar3 = *(unaff_EBP + 0x14);\n    *piVar2 = 0;\n    *puVar3 = 0;\n    if (*(extraout_ECX + 0x54) == 0) {\n        var_10h = unaff_EBP + 0xc;\n        fcn.00439881(var_10h, *(unaff_EBP + 8), *(unaff_EBP + 0xc), 0);\n        uVar4 = *(*(unaff_EBP + 0xc) + -0xc);\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + 8) = uVar4;\n        if (uVar4 != 0) {\n            **(unaff_EBP + 0x14) = uVar4 >> 1;\n            iVar8 = fcn.00414af6(uVar4 >> 1);\n            *piVar2 = iVar8;\n            iVar8 = 0;\n            if (0 < uVar4) {\n                do {\n                    var_10h = iVar8;\n                    cVar6 = fcn.00404240(var_10h + 1);\n                    cVar7 = fcn.00404240();\n                    iVar1 = *(unaff_EBP + 8);\n                    *(var_10h / 2 + *piVar2) = cVar7 + (cVar6 + -1) * '\\x10' + -0x41;\n                    iVar8 = var_10h + 2;\n                } while (var_10h + 2 < iVar1);\n            }\n        }\n        fcn.004010f0(var_10h);\n        goto code_r0x00439a4b;\n    }\n    iVar8 = fcn.004395ec(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x10) = iVar8;\n    if (iVar8 == 0) goto code_r0x00439a4b;\n    *(unaff_EBP + -0x18) = iVar8;\n    *(unaff_EBP + -0x14) = 0;\n    pcVar5 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + 0x10) = 0;\n    *(unaff_EBP + 8) = 0;\n    iVar8 = (*pcVar5)(iVar8, *(unaff_EBP + 0xc), 0, unaff_EBP + 0x10, 0, unaff_EBP + 8);\n    arg_8h_00 = *(unaff_EBP + 8);\n    **(unaff_EBP + 0x14) = arg_8h_00;\n    if (iVar8 == 0) {\n        iVar8 = fcn.00414af6(arg_8h_00);\n        *piVar2 = iVar8;\n        iVar8 = (*pcVar5)(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), 0, unaff_EBP + 0x10, iVar8, unaff_EBP + 8);\n        if (iVar8 != 0) goto code_r0x00439ab2;\n    }\n    else {\ncode_r0x00439ab2:\n        fcn.00414b30(*piVar2);\n        *piVar2 = 0;\n    }\n    fcn.0043985f();\ncode_r0x00439a4b:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1036
    },
    "00422add": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00422add(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t in_ECX;\n    uint lpRect;\n    uint var_8h;\n    uint lParam;\n    \n    if ((arg_8h == 0x79) && (iVar1 = (*_sym.imp.USER32.dll_GetKeyState)(0x10),  iVar1 < 0)) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n        fcn.0042201c(&var_8h);\n        (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0x7b, *(in_ECX + 0x20), CONCAT22(lParam, var_8h));\n        return;\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 208
    },
    "0042c9b8": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c9b8(uint arg_8h)\n\n{\n    uint var_18h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0042c902(arg_8h, &var_18h);\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 100
    },
    "0042cabf": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042cabf(uint arg_8h, uint *arg_ch, uint32_t *arg_10h, uint *arg_14h)\n\n{\n    uint unaff_ESI;\n    uint var_18h;\n    uint var_14h;\n    uint8_t var_10h;\n    uint var_fh;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.0042c902(arg_8h, &var_18h);\n    *arg_ch = var_14h;\n    *arg_10h = var_10h << 0x10 | var_fh;\n    *arg_14h = var_18h;\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 192
    },
    "0041ce7f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.0041ce7f(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    bool bVar3;\n    uint uVar4;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_10h != 0) {\n        uVar4 = 0xffffffff;\n        iVar2 = arg_10h;\n        iVar1 = fcn.0044ba8e(arg_10h);\n        if (iVar1 == 0) {\n            fcn.0041638e(iVar2, uVar4);\n        }\n    }\n    var_4h = arg_8h;\n    var_8h = arg_ch;\n    var_10h = arg_14h;\n    var_14h = arg_18h;\n    var_18h = arg_1ch;\n    var_1ch = arg_20h;\n    var_20h = arg_24h;\n    var_24h = arg_28h;\n    var_ch = arg_10h;\n    var_28h = arg_2ch;\n    iVar2 = fcn.0042052a();\n    var_2ch = *(iVar2 + 8);\n    var_30h = arg_30h;\n    iVar2 = (**(*in_ECX + 100))(&var_30h);\n    if (iVar2 == 0) {\n        (**(*in_ECX + 0x11c))();\n        bVar3 = false;\n    }\n    else {\n        fcn.0041ce25(in_ECX);\n        iVar2 = fcn.004196ad(var_4h, var_8h, var_ch, var_10h, var_14h, var_18h, var_1ch, var_20h, var_24h, var_28h, \n                             var_2ch, var_30h);\n        iVar1 = fcn.0041afcd();\n        if (iVar1 == 0) {\n            (**(*in_ECX + 0x11c))();\n        }\n        bVar3 = iVar2 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 615
    },
    "004258f8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004258f8(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_2ch;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar2 = fcn.004469c0(*(in_ECX + 0x24), 0x4850c0);\n    if (piVar2 != NULL) {\n        iVar3 = (**(*piVar2 + 0x14))(piVar2, &var_4h);\n        if ((iVar3 == 0) && (var_4h != NULL)) {\n            piVar4 = fcn.004469c0(*(in_ECX + 0x24), 0x485080);\n            iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_30h, 0);\n            pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n            while (iVar3 == 0) {\n                iVar3 = (**(*piVar4 + 0xc))(piVar4, &var_30h, &var_10h);\n                if (iVar3 == 0) {\n                    if (var_8h != 0) {\n                        (*_sym.imp.ole32.dll_ReleaseStgMedium)(&var_10h);\n                        goto code_r0x00425982;\n                    }\n                    fcn.00447077(0, &var_10h, &var_30h);\n                }\n                else {\ncode_r0x00425982:\n                    (*pcVar1)(var_2ch);\n                }\n                iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_30h, 0);\n            }\n            (**(*var_4h + 8))(var_4h);\n            (**(*piVar4 + 8))(piVar4);\n        }\n        (**(*piVar2 + 8))(piVar2);\n    }\n    return;\n}\n",
        "token_count": 489
    },
    "0041656e": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041656e(uint32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    if (arg_8h < 0x81) {\n        *in_ECX = in_ECX + 1;\n    }\n    else {\n        fcn.004164e7(arg_8h);\n    }\n    return *in_ECX;\n}\n",
        "token_count": 87
    },
    "00435bb6": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00435bb6(uint noname_0, int32_t arg_ch)\n\n{\n    uint uVar1;\n    \n    if (arg_ch - 10U < 8) {\n        uVar1 = 3;\n    }\n    else {\n        uVar1 = fcn.0041ae6e();\n    }\n    return uVar1;\n}\n",
        "token_count": 81
    },
    "00420717": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420717(uint noname_0, int32_t arg_ch, uint32_t *arg_10h)\n\n{\n    uint32_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    \n    if (arg_ch == 2) {\n        iVar3 = fcn.0041ff5e();\n        puVar1 = arg_10h;\n        if ((*arg_10h == *(iVar3 + 0x1c)) && (arg_10h[1] == *(iVar3 + 0x20))) {\n            uVar2 = 0;\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_VirtualProtect)(arg_10h, 0x12, 4, &arg_ch);\n            if ((*puVar1 & 0x40) == 0) {\n                uVar4 = *(iVar3 + 0x1c) & 0xffffffbf;\n            }\n            else {\n                uVar4 = *(iVar3 + 0x1c) | 0x40;\n            }\n            *puVar1 = uVar4;\n            puVar1[1] = *(iVar3 + 0x20);\n            uVar2 = 1;\n        }\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 302
    },
    "00436570": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n\nvoid __cdecl fcn.00436570(int32_t arg_8h, int32_t arg_ch)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    uint unaff_ESI;\n    uint arg_10h;\n    uint lpRect;\n    uint var_128h;\n    uint var_124h;\n    int32_t var_120h;\n    int32_t var_11ch;\n    int32_t var_118h;\n    int32_t var_114h;\n    int32_t var_110h;\n    int32_t lprc2;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    var_110h = arg_8h;\n    lprc2 = arg_ch;\n    if (in_ECX != 0) goto code_r0x004365a7;\n    do {\n        fcn.0041638e();\ncode_r0x004365a7:\n    } while (arg_8h == 0);\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x20), &fcn.00436570::lpRect);\n    if (*(arg_8h + 0x90) == in_ECX) {\n        if (lprc2 == 0) goto code_r0x00436833;\n        iVar2 = (*_sym.imp.USER32.dll_EqualRect)(&fcn.00436570::lpRect, lprc2);\n        if (iVar2 != 0) goto code_r0x00436833;\n    }\n    if ((*(in_ECX + 0x98) != 0) && ((*(arg_8h + 0x88) & 0x40) != 0)) {\n        *(in_ECX + 0x84) = *(in_ECX + 0x84) | 0x40;\n    }\n    *(in_ECX + 0x84) = *(in_ECX + 0x84) & 0xfffffff9;\n    uVar3 = *(in_ECX + 0x84);\n    *(in_ECX + 0x84) = *(arg_8h + 0x84) & 6 | uVar3;\n    if ((uVar3 & 0x40) == 0) {\n        fcn.004182b0(&fcn.00436570::var_108h, 0x104);\n        fcn.0044af85(*(in_ECX + 0x20), &fcn.00436570::var_108h);\n    }\n    uVar3 = (*(arg_8h + 0x84) ^ *(in_ECX + 0x84)) & 0xf000 ^ *(arg_8h + 0x84);\n    if (*(in_ECX + 0x98) == 0) {\n        uVar3 = uVar3 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar3 = uVar3 | 0xf01;\n    }\n    fcn.0042e179(uVar3);\n    bVar1 = false;\n    if (*(arg_8h + 0x90) != in_ECX) {\n        iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(arg_8h + 0x20));\n        if (iVar2 != 0) {\n            fcn.0041822e(0, 0, 0, 0, 0, 0x97);\n            bVar1 = true;\n        }\n    }\n    var_128h = 0xffffffff;\n    if (lprc2 == 0) {\n        fcn.00405010(arg_8h);\n        fcn.00405010(0);\n        fcn.0041822e(0, -*0x49be50, -*0x49be54, 0, 0, 0x115);\n    }\n    else {\n        fcn.004030d0(lprc2);\n        fcn.004172a1(&fcn.00436570::var_120h);\n        var_128h = fcn.00435a66(var_110h, var_120h, var_11ch, var_118h, var_114h, (var_118h - var_120h) / 2 + var_120h, \n                                (var_114h - var_11ch) / 2 + var_11ch);\n        fcn.0041822e(0, var_120h, var_11ch, var_118h - var_120h, var_114h - var_11ch, 0x114);\n        arg_8h = var_110h;\n    }\n    (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x20));\n    iVar2 = fcn.0041af14(0x4367be);\n    if (iVar2 != in_ECX) {\n        fcn.00433cd1(in_ECX);\n    }\n    iVar2 = *(arg_8h + 0x90);\n    if (iVar2 == in_ECX) {\n        arg_10h = 0;\ncode_r0x004367fb:\n        fcn.00435e36(arg_8h, var_128h, arg_10h);\n    }\n    else if (iVar2 != 0) {\n        if ((*(in_ECX + 0x98) == 0) || (*(iVar2 + 0x98) != 0)) {\n            arg_10h = 0;\n        }\n        else {\n            arg_10h = 1;\n        }\n        var_128h = 0xffffffff;\n        goto code_r0x004367fb;\n    }\n    *(arg_8h + 0x90) = in_ECX;\n    if (bVar1) {\n        fcn.0041822e(0, 0, 0, 0, 0, 0x57);\n    }\n    fcn.00435dcd(arg_8h);\n    iVar2 = fcn.00430e96();\n    *(iVar2 + 0xe4) = *(iVar2 + 0xe4) | 0xc;\ncode_r0x00436833:\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 1431
    },
    "0044fbe5": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044fbe5(uint pt, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    int32_t lprc;\n    int32_t iStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0xc))();\n    fcn.0044fa5e(&var_14h);\n    pcVar2 = _sym.imp.USER32.dll_PtInRect;\n    iVar3 = (*_sym.imp.USER32.dll_PtInRect)(&var_14h, pt, arg_ch);\n    if (iVar3 == 0) {\n        iVar3 = -1;\n    }\n    else {\n        iVar3 = 0;\n        do {\n            if ((var_4h & 1 << (iVar3 & 0x1f)) != 0) {\n                fcn.0044fab2(iVar3, &var_14h);\n                iVar4 = (*pcVar2)(&var_14h, pt, arg_ch);\n                if (iVar4 != 0) {\n                    return iVar3;\n                }\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 8);\n        uVar1 = in_ECX[1];\n        if ((uVar1 & 4) == 0) {\n            lprc = in_ECX[2];\n            iStack36 = in_ECX[3];\n            iStack32 = in_ECX[4];\n            iStack28 = in_ECX[5];\n            fcn.0044f70e();\n            if ((uVar1 & 2 | 1) != 0) {\n                (*_sym.imp.USER32.dll_InflateRect)(&lprc, 1, 1);\n            }\n            iVar3 = (*_sym.imp.USER32.dll_PtInRect)(&lprc, pt, arg_ch);\n            if (iVar3 == 0) {\n                return -1;\n            }\n        }\n        iVar3 = 8;\n    }\n    return iVar3;\n}\n",
        "token_count": 501
    },
    "0042a064": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042a064(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_16ch;\n    uint pvParam;\n    uint var_c8h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x160);\n    extraout_ECX[1] = NULL;\n    *(unaff_EBP + -0x16c) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CChevronOwnerDrawMenu.0;\n    extraout_ECX[3] = NULL;\n    extraout_ECX[2] = vtable.CFont.0;\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.0042da14();\n    iVar2 = (-(uVar1 < 0x60001) & 0xfffffffc) + 0x158;\n    *(unaff_EBP + -0x168) = iVar2;\n    (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x29, iVar2, unaff_EBP + -0x168, 0);\n    fcn.00401120(unaff_EBP + -200);\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 321
    },
    "0042bcc6": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14ch\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042bcc6(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    ulong uVar3;\n    uint var_14ch;\n    uint lpFindFileData;\n    uint var_140h;\n    uint var_138h;\n    uint var_130h;\n    uint var_128h;\n    uint32_t var_124h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if ((arg_8h != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h),  iVar1 < 0x104)) {\n        iVar1 = fcn.0042b4c9(arg_ch + 0x22, arg_8h);\n        if (iVar1 == 0) {\n            *(arg_ch + 0x22) = 0;\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(arg_8h, &lpFindFileData);\n            if (iVar1 != -1) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n                *(arg_ch + 8) = lpFindFileData & 0x7f;\n                uVar3 = fcn.0045d480();\n                arg_ch[6] = uVar3;\n                arg_ch[6] = arg_ch[6] | var_124h;\n                arg_ch[7] = uVar3 >> 0x20;\n                arg_ch[7] = arg_ch[7];\n                iVar1 = fcn.0042ba45(&var_140h);\n                if (iVar1 == 0) {\n                    *arg_ch = 0;\n                    arg_ch[1] = 0;\n                }\n                else {\n                    puVar2 = fcn.0042bb68(&var_140h, 0xffffffff);\n                    *arg_ch = *puVar2;\n                    arg_ch[1] = puVar2[1];\n                }\n                iVar1 = fcn.0042ba45(&var_138h);\n                if (iVar1 == 0) {\n                    arg_ch[4] = 0;\n                    arg_ch[5] = 0;\n                }\n                else {\n                    puVar2 = fcn.0042bb68(&var_138h, 0xffffffff);\n                    arg_ch[4] = *puVar2;\n                    arg_ch[5] = puVar2[1];\n                }\n                iVar1 = fcn.0042ba45(&var_130h);\n                if (iVar1 == 0) {\n                    arg_ch[2] = 0;\n                    arg_ch[3] = 0;\n                }\n                else {\n                    puVar2 = fcn.0042bb68(&var_130h, 0xffffffff);\n                    arg_ch[2] = *puVar2;\n                    arg_ch[3] = puVar2[1];\n                }\n                if ((*arg_ch | arg_ch[1]) == 0) {\n                    *arg_ch = arg_ch[2];\n                    arg_ch[1] = arg_ch[3];\n                }\n                if ((arg_ch[4] | arg_ch[5]) == 0) {\n                    arg_ch[4] = arg_ch[2];\n                    arg_ch[5] = arg_ch[3];\n                }\n            }\n        }\n    }\n    fcn.0045843c(var_14ch);\n    return;\n}\n",
        "token_count": 804
    },
    "0042c326": {
        "rules": [
            "hash data using djb2/6ad21e310d674441ba35d7276afbe57d",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042c326(uint8_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t extraout_ECX;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = 0;\n    if (arg_8h != NULL) goto code_r0x0042c342;\n    uVar3 = fcn.0041638e();\n    uVar2 = extraout_ECX;\n    do {\n        iVar1 = uVar3 * 0x21 + uVar2;\n        arg_8h = (uVar3 >> 0x20) + 1;\ncode_r0x0042c342:\n        uVar3 = CONCAT44(arg_8h, iVar1);\n        uVar2 = *arg_8h;\n    } while (*arg_8h != 0);\n    return iVar1;\n}\n",
        "token_count": 197
    },
    "00433d44": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00433d44(code **param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    *param_1 = vtable.CDockState.0;\n    fcn.0042c1e0();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    param_1[0x11] = 0x2;\n    param_1[6] = NULL;\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    pcVar2 = (*pcVar1)(0);\n    param_1[9] = pcVar2;\n    pcVar2 = (*pcVar1)(1);\n    param_1[10] = pcVar2;\n    pcVar2 = (*pcVar1)(0x4c);\n    param_1[0xb] = pcVar2;\n    pcVar2 = (*pcVar1)(0x4d);\n    param_1[0xc] = pcVar2;\n    pcVar2 = (*pcVar1)(0x4e);\n    param_1[0xd] = pcVar2;\n    pcVar2 = (*pcVar1)(0x4f);\n    param_1[0xe] = pcVar2;\n    iVar3 = (*pcVar1)(0xb);\n    param_1[0xd] = param_1[0xd] + -iVar3;\n    iVar3 = (*pcVar1)(0xc);\n    pcVar2 = param_1[0xe];\n    iVar4 = (*pcVar1)(0x33);\n    param_1[0xe] = pcVar2 + (-iVar4 - iVar3);\n    return param_1;\n}\n",
        "token_count": 390
    },
    "004379bc": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nint32_t fcn.004379bc(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041ff5e();\n    return iVar1 + 0x30;\n}\n",
        "token_count": 45
    },
    "0043e84d": {
        "rules": [
            "encrypt data using HC-128/11bb23636d2a4650a9dbaa6512d69580"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_13h\n\nvoid __cdecl fcn.0043e84d(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    code *pcVar5;\n    uint32_t uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t unaff_EBP;\n    uint var_168h;\n    uint var_164h;\n    uint var_160h;\n    uint var_154h;\n    uint var_14ch;\n    uint var_148h;\n    uint var_144h;\n    uint var_140h;\n    uint var_13ch;\n    uint var_134h;\n    uint var_130h;\n    uint var_12ch;\n    uint var_124h;\n    uint lParam;\n    uint var_11ch;\n    uint lpFilename;\n    uint var_13h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x15c);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    *(unaff_EBP + -0x124) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x130) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x120) = 0;\n    *(unaff_EBP + -0x11c) = 0;\n    uVar4 = (*pcVar1)(0x47ef10);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    *(unaff_EBP + -0x134) = uVar4;\n    pcVar5 = (*pcVar7)(uVar4, \"GetUserDefaultUILanguage\");\n    if (pcVar5 == NULL) {\n        iVar8 = (*pcVar1)(\"ntdll.dll\");\n        if (iVar8 != 0) {\n            *(unaff_EBP + -0x120) = 0;\n            (*_sym.imp.KERNEL32.dll_EnumResourceLanguagesA)(iVar8, 0x10, 1, fcn.0043defd, unaff_EBP + -0x120);\n            pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n            if (*(unaff_EBP + -0x120) != 0) {\n                uVar6 = *(unaff_EBP + -0x120) & 0x3ff;\n                uVar4 = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)((*(unaff_EBP + -0x120) >> 10) << 10 | uVar6);\n                *(unaff_EBP + -0x148) = uVar4;\n                uVar4 = (*pcVar1)(uVar6);\n                *(unaff_EBP + -0x144) = uVar4;\n                *(unaff_EBP + -0x11c) = 2;\n            }\n        }\n    }\n    else {\n        uVar6 = (*pcVar5)();\n        pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n        *(unaff_EBP + -0x120) = uVar6 & 0xffff;\n        *(unaff_EBP + -0x11c) = uVar6 & 0x3ff;\n        uVar4 = (*pcVar1)(uVar6 & 0xffff);\n        *(unaff_EBP + -0x148) = uVar4;\n        uVar4 = (*pcVar1)(*(unaff_EBP + -0x11c));\n        *(unaff_EBP + -0x144) = uVar4;\n        *(unaff_EBP + -0x11c) = 2;\n        pcVar7 = (*pcVar7)(*(unaff_EBP + -0x134), \"GetSystemDefaultUILanguage\");\n        if (pcVar7 != NULL) {\n            uVar3 = (*pcVar7)();\n            *(unaff_EBP + -0x120) = uVar3;\n            uVar4 = (*pcVar1)(uVar3);\n            *(unaff_EBP + -0x140) = uVar4;\n            uVar4 = (*pcVar1)(uVar3 & 0x3ff);\n            *(unaff_EBP + -0x13c) = uVar4;\n            *(unaff_EBP + -0x11c) = 4;\n        }\n    }\n    iVar8 = *(unaff_EBP + -0x11c);\n    *(unaff_EBP + -0x11c) = *(unaff_EBP + -0x11c) + 1;\n    *(unaff_EBP + -0x148 + iVar8 * 4) = 0x800;\n    *(unaff_EBP + -0x13) = 0;\n    *(unaff_EBP + -0x14) = 0;\n    iVar8 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0x400000, unaff_EBP + -0x118, 0x105);\n    if (iVar8 != 0) {\n        fcn.00458b20(unaff_EBP + -0x168, 0, 0x20);\n        *(unaff_EBP + -0x168) = 0x20;\n        *(unaff_EBP + -0x160) = unaff_EBP + -0x118;\n        *(unaff_EBP + -0x154) = 1000;\n        *(unaff_EBP + -0x14c) = 0x400000;\n        *(unaff_EBP + -0x164) = 0x88;\n        fcn.0043df17(0xffffffff);\n        *(unaff_EBP + -4) = 0;\n        cVar2 = fcn.0043dfce(unaff_EBP + -0x168);\n        if (cVar2 != '\\0') {\n            fcn.0043e008();\n        }\n        iVar8 = 0;\n        if (0 < *(unaff_EBP + -0x11c)) {\n            do {\n                iVar9 = fcn.0043e4c1(*(unaff_EBP + -0x148 + iVar8 * 4));\n                if (iVar9 != 0) break;\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < *(unaff_EBP + -0x11c));\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0043e593();\n    }\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 1491
    },
    "0044b044": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b044(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    \n    if (arg_8h != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(arg_8h);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(arg_8h);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 138
    },
    "004565db": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: hRgn\n\nvoid __cdecl fcn.004565db(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint hRgn;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    if (*(unaff_EBP + 8) == 0) {\n        fcn.0041638e();\n    }\n    piVar1 = extraout_ECX + 0x19;\n    fcn.0040b910(piVar1);\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x25);\n    extraout_ECX[0x16] = extraout_ECX[0x1a] - iVar3;\n    iVar3 = (*pcVar2)(0x25);\n    extraout_ECX[0x18] = iVar3 + extraout_ECX[0x1a];\n    iVar4 = (*pcVar2)(0x24);\n    iVar3 = *piVar1;\n    extraout_ECX[0x15] = *piVar1 - iVar4;\n    iVar4 = (*pcVar2)(0x24);\n    extraout_ECX[0x17] = iVar4 + iVar3;\n    *(unaff_EBP + -0x10) = *extraout_ECX;\n    uVar5 = fcn.0041dbe1(0x800, 0, 0, 0);\n    uVar5 = (**(*(unaff_EBP + -0x10) + 0x5c))(0x88, uVar5);\n    *(unaff_EBP + -0x10) = uVar5;\n    fcn.00408480(*(unaff_EBP + 8));\n    if (*(unaff_EBP + -0x10) != 0) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -0x18) = vtable.CRgn.0;\n        *(unaff_EBP + -4) = 0;\n        uVar5 = (*_sym.imp.GDI32.dll_CreateEllipticRgn)(0, 0, 0x20, 0x20);\n        fcn.00417780(uVar5);\n        (*_sym.imp.USER32.dll_SetWindowRgn)(extraout_ECX[8], *(unaff_EBP + -0x14), 1);\n        uVar5 = (*_sym.imp.USER32.dll_SetCapture)(extraout_ECX[8]);\n        fcn.0041af14(uVar5);\n        (*_sym.imp.USER32.dll_SetTimer)(extraout_ECX[8], 0xe000, 0x32, 0);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x18) = vtable.CRgn.0;\n        fcn.00402550();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 760
    },
    "00401040": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00401040(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    uint16_t *puVar3;\n    uint32_t unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(param_1, param_2);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    puVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    if (puVar2 != NULL) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_SizeofResource)(param_1, param_2);\n        puVar3 = iVar1 + puVar2;\n        for (unaff_EDI = unaff_EDI & 0xf; unaff_EDI != 0; unaff_EDI = unaff_EDI - 1) {\n            if (puVar3 <= puVar2) {\n                return 0;\n            }\n            puVar2 = puVar2 + *puVar2 + 1;\n        }\n        if (puVar2 < puVar3) {\n            return -(*puVar2 != 0) & puVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 277
    },
    "004010b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004010b0(uint param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_1, (param_2 >> 4) + 1 & 0xffff, 6);\n    if (iVar1 == 0) {\n        return;\n    }\n    fcn.00401040(param_1, iVar1, param_2);\n    return;\n}\n",
        "token_count": 106
    },
    "00401170": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401170(int32_t param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)(*(param_1 + 8), param_3, param_4);\n    return;\n}\n",
        "token_count": 70
    },
    "00401260": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00401260(code **param_1)\n\n{\n    uint32_t uVar1;\n    uint arg_8h;\n    int32_t **in_FS_OFFSET;\n    int32_t *piVar2;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46eba8;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    fcn.00417038(uVar1);\n    piVar2 = NULL;\n    uStack4 = 0;\n    *param_1 = vtable.CDisplayIC.0;\n    arg_8h = (*_sym.imp.GDI32.dll_CreateICA)(\"DISPLAY\", 0, 0, 0);\n    fcn.004174ae(arg_8h);\n    *in_FS_OFFSET = piVar2;\n    return param_1;\n}\n",
        "token_count": 231
    },
    "00401570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00401570(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint arg_8h;\n    int32_t *in_FS_OFFSET;\n    uint uStack84;\n    uint uStack80;\n    uchar auStack72 [8];\n    uint uStack64;\n    int32_t iStack28;\n    uint uStack20;\n    uint *puStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46ebd8;\n    puStack12 = *in_FS_OFFSET;\n    uVar2 = *0x4987a4 ^ &stack0xffffffa8;\n    *in_FS_OFFSET = &puStack12;\n    fcn.00401260(uVar2);\n    uStack4 = 0;\n    arg_8h = fcn.004178bb(param_1 + 0x74);\n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(uStack80, auStack72);\n    fcn.004178bb(arg_8h);\n    puVar1 = puStack12;\n    *puStack12 = uStack64;\n    puStack12[1] = uStack84;\n    uStack20 = 0xffffffff;\n    fcn.0041752d();\n    *in_FS_OFFSET = iStack28;\n    return puVar1;\n}\n",
        "token_count": 313
    },
    "00401710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401710(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBP;\n    int32_t **ppiVar6;\n    \n    iVar2 = *param_1;\n    iVar3 = *(iVar2 + -0xc);\n    ppiVar6 = iVar2 + -0x10;\n    puVar4 = (**(**ppiVar6 + 0x10))();\n    iVar5 = (***puVar4)(param_2, 1);\n    if (iVar5 == 0) {\n        fcn.004016c0();\n    }\n    if (iVar3 < param_2) {\n        param_2 = iVar3;\n    }\n    fcn.0045850c(iVar5 + 0x10, param_2 + 1, iVar2, param_2 + 1);\n    *(iVar5 + 4) = iVar3;\n    piVar1 = iVar2 + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar6 + 4))(ppiVar6);\n    }\n    *unaff_EBP = iVar5 + 0x10;\n    return;\n}\n",
        "token_count": 332
    },
    "004018a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004018a0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    \n    if (param_2 == NULL) {\n        fcn.00401000(0x80004005);\n        param_2 = extraout_ECX;\n    }\n    iVar1 = (**(*param_2 + 0xc))();\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 122
    },
    "00401930": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401930(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    bool bVar5;\n    int32_t iVar6;\n    \n    if (param_2 == 0) {\n        *param_1 = 0;\n        return;\n    }\n    iVar6 = param_2;\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_2);\n    iVar1 = iVar1 + 1;\n    fcn.004017d0(param_1, iVar1, param_1 + 1, 0x80);\n    iVar4 = param_2;\n    iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(param_2, 0, param_2, iVar1, *param_1, iVar1);\n    bVar5 = iVar2 == 0;\n    if (bVar5) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar2 == 0x7a) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(iVar6, 0, param_2, iVar1, 0, 0);\n            fcn.004017d0(param_1, uVar3, param_1 + 1, 0x80);\n            iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(iVar4, 0, param_2, iVar1, *param_1, uVar3);\n            bVar5 = iVar4 == 0;\n        }\n        if (bVar5) {\n            fcn.00401020();\n        }\n    }\n    return;\n}\n",
        "token_count": 397
    },
    "00401a30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771",
            "PEB access",
            "contain loop",
            "resolve function by parsing PE exports"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401a30(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uchar *puVar6;\n    uchar *extraout_ECX;\n    uchar *puVar7;\n    int32_t unaff_EDI;\n    uchar *X;\n    int32_t *in_FS_OFFSET;\n    int32_t iVar8;\n    uchar *puVar9;\n    uchar *puVar10;\n    uchar *cx;\n    uchar *puStack220;\n    int32_t iStack216;\n    uint uStack212;\n    uchar *puStack208;\n    int32_t iStack204;\n    int32_t *piStack200;\n    int32_t *piStack196;\n    int32_t *piVar11;\n    int32_t *piVar12;\n    int32_t iStack184;\n    int32_t iStack180;\n    uchar *puStack176;\n    uint32_t uStack172;\n    uchar *puStack160;\n    uchar auStack128 [8];\n    int32_t iStack120;\n    uint uStack112;\n    uchar auStack100 [4];\n    uint uStack96;\n    int32_t iStack80;\n    int32_t iStack72;\n    uchar *puStack56;\n    uint uStack28;\n    int32_t iStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    puStack160 = &stack0xfffffffc;\n    uStack12 = 0xffffffff;\n    uStack16 = 0x46ec08;\n    iStack20 = *in_FS_OFFSET;\n    uStack172 = *0x4987a4 ^ &stack0xffffff58;\n    *in_FS_OFFSET = &stack0xffffffec;\n    puStack176 = &stack0xffffff9c;\n    iStack180 = 0x401a6f;\n    fcn.00401570();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iStack180 = 0xc;\n    (*_sym.imp.USER32.dll_GetSystemMetrics)();\n    iStack184 = 0xb;\n    iVar2 = (*pcVar1)();\n    X = iVar2 / 2;\n    piVar12 = param_1;\n    iStack120 = iVar2;\n    fcn.00417546(param_1);\n    piVar11 = param_1 + 0x1d;\n    uStack28 = 0;\n    piStack196 = 0x401ad2;\n    fcn.004178bb(piVar11);\n    pcVar1 = _sym.imp.GDI32.dll_GetTextExtentPoint32A;\n    piStack196 = &stack0xffffff88;\n    piStack200 = 0x3;\n    iStack204 = 0x475cb4;\n    puStack208 = puStack56;\n    uStack212 = 0x401af2;\n    (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)();\n    uStack212 = 8;\n    iStack216 = iStack72;\n    puStack220 = 0x401b02;\n    iVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)();\n    puStack176 = iVar3 * 5 + (iVar3 * 5 >> 0x1f & 7U) >> 3;\n    iVar3 = param_1[0x50];\n    puStack220 = &stack0xffffff80;\n    (*pcVar1)(iStack80, iVar3, *(iVar3 + -0xc));\n    puVar10 = param_1[0x51];\n    (*pcVar1)(uStack96, puVar10, *(puVar10 + -0xc));\n    piStack196 = piVar12;\n    piStack200 = piVar11;\n    puVar5 = param_1[0x54];\n    puStack220 = piStack200 + iVar2 + X * 3;\n    puVar6 = (puVar5 + 1) * X;\n    iVar2 = 0;\n    cx = puVar6;\n    piVar11 = piStack200;\n    if (0 < puVar5) {\n        do {\n            if (iVar2 < 0) goto code_r0x00401beb;\n            if (param_1[0x54] <= iVar2) goto code_r0x00401beb;\n            if (param_1[0x54] <= iVar2) goto code_r0x00401beb;\n            (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                      (uStack112, *(param_1[0x53] + iVar2 * 4), *(*(param_1[0x53] + iVar2 * 4) + -0xc), &stack0xffffff58\n                      );\n            puVar6 = cx + unaff_EDI + puStack176 * 2;\n            iVar2 = iVar2 + 1;\n            cx = puVar6;\n        } while (iVar2 < puVar5);\n    }\n    puVar5 = puStack208;\n    cx = puVar6;\n    if (puStack208 <= puStack220) goto code_r0x00401bf0;\n    do {\n        if (puStack220 <= puStack160) {\n            puStack220 = puStack160;\n        }\n        if (puStack220 <= puVar6) {\n            puStack220 = puVar6;\n        }\n        puVar6 = puStack220;\n        iVar8 = 0;\n        puVar9 = X;\n        puVar7 = X;\n        iVar2 = iStack184;\n        fcn.0041822e(0, X, X, 0xb, iStack216, 4);\n        puVar4 = puVar6 + X * -3 + -0xb;\n        puVar5 = puStack220;\n        if (puVar4 < iStack216) {\n            (*_sym.imp.USER32.dll_SetRect)(&stack0xffffff60, 0, 0, puVar4, 0x7fff);\n            puVar5 = (*_sym.imp.USER32.dll_DrawTextA)\n                               (puStack160, param_1[0x51], *(param_1[0x51] + -0xc), &stack0xffffff4c, 0xc50);\n            cx = puVar4;\n        }\n        fcn.0041822e(0, puStack208 + X * 2, X, cx, puVar5, 4);\n        if (puVar5 <= puVar7) {\n            puVar5 = puVar7;\n            puVar10 = puVar7;\n        }\n        piStack196 = puVar5 + X * 2;\n        puVar7 = piStack196 + X + iVar2;\n        iVar2 = piStack196 + iVar2;\n        piStack200 = (puVar6 + (X * 2 - iVar8)) / 2;\n        iVar8 = 0;\n        puVar5 = puVar6;\n        if (param_1[0x54] < 1) {\ncode_r0x00401d98:\n            (*_sym.imp.USER32.dll_SetRect)(&stack0xffffff38, 0, 0, puVar6);\n            (**(*param_1 + 0x68))(&stack0xffffff24);\n            iVar8 = iStack216 - cx;\n            iVar3 = puStack220 - iVar3;\n            (*_sym.imp.GDI32.dll_GetDeviceCaps)(iVar2, 10);\n            iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(piStack196, 8);\n            fcn.0041822e(0, (puVar10 + (iVar2 - &stack0xffffff50)) / 2, (puVar7 - (cx - iStack80)) / 2, iVar3, iVar8, \n                         0x14);\n            fcn.004178bb(0);\n            puStack208 = 0xffffffff;\n            fcn.0041759a();\n            *in_FS_OFFSET = iStack216;\n            return;\n        }\n        while ((puVar6 = puVar9,  -1 < iVar8 && (iVar8 < param_1[0x54]))) {\n            if (param_1[0x54] <= iVar8) break;\n            (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                      (puStack160, *(param_1[0x53] + iVar8 * 4), *(*(param_1[0x53] + iVar8 * 4) + -0xc), \n                       &stack0xffffff30);\n            puVar5 = unaff_EDI - puStack176;\n            uStack172 = iVar2 + iStack204 * 2 + iStack180;\n            fcn.00418120(iStack180, puStack176, uStack172 - iStack180, puVar5, 1);\n            piStack200 = piVar11 + X;\n            iVar8 = iVar8 + 1;\n            puVar9 = puVar6;\n            if (param_1[0x54] <= iVar8) goto code_r0x00401d98;\n        }\ncode_r0x00401beb:\n        fcn.0041638e();\n        puVar6 = extraout_ECX;\ncode_r0x00401bf0:\n        puStack220 = puVar5;\n    } while( true );\n}\n",
        "token_count": 2045
    },
    "00401e60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00401e60(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00401000(0x80004005);\n    }\n    iVar2 = (**(*piVar1 + 0xc))();\n    *param_1 = iVar2 + 0x10;\n    return param_1;\n}\n",
        "token_count": 121
    },
    "004022e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004022e0(int32_t *param_1, uint param_2, uint32_t param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort *puVar3;\n    uint uVar4;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_2, (param_3 >> 4) + 1 & 0xffff, 6);\n    if (iVar2 != 0) {\n        puVar3 = fcn.00401040(param_2, iVar2, param_3);\n        if (puVar3 != NULL) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(3, 0, puVar3 + 1, *puVar3, 0, 0, 0, 0);\n            if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - iVar2) < 0) {\n                fcn.004019e0(iVar2);\n            }\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(3, 0, puVar3 + 1, *puVar3, *param_1, iVar2, 0, 0);\n            if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n                *(*param_1 + -0xc) = iVar2;\n                *(iVar2 + *param_1) = 0;\n                return 1;\n            }\n            fcn.00401000(0x80070057);\n            pcVar1 = swi(3);\n            uVar4 = (*pcVar1)();\n            return uVar4;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 391
    },
    "004023a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004023a0(int32_t *param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t unaff_EDI;\n    uint32_t uVar3;\n    int32_t unaff_retaddr;\n    int32_t in_stack_ffffffec;\n    \n    if (param_3 == 0) {\n        fcn.004018d0();\n        return;\n    }\n    if (param_2 != 0) goto code_r0x004023c8;\n    do {\n        fcn.00401000();\n        param_2 = extraout_ECX;\ncode_r0x004023c8:\n        iVar1 = *param_1;\n        uVar2 = *(iVar1 + -0xc);\n        uVar3 = param_2 - iVar1;\n        if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - param_3) < 0) {\n            param_2 = unaff_retaddr;\n            in_stack_ffffffec = param_3;\n            fcn.004019e0(param_3, unaff_EDI, unaff_EBP);\n            unaff_retaddr = param_2;\n        }\n        unaff_EBP = unaff_EDI;\n        unaff_EDI = in_stack_ffffffec;\n        iVar1 = *param_1;\n        if (uVar2 < uVar3) {\n            fcn.0045850c(iVar1, *(iVar1 + -8), param_2, param_3);\n        }\n        else {\n            fcn.00458589(iVar1, *(iVar1 + -8), iVar1 + uVar3, param_3);\n        }\n        in_stack_ffffffec = unaff_EDI;\n    } while ((param_3 < 0) || (*(*param_1 + -8) < param_3));\n    *(*param_1 + -0xc) = param_3;\n    *(param_3 + *param_1) = 0;\n    return;\n}\n",
        "token_count": 479
    },
    "00402430": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00402430(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (param_2 == 0) {\n        fcn.00401000(0x80070057);\n    }\n    iVar2 = fcn.00458786(param_2, param_2);\n    if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - iVar2) < 0) {\n        fcn.004019e0(iVar2);\n    }\n    fcn.004588f6(*param_1, iVar2 + 1, param_2, param_2);\n    if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = iVar2;\n        *(iVar2 + *param_1) = 0;\n        return;\n    }\n    fcn.00401000(0x80070057);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 250
    },
    "00402550": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402550(code **param_1)\n\n{\n    int32_t **in_FS_OFFSET;\n    uint in_stack_fffffde0;\n    int32_t *piStack532;\n    uint uStack528;\n    uint uStack524;\n    uchar auStack520 [512];\n    uint32_t uStack8;\n    \n    uStack528 = 0x46ec68;\n    piStack532 = *in_FS_OFFSET;\n    uStack8 = *0x4987a4 ^ auStack520;\n    *in_FS_OFFSET = &piStack532;\n    *param_1 = vtable.CGdiObject.0;\n    uStack524 = 0;\n    fcn.004177d8();\n    *in_FS_OFFSET = piStack532;\n    fcn.0045843c(in_stack_fffffde0);\n    return;\n}\n",
        "token_count": 185
    },
    "00402c50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00402c50(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7, \n                 uint param_8)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack36;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46eddb;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xfffffe94;\n    *in_FS_OFFSET = &piStack12;\n    fcn.004029f0(param_1, param_2, param_3, param_4, param_7, param_8, uVar1);\n    uVar2 = fcn.00402250();\n    fcn.00402670();\n    *in_FS_OFFSET = piStack36;\n    return uVar2;\n}\n",
        "token_count": 241
    },
    "004039b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004039b0(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t **ppiVar4;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46eee8;\n    piStack12 = *in_FS_OFFSET;\n    uVar3 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    ppiVar4 = *(param_1 + 200) + -0x10;\n    uStack4 = 0;\n    piVar1 = *(param_1 + 200) + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar4 + 4))(ppiVar4, uVar3);\n    }\n    fcn.0041e2c6();\n    uStack4 = 0xffffffff;\n    fcn.0041ec27();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 288
    },
    "00403e40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00403e40(uint param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t **in_FS_OFFSET;\n    uint unaff_retaddr;\n    int32_t *piStack24;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46ef58;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffff88;\n    *in_FS_OFFSET = &piStack12;\n    fcn.0040abc0(param_1, 0, uVar1);\n    piStack12 = NULL;\n    uVar2 = fcn.0040a050(unaff_retaddr);\n    fcn.0040a900();\n    *in_FS_OFFSET = piStack24;\n    return uVar2;\n}\n",
        "token_count": 206
    },
    "00404080": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404080(void)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if (*0x499ba4 == 0) {\n        puVar3 = 0x49635c;\n        do {\n            pcVar1 = puVar3[2];\n            if ((pcVar1 != NULL) && (*pcVar1 != '\\0')) {\n                iVar2 = fcn.00403fc0(pcVar1);\n                if (iVar2 == 0) {\n                    *puVar3 = 0;\n                    puVar3[-1] = 0;\n                }\n            }\n            puVar3 = puVar3 + 6;\n        } while (puVar3 < 0x49644c);\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        if (iVar2 != 0) {\n            *0x4963ec = 0;\n            *0x4963e8 = 0;\n        }\n        *0x499ba4 = 1;\n    }\n    return;\n}\n",
        "token_count": 239
    },
    "004041b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004041b0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404010(*param_2 + -0x10);\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 81
    },
    "004041d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004041d0(int32_t *param_1, int32_t param_2, uint param_3, uint *param_4)\n\n{\n    int32_t iVar1;\n    uint *extraout_ECX;\n    uint *extraout_ECX_00;\n    int32_t unaff_retaddr;\n    \n    if (param_4 == NULL) {\n        fcn.00401000(0x80004005);\n        param_4 = extraout_ECX;\n    }\n    if (unaff_retaddr != 0) goto code_r0x00404201;\n    if (param_2 == 0) goto code_r0x00404201;\n    do {\n        fcn.00401000();\n        param_4 = extraout_ECX_00;\ncode_r0x00404201:\n        iVar1 = (***param_4)(param_2, 1);\n        if (iVar1 == 0) {\n            iVar1 = fcn.004016c0();\n        }\n        *param_1 = iVar1 + 0x10;\n    } while ((param_2 < 0) || (*(iVar1 + 8) < param_2));\n    *(iVar1 + 4) = param_2;\n    *(param_2 + *param_1) = 0;\n    fcn.0045850c(*param_1, param_2, unaff_retaddr, param_2);\n    return param_1;\n}\n",
        "token_count": 323
    },
    "00404280": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.00404280(void)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    bool bVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    uint uStack576;\n    uint uStack572;\n    uint uStack568;\n    uchar *puStack564;\n    uchar auStack560 [4];\n    uint uStack556;\n    uint32_t uStack552;\n    uint uStack540;\n    uchar *puStack336;\n    uchar auStack332 [20];\n    uint uStack312;\n    uchar *puStack304;\n    uchar auStack300 [232];\n    uint uStack68;\n    int32_t iStack44;\n    int32_t iStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46efbb;\n    iStack12 = *in_FS_OFFSET;\n    uStack552 = *0x4987a4 ^ &stack0xfffffddc;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack556 = 3;\n    bVar2 = false;\n    puStack564 = 0x4042c1;\n    fcn.00401930();\n    puStack564 = &stack0xfffffddc;\n    uStack568 = 0;\n    uStack572 = 0;\n    uStack576 = 0x10;\n    iVar1 = (*_sym.imp.ole32.dll_StgOpenStorage)(uStack540);\n    if (puStack564 != &stack0xfffffdd0) {\n        fcn.004585e6(puStack564);\n    }\n    if (iVar1 == 0) {\n        puStack304 = &stack0xfffffed4;\n        fcn.00401930(0x478cfc, 3);\n        piVar4 = NULL;\n        piVar3 = 0x10;\n        iStack44 = 0;\n        iVar1 = (**(_pe_dos_header + 0x10))(0, uStack312, 0, 0x10, 0, &stack0xfffffdc0);\n        uStack68 = 0xffffffff;\n        if (puStack336 != &stack0xfffffeb4) {\n            fcn.004585e6(puStack336);\n        }\n        bVar2 = iVar1 == 0;\n        if (bVar2) {\n            (**(*piVar4 + 8))(piVar4);\n        }\n        (**(*piVar3 + 8))(piVar3);\n    }\n    *in_FS_OFFSET = iStack44;\n    return bVar2;\n}\n",
        "token_count": 578
    },
    "004043a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004043a0(int32_t *param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if (param_3 < 0) {\n        param_3 = 0;\n    }\n    iVar2 = *param_1;\n    iVar1 = *(iVar2 + -0xc);\n    if (iVar1 <= param_3) {\n        iVar2 = fcn.00404010(iVar2 + -0x10);\n        *param_2 = iVar2 + 0x10;\n        return param_2;\n    }\n    if (*(iVar2 + -0x10) != NULL) {\n        iVar2 = (**(**(iVar2 + -0x10) + 0x10))();\n        if (iVar2 != 0) goto code_r0x00404401;\n    }\n    piVar3 = fcn.0041f6b5();\n    iVar2 = (**(*piVar3 + 0x10))();\ncode_r0x00404401:\n    fcn.004041d0((*param_1 - param_3) + iVar1, param_3, iVar2);\n    return param_2;\n}\n",
        "token_count": 288
    },
    "00404480": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00404480(int32_t *param_1, char *param_2, char *param_3)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t iVar4;\n    int32_t *unaff_EBX;\n    uint32_t arg_10h;\n    uint32_t uVar5;\n    uint32_t unaff_retaddr;\n    \n    iVar4 = *param_1;\n    uVar3 = *(iVar4 + -0xc);\n    arg_10h = param_2 - iVar4;\n    if (param_3 < 0) {\n        param_2 = fcn.00401000(0x80070057);\n        iVar4 = extraout_ECX;\n    }\n    if (param_2 != NULL) {\n        pcVar1 = param_2 + 1;\n        do {\n            cVar2 = *param_2;\n            param_2 = param_2 + 1;\n        } while (cVar2 != '\\0');\n        param_2 = param_2 + -pcVar1;\n    }\n    if (param_2 < param_3) {\n        param_3 = param_2;\n    }\n    uVar5 = arg_10h;\n    if (uVar3 <= 0x7fffffff - param_3) goto code_r0x004044d4;\n    do {\n        fcn.00401000();\n        iVar4 = extraout_ECX_00;\n        uVar5 = arg_10h;\ncode_r0x004044d4:\n        pcVar1 = param_3 + uVar3;\n        if ((1U - *(iVar4 + -4) | *(iVar4 + -8) - pcVar1) < 0) {\n            fcn.004019e0(pcVar1);\n        }\n        arg_10h = unaff_retaddr;\n        if (uVar5 <= uVar3) {\n            arg_10h = uVar5 + *unaff_EBX;\n        }\n        fcn.0045850c(*unaff_EBX + uVar3, param_3, arg_10h, param_3);\n    } while ((pcVar1 < 0) || (*(*unaff_EBX + -8) < pcVar1));\n    *(*unaff_EBX + -0xc) = pcVar1;\n    pcVar1[*unaff_EBX] = '\\0';\n    return;\n}\n",
        "token_count": 558
    },
    "00404580": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00404580(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack44;\n    int32_t iStack36;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f001;\n    piStack12 = *in_FS_OFFSET;\n    uVar2 = *0x4987a4 ^ &stack0xffffffe4;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack4 = 0;\n    iStack36 = 0x4045bc;\n    piVar3 = fcn.0041f6b5(uVar2);\n    if (piVar3 == NULL) {\n        iStack36 = -0x7fffbffb;\n        piVar3 = fcn.00401000();\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    piVar3 = *(param_1 + 4);\n    uStack8 = 1;\n    piStack44 = 0x4045f2;\n    iVar5 = fcn.0041f625(piVar3);\n    iVar4 = iVar4 + 0x10;\n    if (iVar5 != 0) {\n        fcn.004022e0(iVar5);\n        iVar4 = iStack36;\n        piStack44 = piVar3;\n    }\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar5 = (**(*piVar3 + 0xc))();\n    piVar1 = piStack12;\n    *piStack12 = iVar5 + 0x10;\n    fcn.0041f630(piStack12, iVar4, uStack8, 10);\n    piVar3 = iVar4 + -4;\n    LOCK();\n    iVar5 = *piVar3;\n    *piVar3 = *piVar3 + -1;\n    if (iVar5 == 1 || iVar5 + -1 < 0) {\n        (**(**(iVar4 + -0x10) + 4))(iVar4 + -0x10);\n    }\n    *in_FS_OFFSET = piStack44;\n    return piVar1;\n}\n",
        "token_count": 560
    },
    "00404680": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Heritage AFTER dead removal. Example location: s0xfffffff0 : 0x00404719\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t * fcn.00404680(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t **in_FS_OFFSET;\n    uchar auStack32 [12];\n    int32_t *piStack12;\n    uint uStack8;\n    int32_t *piStack4;\n    \n    piStack4 = 0xffffffff;\n    uStack8 = 0x46f028;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    fcn.00404080();\n    fcn.00404580();\n    piVar3 = piStack4;\n    iVar2 = *(uVar1 - 0xc);\n    piStack12 = NULL;\n    if (iVar2 == 0) {\n        iVar2 = fcn.00404010(uVar1 - 0x10);\n        *piStack4 = iVar2 + 0x10;\n        piVar3 = piStack4;\n    }\n    else {\n        fcn.004043a0(piStack4, iVar2 + -1);\n    }\n    LOCK();\n    (**0x4)(auStack32);\n    *in_FS_OFFSET = 0x2;\n    return piVar3;\n}\n",
        "token_count": 333
    },
    "00404740": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00404740(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t unaff_ESI;\n    int32_t **in_FS_OFFSET;\n    int32_t *unaff_retaddr;\n    int32_t iVar4;\n    uint32_t uStack48;\n    uint auStack32 [2];\n    uchar auStack24 [8];\n    int32_t *piStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f089;\n    piStack12 = *in_FS_OFFSET;\n    uStack48 = *0x4987a4 ^ &stack0xffffffd4;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    auStack32[0] = 0;\n    fcn.00404080();\n    piVar2 = fcn.0041f6b5();\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar2 + 0xc))();\n    *unaff_retaddr = iVar3 + 0x10;\n    uStack8 = 0;\n    iVar3 = 0x496350;\n    do {\n        if (param_1 == 0) {\n            if ((*(iVar3 + 0xc) != 0) && (*(iVar3 + 0x10) == 0)) {\n                iVar4 = 0;\n                piVar2 = fcn.00404580(auStack24);\n                piStack16 = 0x3;\n                fcn.00404480(*piVar2, *(*piVar2 + -0xc));\n                auStack24[0] = 0;\n                piVar2 = unaff_ESI + -4;\n                LOCK();\n                iVar1 = *piVar2;\n                *piVar2 = *piVar2 + -1;\n                if (iVar1 == 1 || iVar1 + -1 < 0) {\n                    (**(**(unaff_ESI + -0x10) + 4))(unaff_ESI + -0x10);\n                }\n                fcn.00404420(0);\n                piVar2 = fcn.00404580(&stack0xffffffd8, 2);\n                fcn.00404480(*piVar2, *(*piVar2 + -0xc));\n                goto code_r0x004048d4;\n            }\n        }\n        else if ((*(iVar3 + 8) != 0) && (*(iVar3 + 0x10) == 0)) {\n            piVar2 = fcn.00404580(auStack32, 1);\n            iVar4 = *(*piVar2 + -0xc);\n            piStack16 = 0x1;\n            fcn.00404480(*piVar2);\n            auStack24[0] = 0;\n            piVar2 = uStack48 - 4;\n            LOCK();\n            iVar1 = *piVar2;\n            *piVar2 = *piVar2 + -1;\n            if (iVar1 == 1 || iVar1 + -1 < 0) {\n                (**(**(uStack48 - 0x10) + 4))(uStack48 - 0x10);\n            }\n            fcn.00404420(0);\n            piVar2 = fcn.00404580(&uStack48, 2);\n            fcn.00404480(*piVar2, *(*piVar2 + -0xc));\ncode_r0x004048d4:\n            piVar2 = iVar4 + -4;\n            LOCK();\n            iVar1 = *piVar2;\n            *piVar2 = *piVar2 + -1;\n            if (iVar1 == 1 || iVar1 + -1 < 0) {\n                (**(**(iVar4 + -0x10) + 4))(iVar4 + -0x10);\n            }\n            fcn.00404420(0);\n        }\n        iVar3 = iVar3 + 0x18;\n        if (0x49643f < iVar3) {\n            *in_FS_OFFSET = piStack16;\n            return unaff_retaddr;\n        }\n    } while( true );\n}\n",
        "token_count": 953
    },
    "00404920": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00404920(int32_t *param_1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t *unaff_EDI;\n    int32_t **in_FS_OFFSET;\n    char *unaff_retaddr;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f0b8;\n    piStack12 = *in_FS_OFFSET;\n    uVar2 = *0x4987a4 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    piVar3 = fcn.0041f6b5(uVar2);\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    *param_1 = iVar4 + 0x10;\n    uStack8 = 0;\n    if (unaff_retaddr == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        if ((unaff_retaddr & 0xffff0000) == 0) {\n            iVar4 = fcn.0041f625(unaff_retaddr & 0xffff);\n            if (iVar4 != 0) {\n                fcn.004022e0(iVar4, unaff_retaddr & 0xffff);\n            }\n            goto code_r0x004049c2;\n        }\n        pcVar5 = unaff_retaddr;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n        iVar4 = pcVar5 - (unaff_retaddr + 1);\n    }\n    fcn.004023a0(unaff_retaddr, iVar4);\ncode_r0x004049c2:\n    *in_FS_OFFSET = unaff_EDI;\n    return param_1;\n}\n",
        "token_count": 473
    },
    "004049e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004049e0(uint param_1, uint param_2)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    char *unaff_ESI;\n    int32_t **in_FS_OFFSET;\n    uint arg_8h;\n    uchar auStack336 [12];\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint32_t uStack304;\n    uint32_t uStack300;\n    int32_t *piStack40;\n    uint uStack32;\n    uchar uStack24;\n    uint uStack20;\n    uint32_t uStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f101;\n    piStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ auStack336;\n    uVar3 = *0x4987a4 ^ &stack0xfffffea0;\n    *in_FS_OFFSET = &piStack12;\n    fcn.0042b032(uVar3);\n    arg_8h = 0x20;\n    uStack4 = 0;\n    iVar4 = fcn.0042b552(param_1, 0x20, param_2);\n    if (iVar4 == 0) {\n        uStack16 = 0xffffffff;\n        fcn.0042b1bf();\n        goto code_r0x00404d2f;\n    }\n    uStack324 = 0;\n    uStack320 = 0;\n    uStack316 = 0;\n    uStack312 = 0;\n    uStack308 = 0;\n    uStack304 = 0;\n    fcn.0042bee0(&uStack324);\n    if ((uStack304 | uStack300) == 0) {\n        fcn.00404920(param_1);\n        uStack24 = 1;\n        fcn.004043a0(&stack0xfffffeac, 4);\n        uStack32 = CONCAT31(uStack32._1_3_, 3);\n        piVar1 = unaff_EBP + -4;\n        LOCK();\n        iVar4 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar4 == 1 || iVar4 + -1 < 0) {\n            (**(**(unaff_EBP + -0x10) + 4))(unaff_EBP + -0x10);\n        }\n        if (*(unaff_ESI + -0xc) < 0) {\n            fcn.00401000(0x80070057);\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrcmpiA;\n        if (*unaff_ESI == '.') {\n            iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(unaff_ESI, \".doc\");\n            if (iVar4 == 0) {\n                fcn.00401e90();\n                uStack32 = 0xffffffff;\ncode_r0x00404b4c:\n                fcn.0042b1bf();\n                goto code_r0x00404d2f;\n            }\n            iVar4 = (*pcVar2)(unaff_ESI, \".rtf\");\n            if (iVar4 == 0) {\n                fcn.00401e90();\n                uStack32 = 0xffffffff;\n                fcn.0042b1bf();\n                goto code_r0x00404d2f;\n            }\n            fcn.00401e90();\n            uStack32 = 0xffffffff;\n        }\n        else {\n            uStack32 = uStack32 & 0xffffff00;\n            piVar1 = unaff_ESI + -4;\n            LOCK();\n            iVar4 = *piVar1;\n            *piVar1 = *piVar1 + -1;\n            if (iVar4 == 1 || iVar4 + -1 < 0) {\n                (**(**(unaff_ESI + -0x10) + 4))(unaff_ESI + -0x10);\n            }\n            uStack32 = 0xffffffff;\n        }\n    }\n    else {\n        iVar4 = fcn.00403ec0(\"{\\\\rtf\");\n        if (iVar4 != 0) {\n            uStack20 = 0xffffffff;\n            fcn.0042b1bf();\n            goto code_r0x00404d2f;\n        }\n        iVar4 = fcn.00403ec0(0x476c38);\n        if (iVar4 != 0) {\n            uStack20 = 0xffffffff;\n            fcn.0042b1bf();\n            goto code_r0x00404d2f;\n        }\n        iVar4 = fcn.00403ec0(0x476c4c);\n        if (iVar4 != 0) {\n            uStack20 = 0xffffffff;\n            fcn.0042b1bf();\n            goto code_r0x00404d2f;\n        }\n        iVar4 = fcn.00403ec0(0x476c44);\n        if ((iVar4 == 0) && (iVar4 = fcn.00403ec0(0x476c48),  iVar4 == 0)) {\n            iVar4 = fcn.00403ec0(0x476c3c);\n            if (iVar4 == 0) {\n                uStack20 = 0xffffffff;\n                goto code_r0x00404d25;\n            }\n            fcn.0042afcc();\n            iVar4 = fcn.00403e40(\"MSWRD632.WPC\", param_1);\n            if (iVar4 != 0) {\n                iVar4 = fcn.00404280();\n                uStack20 = 0xffffffff;\n                if (iVar4 != 0) {\n                    fcn.0042b1bf();\n                    goto code_r0x00404d2f;\n                }\n                goto code_r0x00404b4c;\n            }\n        }\n        else {\n            fcn.0042afcc();\n            iVar4 = fcn.00403e40(\"WRITE32.WPC\", param_1);\n            if (iVar4 != 0) {\n                uStack20 = 0xffffffff;\n                fcn.0042b1bf();\n                goto code_r0x00404d2f;\n            }\n        }\n        uStack20 = 0xffffffff;\n    }\ncode_r0x00404d25:\n    fcn.0042b1bf();\ncode_r0x00404d2f:\n    *in_FS_OFFSET = piStack40;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 1504
    },
    "00404d90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00404d90(code **param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    int32_t *unaff_ESI;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f138;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    fcn.00402d40(0xa0, param_2, uVar1);\n    piStack12 = NULL;\n    *param_1 = vtable.CFileNewDialog.0;\n    fcn.0041997f();\n    param_1[0x1d] = vtable.CListBox.0;\n    param_1[0x32] = 0xffffffff;\n    *in_FS_OFFSET = unaff_ESI;\n    return param_1;\n}\n",
        "token_count": 238
    },
    "00404e20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404e20(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46eee8;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    fcn.0041e2c6(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.0041ec27();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 157
    },
    "00405190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405190(void)\n\n{\n    int32_t in_EAX;\n    uint arg_8h;\n    uint *unaff_ESI;\n    uint uVar1;\n    uint uStack52;\n    \n    if (in_EAX == 0) {\n        in_EAX = fcn.0041638e();\n    }\n    arg_8h = fcn.004178bb(in_EAX);\n    uVar1 = *0x499df8;\n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(*0x499df8, &stack0xffffffc4);\n    fcn.004178bb(arg_8h);\n    unaff_ESI[1] = uVar1;\n    *unaff_ESI = uStack52;\n    return;\n}\n",
        "token_count": 168
    },
    "004051e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004051e0(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f198;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    fcn.0042c1f7(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.0041e3b0();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 159
    },
    "00405370": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00405370(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f198;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    fcn.0041997f(uVar1);\n    uStack4 = 0;\n    *param_1 = vtable.CLocalComboBox.0;\n    fcn.0042c1e0();\n    *in_FS_OFFSET = piStack12;\n    return param_1;\n}\n",
        "token_count": 180
    },
    "00405450": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/01bb0ec37f0e4f748bf40bf8ad1af4de",
            "validate payment card number using luhn algorithm with lookup table/fb60ffb548f34d1da43070d509ac9033"
        ],
        "decompiled_code": "\nvoid fcn.00405450(uchar *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    \n    if (param_1 == NULL) {\n        fcn.0041638e();\n    }\n    *param_1 = 0;\n    if (-1 < param_2) {\n        uVar1 = (param_2 + 5) / 10;\n        uVar2 = uVar1 & 0x80000001;\n        bVar3 = uVar2 == 0;\n        if (uVar2 < 0) {\n            bVar3 = (uVar2 - 1 | 0xfffffffe) == 0xffffffff;\n        }\n        if (bVar3) {\n            fcn.00458b9a(param_1, 10, 0x4771f8, uVar1 / 2);\n            return;\n        }\n        fcn.00458b9a(param_1, 10, \"%.1f\", SUB84(uVar1 * *0x4771f0, 0));\n    }\n    return;\n}\n",
        "token_count": 254
    },
    "00405970": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405970(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    uVar1 = *(param_1 + 0x20);\n    fcn.004180dc();\n    iVar2 = *(param_1 + 0x38);\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x20));\n    }\n    iVar2 = fcn.0041af14(iVar2);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x20), 0x4e, uVar1, &stack0xfffffff0);\n    return;\n}\n",
        "token_count": 162
    },
    "00405a90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00405a90(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    \n    if (param_2 == *(param_1 + 4)) {\n        *(param_1 + 4) = *param_2;\n    }\n    else {\n        *param_2[1] = *param_2;\n    }\n    if (param_2 == *(param_1 + 8)) {\n        *(param_1 + 8) = param_2[1];\n    }\n    else {\n        *(*param_2 + 4) = param_2[1];\n    }\n    *param_2 = *(param_1 + 0x10);\n    piVar1 = param_1 + 0xc;\n    *piVar1 = *piVar1 + -1;\n    *(param_1 + 0x10) = param_2;\n    if (*piVar1 == 0) {\n        fcn.004056a0();\n    }\n    return;\n}\n",
        "token_count": 230
    },
    "00406160": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00406160(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uchar *in_stack_ffffffe0;\n    uchar auStack16 [12];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ auStack16;\n    iVar1 = fcn.00405f30();\n    if (param_2 != iVar1) {\n        in_stack_ffffffe0 = auStack16;\n        fcn.00405450(in_stack_ffffffe0, param_2);\n        fcn.004055d0(&stack0xffffffe8, 1);\n    }\n    *(param_1 + 0x70) = param_2;\n    fcn.0045843c(in_stack_ffffffe0);\n    return;\n}\n",
        "token_count": 185
    },
    "00406200": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406200(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f228;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    *(param_1 + 0x6c) = vtable.CBitmap.0;\n    fcn.00402550(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.004051e0();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 180
    },
    "00406260": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406260(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t unaff_ESI;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ &uStack100;\n    uStack100 = *(param_1 + 0x20);\n    uStack88 = 0x54;\n    uStack96 = fcn.004180dc();\n    iVar1 = *(param_1 + 0x38);\n    uStack92 = 0x1001;\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x20));\n    }\n    iVar1 = fcn.0041af14(iVar1);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(iVar1 + 0x20), 0x4e, uStack100);\n    if ((unaff_ESI & 0x28000000) == 0x28000000) {\n        iVar1 = &uStack84 + 2;\n        fcn.004057c0(iVar1, uStack84);\n    }\n    else {\n        iVar1 = 0x476744;\n        fcn.004055d0(0x476744, 0);\n    }\n    if ((&stack0xffffff98 & 0x80000000) == 0) {\n        unaff_ESI = 0xffffffff;\n    }\n    fcn.00406160(unaff_ESI);\n    fcn.0045843c(iVar1);\n    return;\n}\n",
        "token_count": 382
    },
    "00406540": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406540(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t **ppiVar6;\n    int32_t iVar7;\n    \n    pcVar3 = _sym.imp.USER32.dll_SendMessageA;\n    iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x20), 0x146, 0, 0);\n    iVar7 = 0;\n    if (0 < iVar4) {\n        do {\n            piVar5 = (*pcVar3)(*(param_1 + 0x20), 0x150, iVar7, 0);\n            if (piVar5 != NULL) {\n                ppiVar6 = piVar5[1] + -0x10;\n                piVar1 = piVar5[1] + -4;\n                LOCK();\n                iVar2 = *piVar1;\n                *piVar1 = *piVar1 + -1;\n                if (iVar2 == 1 || iVar2 + -1 < 0) {\n                    (**(**ppiVar6 + 4))(ppiVar6);\n                }\n                ppiVar6 = *piVar5 + -0x10;\n                piVar1 = *piVar5 + -4;\n                LOCK();\n                iVar2 = *piVar1;\n                *piVar1 = *piVar1 + -1;\n                if (iVar2 == 1 || iVar2 + -1 < 0) {\n                    (**(**ppiVar6 + 4))(ppiVar6);\n                }\n                fcn.00414b30(piVar5);\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < iVar4);\n    }\n    return;\n}\n",
        "token_count": 409
    },
    "00406a60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00406a60(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f374;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 2;\n    fcn.004051e0(uVar1);\n    uStack4._0_1_ = 1;\n    fcn.00406200();\n    uStack4 = uStack4._1_3_ << 8;\n    fcn.0041752d();\n    uStack4 = 0xffffffff;\n    fcn.0042c6d8();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 214
    },
    "00406bb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.00406bb0(int32_t *param_1)\n\n{\n    char cVar1;\n    uint32_t *puVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    uint32_t **in_FS_OFFSET;\n    char *unaff_retaddr;\n    uint32_t *puStack12;\n    uint uStack8;\n    char *pcStack4;\n    \n    pcStack4 = 0xffffffff;\n    uStack8 = 0x46f3a3;\n    puStack12 = *in_FS_OFFSET;\n    puVar2 = *0x4987a4 ^ &stack0xffffffe4;\n    *in_FS_OFFSET = &puStack12;\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    *param_1 = iVar4 + 0x10;\n    uStack8 = 0;\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    param_1[1] = iVar4 + 0x10;\n    uStack8 = CONCAT31(uStack8._1_3_, 1);\n    if (unaff_retaddr == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        pcVar5 = unaff_retaddr;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n        iVar4 = pcVar5 - (unaff_retaddr + 1);\n    }\n    fcn.004023a0(unaff_retaddr, iVar4);\n    if (pcStack4 == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        pcVar5 = pcStack4;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n        iVar4 = pcVar5 - (pcStack4 + 1);\n    }\n    fcn.004023a0(pcStack4, iVar4);\n    param_1[3] = unaff_retaddr;\n    *(param_1 + 2) = uStack8;\n    *(param_1 + 9) = pcStack4._0_1_;\n    *in_FS_OFFSET = puVar2;\n    return param_1;\n}\n",
        "token_count": 617
    },
    "00406cd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00406cd0(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint arg_ch;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f3cb;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    if (*(param_2 + 0x17) != 'M') {\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a, uVar1);\n        if ((iVar2 == 0) || (*(param_2 + 0x1c) != '@')) {\n            iVar2 = fcn.00414af6(0x10);\n            uStack4 = 0;\n            if (iVar2 == 0) {\n                arg_ch = 0;\n            }\n            else {\n                arg_ch = fcn.00406bb0();\n            }\n            fcn.00445c59(*(param_1 + 0x5c), arg_ch);\n        }\n    }\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 306
    },
    "00406df0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00406df0(int32_t *param_1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t *unaff_EDI;\n    int32_t **in_FS_OFFSET;\n    char *unaff_retaddr;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f0b8;\n    piStack12 = *in_FS_OFFSET;\n    uVar2 = *0x4987a4 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    piVar3 = fcn.0041f6b5(uVar2);\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    *param_1 = iVar4 + 0x10;\n    uStack8 = 0;\n    if (unaff_retaddr == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        pcVar5 = unaff_retaddr;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n        iVar4 = pcVar5 - (unaff_retaddr + 1);\n    }\n    fcn.004023a0(unaff_retaddr, iVar4);\n    *in_FS_OFFSET = unaff_EDI;\n    return param_1;\n}\n",
        "token_count": 380
    },
    "00407ca0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00407ca0(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f560;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = vtable.CFormatTabDlg.0;\n    uStack4 = 4;\n    fcn.00414b30(param_1[0x4c], uVar1);\n    uStack4._0_1_ = 3;\n    fcn.0041e3b0();\n    uStack4._0_1_ = 2;\n    fcn.0041e24f();\n    uStack4._0_1_ = 1;\n    fcn.0041e24f();\n    uStack4 = uStack4._1_3_ << 8;\n    fcn.0041e24f();\n    uStack4 = 0xffffffff;\n    fcn.0041ec27();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 292
    },
    "00407d90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00407d90(int32_t param_1, int32_t param_2)\n\n{\n    int32_t arg_8h;\n    \n    arg_8h = *(param_1 + 0x130) + param_2 * 4;\n    fcn.00458589(arg_8h, 4, arg_8h + 4, (*(param_1 + 0x134) - param_2) * 4 + -4);\n    *(param_1 + 0x134) = *(param_1 + 0x134) + -1;\n    return;\n}\n",
        "token_count": 136
    },
    "00407e50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00407e50(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint arg_8h;\n    uchar auStack68 [64];\n    uint32_t uStack4;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    uStack4 = *0x4987a4 ^ &stack0xffffffbc;\n    arg_8h = 0;\n    uStack88 = 0;\n    uStack96 = *(param_1 + 0x254);\n    uStack92 = 0x14b;\n    uStack100 = 0x407e7b;\n    (*_sym.imp.USER32.dll_SendMessageA)();\n    iVar2 = 0;\n    if (0 < *(param_1 + 0x134)) {\n        do {\n            uStack100 = 2;\n            fcn.0040ee30(&stack0xffffffac, 0x40, *(*(param_1 + 0x130) + iVar2 * 4));\n            (*pcVar1)(*(param_1 + 0x254), 0x143, 0, &stack0xffffff9c);\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0x134));\n    }\n    uStack88 = 0x407ece;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 342
    },
    "00408240": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00408240(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uchar *puStack36;\n    \n    puStack36 = 0x408252;\n    fcn.004193e4(param_1, 1);\n    puStack36 = &stack0xffffffe4;\n    fcn.00403a50(&stack0xffffffe8);\n    iVar1 = 0x3fb;\n    fcn.00403b50(&stack0xffffffdc, 0x3fb, 0, 0x7bc0);\n    if (iVar1 != 0x7fffffff) {\n        if (*(param_1 + 0x134) != 0x20) {\n            iVar1 = fcn.00407dd0(iVar1);\n            if (iVar1 != 0) {\n                fcn.00407e50();\n            }\n            return 1;\n        }\n        fcn.0041fb58(0xb0, 0, 0xffffffff);\n        (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x254), 0x303, 0, 0);\n    }\n    return 0;\n}\n",
        "token_count": 262
    },
    "004082e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004082e0(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x134)) {\n        piVar2 = *(param_1 + 0x130);\n        do {\n            if (*piVar2 == param_2) {\n                fcn.00407d90(iVar1);\n                return 1;\n            }\n            iVar1 = iVar1 + 1;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 < *(param_1 + 0x134));\n    }\n    return 0;\n}\n",
        "token_count": 163
    },
    "00408eb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00408eb0(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f740;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 4;\n    fcn.00435197(uVar1);\n    uStack4._0_1_ = 3;\n    fcn.004305f9();\n    uStack4._0_1_ = 2;\n    fcn.0040d8d0();\n    uStack4._0_1_ = 1;\n    fcn.00406a60();\n    uStack4 = uStack4._1_3_ << 8;\n    fcn.0042c6d8();\n    uStack4 = 0xffffffff;\n    fcn.0042fb50();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 260
    },
    "00409110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00409110(uint *param_1, int32_t *param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint unaff_EDI;\n    uchar *puStack32;\n    uint uStack28;\n    uchar *puStack24;\n    uint *puStack4;\n    \n    piVar2 = param_2;\n    puStack24 = 0x409122;\n    puStack4 = param_1;\n    fcn.004018d0();\n    uVar3 = param_3;\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n    puStack24 = &stack0x00000004;\n    uStack28 = 0;\n    puStack32 = &stack0xfffffffc;\n    param_2 = NULL;\n    puStack4 = NULL;\n    iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(*param_1, param_3, 0);\n    if (iVar4 != 0) {\n        return 0;\n    }\n    uVar5 = fcn.004090c0(unaff_EDI);\n    (*pcVar1)(*param_1, uVar3, 0, &stack0xffffffe0, uVar5, &stack0xffffffe8);\n    iVar4 = *piVar2;\n    if (((iVar4 == 0) || (iVar4 = fcn.0045905c(iVar4, *(iVar4 + -8)),  -1 < iVar4)) && (iVar4 <= *(*piVar2 + -8))) {\n        *(*piVar2 + -0xc) = iVar4;\n        *(iVar4 + *piVar2) = 0;\n        return 1;\n    }\n    fcn.00401000(0x80070057);\n    return 0;\n}\n",
        "token_count": 429
    },
    "00409b70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00409b70(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f792;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = vtable.CMainFrame.0;\n    uStack4 = 3;\n    fcn.0040d8d0(uVar1);\n    uStack4._0_1_ = 2;\n    fcn.00406a60();\n    uStack4._0_1_ = 1;\n    fcn.004372ee();\n    uStack4 = uStack4._1_3_ << 8;\n    fcn.0042c6d8();\n    uStack4 = 0xffffffff;\n    fcn.004331e9();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 257
    },
    "00409f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00409f50(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n    uVar2 = 0;\n    if (param_1 != 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, iVar3 * 2 + 1);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(uVar2);\n        if (iVar3 != 0) {\n            iVar4 = (*pcVar1)(param_1);\n            fcn.00459195(iVar3, iVar4 * 2 + 1, param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n    }\n    return uVar2;\n}\n",
        "token_count": 222
    },
    "0040a000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040a000(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    \n    pcVar2 = _sym.imp.USER32.dll_MsgWaitForMultipleObjects;\n    uStack40 = 0x40;\n    uStack44 = 0xffffffff;\n    uStack48 = 0;\n    iVar3 = (*_sym.imp.USER32.dll_MsgWaitForMultipleObjects)(1, param_1 + 0x44);\n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while (iVar3 != 0) {\n        (*pcVar1)(&uStack48, 0, 0, 0, 0);\n        iVar3 = (*pcVar2)(1, param_1 + 0x44, 0, 0xffffffff, 0x40);\n    }\n    return;\n}\n",
        "token_count": 219
    },
    "0040a820": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040a820(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t **ppiVar4;\n    int32_t unaff_ESI;\n    int32_t *in_FS_OFFSET;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f839;\n    uStack12 = *in_FS_OFFSET;\n    uVar3 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &uStack12;\n    *param_1 = vtable.CTrackFile.0;\n    uStack4 = 3;\n    fcn.0040a290(100, uVar3);\n    if (param_1[6] != NULL) {\n        fcn.004320be(0xe001);\n    }\n    ppiVar4 = param_1[9] + -0x10;\n    uStack12._0_1_ = 2;\n    piVar1 = param_1[9] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    ppiVar4 = param_1[8] + -0x10;\n    uStack12._0_1_ = 1;\n    piVar1 = param_1[8] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 + -1 < 1) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    ppiVar4 = param_1[7] + -0x10;\n    uStack12 = uStack12._1_3_ << 8;\n    piVar1 = param_1[7] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    uStack12 = 0xffffffff;\n    fcn.0042b1bf();\n    *in_FS_OFFSET = unaff_ESI;\n    return;\n}\n",
        "token_count": 561
    },
    "0040a9d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0040a9d0(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    \n    iVar1 = *param_1;\n    iVar2 = *(iVar1 + -0xc);\n    if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - iVar2) < 0) {\n        fcn.004019e0(iVar2);\n    }\n    uVar4 = fcn.0045917e(*param_1, iVar2 + 1);\n    fcn.00409e60(uVar4);\n    if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = iVar2;\n        *(iVar2 + *param_1) = 0;\n        return param_1;\n    }\n    fcn.00401000(0x80070057);\n    pcVar3 = swi(3);\n    piVar5 = (*pcVar3)();\n    return piVar5;\n}\n",
        "token_count": 262
    },
    "0040aa30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\ncode ** __fastcall fcn.0040aa30(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t **in_FS_OFFSET;\n    code *unaff_retaddr;\n    int32_t *in_stack_ffffffcc;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f889;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffe0;\n    *in_FS_OFFSET = &piStack12;\n    fcn.0042b032(uVar1);\n    uStack4 = 0;\n    *param_1 = vtable.CTrackFile.0;\n    piVar2 = fcn.0041f6b5();\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar2 + 0xc))();\n    param_1[7] = iVar3 + 0x10;\n    uStack8 = CONCAT31(uStack8._1_3_, 1);\n    piVar2 = fcn.0041f6b5();\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar2 + 0xc))();\n    param_1[8] = iVar3 + 0x10;\n    uStack8 = CONCAT31(uStack8._1_3_, 2);\n    piVar2 = fcn.0041f6b5();\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar2 + 0xc))();\n    param_1[9] = iVar3 + 0x10;\n    uStack8 = CONCAT31(uStack8._1_3_, 3);\n    param_1[4] = 0xffffffff;\n    param_1[5] = NULL;\n    param_1[6] = unaff_retaddr;\n    piVar2 = fcn.0041f625(0x69);\n    if (piVar2 != NULL) {\n        fcn.004022e0(piVar2, 0x69);\n        in_stack_ffffffcc = piVar2;\n    }\n    iVar3 = fcn.0041f625(0x68);\n    if (iVar3 != 0) {\n        fcn.004022e0(iVar3, 0x68);\n    }\n    iVar3 = fcn.0041f625(0x71);\n    if (iVar3 != 0) {\n        fcn.004022e0(iVar3, 0x71);\n    }\n    *in_FS_OFFSET = in_stack_ffffffcc;\n    return param_1;\n}\n",
        "token_count": 682
    },
    "0040ad20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.0040ad20(void)\n\n{\n    uint arg_ch;\n    uint arg_8h;\n    int32_t **in_FS_OFFSET;\n    int32_t iVar1;\n    uchar auStack104 [32];\n    int32_t *piStack72;\n    uint32_t uStack64;\n    uint uStack36;\n    uint uStack32;\n    uchar uStack24;\n    int32_t *piStack16;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f910;\n    piStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &piStack12;\n    fcn.00438873(0x400);\n    iVar1 = 0x1000;\n    uStack8 = 0;\n    fcn.0043941a(&stack0xffffff80, 0, 0x1000, 0);\n    uStack24 = 1;\n    (**(*piStack16 + 8))(auStack104);\n    fcn.00439263();\n    arg_ch = fcn.00438931();\n    arg_8h = fcn.00414b25(arg_ch);\n    (**(iVar1 + 0x28))(0, 0, 0);\n    fcn.00438987(arg_8h, arg_ch);\n    fcn.004397c0(uStack36, uStack32, arg_8h, arg_ch);\n    fcn.00414b30(arg_8h);\n    uStack64 = uStack64 & 0xffffff00;\n    fcn.004393dc();\n    uStack64 = 0xffffffff;\n    fcn.00438bcc();\n    *in_FS_OFFSET = piStack72;\n    return;\n}\n",
        "token_count": 393
    },
    "0040ae80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.0040ae80(uint param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t **in_FS_OFFSET;\n    uint uStack132;\n    uchar auStack128 [68];\n    uchar uStack60;\n    int32_t *piStack52;\n    int32_t *piStack28;\n    uint uStack24;\n    uint32_t uStack20;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f910;\n    piStack12 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &piStack12;\n    uStack132 = 0;\n    iVar1 = fcn.00439a19(param_2, param_3, auStack128, &uStack132);\n    if (iVar1 != 0) {\n        fcn.00438873(0x400);\n        uStack24 = 0;\n        fcn.004389db(param_3, param_2);\n        (**(param_2 + 0x28))(0, 0, 0);\n        fcn.0043941a(&stack0xffffff5c, 1, 0x1000, 0);\n        uStack60 = 1;\n        (**(*piStack52 + 8))(&stack0xffffff74);\n        fcn.00439263();\n        fcn.00414b30();\n        uStack20 = uStack20 & 0xffffff00;\n        fcn.004393dc();\n        uStack20 = 0xffffffff;\n        fcn.00438bcc();\n    }\n    *in_FS_OFFSET = piStack28;\n    return;\n}\n",
        "token_count": 383
    },
    "0040aff0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint * __thiscall\nfcn.0040aff0(uint *param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00401000(0x80004005);\n    }\n    iVar2 = (**(*piVar1 + 0xc))();\n    param_1[7] = iVar2 + 0x10;\n    *param_1 = unaff_retaddr;\n    param_1[2] = param_3;\n    param_1[1] = param_2;\n    param_1[3] = param_4;\n    param_1[5] = param_6;\n    param_1[4] = param_5;\n    param_1[6] = param_7;\n    return param_1;\n}\n",
        "token_count": 240
    },
    "0040b050": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0040b050(uint *param_1, uint *param_2)\n\n{\n    *param_1 = *param_2;\n    param_1[1] = param_2[1];\n    param_1[2] = param_2[2];\n    param_1[3] = param_2[3];\n    param_1[4] = param_2[4];\n    param_1[5] = param_2[5];\n    param_1[6] = param_2[6];\n    fcn.004076d0(param_2 + 7);\n    return param_1;\n}\n",
        "token_count": 143
    },
    "0040b650": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040b650(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46f9fe;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 5;\n    fcn.00403d10(uVar1);\n    uStack4._0_1_ = 4;\n    fcn.00403d10();\n    uStack4._0_1_ = 3;\n    fcn.00403d10();\n    uStack4._0_1_ = 2;\n    fcn.00403d10();\n    uStack4._0_1_ = 1;\n    fcn.00403d10();\n    uStack4 = uStack4._1_3_ << 8;\n    fcn.00421634();\n    uStack4 = 0xffffffff;\n    fcn.0042182d();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 279
    },
    "0040b870": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040b870(int32_t *param_1, int32_t param_2, int32_t param_3, int32_t param_4, int32_t param_5)\n\n{\n    param_1[2] = param_4 + param_2;\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    param_1[3] = param_5 + param_3;\n    return;\n}\n",
        "token_count": 107
    },
    "0040ba40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ba40(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uStack20;\n    \n    if (*(param_1 + 0x18) != 0) {\n        uStack20 = 0x5a0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(param_1 + 0x18), *(*(param_1 + 0x24) + 0xac4));\n        *(param_1 + 0x30) = iVar1;\n        *(param_1 + 0x28) = iVar1;\n        iVar1 = (*(*(param_1 + 0x24) + 0x5c) - *(*(param_1 + 0x24) + 0xacc)) + iVar1;\n        fcn.00417262(&uStack20, iVar1, *(param_1 + 0x2c));\n        fcn.00416e3c(iVar1, *(param_1 + 0x34));\n    }\n    return;\n}\n",
        "token_count": 234
    },
    "0040bf80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.0040bf80(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    \n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    fcn.004177d8();\n    pcVar2 = _sym.imp.USER32.dll_GetSysColor;\n    uVar3 = (*_sym.imp.USER32.dll_GetSysColor)(8);\n    pcVar1 = _sym.imp.GDI32.dll_CreatePen;\n    uVar3 = (*_sym.imp.GDI32.dll_CreatePen)(2, 1, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(0x14);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(0x10);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(6);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(0x12);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(0xf);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(8);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(5);\n    uVar3 = (*pcVar1)(0, 0, uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(5);\n    pcVar1 = _sym.imp.GDI32.dll_CreateSolidBrush;\n    uVar3 = (*_sym.imp.GDI32.dll_CreateSolidBrush)(uVar3);\n    fcn.00417780(uVar3);\n    uVar3 = (*pcVar2)(0xf);\n    uVar3 = (*pcVar1)(uVar3);\n    fcn.00417780(uVar3);\n    return;\n}\n",
        "token_count": 610
    },
    "0040c220": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040c220(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    \n    (**(*(param_1 + 0xcc) + 8))(*(param_2 + 0x14) + *(param_2 + 0xc));\n    (**(*(param_1 + 0x15c) + 8))(*(param_2 + 0xc));\n    (**(*(param_1 + 0x1a0) + 8))(((*(param_1 + 0xaa8) - *(param_1 + 0xab8)) - *(param_1 + 0xab0)) - *(param_2 + 0x10));\n    iVar1 = 0;\n    if (0 < *(param_2 + 0x1a)) {\n        puVar3 = param_2 + 0x1c;\n        piVar2 = param_1 + 0x228;\n        do {\n            (**(*piVar2 + 8))(*puVar3);\n            puVar3 = puVar3 + 1;\n            iVar1 = iVar1 + 1;\n            piVar2 = piVar2 + 0x11;\n        } while (iVar1 < *(param_2 + 0x1a));\n        if (0x1f < iVar1) {\n            return;\n        }\n    }\n    piVar2 = param_1 + 0x228 + iVar1 * 0x44;\n    iVar1 = 0x20 - iVar1;\n    do {\n        (**(*piVar2 + 8))(0);\n        piVar2 = piVar2 + 0x11;\n        iVar1 = iVar1 + -1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 405
    },
    "0040c2f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c2f0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iStack8;\n    int32_t iStack4;\n    \n    iStack8 = 1;\n    piVar2 = param_1 + 0x240;\n    iStack4 = 0x1f;\n    do {\n        if (iStack8 < 0x20) {\n            piVar4 = piVar2 + 0xb;\n            iVar3 = 0x20 - iStack8;\n            do {\n                iVar1 = piVar4[6];\n                if (iVar1 < *piVar2) {\n                    (**(*piVar4 + 8))(*piVar2);\n                    (**(piVar2[-6] + 8))(iVar1);\n                }\n                piVar4 = piVar4 + 0x11;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n        iStack8 = iStack8 + 1;\n        piVar2 = piVar2 + 0x11;\n        iStack4 = iStack4 + -1;\n    } while (iStack4 != 0);\n    return;\n}\n",
        "token_count": 292
    },
    "0040c850": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040c850(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t unaff_retaddr;\n    int32_t arg_8h;\n    int32_t iStack32;\n    uchar auStack28 [24];\n    uint32_t uStack4;\n    \n    uStack4 = *0x4987a4 ^ &stack0xffffffd8;\n    iVar1 = (*(param_1 + 0xaa8) - *(param_1 + 0xab0)) - *(param_1 + 0xab8);\n    iVar4 = *(param_1 + 0xab8) + iVar1;\n    iVar5 = param_3;\n    arg_8h = iVar4;\n    iStack32 = param_1;\n    if (param_3 < iVar4) {\n        do {\n            if (iVar5 != iVar1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar5, *(param_1 + 0xac4), 0x5a0);\n                fcn.00458b9a(auStack28, 10, 0x4771fc, iVar5 / unaff_retaddr);\n                uVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(auStack28);\n                (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)(param_2[2], &iStack32, uVar3, &stack0xffffffd8);\n                iVar4 = arg_8h;\n                (**(*param_2 + 0x60))(iVar2 - unaff_EDI / 2, 8 - unaff_ESI / 2, 0, 0, &stack0xffffffd0, uVar3, 0);\n                param_1 = iStack32;\n                arg_8h = iVar4;\n            }\n            iVar5 = iVar5 + param_3;\n        } while (iVar5 < iVar4);\n    }\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 504
    },
    "0040c960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall\nfcn.0040c960(int32_t param_1, uint param_2, int32_t param_3, int32_t param_4, uint param_5, uint param_6, \n            int32_t param_7, uint param_8, uint param_9, int32_t param_10)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_ch;\n    int32_t arg_10h;\n    int32_t iVar3;\n    \n    iVar2 = *(param_1 + 0xab8);\n    arg_10h = (*(param_1 + 0xaa8) - *(param_1 + 0xab0)) - iVar2;\n    iVar1 = iVar2 + arg_10h;\n    iVar3 = param_3;\n    if (param_3 < iVar1) {\n        do {\n            if ((iVar3 != arg_10h) && (iVar2 = iVar3 / param_4,  iVar3 % param_4 != 0)) {\n                arg_ch = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar3, *(param_1 + 0xac4), 0x5a0);\n                iVar2 = param_10 / 2;\n                arg_10h = -iVar2 + 8;\n                fcn.00417262(&param_4, arg_ch, arg_10h);\n                iVar2 = fcn.00416e3c(arg_ch, -iVar2 + 8 + param_7);\n            }\n            iVar3 = iVar3 + param_3;\n        } while (iVar3 < iVar1);\n    }\n    return iVar2;\n}\n",
        "token_count": 364
    },
    "0040ca10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ca10(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    (**(*(param_1 + 0xcc) + 0x1c))(0, *(param_1 + 0x1b8));\n    (**(*(param_1 + 0x15c) + 0x1c))(0, *(param_1 + 0x1b8));\n    iVar1 = *(param_1 + 0x174);\n    if (*(param_1 + 0x174) < *(param_1 + 0xe4)) {\n        iVar1 = *(param_1 + 0xe4);\n    }\n    iVar3 = *(param_1 + 0xaa8) - *(param_1 + 0xab0);\n    (**(*(param_1 + 0x1a0) + 0x1c))(iVar1, iVar3);\n    piVar2 = param_1 + 0x228;\n    iVar1 = 0x20;\n    do {\n        (**(*piVar2 + 0x1c))(0, iVar3);\n        piVar2 = piVar2 + 0x11;\n        iVar1 = iVar1 + -1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 297
    },
    "0040cad0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040cad0(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    iVar2 = 0;\n    puVar3 = param_1 + 0x228;\n    do {\n        iVar1 = (***puVar3)(param_2, param_3);\n        if (iVar1 != 0) {\n            return param_1 + 0x228 + iVar2 * 0x44;\n        }\n        iVar2 = iVar2 + 1;\n        puVar3 = puVar3 + 0x11;\n    } while (iVar2 < 0x20);\n    return 0;\n}\n",
        "token_count": 169
    },
    "0040cb20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040cb20(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack12;\n    \n    fcn.0041ae6e();\n    iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    if (iVar2 == *(param_1 + 0x20)) {\n        uStack36 = *(param_1 + 0xac4);\n        iStack40 = *(param_1 + 0xaa8) - *(param_1 + 0xab0);\n        uStack32 = 0x5a0;\n        (*_sym.imp.KERNEL32.dll_MulDiv)();\n        iVar2 = 0;\n        (*_sym.imp.USER32.dll_OffsetRect)(&stack0xffffffe4, *(param_1 + 0x5c) - *(param_1 + 0xacc), *(param_1 + 100));\n        uVar3 = (*_sym.imp.USER32.dll_PtInRect)(&iStack40, 0x11, uStack12);\n        iStack40 = (*pcVar1)((*(param_1 + 0xacc) - *(param_1 + 0x5c)) + iVar2, 0x5a0, *(param_1 + 0xac4));\n        iStack40 = iStack40 + *(param_1 + 0xb0) / 2;\n        iStack40 = iStack40 - iStack40 % *(param_1 + 0xb0);\n        (**(**(param_1 + 0xc0) + 0xc))(iStack40, uVar3);\n        (*_sym.imp.USER32.dll_UpdateWindow)(*(param_1 + 0x20));\n    }\n    return;\n}\n",
        "token_count": 427
    },
    "0040cd90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0040cd90(code **param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uint32_t uStack36;\n    \n    *param_1 = vtable.CRulerItem.0;\n    param_1[7] = 0x6;\n    param_1[0xe] = NULL;\n    param_1[8] = NULL;\n    param_1[1] = NULL;\n    param_1[2] = NULL;\n    if (param_2 != 0) {\n        uStack36 = 0x40cdbf;\n        iVar2 = fcn.0042052a();\n        pcVar1 = *(iVar2 + 0xc);\n        uStack36 = param_2 + 1 & 0xffff;\n        pcVar3 = (*_sym.imp.USER32.dll_LoadBitmapA)();\n        param_1[2] = pcVar3;\n        fcn.0040b9c0();\n        (*_sym.imp.GDI32.dll_GetObjectA)(param_1[1], 0x18, &stack0xffffffdc);\n        param_1[3] = param_2 & 0xffff;\n        param_1[4] = pcVar1;\n    }\n    return param_1;\n}\n",
        "token_count": 295
    },
    "0040ce10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ce10(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iStack16;\n    int32_t iStack12;\n    int32_t iStack8;\n    \n    fcn.0040bbb0(&iStack16);\n    iVar1 = *(param_1 + 0x24);\n    iStack16 = iStack16 + *(iVar1 + 100);\n    iStack8 = iStack8 + *(iVar1 + 100);\n    iStack12 = iStack12 + (*(iVar1 + 0x5c) - *(iVar1 + 0xacc));\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(iVar1 + 0x20), &stack0xffffffec, 1);\n    return;\n}\n",
        "token_count": 173
    },
    "0040cff0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040cff0(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    \n    *(param_2 + 4) = 0x17;\n    iVar5 = *(param_1 + 0x174);\n    *(param_2 + 0xc) = iVar5;\n    *(param_2 + 0x14) = *(param_1 + 0xe4) - iVar5;\n    iVar5 = *(param_1 + 0xaa8);\n    iVar3 = *(param_1 + 0xab8);\n    iVar1 = *(param_1 + 0xab0);\n    iVar2 = *(param_1 + 0x1b8);\n    *(param_2 + 0x1a) = 0;\n    *(param_2 + 0x10) = ((iVar5 - iVar3) - iVar1) - iVar2;\n    fcn.0040c2f0();\n    iVar3 = 0;\n    piVar4 = param_1 + 0x284;\n    iVar5 = 8;\n    do {\n        iVar1 = piVar4[-0x11];\n        if (iVar3 != iVar1) {\n            *(param_2 + 0x1c + *(param_2 + 0x1a) * 4) = iVar1;\n            *(param_2 + 0x1a) = *(param_2 + 0x1a) + 1;\n            iVar3 = iVar1;\n        }\n        iVar1 = *piVar4;\n        if (iVar3 != iVar1) {\n            *(param_2 + 0x1c + *(param_2 + 0x1a) * 4) = iVar1;\n            *(param_2 + 0x1a) = *(param_2 + 0x1a) + 1;\n            iVar3 = iVar1;\n        }\n        iVar1 = piVar4[0x11];\n        if (iVar3 != iVar1) {\n            *(param_2 + 0x1c + *(param_2 + 0x1a) * 4) = iVar1;\n            *(param_2 + 0x1a) = *(param_2 + 0x1a) + 1;\n            iVar3 = iVar1;\n        }\n        iVar1 = piVar4[0x22];\n        if (iVar3 != iVar1) {\n            *(param_2 + 0x1c + *(param_2 + 0x1a) * 4) = iVar1;\n            *(param_2 + 0x1a) = *(param_2 + 0x1a) + 1;\n            iVar3 = iVar1;\n        }\n        piVar4 = piVar4 + 0x44;\n        iVar5 = iVar5 + -1;\n    } while (iVar5 != 0);\n    return;\n}\n",
        "token_count": 672
    },
    "0040d8d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040d8d0(code **param_1)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    code **ppcVar3;\n    int32_t **ppiVar4;\n    int32_t iVar5;\n    uint32_t **in_FS_OFFSET;\n    uint32_t *puStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46fcd2;\n    puStack12 = *in_FS_OFFSET;\n    puVar2 = *0x4987a4 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &puStack12;\n    *param_1 = vtable.CRulerBar.0;\n    uStack4 = 0x10;\n    ppcVar3 = param_1 + 0x8c;\n    iVar5 = 0x20;\n    do {\n        ppcVar3[-1] = NULL;\n        *ppcVar3 = NULL;\n        ppcVar3 = ppcVar3 + 0x11;\n        iVar5 = iVar5 + -1;\n    } while (iVar5 != 0);\n    param_1[0x2c6] = vtable.CBrush.0;\n    fcn.00402550();\n    uStack4._0_1_ = 0xf;\n    param_1[0x2c4] = vtable.CBrush.0;\n    fcn.00402550();\n    uStack4._0_1_ = 0xe;\n    param_1[0x2c2] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 0xd;\n    param_1[0x2c0] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 0xc;\n    param_1[0x2be] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 0xb;\n    param_1[700] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 10;\n    param_1[0x2ba] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 9;\n    param_1[0x2b8] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 8;\n    param_1[0x2b6] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4._0_1_ = 7;\n    param_1[0x2b4] = vtable.CPen.0;\n    fcn.00402550();\n    uStack4 = CONCAT31(uStack4._1_3_, 6);\n    fcn.004584a9(param_1 + 0x8a, 0x44, 0x20, 0x40bf70);\n    fcn.0040b980();\n    fcn.0040b980();\n    fcn.0040b980();\n    fcn.0040b980();\n    fcn.0040b980();\n    param_1[0x31] = vtable.CFont.0;\n    fcn.00402550();\n    ppiVar4 = param_1[0x2f] + -0x10;\n    piVar1 = param_1[0x2f] + -4;\n    LOCK();\n    iVar5 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar5 == 1 || iVar5 + -1 < 0) {\n        (**(**ppiVar4 + 4))(ppiVar4);\n    }\n    fcn.0042e5ae();\n    *in_FS_OFFSET = puVar2;\n    return;\n}\n",
        "token_count": 898
    },
    "0040db60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040db60(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uStack36;\n    uint uStack32;\n    \n    uStack32 = 0x40db6b;\n    iVar1 = fcn.0042052a();\n    uStack36 = *(iVar1 + 0xc);\n    uStack32 = 0xa2;\n    iVar1 = (*_sym.imp.USER32.dll_LoadBitmapA)();\n    fcn.00417780(iVar1);\n    (*_sym.imp.GDI32.dll_GetObjectA)(*(param_1 + 0x58), 0x18);\n    *(param_1 + 0x60) = iVar1;\n    *(param_1 + 0x5c) = &stack0xffffffdc;\n    fcn.0041822e(0, 0, 0, &stack0xffffffe4, iVar1 + 8, 0x16);\n    return;\n}\n",
        "token_count": 214
    },
    "0040e3a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040e3a0(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46fd98;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    fcn.0043421c(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.0043421c();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 157
    },
    "0040ef90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040ef90(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    bool bVar3;\n    uint uVar4;\n    uint uVar5;\n    \n    if (param_2 == 0) {\n        *param_1 = 0;\n        return;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_2);\n    iVar1 = iVar1 + 1;\n    fcn.0040ea60(param_1, iVar1 * 4, param_1 + 1, 0x80);\n    uVar5 = 0;\n    iVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(param_2, 0, param_2, iVar1, *param_1, iVar1 * 4, 0, 0);\n    bVar3 = iVar2 == 0;\n    if (bVar3) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar2 == 0x7a) {\n            uVar4 = 0;\n            uVar5 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(uVar5, 0, param_2, iVar1, 0, 0, 0, 0);\n            fcn.0040ea60(param_1, uVar5, param_1 + 1, 0x80);\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(uVar4, 0, param_2, iVar1, *param_1, uVar5, 0, 0);\n            bVar3 = iVar1 == 0;\n        }\n        if (bVar3) {\n            fcn.00401020();\n        }\n    }\n    return;\n}\n",
        "token_count": 416
    },
    "0040f340": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040f340(int32_t param_1)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint16_t *puVar6;\n    \n    iVar2 = *(*(param_1 + 0xc4) + -0xc);\n    uVar5 = 0;\n    if (((iVar2 != 0) && (iVar3 = *(*(param_1 + 0xc0) + -0xc),  iVar3 != 0)) &&\n       (iVar4 = *(*(param_1 + 200) + -0xc),  iVar4 != 0)) {\n        iVar2 = iVar4 + iVar3 + 0xb + iVar2;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, iVar2);\n        puVar6 = (*_sym.imp.KERNEL32.dll_GlobalLock)(uVar5);\n        *puVar6 = 8;\n        fcn.00459195(puVar6 + 4, iVar2 + -8, *(param_1 + 0xc4));\n        uVar1 = *puVar6;\n        puVar6[1] = *(*(param_1 + 0xc4) + -0xc) + uVar1 + 1;\n        fcn.00459195(uVar1 + puVar6, iVar2 - uVar1, *(param_1 + 0xc0));\n        puVar6[2] = *(*(param_1 + 0xc0) + -0xc) + puVar6[1] + 1;\n        fcn.00459195(*puVar6 + puVar6, iVar2 - *puVar6, *(param_1 + 200));\n        puVar6[3] = 0;\n    }\n    return uVar5;\n}\n",
        "token_count": 418
    },
    "0040f470": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040f470(int32_t param_1, uint *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    \n    uVar1 = param_2;\n    if (*(param_1 + 0x14) < param_2) {\n        fcn.0046e6c9();\n    }\n    uVar2 = *(param_1 + 0x14) - param_2;\n    if (uVar2 < param_3) {\n        param_3 = uVar2;\n    }\n    if (param_3 != 0) {\n        puVar5 = param_1 + 4;\n        puVar4 = puVar5;\n        param_2 = puVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar4 = *puVar5;\n            param_2 = *puVar5;\n        }\n        fcn.00458589(puVar4 + uVar1, *(param_1 + 0x18) - uVar1, param_2 + param_3 + uVar1, uVar2 - param_3);\n        iVar3 = *(param_1 + 0x14) - param_3;\n        *(param_1 + 0x14) = iVar3;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar5 = *puVar5;\n        }\n        *(iVar3 + puVar5) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 372
    },
    "0040f710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f710(int32_t param_1)\n\n{\n    if (0xf < *(param_1 + 0x18)) {\n        fcn.00414b30(*(param_1 + 4));\n    }\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 4) = 0;\n    return;\n}\n",
        "token_count": 102
    },
    "0040f880": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040f880(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    int32_t *arg_8h;\n    int32_t *piVar1;\n    uint32_t arg_14h;\n    \n    if (*(param_2 + 0x14) < param_3) {\n        fcn.0046e6c9();\n    }\n    arg_14h = *(param_2 + 0x14) - param_3;\n    if (param_4 < arg_14h) {\n        arg_14h = param_4;\n    }\n    if (param_1 != param_2) {\n        if (arg_14h == 0xffffffff) {\n            fcn.0046e691();\n        }\n        if (*(param_1 + 0x18) < arg_14h) {\n            fcn.0040f500(arg_14h, *(param_1 + 0x14));\n        }\n        else if (arg_14h == 0) {\n            *(param_1 + 0x14) = 0;\n            if (*(param_1 + 0x18) < 0x10) {\n                *(param_1 + 4) = 0;\n                return param_1;\n            }\n            **(param_1 + 4) = 0;\n            return param_1;\n        }\n        if (arg_14h != 0) {\n            if (*(param_2 + 0x18) < 0x10) {\n                param_2 = param_2 + 4;\n            }\n            else {\n                param_2 = *(param_2 + 4);\n            }\n            piVar1 = param_1 + 4;\n            arg_8h = piVar1;\n            if (0xf < *(param_1 + 0x18)) {\n                arg_8h = *piVar1;\n            }\n            fcn.0045850c(arg_8h, *(param_1 + 0x18), param_2 + param_3, arg_14h);\n            *(param_1 + 0x14) = arg_14h;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar1 = *piVar1;\n            }\n            *(piVar1 + arg_14h) = 0;\n        }\n        return param_1;\n    }\n    fcn.0040f470(arg_14h + param_3, 0xffffffff);\n    fcn.0040f470(0, param_3);\n    return param_1;\n}\n",
        "token_count": 584
    },
    "0040f960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040f960(int32_t param_1, uint *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *arg_8h;\n    uint *puVar4;\n    int32_t *piVar5;\n    \n    if (param_2 != NULL) {\n        uVar1 = *(param_1 + 0x18);\n        puVar2 = param_1 + 4;\n        puVar4 = puVar2;\n        if (0xf < uVar1) {\n            puVar4 = *puVar2;\n        }\n        if (puVar4 <= param_2) {\n            puVar4 = puVar2;\n            if (0xf < uVar1) {\n                puVar4 = *puVar2;\n            }\n            if (param_2 < *(param_1 + 0x14) + puVar4) {\n                if (0xf < uVar1) {\n                    puVar2 = *puVar2;\n                }\n                iVar3 = fcn.0040f880(param_1, param_2 - puVar2, param_3);\n                return iVar3;\n            }\n        }\n    }\n    if (param_3 == 0xffffffff) {\n        fcn.0046e691();\n    }\n    if (*(param_1 + 0x18) < param_3) {\n        fcn.0040f500(param_3, *(param_1 + 0x14));\n    }\n    else if (param_3 == 0) {\n        *(param_1 + 0x14) = 0;\n        if (*(param_1 + 0x18) < 0x10) {\n            *(param_1 + 4) = 0;\n            return param_1;\n        }\n        **(param_1 + 4) = 0;\n        return param_1;\n    }\n    if (param_3 != 0) {\n        piVar5 = param_1 + 4;\n        arg_8h = piVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            arg_8h = *piVar5;\n        }\n        fcn.0045850c(arg_8h, *(param_1 + 0x18), param_2, param_3);\n        *(param_1 + 0x14) = param_3;\n        if (0xf < *(param_1 + 0x18)) {\n            piVar5 = *piVar5;\n        }\n        *(piVar5 + param_3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 597
    },
    "0040fa40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid fcn.0040fa40(void)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t *in_FS_OFFSET;\n    int32_t in_stack_00001608;\n    int32_t in_stack_00001618;\n    uint32_t in_stack_0000161c;\n    uint8_t *in_stack_00001620;\n    int32_t in_stack_00001624;\n    int32_t arg_8h;\n    uint8_t *puStack8;\n    \n    arg_8h = *in_FS_OFFSET;\n    fcn.0045a520();\n    *in_FS_OFFSET = &stack0x00001608;\n    uVar3 = 0;\n    if (in_stack_00001624 != 0) {\n        do {\n            (&stack0x00000000)[uVar3] = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x1604);\n        uVar7 = 0;\n        uVar3 = 0;\n        do {\n            uVar1 = (&stack0x00000000)[uVar3];\n            uVar6 = uVar3 + 1;\n            uVar7 = (uVar1 + *(uVar3 % in_stack_0000161c + in_stack_00001618) + uVar7) % 0x1604;\n            (&stack0x00000000)[uVar3] = (&stack0x00000000)[uVar7];\n            (&stack0x00000000)[uVar7] = uVar1;\n            uVar3 = uVar6;\n        } while (uVar6 < 0x1604);\n        uVar7 = 0;\n        uVar3 = 0;\n        puStack8 = in_stack_00001620;\n        do {\n            uVar3 = (uVar3 + 1) % 0x1604;\n            in_stack_00001624 = in_stack_00001624 + -1;\n            uVar1 = (&stack0x00000000)[uVar3];\n            uVar7 = (uVar1 + uVar7) % 0x1604;\n            (&stack0x00000000)[uVar3] = (&stack0x00000000)[uVar7];\n            (&stack0x00000000)[uVar7] = uVar1;\n            iVar4 = (*_sym.imp.USER32.dll_GetSystemMenu)();\n            if (iVar4 != 0) {\n                piVar5 = fcn.0041f6b5();\n                if (piVar5 == NULL) {\ncode_r0x0040fd73:\n                    fcn.00401000();\n                    pcVar2 = swi(3);\n                    (*pcVar2)();\n                    return;\n                }\n                (**(*piVar5 + 0xc))();\n                iVar4 = fcn.0041f625();\n                if (iVar4 != 0) {\n                    fcn.004022e0();\n                }\n                piVar5 = arg_8h + -4;\n                LOCK();\n                iVar4 = *piVar5;\n                *piVar5 = *piVar5 + -1;\n                if (iVar4 == 1 || iVar4 + -1 < 0) {\n                    (**(**(arg_8h + -0x10) + 4))();\n                }\n                piVar5 = fcn.0041f6b5();\n                if (piVar5 == NULL) goto code_r0x0040fd73;\n                (**(*piVar5 + 0xc))();\n                iVar4 = fcn.0041f625();\n                if (iVar4 != 0) {\n                    fcn.004022e0();\n                }\n                piVar5 = arg_8h + -4;\n                LOCK();\n                iVar4 = *piVar5;\n                *piVar5 = *piVar5 + -1;\n                if (iVar4 == 1 || iVar4 + -1 < 0) {\n                    (**(**(arg_8h + -0x10) + 4))();\n                }\n                piVar5 = fcn.0041f6b5();\n                if (piVar5 == NULL) goto code_r0x0040fd73;\n                (**(*piVar5 + 0xc))();\n                iVar4 = fcn.0041f625();\n                if (iVar4 != 0) {\n                    fcn.004022e0();\n                }\n                piVar5 = arg_8h + -4;\n                LOCK();\n                iVar4 = *piVar5;\n                *piVar5 = *piVar5 + -1;\n                if (iVar4 == 1 || iVar4 + -1 < 0) {\n                    (**(**(arg_8h + -0x10) + 4))();\n                }\n                piVar5 = fcn.0041f6b5();\n                if (piVar5 == NULL) goto code_r0x0040fd73;\n                (**(*piVar5 + 0xc))();\n                iVar4 = fcn.0041f625();\n                if (iVar4 != 0) {\n                    fcn.004022e0();\n                }\n                piVar5 = arg_8h + -4;\n                LOCK();\n                iVar4 = *piVar5;\n                *piVar5 = *piVar5 + -1;\n                if (iVar4 == 1 || iVar4 + -1 < 0) {\n                    (**(**(arg_8h + -0x10) + 4))();\n                }\n            }\n            *puStack8 = *puStack8 ^ (&stack0x00000000)[((&stack0x00000000)[uVar3] + uVar1) % 0x1604];\n            puStack8 = puStack8 + 1;\n        } while (in_stack_00001624 != 0);\n    }\n    *in_FS_OFFSET = in_stack_00001608;\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 1352
    },
    "0040fd80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040fd80(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x46ffa8;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    *(param_1 + 0x54) = vtable.CBitmap.0;\n    fcn.00402550(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.0041e24f();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 181
    },
    "0040fe00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040fe00(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = 0x499c54;\n    do {\n        uVar1 = *(iVar3 + -8);\n        iVar2 = fcn.0041f625(uVar1);\n        if (iVar2 != 0) {\n            fcn.004022e0(iVar2, uVar1);\n        }\n        iVar3 = iVar3 + 0x20;\n    } while (iVar3 < 0x499d34);\n    return;\n}\n",
        "token_count": 132
    },
    "00410350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00410350(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x470098;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    fcn.0041ec03(uVar1);\n    uStack4 = 0;\n    *param_1 = vtable.CSplashWnd.0;\n    fcn.0041997f();\n    param_1[0x1d] = vtable.CBigIcon.0;\n    param_1[0x33] = NULL;\n    param_1[0x32] = vtable.CBitmap.0;\n    *in_FS_OFFSET = piStack12;\n    return param_1;\n}\n",
        "token_count": 226
    },
    "004103c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004103c0(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x4700c8;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 0;\n    fcn.0040fd80(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.0041ec27();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 156
    },
    "00410530": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00410530(code **param_1, code *param_2, char *param_3)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t *unaff_ESI;\n    int32_t **in_FS_OFFSET;\n    code *unaff_retaddr;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x47012b;\n    piStack12 = *in_FS_OFFSET;\n    uVar2 = *0x4987a4 ^ &stack0xffffffe4;\n    *in_FS_OFFSET = &piStack12;\n    fcn.004163d9(uVar2);\n    *param_1 = vtable.CFileException.0;\n    piVar3 = fcn.0041f6b5();\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    param_1[4] = iVar4 + 0x10;\n    param_1[3] = param_2;\n    uStack8 = 0;\n    param_1[2] = unaff_retaddr;\n    if (param_3 == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        pcVar5 = param_3;\n        do {\n            cVar1 = *pcVar5;\n            pcVar5 = pcVar5 + 1;\n        } while (cVar1 != '\\0');\n        iVar4 = pcVar5 - (param_3 + 1);\n    }\n    fcn.004023a0(param_3, iVar4);\n    *in_FS_OFFSET = unaff_ESI;\n    return param_1;\n}\n",
        "token_count": 432
    },
    "00411240": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00411240(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    int32_t *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uchar *arg_8h;\n    uint uVar4;\n    int32_t in_stack_ffffffb4;\n    uint uVar5;\n    uint32_t uStack60;\n    uchar auStack48 [4];\n    int32_t iStack44;\n    uint uStack36;\n    uint uStack32;\n    uchar uStack20;\n    uint32_t uStack16;\n    int32_t iStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x470288;\n    iStack12 = *in_FS_OFFSET;\n    uStack16 = *0x4987a4 ^ &stack0xffffffd0;\n    uStack60 = *0x4987a4 ^ &stack0xffffffc8;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    uStack32 = param_3;\n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00401000(0x80004005);\n    }\n    iVar2 = (**(*piVar1 + 0xc))();\n    iVar2 = iVar2 + 0x10;\n    uStack8 = 0;\n    uVar5 = 0x4112bc;\n    iStack44 = iVar2;\n    iVar3 = fcn.0041f625(param_1);\n    if (iVar3 != 0) {\n        iVar2 = unaff_EBP;\n        fcn.004022e0(iVar3, unaff_retaddr);\n        in_stack_ffffffb4 = iVar3;\n        uVar5 = unaff_retaddr;\n    }\n    piVar1 = fcn.0041f6b5();\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar1 + 0xc))();\n    uStack60 = iVar3 + 0x10;\n    uVar4 = 3;\n    arg_8h = &stack0xffffffc4;\n    uStack20 = 1;\n    fcn.0041f630(arg_8h, iVar2, 3, 10);\n    *(unaff_ESI + 4) = param_1;\n    *(unaff_ESI + 0x10) = in_stack_ffffffb4;\n    *(unaff_ESI + 0x18) = unaff_EDI;\n    fcn.00458b9a(&stack0xffffffc4, 10, 0x4771fc, uStack16);\n    *(unaff_ESI + 0x1c) = &stack0xffffffc4;\n    uStack36 = CONCAT31(uStack36._1_3_, 2);\n    iVar3 = fcn.00409020(0x80000000);\n    if (iVar3 == 0) {\n        fcn.00410e70(uVar5);\n    }\n    fcn.00408fe0();\n    iVar3 = fcn.00409020(0x80000000, param_1);\n    if (iVar3 == 0) {\n        fcn.00410e70(uVar4);\n    }\n    fcn.00408fe0();\n    piVar1 = arg_8h + -4;\n    LOCK();\n    iVar3 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**(arg_8h + -0x10) + 4))(arg_8h + -0x10);\n    }\n    piVar1 = iVar2 + -4;\n    LOCK();\n    iVar3 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**(iVar2 + -0x10) + 4))(iVar2 + -0x10);\n    }\n    *in_FS_OFFSET = uStack60;\n    fcn.0045843c(unaff_EDI);\n    return;\n}\n",
        "token_count": 1013
    },
    "00411a80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.00411a80(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *extraout_ECX;\n    \n    piVar1 = *param_1;\n    if (piVar1 == NULL) {\n        piVar1 = fcn.0041638e();\n        param_1 = extraout_ECX;\n    }\n    *param_1 = *piVar1;\n    return piVar1 + 2;\n}\n",
        "token_count": 107
    },
    "00412130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00412130(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0045ab93(*param_1, param_2);\n    if (iVar1 == 0) {\n        return -1;\n    }\n    return iVar1 - *param_1;\n}\n",
        "token_count": 83
    },
    "00412210": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00412210(int32_t *param_1, uint8_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((-1 < param_3) && (param_3 < *(*param_1 + -0xc))) {\n        iVar1 = fcn.0045aaaf(*param_1 + param_3, param_2);\n        if (iVar1 != 0) {\n            return iVar1 - *param_1;\n        }\n    }\n    return -1;\n}\n",
        "token_count": 124
    },
    "00412eb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00412eb0(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((((*(param_1 + 4) == *(param_2 + 4)) && (*(param_1 + 8) == *(param_2 + 8))) &&\n        (*(param_1 + 0xc) == *(param_2 + 0xc))) &&\n       (((*(param_1 + 0x10) == *(param_2 + 0x10) && (*(param_1 + 0x14) == *(param_2 + 0x14))) &&\n        (*(param_1 + 0x19) == *(param_2 + 0x19))))) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(param_1 + 0x1a, param_2 + 0x1a);\n        if (iVar1 == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 226
    },
    "00412f10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00412f10(int32_t param_1, int32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (((((((*(param_1 + 4) == *(param_2 + 4)) && (*(param_1 + 8) == *(param_2 + 8))) &&\n           (*(param_1 + 10) == *(param_2 + 10))) &&\n          (((*(param_1 + 0xc) == *(param_2 + 0xc) && (*(param_1 + 0x10) == *(param_2 + 0x10))) &&\n           ((*(param_1 + 0x14) == *(param_2 + 0x14) &&\n            ((iVar1 = *(param_2 + 0x1a),  *(param_1 + 0x1a) == iVar1 && (*(param_1 + 0x9c) == *(param_2 + 0x9c)))))))))\n         && ((*(param_1 + 0xa0) == *(param_2 + 0xa0) &&\n             (((*(param_1 + 0xa4) == *(param_2 + 0xa4) && (*(param_1 + 0xa8) == *(param_2 + 0xa8))) &&\n              (*(param_1 + 0xaa) == *(param_2 + 0xaa))))))) &&\n        (((*(param_1 + 0xab) == *(param_2 + 0xab) && (*(param_1 + 0xac) == *(param_2 + 0xac))) &&\n         (((*(param_1 + 0xae) == *(param_2 + 0xae) &&\n           ((*(param_1 + 0xb0) == *(param_2 + 0xb0) && (*(param_1 + 0xb2) == *(param_2 + 0xb2))))) &&\n          (*(param_1 + 0xb4) == *(param_2 + 0xb4))))))) &&\n       (((*(param_1 + 0xb6) == *(param_2 + 0xb6) && (*(param_1 + 0xb8) == *(param_2 + 0xb8))) &&\n        (*(param_1 + 0xba) == *(param_2 + 0xba))))) {\n        iVar3 = 0;\n        if (0 < iVar1) {\n            piVar2 = param_1 + 0x1c;\n            do {\n                if (*piVar2 != *((param_2 - param_1) + piVar2)) {\n                    return 0;\n                }\n                iVar3 = iVar3 + 1;\n                piVar2 = piVar2 + 1;\n            } while (iVar3 < iVar1);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 640
    },
    "004130b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004130b0(void)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint32_t uStack4;\n    \n    uStack8 = 0x470503;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    uStack4 = 1;\n    fcn.00445b23(uVar1);\n    uStack4 = uStack4 & 0xffffff00;\n    fcn.0041752d();\n    uStack4 = 0xffffffff;\n    fcn.00445aac();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 178
    },
    "00413140": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00413140(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint arg_8h;\n    uint uStack340;\n    uchar auStack284 [8];\n    uint uStack276;\n    uchar auStack144 [56];\n    uint uStack88;\n    uint32_t uStack4;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    uStack4 = *0x4987a4 ^ &stack0xfffffee4;\n    uStack88 = 0x54;\n    uStack276 = 0x9c;\n    (*_sym.imp.USER32.dll_SendMessageA)();\n    (*pcVar1)();\n    uStack340 = 0x41319d;\n    fcn.0044236b(0, 0xffffffff);\n    uStack340 = 0;\n    uVar2 = (*pcVar1)(*(param_1 + 0x20), 0x442, 0);\n    if ((uVar2 & 10) == 0) {\n        fcn.004424b0(&stack0xffffff70);\n        iVar3 = fcn.00412eb0(param_1 + 0x2ec);\n        if (iVar3 != 0) {\n            fcn.004424d3(&stack0xfffffeac);\n            fcn.00412f10(param_1 + 0x1dc);\n        }\n    }\n    (*pcVar1)(*(param_1 + 0x20), 0x437, 0, &stack0xfffffeac);\n    arg_8h = 0;\n    (*pcVar1)(*(param_1 + 0x20), 0x43f, 0);\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 406
    },
    "00413910": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00413910(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    iVar3 = (*_sym.imp.USER32.dll_GetWindow)(param_1, 5);\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    for (; iVar3 != 0; iVar3 = (*pcVar1)(iVar3, 2)) {\n        if (iVar3 != unaff_retaddr) {\n            (*pcVar2)(iVar3, 0x311, unaff_retaddr, 0);\n            fcn.00413910(iVar3, unaff_retaddr);\n        }\n    }\n    return;\n}\n",
        "token_count": 177
    },
    "004139a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004139a0(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    iVar3 = (*_sym.imp.USER32.dll_GetWindow)(param_1, 5);\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    while( true ) {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar4 = (*pcVar2)(iVar3, 0x30f, 0, 0);\n        if ((iVar4 != 0) || (iVar4 = fcn.004139a0(iVar3),  iVar4 != 0)) break;\n        iVar3 = (*pcVar1)(iVar3, 2);\n    }\n    return 1;\n}\n",
        "token_count": 198
    },
    "00414280": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00414280(void)\n\n{\n    int32_t **in_FS_OFFSET;\n    uint in_stack_fffffde0;\n    int32_t *piStack532;\n    uint uStack528;\n    uint uStack524;\n    uchar auStack520 [512];\n    uint32_t uStack8;\n    \n    uStack528 = 0x4706c8;\n    piStack532 = *in_FS_OFFSET;\n    uStack8 = *0x4987a4 ^ auStack520;\n    *in_FS_OFFSET = &piStack532;\n    uStack524 = 0;\n    fcn.0042052a();\n    fcn.0041e8b5();\n    *in_FS_OFFSET = piStack532;\n    fcn.0045843c(in_stack_fffffde0);\n    return;\n}\n",
        "token_count": 177
    },
    "00414600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00414600(uint param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *unaff_EDI;\n    uint32_t arg_10h;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x46f168;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x4987a4 ^ &stack0xffffffe4;\n    *in_FS_OFFSET = &piStack12;\n    piVar2 = fcn.0041f6b5();\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    iVar3 = (**(*piVar2 + 0xc))();\n    uStack8 = 0;\n    iVar4 = fcn.0041f625(param_1);\n    arg_10h = iVar3 + 0x10;\n    if (iVar4 != 0) {\n        fcn.004022e0(iVar4, param_1);\n        arg_10h = uVar1;\n    }\n    piVar2 = piStack12;\n    piStack12[1] = -0x2fffffe1;\n    piStack12[2] = 0x40000000;\n    piStack12[3] = 200;\n    piStack12[4] = 0;\n    piStack12[5] = 0;\n    *(piStack12 + 6) = 0;\n    *(piStack12 + 0x19) = 0;\n    fcn.00458da4(piStack12 + 0x1a, 0x20, arg_10h, 0xffffffff);\n    piVar2[1] = piVar2[1] | 0x20000000;\n    piVar2 = arg_10h - 4;\n    LOCK();\n    iVar3 = *piVar2;\n    *piVar2 = *piVar2 + -1;\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(**(arg_10h - 0x10) + 4))(arg_10h - 0x10);\n    }\n    *in_FS_OFFSET = unaff_EDI;\n    return;\n}\n",
        "token_count": 550
    },
    "00414b3b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00414b3b(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00424c12(0x47a298);\n    if (iVar1 == 0) {\n        iVar1 = fcn.00424c12(0x47a38c);\n        if (iVar1 == 0) {\n            iVar1 = fcn.00424c12(0x47a3a8);\n            iVar1 = (-(iVar1 != 0) & 0xffff4002) + 0x8000ffff;\n        }\n        else {\n            iVar1 = -0x7ff8fff2;\n        }\n    }\n    else {\n        iVar1 = *(arg_8h + 8);\n    }\n    return iVar1;\n}\n",
        "token_count": 181
    },
    "00414f41": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414f41(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint cb;\n    \n    cb = 0;\n    iVar1 = fcn.00414f1d(&cb, arg_8h, arg_ch);\n    if (iVar1 < 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(cb);\n    return uVar2;\n}\n",
        "token_count": 114
    },
    "00414fcb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414fcb(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0045850c(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 87
    },
    "00414fec": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414fec(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00414faa(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 86
    },
    "0041500d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041500d(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00458a7f(arg_8h, arg_ch, arg_10h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 77
    },
    "0041502b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041502b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0045ae74(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 87
    },
    "004150fd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004150fd(int32_t *arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    if (-arg_ch - 1U < arg_10h) {\n        return 0x80070057;\n    }\n    *arg_8h = arg_ch + arg_10h;\n    return 0;\n}\n",
        "token_count": 82
    },
    "004151c2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004151c2(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint arg_14h;\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t arg_10h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalSize;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GlobalSize)(arg_ch);\n    if (arg_8h == 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, uVar3);\n        if (arg_8h != 0) {\ncode_r0x004151fd:\n            pcVar2 = _sym.imp.KERNEL32.dll_GlobalLock;\n            arg_14h = (*_sym.imp.KERNEL32.dll_GlobalLock)(arg_ch);\n            arg_8h_00 = (*pcVar2)(arg_8h);\n            arg_10h = arg_8h;\n            arg_ch_00 = (*pcVar1)(arg_8h, arg_14h, uVar3);\n            fcn.00414fcb(arg_8h_00, arg_ch_00, arg_10h, arg_14h);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(arg_8h);\n            (*pcVar1)(arg_ch);\n            return arg_8h;\n        }\n    }\n    else {\n        uVar4 = (*pcVar1)(arg_8h);\n        if (uVar3 <= uVar4) goto code_r0x004151fd;\n    }\n    return 0;\n}\n",
        "token_count": 405
    },
    "00415352": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00415352(uint *arg_8h)\n\n{\n    int32_t arg_8h_00;\n    \n    if (arg_8h == NULL) {\n        arg_8h_00 = 0;\n    }\n    else {\n        arg_8h_00 = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(*arg_8h);\n        if (arg_8h_00 != 0) {\n            fcn.00414fcb(arg_8h_00, *arg_8h, arg_8h, *arg_8h);\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 146
    },
    "004153f5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.004153f5(uint noname_0, uint noname_1, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    uint var_34h;\n    uint var_24h;\n    uint var_1dh;\n    uint var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x14;\n    var_4h_2 = 0x48c150;\n    fcn.0045b134();\n    *(unaff_EBP + -0x1d) = 1;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x24) = 0;\n    iVar1 = fcn.004150fd(unaff_EBP + -0x24, *(unaff_EBP + 8), 0x2000);\n    if (iVar1 < 0) {\n        *(unaff_EBP + -0x1d) = 0;\n    }\n    else {\n        fcn.0045b320();\n        *(unaff_EBP + -0x18) = &fcn.004153f5::var_4h_2;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    *(unaff_EBP + -0x38) = 0x415469;\n    fcn.0045b17c();\n    return;\n}\n",
        "token_count": 361
    },
    "00415582": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00415582(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.004150fd(&var_4h, arg_8h, arg_ch);\n    if (iVar1 < 0) {\n        fcn.00401000(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 91
    },
    "004155b6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004155b6(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint var_4h;\n    \n    var_4h = 0;\n    uVar1 = fcn.00414f1d(&var_4h, arg_8h, 2);\n    if (uVar1 < 0) {\n        uVar1 = uVar1 & 0xffffff00;\n    }\n    else {\n        uVar1 = fcn.004153d8(var_4h);\n    }\n    return uVar1;\n}\n",
        "token_count": 128
    },
    "0041563d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041563d(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *extraout_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.00401000(0x80004005);\n        arg_8h = extraout_ECX;\n    }\n    iVar1 = (**(*arg_8h + 0xc))();\n    *in_ECX = iVar1 + 0x10;\n    return;\n}\n",
        "token_count": 120
    },
    "0041569f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0041569f(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    uint *puVar1;\n    uint *in_ECX;\n    \n    arg_8h_00 = fcn.00415582(arg_8h, 8);\n    puVar1 = fcn.0045adaa(arg_8h_00);\n    if (puVar1 != NULL) {\n        *puVar1 = *in_ECX;\n        *in_ECX = puVar1;\n        puVar1 = puVar1 + 2;\n    }\n    return puVar1;\n}\n",
        "token_count": 136
    },
    "004156e2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004156e2(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = *param_1;\n    piVar1 = *(iVar2 + -0x10);\n    if (*(iVar2 + -0xc) != 0) {\n        if (*(iVar2 + -4) < 0) {\n            fcn.00415667(0);\n        }\n        else {\n            fcn.004010f0();\n            iVar2 = (**(*piVar1 + 0xc))();\n            *param_1 = iVar2 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 150
    },
    "00415719": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415719(int32_t arg_8h)\n\n{\n    int32_t arg_10h;\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_10h = *in_ECX;\n    iVar1 = *(arg_10h + -0xc);\n    puVar2 = (**(**(arg_10h + -0x10) + 0x10))();\n    iVar3 = (***puVar2)(arg_8h, 2);\n    if (iVar3 == 0) {\n        fcn.00415694();\n    }\n    if (iVar1 < arg_8h) {\n        arg_8h = iVar1;\n    }\n    fcn.00414faa(iVar3 + 0x10, arg_8h + 1, arg_10h, arg_8h + 1);\n    *(iVar3 + 4) = iVar1;\n    fcn.004010f0();\n    *in_ECX = iVar3 + 0x10;\n    return;\n}\n",
        "token_count": 261
    },
    "00415783": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415783(int32_t arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    ppiVar1 = *in_ECX + -0x10;\n    if ((*(*in_ECX + -8) < arg_8h) && (0 < arg_8h)) {\n        iVar2 = (**(**ppiVar1 + 8))(ppiVar1, arg_8h, 2);\n        if (iVar2 != 0) goto code_r0x004157b2;\n    }\n    iVar2 = fcn.00415694();\ncode_r0x004157b2:\n    *in_ECX = iVar2 + 0x10;\n    return;\n}\n",
        "token_count": 172
    },
    "00415ccc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint16_t * __cdecl fcn.00415ccc(uint arg_8h, uint arg_ch)\n\n{\n    uint16_t *puVar1;\n    uint arg_8h_00;\n    uint32_t arg_8h_01;\n    \n    puVar1 = fcn.004010b0(arg_8h, arg_ch);\n    if (puVar1 != NULL) {\n        arg_8h_01 = *puVar1;\n        arg_8h_00 = fcn.0041581c(arg_8h_01);\n        fcn.00415083(arg_8h_00, arg_8h_01, puVar1 + 1, *puVar1);\n        fcn.00415667(arg_8h_01);\n        puVar1 = 0x1;\n    }\n    return puVar1;\n}\n",
        "token_count": 185
    },
    "00415fce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpString\n// WARNING: Variable defined which should be unmapped: pv\n// WARNING: Variable defined which should be unmapped: ppbc\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h\n\nvoid __cdecl fcn.00415fce(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t *piVar5;\n    int32_t unaff_EBP;\n    int32_t *piVar6;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint lpString;\n    uint pv;\n    uint ppbc;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x44);\n    piVar6 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x30) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x24) = piVar6;\n    *(unaff_EBP + -0x50) = *(unaff_EBP + 0x1c);\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    fcn.004155eb(piVar6);\n    fcn.0041560f(piVar6);\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x34) = *(unaff_EBP + -0x40) != 0;\n    iVar3 = (**(*piVar6 + 0x3c))(piVar6, unaff_EBP + -0x20);\n    if (iVar3 != 0) {\n        *(unaff_EBP + -0x20) = *0x485000;\n        *(unaff_EBP + -0x1c) = *0x485004;\n        *(unaff_EBP + -0x18) = *0x485008;\n        *(unaff_EBP + -0x14) = *0x48500c;\n        piVar6 = *(unaff_EBP + -0x24);\n    }\n    (**(*piVar6 + 0x40))(piVar6, 1, unaff_EBP + -0x2c);\n    if (*(unaff_EBP + -0x34) == 0) {\n        if (*(unaff_EBP + -0x30) == 0) {\n            iVar3 = (**(*piVar6 + 0x20))(piVar6, 4, 3, unaff_EBP + -0x48);\n            if (iVar3 == 0) {\n                *(unaff_EBP + -0x24) = 0;\n                *(unaff_EBP + -4) = 6;\n                (*_sym.imp.ole32.dll_CreateBindCtx)(0, unaff_EBP + -0x24);\n                (**(**(unaff_EBP + -0x48) + 0x50))(*(unaff_EBP + -0x48), *(unaff_EBP + -0x24), 0, unaff_EBP + -0x30);\n                piVar5 = *(unaff_EBP + -0x24);\n                *(unaff_EBP + -0x28) = 1;\n                *(unaff_EBP + -4) = 3;\n                if (piVar5 != NULL) {\n                    (**(*piVar5 + 8))(piVar5);\n                }\n            }\n        }\n    }\n    else {\n        if (*(unaff_EBP + -0x2c) != 0) {\n            fcn.004156cc();\n            *(unaff_EBP + -4) = 4;\n            iVar3 = fcn.00415d18(0xf094);\n            if (iVar3 == 0) {\n                fcn.0041638e();\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenW)(*(unaff_EBP + -0x2c));\n            iVar3 = *(*(unaff_EBP + -0x24) + -0xc) + 1 + iVar3;\n            *(unaff_EBP + -0x28) = 0;\n            *(unaff_EBP + -4) = 5;\n            cVar2 = fcn.004155b6(iVar3);\n            if (cVar2 != '\\0') {\n                puVar4 = fcn.0045b3af();\n                *(unaff_EBP + -0x34) = *puVar4;\n                puVar4 = fcn.0045b3af();\n                *puVar4 = 0;\n                fcn.0045b34c(*(unaff_EBP + -0x28), iVar3, iVar3 + -1, *(unaff_EBP + -0x24), *(unaff_EBP + -0x2c));\n                piVar5 = fcn.0045b3af();\n                if (*piVar5 == 0) {\n                    puVar4 = fcn.0045b3af();\n                    *puVar4 = *(unaff_EBP + -0x34);\n                }\n                else {\n                    puVar4 = fcn.0045b3af();\n                    fcn.00415526(*puVar4);\n                }\n                uVar1 = *(unaff_EBP + -0x28);\n                *(unaff_EBP + -0x28) = 0;\n                fcn.004153be(uVar1);\n            }\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x28));\n            *(unaff_EBP + -4) = 3;\n            fcn.004010f0();\n        }\n        (**(**(unaff_EBP + -0x40) + 0x20))(*(unaff_EBP + -0x40), unaff_EBP + -0x30);\n        *(unaff_EBP + -0x28) = 1;\n    }\n    puVar4 = *(unaff_EBP + -0x50);\n    if (puVar4 == NULL) {\n        piVar5 = *(unaff_EBP + -0x4c);\n        if (piVar5 != NULL) {\n            iVar3 = (**(*piVar5 + 0x24))(piVar5, *(unaff_EBP + 0x10), 0xffffffff, 0, unaff_EBP + -0x3c);\n            if (iVar3 == 0) goto code_r0x004161b0;\n        }\n        *(unaff_EBP + -0x3c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n    }\n    else {\n        uVar1 = puVar4[1];\n        *(unaff_EBP + -0x3c) = *puVar4;\n        *(unaff_EBP + -0x38) = uVar1;\n    }\ncode_r0x004161b0:\n    iVar3 = (**(*piVar6 + 0x58))(piVar6, *(unaff_EBP + 0x10), unaff_EBP + -0x44);\n    if (iVar3 != 0) {\n        *(unaff_EBP + -0x44) = 0;\n    }\n    fcn.0041523b(*(unaff_EBP + -0x20), *(unaff_EBP + -0x1c), *(unaff_EBP + -0x18), *(unaff_EBP + -0x14), \n                 *(unaff_EBP + 0x10), *(unaff_EBP + -0x3c), *(unaff_EBP + -0x38), *(unaff_EBP + 0x14), \n                 *(unaff_EBP + 0x18), *(unaff_EBP + -0x44), *(unaff_EBP + -0x2c), *(unaff_EBP + -0x30));\n    if (*(unaff_EBP + -0x28) != 0) {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x30));\n    }\n    piVar6 = *(unaff_EBP + -0x40);\n    *(unaff_EBP + -4) = 2;\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    piVar6 = *(unaff_EBP + -0x4c);\n    *(unaff_EBP + -4) = 1;\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    piVar6 = *(unaff_EBP + -0x48);\n    *(unaff_EBP + -4) = 0;\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\n    (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x2c));\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 2311
    },
    "004164bd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004164bd(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00458589(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 85
    },
    "0041650d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041650d(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.00414f1d(&var_4h, arg_8h, arg_ch);\n    if (iVar1 < 0) {\n        fcn.00401000(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 94
    },
    "004166d5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004166d5(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_ch_00;\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    arg_ch_00 = arg_8h;\n    iVar2 = 0;\n    if (-1 < arg_8h) goto code_r0x004166ed;\n    do {\n        fcn.0041638e();\ncode_r0x004166ed:\n        if (iVar2 <= arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_ch_00 == iVar2) {\n            fcn.004166aa(*(in_ECX + 4), *(in_ECX + 8));\n            fcn.00414b30(*(in_ECX + 4));\n            *(in_ECX + 0xc) = iVar2;\n            *(in_ECX + 8) = iVar2;\n            goto code_r0x00416801;\n        }\n        iVar1 = *(in_ECX + 4);\n        if (iVar1 == iVar2) {\n            arg_8h_00 = fcn.00414af6(arg_ch_00 << 2);\n            *(in_ECX + 4) = arg_8h_00;\n            fcn.0041664d(arg_8h_00, arg_ch_00);\n            *(in_ECX + 0xc) = arg_ch_00;\ncode_r0x0041676e:\n            *(in_ECX + 8) = arg_ch_00;\n            return;\n        }\n        iVar2 = *(in_ECX + 0xc);\n        if (arg_ch_00 <= iVar2) {\n            iVar2 = *(in_ECX + 8);\n            if (iVar2 < arg_ch_00) {\n                fcn.0041664d(iVar1 + iVar2 * 4, arg_ch_00 - iVar2);\n            }\n            else if (arg_ch_00 < iVar2) {\n                fcn.004166aa(iVar1 + arg_ch_00 * 4, iVar2 - arg_ch_00);\n            }\n            goto code_r0x0041676e;\n        }\n        iVar1 = *(in_ECX + 0x10);\n        if (iVar1 == 0) {\n            iVar1 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar1 < 4) {\ncode_r0x004167a0:\n                iVar1 = 4;\n            }\n            else if (iVar1 < 0x401) {\n                if (iVar1 < 4) goto code_r0x004167a0;\n            }\n            else {\n                iVar1 = 0x400;\n            }\n        }\n        arg_8h = iVar1 + iVar2;\n        if (iVar1 + iVar2 <= arg_ch_00) {\n            arg_8h = arg_ch_00;\n        }\n    } while (arg_8h < iVar2);\n    iVar2 = fcn.00414af6(arg_8h << 2);\n    fcn.00414fcb(iVar2, arg_8h << 2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.0041664d(iVar2 + *(in_ECX + 8) * 4, arg_ch_00 - *(in_ECX + 8));\n    fcn.00414b30(*(in_ECX + 4));\n    *(in_ECX + 8) = arg_ch_00;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00416801:\n    *(in_ECX + 4) = iVar2;\n    return;\n}\n",
        "token_count": 858
    },
    "0041680b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0041680b(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    uVar1 = fcn.0041f6b5();\n    fcn.004018a0(uVar1);\n    *(unaff_EBP + -4) = 0;\n    if (0 < *(unaff_EBP + 0xc)) {\n        if (*(unaff_EBP + 8) == 0) {\n            fcn.00401000(0x80070057);\n        }\n        uVar1 = fcn.004016d0(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        uVar2 = fcn.00401eb0(uVar1);\n        fcn.00401690(uVar2, uVar1, *(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        fcn.00401660(uVar1);\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 323
    },
    "0041701f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041701f(uint arg_8h, uint arg_ch)\n\n{\n    uint *puVar1;\n    \n    puVar1 = fcn.0044abf4(arg_8h);\n    *puVar1 = arg_ch;\n    return;\n}\n",
        "token_count": 61
    },
    "00418582": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00418582(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.004183cd();\n    if (iVar2 == 0) {\n        if ((((arg_8h == 0x12340042) && (arg_ch != NULL)) && (0x27 < *arg_ch)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar4;\n            uVar4 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            uVar3 = 1;\n            arg_ch[4] = uVar4;\n            arg_ch[9] = 1;\n            if (0x47 < *arg_ch) {\n                fcn.00458da4(arg_ch + 10, 0x20, \"DISPLAY\", 0x1f);\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n    }\n    else {\n        uVar3 = (**0x49bbe0)(arg_8h, arg_ch);\n    }\n    return uVar3;\n}\n",
        "token_count": 418
    },
    "0041a852": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041a852(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x24);\n    *(unaff_EBP + -0x2c) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x28) = extraout_ECX;\n    *(unaff_EBP + -0x24) = 0;\n    iVar1 = fcn.0041ff5e();\n    *(unaff_EBP + -0x18) = iVar1;\n    *(unaff_EBP + -0x14) = *(iVar1 + 0xdc);\n    *(iVar1 + 0xdc) = extraout_ECX[8];\n    iVar1 = *extraout_ECX;\n    *(unaff_EBP + 8) = 0;\n    *(unaff_EBP + -4) = 0;\n    (**(iVar1 + 0xfc))(unaff_EBP + -0x2c);\n    *(unaff_EBP + 8) = 1;\n    *(*(unaff_EBP + -0x18) + 0xdc) = *(unaff_EBP + -0x14);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 357
    },
    "0041a8dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a8dd(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t lpPoints;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.00418009();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x20), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        }\n        if (iVar5 != 0) {\n            iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x36b, 0, 0);\n            if (iVar4 != 0) {\n                iVar5 = iVar4;\n            }\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x20);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x20), &var_38h);\n    if ((var_4h & 0x40000000) == 0) {\n        if (iVar5 != 0) {\n            uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0);\n            if (((uVar2 & 0x10000000) == 0) || ((uVar2 & 0x20000000) != 0)) {\n                iVar5 = 0;\n            }\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.00409ef0();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x20);\n            }\n            uVar3 = fcn.00418515(iVar5, 1);\n            fcn.00418582(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.00418515(iVar5, 2);\n            fcn.00418582(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_20h) / 2 - (var_30h - var_38h) / 2;\n    iVar4 = (var_24h + var_1ch) / 2 - (var_2ch - var_34h) / 2;\n    if (var_10h < (var_30h - var_38h) + iVar5) {\n        iVar5 = (var_38h - var_30h) + var_10h;\n    }\n    if (iVar5 < lprcDst) {\n        iVar5 = lprcDst;\n    }\n    if (var_ch < (var_2ch - var_34h) + iVar4) {\n        iVar4 = (var_34h - var_2ch) + var_ch;\n    }\n    if (iVar4 < var_14h) {\n        iVar4 = var_14h;\n    }\n    fcn.0041822e(0, iVar5, iVar4, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1080
    },
    "0041af40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0041af40(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    uint uVar3;\n    \n    uVar3 = 0;\n    iVar1 = fcn.0041aea0(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = iVar1 + 0x1c;\n    if (iVar1 == 0) {\n        fcn.0041638e(uVar3);\n        iVar1 = extraout_ECX;\n    }\n    if (*(iVar1 + 4) != 0) {\n        for (puVar2 = *(*(iVar1 + 4) + ((unaff_retaddr >> 4) % *(iVar1 + 8)) * 4); puVar2 != NULL; puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 239
    },
    "0041dbe1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041dbe1(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t *piVar4;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.0041ff5e();\n    iVar1 = iVar1 + 0x7c;\n    iVar2 = fcn.0042052a();\n    var_1ch = *(iVar2 + 8);\n    if (((arg_ch == 0) && (arg_10h == 0)) && (arg_14h == 0)) {\n        puVar3 = fcn.0045b3af();\n        var_4h = *puVar3;\n        puVar3 = fcn.0045b3af();\n        *puVar3 = 0;\n        fcn.00458bb8(iVar1, 0x60, 0x5f, \"Afx:%p:%x\", var_1ch);\n    }\n    else {\n        puVar3 = fcn.0045b3af();\n        var_4h = *puVar3;\n        puVar3 = fcn.0045b3af();\n        *puVar3 = 0;\n        fcn.00458bb8(iVar1, 0x60, 0x5f, \"Afx:%p:%x:%p:%p:%p\", var_1ch);\n    }\n    piVar4 = fcn.0045b3af();\n    if (*piVar4 == 0) {\n        puVar3 = fcn.0045b3af();\n        *puVar3 = var_4h;\n    }\n    else {\n        puVar3 = fcn.0045b3af();\n        fcn.00415526(*puVar3);\n    }\n    iVar2 = fcn.00419585(var_1ch, iVar1, &var_2ch);\n    if (iVar2 == 0) {\n        var_2ch = arg_8h;\n        var_28h = _sym.imp.USER32.dll_DefWindowProcA;\n        var_18h = arg_14h;\n        var_14h = arg_ch;\n        var_10h = arg_10h;\n        var_20h = 0;\n        var_24h = 0;\n        var_ch = 0;\n        var_8h = iVar1;\n        iVar2 = fcn.0041db54(&var_2ch);\n        if (iVar2 == 0) {\n            fcn.00416f76();\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 674
    },
    "0041e4c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0041e4c1(int32_t arg_8h, uint *arg_ch, uint noname_2, code *arg_14h, uint *arg_18h, int32_t arg_1ch, \n            int32_t *arg_20h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    uint unaff_EBX;\n    uint uVar3;\n    uint *unaff_ESI;\n    uint *puVar4;\n    \n    uVar3 = unaff_EBX;\n    puVar4 = unaff_ESI;\n    if (arg_8h != 0) goto code_r0x0041e4d2;\ncode_r0x0041e4cd:\n    fcn.0041638e();\n    arg_8h = extraout_ECX;\n    uVar3 = unaff_EBX;\n    puVar4 = unaff_ESI;\ncode_r0x0041e4d2:\n    unaff_EBX = 1;\n    if (arg_20h != NULL) {\n        *arg_20h = arg_8h;\n        arg_20h[1] = arg_14h;\n        return 1;\n    }\n    if (0xb < arg_1ch - 0x39U) {\n        return 0;\n    }\n    // switch table (12 cases) at 0x41e5c9\n    unaff_ESI = puVar4;\n    switch(*((arg_1ch - 0x39U) * 4 + 0x41e5c9)) {\n    case 0x41e503:\n        (*arg_14h)();\n        return 1;\n    case 0x41e50b:\n        uVar2 = (*arg_14h)();\n        return uVar2;\n    case 0x41e513:\n        arg_18h = arg_ch;\n        break;\n    case 0x41e51e:\n        arg_18h = arg_ch;\n        goto code_r0x0041e5b7;\n    case 0x41e526:\n        if (arg_18h != NULL) {\n            (*arg_14h)(arg_18h[1], *arg_18h);\n            return 1;\n        }\n        goto code_r0x0041e4cd;\n    case 0x41e53a:\n        if (arg_18h != NULL) {\n            uVar2 = (*arg_14h)(arg_18h[1], *arg_18h);\n            return uVar2;\n        }\n        goto code_r0x0041e4cd;\n    case 0x41e54b:\n        if (arg_18h != NULL) {\n            (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n            return 1;\n        }\n        goto code_r0x0041e4cd;\n    case 0x41e563:\n        if (arg_18h != NULL) {\n            uVar2 = (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n            return uVar2;\n        }\n        goto code_r0x0041e4cd;\n    case 0x41e57b:\n        unaff_ESI = arg_18h;\n        if (arg_18h != NULL) {\n            (*arg_14h)(arg_18h);\n            goto code_r0x0041e58a;\n        }\n        goto code_r0x0041e4cd;\n    case 0x41e598:\n        goto code_r0x0041e598;\n    case 0x41e5ac:\n        break;\n    case 0x41e5b4:\ncode_r0x0041e5b7:\n        uVar2 = (*arg_14h)(arg_18h);\n        return uVar2;\n    }\n    (*arg_14h)(arg_18h);\n    return 1;\ncode_r0x0041e598:\n    unaff_ESI = arg_18h;\n    if (arg_18h != NULL) {\n        (*arg_14h)(arg_18h, arg_ch, puVar4, uVar3);\ncode_r0x0041e58a:\n        iVar1 = arg_18h[7];\n        arg_18h[7] = 0;\n        return iVar1 == 0;\n    }\n    goto code_r0x0041e4cd;\n}\n",
        "token_count": 991
    },
    "0041ec03": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0041ec03(code **param_1)\n\n{\n    fcn.0041997f();\n    *param_1 = vtable.CDialog.0;\n    fcn.00458b20(param_1 + 0x15, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 73
    },
    "0041ecb7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ecb7(code *arg_8h, code *arg_ch)\n\n{\n    code **in_ECX;\n    \n    fcn.0041997f();\n    *in_ECX = vtable.CDialog.0;\n    fcn.00458b20(in_ECX + 0x15, 0, 0x20);\n    in_ECX[0x1a] = arg_ch;\n    in_ECX[0x15] = arg_8h;\n    in_ECX[0x16] = arg_8h & 0xffff;\n    return;\n}\n",
        "token_count": 132
    },
    "0041f111": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: hMem\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041f111(uint arg_8h, uint arg_ch, uint hInstance)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_48h;\n    uint var_38h;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hMem;\n    uint var_4h;\n    \n    fcn.0045af6e(0x3c);\n    *(unaff_EBP + -0x20) = arg_8h_00;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar2 = fcn.0042052a();\n        *(unaff_EBP + 0x10) = *(iVar2 + 0xc);\n    }\n    iVar2 = fcn.0042052a();\n    piVar1 = *(iVar2 + 0x3c);\n    *(unaff_EBP + -0x28) = piVar1;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0041de55(0x10);\n    fcn.0041de55(0x3c000);\n    if (piVar1 == NULL) {\n        iVar2 = *(unaff_EBP + 8);\n    }\n    else {\n        iVar2 = (**(*arg_8h_00 + 0x134))(unaff_EBP + -0x48);\n        if (iVar2 == 0) goto code_r0x0041f2bf;\n        iVar2 = (**(*piVar1 + 0x14))(unaff_EBP + -0x48, *(unaff_EBP + 8));\n    }\n    if (iVar2 != 0) {\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x18) = 0;\n        iVar3 = fcn.0044beb0(iVar2, unaff_EBP + -0x1c, unaff_EBP + -0x18);\n        if (iVar3 == 0) {\n            fcn.0044be74(iVar2);\n            *(unaff_EBP + -4) = 2;\n            fcn.0044bdd0(*(unaff_EBP + -0x18));\n            uVar4 = fcn.0044badd();\n            *(unaff_EBP + -0x14) = uVar4;\n            *(unaff_EBP + -4) = 1;\n            fcn.0044bacf();\n            if (*(unaff_EBP + -0x14) != 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n            }\n        }\n        arg_8h_00[0x11] = -1;\n        arg_8h_00[0xf] = arg_8h_00[0xf] | 0x10;\n        fcn.0041ce25(arg_8h_00);\n        if (*(unaff_EBP + 0xc) == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = *(*(unaff_EBP + 0xc) + 0x20);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamA)(*(unaff_EBP + 0x10), iVar2, uVar4, fcn.0041ebc5, 0);\n        fcn.004010f0();\n        *(unaff_EBP + -4) = 0xffffffff;\n        if ((*(unaff_EBP + -0x28) != NULL) && (iVar2 != 0)) {\n            (**(**(unaff_EBP + -0x28) + 0x18))(unaff_EBP + -0x48);\n            (**(*arg_8h_00 + 0x134))(0);\n        }\n        iVar3 = fcn.0041afcd();\n        if (iVar3 == 0) {\n            (**(*arg_8h_00 + 0x11c))();\n        }\n        if ((iVar2 != 0) && ((*(arg_8h_00 + 0xf) & 0x10) == 0)) {\n            (*_sym.imp.USER32.dll_DestroyWindow)(iVar2);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n        }\n    }\ncode_r0x0041f2bf:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1194
    },
    "0041f5cb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041f5cb(uint arg_8h, uchar *arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort *puVar3;\n    \n    if ((arg_ch != NULL) && (arg_10h != 0)) {\n        iVar2 = fcn.0042052a();\n        puVar3 = fcn.004010b0(*(iVar2 + 0xc), arg_8h);\n        if (puVar3 == NULL) {\n            *arg_ch = 0;\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar3 + 1, *puVar3, arg_ch, arg_10h + -1, 0, 0);\n            arg_ch[iVar2] = 0;\n        }\n        return iVar2;\n    }\n    fcn.0041638e();\n    pcVar1 = swi(3);\n    iVar2 = (*pcVar1)();\n    return iVar2;\n}\n",
        "token_count": 248
    },
    "0041fb0a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041fb0a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042052a();\n    if (*(iVar1 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x0041fb20. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(iVar1 + 4) + 0x98))();\n        return;\n    }\n    fcn.0041f9a9(0, arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 148
    },
    "0042007c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042007c(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    fcn.00404920(\"comctl32.dll\");\n    *(unaff_EBP + -4) = 0;\n    fcn.0042002e(unaff_EBP + -0x10);\n    fcn.004010f0();\n    *extraout_ECX = vtable.CComCtlWrapper.0;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[10] = NULL;\n    extraout_ECX[0xb] = NULL;\n    extraout_ECX[0xc] = NULL;\n    extraout_ECX[0xd] = NULL;\n    extraout_ECX[0xe] = NULL;\n    extraout_ECX[0xf] = NULL;\n    extraout_ECX[0x10] = NULL;\n    extraout_ECX[0x11] = NULL;\n    extraout_ECX[0x12] = NULL;\n    extraout_ECX[0x13] = NULL;\n    extraout_ECX[0x14] = NULL;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x16] = NULL;\n    extraout_ECX[0x17] = NULL;\n    extraout_ECX[0x18] = NULL;\n    extraout_ECX[0x19] = NULL;\n    extraout_ECX[0x1a] = NULL;\n    extraout_ECX[0x1b] = NULL;\n    extraout_ECX[0x1c] = NULL;\n    extraout_ECX[0x1d] = NULL;\n    extraout_ECX[0x1e] = NULL;\n    extraout_ECX[0x1f] = NULL;\n    extraout_ECX[0x20] = NULL;\n    extraout_ECX[0x21] = NULL;\n    extraout_ECX[0x22] = NULL;\n    extraout_ECX[0x23] = NULL;\n    extraout_ECX[0x24] = NULL;\n    extraout_ECX[0x25] = NULL;\n    extraout_ECX[0x26] = NULL;\n    extraout_ECX[0x27] = NULL;\n    extraout_ECX[0x28] = NULL;\n    extraout_ECX[0x29] = NULL;\n    extraout_ECX[0x2a] = NULL;\n    extraout_ECX[0x2b] = NULL;\n    extraout_ECX[0x2c] = NULL;\n    extraout_ECX[0x2d] = NULL;\n    extraout_ECX[0x2e] = NULL;\n    extraout_ECX[0x2f] = NULL;\n    extraout_ECX[0x30] = NULL;\n    extraout_ECX[0x31] = NULL;\n    extraout_ECX[0x32] = NULL;\n    extraout_ECX[0x33] = NULL;\n    extraout_ECX[0x34] = NULL;\n    extraout_ECX[0x35] = NULL;\n    extraout_ECX[0x36] = NULL;\n    extraout_ECX[0x37] = NULL;\n    extraout_ECX[0x38] = NULL;\n    extraout_ECX[0x39] = NULL;\n    extraout_ECX[0x3a] = NULL;\n    extraout_ECX[0x3b] = NULL;\n    extraout_ECX[0x3c] = NULL;\n    extraout_ECX[0x3d] = NULL;\n    extraout_ECX[0x3e] = NULL;\n    extraout_ECX[0x3f] = NULL;\n    extraout_ECX[0x40] = NULL;\n    extraout_ECX[0x41] = NULL;\n    extraout_ECX[0x42] = NULL;\n    extraout_ECX[0x43] = NULL;\n    extraout_ECX[0x44] = NULL;\n    extraout_ECX[0x45] = NULL;\n    extraout_ECX[0x46] = NULL;\n    extraout_ECX[0x47] = NULL;\n    extraout_ECX[0x48] = NULL;\n    extraout_ECX[0x49] = NULL;\n    extraout_ECX[0x4a] = NULL;\n    extraout_ECX[0x4b] = NULL;\n    extraout_ECX[0x4c] = NULL;\n    extraout_ECX[0x4d] = NULL;\n    extraout_ECX[0x4e] = NULL;\n    extraout_ECX[0x4f] = NULL;\n    extraout_ECX[0x50] = NULL;\n    extraout_ECX[0x51] = NULL;\n    extraout_ECX[0x52] = NULL;\n    extraout_ECX[0x53] = NULL;\n    extraout_ECX[0x54] = NULL;\n    extraout_ECX[0x55] = NULL;\n    extraout_ECX[0x56] = NULL;\n    extraout_ECX[0x57] = NULL;\n    extraout_ECX[0x58] = NULL;\n    extraout_ECX[0x59] = NULL;\n    extraout_ECX[0x5a] = NULL;\n    extraout_ECX[0x5b] = NULL;\n    extraout_ECX[0x5c] = NULL;\n    extraout_ECX[0x5d] = NULL;\n    extraout_ECX[0x5e] = NULL;\n    extraout_ECX[0x5f] = NULL;\n    extraout_ECX[0x60] = NULL;\n    extraout_ECX[0x61] = NULL;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1388
    },
    "004202c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004202c0(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    fcn.00404920(\"comdlg32.dll\");\n    *(unaff_EBP + -4) = 0;\n    fcn.0042002e(unaff_EBP + -0x10);\n    fcn.004010f0();\n    *extraout_ECX = vtable.CCommDlgWrapper.0;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[10] = NULL;\n    extraout_ECX[0xb] = NULL;\n    extraout_ECX[0xc] = NULL;\n    extraout_ECX[0xd] = NULL;\n    extraout_ECX[0xe] = NULL;\n    extraout_ECX[0xf] = NULL;\n    extraout_ECX[0x10] = NULL;\n    extraout_ECX[0x11] = NULL;\n    extraout_ECX[0x12] = NULL;\n    extraout_ECX[0x13] = NULL;\n    extraout_ECX[0x14] = NULL;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x16] = NULL;\n    extraout_ECX[0x17] = NULL;\n    extraout_ECX[0x18] = NULL;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 409
    },
    "00420343": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00420343(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    fcn.00404920(\"shell32.dll\");\n    *(unaff_EBP + -4) = 0;\n    fcn.0042002e(unaff_EBP + -0x10);\n    fcn.004010f0();\n    *extraout_ECX = vtable.CShellWrapper.0;\n    extraout_ECX[4] = NULL;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 163
    },
    "0042055d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042055d(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uStack8;\n    \n    fcn.0042052a();\n    iVar2 = fcn.0042001a();\n    if (iVar2 == 0) {\n        uStack8 = 0x496e18;\n        fcn.004593a9(&uStack8, 0x48c300);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 121
    },
    "004205ed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004205ed(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == 0) {\n        arg_8h = 0x38;\n    }\n    iVar1 = fcn.0045adaa(arg_8h);\n    *(in_ECX + 0x74) = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.00416356();\n    }\n    fcn.00458b20(iVar1, 0, arg_8h);\n    **(in_ECX + 0x74) = arg_8h;\n    return;\n}\n",
        "token_count": 156
    },
    "004208a6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004208a6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00420885(arg_8h);\n    if (iVar1 == 0) {\n        fcn.0041638e();\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00420bd8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420bd8(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    fcn.00458b20(in_ECX + 0x54, 0, 0x34);\n    *(in_ECX + 0xa8) = 0;\n    *(in_ECX + 0x68) = *(in_ECX + 0x9c);\n    *(in_ECX + 0x54) = 0x34;\n    *(in_ECX + 0x58) = 8;\n    *(in_ECX + 0x70) = arg_ch;\n    *(in_ECX + 0xa4) = 1;\n    iVar1 = fcn.0041ef70();\n    if (iVar1 != 0) {\n        *(in_ECX + 0x58) = *(in_ECX + 0x58) | 0x200;\n    }\n    *(in_ECX + 0xa0) = arg_8h;\n    return;\n}\n",
        "token_count": 236
    },
    "004216a8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.004216a8(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x1c);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    iVar1 = fcn.0044c34f(unaff_EBP + -0x14, unaff_EBP + -0x1c, *(unaff_EBP + 0xc));\n    if (iVar1 == 0) {\ncode_r0x004216d4:\n        fcn.004010f0();\n    }\n    else {\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 1;\n        iVar1 = fcn.0044beb0(*(unaff_EBP + 8), unaff_EBP + -0x18, unaff_EBP + -0x10);\n        if (iVar1 != 0) {\n            iVar1 = fcn.00420ff8(*(unaff_EBP + -0x14));\n            if ((iVar1 == 0) && (*(unaff_EBP + -0x10) == *(unaff_EBP + -0x1c))) {\n                fcn.004010f0();\n                goto code_r0x004216d4;\n            }\n        }\n        fcn.0044be74(*(unaff_EBP + 8));\n        *(unaff_EBP + -4) = 2;\n        fcn.0044bc7c(*(unaff_EBP + -0x14), *(unaff_EBP + -0x1c));\n        fcn.0044badd();\n        *(unaff_EBP + -4) = 1;\n        fcn.0044bacf();\n        fcn.004010f0();\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 557
    },
    "00421c53": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00421c53(uint *param_1)\n\n{\n    *param_1 = 0x38;\n    fcn.00458b20(param_1 + 1, 0, 0x34);\n    return param_1;\n}\n",
        "token_count": 60
    },
    "0042201c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0042201c(int32_t *arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    *arg_8h = (in_ECX[2] + *in_ECX) / 2;\n    arg_8h[1] = (in_ECX[3] + in_ECX[1]) / 2;\n    return arg_8h;\n}\n",
        "token_count": 93
    },
    "00422e48": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422e48(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_1ch;\n    int32_t var_14h;\n    uint lpPoint;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004423c2(&var_4h, &var_8h);\n    fcn.00412df0(&lpPoint, var_4h);\n    (*_sym.imp.USER32.dll_ClientToScreen)(*(in_ECX + 0x20), &lpPoint);\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x20), &lpRect);\n    iVar1 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, var_ch);\n    if (iVar1 == 0) {\n        return;\n    }\n    if (var_14h - var_1ch < var_ch) {\n        iVar1 = (var_ch - var_14h) + -0x14;\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetSystemMetrics)(1);\n        if (iVar1 <= (var_14h - var_1ch) + var_ch) goto code_r0x00422edf;\n        iVar1 = (var_ch - var_1ch) + 0x28;\n    }\n    (*_sym.imp.USER32.dll_OffsetRect)(&lpRect, 0, iVar1);\ncode_r0x00422edf:\n    fcn.004011b0(&lpRect, 1);\n    return;\n}\n",
        "token_count": 375
    },
    "004238c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004238c6(uint lpString, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    fcn.004423c2(&var_ch, &var_8h);\n    if (iVar1 == var_8h - var_ch) {\n        fcn.004425d3(&var_4h);\n        if (arg_ch == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString, var_4h);\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)();\n        }\n        bVar2 = iVar1 == 0;\n        fcn.004010f0();\n    }\n    else {\n        bVar2 = false;\n    }\n    return bVar2;\n}\n",
        "token_count": 224
    },
    "004245d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.004245d3(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x14);\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    fcn.00404920(*(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    fcn.00412d50();\n    iVar1 = **(extraout_ECX + 0x54);\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -4) = 2;\n    iVar1 = (**(iVar1 + 0x140))(0);\n    *(iVar1 + 0x84) = 1;\n    *(unaff_EBP + -0x14) = iVar1;\n    iVar2 = fcn.0042676e(*(unaff_EBP + -0x18), 0x485000, 1, 0, 0);\n    if (iVar2 == 0) {\n        fcn.00416356();\n    }\n    fcn.00428202();\n    fcn.00422cee(iVar1);\n    *(iVar1 + 0x84) = 0;\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -4) = 0;\n    fcn.00414280();\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 455
    },
    "00424ca9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424ca9(int32_t arg_8h, uint *arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar2 = *(in_ECX + 8);\n            fcn.00436fd5(iVar2 + arg_10h, 0xffffffff);\n            iVar2 = (iVar2 - arg_8h) * 4;\n            fcn.004164bd(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, iVar2, *(in_ECX + 4) + arg_8h * 4, iVar2);\n            fcn.00458b20(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n        }\n        else {\n            fcn.00436fd5(arg_8h + arg_10h, 0xffffffff);\n        }\n        arg_8h = arg_8h << 2;\n        do {\n            arg_10h = arg_10h + -1;\n            *(arg_8h + *(in_ECX + 4)) = *arg_ch;\n            arg_8h = arg_8h + 4;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.0041638e();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 374
    },
    "004255e9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004255e9(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00458b9a(arg_8h, arg_ch, \"Embedding %lu\", *(in_ECX + 0x2c));\n    return;\n}\n",
        "token_count": 69
    },
    "004256d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004256d0(int32_t param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    \n    ppiVar1 = param_1 + 0x3c;\n    arg_8h = 0;\n    iVar2 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(0, 1, ppiVar1);\n    if (iVar2 == 0) goto code_r0x004256ee;\n    while( true ) {\n        fcn.00415123(arg_8h);\ncode_r0x004256ee:\n        param_1 = (*_sym.imp.ole32.dll_StgCreateDocfileOnILockBytes)(*ppiVar1, 0x1012, 0, param_1 + 0x38);\n        if (param_1 == 0) break;\n        (**(**ppiVar1 + 8))(*ppiVar1);\n        *ppiVar1 = NULL;\n        arg_8h = param_1;\n    }\n    return;\n}\n",
        "token_count": 240
    },
    "0042676e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0042676e(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x18);\n    iVar1 = fcn.00425bda();\n    extraout_ECX[0xb] = iVar1;\n    (**(*extraout_ECX + 0xd0))();\n    uVar2 = fcn.00414c52(*(unaff_EBP + 0x18), *(unaff_EBP + 0x14), unaff_EBP + -0x24);\n    uVar3 = (**(*extraout_ECX + 0xc0))();\n    fcn.00416242(*(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    uVar2 = (*_sym.imp.ole32.dll_OleCreateFromFile)\n                      (*(unaff_EBP + 0xc), *(unaff_EBP + -0x10), 0x4850a0, *(unaff_EBP + 0x10), uVar2, uVar3, \n                       extraout_ECX[0xe], extraout_ECX + 9);\n    (**(*extraout_ECX + 0xc4))(uVar2);\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 417
    },
    "004267f9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.004267f9(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x18);\n    iVar1 = fcn.00425bda();\n    extraout_ECX[0xb] = iVar1;\n    (**(*extraout_ECX + 0xd0))();\n    uVar2 = fcn.00414c52(*(unaff_EBP + 0x14), *(unaff_EBP + 0x10), unaff_EBP + -0x24);\n    uVar3 = (**(*extraout_ECX + 0xc0))();\n    fcn.00416242(*(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    uVar2 = (*_sym.imp.ole32.dll_OleCreateLinkToFile)\n                      (*(unaff_EBP + -0x10), 0x4850a0, *(unaff_EBP + 0xc), uVar2, uVar3, extraout_ECX[0xe], \n                       extraout_ECX + 9);\n    (**(*extraout_ECX + 0xc4))(uVar2);\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 401
    },
    "00426881": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid fcn.00426881(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x24);\n    piVar1 = *(extraout_ECX + 0x20);\n    if (piVar1[0x1f] == 0) {\n        piVar1[0x14] = 0;\n        iVar2 = (**(*piVar1 + 0x70))();\n        if (iVar2 == 0) {\n            fcn.00416356();\n        }\n    }\n    fcn.004255e9(unaff_EBP + -0x28, 0x15);\n    fcn.00416242(unaff_EBP + -0x28);\n    piVar1 = piVar1[0x1f];\n    iVar2 = *piVar1;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (**(iVar2 + 0x14))(piVar1, *(unaff_EBP + -0x2c), 0x11012, 0, 0, unaff_EBP + -0x30);\n    if (iVar2 != 0) {\n        fcn.00415123(iVar2);\n    }\n    *(extraout_ECX + 0x38) = *(unaff_EBP + -0x30);\n    fcn.004010f0();\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 401
    },
    "00426d99": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00426d99(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x10);\n    puVar1 = *(unaff_EBP + 8);\n    if (puVar1 == NULL) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -0x10) = 0;\n    }\n    else {\n        uVar2 = *puVar1;\n        *(unaff_EBP + -0x10) = puVar1[1];\n        *(unaff_EBP + -0x14) = uVar2;\n        fcn.0044b322(unaff_EBP + -0x14);\n    }\n    puVar1 = *(unaff_EBP + 0xc);\n    if (puVar1 == NULL) {\n        *(unaff_EBP + -0x1c) = 0;\n        *(unaff_EBP + -0x18) = 0;\n    }\n    else {\n        uVar2 = *puVar1;\n        *(unaff_EBP + -0x18) = puVar1[1];\n        *(unaff_EBP + -0x1c) = uVar2;\n        fcn.0044b322(unaff_EBP + -0x1c);\n    }\n    iVar3 = *(extraout_ECX + 0x20);\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(extraout_ECX + 4);\n    fcn.00416242(*(iVar3 + 0x24));\n    iVar3 = *(iVar3 + 0x24);\n    *(unaff_EBP + -4) = 0;\n    iVar3 = fcn.00415fce(*(extraout_ECX + 0x24), -(iVar3 != 0) & *(unaff_EBP + 8), *(extraout_ECX + 0x30), \n                         *(unaff_EBP + -0x14), *(unaff_EBP + -0x10), unaff_EBP + -0x1c);\n    (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(extraout_ECX + 4);\n    if (iVar3 == 0) {\n        fcn.00416356();\n    }\n    puVar1 = *(unaff_EBP + 0x10);\n    puVar1[2] = 0;\n    *puVar1 = 1;\n    puVar1[1] = iVar3;\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 728
    },
    "00427b1d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00427b1d(uint arg_8h)\n\n{\n    int32_t lpString2;\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x20);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    if ((extraout_ECX[0x1e] == 0) && (extraout_ECX[0x1f] == 0)) {\n        fcn.0044363b(*(unaff_EBP + 8));\n    }\n    else {\n        lpString2 = *(unaff_EBP + 8);\n        *(unaff_EBP + -0x14) = 0;\n        if (lpString2 != 0) {\n            iVar1 = fcn.0042abf7(extraout_ECX[9], lpString2);\n            extraout_ECX[0x20] = iVar1;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -4) = 0;\n        if ((lpString2 != 0) && (extraout_ECX[0x20] == 0)) {\n            *(unaff_EBP + -0x14) = extraout_ECX[0x1f];\n            extraout_ECX[0x1f] = 0;\n            fcn.00416242(lpString2);\n            *(unaff_EBP + -4) = 1;\n            iVar1 = (*_sym.imp.ole32.dll_StgCreateDocfile)(*(unaff_EBP + -0x1c), 0x11022, 0, unaff_EBP + -0x24);\n            if (iVar1 != 0) {\n                fcn.00415123(iVar1);\n            }\n            extraout_ECX[0x1f] = *(unaff_EBP + -0x24);\n            *(unaff_EBP + -4) = 0;\n            fcn.004010f0();\n        }\n        (**(*extraout_ECX + 0xdc))(0);\n        if (lpString2 != 0) {\n            if ((extraout_ECX[0x21] == 0) || (extraout_ECX[0x20] != 0)) {\n                arg_8h_00 = 0;\n            }\n            else {\n                arg_8h_00 = 1;\n            }\n            fcn.0042713e(arg_8h_00, 0);\n            if (extraout_ECX[0x21] != 0) {\n                (**(*extraout_ECX + 0x5c))(0);\n            }\n            if (extraout_ECX[0x20] == 0) {\n                if (extraout_ECX[0x21] == 0) {\n                    (**(*extraout_ECX[0x1f] + 8))(extraout_ECX[0x1f]);\n                    extraout_ECX[0x1f] = *(unaff_EBP + -0x14);\n                }\n                else {\n                    (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n                }\n            }\n        }\n        *(unaff_EBP + -0x20) = 1;\n        extraout_ECX[0x20] = 1;\n        extraout_ECX[0x21] = 1;\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 898
    },
    "00429ddd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00429ddd(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    uint uVar3;\n    \n    uVar3 = 0;\n    iVar1 = fcn.00429d55(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = iVar1 + 0x1c;\n    if (iVar1 == 0) {\n        fcn.0041638e(uVar3);\n        iVar1 = extraout_ECX;\n    }\n    if (*(iVar1 + 4) != 0) {\n        for (puVar2 = *(*(iVar1 + 4) + ((unaff_retaddr >> 4) % *(iVar1 + 8)) * 4); puVar2 != NULL; puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 238
    },
    "0042a985": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a985(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00459195(arg_8h, arg_ch, arg_10h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 75
    },
    "0042aae7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0042aae7(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    iVar1 = fcn.004024c0(*(unaff_EBP + 0xc));\n    if (iVar1 != 0) {\n        fcn.0042a9a3(*(unaff_EBP + 8), *(unaff_EBP + -0x10), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 240
    },
    "0042b179": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b179(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    \n    arg_8h_00 = fcn.00401eb0(0x104);\n    fcn.00458b20(arg_8h_00, 0, 0x104);\n    fcn.0041502b(arg_8h_00, 0x104, arg_8h, 0xffffffff);\n    (*_sym.imp.SHLWAPI.dll_PathStripToRootA)(arg_8h_00);\n    fcn.00409070(0xffffffff);\n    return;\n}\n",
        "token_count": 142
    },
    "0042b73c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b73c(uint arg_8h, uint *arg_ch)\n\n{\n    uint unaff_ESI;\n    uint var_108h;\n    uint var_104h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    fcn.00458b9a(&var_104h, 0x100, \"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", *arg_ch);\n    fcn.00404920(&var_104h);\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 164
    },
    "0042b7cb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0042b7cb(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    arg_ch_00 = *(unaff_EBP + 8);\n    puVar1 = *(unaff_EBP + 0x10);\n    *puVar1 = 0;\n    fcn.0042b73c(unaff_EBP + -0x10, arg_ch_00);\n    *(unaff_EBP + -4) = 0;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0042b0c7(*(unaff_EBP + -0x10), unaff_EBP + 0x10);\n    if (iVar2 == 0) {\n        fcn.004010f0();\n        fcn.004010f0();\n    }\n    else {\n        iVar2 = fcn.004197f3(*(unaff_EBP + 0x10));\n        if ((iVar2 != 0) &&\n           (pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"DllGetClassObject\"),  pcVar3 != NULL)) {\n            (*pcVar3)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), puVar1);\n        }\n        fcn.004010f0();\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 423
    },
    "0042b8d8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042b8d8(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uchar *puVar2;\n    uint *puVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t unaff_EBP;\n    uint var_17dh;\n    uint var_178h;\n    uint var_174h;\n    uint psfi;\n    uint var_168h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x174);\n    iVar6 = *(unaff_EBP + 8);\n    uVar1 = *(unaff_EBP + 0xc);\n    puVar2 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x178) = uVar1;\n    *(unaff_EBP + -0x174) = 0;\n    *puVar2 = 0;\n    if ((((iVar6 != 0) &&\n         (iVar5 = (*_sym.imp.SHELL32.dll_SHGetFileInfoA)(uVar1, 0, unaff_EBP + -0x170, 0x160, 0x800),  iVar5 != 0)) &&\n        ((*(unaff_EBP + -0x168) & 0x10000) != 0)) &&\n       ((iVar5 = fcn.0042b87a(0x47c87c, 0, 0x47c88c, unaff_EBP + -0x174),  -1 < iVar5 &&\n        (puVar3 = *(unaff_EBP + -0x174),  puVar3 != NULL)))) {\n        *(unaff_EBP + -0x17c) = 0;\n        iVar5 = (***puVar3)(puVar3, 0x485040, unaff_EBP + -0x17c);\n        if (-1 < iVar5) {\n            fcn.00416242(*(unaff_EBP + -0x178));\n            piVar4 = *(unaff_EBP + -0x17c);\n            *(unaff_EBP + -4) = 0;\n            if (piVar4 != NULL) {\n                iVar5 = (**(*piVar4 + 0x14))(piVar4, *(unaff_EBP + -0x178), 0);\n                if ((-1 < iVar5) &&\n                   (iVar6 = (**(**(unaff_EBP + -0x174) + 0x4c))(*(unaff_EBP + -0x174), *(iVar6 + 0x20), 2),  -1 < iVar6)\n                   ) {\n                    (**(**(unaff_EBP + -0x174) + 0xc))(*(unaff_EBP + -0x174), puVar2, *(unaff_EBP + 0x14), 0, 0);\n                    (**(**(unaff_EBP + -0x17c) + 8))(*(unaff_EBP + -0x17c));\n                    (**(**(unaff_EBP + -0x174) + 8))(*(unaff_EBP + -0x174));\n                    fcn.004010f0();\n                    goto code_r0x0042ba3d;\n                }\n                piVar4 = *(unaff_EBP + -0x17c);\n                if (piVar4 != NULL) {\n                    (**(*piVar4 + 8))(piVar4);\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004010f0();\n        }\n        (**(**(unaff_EBP + -0x174) + 8))(*(unaff_EBP + -0x174));\n    }\ncode_r0x0042ba3d:\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 882
    },
    "0042bc0a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0042bc0a(void)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    \n    iVar1 = fcn.0042bbc8(&var_24h);\n    if (iVar1 != 0) {\n        return *(iVar1 + 0x14) + 0x76c;\n    }\n    return 0;\n}\n",
        "token_count": 83
    },
    "0042c207": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c207(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar1 = *(in_ECX + 8);\n            fcn.00445b33(iVar1 + arg_10h, 0xffffffff);\n            fcn.004164bd(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, ((*(in_ECX + 8) - arg_8h) - arg_10h) * 4, \n                         *(in_ECX + 4) + arg_8h * 4, (iVar1 - arg_8h) * 4);\n            fcn.00458b20(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n        }\n        else {\n            fcn.00445b33(arg_8h + arg_10h, 0xffffffff);\n        }\n        arg_8h = arg_8h << 2;\n        do {\n            arg_10h = arg_10h + -1;\n            *(arg_8h + *(in_ECX + 4)) = arg_ch;\n            arg_8h = arg_8h + 4;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.0041638e();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 389
    },
    "0042c2ad": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c2ad(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h + arg_ch;\n    if ((((-1 < arg_8h) && (-1 < arg_ch)) && (iVar1 <= *(in_ECX + 8))) && ((arg_8h <= iVar1 && (arg_ch <= iVar1)))) {\n        iVar3 = *(in_ECX + 8) - iVar1;\n        if (iVar3 != 0) {\n            iVar3 = iVar3 * 4;\n            fcn.004164bd(*(in_ECX + 4) + arg_8h * 4, iVar3, *(in_ECX + 4) + iVar1 * 4, iVar3);\n        }\n        *(in_ECX + 8) = *(in_ECX + 8) - arg_ch;\n        return;\n    }\n    fcn.0041638e();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 257
    },
    "0042c7c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042c7c1(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint unaff_EDI;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    for (iVar1 = (**(*in_ECX + 0x118))(0x418, 0, 0); iVar1 != 0; iVar1 = iVar1 + -1) {\n        (**(*in_ECX + 0x118))(0x416, 0, 0);\n    }\n    fcn.00458b20(&var_18h, 0, 0x14);\n    var_8h = 0xffffffff;\n    if (arg_8h == NULL) {\n        iVar1 = 0;\n        var_10h._0_1_ = 4;\n        if (0 < arg_ch) {\n            do {\n                iVar3 = (**(*in_ECX + 0x118))(0x414, 1, &var_18h);\n                if (iVar3 == 0) goto code_r0x0042c8f1;\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < arg_ch);\n        }\n    }\n    else {\n        var_20h = 0;\n        var_1ch = 0;\n        if (0 < arg_ch) {\n            do {\n                var_14h = *arg_8h;\n                arg_8h = arg_8h + 1;\n                var_10h._0_1_ = 4;\n                if (var_14h == 0) {\n                    var_10h._1_1_ = 1;\n                    uVar2 = fcn.00418009();\n                    if (((uVar2 & 0x800) == 0) && (*0x49776c != 0x40047)) {\n                        var_18h = 8;\n                    }\n                    else {\n                        var_18h = 6;\n                    }\n                }\n                else {\n                    var_10h._1_1_ = 0;\n                    var_18h = var_20h;\n                    var_20h = var_20h + 1;\n                }\n                iVar1 = (**(*in_ECX + 0x118))(0x414, 1, &var_18h);\n                if (iVar1 == 0) goto code_r0x0042c8f1;\n                var_1ch = var_1ch + 1;\n            } while (var_1ch < arg_ch);\n        }\n    }\n    iVar1 = (**(*in_ECX + 0x118))(0x418, 0, 0);\n    in_ECX[0x1d] = iVar1;\n    in_ECX[0x29] = 1;\ncode_r0x0042c8f1:\n    fcn.0045843c(unaff_EDI);\n    return;\n}\n",
        "token_count": 745
    },
    "0042d2f4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d2f4(uint arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint var_20h;\n    uint var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    if (arg_14h == 0) {\n        arg_14h = arg_10h;\n        var_4h = fcn.0042c9f1(arg_8h, arg_ch, arg_10h);\n        iVar1 = fcn.0042c9f1(arg_8h, arg_ch, 0);\n        if ((iVar1 != var_4h) && (0 < arg_10h)) {\n            do {\n                iVar1 = (arg_14h + iVar4) / 2;\n                iVar2 = fcn.0042c9f1(arg_8h, arg_ch, iVar1);\n                if ((iVar2 != var_4h) && (bVar5 = iVar4 == iVar1,  iVar4 = iVar1,  iVar1 = arg_14h,  bVar5)) {\n                    fcn.0042c9f1(arg_8h, arg_ch, arg_14h);\n                    break;\n                }\n                arg_14h = iVar1;\n            } while (iVar4 < arg_14h);\n        }\n        fcn.0042d1c2(&var_10h, arg_8h, arg_ch);\n        iVar1 = var_10h;\ncode_r0x0042d46c:\n        fcn.0042c9f1(arg_8h, arg_ch, iVar1);\n    }\n    else {\n        fcn.0042c9f1(arg_8h, arg_ch, 0);\n        piVar3 = fcn.0042d1c2(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        var_4h = piVar3[1];\n        var_8h = iVar4;\n        fcn.0042c9f1(arg_8h, arg_ch, 0x7fff);\n        piVar3 = fcn.0042d1c2(&var_18h, arg_8h, arg_ch);\n        iVar1 = *piVar3;\n        var_ch = piVar3[1];\n        var_10h = iVar1;\n        if (iVar4 < iVar1) {\n            do {\n                fcn.0042c9f1(arg_8h, arg_ch, (iVar1 + iVar4) / 2);\n                piVar3 = fcn.0042d1c2(&var_18h, arg_8h, arg_ch);\n                iVar4 = piVar3[1];\n                if (arg_10h < iVar4) {\n                    iVar4 = fcn.00437c86(*piVar3, iVar4);\n                    if (iVar4 != 0) goto code_r0x0042d46c;\n                    var_8h = *piVar3;\n                    var_4h = piVar3[1];\n                }\n                else {\n                    if (arg_10h <= iVar4) {\n                        return;\n                    }\n                    iVar4 = fcn.00437c86(*piVar3, iVar4);\n                    iVar1 = var_8h;\n                    if (iVar4 != 0) goto code_r0x0042d46c;\n                    iVar1 = *piVar3;\n                    var_ch = piVar3[1];\n                    var_10h = iVar1;\n                }\n                iVar4 = var_8h;\n            } while (var_8h < iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 879
    },
    "0042d5f2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d5f2(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0042e4ea(&var_10h, (*(in_ECX + 0x84) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    if (*0x49776c < 0x40047) {\n        arg_ch[1] = arg_ch[1] + -2;\n    }\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 227
    },
    "0042fd2a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042fd2a(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.004320da(arg_8h);\n    if (((iVar1 == 0) && ((*(in_ECX + 0x108) == 0 || (iVar1 = fcn.004320da(arg_8h),  iVar1 == 0)))) &&\n       ((*(in_ECX + 0x10c) == 0 || (iVar1 = fcn.004320da(arg_8h),  iVar1 == 0)))) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.0043216f(arg_8h);\n    }\n    return uVar2;\n}\n",
        "token_count": 183
    },
    "0042febf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042febf(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    \n    iVar1 = fcn.0041ff5e();\n    in_ECX[1] = iVar1;\n    in_ECX[2] = *(iVar1 + 0xf0);\n    *in_ECX = *(iVar1 + 0xec);\n    *(iVar1 + 0xec) = arg_8h;\n    *(in_ECX[1] + 0xf0) = in_ECX;\n    return;\n}\n",
        "token_count": 126
    },
    "00430114": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430114(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = (**(*in_ECX + 0x144))();\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_CopyRect)(&var_10h, arg_ch);\n        arg_8h = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n        fcn.0041af14(arg_8h);\n        fcn.004172e2(&var_10h);\n        fcn.004172a1(&var_10h);\n        piVar2 = fcn.00417f55(0xe900);\n        var_20h = in_ECX[0x4c];\n        var_1ch = in_ECX[0x4d];\n        var_18h = in_ECX[0x4e];\n        var_14h = in_ECX[0x4f];\n        (**(*piVar2 + 0x68))(&var_20h, 1);\n        var_10h = var_10h + (in_ECX[0x4c] - var_20h);\n        var_ch = var_ch + (in_ECX[0x4d] - var_1ch);\n        var_8h = var_8h + (in_ECX[0x4e] - var_18h);\n        var_4h = var_4h + (in_ECX[0x4f] - var_14h);\n        (**(*in_ECX + 0x1b0))(&var_10h);\n    }\n    return 0;\n}\n",
        "token_count": 463
    },
    "004301f4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004301f4(int32_t *param_1)\n\n{\n    uint arg_8h;\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint lprcDst;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcSrc1;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h = (*_sym.imp.USER32.dll_GetParent)(param_1[8]);\n    var_8h = fcn.0041af14(arg_8h);\n    var_4h = 0;\n    iVar1 = (**(*param_1 + 0x144))();\n    if ((iVar1 != 0) && (*(iVar1 + 0xd4) != 0)) {\n        var_4h = 1;\n    }\n    var_20h = 0x3fffffff;\n    var_1ch = 0x3fffffff;\n    var_28h = 0;\n    var_24h = 0;\n    fcn.0041b2fb(0, 0xffff, 0xe900, 1, &var_38h, &var_28h, 1);\n    lprcSrc1 = param_1[0x4c] - var_38h;\n    var_14h = param_1[0x4d] - var_34h;\n    var_10h = param_1[0x4e] + (0x3fffffff - var_30h);\n    var_ch = param_1[0x4f] + (0x3fffffff - var_2ch);\n    piVar2 = fcn.00417f55(0xe900);\n    if (piVar2 != NULL) {\n        var_28h = param_1[0x4c];\n        var_24h = param_1[0x4d];\n        var_20h = param_1[0x4e];\n        var_1ch = param_1[0x4f];\n        (**(*piVar2 + 0x68))(&var_28h, 1);\n        lprcSrc1 = lprcSrc1 + (var_28h - param_1[0x4c]);\n        var_14h = var_14h + (var_24h - param_1[0x4d]);\n        var_10h = var_10h + (var_20h - param_1[0x4e]);\n        var_ch = var_ch + (var_1ch - param_1[0x4f]);\n    }\n    (**(*param_1 + 0x68))(&lprcSrc1, var_4h);\n    (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, param_1 + 0x50);\n    fcn.00418f77(0, param_1[8], &lprcDst);\n    fcn.004172e2(&lprcSrc1);\n    fcn.004172a1(&lprcSrc1);\n    fcn.0041b2fb(0, 0xffff, 0xe900, 0, 0, &lprcSrc1, 1);\n    return;\n}\n",
        "token_count": 812
    },
    "004303a7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004303a7(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.004320da(*(arg_8h + 4));\n    if (((iVar1 == 0) && ((*(in_ECX + 0x108) == 0 || (iVar1 = fcn.004320da(*(arg_8h + 4)),  iVar1 == 0)))) &&\n       ((*(in_ECX + 0x10c) == 0 || (iVar1 = fcn.004320da(*(arg_8h + 4)),  iVar1 == 0)))) {\n        *(arg_8h + 0x1c) = 1;\n    }\n    else {\n        fcn.0043212c(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 192
    },
    "00430e3c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430e3c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00458da4(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 88
    },
    "00431215": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00431215(uint noname_0, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_ch == 0) {\n        iVar1 = fcn.0041943a();\n        if (iVar1 == 0) {\n            arg_ch = *(in_ECX + 0xa4) + 0x20000;\n        }\n        else {\n            arg_ch = *(in_ECX + 0xa8) + 0x10000;\n        }\n        if (arg_ch == 0) {\n            return 0;\n        }\n    }\n    iVar1 = fcn.0042052a();\n    if (*(iVar1 + 4) != NULL) {\n        (**(**(iVar1 + 4) + 0xac))(arg_ch, 1);\n    }\n    return 1;\n}\n",
        "token_count": 193
    },
    "00432b5f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432b5f(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    \n    iVar2 = arg_8h;\n    if ((arg_8h == 0) || ((*(in_ECX + 0xf) & 4) == 0)) {\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n        iVar3 = fcn.0041af14(arg_8h_00);\n        if (iVar3 != 0) {\n            arg_8h = 0;\n            (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(*(iVar3 + 0x20), &arg_8h);\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n            if (iVar3 == arg_8h) {\n                return;\n            }\n        }\n        pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n        if (iVar2 == 0) {\n            if (in_ECX[0x2e] == 0) {\n                in_ECX[0xf] = in_ECX[0xf] | 0x80;\n                (**(*in_ECX + 0x100))();\n            }\n        }\n        else {\n            if (in_ECX[0xf] < '\\0') {\n                in_ECX[0xf] = in_ECX[0xf] & 0xffffff7f;\n                (**(*in_ECX + 0x104))();\n                arg_8h = in_ECX[8];\n                iVar3 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                if (iVar3 == arg_8h) {\n                    (*pcVar1)(arg_8h, 6, 1, 0);\n                }\n            }\n            if ((*(in_ECX + 0xf) & 0x20) != 0) {\n                (*pcVar1)(in_ECX[8], 0x86, 1, 0);\n            }\n        }\n        fcn.004312f4((-(iVar2 != 0) & 0xfffffff0) + 0x20);\n    }\n    else {\n        fcn.004181a2(0);\n        (*_sym.imp.USER32.dll_SetFocus)(0);\n    }\n    return;\n}\n",
        "token_count": 539
    },
    "00432cf3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00432cf3(uint param_1)\n\n{\n    fcn.0042052a();\n    fcn.0042001a();\n    fcn.0044a351(param_1);\n    return;\n}\n",
        "token_count": 51
    },
    "00432d12": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00432d12(uint param_1)\n\n{\n    fcn.0042052a();\n    fcn.0042001a();\n    fcn.0044a36f(param_1);\n    return;\n}\n",
        "token_count": 52
    },
    "00433b03": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00433b03(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_34h;\n    uint var_30h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x28);\n    iVar1 = *(unaff_EBP + 8);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.00418009();\n    if ((uVar2 & 0x4000) == 0) {\n        fcn.00404480(*(extraout_ECX + 0xc4), *(*(extraout_ECX + 0xc4) + -0xc));\n        if (iVar1 != 0) {\n            fcn.004061b0(0x47de50);\n            fcn.004061b0(iVar1);\n            if (0 < *(extraout_ECX + 0x58)) {\n                fcn.00458b9a(unaff_EBP + -0x30, 0x20, 0x47de54, *(extraout_ECX + 0x58));\n                fcn.004061b0(unaff_EBP + -0x30);\n            }\n        }\n    }\n    else {\n        if (iVar1 != 0) {\n            fcn.004061b0(iVar1);\n            if (0 < *(extraout_ECX + 0x58)) {\n                fcn.00458b9a(unaff_EBP + -0x30, 0x20, 0x47de54, *(extraout_ECX + 0x58));\n                fcn.004061b0(unaff_EBP + -0x30);\n            }\n            fcn.004061b0(0x47de50);\n        }\n        fcn.00404480(*(extraout_ECX + 0xc4), *(*(extraout_ECX + 0xc4) + -0xc));\n    }\n    fcn.0044af85(*(extraout_ECX + 0x20), *(unaff_EBP + -0x34));\n    fcn.004010f0();\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 533
    },
    "00433f5e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433f5e(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    uint var_ch;\n    \n    *(arg_8h + 0x10) = 1;\n    *(arg_8h + 8) = *(in_ECX + 0x98);\n    if (*(in_ECX + 0x98) != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x20), &lpRect);\n        *(arg_8h + 0x14) = lpRect;\n        *(arg_8h + 0x18) = var_ch;\n    }\n    *(arg_8h + 0xc) = (*(in_ECX + 0x84) & 0xa000) != 0;\n    arg_8h = 0;\n    if (0 < *(in_ECX + 0xa4)) {\n        do {\n            puVar1 = fcn.00404ff0(arg_8h);\n            uVar2 = *puVar1;\n            if (uVar2 == 0) {\n                uVar2 = 0;\n            }\n            else if (uVar2 < 0x10000) {\n                uVar2 = uVar2 & 0xffff | 0x10000;\n            }\n            else {\n                uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(uVar2 + 0x20));\n            }\n            fcn.00422046(uVar2);\n            arg_8h = arg_8h + 1;\n        } while (arg_8h < *(in_ECX + 0xa4));\n    }\n    return;\n}\n",
        "token_count": 397
    },
    "00434729": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434729(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_ch;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = (**(*in_ECX + 0x170))();\n    if (iVar1 == 0) {\n        arg_ch = 0x15;\n        if (in_ECX[0x24] == 0) {\n            arg_ch = 0x17;\n        }\n        in_ECX[0x1c] = *(arg_8h + 0x1c);\n        (**(*in_ECX + 0x140))(&var_ch, 0, 0x46);\n        if (*(arg_8h + 0x20) != 0) {\n            *(in_ECX[0x25] + 0x90) = *(arg_8h + 0x24);\n            iVar1 = in_ECX[0x25];\n            *(iVar1 + 0x94) = *(arg_8h + 0x28);\n            *(iVar1 + 0x98) = *(arg_8h + 0x2c);\n            *(iVar1 + 0x9c) = *(arg_8h + 0x30);\n            *(iVar1 + 0xa0) = *(arg_8h + 0x34);\n            *(var_4h[0x25] + 0xa4) = *(arg_8h + 0x38);\n            iVar1 = var_4h[0x25];\n            *(iVar1 + 0xa8) = *(arg_8h + 0x3c);\n            *(iVar1 + 0xac) = *(arg_8h + 0x40);\n        }\n        fcn.0041822e(0, *(arg_8h + 0x14), *(arg_8h + 0x18), 0, 0, (-(*(arg_8h + 4) != 0) & 0xffffffc0) + 0x80 | arg_ch);\n    }\n    else {\n        fcn.00434502(arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 507
    },
    "00435348": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435348(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint *unaff_ESI;\n    uint *arg_ch_00;\n    uint var_4h;\n    \n    iVar2 = 0;\n    arg_ch_00 = unaff_ESI;\n    if (arg_8h != 0) goto code_r0x0043535e;\n    while( true ) {\n        fcn.0041638e();\n        arg_ch_00 = unaff_ESI;\ncode_r0x0043535e:\n        if (arg_ch != iVar2) break;\n        unaff_ESI = 0x47df98;\n        do {\n            iVar1 = fcn.004320da(*unaff_ESI);\n            if (iVar1 != 0) {\n                arg_8h_00 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x20), 0xffffffff);\n                iVar1 = fcn.00435a01(arg_8h_00, arg_ch_00);\n                if (0 < iVar1) goto code_r0x004353c8;\n            }\n            if (((unaff_ESI[1] ^ *(arg_8h + 0x84)) & 0xf000) == 0) {\n                iVar2 = fcn.004320da(*unaff_ESI);\n            }\n            unaff_ESI = unaff_ESI + 2;\n        } while (unaff_ESI < 0x47dfb8);\n        if (iVar2 != 0) break;\n    }\ncode_r0x004353c8:\n    fcn.00436844(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 408
    },
    "00435935": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435935(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    (**(*in_ECX + 0x148))(&var_10h, in_ECX[0x21] & 0xa000);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 188
    },
    "00435984": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00435984(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint var_10h;\n    \n    if (arg_8h == 0) {\n        fcn.0041638e();\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &var_10h);\n    if (*(in_ECX + 0x7c) != 0) {\n        iVar1 = fcn.0044f654(*(in_ECX + 0x7c), 6, 0);\n        if (iVar1 != 0) {\n            fcn.0044f6a3(*(in_ECX + 0x20), *(arg_8h + 4), &var_10h);\n        }\n        iVar1 = fcn.0044f5a1(*(in_ECX + 0x7c), *(arg_8h + 4), 6, 0, &var_10h, 0);\n        if (-1 < iVar1) {\n            return 1;\n        }\n    }\n    uVar2 = fcn.0041ae6e();\n    return uVar2;\n}\n",
        "token_count": 278
    },
    "00435a42": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00435a42(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = fcn.00420885(arg_8h);\n    return -(0xffff < uVar1) & uVar1;\n}\n",
        "token_count": 61
    },
    "00435a66": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.00435a66(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint noname_3, uint noname_4, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    int32_t arg_8h_00;\n    bool bVar4;\n    bool bVar5;\n    int32_t lpRect;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = 0;\n    if (in_ECX != 0) goto code_r0x00435a7e;\n    do {\n        iVar1 = fcn.0041638e();\ncode_r0x00435a7e:\n    } while (arg_8h == iVar1);\n    uVar3 = *(in_ECX + 0x84) & 0xa000;\n    var_10h = iVar1;\n    var_ch = iVar1;\n    var_8h = iVar1;\n    var_4h = iVar1;\n    if (*(in_ECX + 0xa4) != iVar1 && iVar1 <= *(in_ECX + 0xa4)) {\n        do {\n            piVar2 = fcn.00435a42(var_4h);\n            if (piVar2 == NULL) {\n                iVar1 = var_8h - *0x49be54;\n                var_8h = 0;\n                var_10h = var_10h + iVar1;\n                iVar1 = arg_20h;\n                if (uVar3 == 0) {\n                    iVar1 = arg_1ch;\n                }\n                if (iVar1 < var_10h) {\n                    if (var_4h == 0) {\n                        fcn.0042c207(var_ch + 1, var_ch + 1, 1);\n                    }\n                    arg_8h_00 = var_ch + 1;\n                    goto code_r0x00435b7e;\n                }\ncode_r0x00435b4d:\n                var_ch = var_4h;\n            }\n            else {\n                iVar1 = (**(*piVar2 + 0x168))();\n                if (iVar1 != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(piVar2[8], &lpRect);\n                    fcn.004172a1(&lpRect);\n                    if (uVar3 == 0) {\n                        iVar1 = (var_18h - lpRect) + -1;\n                    }\n                    else {\n                        iVar1 = var_14h - var_1ch;\n                    }\n                    if (var_8h <= iVar1) {\n                        if (uVar3 == 0) {\n                            var_8h = (var_18h - lpRect) + -1;\n                        }\n                        else {\n                            var_8h = var_14h - var_1ch;\n                        }\n                    }\n                    if (uVar3 == 0) {\n                        bVar5 = SBORROW4(arg_10h, var_1ch);\n                        iVar1 = arg_10h - var_1ch;\n                        bVar4 = arg_10h == var_1ch;\n                    }\n                    else {\n                        bVar5 = SBORROW4(arg_ch, lpRect);\n                        iVar1 = arg_ch - lpRect;\n                        bVar4 = arg_ch == lpRect;\n                    }\n                    if (!bVar4 && bVar5 == iVar1 < 0) goto code_r0x00435b4d;\n                }\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < *(in_ECX + 0xa4));\n        iVar1 = 0;\n    }\n    arg_8h_00 = var_ch + 1;\n    fcn.0042c207(arg_8h_00, iVar1, 1);\ncode_r0x00435b7e:\n    fcn.0042c207(arg_8h_00, arg_8h, 1);\n    return arg_8h_00;\n}\n",
        "token_count": 971
    },
    "00435cf8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00435cf8(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t arg_8h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockBar.0;\n    arg_8h = 0;\n    pcVar1 = extraout_ECX[0x29];\n    *(unaff_EBP + -4) = 1;\n    if (0 < pcVar1) {\n        do {\n            iVar2 = fcn.00435a42(arg_8h);\n            if ((iVar2 != 0) && (*(iVar2 + 0x90) == extraout_ECX)) {\n                *(iVar2 + 0x90) = 0;\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h < extraout_ECX[0x29]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042c1f7();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042e5ae();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 317
    },
    "00436d09": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00436d09(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    \n    iVar1 = *(in_ECX + 0x74);\n    if (0 < iVar1) {\n        piVar3 = *(in_ECX + 0x78);\n        iVar2 = 0;\n        if (0 < iVar1) {\n            do {\n                if (*piVar3 == arg_8h) {\n                    return iVar2;\n                }\n                iVar2 = iVar2 + 1;\n                piVar3 = piVar3 + 5;\n            } while (iVar2 < iVar1);\n        }\n    }\n    return -1;\n}\n",
        "token_count": 173
    },
    "00436f1b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00436f1b(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0042e4ea(&var_10h, 1);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 170
    },
    "00436fd5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00436fd5(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t unaff_EDI;\n    \n    iVar2 = arg_8h;\n    iVar4 = unaff_EDI;\n    if (-1 < arg_8h) goto code_r0x00436fea;\n    do {\n        fcn.0041638e();\n        iVar4 = unaff_EDI;\ncode_r0x00436fea:\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (iVar2 == 0) {\n            if (*(in_ECX + 4) != 0) {\n                fcn.00414b30(*(in_ECX + 4));\n                *(in_ECX + 4) = 0;\n            }\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            return;\n        }\n        if (*(in_ECX + 4) == 0) {\n            iVar4 = *(in_ECX + 0x10);\n            if (*(in_ECX + 0x10) < iVar2) {\n                iVar4 = iVar2;\n            }\n            uVar3 = fcn.00414af6(iVar4 << 2);\n            *(in_ECX + 4) = uVar3;\n            fcn.00458b20(uVar3, 0, iVar4 << 2);\n            *(in_ECX + 0xc) = iVar4;\n            goto code_r0x00437106;\n        }\n        unaff_EDI = *(in_ECX + 0xc);\n        if (iVar2 <= unaff_EDI) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < iVar2) {\n                fcn.00458b20(*(in_ECX + 4) + iVar1 * 4, 0, (iVar2 - iVar1) * 4, iVar4);\n            }\n            goto code_r0x00437106;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar4 < 4) {\n                iVar4 = 4;\n            }\n            else if (0x400 < iVar4) {\n                iVar4 = 0x400;\n            }\n        }\n        arg_8h = iVar4 + unaff_EDI;\n        if (iVar4 + unaff_EDI <= iVar2) {\n            arg_8h = iVar2;\n        }\n    } while (arg_8h < unaff_EDI);\n    iVar4 = fcn.00414af6(arg_8h << 2);\n    fcn.00414fcb(iVar4, arg_8h << 2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.00458b20(iVar4 + *(in_ECX + 8) * 4, 0, (iVar2 - *(in_ECX + 8)) * 4);\n    fcn.00414b30(*(in_ECX + 4));\n    *(in_ECX + 4) = iVar4;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00437106:\n    *(in_ECX + 8) = iVar2;\n    return;\n}\n",
        "token_count": 819
    },
    "004371ce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004371ce(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (arg_8h == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar1 = fcn.00436d09(0);\n        if (-1 < iVar1) {\n            iVar1 = *(iVar1 * 0x14 + *(in_ECX + 0x78) + 0x10);\n            iVar2 = *(iVar1 + -0xc);\n            if (arg_8h < iVar2) {\n                iVar2 = arg_8h + -1;\n            }\n            fcn.00414fcb(arg_ch, arg_8h, iVar1, iVar2);\n        }\n        *(iVar2 + arg_ch) = 0;\n        iVar2 = iVar2 + 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 225
    },
    "00437289": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00437289(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(in_ECX + 0x74)) {\n        do {\n            fcn.00416627(0);\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(in_ECX + 0x74));\n    }\n    iVar2 = fcn.0042e1b0(arg_8h, arg_ch);\n    if (iVar2 != 0) {\n        iVar2 = 0;\n        if (0 < *(in_ECX + 0x74)) {\n            iVar1 = *(in_ECX + 0x78) + 0x10;\n            do {\n                if (iVar1 != 0) {\n                    fcn.00401e60();\n                }\n                iVar1 = iVar1 + 0x14;\n                iVar2 = iVar2 + 1;\n            } while (iVar2 < *(in_ECX + 0x74));\n        }\n        iVar2 = 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 265
    },
    "004375a3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004375a3(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = arg_8h * 0x14 + *(in_ECX + 0x78);\n    if (*(iVar1 + 8) != arg_ch) {\n        if (((*(iVar1 + 8) ^ arg_ch) & 0x8000000) != 0) {\n            *(iVar1 + 8) = arg_ch;\n            fcn.00437438(1, 0);\n        }\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) | 1;\n        *(iVar1 + 8) = arg_ch;\n        fcn.00437343(arg_8h, *(iVar1 + 0x10), 1);\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "00437955": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00437955(uint32_t arg_8h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t extraout_ECX;\n    \n    iVar2 = in_ECX[0x22];\n    if (iVar2 != 0) goto code_r0x0043796d;\n    do {\n        fcn.0041638e();\n        iVar2 = extraout_ECX;\ncode_r0x0043796d:\n    } while ((arg_8h < 0xe110) || (*(iVar2 + 4) + 0xe110U <= arg_8h));\n    puVar1 = fcn.004378ee(arg_8h - 0xe110);\n    iVar2 = (**(*in_ECX + 0x88))(*puVar1);\n    if (iVar2 == 0) {\n        (***in_ECX[0x22])(arg_8h - 0xe110);\n    }\n    return 1;\n}\n",
        "token_count": 227
    },
    "00437aab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00437aab(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0x20) = 0;\n    *(param_1 + 0x24) = 0;\n    *(param_1 + 0x2c) = 0;\n    *(param_1 + 0x30) = 0;\n    iVar1 = fcn.0041ff5e();\n    *(iVar1 + 0x34) = 0;\n    *(iVar1 + 0x54) = 0;\n    (*_sym.imp.USER32.dll_GetCursorPos)(iVar1 + 0x4c);\n    *(param_1 + 0x40) = 0;\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x28) = 1;\n    return;\n}\n",
        "token_count": 199
    },
    "00437bd7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00437bd7(int32_t arg_8h)\n\n{\n    code **ppcVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t *in_ECX;\n    uint arg_14h;\n    uint var_4h;\n    \n    ppcVar1 = (**(*in_ECX + 0x28))();\n    pcVar3 = *ppcVar1;\n    do {\n        if (pcVar3 == NULL) {\n            return 0;\n        }\n        arg_14h = 0;\n        if (*(arg_8h + 4) < 0xc000) {\n            iVar2 = fcn.00418e3e(ppcVar1[1], *(arg_8h + 4), 0, 0);\n            if (iVar2 != 0) {\ncode_r0x00437c11:\n                (**(iVar2 + 0x14))(*(arg_8h + 8), *(arg_8h + 0xc));\n                return 1;\n            }\n        }\n        else {\n            pcVar3 = ppcVar1[1];\n            while (iVar2 = fcn.00418e3e(pcVar3, 0xc000, 0, arg_14h),  iVar2 != 0) {\n                if (**(iVar2 + 0x10) == *(arg_8h + 4)) goto code_r0x00437c11;\n                pcVar3 = iVar2 + 0x18;\n            }\n        }\n        ppcVar1 = (**ppcVar1)();\n        pcVar3 = *ppcVar1;\n    } while( true );\n}\n",
        "token_count": 367
    },
    "0043833c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043833c(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    code *pcVar2;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t hHandle;\n    int32_t hEvent;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x2c) != 0) {\n        fcn.0041638e();\n    }\n    fcn.00458b20(&var_1ch, 0, 0x1c);\n    var_1ch = fcn.0041ff5e();\n    pcVar2 = _sym.imp.KERNEL32.dll_CreateEventA;\n    hHandle = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 1, 0, 0);\n    hEvent = (*pcVar2)(0, 1, 0, 0);\n    pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n    var_14h = arg_8h;\n    if (hHandle != 0) {\n        if (hEvent != 0) {\n            iVar1 = fcn.0045d5a0(arg_10h, arg_ch, 0x438220, &var_1ch, arg_8h | 4, in_ECX + 0x30);\n            *(in_ECX + 0x2c) = iVar1;\n            if (iVar1 == 0) {\n                (*pcVar2)(hHandle);\n                (*pcVar2)(hEvent);\n                return 0;\n            }\n            (*_sym.imp.KERNEL32.dll_ResumeThread)(iVar1);\n            (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(hHandle, 0xffffffff);\n            pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hHandle);\n            if ((arg_8h & 4) != 0) {\n                (*_sym.imp.KERNEL32.dll_SuspendThread)(*(in_ECX + 0x2c));\n            }\n            if (var_4h == 0) {\n                (*_sym.imp.KERNEL32.dll_SetEvent)(hEvent);\n                return 1;\n            }\n            (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(in_ECX + 0x2c), 0xffffffff);\n            (*pcVar2)(*(in_ECX + 0x2c));\n            *(in_ECX + 0x2c) = 0;\n            goto code_r0x00438439;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hHandle);\n    }\n    if (hEvent == 0) {\n        return 0;\n    }\ncode_r0x00438439:\n    (*pcVar2)(hEvent);\n    return 0;\n}\n",
        "token_count": 652
    },
    "004384be": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004384be(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (0x10b < arg_8h) {\n        if (arg_8h == 0x3e3) {\n            return 10;\n        }\n        if (arg_8h == 0x3e4) {\n            return 10;\n        }\n        if (arg_8h == 0x3e5) {\n            return 10;\n        }\n        if (arg_8h != 999) {\n            return 1;\n        }\n        return 5;\n    }\n    if (arg_8h == 0x10b) {\n        return 3;\n    }\n    if (arg_8h < 0x3f) {\n        if (arg_8h == 0x3e) {\n            return 8;\n        }\n        if (arg_8h < 0x1a) {\n            if (arg_8h == 0x19) {\n                return 9;\n            }\n            if (arg_8h < 0x19) {\n    // switch table (25 cases) at 0x4386ce\n                switch(*(arg_8h * 4 + 0x4386ce)) {\n                case 0x4384ff:\n                    return 0;\n                case 0x438506:\n                    return 2;\n                case 0x43850d:\n                    return 4;\n                case 0x438514:\n                    return 7;\n                case 0x438544:\n                    return 9;\n                case 0x4385ca:\n                    return 3;\n                case 0x4385f3:\n                    return 10;\n                case 0x43862f:\n                    return 6;\n                case 0x438682:\n                    return 5;\n                case 0x4386c4:\n                    return 1;\n                }\n            }\n            return 1;\n        }\n        if (0x27 < arg_8h) {\n            if (8 < arg_8h - 0x34) {\n                return 1;\n            }\n    // switch table (9 cases) at 0x438732\n            switch(*((arg_8h - 0x34) * 4 + 0x438732)) {\n            case 0x4385ca:\n                return 3;\n            case 0x4385f3:\n                return 10;\n            case 0x43862f:\n                return 6;\n            case 0x438682:\n                return 5;\n            case 0x4386c4:\n                return 1;\n            }\n        }\n        if (arg_8h == 0x27) {\n            return 0xd;\n        }\n        if (0x20 < arg_8h) {\n            if (arg_8h == 0x21) {\n                return 0xc;\n            }\n            if (arg_8h == 0x22) {\n                return 3;\n            }\n            if (arg_8h == 0x24) {\n                return 4;\n            }\n            if (arg_8h != 0x26) {\n                return 1;\n            }\n            return 0xe;\n        }\n        if (arg_8h == 0x20) {\n            return 0xb;\n        }\n        if (arg_8h == 0x1a) {\n            return 6;\n        }\n        if (arg_8h == 0x1b) {\n            return 9;\n        }\n        iVar1 = arg_8h - 0x1d;\n        if (iVar1 == 0) {\n            return 5;\n        }\ncode_r0x0043853d:\n        if (iVar1 == 1) {\n            return 9;\n        }\n    }\n    else {\n        if (arg_8h < 0x6c) {\n            if (arg_8h == 0x6b) {\n                return 2;\n            }\n            if (0x47 < arg_8h) {\n                if (arg_8h == 0x50) {\n                    return 5;\n                }\n                if (arg_8h == 0x52) {\n                    return 5;\n                }\n                if (arg_8h == 0x55) {\n                    return 3;\n                }\n                if (arg_8h == 0x56) {\n                    return 5;\n                }\n                if (arg_8h != 0x58) {\n                    return 1;\n                }\n                return 10;\n            }\n            if (arg_8h == 0x47) {\n                return 5;\n            }\n            if (arg_8h == 0x40) {\n                return 5;\n            }\n            if (arg_8h == 0x41) {\n                return 5;\n            }\n            if (arg_8h == 0x42) {\n                return 6;\n            }\n            if (arg_8h == 0x43) {\n                return 3;\n            }\n            iVar1 = arg_8h - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\n        }\n        else {\n            if (arg_8h < 0x91) {\n                if (arg_8h == 0x90) {\n                    return 3;\n                }\n                if (arg_8h < 0x76) {\n                    if (arg_8h == 0x75) {\n                        return 10;\n                    }\n                    if (arg_8h == 0x6c) {\n                        return 0xc;\n                    }\n                    if (arg_8h == 0x6f) {\n                        return 3;\n                    }\n                    if (arg_8h != 0x70) {\n                        if (arg_8h == 0x71) {\n                            return 4;\n                        }\n                        if (arg_8h == 0x72) {\n                            return 6;\n                        }\n                        return 1;\n                    }\n                    return 0xd;\n                }\n                if (arg_8h == 0x7b) {\n                    return 3;\n                }\n                if (arg_8h == 0x7c) {\n                    return 3;\n                }\n                if (arg_8h == 0x7d) {\n                    return 3;\n                }\n                iVar1 = arg_8h - 0x83;\n                if (iVar1 == 0) {\n                    return 9;\n                }\n                goto code_r0x0043853d;\n            }\n            if (arg_8h < 0xb7) {\n                if (arg_8h == 0xb6) {\n                    return 6;\n                }\n                if (arg_8h == 0x91) {\n                    return 7;\n                }\n                if (arg_8h == 0x9a) {\n                    return 3;\n                }\n                if (arg_8h == 0xa1) {\n                    return 3;\n                }\n                if (arg_8h == 0xa7) {\n                    return 0xc;\n                }\n                if (arg_8h != 0xaa) {\n                    return 1;\n                }\n                return 5;\n            }\n            if (arg_8h == 0xb7) {\n                return 5;\n            }\n            if (arg_8h == 0xbf) {\n                return 6;\n            }\n            if (arg_8h == 0xc1) {\n                return 6;\n            }\n            iVar1 = arg_8h - 0xce;\n            if (iVar1 == 0) {\n                return 3;\n            }\n        }\n        if (iVar1 == 2) {\n            return 3;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 1703
    },
    "00439523": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439523(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    fcn.004585e6(*(in_ECX + 0x54));\n    uVar1 = fcn.0045d650(arg_8h);\n    *(in_ECX + 0x54) = uVar1;\n    fcn.004585e6(*(in_ECX + 0x68));\n    uVar1 = fcn.0045d650(*(in_ECX + 0x50));\n    *(in_ECX + 0x68) = uVar1;\n    return;\n}\n",
        "token_count": 143
    },
    "00439881": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00439881(uint arg_8h, uint arg_ch, uint arg_10h, uint *arg_14h)\n\n{\n    code *pcVar1;\n    int32_t extraout_ECX;\n    uint unaff_ESI;\n    int32_t *in_FS_OFFSET;\n    uint var_102ch;\n    int32_t hKey;\n    int32_t var_1024h;\n    uint var_1020h;\n    uint *lpDefault;\n    uint var_1018h;\n    uint var_1014h;\n    uint lpReturnedString;\n    uint uStackY92;\n    int32_t iStackY88;\n    uint uStackY84;\n    uint uStackY80;\n    uint *puStackY76;\n    uint uStackY72;\n    uint *puStackY68;\n    int32_t iStackY64;\n    int32_t iStackY60;\n    uint uStackY56;\n    uint uStackY52;\n    uint *puStackY48;\n    uint *puStackY44;\n    uint *puStackY40;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4720b4;\n    var_ch = *in_FS_OFFSET;\n    fcn.0045a520();\n    *in_FS_OFFSET = &fcn.00439881::var_ch;\n    var_1018h = arg_8h;\n    lpDefault = arg_14h;\n    var_1024h = 0;\n    if (*(extraout_ECX + 0x54) == 0) {\n        if (arg_14h == NULL) {\n            lpDefault = 0x476744;\n        }\n        puStackY44 = &fcn.00439881::lpReturnedString;\n        puStackY40 = 0x1000;\n        puStackY48 = lpDefault;\n        uStackY52 = arg_10h;\n        uStackY56 = arg_ch;\n        iStackY60 = 0x4399ed;\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringA)();\n        puStackY40 = &fcn.00439881::lpReturnedString;\n    }\n    else {\n        puStackY40 = 0x4398e4;\n        hKey = fcn.004395ec(arg_ch);\n        if (hKey != 0) {\n            puStackY40 = 0x439904;\n            fcn.00401e60();\n            pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n            puStackY40 = &fcn.00439881::var_1020h;\n            puStackY44 = NULL;\n            puStackY48 = &fcn.00439881::var_102ch;\n            uStackY52 = 0;\n            uStackY56 = arg_10h;\n            iStackY60 = hKey;\n            var_4h = 0;\n            var_102ch = 0;\n            var_1020h = 0;\n            iStackY64 = 0x439932;\n            var_1024h = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)();\n            if (var_1024h == 0) {\n                iStackY64 = var_1020h;\n                puStackY68 = 0x43994d;\n                uStackY72 = fcn.00401eb0();\n                puStackY68 = &fcn.00439881::var_1020h;\n                puStackY76 = &fcn.00439881::var_102ch;\n                uStackY80 = 0;\n                uStackY84 = arg_10h;\n                iStackY88 = hKey;\n                uStackY92 = 0x439966;\n                var_1024h = (*pcVar1)();\n                iStackY60 = -1;\n                iStackY64 = 0x439979;\n                fcn.00409070();\n            }\n            iStackY64 = hKey;\n            puStackY68 = 0x439985;\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)();\n            if (var_1024h == 0) {\n                puStackY40 = &fcn.00439881::var_1014h;\n                puStackY44 = 0x43999f;\n                fcn.004041b0();\n            }\n            else {\n                puStackY40 = lpDefault;\n                puStackY44 = 0x4399c0;\n                fcn.00404920();\n            }\n            puStackY44 = 0x4399ad;\n            fcn.004010f0();\n            goto code_r0x004399fd;\n        }\n        puStackY40 = lpDefault;\n    }\n    puStackY44 = 0x4399fb;\n    fcn.00404920();\ncode_r0x004399fd:\n    *in_FS_OFFSET = var_ch;\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 1129
    },
    "0043a41d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043a41d(uint *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    piVar1 = fcn.00446a07(0x485100);\n    iVar2 = (**(*piVar1 + 0x20))(piVar1, 4, 3, &var_8h);\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ole32.dll_CreateStreamOnHGlobal)(0, 1, &var_4h);\n        if (iVar2 != 0) {\n            (**(*var_8h + 8))(var_8h);\n            fcn.00416356();\n        }\n        piVar1 = (*_sym.imp.ole32.dll_OleSaveToStream)(var_8h, var_4h);\n        (**(*var_8h + 8))(var_8h);\n        if (piVar1 == NULL) goto code_r0x0043a495;\n        (**(*var_4h + 8))(var_4h);\n        while( true ) {\n            fcn.00415123(piVar1);\ncode_r0x0043a495:\n            in_ECX = (*_sym.imp.ole32.dll_WriteClassStm)(var_4h, *(in_ECX[8] + 0x8c) + 0x28);\n            if (in_ECX == NULL) break;\n            (**(*var_4h + 8))(var_4h);\n            piVar1 = in_ECX;\n        }\n        arg_8h[2] = 0;\n        *arg_8h = 4;\n        arg_8h[1] = var_4h;\n        uVar3 = 1;\n    }\n    else {\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 469
    },
    "0043a4d9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043a4d9(uint *arg_8h, uint *arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint arg_14h;\n    uint arg_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = fcn.00446a07(0x485100);\n    arg_14h = 0;\n    arg_18h = 0;\n    if (arg_8h != NULL) {\n        var_14h = *arg_8h;\n        var_10h = arg_8h[1];\n        fcn.0044b322(&var_14h);\n        arg_14h = var_14h;\n        arg_18h = var_10h;\n    }\n    if (arg_ch == NULL) {\n        var_ch = 0;\n        var_8h = 0;\n    }\n    else {\n        var_ch = *arg_ch;\n        var_8h = arg_ch[1];\n        fcn.0044b322(&var_ch);\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(in_ECX + 4);\n    iVar1 = fcn.00415fce(var_4h, 0, 1, arg_14h, arg_18h, &var_ch);\n    (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(in_ECX + 4);\n    if (iVar1 == 0) {\n        fcn.00416356();\n    }\n    arg_10h[2] = 0;\n    arg_10h[1] = iVar1;\n    *arg_10h = 1;\n    return;\n}\n",
        "token_count": 404
    },
    "0043e05b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043e05b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    *(param_1 + 0xa0) = 0;\n    var_4h = 0;\n    var_8h = 0;\n    var_14h = 4;\n    var_ch = 0;\n    piVar2 = 0x497c14;\n    var_10h = param_1;\n    iVar1 = *0x497c14;\n    while (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, *piVar2, 0, 1, &var_4h);\n        if (iVar1 == 0) {\n            for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n                iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, *piVar3, 0, &var_ch, &var_8h, &var_14h);\n                if ((iVar1 == 0) && (var_ch == 4)) {\n                    if (var_8h == 0) {\n                        *(var_10h + 0xa0) = *(var_10h + 0xa0) & ~piVar3[1];\n                    }\n                    else {\n                        *(var_10h + 0xa0) = *(var_10h + 0xa0) | piVar3[1];\n                    }\n                }\n                var_8h = 0;\n                var_14h = 4;\n                var_ch = 0;\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n            var_4h = 0;\n        }\n        piVar2 = piVar2 + 2;\n        iVar1 = *piVar2;\n    }\n    return 1;\n}\n",
        "token_count": 498
    },
    "0043ecd8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043ecd8(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_21ch;\n    uint var_4h;\n    \n    fcn.0045afda(0x214);\n    *(unaff_EBP + -0x21c) = extraout_ECX;\n    *extraout_ECX = vtable.CWinApp.0;\n    piVar1 = extraout_ECX[0x16];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n    }\n    if (extraout_ECX[0x22] != NULL) {\n        (**(*extraout_ECX[0x22] + 0x18))(1);\n    }\n    iVar2 = fcn.0042052a();\n    if (*(iVar2 + 0x14) == '\\0') {\n        if (*0x49bdc0 != NULL) {\n            (**(**0x49bdc0 + 4))(1);\n            *0x49bdc0 = NULL;\n        }\n        if (*0x49bdbc != NULL) {\n            (**(**0x49bdbc + 4))(1);\n            *0x49bdbc = NULL;\n        }\n    }\n    if (extraout_ECX[0x1c] != NULL) {\n        fcn.0044b044(extraout_ECX[0x1c]);\n    }\n    if (extraout_ECX[0x1d] != NULL) {\n        fcn.0044b044(extraout_ECX[0x1d]);\n    }\n    if (*(extraout_ECX + 0x24) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(*(extraout_ECX + 0x24));\n    }\n    if (*(extraout_ECX + 0x92) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(*(extraout_ECX + 0x92));\n    }\n    if (extraout_ECX[0x23] != NULL) {\n        (**(*extraout_ECX[0x23] + 4))(1);\n    }\n    iVar2 = fcn.0042052a();\n    if (*(iVar2 + 0x10) == extraout_ECX[0x14]) {\n        *(iVar2 + 0x10) = 0;\n    }\n    if (*(iVar2 + 4) == extraout_ECX) {\n        *(iVar2 + 4) = 0;\n    }\n    fcn.004585e6(extraout_ECX[0x14]);\n    fcn.004585e6(extraout_ECX[0x15]);\n    fcn.004585e6(extraout_ECX[0x18]);\n    fcn.004585e6(extraout_ECX[0x19]);\n    fcn.004585e6(extraout_ECX[0x1a]);\n    extraout_ECX[0xb] = NULL;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00437ae4();\n    fcn.0045b036();\n    return;\n}\n",
        "token_count": 749
    },
    "0043fc9a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043fc9a(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h, int32_t arg_18h)\n\n{\n    int32_t arg_8h_00;\n    \n    arg_8h_00 = fcn.00401eb0(arg_10h + arg_18h);\n    fcn.0045850c(arg_8h_00, arg_10h, arg_ch, arg_10h);\n    fcn.0045850c(arg_8h_00 + arg_10h, arg_18h, arg_14h, arg_18h);\n    fcn.00401660(arg_10h + arg_18h);\n    return;\n}\n",
        "token_count": 166
    },
    "0043fd38": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043fd38(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    uint arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_10h;\n    int32_t arg_14h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    piVar1 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x10) = 0;\n    uVar2 = fcn.00404180();\n    fcn.0043fc83(uVar2);\n    arg_14h = *piVar1;\n    uVar2 = *(arg_14h + -0xc);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    arg_10h_00 = fcn.004016f0(*(unaff_EBP + 0xc));\n    fcn.0043fc9a(*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_10h_00, arg_14h, uVar2);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 323
    },
    "00441433": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: pv\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00441433(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint arg_8h_00;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint pv;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(8);\n    *(unaff_EBP + -0x14) = 0;\n    if (*(extraout_ECX + 0x78) == 1) {\n        if (*(extraout_ECX + 0x20) != 0) {\n            iVar1 = (**(**(extraout_ECX + 0x80) + 0x40))(*(extraout_ECX + 0x80), unaff_EBP + -0x14);\n            fcn.0041589a(*(unaff_EBP + -0x14));\n            *(unaff_EBP + -4) = 0;\n            if (-1 < iVar1) {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x14));\n            }\ncode_r0x00441487:\n            fcn.00409070(0xffffffff);\n            fcn.004041b0(unaff_EBP + -0x10);\n            fcn.004010f0();\n            goto code_r0x0044151b;\n        }\n    }\n    else if (((*(*(extraout_ECX + 0x74) + 0x34) & 0x80000) != 0) && (*(extraout_ECX + 0x20) != 0)) {\n        fcn.00401e60();\n        *(unaff_EBP + -4) = 1;\n        uVar2 = fcn.00401eb0(0x104);\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(*(extraout_ECX + 0x20));\n        iVar1 = fcn.0041af14(arg_8h_00);\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar1 + 0x20), 0x464, 0x104, uVar2);\n        if (-1 < iVar1) goto code_r0x00441487;\n        fcn.004018d0();\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004010f0();\n    }\n    fcn.00404920(*(*(extraout_ECX + 0x74) + 0x24));\ncode_r0x0044151b:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 634
    },
    "004416ca": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: lpWideCharStr\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid fcn.004416ca(void)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t *piVar7;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uchar *puVar8;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint lpWideCharStr;\n    uint var_4h;\n    \n    fcn.0045af3b(0x28);\n    if (*(extraout_ECX + 0x78) != 1) goto code_r0x00441a3c;\n    iVar3 = (**(**(extraout_ECX + 0x80) + 0x50))(*(extraout_ECX + 0x80), unaff_EBP + -0x28);\n    if (iVar3 < 0) {\n        if ((*(*(extraout_ECX + 0x74) + 0x34) & 0x200) != 0) {\n            puVar1 = *(extraout_ECX + 0x80);\n            *(unaff_EBP + -0x24) = 0;\n            iVar3 = (***puVar1)();\n            if (-1 < iVar3) {\n                *(unaff_EBP + -0x20) = 0;\n                iVar3 = (**(**(unaff_EBP + -0x24) + 0x6c))();\n                if (-1 < iVar3) {\n                    iVar3 = (**(**(unaff_EBP + -0x20) + 0x24))(*(unaff_EBP + -0x20), unaff_EBP + -0x1c);\n                    if (-1 < iVar3) {\n                        *(unaff_EBP + -0x2c) = 0;\n                        iVar3 = (**(**(unaff_EBP + -0x1c) + 0xc))\n                                          (*(unaff_EBP + -0x1c), 1, unaff_EBP + -0x18, unaff_EBP + -0x2c);\n                        if (iVar3 == 0) {\n                            fcn.004156cc();\n                            iVar3 = *(extraout_ECX + 0x74);\n                            *(unaff_EBP + -4) = 1;\n                            puVar8 = *(iVar3 + 0x1c);\n                            *(unaff_EBP + -0x10) = 0;\n                            iVar3 = (**(**(unaff_EBP + -0x18) + 0x14))\n                                              (*(unaff_EBP + -0x18), 0x80058000, unaff_EBP + -0x10);\n                            if (-1 < iVar3) {\n                                (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(*(unaff_EBP + -0x10));\n                                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                                  (0, 0, *(unaff_EBP + -0x10), 0xffffffff, puVar8, \n                                                   *(*(extraout_ECX + 0x74) + 0x20) + -1, 0, 0);\n                                puVar8 = puVar8 + iVar3;\n                                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x10));\n                            }\n                            do {\n                                *(unaff_EBP + -0x10) = 0;\n                                iVar3 = (**(**(unaff_EBP + -0x18) + 0x14))\n                                                  (*(unaff_EBP + -0x18), 0x80058000, unaff_EBP + -0x10);\n                                if (-1 < iVar3) {\n                                    fcn.00440885(*(unaff_EBP + -0x10));\n                                    uVar4 = fcn.00440848();\n                                    (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(uVar4);\n                                    fcn.00440740(0xffffffff);\n                                    iVar3 = *(*(unaff_EBP + -0x14) + -0xc);\n                                    if (*(*(unaff_EBP + -0x10) + iVar3 * 2) == 0x5c) {\n                                        iVar3 = iVar3 + 1;\n                                    }\n                                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                                      (0, 0, *(unaff_EBP + -0x10) + iVar3 * 2, 0xffffffff, puVar8, \n                                                       ((*(*(extraout_ECX + 0x74) + 0x20) +\n                                                        *(*(extraout_ECX + 0x74) + 0x1c)) - puVar8) + -1, 0, 0);\n                                    puVar8 = puVar8 + iVar3;\n                                    (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x10));\n                                }\n                                (**(**(unaff_EBP + -0x18) + 8))(*(unaff_EBP + -0x18));\n                                if (*(*(extraout_ECX + 0x74) + 0x20) + -1 + *(*(extraout_ECX + 0x74) + 0x1c) <= puVar8)\n                                break;\n                                iVar3 = (**(**(unaff_EBP + -0x1c) + 0xc))\n                                                  (*(unaff_EBP + -0x1c), 1, unaff_EBP + -0x18, unaff_EBP + -0x2c);\n                            } while (iVar3 == 0);\n                            if (puVar8 < *(*(extraout_ECX + 0x74) + 0x20) + -1 + *(*(extraout_ECX + 0x74) + 0x1c)) {\n                                *puVar8 = 0;\n                            }\n                            else {\n                                *(*(*(extraout_ECX + 0x74) + 0x20) + -2 + *(*(extraout_ECX + 0x74) + 0x1c)) = 0;\n                                *(*(*(extraout_ECX + 0x74) + 0x20) + -1 + *(*(extraout_ECX + 0x74) + 0x1c)) = 0;\n                            }\n                            *(unaff_EBP + -4) = 0xffffffff;\n                            fcn.004010f0();\n                        }\n                        (**(**(unaff_EBP + -0x1c) + 8))(*(unaff_EBP + -0x1c));\n                    }\n                    (**(**(unaff_EBP + -0x20) + 8))(*(unaff_EBP + -0x20));\n                }\n                piVar6 = *(unaff_EBP + -0x24);\n                goto code_r0x004419a2;\n            }\n        }\n    }\n    else {\n        *(unaff_EBP + -0x10) = 0;\n        iVar3 = (**(**(unaff_EBP + -0x28) + 0x14))();\n        if (-1 < iVar3) {\n            fcn.00441686(*(unaff_EBP + -0x10));\n            *(unaff_EBP + -4) = 0;\n            uVar4 = fcn.00440848();\n            (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(uVar4);\n            fcn.00440740(0xffffffff);\n            pcVar2 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n            iVar3 = *(*(unaff_EBP + -0x14) + -0xc);\n            if (*(*(unaff_EBP + -0x10) + iVar3 * 2) == 0x5c) {\n                iVar3 = iVar3 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                      (0, 0, *(unaff_EBP + -0x10) + iVar3 * 2, 0xffffffff, *(*(extraout_ECX + 0x74) + 0x24), \n                       *(*(extraout_ECX + 0x74) + 0x28), 0, 0);\n            *(*(*(extraout_ECX + 0x74) + 0x28) + -1 + *(*(extraout_ECX + 0x74) + 0x24)) = 0;\n            (*pcVar2)(0, 0, *(unaff_EBP + -0x10), 0xffffffff, *(*(extraout_ECX + 0x74) + 0x1c), \n                      *(*(extraout_ECX + 0x74) + 0x20) + -1, 0, 0);\n            *(*(*(extraout_ECX + 0x74) + 0x20) + -2 + *(*(extraout_ECX + 0x74) + 0x1c)) = 0;\n            iVar3 = *(extraout_ECX + 0x74);\n            iVar5 = fcn.0045aeb0(*(iVar3 + 0x1c));\n            *(iVar5 + 1 + *(iVar3 + 0x1c)) = 0;\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x10));\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004010f0();\n        }\n        piVar6 = *(unaff_EBP + -0x28);\ncode_r0x004419a2:\n        (**(*piVar6 + 8))(piVar6);\n    }\n    piVar6 = fcn.00441276(unaff_EBP + -0x24);\n    *(unaff_EBP + -4) = 2;\n    piVar7 = fcn.00441433(unaff_EBP + -0x2c);\n    *(*(extraout_ECX + 0x74) + 0x38) = *(*piVar6 + -0xc) - *(*piVar7 + -0xc);\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004010f0();\n    piVar6 = fcn.00441276(unaff_EBP + -0x34);\n    *(unaff_EBP + -4) = 3;\n    piVar7 = fcn.00441526(unaff_EBP + -0x30);\n    *(*(extraout_ECX + 0x74) + 0x3a) = *(*piVar6 + -0xc) - *(*piVar7 + -0xc);\n    fcn.004010f0();\n    fcn.004010f0();\ncode_r0x00441a3c:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 2644
    },
    "00441d51": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00441d51(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042052a();\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 0x2c);\n    return;\n}\n",
        "token_count": 58
    },
    "00441f7e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00441f7e(uint param_1)\n\n{\n    fcn.00458b20(param_1, 0, 0x14);\n    return param_1;\n}\n",
        "token_count": 45
    },
    "004425d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "capture webcam video/77a2bdf63842401e87d4da7ad796395a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.004425d3(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uchar *puVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    *(unaff_EBP + -0x10) = 0;\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    uVar1 = *(extraout_ECX + 0x20);\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    (*pcVar2)(uVar1, 0x434, 0, unaff_EBP + -0x18);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    puVar3 = fcn.004090c0((*(unaff_EBP + -0x14) - *(unaff_EBP + -0x18)) + 1);\n    *puVar3 = 0;\n    (*pcVar2)(*(extraout_ECX + 0x20), 0x43e, 0, puVar3);\n    fcn.00409070(0xffffffff);\n    fcn.004041b0(unaff_EBP + -0x10);\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 422
    },
    "0044299d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044299d(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    if (0x7fffffff - arg_ch < arg_10h) {\n        return 0x80070057;\n    }\n    *arg_8h = arg_ch + arg_10h;\n    return 0;\n}\n",
        "token_count": 84
    },
    "00442bb4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00442bb4(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.0044299d(&var_4h, arg_8h, arg_ch);\n    if (iVar1 < 0) {\n        fcn.00401000(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 93
    },
    "0044349a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_11h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid __cdecl fcn.0044349a(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    int64_t iVar2;\n    uint var_80h;\n    uint var_7ch;\n    uint var_38h;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_11h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x74);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    if (*(unaff_EBP + 8) == 0) {\n        fcn.0041638e();\n    }\n    fcn.00410530(0, 0xffffffff, 0);\n    iVar1 = *extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = (**(iVar1 + 0x84))(*(unaff_EBP + 8), 0x20, unaff_EBP + -0x38);\n    iVar1 = *extraout_ECX;\n    *(unaff_EBP + -0x1c) = arg_8h_00;\n    if (arg_8h_00 == NULL) {\n        (**(iVar1 + 0x80))(*(unaff_EBP + 8), unaff_EBP + -0x38, 0, 0xf101);\n        *(unaff_EBP + -0x38) = vtable.CFileException.0;\n        fcn.004010f0();\n    }\n    else {\n        (**(iVar1 + 0x6c))();\n        (**(*extraout_ECX + 0x5c))(1);\n        fcn.0043941a(arg_8h_00, 3, 0x1000, 0);\n        *(unaff_EBP + -0x80) = extraout_ECX;\n        *(unaff_EBP + -0x7c) = 0;\n        *(unaff_EBP + -4) = 2;\n        fcn.00412d50();\n        iVar1 = *arg_8h_00;\n        *(unaff_EBP + -4) = 3;\n        iVar2 = (**(iVar1 + 0x30))();\n        if (iVar2 != 0) {\n            (**(*extraout_ECX + 8))(unaff_EBP + -0x80);\n        }\n        fcn.00439263();\n        (**(*extraout_ECX + 0x88))(arg_8h_00, 0);\n        *(unaff_EBP + -4) = 2;\n        fcn.00414280();\n        iVar1 = *extraout_ECX;\n        *(unaff_EBP + -4) = 1;\n        (**(iVar1 + 0x5c))(0);\n        *(unaff_EBP + -4) = 0;\n        fcn.004393dc();\n        *(unaff_EBP + -0x38) = vtable.CFileException.0;\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 821
    },
    "0044363b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_11h\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.0044363b(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_80h;\n    uint var_7ch;\n    uint var_38h;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_11h;\n    uint var_4h;\n    \n    fcn.0045af6e(0x74);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    if (*(unaff_EBP + 8) == 0) {\n        fcn.0041638e();\n    }\n    fcn.00410530(0, 0xffffffff, 0);\n    iVar2 = *extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (**(iVar2 + 0x84))(*(unaff_EBP + 8), 0x1012, unaff_EBP + -0x38);\n    *(unaff_EBP + -0x1c) = iVar2;\n    if (iVar2 == 0) {\n        (**(*extraout_ECX + 0x80))(*(unaff_EBP + 8), unaff_EBP + -0x38, 1, 0xf100);\n        *(unaff_EBP + -0x38) = vtable.CFileException.0;\n        fcn.004010f0();\n    }\n    else {\n        fcn.0043941a(iVar2, 2, 0x1000, 0);\n        *(unaff_EBP + -0x80) = extraout_ECX;\n        *(unaff_EBP + -0x7c) = 0;\n        *(unaff_EBP + -4) = 2;\n        fcn.00412d50();\n        iVar1 = *extraout_ECX;\n        *(unaff_EBP + -4) = 3;\n        (**(iVar1 + 8))(unaff_EBP + -0x80);\n        fcn.00439263();\n        (**(*extraout_ECX + 0x88))(iVar2, 0);\n        *(unaff_EBP + -4) = 2;\n        fcn.00414280();\n        iVar2 = *extraout_ECX;\n        *(unaff_EBP + -4) = 1;\n        (**(iVar2 + 0x5c))(0);\n        *(unaff_EBP + -4) = 0;\n        fcn.004393dc();\n        *(unaff_EBP + -0x38) = vtable.CFileException.0;\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 724
    },
    "00444af1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444af1(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.004594f3(arg_8h, arg_ch, arg_10h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 76
    },
    "00445525": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445525(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    \n    iVar1 = fcn.0041ff5e();\n    in_ECX[1] = iVar1;\n    in_ECX[2] = *(iVar1 + 0xe8);\n    *in_ECX = *(iVar1 + 0xe4);\n    *(iVar1 + 0xe4) = arg_8h;\n    *(in_ECX[1] + 0xe8) = in_ECX;\n    return;\n}\n",
        "token_count": 127
    },
    "00445b33": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00445b33(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    \n    iVar1 = arg_8h;\n    iVar4 = 0;\n    if (-1 < arg_8h) goto code_r0x00445b4b;\n    do {\n        fcn.0041638e();\ncode_r0x00445b4b:\n        if (iVar4 <= arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (iVar1 == iVar4) {\n            fcn.00414b30(*(in_ECX + 4));\n            *(in_ECX + 0xc) = iVar4;\n            *(in_ECX + 8) = iVar4;\n            goto code_r0x00445c4f;\n        }\n        if (*(in_ECX + 4) == iVar4) {\n            uVar2 = fcn.00414af6(iVar1 << 2);\n            *(in_ECX + 4) = uVar2;\n            fcn.00458b20(uVar2, 0, iVar1 << 2);\n            *(in_ECX + 0xc) = iVar1;\ncode_r0x00445bb7:\n            *(in_ECX + 8) = iVar1;\n            return;\n        }\n        iVar4 = *(in_ECX + 0xc);\n        if (iVar1 <= iVar4) {\n            iVar4 = *(in_ECX + 8);\n            if (iVar4 < iVar1) {\n                fcn.00458b20(*(in_ECX + 4) + iVar4 * 4, 0, (iVar1 - iVar4) * 4);\n            }\n            goto code_r0x00445bb7;\n        }\n        iVar3 = *(in_ECX + 0x10);\n        if (iVar3 == 0) {\n            iVar3 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar3 < 4) {\ncode_r0x00445be9:\n                iVar3 = 4;\n            }\n            else if (iVar3 < 0x401) {\n                if (iVar3 < 4) goto code_r0x00445be9;\n            }\n            else {\n                iVar3 = 0x400;\n            }\n        }\n        arg_8h = iVar3 + iVar4;\n        if (iVar3 + iVar4 <= iVar1) {\n            arg_8h = iVar1;\n        }\n    } while (arg_8h < iVar4);\n    iVar4 = fcn.00414af6(arg_8h << 2);\n    fcn.00414fcb(iVar4, arg_8h << 2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.00458b20(iVar4 + *(in_ECX + 8) * 4, 0, (iVar1 - *(in_ECX + 8)) * 4);\n    fcn.00414b30(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x00445c4f:\n    *(in_ECX + 4) = iVar4;\n    return;\n}\n",
        "token_count": 782
    },
    "00446bd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00446bd0(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00446a07(arg_8h);\n    *arg_ch = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.00446aba(arg_8h);\n        *arg_ch = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.00446b4a();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 151
    },
    "00446c36": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00446c36(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (*(param_1 + 0x20) != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 0x28) != 0) {\n            do {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(iVar2 + 4 + *(param_1 + 0x20)));\n                (*_sym.imp.ole32.dll_ReleaseStgMedium)(iVar2 + 0x14 + *(param_1 + 0x20));\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x24;\n            } while (uVar1 < *(param_1 + 0x28));\n        }\n        fcn.00414b30(*(param_1 + 0x20));\n        *(param_1 + 0x20) = 0;\n        *(param_1 + 0x24) = 0;\n        *(param_1 + 0x28) = 0;\n    }\n    return;\n}\n",
        "token_count": 264
    },
    "00446ead": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00446ead(code **param_1)\n\n{\n    code **extraout_ECX;\n    code *pcVar1;\n    int32_t unaff_EBP;\n    uint *puVar2;\n    \n    pcVar1 = NULL;\n    *param_1 = vtable.CEnumFormatEtc.0;\n    if ((param_1[9] == NULL) && (param_1[0xc] != NULL)) {\n        puVar2 = param_1[10] + 4;\n        do {\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*puVar2);\n            pcVar1 = pcVar1 + 1;\n            puVar2 = puVar2 + 5;\n        } while (pcVar1 < param_1[0xc]);\n    }\n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[9];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.00446b65();\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        fcn.00414b30(extraout_ECX[10]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041e889();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 336
    },
    "004470b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004470b9(uint arg_8h, int16_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_14h;\n    \n    if (arg_ch == NULL) {\n        arg_ch = fcn.00414c52(0, arg_8h, &var_14h);\n        *(arg_ch + 8) = 1;\n    }\n    if (arg_8h != 0) {\n        *arg_ch = arg_8h;\n    }\n    iVar1 = fcn.00446fc2(arg_ch, 1);\n    fcn.00458b20(iVar1 + 0x14, 0, 0xc);\n    return;\n}\n",
        "token_count": 157
    },
    "0044712b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044712b(ushort *arg_8h)\n\n{\n    int64_t iVar1;\n    uint arg_8h_00;\n    ushort *puVar2;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x30) == *(in_ECX + 0x3c)) {\n        iVar1 = (*(in_ECX + 0x30) + 10) * 0x14;\n        arg_8h_00 = fcn.00414af6(-(iVar1 >> 0x20 != 0) | iVar1);\n        *(in_ECX + 0x3c) = *(in_ECX + 0x3c) + 10;\n        fcn.00414fcb(arg_8h_00, (*(in_ECX + 0x30) + 10) * 0x14, *(in_ECX + 0x28), *(in_ECX + 0x30) * 0x14);\n        fcn.00414b30(*(in_ECX + 0x28));\n        *(in_ECX + 0x28) = arg_8h_00;\n    }\n    puVar2 = *(in_ECX + 0x30) * 0x14 + *(in_ECX + 0x28);\n    *puVar2 = *arg_8h;\n    *(puVar2 + 2) = *(arg_8h + 2);\n    *(puVar2 + 4) = *(arg_8h + 4);\n    *(puVar2 + 6) = *(arg_8h + 6);\n    *(puVar2 + 8) = *(arg_8h + 8);\n    *(in_ECX + 0x30) = *(in_ECX + 0x30) + 1;\n    return;\n}\n",
        "token_count": 409
    },
    "00447af2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00447af2(uint arg_8h)\n\n{\n    uint16_t *puVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = *(*(in_ECX + 0x74) + 0xc);\n    if (iVar2 != 0) {\n        puVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar2, 0);\n        iVar2 = *puVar1 + puVar1;\n    }\n    fcn.00404920(iVar2);\n    return arg_8h;\n}\n",
        "token_count": 152
    },
    "00447b25": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00447b25(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x74) + 0xc);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        iVar1 = *(iVar1 + 2) + iVar1;\n    }\n    fcn.00404920(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 144
    },
    "00447b59": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00447b59(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x74) + 0xc);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        iVar1 = *(iVar1 + 4) + iVar1;\n    }\n    fcn.00404920(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 144
    },
    "00447dc2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447dc2(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t in_ECX;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    if (*(in_ECX + 0x10c) == 0) {\n        uVar1 = 0;\n        if (*(in_ECX + 0x110) != 0) {\n            iVar2 = 0;\n            do {\n                *(iVar2 + 0x18 + *(in_ECX + 0xb0)) = 0;\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x28;\n            } while (uVar1 < *(in_ECX + 0x110));\n        }\n        fcn.0041ae6e();\n    }\n    else {\n        *(in_ECX + 0x70) = arg_ch;\n        *(in_ECX + 0x74) = arg_10h;\n        *(in_ECX + 0x78) = arg_ch / 10;\n        *(in_ECX + 0x7c) = arg_10h / 10;\n        fcn.00456577(arg_8h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 289
    },
    "004482ee": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004482ee(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    *(in_ECX + 0x114) = arg_8h;\n    uVar1 = *(*(**(in_ECX + 0x134) + 0x74) + 0x1e);\n    if (uVar1 < arg_8h) {\n        *(in_ECX + 0x114) = uVar1;\n    }\n    uVar1 = *(*(**(in_ECX + 0x134) + 0x74) + 0x1c);\n    if (*(in_ECX + 0x114) < uVar1) {\n        *(in_ECX + 0x114) = uVar1;\n    }\n    if (*(in_ECX + 0x10c) == 0) {\n        fcn.00419c40(1, *(in_ECX + 0x114), 1);\n    }\n    if (arg_ch != 0) {\n        uVar1 = 0;\n        if (*(in_ECX + 0x110) != 0) {\n            iVar2 = 0;\n            do {\n                *(*(in_ECX + 0xb0) + 0x18 + iVar2) = 0;\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x28;\n            } while (uVar1 < *(in_ECX + 0x110));\n        }\n    }\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    return;\n}\n",
        "token_count": 385
    },
    "00448980": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00448980(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    \n    pcVar3 = _sym.imp.USER32.dll_ShowScrollBar;\n    if (*(in_ECX + 0x10c) == 0) {\n        *(in_ECX + 0x118) = *(in_ECX + 0x108);\n        (*pcVar3)(*(in_ECX + 0x20), 0);\n        iVar4 = *(**(in_ECX + 0x134) + 0x74);\n        uVar2 = *(iVar4 + 0x1e);\n        if ((0x7fff < uVar2) || (arg_8h = 1,  0x7fff < uVar2 - *(iVar4 + 0x1c))) {\n            arg_8h = 0;\n        }\n        (*pcVar3)(*(in_ECX + 0x20), 1, arg_8h);\n        if (arg_8h != 0) {\n            var_18h = 3;\n            var_14h = *(*(**(in_ECX + 0x134) + 0x74) + 0x1c);\n            var_10h = *(*(**(in_ECX + 0x134) + 0x74) + 0x1e);\n            var_ch = 1;\n            iVar4 = fcn.00418ef7(1, &var_1ch, 0);\n            if (iVar4 == 0) {\n                fcn.00419ca0(1, var_14h, var_10h, 0);\n            }\n        }\n        fcn.004482ee(*(in_ECX + 0x114), 1);\n    }\n    else {\n        iVar4 = *(in_ECX + 0xb0);\n        iVar5 = arg_8h * 0x28;\n        *(in_ECX + 0x118) = 1;\n        *(iVar4 + 0x20) = *(iVar4 + 0x20 + iVar5);\n        *(iVar4 + 0x24) = *(iVar4 + 0x24 + iVar5);\n        iVar4 = *(in_ECX + 0xb0);\n        *(iVar4 + 0x10) = *(iVar4 + 0x10 + iVar5);\n        *(iVar4 + 0x14) = *(iVar4 + 0x14 + iVar5);\n        fcn.004482ee(*(in_ECX + 0x114) + arg_8h, 0);\n        fcn.00448020(0);\n        pcVar3 = _sym.imp.KERNEL32.dll_MulDiv;\n        puVar1 = iVar5 + 0x18 + *(in_ECX + 0xb0);\n        iVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_ch, *puVar1, puVar1[1]);\n        iVar5 = (*pcVar3)(arg_10h, *puVar1, puVar1[1]);\n        fcn.00455b76(iVar4 + **(in_ECX + 0xb0), iVar5 + (*(in_ECX + 0xb0))[1]);\n    }\n    return;\n}\n",
        "token_count": 798
    },
    "004497ef": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004497ef(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_164h;\n    uint var_160h;\n    uint pv;\n    uint var_114h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x158);\n    *(unaff_EBP + -0x164) = extraout_ECX;\n    fcn.0042b032();\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.COleStreamFile.0;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[4] = *(unaff_EBP + 8);\n    fcn.004018d0();\n    piVar1 = extraout_ECX[4];\n    if (piVar1 != NULL) {\n        iVar3 = (**(*piVar1 + 0x30))(piVar1, unaff_EBP + -0x15c, 0);\n        if ((iVar3 == 0) && (*(unaff_EBP + -0x15c) != 0)) {\n            fcn.0041589a(*(unaff_EBP + -0x15c));\n            iVar3 = *(unaff_EBP + -0x160);\n            iVar2 = *(iVar3 + -0xc);\n            *(unaff_EBP + -4) = 2;\n            if (0x103 < iVar2) {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x15c));\n                iVar3 = fcn.0043880a(3, 0xffffffff, 0);\n            }\n            fcn.0042b4c9(unaff_EBP + -0x114, iVar3);\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x15c));\n            fcn.004024f0(unaff_EBP + -0x114);\n            fcn.004010f0();\n        }\n    }\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 524
    },
    "00449b06": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449b06(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.0045af3b(0);\n    piVar1 = *(unaff_EBP + 8);\n    if ((piVar1 != NULL) && (*(unaff_EBP + 0xc) != 0)) {\n        fcn.00416242(*(unaff_EBP + 0xc));\n        iVar2 = *piVar1;\n        *(unaff_EBP + -4) = 0;\n        iVar2 = (**(iVar2 + 0x10))(piVar1, *(unaff_EBP + 0xc), 0, *(unaff_EBP + 0x10), 0, extraout_ECX + 0x10);\n        if ((iVar2 < 0) && (*(unaff_EBP + 0x14) != 0)) {\n            fcn.004495bd(*(unaff_EBP + 0x14), iVar2);\n        }\n        fcn.004010f0();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 311
    },
    "00449b74": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00449b74(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_16ch;\n    uint var_168h;\n    uint var_164h;\n    uint var_160h;\n    uint pv;\n    uint var_114h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x160);\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x16c) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x164) = *(unaff_EBP + 0x14);\n    if ((piVar1 != NULL) && (*(unaff_EBP + 0xc) != 0)) {\n        iVar2 = (**(*piVar1 + 0x44))(piVar1, unaff_EBP + -0x15c, 0);\n        if ((iVar2 == 0) && (*(unaff_EBP + -0x15c) != 0)) {\n            fcn.0041589a(*(unaff_EBP + -0x15c));\n            *(unaff_EBP + -4) = 0;\n            fcn.0042b4c9(unaff_EBP + -0x114, *(unaff_EBP + -0x168));\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x15c));\n            fcn.004024f0(unaff_EBP + -0x114);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004010f0();\n        }\n        fcn.00416242(*(unaff_EBP + -0x16c));\n        iVar2 = *piVar1;\n        *(unaff_EBP + -4) = 1;\n        iVar2 = (**(iVar2 + 0xc))(piVar1, *(unaff_EBP + -0x160), *(unaff_EBP + 0x10), 0, 0, extraout_ECX + 0x10);\n        if ((iVar2 < 0) && (*(unaff_EBP + -0x164) != 0)) {\n            fcn.004495bd(*(unaff_EBP + -0x164), iVar2);\n        }\n        fcn.004010f0();\n    }\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 597
    },
    "0044a59f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: lpCriticalSection\n\nvoid __cdecl fcn.0044a59f(uint arg_8h, uint arg_ch)\n\n{\n    code **arg_8h_00;\n    uint uVar1;\n    code *pcVar2;\n    uint *extraout_ECX;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint lpCriticalSection;\n    uint uVar4;\n    uint *puVar5;\n    uint var_4h;\n    \n    fcn.0045af6e(0x10);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    puVar5 = extraout_ECX + 7;\n    *(unaff_EBP + -0x14) = puVar5;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar5);\n    if ((*(unaff_EBP + 8) < 1) || (extraout_ECX[3] <= *(unaff_EBP + 8))) goto code_r0x0044a6c6;\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*extraout_ECX);\n    if (arg_8h_00 == NULL) {\n        *(unaff_EBP + -4) = 0;\n        arg_8h_00 = fcn.0044a21f(0x10);\n        if (arg_8h_00 == NULL) {\n            arg_8h_00 = NULL;\n        }\n        else {\n            *arg_8h_00 = vtable.CThreadData.0;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        arg_8h_00[2] = NULL;\n        arg_8h_00[3] = NULL;\n        fcn.0044a351(arg_8h_00);\ncode_r0x0044a5f6:\n        if (arg_8h_00[3] == NULL) {\n            uVar1 = fcn.0041650d(extraout_ECX[3], 4);\n            pcVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, uVar1);\n        }\n        else {\n            uVar4 = 2;\n            uVar1 = fcn.0041650d(extraout_ECX[3], 4);\n            pcVar2 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(arg_8h_00[3], uVar1, uVar4);\n        }\n        if (pcVar2 == NULL) {\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*(unaff_EBP + -0x14));\n            pcVar2 = fcn.00416356();\n        }\n        arg_8h_00[3] = pcVar2;\n        fcn.00458b20(pcVar2 + arg_8h_00[2] * 4, 0, (extraout_ECX[3] - arg_8h_00[2]) * 4);\n        arg_8h_00[2] = extraout_ECX[3];\n        (*_sym.imp.KERNEL32.dll_TlsSetValue)(*extraout_ECX, arg_8h_00);\n        iVar3 = *(unaff_EBP + 8);\n    }\n    else {\n        iVar3 = *(unaff_EBP + 8);\n        if ((arg_8h_00[2] <= iVar3) && (*(unaff_EBP + 0xc) != 0)) goto code_r0x0044a5f6;\n    }\n    if ((arg_8h_00[3] != NULL) && (iVar3 < arg_8h_00[2])) {\n        *(arg_8h_00[3] + iVar3 * 4) = *(unaff_EBP + 0xc);\n    }\n    puVar5 = *(unaff_EBP + -0x14);\ncode_r0x0044a6c6:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar5);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 942
    },
    "0044abf4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0044abf4(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.0044a9f2(arg_8h, &arg_8h, &var_4h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.0044a949(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.0044aba4();\n        puVar2[1] = iVar1;\n        *puVar2 = *(arg_8h * 4 + *(in_ECX + 4));\n        *(arg_8h * 4 + *(in_ECX + 4)) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 220
    },
    "0044af85": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044af85(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uchar lpString1;\n    uint var_103h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    if (arg_8h != 0) goto code_r0x0044afac;\n    do {\n        fcn.0041638e();\ncode_r0x0044afac:\n    } while (arg_ch == 0);\n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n    lpString1 = 0;\n    fcn.00458b20(&var_103h, 0, 0xff);\n    if (uVar1 < 0x101) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(arg_8h, &lpString1, 0x100);\n        if (uVar2 == uVar1) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, arg_ch);\n            if (iVar3 == 0) goto code_r0x0044b00c;\n        }\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(arg_8h, arg_ch);\ncode_r0x0044b00c:\n    fcn.0045843c(unaff_EBX);\n    return;\n}\n",
        "token_count": 351
    },
    "0044b457": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b457(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t Y, uint crColor)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    var_10h = arg_8h;\n    var_8h = arg_8h + arg_10h;\n    var_ch = arg_ch;\n    var_4h = arg_ch + Y;\n    (*_sym.imp.GDI32.dll_ExtTextOutA)(*(in_ECX + 4), 0, 0, 2, &var_10h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 207
    },
    "0044b4a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b4a5(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint var_4h;\n    \n    fcn.0044b457(arg_8h, arg_ch, arg_10h + -1, 1, arg_18h);\n    fcn.0044b457(arg_8h, arg_ch, 1, arg_14h + -1, arg_18h);\n    fcn.0044b457(arg_8h + arg_10h, arg_ch, 0xffffffff, arg_14h, arg_1ch);\n    fcn.0044b457(arg_8h, arg_ch + arg_14h, arg_10h, 0xffffffff, arg_1ch);\n    return;\n}\n",
        "token_count": 202
    },
    "0044ba30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044ba30(uint32_t arg_8h)\n\n{\n    if (0x10 < arg_8h) {\n        arg_8h = fcn.0041638e();\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(arg_8h * 0x18 + 0x49bee0);\n    return;\n}\n",
        "token_count": 83
    },
    "0044baf7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044baf7(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    if (*(arg_8h + 2) == -1) {\n        piVar2 = arg_8h + 0x1a;\n    }\n    else {\n        piVar2 = arg_8h + 0x12;\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 258
    },
    "0044c14e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: lpClassName\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0044c14e(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint lpClassName;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    fcn.0042052a();\n    fcn.0044b9be(1);\n    *(unaff_EBP + -0x14) = 0;\n    fcn.004437bd(unaff_EBP + -0x10, 0x48083c, unaff_EBP + -0x14);\n    *(unaff_EBP + -4) = 0;\n    while (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n        iVar1 = fcn.0042052a();\n        (*_sym.imp.USER32.dll_UnregisterClassA)(*(unaff_EBP + -0x10), *(iVar1 + 8));\n        uVar2 = fcn.004437bd(unaff_EBP + -0x18, 0x48083c, unaff_EBP + -0x14);\n        *(unaff_EBP + -4) = 1;\n        fcn.004076d0(uVar2);\n        *(unaff_EBP + -4) = 0;\n        fcn.004010f0();\n    }\n    fcn.004018d0();\n    fcn.0044ba30(1);\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 420
    },
    "0044c2a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0044c2a5(uint param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint unaff_ESI;\n    uint lParam;\n    uint lpLogfont;\n    uint var_29h;\n    uint var_24h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    lParam = 0;\n    fcn.00458b20(&lpLogfont, 0, 0x3c);\n    uVar1 = fcn.0045aeb0(param_1);\n    if (0x1f < uVar1) {\n        fcn.0041638e();\n    }\n    fcn.0042a985(&var_24h, 0x20, param_1);\n    var_29h._0_1_ = 1;\n    lParam = 0;\n    iVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n    if (iVar2 != 0) {\n        (*_sym.imp.GDI32.dll_EnumFontFamiliesExA)(iVar2, &lpLogfont, fcn.0044c263, &lParam, 0);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, iVar2);\n    }\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 318
    },
    "0044cedc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044cedc(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = 0;\n    if (0 < *(in_ECX + 0xac)) {\n        piVar2 = *(in_ECX + 0xa8);\n        do {\n            if (*piVar2 == arg_8h) break;\n            iVar1 = iVar1 + 1;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 < *(in_ECX + 0xac));\n        if (iVar1 == 8) {\n            return 0;\n        }\n    }\n    *(*(in_ECX + 0xa8) + iVar1 * 4) = arg_8h;\n    if (iVar1 == *(in_ECX + 0xac)) {\n        *(in_ECX + 0xac) = *(in_ECX + 0xac) + 1;\n    }\n    return 1 << (iVar1 & 0x1f);\n}\n",
        "token_count": 241
    },
    "0044d6a1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0044d6a1(void)\n\n{\n    code *arg_8h;\n    code **extraout_ECX;\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t iVar2;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.COlePasteSpecialDialog.0;\n    arg_8h = extraout_ECX[0x30];\n    iVar1 = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00414eec(arg_8h);\n    if (0 < extraout_ECX[0x29]) {\n        iVar2 = 0;\n        do {\n            fcn.004585e6(*(extraout_ECX[0x28] + iVar2 + 0x14));\n            fcn.004585e6(*(extraout_ECX[0x28] + iVar2 + 0x18));\n            iVar1 = iVar1 + 1;\n            iVar2 = iVar2 + 0x24;\n        } while (iVar1 < extraout_ECX[0x29]);\n    }\n    fcn.004585e6(extraout_ECX[0x28]);\n    fcn.004469e6(extraout_ECX + 0x27);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *extraout_ECX = vtable.CCommonDialog.0;\n    fcn.0041ec27();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 385
    },
    "0044dc6d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044dc6d(int32_t arg_8h)\n\n{\n    return arg_8h + -0x74;\n}\n",
        "token_count": 36
    },
    "0044dc82": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0044dc82(code **param_1)\n\n{\n    fcn.004400c1(0);\n    *param_1 = vtable.CFindReplaceDialog.0;\n    fcn.00458b20(param_1 + 0x1d, 0, 0x28);\n    param_1[0x1d] = 0x28;\n    param_1[0x21] = param_1 + 0x27;\n    *(param_1 + 0x27) = 0;\n    *(param_1 + 0x47) = 0;\n    param_1[0x20] = 0x100;\n    param_1[0x25] = fcn.00445036;\n    return param_1;\n}\n",
        "token_count": 175
    },
    "0044e2d8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0044e2d8(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.00404920(*(in_ECX + 0x80) + 0x1c, 0);\n    return arg_8h;\n}\n",
        "token_count": 87
    },
    "0044e789": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044e789(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0045e08a(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00409e60(uVar1);\n    return;\n}\n",
        "token_count": 88
    },
    "0044e8c9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl fcn.0044e8c9(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t unaff_EBP;\n    uint var_26ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x260);\n    iVar6 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x10) = 0x80004003;\n    if (iVar6 != 0) {\n        *(unaff_EBP + -0x10) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            iVar7 = *(unaff_EBP + 0x10);\n            if (iVar7 != 0) {\n                puVar3 = iVar6 + 4;\n                do {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 2;\n                    iVar7 = iVar7 + -1;\n                } while (iVar7 != 0);\n            }\n        }\n        else {\n            fcn.0044e7aa(iVar6, *(unaff_EBP + 0x10), *(unaff_EBP + 0xc));\n            piVar1 = *(unaff_EBP + 0x18);\n            *(unaff_EBP + -4) = 0;\n            if (piVar1 == NULL) {\n                *(unaff_EBP + -0x20) = 0;\n            }\n            else {\n                *(unaff_EBP + -0x20) = *piVar1;\n            }\n            *(unaff_EBP + -0x40) = 0;\n            if (*(unaff_EBP + 0x10) != 0) {\n                do {\n                    *(unaff_EBP + -0x44) = *(iVar6 + *(unaff_EBP + -0x40) * 8);\n                    fcn.0044e6d4(*(unaff_EBP + 8), 1);\n                    *(unaff_EBP + -0x40) = *(unaff_EBP + -0x40) + 1;\n                } while (*(unaff_EBP + -0x40) < *(unaff_EBP + 0x10));\n            }\n            if (((piVar1 != NULL) && (piVar1 + 3 != NULL)) && (*piVar1 != 0)) {\n                uVar4 = fcn.004043a0(unaff_EBP + 0x10, piVar1[2] + -1);\n                *(unaff_EBP + -4) = 1;\n                fcn.004076d0(uVar4);\n                *(unaff_EBP + -4) = 0;\n                fcn.004010f0();\n                iVar6 = *(unaff_EBP + -0x14);\n                uVar2 = *(iVar6 + -0xc);\n                uVar5 = piVar1[2] - 1U;\n                if (uVar2 < piVar1[2] - 1U) {\n                    uVar5 = uVar2;\n                }\n                piVar1[1] = uVar5;\n                iVar6 = fcn.0044c107(iVar6);\n                uVar4 = *(iVar6 + 0xc);\n                *(unaff_EBP + -4) = 2;\n                fcn.0044e789(piVar1 + 3, piVar1[2], uVar4, 0xffffffff);\n                fcn.0044c0bd();\n            }\n            *(unaff_EBP + -0x48) = vtable.COleCmdUI.0;\n            fcn.004010f0();\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 992
    },
    "00451501": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00451501(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    uint arg_8h_00;\n    \n    fcn.00451176(1);\n    (*_sym.imp.USER32.dll_ReleaseCapture)();\n    arg_8h_00 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    fcn.0041af14(arg_8h_00);\n    (*_sym.imp.USER32.dll_LockWindowUpdate)(0);\n    arg_8h = *(param_1 + 0x84);\n    if (arg_8h != 0) {\n        fcn.0044f72d(arg_8h);\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 170
    },
    "0045280e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0045280e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t arg_14h;\n    int32_t arg_ch_00;\n    uint arg_10h_00;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    piVar1 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x10) = 0;\n    uVar2 = fcn.00404180();\n    fcn.0043fc83(uVar2);\n    arg_14h = **(unaff_EBP + 0x10);\n    uVar2 = *(arg_14h + -0xc);\n    arg_ch_00 = *piVar1;\n    arg_10h_00 = *(arg_ch_00 + -0xc);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    fcn.0043fc9a(*(unaff_EBP + 8), arg_ch_00, arg_10h_00, arg_14h, uVar2);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 337
    },
    "00452944": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00452944(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *arg_10h_00;\n    code *pcVar1;\n    uint uVar2;\n    code **ppcVar3;\n    code **extraout_ECX;\n    uint32_t uVar4;\n    code **arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CRecentFileList.0;\n    fcn.00401e60();\n    arg_8h_00 = NULL;\n    *(unaff_EBP + -4) = 0;\n    fcn.00401e60();\n    fcn.00401e60();\n    arg_10h_00 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 2;\n    if (-1 < arg_10h_00) goto code_r0x00452988;\n    do {\n        fcn.0041638e();\ncode_r0x00452988:\n        uVar4 = -(ZEXT48(arg_10h_00) * 4 >> 0x20 != 0) | ZEXT48(arg_10h_00) * 4;\n        ppcVar3 = fcn.00414af6(-(0xfffffffb < uVar4) | uVar4 + 4);\n        if (ppcVar3 != arg_8h_00) {\n            arg_8h_00 = ppcVar3 + 1;\n            *ppcVar3 = arg_10h_00;\n            fcn.00458a1a(arg_8h_00, 4, arg_10h_00, fcn.00401e60);\n        }\n        extraout_ECX[2] = arg_8h_00;\n    } while (arg_8h_00 == NULL);\n    pcVar1 = *(unaff_EBP + 8);\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[1] = arg_10h_00;\n    extraout_ECX[5] = pcVar1;\n    fcn.00402830(uVar2);\n    fcn.00402830(*(unaff_EBP + 0x10));\n    extraout_ECX[6] = *(unaff_EBP + 0x18);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 627
    },
    "00452d6d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00452d6d(uint32_t arg_8h)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    \n    uVar1 = fcn.00414af6(-(arg_8h * 4 >> 0x20 != 0) | arg_8h * 4);\n    *in_ECX = uVar1;\n    fcn.00458b20(uVar1, 0, arg_8h << 2);\n    in_ECX[1] = arg_8h;\n    return;\n}\n",
        "token_count": 123
    },
    "00452f05": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00452f05(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char *arg_ch_00;\n    int32_t unaff_EBP;\n    char **ppcVar1;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x14);\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x14) = 0;\n    if (*(unaff_EBP + 0x14) == -0x80000000) {\n        fcn.00449e43(0x80000000, \"CLSID\", 0, 0x20019, unaff_EBP + -0x14);\n    }\n    *(unaff_EBP + -0x20) = *(unaff_EBP + -0x14);\n    *(unaff_EBP + -0x1c) = 0;\n    ppcVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    while (arg_ch_00 = *ppcVar1,  arg_ch_00 != NULL) {\n        ppcVar1 = ppcVar1 + 1;\n        if ((*(unaff_EBP + 0x14) != -0x80000000) || (*arg_ch_00 != '\\0')) {\n            fcn.0042a9a3(unaff_EBP + -0x10, arg_ch_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n            if ((*(unaff_EBP + 0x14) != -0x80000000) || (*(*(unaff_EBP + -0x10) + -0xc) != 0)) {\n                fcn.00453639(*(unaff_EBP + -0x10));\n            }\n        }\n    }\n    fcn.0043985f();\n    fcn.004010f0();\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 583
    },
    "00453639": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: hKey\n\nvoid __cdecl fcn.00453639(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uchar *arg_ch;\n    uint hKey;\n    uint lpName;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_8h_00 = fcn.0045d650(arg_8h);\n    if (arg_8h_00 != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h_00);\n        arg_ch = iVar1 + arg_8h_00;\n        while (arg_ch != NULL) {\n            *arg_ch = 0;\n            fcn.0045e073(arg_8h_00, arg_ch);\n            iVar1 = fcn.00449dbb(0x80000000, arg_8h_00, &hKey);\n            if (iVar1 != 0) break;\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(hKey, 0, &lpName, 0x105);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            if (iVar1 == 0) break;\n            fcn.00449fea(0x80000000, arg_8h_00);\n            arg_ch = fcn.0045e229(arg_8h_00, 0x5c);\n        }\n        fcn.004585e6(arg_8h_00);\n    }\n    fcn.0045843c(hKey);\n    return;\n}\n",
        "token_count": 381
    },
    "0045530a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0045530a(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t arg_ch;\n    int32_t in_ECX;\n    bool bVar2;\n    \n    uVar1 = *(in_ECX + 0x2c);\n    bVar2 = uVar1 < *(in_ECX + 0x30);\n    if (bVar2) {\n        arg_ch = *(in_ECX + 0x20);\n        fcn.00414fcb(arg_8h, arg_ch, arg_ch * uVar1 + *(in_ECX + 0x28), arg_ch);\n        *(in_ECX + 0x2c) = *(in_ECX + 0x2c) + 1;\n    }\n    return bVar2;\n}\n",
        "token_count": 178
    },
    "00455c17": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00455c17(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    uVar1 = fcn.00418009();\n    fcn.00455669(arg_ch);\n    if ((*arg_ch != 0) && ((uVar1 & 0x200000) != 0)) {\n        *arg_8h = *arg_8h + *arg_ch;\n    }\n    if ((arg_ch[1] != 0) && ((uVar1 & 0x100000) != 0)) {\n        arg_8h[1] = arg_8h[1] + arg_ch[1];\n    }\n    if ((*arg_ch < *arg_8h) && (arg_ch[1] < arg_8h[1])) {\n        uVar2 = 1;\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 303
    },
    "00455c94": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00455c94(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h, int32_t *arg_14h, int32_t *arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    fcn.00455669(&var_8h);\n    iVar1 = *(in_ECX + 0x6c);\n    *arg_14h = *(in_ECX + 0x68) - arg_8h;\n    arg_14h[1] = iVar1 - arg_ch;\n    piVar2 = fcn.00455b0c(&var_10h);\n    *arg_18h = *piVar2;\n    arg_18h[1] = piVar2[1];\n    uVar3 = 0 < *arg_14h;\n    if (uVar3 == 0) {\n        *arg_18h = 0;\n    }\n    else if (arg_1ch != 0) {\n        arg_14h[1] = arg_14h[1] + var_4h;\n    }\n    uVar4 = 0 < arg_14h[1];\n    if (uVar4 == 0) {\n        arg_18h[1] = 0;\n    }\n    else {\n        if (arg_1ch != 0) {\n            *arg_14h = *arg_14h + var_8h;\n        }\n        if (uVar3 == 0) {\n            if (*arg_14h < 1) goto code_r0x00455d31;\n            uVar3 = 1;\n            arg_14h[1] = arg_14h[1] + var_4h;\n        }\n    }\n    iVar1 = *arg_14h;\n    if ((0 < iVar1) && (iVar1 <= *arg_18h)) {\n        *arg_18h = iVar1;\n    }\ncode_r0x00455d31:\n    iVar1 = arg_14h[1];\n    if ((0 < iVar1) && (iVar1 <= arg_18h[1])) {\n        arg_18h[1] = iVar1;\n    }\n    *arg_10h = uVar3;\n    arg_10h[1] = uVar4;\n    return;\n}\n",
        "token_count": 579
    },
    "004567d4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004567d4(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar8 = arg_ch * arg_10h;\n    iVar4 = iVar8 >> 0x20;\n    iVar1 = iVar8;\n    iVar7 = arg_14h * arg_18h;\n    iVar5 = iVar7 >> 0x20;\n    iVar9 = iVar8;\n    if ((iVar4 == 0 || iVar8 < 0) && (iVar8 < 0)) {\n        iVar9 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    iVar6 = 0;\n    while (iVar9 != 0) {\n        iVar9 = fcn.0045e240();\n        iVar6 = iVar6 + 1;\n    }\n    iVar2 = arg_8h;\n    if (arg_8h < 0) {\n        iVar2 = -arg_8h;\n    }\n    arg_ch = 0;\n    iVar9 = iVar2;\n    while (iVar9 != 0) {\n        iVar9 = fcn.0045e240();\n        arg_ch = arg_ch + 1;\n    }\n    iVar6 = iVar6 + arg_ch;\n    if ((iVar5 == 0 || iVar7 < 0) && (iVar7 < 0)) {\n        iVar7 = CONCAT44(-(iVar5 + (iVar7 != 0)), -iVar7);\n        iVar8 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    while (0x1f < iVar6) {\n        iVar8 = fcn.0045e240();\n        iVar7 = fcn.0045e240();\n        iVar1 = iVar6 + -2;\n        if (iVar6 + -1 < 0x20) break;\n        iVar8 = fcn.0045e240();\n        iVar7 = fcn.0045e240();\n        iVar6 = iVar6 + -3;\n        if (iVar1 < 0x20) break;\n        arg_8h = arg_8h >> 1;\n        iVar7 = fcn.0045e240();\n    }\n    iVar8 = fcn.00459270(arg_8h, arg_8h >> 0x1f, iVar8);\n    if (iVar7 == 0) {\n        if ((iVar8 < 0x100000000) && (iVar8 < 0)) {\n            uVar3 = 0x80000000;\n        }\n        else {\n            uVar3 = 0x7fffffff;\n        }\n    }\n    else {\n        iVar9 = fcn.0045df30(iVar7, 2, 0);\n        uVar3 = fcn.0045df30(iVar9 + iVar8, iVar7);\n    }\n    return uVar3;\n}\n",
        "token_count": 723
    },
    "00456a43": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00456a43(int32_t arg_8h, uint32_t arg_ch, int32_t *arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint32_t uVar1;\n    uint32_t extraout_EDX;\n    \n    uVar1 = 0;\n    if (arg_18h == 0) {\n        fcn.0041638e();\n        uVar1 = extraout_EDX;\n    }\n    arg_8h = arg_8h - arg_14h;\n    do {\n        if (arg_ch <= uVar1) {\n            arg_18h = (arg_8h / arg_18h + 1) * arg_18h;\ncode_r0x00456a78:\n            return arg_18h + arg_14h;\n        }\n        if (*arg_10h != arg_8h && arg_8h <= *arg_10h) {\n            arg_18h = *arg_10h;\n            goto code_r0x00456a78;\n        }\n        uVar1 = uVar1 + 1;\n        arg_10h = arg_10h + 1;\n    } while( true );\n}\n",
        "token_count": 274
    },
    "0045777f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045777f(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t nRightRect;\n    int32_t nBottomRect;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    nRightRect = param_1;\n    nBottomRect = param_1;\n    iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(param_1 + 8), 10);\n    nRightRect = (*pcVar1)(*(param_1 + 8), 8);\n    nBottomRect = iVar2;\n    fcn.0045725d(&nRightRect);\n    (*_sym.imp.GDI32.dll_SetMapMode)(*(param_1 + 4), 1);\n    (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), 0, 0, 0);\n    (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), *(param_1 + 0x20), *(param_1 + 0x24), 0);\n    (*_sym.imp.GDI32.dll_IntersectClipRect)(*(param_1 + 4), 0xffffffff, 0xffffffff, nRightRect + 2, nBottomRect + 2);\n    fcn.00457680(0);\n    return;\n}\n",
        "token_count": 311
    },
    "00458786": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00458786(uint arg_8h, uint arg_ch)\n\n{\n    fcn.0045872f(fcn.00460ce0, arg_8h, 0, arg_ch);\n    return;\n}\n",
        "token_count": 52
    },
    "00458f78": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00458f78(uint arg_8h, uint arg_ch)\n\n{\n    fcn.00458e59(arg_8h, arg_ch, 0);\n    return;\n}\n",
        "token_count": 45
    },
    "0045d945": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045d945(uint arg_8h)\n\n{\n    fcn.0045d819(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 41
    },
    "00466fcb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00466fdf)\n// WARNING: Removing unreachable block (ram,0x00466fe5)\n// WARNING: Removing unreachable block (ram,0x00466fe7)\n\nvoid fcn.00466fcb(void)\n\n{\n    return;\n}\n",
        "token_count": 63
    },
    "004679e4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004679e4(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (arg_8h == NULL) {\n        puVar1 = fcn.0045b3af();\n        *puVar1 = 0x16;\n        fcn.0045f989(0, 0, 0, 0, 0);\n        uVar2 = 0x16;\n    }\n    else {\n        *arg_8h = *0x499334;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 137
    },
    "00467a1d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00467a1d(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (arg_8h == NULL) {\n        puVar1 = fcn.0045b3af();\n        *puVar1 = 0x16;\n        fcn.0045f989(0, 0, 0, 0, 0);\n        uVar2 = 0x16;\n    }\n    else {\n        *arg_8h = *0x499338;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 138
    },
    "00467a56": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00467a56(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (arg_8h == NULL) {\n        puVar1 = fcn.0045b3af();\n        *puVar1 = 0x16;\n        fcn.0045f989(0, 0, 0, 0, 0);\n        uVar2 = 0x16;\n    }\n    else {\n        *arg_8h = *0x499330;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 137
    },
    "0046e701": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0046e701(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.00459308(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.std::logic_error.0;\n    fcn.00410320(arg_8h_00 + 0xc);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 199
    },
    "0046e794": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0046e794(uint param_1)\n\n{\n    fcn.00458b20(param_1, 0, 0x18);\n    return param_1;\n}\n",
        "token_count": 44
    },
    "004580e3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004580e3(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.0045ef3b(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 112
    },
    "00414c92": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414c92(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    iVar3 = (*_sym.imp.ole32.dll_ReadClassStg)(arg_8h, &var_14h);\n    if (iVar3 != 0) goto code_r0x00414d53;\n    var_20h = 0;\n    (*_sym.imp.ole32.dll_ReadFmtUserTypeStg)(arg_8h, &var_28h, &var_20h);\n    var_24h = 0;\n    var_18h = NULL;\n    iVar3 = (*_sym.imp.ole32.dll_OleRegGetUserType)(arg_ch, 1, &var_18h);\n    pcVar1 = _sym.imp.ole32.dll_WriteClassStg;\n    if (iVar3 != 0) {\n        var_18h = &var_24h;\n    }\n    var_1ch = (*_sym.imp.ole32.dll_WriteClassStg)(arg_8h, arg_ch);\n    pcVar2 = _sym.imp.ole32.dll_WriteFmtUserTypeStg;\n    if (var_1ch == 0) {\n        var_1ch = (*_sym.imp.ole32.dll_WriteFmtUserTypeStg)(arg_8h, var_28h, var_18h);\n        if (var_1ch == 0) {\n            var_1ch = (*_sym.imp.ole32.dll_SetConvertStg)(arg_8h, 1);\n            if (var_1ch == 0) goto code_r0x00414d38;\n        }\n        (*pcVar1)(arg_8h, &var_14h);\n        (*pcVar2)(arg_8h, var_28h, var_20h);\n    }\ncode_r0x00414d38:\n    pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n    if (var_18h != &var_24h) {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(var_18h);\n    }\n    (*pcVar1)(var_20h);\ncode_r0x00414d53:\n    fcn.0045843c(unaff_ESI);\n    return;\n}\n",
        "token_count": 600
    },
    "00419d4f": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00419d4f(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    int32_t var_14h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.00419cd7(arg_8h, &var_8h, &var_4h);\n    iVar1 = fcn.00418f37(arg_8h, &var_24h, 2);\n    if (iVar1 != 0) {\n        var_4h = var_4h - (-(var_14h != 1) & var_14h - 1U);\n    }\n    return var_4h;\n}\n",
        "token_count": 162
    },
    "0042246e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042246e(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint *lpPoints;\n    uint uVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    uint uVar8;\n    int32_t *in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint lprc;\n    \n    uVar5 = *(arg_ch + 0x14);\n    lpPoints = arg_ch + 0x24;\n    uVar1 = *lpPoints;\n    uVar2 = *(arg_ch + 0x28);\n    uVar3 = *(arg_ch + 0x2c);\n    uVar4 = *(arg_ch + 0x30);\n    (**(*arg_8h + 0x1c))();\n    fcn.00416db1(0, 0, 0, 0);\n    uVar6 = in_ECX[0x2a];\n    *(arg_ch + 0x14) = uVar6;\n    while (uVar6 < uVar5) {\n        (**(*in_ECX + 0x160))(arg_8h, arg_ch);\n        uVar7 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 10);\n        uVar8 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 8);\n        (*_sym.imp.USER32.dll_SetRect)(lpPoints, 0, 0, uVar8, uVar7);\n        fcn.00422086(lpPoints);\n        (**(*in_ECX + 0x180))(arg_8h, arg_ch);\n        if (*(arg_ch + 0x14) == in_ECX[0x2a]) break;\n        *(arg_ch + 0x14) = *(arg_ch + 0x14) + 1;\n        uVar6 = *(arg_ch + 0x14);\n    }\n    uVar6 = *(arg_ch + 0x14);\n    (**(*arg_8h + 0x20))(0xffffffff);\n    *lpPoints = uVar1;\n    *(arg_ch + 0x28) = uVar2;\n    *(arg_ch + 0x2c) = uVar3;\n    *(arg_ch + 0x30) = uVar4;\n    *(arg_ch + 0x14) = uVar5;\n    return uVar6 == uVar5;\n}\n",
        "token_count": 575
    },
    "004257c9": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004257c9(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = fcn.004469c0(*(in_ECX + 0x24), 0x4850c0);\n    uVar3 = 0;\n    if (piVar1 == NULL) {\n        return 0;\n    }\n    var_18h = 0xffffffff;\n    var_24h._0_2_ = 3;\n    var_20h = 0;\n    var_1ch = 4;\n    var_14h = 0x20;\n    iVar2 = (**(*piVar1 + 0xc))(piVar1, &var_24h, 7, &var_4h);\n    if (iVar2 < 0) {\n        (**(*piVar1 + 8))(piVar1);\n        return 0;\n    }\n    if (arg_8h != 0) {\n        var_ch = arg_8h;\n        var_10h = 0x20;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x1c))(piVar1, &var_24h, &var_10h, 0);\n        if (iVar2 < 0) goto code_r0x0042584e;\n    }\n    uVar3 = 1;\ncode_r0x0042584e:\n    (**(*piVar1 + 8))(piVar1);\n    return uVar3;\n}\n",
        "token_count": 431
    },
    "00427f11": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427f11(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint var_ch;\n    \n    fcn.0042585d(&var_ch);\n    fcn.00447077(*0x49bdfc, &var_ch, 0);\n    fcn.00426d99(arg_10h, arg_14h, &var_ch);\n    fcn.00447077(*0x49be08, &var_ch, 0);\n    fcn.004258f8(arg_8h);\n    if (arg_ch != 0) {\n        iVar1 = fcn.004259cc(&var_ch);\n        if (iVar1 != 0) {\n            fcn.00447077(*0x49be04, &var_ch, 0);\n            fcn.00426d99(arg_10h, arg_14h, &var_ch);\n            fcn.00447077(*0x49be0c, &var_ch, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 246
    },
    "0042995e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042995e(code **param_1)\n\n{\n    int32_t *piVar1;\n    uint unaff_ESI;\n    \n    *param_1 = vtable.COleFrameHook.0;\n    if ((param_1[8] != NULL) && (piVar1 = param_1[8] + 0x80,  *piVar1 == param_1)) {\n        *piVar1 = 0;\n    }\n    fcn.004010f0();\n    if (param_1[4] != NULL) {\n        (**(param_1[4] + 0x1c))(unaff_ESI);\n    }\n    param_1[7] = NULL;\n    return;\n}\n",
        "token_count": 161
    },
    "0042c725": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0042c725(int32_t hgdiobj)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint lpvObject;\n    int32_t var_30h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0x18, &lpvObject);\n    arg_8h = in_ECX + 0x28;\n    if (*arg_8h == 0) {\n        var_8h = 0;\n        var_4h = hgdiobj;\n        iVar1 = (**(*in_ECX + 0x118))(0x413, var_30h / in_ECX[0x2a], &var_8h);\n        uVar2 = iVar1 == 0;\n    }\n    else {\n        var_ch = var_30h / in_ECX[0x2a];\n        var_1ch = 0;\n        var_14h = 0;\n        var_10h = hgdiobj;\n        var_18h = *arg_8h;\n        uVar2 = (**(*in_ECX + 0x118))(0x42e, 0, &var_1ch);\n    }\n    if (uVar2 != 0) {\n        fcn.0044b01d(arg_8h);\n        *arg_8h = hgdiobj;\n    }\n    return uVar2;\n}\n",
        "token_count": 389
    },
    "004313af": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004313af(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint in_ECX;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = in_ECX;\n    if (arg_8h != NULL) goto code_r0x004313cb;\n    do {\n        fcn.0041638e();\ncode_r0x004313cb:\n    } while (*arg_8h == 0);\n    piVar1 = fcn.00424b9d();\n    if (piVar1 != NULL) {\n        var_14h = 0;\n        var_10h = 0;\n        var_ch = 0;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x54))(0, 0, 0x50800000, &var_14h, var_4h, arg_ch, arg_8h);\n        if (iVar2 != 0) {\n            uVar3 = fcn.00418023();\n            if ((uVar3 & 0x200) == 0) {\n                return piVar1;\n            }\n            fcn.00418069(0x200, 0, 0x20);\n            return piVar1;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 338
    },
    "00432524": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432524(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_ECX[0x32] == 0) {\n        uVar1 = in_ECX[0x39];\n        in_ECX[0x32] = 1;\n        if ((uVar1 & 4) != 0) {\n            arg_8h = 1;\n        }\n        in_ECX[0x39] = uVar1 & 0xfffffff3;\n        if ((arg_8h != 0) && (in_ECX[0x20] != NULL)) {\n            (**(*in_ECX[0x20] + 0x50))();\n        }\n        uVar1 = fcn.00418009();\n        if ((uVar1 & 0x2000) == 0) {\n            fcn.0041b2fb(0, 0xffff, 0xe900, 2, in_ECX + 0x1c, 0, 1);\n        }\n        else {\n            var_8h = 0x7fff;\n            var_4h = 0x7fff;\n            var_10h = 0;\n            var_ch = 0;\n            fcn.0041b2fb(0, 0xffff, 0xe900, 1, &var_10h, &var_10h, 0);\n            fcn.0041b2fb(0, 0xffff, 0xe900, 2, in_ECX + 0x1c, &var_10h, 1);\n            (**(*in_ECX + 0x68))(&var_10h, 0);\n            fcn.0041822e(0, 0, 0, var_8h - var_10h, var_4h - var_ch, 0x16);\n        }\n        in_ECX[0x32] = 0;\n    }\n    return;\n}\n",
        "token_count": 483
    },
    "004358cd": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004358cd(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar6 = *(in_ECX + 0xb0);\n    puVar1 = in_ECX + 0xb4;\n    uVar2 = *puVar1;\n    uVar3 = *(in_ECX + 0xb8);\n    uVar4 = *(in_ECX + 0xbc);\n    uVar5 = *(in_ECX + 0xc0);\n    *(in_ECX + 0xb0) = *arg_ch == 0;\n    (*_sym.imp.USER32.dll_CopyRect)(puVar1, arg_ch + 1);\n    fcn.0042ebc7(arg_8h, arg_ch);\n    *puVar1 = uVar2;\n    *(in_ECX + 0xb8) = uVar3;\n    *(in_ECX + 0xbc) = uVar4;\n    *(in_ECX + 0xc0) = uVar5;\n    *(in_ECX + 0xb0) = uVar6;\n    return;\n}\n",
        "token_count": 308
    },
    "0043a925": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043a925(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint var_ch;\n    \n    fcn.0043a33c(&var_ch);\n    fcn.00447077(*0x49be00, &var_ch, 0);\n    fcn.0043a4d9(arg_10h, arg_14h, &var_ch);\n    fcn.00447077(*0x49be08, &var_ch, 0);\n    fcn.00439c2c(arg_8h);\n    if (arg_ch != 0) {\n        iVar1 = fcn.0043a41d(&var_ch);\n        if (iVar1 != 0) {\n            fcn.00447077(*0x49be04, &var_ch, 0);\n            fcn.0043a4d9(arg_10h, arg_14h, &var_ch);\n            fcn.00447077(*0x49be0c, &var_ch, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 253
    },
    "00445ef4": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nbool fcn.00445ef4(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    iVar1 = fcn.0044a2be(0x445db2);\n    if (iVar1 != 0) goto code_r0x00445f35;\n    fcn.0041638e();\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(&lpMsg, 0, 0, 0, 0);\n        if (iVar2 == 0) break;\n        iVar2 = fcn.00437f42();\n        if (iVar2 == 0) {\n            return false;\n        }\ncode_r0x00445f35:\n    } while (*(iVar1 + 4) == 0);\n    return *(iVar1 + 4) == 0;\n}\n",
        "token_count": 191
    },
    "0044b51c": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lprcSrc1\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_3ch\n\nvoid __cdecl\nfcn.0044b51c(uint lprcSrc2, uint dx, uint dy, uint lprcSrc, uint arg_18h, uint arg_1ch, uint arg_20h, uint arg_24h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t unaff_EBP;\n    uint lprcSrc1;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x38);\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -0x34) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x2c) = vtable.CRgn.0;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -0x24) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.0044b2b5(*(unaff_EBP + 8));\n    fcn.004030d0(*(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0xc), -*(unaff_EBP + 0x10));\n    (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 8));\n    fcn.0044b2b5(unaff_EBP + -0x44);\n    uVar1 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n    fcn.00417780(uVar1);\n    fcn.0044b2f3(unaff_EBP + -0x2c, unaff_EBP + -0x24, 3);\n    if (*(unaff_EBP + 0x20) == 0) {\n        uVar1 = fcn.0044b3b2();\n        *(unaff_EBP + 0x20) = uVar1;\n    }\n    iVar2 = *(unaff_EBP + 0x20);\n    if (iVar2 == 0) {\n        fcn.0041638e();\n        iVar2 = extraout_ECX_00;\n    }\n    if (*(unaff_EBP + 0x24) == 0) {\n        *(unaff_EBP + 0x24) = iVar2;\n    }\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CRgn.0;\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 4;\n    if (*(unaff_EBP + 0x14) != 0) {\n        uVar1 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n        fcn.00417780(uVar1);\n        fcn.0044b2d3(*(unaff_EBP + 0x14));\n        (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, *(unaff_EBP + 0x14));\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0x18), -*(unaff_EBP + 0x1c));\n        (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 0x14));\n        fcn.0044b2d3(unaff_EBP + -0x44);\n        fcn.0044b2f3(unaff_EBP + -0x2c, unaff_EBP + -0x24, 3);\n        if (*(*(unaff_EBP + 0x20) + 4) == *(*(unaff_EBP + 0x24) + 4)) {\n            uVar1 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n            fcn.00417780(uVar1);\n            fcn.0044b2f3(unaff_EBP + -0x1c, unaff_EBP + -0x34, 3);\n        }\n    }\n    if ((*(*(unaff_EBP + 0x20) + 4) != *(*(unaff_EBP + 0x24) + 4)) && (*(unaff_EBP + 0x14) != 0)) {\n        fcn.0041721d(unaff_EBP + -0x1c);\n        (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n        uVar1 = fcn.004178bb(*(unaff_EBP + 0x24));\n        *(unaff_EBP + 0x14) = uVar1;\n        fcn.00447c89(*(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), \n                     *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n        fcn.004178bb(*(unaff_EBP + 0x14));\n    }\n    iVar2 = unaff_EBP + -0x14;\n    if (*(unaff_EBP + -0x10) == 0) {\n        iVar2 = unaff_EBP + -0x34;\n    }\n    fcn.0041721d(iVar2);\n    (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n    uVar1 = fcn.004178bb(*(unaff_EBP + 0x20));\n    *(unaff_EBP + 0x14) = uVar1;\n    fcn.00447c89(*(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), \n                 *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n    if (*(unaff_EBP + 0x14) != 0) {\n        fcn.004178bb(*(unaff_EBP + 0x14));\n    }\n    fcn.0041721d(0);\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x14) = vtable.CRgn.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x1c) = vtable.CRgn.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x24) = vtable.CRgn.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x2c) = vtable.CRgn.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x34) = vtable.CRgn.0;\n    fcn.00402550();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 2129
    },
    "0044ba55": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.0044ba55(void)\n\n{\n    uint arg_8h;\n    uint var_18h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4987a4 ^ &stack0xfffffffc;\n    arg_8h = (*_sym.imp.KERNEL32.dll_GetOEMCP)(&var_18h);\n    (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    fcn.0045843c(arg_8h);\n    return;\n}\n",
        "token_count": 111
    },
    "004563c5": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004563c5(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *(in_ECX + 0x5c) = 0xffffffff;\n    *(in_ECX + 0x60) = arg_8h;\n    *(in_ECX + 100) = arg_ch;\n    if (*(in_ECX + 0x20) != 0) {\n        uVar1 = fcn.00418009();\n        if ((uVar1 & 0x300000) != 0) {\n            fcn.00419c40(0, 0, 1);\n            fcn.00419c40(1, 0, 1);\n            fcn.00419d0b(3, 0);\n        }\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n    *(in_ECX + 0x68) = var_8h - lpRect;\n    *(in_ECX + 0x6c) = var_4h - var_ch;\n    if (*(in_ECX + 0x20) != 0) {\n        fcn.00455d52();\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 344
    },
    "004222b1": {
        "rules": [
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004222b1(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    \n    *in_ECX = 0x38;\n    fcn.004257a2(in_ECX + 2);\n    in_ECX[6] = *(arg_8h + 0x24);\n    in_ECX[7] = *(arg_8h + 0x38);\n    in_ECX[8] = *(arg_8h + 0x7c);\n    (**(*in_ECX[6] + 4))(in_ECX[6]);\n    (**(*in_ECX[7] + 4))(in_ECX[7]);\n    (**(*in_ECX[8] + 4))(in_ECX[8]);\n    in_ECX[10] = 0;\n    in_ECX[9] = 0;\n    uVar1 = *(arg_8h + 0x30);\n    in_ECX[0xd] = 0;\n    in_ECX[0xb] = uVar1;\n    in_ECX[0xc] = 1;\n    return;\n}\n",
        "token_count": 254
    },
    "004056a0": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004056a0(int32_t param_1)\n\n{\n    uint *puVar1;\n    \n    for (puVar1 = *(param_1 + 4); puVar1 != NULL; puVar1 = *puVar1) {\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.0042e050();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 143
    },
    "0040ea00": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040ea00(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CList_struct_HWND_____struct_HWND____.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 112
    },
    "0041632b": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041632b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.0041f5cb(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 99
    },
    "00417664": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00417664(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = NULL;\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CPaintDC.0;\n    pcVar1 = *(iVar2 + 0x20);\n    extraout_ECX[4] = pcVar1;\n    arg_8h_00 = (*_sym.imp.USER32.dll_BeginPaint)(pcVar1, extraout_ECX + 5);\n    iVar2 = fcn.004174ae(arg_8h_00);\n    if (iVar2 == 0) {\n        fcn.00416f76();\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 301
    },
    "0041c766": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0041c766(code **param_1)\n\n{\n    param_1[5] = NULL;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    fcn.00441d51();\n    return param_1;\n}\n",
        "token_count": 145
    },
    "0041e777": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041e777(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 126
    },
    "0041e861": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0041e861(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0042052a();\n    *(param_1 + 0x1c) = uVar1;\n    *(param_1 + 4) = 1;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x18) = 0;\n    return param_1;\n}\n",
        "token_count": 150
    },
    "0042c352": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c352(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    *in_ECX = vtable.CMapStringToPtr.0;\n    if (arg_8h < 1) {\n        arg_8h = 0xa;\n    }\n    in_ECX[1] = NULL;\n    in_ECX[2] = 0x11;\n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[5] = NULL;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 137
    },
    "0042c4a1": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042c4a1(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    uVar2 = 0;\n    if (*(param_1 + 4) != 0) {\n        if (*(param_1 + 8) != 0) {\n            do {\n                for (puVar3 = *(*(param_1 + 4) + uVar2 * 4); puVar3 != NULL; puVar3 = *puVar3) {\n                    if (puVar3 == 0xfffffff8) {\n                        fcn.0041638e();\n                        pcVar1 = swi(3);\n                        (*pcVar1)();\n                        return;\n                    }\n                    fcn.00416627(0);\n                }\n                uVar2 = uVar2 + 1;\n            } while (uVar2 < *(param_1 + 8));\n        }\n        fcn.00414b30(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.0042e050();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 299
    },
    "00433cf4": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00433cf4(uint *param_1)\n\n{\n    fcn.00450842();\n    param_1[6] = 0xffffffff;\n    param_1[5] = 0xffffffff;\n    *param_1 = 0;\n    param_1[8] = 0;\n    param_1[3] = 0;\n    param_1[2] = 0;\n    param_1[1] = 0;\n    param_1[4] = 0;\n    param_1[0x16] = 0;\n    param_1[7] = 0x7fff;\n    param_1[9] = 0;\n    (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 10);\n    param_1[0xe] = 0;\n    param_1[0x10] = 0;\n    param_1[0xf] = 0;\n    return param_1;\n}\n",
        "token_count": 216
    },
    "0043ec07": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0043ec07(code **param_1)\n\n{\n    *param_1 = vtable.CCommandLineInfo.0;\n    fcn.00401e60();\n    fcn.00401e60();\n    fcn.00401e60();\n    fcn.00401e60();\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[1] = 0x1;\n    return param_1;\n}\n",
        "token_count": 129
    },
    "00445dc7": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00445dc7(void)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00401e60();\n    *(unaff_EBP + -4) = 0;\n    iVar1 = fcn.00414af6(0xbc);\n    *(unaff_EBP + -0x14) = iVar1;\n    *(unaff_EBP + -4) = 1;\n    if (iVar1 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.0044775a(0, 0x40004, 0);\n    }\n    *extraout_ECX = iVar1;\n    *(*(iVar1 + 0x74) + 0x1c) = 1;\n    *(*(*extraout_ECX + 0x74) + 0x1e) = 0xffff;\n    extraout_ECX[0xd] = -1;\n    extraout_ECX[5] = 1;\n    extraout_ECX[8] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[1] = 0;\n    extraout_ECX[4] = 1;\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 402
    },
    "0044a9a7": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044a9a7(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.00414b30(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.0042e050();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 124
    },
    "0044ab66": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044ab66(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    *in_ECX = vtable.CMapPtrToPtr.0;\n    if (arg_8h < 1) {\n        arg_8h = 0xa;\n    }\n    in_ECX[1] = NULL;\n    in_ECX[2] = 0x11;\n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[5] = NULL;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 137
    },
    "0044b870": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b870(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[2] = NULL;\n    in_ECX[1] = NULL;\n    in_ECX[5] = NULL;\n    *in_ECX = vtable.CPtrList.0;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 108
    },
    "0044e4fe": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044e4fe(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.0042e050();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "0044d76f": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044d76f(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    in_ECX[1] = arg_8h;\n    *in_ECX = vtable.COleUILinkInfo.0;\n    in_ECX[2] = NULL;\n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[5] = NULL;\n    return;\n}\n",
        "token_count": 101
    },
    "0044e568": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044e568(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[2] = NULL;\n    in_ECX[1] = NULL;\n    in_ECX[5] = NULL;\n    *in_ECX = vtable.CObList.0;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 108
    },
    "0046e829": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.0046e829(uint *param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.0046e7f5();\n    *param_1 = 0x38;\n    param_1[2] = 0x400000;\n    param_1[1] = 0x400000;\n    param_1[3] = 0x900;\n    param_1[4] = 0x48521c;\n    iVar1 = fcn.0046e7aa();\n    if (iVar1 < 0) {\n        *0x499b80 = 1;\n    }\n    return param_1;\n}\n",
        "token_count": 148
    },
    "00410320": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00410320(int32_t param_1, uint param_2)\n\n{\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4) = 0;\n    fcn.0040f880(param_2, 0, 0xffffffff);\n    return param_1;\n}\n",
        "token_count": 96
    },
    "00410440": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00410440(int32_t param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 4) = 0;\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.0040f960(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 161
    },
    "0042038a": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042038a(uint arg_8h)\n\n{\n    uchar uVar1;\n    uint *puVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.0045af6e(0xc);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_STATE.0;\n    extraout_ECX[7] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[10] = NULL;\n    fcn.00401e60();\n    extraout_ECX[0x10] = NULL;\n    extraout_ECX[0x11] = NULL;\n    extraout_ECX[0x14] = 0xffffffff;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x1a] = NULL;\n    extraout_ECX[0x1b] = NULL;\n    uVar1 = *(unaff_EBP + 8);\n    extraout_ECX[10] = 0x20;\n    extraout_ECX[8] = 0x14;\n    extraout_ECX[6] = NULL;\n    *(extraout_ECX + 5) = uVar1;\n    *(unaff_EBP + -4) = 2;\n    fcn.00401eb0(0x1000);\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[0xc] = 0x1;\n    extraout_ECX[0x11] = 0x18;\n    pcVar3 = fcn.00414af6(0xc);\n    extraout_ECX[0x1e] = pcVar3;\n    iVar4 = fcn.0044a21f(0x188);\n    *(unaff_EBP + 8) = iVar4;\n    *(unaff_EBP + -4) = 4;\n    if (iVar4 == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = fcn.0042007c();\n    }\n    puVar2 = extraout_ECX[0x1e];\n    *(unaff_EBP + -4) = 1;\n    *puVar2 = uVar5;\n    iVar4 = fcn.0044a21f(100);\n    *(unaff_EBP + 8) = iVar4;\n    *(unaff_EBP + -4) = 5;\n    if (iVar4 == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = fcn.004202c0();\n    }\n    pcVar3 = extraout_ECX[0x1e];\n    *(unaff_EBP + -4) = 1;\n    *(pcVar3 + 4) = uVar5;\n    iVar4 = fcn.0044a21f(0x14);\n    *(unaff_EBP + 8) = iVar4;\n    *(unaff_EBP + -4) = 6;\n    if (iVar4 == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = fcn.00420343();\n    }\n    *(extraout_ECX[0x1e] + 8) = uVar5;\n    extraout_ECX[0x1f] = 0x1;\n    extraout_ECX[0x20] = NULL;\n    extraout_ECX[0x21] = NULL;\n    extraout_ECX[0x22] = NULL;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 886
    },
    "0042393a": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042393a(int32_t arg_8h)\n\n{\n    fcn.00423660(*(arg_8h + 0xc), *(arg_8h + 0x14), *(arg_8h + 0x1c), *(arg_8h + 0x18));\n    return;\n}\n",
        "token_count": 75
    },
    "0042457c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042457c(int32_t arg_8h)\n\n{\n    fcn.0042424a(*(arg_8h + 0xc), *(arg_8h + 0x14), *(arg_8h + 0x1c), *(arg_8h + 0x18));\n    return;\n}\n",
        "token_count": 76
    },
    "00437d4e": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00437d4e(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = *(arg_8h + 4);\n    if ((iVar2 == 0x200) || (iVar2 == 0xa0)) {\n        iVar2 = fcn.0041ff5e();\n        iVar3 = fcn.00437c86(*(arg_8h + 0x14), *(arg_8h + 0x18));\n        if ((iVar3 == 0) || (*(arg_8h + 4) != *(iVar2 + 0x54))) {\n            *(iVar2 + 0x4c) = *(arg_8h + 0x14);\n            *(iVar2 + 0x50) = *(arg_8h + 0x18);\n            *(iVar2 + 0x54) = *(arg_8h + 4);\n            uVar1 = 1;\n        }\n        else {\n            uVar1 = 0;\n        }\n    }\n    else if ((iVar2 == 0xf) || (iVar2 == 0x118)) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 295
    },
    "00438873": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438873(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    fcn.0042b032();\n    in_ECX[4] = arg_8h;\n    in_ECX[5] = NULL;\n    in_ECX[6] = NULL;\n    in_ECX[7] = NULL;\n    in_ECX[8] = NULL;\n    *in_ECX = vtable.CMemFile.0;\n    in_ECX[9] = 0x1;\n    return;\n}\n",
        "token_count": 119
    },
    "00438ab7": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438ab7(int32_t *param_1)\n\n{\n    param_1[4] = 0;\n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[7] = 0;\n    if ((param_1[8] != 0) && (param_1[9] != 0)) {\n        (**(*param_1 + 0x60))(param_1[8]);\n    }\n    param_1[8] = 0;\n    return;\n}\n",
        "token_count": 125
    },
    "00438bcc": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00438bcc(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CMemFile.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[8] != NULL) {\n        fcn.00438ab7();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    fcn.0042b1bf();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 209
    },
    "0044ac7b": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0044ac7b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    int32_t arg_ch_00;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    pcVar1 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CHandleMap.0;\n    fcn.00457bdc(*(pcVar1 + 4), 0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.0044ab66(10);\n    *(unaff_EBP + -4) = 1;\n    fcn.0044ab66(4);\n    arg_ch_00 = 0;\n    *(unaff_EBP + -4) = 2;\n    if (*(unaff_EBP + 0xc) != 0) goto code_r0x0044acd0;\n    do {\n        arg_ch_00 = fcn.0041638e();\ncode_r0x0044acd0:\n    } while (*(unaff_EBP + 0x10) == arg_ch_00);\n    fcn.0044a949(7, arg_ch_00);\n    extraout_ECX[5] = *(unaff_EBP + 0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x10);\n    extraout_ECX[0x16] = *(unaff_EBP + 0x14);\n    extraout_ECX[0x17] = *(unaff_EBP + 0x18);\n    extraout_ECX[0x15] = pcVar1;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 473
    },
    "0042231b": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042231b(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.0044557a(arg_8h);\n    if (iVar1 == 0) {\n        fcn.00422135(*0x497420);\n        fcn.0042218b(0x80005);\n        fcn.004221a7(in_ECX + 0x73);\n        iVar1 = fcn.004423f1();\n        in_ECX[0x1a] = iVar1;\n        (*_sym.imp.SHELL32.dll_DragAcceptFiles)(in_ECX[8], 1);\n        fcn.00411aa0(2, 1);\n        (**(*in_ECX + 0x1a0))();\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = 0xffffffff;\n    }\n    return uVar2;\n}\n",
        "token_count": 220
    },
    "00425537": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00425537(uint arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar1 = in_ECX + 0x28;\n    piVar2 = *ppiVar1;\n    *(in_ECX + 0x34) = 0;\n    var_4h = in_ECX;\n    if (piVar2 != NULL) {\n        var_4h = 0;\n        var_8h = in_ECX;\n        (**(*piVar2 + 0x20))(piVar2, &var_8h, 0, &var_4h);\n        if (var_4h != 0) {\n            fcn.004469e6(&var_4h);\n        }\n        (**(**ppiVar1 + 0x1c))(*ppiVar1, var_8h, 0, 0);\n        fcn.004469e6(ppiVar1);\n    }\n    ppiVar1 = in_ECX + 0x24;\n    piVar2 = *ppiVar1;\n    if (piVar2 != NULL) {\n        if (*(in_ECX + 0x40) != 0) {\n            (**(*piVar2 + 0x50))(piVar2, *(in_ECX + 0x40));\n            *(in_ECX + 0x40) = 0;\n        }\n        uVar3 = (**(**ppiVar1 + 0x18))(*ppiVar1, arg_8h);\n        *(in_ECX + 0x34) = uVar3;\n        fcn.004469e6(ppiVar1);\n    }\n    fcn.004469e6(in_ECX + 0x38);\n    fcn.004469e6(in_ECX + 0x3c);\n    if (*(in_ECX + 0x60) != 0) {\n        fcn.00446b65();\n        *(in_ECX + 0x60) = 0;\n        if (*(in_ECX + 100) != 0) {\n            fcn.00446b65();\n            *(in_ECX + 100) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 521
    },
    "0043220a": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043220a(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.0041638e();\n    }\n    iVar1 = fcn.00409ef0();\n    if (iVar1 == in_ECX) {\n        (**(*arg_8h + 4))(*(in_ECX + 0x68) != 0);\n    }\n    else {\n        arg_8h[7] = 1;\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "00439559": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a",
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00439559(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExA;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)\n                          (var_4h, *(param_1 + 0x54), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 0x68), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 380
    },
    "0043f428": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint fcn.0043f428(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    \n    uVar3 = 1;\n    iVar1 = fcn.0042052a();\n    fcn.0044b9be(0);\n    for (piVar2 = *(iVar1 + 0x24); piVar2 != NULL; piVar2 = piVar2[8]) {\n        iVar1 = (**(*piVar2 + 0x50))();\n        if (iVar1 == 0) {\n            iVar1 = fcn.0043efda(piVar2 + 10, 0x485000);\n            if (iVar1 != 0) {\n                iVar1 = (**(*piVar2 + 0x54))();\n                if (iVar1 == 0) {\n                    uVar3 = 0;\n                }\n            }\n        }\n    }\n    fcn.0044ba30(0);\n    return uVar3;\n}\n",
        "token_count": 220
    },
    "00442519": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00442519(uint wParam)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    \n    iVar2 = fcn.004379b3();\n    piVar1 = *(iVar2 + 0x40);\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0x50))();\n    }\n    uVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x20), 0x432, wParam, 0);\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0x54))();\n    }\n    return uVar3;\n}\n",
        "token_count": 164
    },
    "004428ca": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004428ca(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    fcn.0044b900(arg_8h);\n    *(arg_8h + 0x54) = in_ECX;\n    (**(*in_ECX + 0x68))();\n    return;\n}\n",
        "token_count": 76
    },
    "004428ef": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004428ef(int32_t arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    \n    arg_8h_00 = fcn.0044b847(arg_8h, 0);\n    fcn.0044b802(arg_8h_00);\n    *(arg_8h + 0x54) = 0;\n    (**(*in_ECX + 0x68))();\n    return;\n}\n",
        "token_count": 109
    },
    "00446d4c": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00446d4c(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_58h;\n    uint var_24h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x4c);\n    iVar3 = *(unaff_EBP + 8);\n    piVar1 = *(unaff_EBP + 0xc);\n    if ((*(iVar3 + 0x10) & 1) != 0) {\n        iVar2 = *extraout_ECX;\n        *(unaff_EBP + 0xc) = piVar1[1];\n        iVar3 = (**(iVar2 + 0x50))(iVar3, unaff_EBP + 0xc);\n        if (iVar3 != 0) {\n            iVar3 = *(unaff_EBP + 0xc);\n            *piVar1 = 1;\n            piVar1[1] = iVar3;\n            goto code_r0x00446e7f;\n        }\n        fcn.004550dd(2, 0x1000);\n        *(unaff_EBP + -4) = 0;\n        if (*piVar1 == 1) {\n            fcn.00455142(piVar1[1], 0);\n        }\n        iVar3 = (**(*extraout_ECX + 0x54))(*(unaff_EBP + 8), unaff_EBP + -0x58);\n        if (iVar3 != 0) {\n            *piVar1 = 1;\n            iVar3 = fcn.004551fc();\n            *(unaff_EBP + -4) = 0xffffffff;\n            piVar1[1] = iVar3;\n            fcn.0045510b();\n            goto code_r0x00446e7f;\n        }\n        if (*piVar1 == 1) {\n            fcn.004551fc();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0045510b();\n        iVar3 = *(unaff_EBP + 8);\n    }\n    if ((*(iVar3 + 0x10) & 4) == 0) goto code_r0x00446e7f;\n    fcn.004497ef(0);\n    iVar3 = *piVar1;\n    *(unaff_EBP + -4) = 1;\n    if (iVar3 == 4) {\n        fcn.00449566(piVar1[1]);\ncode_r0x00446e20:\n        iVar3 = (**(*extraout_ECX + 0x54))(*(unaff_EBP + 8), unaff_EBP + -0x24);\n        if (iVar3 != 0) {\n            *piVar1 = 4;\n            iVar3 = fcn.0044955e();\n            *(unaff_EBP + -4) = 0xffffffff;\n            piVar1[1] = iVar3;\n            fcn.004496c9();\n            goto code_r0x00446e7f;\n        }\n    }\n    else {\n        iVar3 = fcn.00449628(0);\n        if (iVar3 != 0) goto code_r0x00446e20;\n        fcn.00416356();\n    }\n    if (*piVar1 == 4) {\n        fcn.0044955e();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004496c9();\ncode_r0x00446e7f:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 839
    },
    "0045164a": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045164a(int32_t param_1)\n\n{\n    int32_t var_8h;\n    int32_t iStack8;\n    \n    var_8h = param_1;\n    iStack8 = param_1;\n    fcn.00451501();\n    (**(**(param_1 + 0x68) + 0x140))(&var_8h, *(param_1 + 0x40) - *(param_1 + 0x38), 0x42);\n    fcn.00435497(*(param_1 + 0x68), *(param_1 + 0x48), *(param_1 + 0x4c), *(param_1 + 0x70) & 0x40 | 0x2004);\n    return;\n}\n",
        "token_count": 179
    },
    "004179f5": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: hdc\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: lpvObject\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_52h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.004179f5(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint lpvObject;\n    uint var_60h;\n    uint var_5ch;\n    uint var_52h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint hdc;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x58);\n    *(unaff_EBP + -0x3c) = vtable.CDC.0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x4c) = vtable.CDC.0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    pcVar1 = _sym.imp.USER32.dll_GetSysColor;\n    *(unaff_EBP + -4) = 2;\n    uVar2 = (*pcVar1)(0x14);\n    fcn.004179b2(uVar2);\n    *(unaff_EBP + -4) = 3;\n    uVar2 = (*pcVar1)(0x10);\n    fcn.004179b2(uVar2);\n    *(unaff_EBP + -4) = 4;\n    iVar3 = fcn.00405030(0);\n    if (iVar3 != 0) {\n        iVar3 = fcn.00405030(0);\n        if (iVar3 != 0) {\n            iVar3 = *(unaff_EBP + 8);\n            (*_sym.imp.GDI32.dll_GetObjectA)(*(iVar3 + 4), 0x18, unaff_EBP + -100);\n            fcn.004177d8();\n            iVar4 = fcn.00417814(*(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), *(unaff_EBP + -0x54), *(unaff_EBP + -0x52)\n                                 , 0);\n            if (iVar4 != 0) {\n                iVar4 = fcn.00417814(*(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), 1, 1, 0);\n                if (iVar4 != 0) {\n                    uVar2 = fcn.00405070(iVar3);\n                    *(unaff_EBP + 8) = uVar2;\n                    iVar3 = fcn.00405070(unaff_EBP + -0x1c);\n                    *(unaff_EBP + -0x14) = iVar3;\n                    if ((*(unaff_EBP + 8) != 0) && (iVar3 != 0)) {\n                        uVar2 = (*_sym.imp.GDI32.dll_GetPixel)(*(unaff_EBP + -0x38), 0, 0);\n                        uVar2 = fcn.00416bf5(uVar2);\n                        pcVar1 = _sym.imp.GDI32.dll_BitBlt;\n                        *(unaff_EBP + -0x10) = uVar2;\n                        (*pcVar1)(*(unaff_EBP + -0x48), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                  *(unaff_EBP + -0x38), 0, 0, 0xcc0020);\n                        fcn.00416bf5(0xffffff);\n                        (*pcVar1)(*(unaff_EBP + -0x48), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                  *(unaff_EBP + -0x38), 0, 0, 0x1100a6);\n                        iVar3 = fcn.00405070(*(unaff_EBP + 0xc));\n                        if (iVar3 != 0) {\n                            fcn.0044b457(0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), *(unaff_EBP + 0x10));\n                            fcn.00416bf5(0xffffff);\n                            uVar2 = fcn.004178bb(unaff_EBP + -0x2c);\n                            *(unaff_EBP + 0xc) = uVar2;\n                            (*pcVar1)(*(unaff_EBP + -0x38), 1, 1, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                      *(unaff_EBP + -0x48), 0, 0, 0xe20746);\n                            fcn.004178bb(unaff_EBP + -0x24);\n                            (*pcVar1)(*(unaff_EBP + -0x38), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                      *(unaff_EBP + -0x48), 0, 0, 0xe20746);\n                            fcn.004178bb(*(unaff_EBP + 0xc));\n                            fcn.00416bf5(*(unaff_EBP + -0x10));\n                        }\n                        fcn.00405070(*(unaff_EBP + -0x14));\n                        fcn.00405070(*(unaff_EBP + 8));\n                    }\n                }\n            }\n        }\n    }\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x24) = vtable.CBrush.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x2c) = vtable.CBrush.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041752d();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041752d();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1917
    },
    "00417c4c": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: hdc\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_6ah\n// WARNING: Variable defined which should be unmapped: var_64h\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: lpvObject\n// WARNING: Variable defined which should be unmapped: var_78h\n// WARNING: Variable defined which should be unmapped: var_74h\n\nvoid __cdecl fcn.00417c4c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint lpvObject;\n    uint var_78h;\n    uint var_74h;\n    uint var_6ah;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint hdc;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x70);\n    *(unaff_EBP + -0x44) = vtable.CDC.0;\n    *(unaff_EBP + -0x40) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x54) = vtable.CDC.0;\n    *(unaff_EBP + -0x50) = 0;\n    *(unaff_EBP + -0x4c) = 0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x34) = vtable.CDC.0;\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -0x24) = vtable.CBrush.0;\n    *(unaff_EBP + -4) = 4;\n    iVar2 = fcn.00405030(0);\n    if (iVar2 != 0) {\n        iVar2 = fcn.00405030(0);\n        if (iVar2 != 0) {\n            iVar2 = fcn.00405030(0);\n            if (iVar2 != 0) {\n                iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(*(*(unaff_EBP + 8) + 4), 0x18, unaff_EBP + -0x7c);\n                if (iVar2 != 0) {\n                    fcn.004177d8();\n                    iVar2 = fcn.00417814(*(unaff_EBP + -0x78), *(unaff_EBP + -0x74), *(unaff_EBP + -0x6c), \n                                         *(unaff_EBP + -0x6a), 0);\n                    if (iVar2 != 0) {\n                        uVar3 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, 0x47a8d4);\n                        fcn.00417780(uVar3);\n                        fcn.004177ee(unaff_EBP + -0x1c);\n                        fcn.004177d8();\n                        fcn.00417814(*(unaff_EBP + -0x78), *(unaff_EBP + -0x74), 1, 1, 0);\n                        uVar3 = fcn.00405070(*(unaff_EBP + 8));\n                        *(unaff_EBP + 8) = uVar3;\n                        iVar2 = fcn.00405070(unaff_EBP + -0x1c);\n                        *(unaff_EBP + -0x14) = iVar2;\n                        if ((*(unaff_EBP + 8) != 0) && (iVar2 != 0)) {\n                            uVar3 = (*_sym.imp.GDI32.dll_GetPixel)(*(unaff_EBP + -0x40), 0, 0);\n                            uVar3 = fcn.00416bf5(uVar3);\n                            pcVar1 = _sym.imp.GDI32.dll_BitBlt;\n                            *(unaff_EBP + -0x10) = uVar3;\n                            (*pcVar1)(*(unaff_EBP + -0x50), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                      *(unaff_EBP + -0x40), 0, 0, 0xcc0020);\n                            fcn.00416bf5(0xffffff);\n                            (*pcVar1)(*(unaff_EBP + -0x50), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                      *(unaff_EBP + -0x40), 0, 0, 0xee0086);\n                            fcn.00416bf5(*(unaff_EBP + -0x10));\n                            iVar2 = fcn.00405070(*(unaff_EBP + 0xc));\n                            *(unaff_EBP + 0xc) = iVar2;\n                            if (iVar2 != 0) {\n                                uVar3 = fcn.00416cf0(*(unaff_EBP + 0x10));\n                                uVar4 = fcn.00416bf5(*(unaff_EBP + 0x14));\n                                *(unaff_EBP + 0x14) = uVar4;\n                                *(unaff_EBP + -0x5c) = *(unaff_EBP + -0x78);\n                                *(unaff_EBP + -0x58) = *(unaff_EBP + -0x74);\n                                *(unaff_EBP + -100) = 0;\n                                *(unaff_EBP + -0x60) = 0;\n                                fcn.004030f0(unaff_EBP + -100, unaff_EBP + -0x24);\n                                fcn.00416cf0(uVar3);\n                                fcn.00416bf5(*(unaff_EBP + 0x14));\n                                (*pcVar1)(*(unaff_EBP + -0x30), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                          *(unaff_EBP + -0x40), 0, 0, 0x660046);\n                                (*pcVar1)(*(unaff_EBP + -0x30), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                          *(unaff_EBP + -0x50), 0, 0, 0x8800c6);\n                                (*pcVar1)(*(unaff_EBP + -0x30), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                          *(unaff_EBP + -0x40), 0, 0, 0x660046);\n                            }\n                            fcn.00405070(*(unaff_EBP + 0xc));\n                            fcn.00405070(*(unaff_EBP + -0x14));\n                            fcn.00405070(*(unaff_EBP + 8));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x24) = vtable.CBrush.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    fcn.00402550();\n    *(unaff_EBP + -4) = 1;\n    fcn.0041752d();\n    *(unaff_EBP + -4) = 0;\n    fcn.0041752d();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041752d();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 2362
    },
    "0042bb0b": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042bb0b(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n    }\n    else {\n        fcn.0042ba76(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = in_ECX;\n        in_ECX[1] = in_ECX;\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "0043939f": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043939f(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    uint *in_ECX;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*in_ECX);\n    arg_8h_00 = *(in_ECX + 2);\n    fcn.00424d7f(arg_8h_00);\n    fcn.00424d7f(arg_8h_00);\n    fcn.00439273(*in_ECX, uVar1 & 0xffff);\n    return;\n}\n",
        "token_count": 138
    },
    "00409000": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00409000(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(param_2, param_3, param_1);\n    return iVar1 == 0;\n}\n",
        "token_count": 74
    },
    "00409020": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00409020(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(param_2, param_3, param_1);\n    return iVar1 == 0;\n}\n",
        "token_count": 74
    },
    "0042b0c7": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042b0c7(uint hKey, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    bool bVar4;\n    uint lpType;\n    uint lpData;\n    uint lpcbData;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar4 = false;\n    var_8h = 0;\n    lpData = fcn.00401eb0(0x104);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegOpenKeyA;\n    lpcbData = 0x104;\n    lpType = 0;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, \"CLSID\", &var_8h);\n    if (iVar3 == 0) {\n        var_4h = 0;\n        iVar3 = (*pcVar1)(var_8h, hKey, &var_4h);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar3 == 0) {\n            hKey = 0;\n            iVar3 = (*pcVar1)(var_4h, \"InProcServer32\", &hKey);\n            if (iVar3 == 0) {\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0x476744, 0, &lpType, lpData, &lpcbData);\n                bVar4 = iVar3 == 0;\n                (*pcVar2)(hKey);\n            }\n            (*pcVar2)(var_4h);\n        }\n        (*pcVar2)(var_8h);\n    }\n    fcn.00409070(0xffffffff);\n    return bVar4;\n}\n",
        "token_count": 400
    },
    "004395ec": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004395ec(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.00439559();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 163
    },
    "0046dd04": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0046dd04(void)\n\n{\n    *0x499ae4 = (*_sym.imp.KERNEL32.dll_CreateFileA)(\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 61
    },
    "00438447": {
        "rules": [
            "resume thread"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00438447(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *piVar2;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(4);\n    iVar1 = fcn.00414af6(0x44);\n    *(unaff_EBP + -0x10) = iVar1;\n    piVar2 = NULL;\n    *(unaff_EBP + -4) = 0;\n    if (iVar1 != 0) {\n        piVar2 = fcn.00437e29(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    iVar1 = fcn.0043833c(*(unaff_EBP + 0x18) | 4, *(unaff_EBP + 0x14), *(unaff_EBP + 0x1c));\n    if (iVar1 == 0) {\n        (**(*piVar2 + 0x78))();\n    }\n    else {\n        fcn.00437ca5(*(unaff_EBP + 0x10));\n        if ((*(unaff_EBP + 0x18) & 4) == 0) {\n            (*_sym.imp.KERNEL32.dll_ResumeThread)(piVar2[0xb]);\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 396
    },
    "004016f0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nchar * fcn.004016f0(char *param_1)\n\n{\n    char *pcVar1;\n    char cVar2;\n    \n    if (param_1 == NULL) {\n        return param_1;\n    }\n    pcVar1 = param_1 + 1;\n    do {\n        cVar2 = *param_1;\n        param_1 = param_1 + 1;\n    } while (cVar2 != '\\0');\n    return param_1 + -pcVar1;\n}\n",
        "token_count": 109
    },
    "004024f0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004024f0(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_1 == NULL) {\n        fcn.004023a0(0, 0);\n        return;\n    }\n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004023a0(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 132
    },
    "00402830": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00402830(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_2 == NULL) {\n        fcn.004023a0(0, 0);\n        return param_1;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004023a0(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 145
    },
    "00405ad0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00405ad0(int32_t param_1, uint param_2, uint *param_3)\n\n{\n    int32_t iVar1;\n    \n    if (param_3 == NULL) {\n        param_3 = *(param_1 + 4);\n    }\n    else {\n        param_3 = *param_3;\n    }\n    while( true ) {\n        if (param_3 == NULL) {\n            return NULL;\n        }\n        iVar1 = fcn.00405760();\n        if (iVar1 != 0) break;\n        param_3 = *param_3;\n    }\n    return param_3;\n}\n",
        "token_count": 143
    },
    "004061b0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.004061b0(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_1 == NULL) {\n        fcn.00404480(0, 0);\n        return;\n    }\n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00404480(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 130
    },
    "00406b70": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00406b70(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    if (param_2 == NULL) {\n        fcn.00404480(0, 0);\n        return param_1;\n    }\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00404480(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 144
    },
    "00407dd0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00407dd0(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    \n    iVar4 = 0;\n    bVar2 = false;\n    if (0 < *(param_1 + 0x134)) {\n        do {\n            if ((bVar2) || (piVar3 = *(param_1 + 0x130) + iVar4 * 4,  *(*(param_1 + 0x130) + iVar4 * 4) <= param_2)) {\n                piVar3 = *(param_1 + 0x130) + iVar4 * 4;\n                if (param_2 == *(*(param_1 + 0x130) + iVar4 * 4)) {\n                    return 0;\n                }\n                if (bVar2) goto code_r0x00407e0e;\n            }\n            else {\n                bVar2 = true;\ncode_r0x00407e0e:\n                iVar1 = *piVar3;\n                *piVar3 = param_2;\n                param_2 = iVar1;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < *(param_1 + 0x134));\n    }\n    *(*(param_1 + 0x130) + *(param_1 + 0x134) * 4) = param_2;\n    *(param_1 + 0x134) = *(param_1 + 0x134) + 1;\n    return 1;\n}\n",
        "token_count": 362
    },
    "0040f050": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040f050(code **param_1)\n\n{\n    uint *puVar1;\n    \n    *param_1 = vtable.CList_struct_HWND_____struct_HWND____.0;\n    for (puVar1 = param_1[1]; puVar1 != NULL; puVar1 = *puVar1) {\n    }\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    fcn.0042e050();\n    param_1[5] = NULL;\n    return;\n}\n",
        "token_count": 141
    },
    "00414af6": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00414af6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0045adaa(arg_8h);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x496b6c == NULL) break;\n        iVar1 = (**0x496b6c)(arg_8h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 123
    },
    "00414b25": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00414b25(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0045adaa(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x496b6c == NULL) break;\n        iVar1 = (**0x496b6c)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 118
    },
    "00414b8f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414b8f(uint hMenu, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t uPosition;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetMenuItemCount;\n    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(arg_ch);\n    iVar4 = (*pcVar2)(hMenu);\n    pcVar1 = _sym.imp.USER32.dll_GetSubMenu;\njoined_r0x00414baf:\n    do {\n        do {\n            iVar4 = iVar4 + -1;\n            if (iVar4 < 0) {\n                return;\n            }\n            iVar5 = (*pcVar1)(hMenu, iVar4);\n        } while (iVar5 == 0);\n        if (arg_10h != 0) {\n            iVar6 = (*pcVar2)(iVar5);\n            uPosition = 0;\n            if (0 < iVar6) {\n                do {\n                    iVar7 = (*pcVar1)(iVar5, uPosition);\n                    if (iVar7 == arg_10h) {\n                        (*_sym.imp.USER32.dll_RemoveMenu)(iVar5, uPosition, 0x400);\n                        arg_10h = 0;\n                        break;\n                    }\n                    uPosition = uPosition + 1;\n                } while (uPosition < iVar6);\n            }\n            goto joined_r0x00414baf;\n        }\n        uPosition = 0;\n        if (0 < iVar3) {\n            do {\n                iVar6 = (*pcVar1)(arg_ch, uPosition);\n                if (iVar6 == iVar5) {\n                    (*_sym.imp.USER32.dll_RemoveMenu)(hMenu, iVar4, 0x400);\n                    break;\n                }\n                uPosition = uPosition + 1;\n            } while (uPosition < iVar3);\n        }\n    } while( true );\n}\n",
        "token_count": 470
    },
    "00415526": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415526(int32_t arg_8h)\n\n{\n    uint uVar1;\n    \n    if (arg_8h == 0) {\n        return;\n    }\n    if (arg_8h == 0xc) {\n        uVar1 = 0x8007000e;\n    }\n    else {\n        if (arg_8h == 0x16) goto code_r0x00415550;\n        if (arg_8h == 0x22) goto code_r0x00415550;\n        if (arg_8h == 0x50) {\n            return;\n        }\n        uVar1 = 0x80004005;\n    }\n    do {\n        fcn.00401000(uVar1);\ncode_r0x00415550:\n        uVar1 = 0x80070057;\n    } while( true );\n}\n",
        "token_count": 192
    },
    "00416974": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00416974(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (-1 < arg_8h) goto code_r0x00416989;\n    do {\n        fcn.0041638e();\ncode_r0x00416989:\n        if (arg_8h < *(in_ECX + 8)) goto code_r0x004169b2;\n    } while (((*(in_ECX + 0xc) <= arg_8h) && (*(in_ECX + 4) <= arg_ch)) &&\n            (arg_ch < *(in_ECX + 4) + *(in_ECX + 0xc) * 4));\n    fcn.004166d5(arg_8h + 1, 0xffffffff);\ncode_r0x004169b2:\n    fcn.00407a00(arg_ch);\n    return;\n}\n",
        "token_count": 203
    },
    "0041992f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041992f(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *extraout_ECX;\n    int32_t unaff_ESI;\n    \n    iVar2 = 0x7fffffff;\n    iVar1 = unaff_ESI;\n    if (arg_8h == 0x7fffffff) goto code_r0x00419952;\n    if (*in_ECX == 0x7fffffff) goto code_r0x00419950;\n    if (*in_ECX == arg_8h) goto code_r0x00419950;\n    do {\n        iVar2 = fcn.0041638e();\n        in_ECX = extraout_ECX;\ncode_r0x00419950:\n        *in_ECX = arg_8h;\n        iVar1 = unaff_ESI;\ncode_r0x00419952:\n        arg_8h = iVar1;\n        unaff_ESI = arg_8h;\n    } while (*in_ECX == iVar2);\n    fcn.0044b9be(*in_ECX);\n    return;\n}\n",
        "token_count": 258
    },
    "00419b49": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00419b49(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t nPos;\n    \n    if (arg_8h == 0) {\n        fcn.0041638e();\n    }\n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n    nPos = 0;\n    if (0 < iVar1) {\n        do {\n            iVar2 = fcn.00412d20(nPos);\n            if (iVar2 == 0) {\n                iVar2 = fcn.00419891(nPos);\n                if (iVar2 == arg_ch) goto code_r0x00419bab;\n            }\n            else {\n                if (*(iVar2 + 4) == arg_ch) {\ncode_r0x00419bab:\n                    iVar1 = fcn.00429ddd(*(arg_8h + 4));\n                    return iVar1;\n                }\n                iVar2 = fcn.00419b49(iVar2, arg_ch);\n                if (iVar2 != 0) {\n                    return iVar2;\n                }\n            }\n            nPos = nPos + 1;\n        } while (nPos < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 289
    },
    "0041b21a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041b21a(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t arg_8h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    if ((param_1 == 0) || (arg_8h = *(param_1 + 0x20),  arg_8h == 0)) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_8h, 0xfffffff0);\n    while ((uVar2 & 0x40000000) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(arg_8h);\n        if (iVar3 == 0) break;\n        uVar2 = (*pcVar1)(iVar3, 0xfffffff0);\n        arg_8h = iVar3;\n    }\n    uVar4 = fcn.0041af14(arg_8h);\n    return uVar4;\n}\n",
        "token_count": 249
    },
    "0041b282": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b282(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.0041b282(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return;\n        }\n        if (arg_10h == 0) {\n            fcn.0041af14(iVar2);\n            return;\n        }\n        iVar2 = fcn.0041af40();\n        if (iVar2 != 0) {\n            return;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return;\n        }\n        iVar3 = fcn.0041b282(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return;\n}\n",
        "token_count": 318
    },
    "0041b447": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b447(int32_t arg_8h, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *arg_ch;\n    while( true ) {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        piVar1 = fcn.0041af40(iVar3);\n        if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x108))(arg_ch),  iVar2 != 0)) break;\n        if (iVar3 == arg_8h) {\n            return 0;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar3);\n    }\n    return 1;\n}\n",
        "token_count": 179
    },
    "0041b5bd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0041b5bd(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 129
    },
    "0041b98e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0041b98e(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    int32_t *piVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if ((param_1 != 0) && (iVar2 = *(param_1 + 0x20),  iVar2 != 0)) {\n        while( true ) {\n            arg_8h = (*pcVar1)(iVar2);\n            piVar3 = fcn.0041af14(arg_8h);\n            if ((piVar3 == NULL) || (iVar2 = (**(*piVar3 + 0x128))(),  iVar2 != 0)) break;\n            iVar2 = piVar3[8];\n        }\n        return piVar3;\n    }\n    return NULL;\n}\n",
        "token_count": 198
    },
    "0041c59b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041c59b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_8h;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x20),  *(param_1 + 0x20) != 0)) {\n        do {\n            arg_8h = iVar1;\n            iVar1 = fcn.0041c551(arg_8h);\n        } while (iVar1 != 0);\n        uVar2 = fcn.0041af14(arg_8h);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 153
    },
    "00420b12": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00420b12(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetDlgItem;\n    if (((in_ECX[0x16] & 0x1000020U) != 0) &&\n       (((iVar3 = (*_sym.imp.USER32.dll_GetDlgItem)(in_ECX[8], arg_8h),  pcVar1 = _sym.imp.USER32.dll_GetWindowLongA, \n         iVar3 == 0 || (uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0),  (uVar4 & 0x10000000) == 0))\n        || (iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar3 == 0)))) {\n        arg_8h = 0;\n        do {\n            uVar5 = (*pcVar2)(in_ECX[8], *(arg_8h * 4 + 0x47b77c));\n            uVar4 = (*pcVar1)(uVar5, 0xfffffff0);\n            if (((uVar4 & 0x10000000) != 0) && (iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(uVar5),  iVar3 != 0)) {\n                uVar6 = (*_sym.imp.USER32.dll_GetFocus)();\n                iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(uVar6);\n                if (iVar3 == 0) {\n                    (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n                }\n                (**(*in_ECX + 0x118))(0x401, *(arg_8h * 4 + 0x47b77c), arg_ch);\n                return;\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h < 4);\n    }\n    fcn.0041ae6e();\n    return;\n}\n",
        "token_count": 497
    },
    "0042300f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042300f(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_30h;\n    uint var_4h;\n    \n    fcn.0045afa4(0x44);\n    iVar2 = (**(*extraout_ECX + 0x144))();\n    if (iVar2 != 0) {\n        fcn.00422f6f();\n        iVar3 = (**(**(iVar2 + 0x68) + 0x10))(*(iVar2 + 0x68));\n        *(unaff_EBP + -0x4c) = 0;\n        *(unaff_EBP + -0x50) = iVar3;\n        if (0 < iVar3) {\n            do {\n                fcn.00421c53();\n                piVar1 = *(iVar2 + 0x68);\n                iVar3 = *piVar1;\n                *(unaff_EBP + -4) = 0;\n                iVar3 = (**(iVar3 + 0x18))(piVar1, *(unaff_EBP + -0x4c), unaff_EBP + -0x48, 7);\n                if (iVar3 == 0) {\n                    iVar3 = fcn.00421e5c(*(unaff_EBP + -0x30));\n                    if (iVar3 == 0) {\n                        iVar3 = (**(*extraout_ECX + 0x140))(unaff_EBP + -0x48);\n                        fcn.00425608();\n                    }\n                    *(iVar3 + 0x80) = 1;\n                }\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00421c72();\n                *(unaff_EBP + -0x4c) = *(unaff_EBP + -0x4c) + 1;\n            } while (*(unaff_EBP + -0x4c) < *(unaff_EBP + -0x50));\n        }\n        fcn.00422fba();\n    }\n    extraout_ECX[0x3c] = 0;\n    fcn.0045b027();\n    return;\n}\n",
        "token_count": 537
    },
    "00424c12": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00424c12(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint *extraout_ECX;\n    uint unaff_EBP;\n    \n    if (param_1 != NULL) goto code_r0x00424c20;\n    do {\n        fcn.0041638e();\n        param_1 = extraout_ECX;\ncode_r0x00424c20:\n        iVar1 = (***param_1)();\n    } while (iVar1 == 0);\n    if (iVar1 != 0) goto code_r0x00424bf7;\n    do {\n        iVar1 = fcn.0041638e(unaff_EBP);\ncode_r0x00424bf7:\n    } while (param_2 == 0);\n    do {\n        if (iVar1 == param_2) {\n            return 1;\n        }\n        iVar1 = *(iVar1 + 0x10);\n    } while (iVar1 != 0);\n    return 0;\n}\n",
        "token_count": 227
    },
    "00424f5f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00424f5f(uint arg_8h)\n\n{\n    uint arg_ch;\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0xc);\n    if ((~*(extraout_ECX + 0x18) & 1) == 0) {\n        if (*(extraout_ECX + 0x38) != 0) goto code_r0x0042504d;\n        iVar1 = fcn.00414af6(0x14);\n        *(unaff_EBP + -0x18) = iVar1;\n        *(unaff_EBP + -4) = 1;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.0042c1e0();\n        }\n        arg_ch = *(extraout_ECX + 0x40);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x38) = uVar2;\n        fcn.00445b33(1, arg_ch);\n        iVar1 = *(extraout_ECX + 0x38);\n        if (0 < *(iVar1 + 8)) goto code_r0x00425026;\n        do {\n            iVar1 = fcn.0041638e();\ncode_r0x00425026:\n            **(iVar1 + 4) = 0;\n            *(extraout_ECX + 0x34) = 1;\n            *(unaff_EBP + -0x10) = 0;\n            fcn.00424e8b(unaff_EBP + -0x10);\n            *(unaff_EBP + -0x18) = 0;\n            fcn.00424ca9(0, unaff_EBP + -0x18, 1);\ncode_r0x0042504d:\n            if (*(unaff_EBP + 8) == 0) goto code_r0x00425096;\n            fcn.00424c7e();\n            fcn.0042c207(*(extraout_ECX + 0x34), *(unaff_EBP + 8), 1);\n            *(unaff_EBP + -0x14) = 0;\n            fcn.0044aa72(1, unaff_EBP + -0x14);\n        } while (*(unaff_EBP + -0x14) == 0);\n        uVar2 = *(extraout_ECX + 0x34);\n        *(unaff_EBP + 8) = 2;\n        fcn.00424ca9(uVar2, unaff_EBP + 8, 1);\n    }\n    else {\n        if (*(extraout_ECX + 0x38) == 0) {\n            iVar1 = fcn.00414af6(0x1c);\n            *(unaff_EBP + -0x18) = iVar1;\n            *(unaff_EBP + -4) = 0;\n            if (iVar1 == 0) {\n                uVar2 = 0;\n            }\n            else {\n                uVar2 = fcn.0044ab66(*(extraout_ECX + 0x40));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(extraout_ECX + 0x38) = uVar2;\n            fcn.0044a949(*(extraout_ECX + 0x44), 1);\n            puVar3 = fcn.0044abf4(0);\n            *puVar3 = 0;\n            *(extraout_ECX + 0x34) = 1;\n        }\n        if (*(unaff_EBP + 8) == 0) goto code_r0x00425096;\n        fcn.00424c7e();\n        puVar3 = fcn.0044abf4(*(unaff_EBP + 8));\n        *puVar3 = *(extraout_ECX + 0x34);\n    }\n    *(extraout_ECX + 0x34) = *(extraout_ECX + 0x34) + 1;\ncode_r0x00425096:\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1050
    },
    "0042585d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042585d(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t arg_8h_00;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    arg_8h_00 = 0;\n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    iVar1 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(0, 1, &var_4h);\n    if (iVar1 == 0) goto code_r0x00425882;\n    while( true ) {\n        do {\n            fcn.00415123(arg_8h_00);\ncode_r0x00425882:\n            arg_8h_00 = (*_sym.imp.ole32.dll_StgCreateDocfileOnILockBytes)(var_4h, 0x1012, 0, &var_8h);\n            (**(*var_4h + 8))(var_4h);\n        } while (arg_8h_00 != 0);\n        in_ECX = fcn.004469c0(in_ECX[9], 0x485050);\n        arg_8h_00 = (*_sym.imp.ole32.dll_OleSave)(in_ECX, var_8h, 0);\n        (**(*in_ECX + 0x20))(in_ECX, 0);\n        (**(*in_ECX + 8))(in_ECX);\n        if (arg_8h_00 == 0) break;\n        (**(*var_8h + 8))(var_8h);\n    }\n    arg_8h[2] = 0;\n    *arg_8h = 8;\n    arg_8h[1] = var_8h;\n    return;\n}\n",
        "token_count": 416
    },
    "00425bda": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00425bda(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t var_4h;\n    \n    piVar1 = *(param_1 + 0x20);\n    iVar3 = piVar1[0x1c];\n    var_4h = param_1;\n    while( true ) {\n        var_4h = (**(*piVar1 + 0xb4))();\n        iVar2 = fcn.004270c5(&var_4h);\n        if (iVar2 == 0) break;\n        do {\n            if (*(iVar2 + 0x2c) == iVar3) break;\n            iVar2 = fcn.004270c5(&var_4h);\n        } while (iVar2 != 0);\n        if (iVar2 == 0) break;\n        iVar3 = iVar3 + 1;\n    }\n    piVar1[0x1c] = iVar3 + 1;\n    return iVar3;\n}\n",
        "token_count": 238
    },
    "0042a69b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a69b(int32_t *hWnd, int32_t arg_ch, int32_t *arg_10h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    piVar2 = hWnd;\n    fcn.0042a5a4(arg_ch);\n    fcn.00417f7f(arg_ch, &hWnd);\n    if (*piVar2 != 0) {\n        *arg_10h = -1;\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    arg_ch = 0;\n    while( true ) {\n        uVar3 = (*pcVar1)(hWnd, 0x87, 0, 0);\n        if ((uVar3 & 0x40) != 0) {\n            if (*piVar2 == 0) {\n                (*pcVar1)(hWnd, 0xf1, arg_ch == *arg_10h, 0);\n            }\n            else {\n                iVar4 = (*pcVar1)(hWnd, 0xf0, 0, 0);\n                if (iVar4 != 0) {\n                    *arg_10h = arg_ch;\n                }\n            }\n            arg_ch = arg_ch + 1;\n        }\n        hWnd = (*_sym.imp.USER32.dll_GetWindow)(hWnd, 2);\n        if (hWnd == NULL) break;\n        uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0);\n        if ((uVar3 & 0x20000) != 0) {\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 380
    },
    "0042ab7a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ab7a(uint param_1, int32_t param_2)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *unaff_EDI;\n    \n    iVar1 = 0;\n    iVar2 = param_2;\n    if (param_2 != 0) {\n        do {\n            if (*in_EAX == '\\0') break;\n            in_EAX = in_EAX + 1;\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n        if (iVar2 != 0) goto code_r0x0042ab98;\n    }\n    iVar1 = -0x7ff8ffa9;\ncode_r0x0042ab98:\n    if (unaff_EDI != NULL) {\n        if (-1 < iVar1) {\n            *unaff_EDI = param_2 - iVar2;\n            return;\n        }\n        *unaff_EDI = 0;\n    }\n    return;\n}\n",
        "token_count": 228
    },
    "0042bb68": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042bb68(uint lpFileTime, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    uint lpSystemTime;\n    uint lpLocalFileTime;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_FileTimeToLocalFileTime)(lpFileTime, &lpLocalFileTime);\n    if (iVar1 != 0) goto code_r0x0042bb95;\n    do {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n        lpFileTime = 0x80070057;\n        fcn.00401000();\ncode_r0x0042bb95:\n        iVar1 = (*_sym.imp.KERNEL32.dll_FileTimeToSystemTime)(&lpLocalFileTime, &lpSystemTime, lpFileTime);\n    } while (iVar1 == 0);\n    fcn.0042bb0b(&lpSystemTime, arg_ch);\n    *in_ECX = var_8h;\n    in_ECX[1] = var_4h;\n    return;\n}\n",
        "token_count": 250
    },
    "0042c3f8": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0042c3f8(uint arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint *puVar3;\n    \n    uVar2 = fcn.0042c326(arg_8h);\n    *arg_10h = uVar2;\n    uVar2 = uVar2 % *(in_ECX + 8);\n    *arg_ch = uVar2;\n    if (*(in_ECX + 4) != 0) {\n        for (puVar3 = *(*(in_ECX + 4) + uVar2 * 4); puVar3 != NULL; puVar3 = *puVar3) {\n            if ((puVar3[1] == *arg_10h) && (cVar1 = fcn.0042c385(puVar3 + 2, arg_8h),  cVar1 != '\\0')) {\n                return puVar3;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 244
    },
    "0042c4ff": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042c4ff(code **param_1)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    *param_1 = vtable.CMapStringToPtr.0;\n    pcVar1 = NULL;\n    if (param_1[1] != NULL) {\n        if (param_1[2] != NULL) {\n            do {\n                for (puVar2 = *(param_1[1] + pcVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    if (puVar2 == 0xfffffff8) {\n                        fcn.0041638e();\n                        pcVar1 = swi(3);\n                        (*pcVar1)();\n                        return;\n                    }\n                    fcn.00416627(0);\n                }\n                pcVar1 = pcVar1 + 1;\n            } while (pcVar1 < param_1[2]);\n        }\n        fcn.00414b30(param_1[1]);\n        param_1[1] = NULL;\n    }\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    fcn.0042e050();\n    param_1[5] = NULL;\n    return;\n}\n",
        "token_count": 277
    },
    "0042d7ff": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0042d7ff(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = 0;\n    iVar5 = 0;\n    if (0x5ffff < *0x49776c) {\n        uVar3 = fcn.0042cb8f();\n        iVar5 = fcn.00414af6(-(uVar3 * 4 >> 0x20 != 0) | uVar3 * 4);\n        uVar4 = 0;\n        if (uVar3 != 0) {\n            do {\n                uVar1 = fcn.0042c9b8(uVar4);\n                *(iVar5 + uVar4 * 4) = uVar1;\n                fcn.0042d15f(uVar4, uVar1 & 0xfffffff7);\n                uVar4 = uVar4 + 1;\n            } while (uVar4 < uVar3);\n        }\n    }\n    uVar2 = fcn.0041ae6e();\n    if (iVar5 != 0) {\n        uVar4 = 0;\n        if (uVar3 != 0) {\n            do {\n                fcn.0042d15f(uVar4, *(iVar5 + uVar4 * 4));\n                uVar4 = uVar4 + 1;\n            } while (uVar4 < uVar3);\n        }\n        fcn.00414b30(iVar5);\n    }\n    return uVar2;\n}\n",
        "token_count": 370
    },
    "0042e050": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042e050(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.00414b30(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 90
    },
    "0042e1b0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042e1b0(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if ((-1 < arg_8h) && (-1 < arg_ch)) goto code_r0x0042e1cd;\n    do {\n        do {\n            fcn.0041638e();\ncode_r0x0042e1cd:\n        } while ((*(in_ECX + 0x78) == 0) && (*(in_ECX + 0x74) != 0));\n        if (arg_8h < 1) goto code_r0x0042e1f1;\n    } while (arg_ch < 1);\n    iVar1 = fcn.00458674(arg_8h, arg_ch);\n    if (iVar1 != 0) {\ncode_r0x0042e1f1:\n        fcn.004585e6(*(in_ECX + 0x78));\n        *(in_ECX + 0x78) = iVar1;\n        *(in_ECX + 0x74) = arg_8h;\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 277
    },
    "00430b17": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430b17(int32_t arg_8h, int32_t arg_ch)\n\n{\n    do {\n        if (arg_8h == arg_ch) {\n            return 1;\n        }\n        arg_ch = fcn.0041c551(arg_ch);\n    } while (arg_ch != 0);\n    return 0;\n}\n",
        "token_count": 78
    },
    "004331e9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004331e9(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_21ch;\n    uint var_4h;\n    \n    fcn.0045afda(0x214);\n    *(unaff_EBP + -0x21c) = extraout_ECX;\n    *extraout_ECX = vtable.CFrameWnd.0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00432d12();\n    iVar1 = fcn.0041ff5e();\n    while (*(iVar1 + 0xec) == extraout_ECX) {\n        fcn.00431075();\n    }\n    if (extraout_ECX[0x2f] != NULL) {\n        fcn.00414b30(extraout_ECX[0x2f]);\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0;\n    fcn.0044b898();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b863();\n    fcn.0045b036();\n    return;\n}\n",
        "token_count": 311
    },
    "004335d7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Variable defined which should be unmapped: var_80h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: dy\n// WARNING: Variable defined which should be unmapped: lprc\n// WARNING: Variable defined which should be unmapped: hmenu\n// WARNING: Variable defined which should be unmapped: var_78h\n\nvoid __cdecl fcn.004335d7(uint arg_8h, uint hWnd, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    code **arg_ch;\n    uint *puVar6;\n    uint *puVar7;\n    int32_t **ppiVar8;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_180h;\n    uint var_17ch;\n    uint var_160h;\n    uint var_11ch;\n    uint lprcSrc;\n    uint lprcDst;\n    uint lprcSrc2;\n    uint lpmi;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_cch;\n    uint var_bch;\n    uint var_b8h;\n    uint var_ach;\n    uint var_98h;\n    uint var_8ch;\n    uint lprcSrc1;\n    uint var_80h;\n    uint var_78h;\n    uint hmenu;\n    uint lprc;\n    uint dy;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_3ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(0x174);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    fcn.00401e60();\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (*pcVar1)(\"ReBarWindow32\");\n    uVar3 = fcn.00401eb0(iVar2 + 1);\n    puVar6 = *(unaff_EBP + 0xc);\n    (*_sym.imp.USER32.dll_GetClassNameA)(*puVar6, uVar3, iVar2 + 1);\n    fcn.00409070(0xffffffff);\n    uVar3 = fcn.0041af40(*puVar6);\n    *(unaff_EBP + -0x14) = uVar3;\n    iVar2 = fcn.00420ff8(\"ReBarWindow32\");\n    if (((iVar2 == 0) && (iVar2 = *(unaff_EBP + -0x14),  iVar2 != 0)) && (iVar4 = fcn.00424c12(0x4817dc),  iVar4 != 0))\n    {\n        iVar4 = fcn.0041b98e();\n        if ((iVar4 == 0) || (*(unaff_EBP + -0x18) == iVar4)) {\n            fcn.0042a064();\n            fcn.00401e60();\n            fcn.00401e60();\n            *(unaff_EBP + -4) = 3;\n            fcn.00417038();\n            *(unaff_EBP + -4) = 4;\n            fcn.00417546(*(unaff_EBP + -0x18));\n            *(unaff_EBP + -0x180) = *(iVar2 + 0x98);\n            uVar3 = puVar6[3];\n            *(unaff_EBP + -4) = 5;\n            *(unaff_EBP + -0x17c) = 0x10;\n            fcn.004310b3(uVar3, unaff_EBP + -0x180);\n            fcn.004310d0(puVar6[3], unaff_EBP + -0x88);\n            iVar2 = (*pcVar1)(\"ToolbarWindow32\");\n            uVar3 = fcn.00401eb0(iVar2 + 1);\n            (*_sym.imp.USER32.dll_GetClassNameA)(*(unaff_EBP + -0x160), uVar3, iVar2 + 1);\n            fcn.00409070(0xffffffff);\n            iVar2 = fcn.0041af40(*(unaff_EBP + -0x160));\n            *(unaff_EBP + -0x58) = iVar2;\n            iVar4 = fcn.00420ff8(0x43374c);\n            if (((iVar4 == 0) && (iVar2 != 0)) && (iVar2 = fcn.00424c12(0x47ca48),  iVar2 != 0)) {\n                *(unaff_EBP + -0x80) = puVar6[6];\n                *(unaff_EBP + -0x54) = puVar6 + 6;\n                fcn.004172e2(unaff_EBP + -0x88);\n                fcn.004172a1(unaff_EBP + -0x88);\n                uVar5 = fcn.0042cb8f();\n                *(unaff_EBP + -0x14) = uVar5;\n                do {\n                    uVar5 = uVar5 - 1;\n                    *(unaff_EBP + -0x24) = uVar5;\n                    fcn.004310b3(uVar5, unaff_EBP + -0xec);\n                    iVar2 = (*_sym.imp.USER32.dll_IntersectRect)\n                                      (unaff_EBP + -0xfc, unaff_EBP + -0x88, unaff_EBP + -0xec);\n                    if (iVar2 != 0) break;\n                } while (uVar5 != 0);\n                fcn.00458b20(unaff_EBP + -0xdc, 0, 0x30);\n                *(unaff_EBP + -0xdc) = 0x30;\n                uVar3 = fcn.0043109a();\n                *(unaff_EBP + -0x28) = uVar3;\n                fcn.00450493();\n                *(unaff_EBP + -0x3c) = 0x47d7a0;\n                *(unaff_EBP + -4) = 6;\n                fcn.00445b33(*(unaff_EBP + -0x14) - uVar5, 0xffffffff);\n                uVar3 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                fcn.00429dfe(uVar3);\n                fcn.00405030(unaff_EBP + -0xac);\n                arg_8h_00 = 0;\n                while (uVar5 < *(unaff_EBP + -0x14)) {\n                    fcn.0042cabf(uVar5, unaff_EBP + -0x20, unaff_EBP + -0x50, unaff_EBP + -0x1c);\n                    if ((*(unaff_EBP + -0x50) & 1) == 0) {\n                        *(unaff_EBP + -0xd8) = 0x162;\n                        iVar2 = fcn.004024c0(*(unaff_EBP + -0x20));\n                        if (iVar2 == 0) {\n                            fcn.004018d0();\n                        }\n                        else {\n                            fcn.0041f630(unaff_EBP + 0xc, *(unaff_EBP + 8), 1, 10);\n                        }\n                        arg_ch = fcn.00414af6(8);\n                        if (arg_ch == NULL) {\n                            arg_ch = NULL;\n                        }\n                        else {\n                            arg_ch[1] = NULL;\n                            *arg_ch = vtable.CBitmap.0;\n                        }\n                        fcn.00445c59(arg_8h_00, arg_ch);\n                        if ((*(unaff_EBP + -0x28) == 0) ||\n                           (iVar2 = fcn.004329ed(*(*(unaff_EBP + -0x28) + 4), *(unaff_EBP + -0x1c), unaff_EBP + -0x11c)\n                           ,  iVar2 == 0)) {\n                            *(unaff_EBP + -0xbc) = 0;\n                        }\n                        else {\n                            (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x68, unaff_EBP + -0x10c);\n                            (*_sym.imp.USER32.dll_OffsetRect)\n                                      (unaff_EBP + -0x68, -*(unaff_EBP + -0x68), -*(unaff_EBP + -100));\n                            fcn.00433c4b(arg_8h_00);\n                            fcn.0043104e(unaff_EBP + -0xac, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c));\n                            puVar6 = fcn.00433c4b(arg_8h_00);\n                            puVar7 = fcn.00433c4b(arg_8h_00);\n                            uVar3 = fcn.00405070(*puVar6);\n                            *puVar7 = uVar3;\n                            uVar3 = (*_sym.imp.USER32.dll_GetSysColor)(4);\n                            fcn.0044b272(unaff_EBP + -0x68, uVar3);\n                            fcn.00432a0e(unaff_EBP + -0x4c, *(unaff_EBP + -0x1c), 0, 0, 1);\n                            puVar6 = fcn.00433c4b(arg_8h_00);\n                            puVar7 = fcn.00433c4b(arg_8h_00);\n                            uVar3 = fcn.00405070(*puVar6);\n                            *puVar7 = uVar3;\n                            puVar6 = fcn.00433c4b(arg_8h_00);\n                            uVar5 = *(unaff_EBP + -0x24);\n                            *(unaff_EBP + -0xbc) = *puVar6;\n                        }\n                        *(unaff_EBP + -0xb8) = *(unaff_EBP + 0xc);\n                        *(unaff_EBP + -0xcc) = *(unaff_EBP + -0x20);\n                        *(unaff_EBP + -0xd4) = 0x100;\n                        arg_8h_00 = arg_8h_00 + 1;\ncode_r0x004339ea:\n                        (*_sym.imp.USER32.dll_InsertMenuItemA)(*(unaff_EBP + -0x74), uVar5, 1, unaff_EBP + -0xdc);\n                    }\n                    else if (arg_8h_00 != 0) {\n                        *(unaff_EBP + -0xd8) = 0x100;\n                        *(unaff_EBP + -0xd4) = 0x800;\n                        goto code_r0x004339ea;\n                    }\n                    uVar5 = uVar5 + 1;\n                    *(unaff_EBP + -0x24) = uVar5;\n                }\n                fcn.004030d0(*(unaff_EBP + -0x54));\n                fcn.004172e2(unaff_EBP + -0x98);\n                fcn.00419af3(0, *(unaff_EBP + -0x98), *(unaff_EBP + -0x8c), *(unaff_EBP + -0x18), 0);\n                uVar5 = 0;\n                **(unaff_EBP + 0x10) = 0;\n                if (arg_8h_00 != 0) {\n                    do {\n                        ppiVar8 = fcn.00433c4b(uVar5);\n                        if (*ppiVar8 != NULL) {\n                            (**(**ppiVar8 + 4))(1);\n                        }\n                        uVar5 = uVar5 + 1;\n                    } while (uVar5 < arg_8h_00);\n                }\n                *(unaff_EBP + -4) = 5;\n                fcn.004504aa();\n                *(unaff_EBP + -4) = 4;\n                fcn.0041759a();\n                *(unaff_EBP + -4) = 3;\n                fcn.0041752d();\n                fcn.004010f0();\n                fcn.004010f0();\n                *(unaff_EBP + -4) = 0;\n                fcn.0042a0dc();\n            }\n            else {\n                *(unaff_EBP + -4) = 4;\n                fcn.0041759a();\n                *(unaff_EBP + -4) = 3;\n                fcn.0041752d();\n                fcn.004010f0();\n                fcn.004010f0();\n                *(unaff_EBP + -4) = 0;\n                fcn.0042a0dc();\n            }\n        }\n        else {\n            fcn.004335d7(*(unaff_EBP + 8), puVar6, *(unaff_EBP + 0x10));\n        }\n    }\n    fcn.004010f0();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 3234
    },
    "00433ddd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00433ddd(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(param_1 + 0xc)) {\n        do {\n            piVar1 = fcn.00404ff0(iVar2);\n            if (*piVar1 != 0) {\n                fcn.00433db9(1);\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0xc));\n    }\n    fcn.00445b33(0, 0xffffffff);\n    return;\n}\n",
        "token_count": 147
    },
    "0043421c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0043421c(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    uint var_10h;\n    uint var_4h;\n    int32_t iVar4;\n    \n    iVar4 = 4;\n    fcn.0045af3b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockState.0;\n    iVar3 = 0;\n    pcVar1 = extraout_ECX[3];\n    *(unaff_EBP + -4) = 0;\n    if (0 < pcVar1) {\n        do {\n            iVar4 = iVar3;\n            piVar2 = fcn.00404ff0();\n            if (*piVar2 != 0) {\n                iVar4 = 1;\n                fcn.00433db9(1);\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < extraout_ECX[3]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042c1f7(iVar4);\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 291
    },
    "004352e7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004352e7(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    if (arg_8h != 0) goto code_r0x004352f9;\n    do {\n        fcn.0041638e();\ncode_r0x004352f9:\n        if (arg_ch != 0) {\ncode_r0x00435336:\n            fcn.00436570(arg_8h, arg_10h);\n            return;\n        }\n        iVar1 = 0;\n        do {\n            if ((*(iVar1 * 8 + 0x47df9c) & 0xf000) == (*(arg_8h + 0x84) & 0xf000)) {\n                iVar1 = fcn.004320da(*(iVar1 * 8 + 0x47df98));\n                if (iVar1 != 0) goto code_r0x00435336;\n                break;\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < 4);\n    } while( true );\n}\n",
        "token_count": 249
    },
    "00435a01": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00435a01(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(in_ECX + 0xa4)) {\n        do {\n            if ((iVar2 != arg_ch) && (piVar1 = fcn.00404ff0(iVar2),  *piVar1 == arg_8h)) {\n                return iVar2;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(in_ECX + 0xa4));\n    }\n    return -1;\n}\n",
        "token_count": 159
    },
    "00435d61": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00435d61(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    \n    arg_8h = 0;\n    iVar2 = 0;\n    if (0 < *(param_1 + 0xa4)) {\n        do {\n            iVar1 = fcn.00435a42(arg_8h);\n            if (iVar1 != 0) {\n                iVar2 = iVar2 + 1;\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h < *(param_1 + 0xa4));\n    }\n    return iVar2;\n}\n",
        "token_count": 159
    },
    "00436458": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00436458(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t in_ECX;\n    int32_t arg_8h_01;\n    \n    arg_8h_01 = 0;\n    if (0 < *(in_ECX + 0xa4)) {\n        do {\n            arg_8h_00 = fcn.00435a42(arg_8h_01);\n            if (arg_8h_00 != 0) {\n                fcn.00430e96();\n                fcn.00431c20(arg_8h_00, arg_8h, 1);\n            }\n            arg_8h_01 = arg_8h_01 + 1;\n        } while (arg_8h_01 < *(in_ECX + 0xa4));\n    }\n    return;\n}\n",
        "token_count": 193
    },
    "00439c2c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439c2c(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint var_24h;\n    uint var_20h;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    piVar2 = fcn.00446a07(0x485080);\n    iVar3 = (**(*piVar2 + 0x20))(piVar2, 1, &var_4h);\n    if (iVar3 == 0) {\n        iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_24h, 0);\n        pcVar1 = _sym.imp.ole32.dll_CoTaskMemFree;\n        while (iVar3 == 0) {\n            iVar3 = (**(*piVar2 + 0xc))(piVar2, &var_24h, &var_10h);\n            if (iVar3 == 0) {\n                if (var_8h != 0) {\n                    (*_sym.imp.ole32.dll_ReleaseStgMedium)(&var_10h);\n                    goto code_r0x00439c8e;\n                }\n                fcn.00447077(0, &var_10h, &var_24h);\n            }\n            else {\ncode_r0x00439c8e:\n                (*pcVar1)(var_20h);\n            }\n            iVar3 = (**(*var_4h + 0xc))(var_4h, 1, &var_24h, 0);\n        }\n        (**(*var_4h + 8))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 391
    },
    "0043a33c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl fcn.0043a33c(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint uVar5;\n    uint var_4h;\n    \n    fcn.0045af6e(0x18);\n    *(unaff_EBP + -0x20) = extraout_ECX;\n    uVar5 = 0;\n    iVar4 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(0, 1, unaff_EBP + -0x14);\n    if (iVar4 == 0) goto code_r0x0043a368;\n    while( true ) {\n        fcn.00415123(uVar5);\ncode_r0x0043a368:\n        iVar4 = (*_sym.imp.ole32.dll_StgCreateDocfileOnILockBytes)(*(unaff_EBP + -0x14), 0x1012, 0, unaff_EBP + -0x18);\n        *(unaff_EBP + -0x1c) = iVar4;\n        if (iVar4 == 0) break;\n        (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n        uVar5 = *(unaff_EBP + -0x1c);\n    }\n    iVar4 = *(extraout_ECX + 0x20);\n    piVar1 = *(unaff_EBP + -0x20);\n    *(iVar4 + 0x80) = 0;\n    *(iVar4 + 0x84) = 0;\n    iVar2 = *piVar1;\n    *(unaff_EBP + -0x1c) = iVar4;\n    *(unaff_EBP + -4) = 0;\n    (**(iVar2 + 0xa0))(*(unaff_EBP + -0x18));\n    fcn.0042713e(0, 0);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(iVar4 + 0x80) = 1;\n    *(iVar4 + 0x84) = 1;\n    (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n    puVar3 = *(unaff_EBP + 8);\n    uVar5 = *(unaff_EBP + -0x18);\n    *puVar3 = 8;\n    puVar3[1] = uVar5;\n    puVar3[2] = 0;\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 719
    },
    "0043ad13": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043ad13(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    while( true ) {\n        iVar1 = fcn.004270db(&var_4h);\n        if (iVar1 == 0) break;\n        fcn.0043a0b2(arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "0043ad4a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043ad4a(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(*in_ECX + 0xb4))();\n    while( true ) {\n        piVar1 = fcn.004270db(&var_4h);\n        if (piVar1 == NULL) break;\n        if (piVar1 != arg_8h) {\n            (**(*piVar1 + 0x58))(arg_8h, arg_ch, arg_10h, arg_14h);\n        }\n    }\n    return;\n}\n",
        "token_count": 167
    },
    "0043d669": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043d669(void)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t arg_8h;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0045af3b(8);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -4) = 1;\n    fcn.0043b5d7();\n    if (*(extraout_ECX + 0xc0) != 0) {\n        fcn.00446bbb();\n        *(extraout_ECX + 0xc0) = 0;\n    }\n    uVar2 = fcn.00427356();\n    *(unaff_EBP + -0x10) = uVar2;\n    while( true ) {\n        arg_8h = fcn.004270db(unaff_EBP + -0x10);\n        if (arg_8h == 0) break;\n        fcn.00427060(arg_8h);\n    }\n    piVar1 = *(extraout_ECX + 0xd4);\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n        *(extraout_ECX + 0xd4) = NULL;\n    }\n    fcn.004469e6(extraout_ECX + 0x7c);\n    fcn.004469e6(extraout_ECX + 0xb0);\n    fcn.004010f0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004443dc();\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 412
    },
    "0043df17": {
        "rules": [
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043df17(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    *in_ECX = arg_8h;\n    in_ECX[1] = 0;\n    if (*0x49bdd4 == '\\0') {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"KERNEL32\");\n        if (iVar2 != 0) goto code_r0x0043df51;\ncode_r0x0043df4c:\n        do {\n            fcn.0041638e();\ncode_r0x0043df51:\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n            iVar3 = iVar2;\n            *0x49bdc4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"CreateActCtxA\");\n            *0x49bdc8 = (*pcVar1)(iVar2, \"ReleaseActCtx\");\n            *0x49bdcc = (*pcVar1)(iVar2, \"ActivateActCtx\");\n            *0x49bdd0 = (*pcVar1)(iVar2, \"DeactivateActCtx\");\n            iVar2 = iVar3;\n            if (*0x49bdc4 == 0) {\n                if ((*0x49bdc8 != 0) || (*0x49bdcc != 0)) goto code_r0x0043df4c;\n            }\n            else if ((*0x49bdc8 == 0) || (*0x49bdcc == 0)) goto code_r0x0043df4c;\n        } while (*0x49bdd0 != 0);\n        *0x49bdd4 = '\\x01';\n    }\n    return;\n}\n",
        "token_count": 400
    },
    "0043e20a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e20a(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    uint uVar3;\n    \n    iVar1 = 1;\n    if (1 < *0x49c194) {\n        do {\n            pcVar2 = *(*0x49c198 + iVar1 * 4);\n            iVar1 = iVar1 + 1;\n            uVar3 = 0;\n            if ((*pcVar2 == '-') || (*pcVar2 == '/')) {\n                uVar3 = 1;\n                pcVar2 = pcVar2 + 1;\n            }\n            (**(*arg_8h + 0xc))(pcVar2, uVar3, iVar1 == *0x49c194);\n        } while (iVar1 < *0x49c194);\n    }\n    return;\n}\n",
        "token_count": 191
    },
    "0043f480": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0043f480(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042052a();\n    fcn.0044b9be(0);\n    for (iVar1 = *(iVar1 + 0x24); iVar1 != 0; iVar1 = *(iVar1 + 0x20)) {\n        fcn.0043efb7();\n    }\n    fcn.0044ba30(0);\n    return;\n}\n",
        "token_count": 105
    },
    "0044598f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0044598f(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    int32_t unaff_EBP;\n    uint var_21ch;\n    uint var_4h;\n    \n    fcn.0045afda(0x214);\n    *(unaff_EBP + -0x21c) = arg_8h;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0041ff5e();\n    while (*(iVar2 + 0xe4) == arg_8h) {\n        puVar1 = *(iVar2 + 0xe8);\n        *(puVar1[1] + 0xe4) = *puVar1;\n        *(puVar1[1] + 0xe8) = puVar1[2];\n        puVar1[1] = 0;\n    }\n    if (*(arg_8h + 0x54) != 0) {\n        fcn.004428ef(arg_8h);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b863();\n    fcn.0045b036();\n    return;\n}\n",
        "token_count": 303
    },
    "00445aac": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00445aac(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    int32_t unaff_EBP;\n    \n    fcn.004010f0();\n    fcn.0045afda(0x214);\n    *(unaff_EBP + -0x21c) = arg_8h;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0041ff5e();\n    while (*(iVar2 + 0xe4) == arg_8h) {\n        puVar1 = *(iVar2 + 0xe8);\n        *(puVar1[1] + 0xe4) = *puVar1;\n        *(puVar1[1] + 0xe8) = puVar1[2];\n        puVar1[1] = 0;\n    }\n    if (*(arg_8h + 0x54) != 0) {\n        fcn.004428ef(arg_8h);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041b863();\n    fcn.0045b036();\n    return;\n}\n",
        "token_count": 281
    },
    "0044a36f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044a36f(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    int32_t *in_ECX;\n    int32_t arg_8h_00;\n    uint var_4h;\n    \n    arg_8h_00 = *in_ECX;\n    if (arg_8h_00 == 0) {\n        var_4h = 0;\n    }\n    else {\n        if (arg_8h_00 == arg_8h) {\n            piVar1 = fcn.0044a337(arg_8h);\n            *in_ECX = *piVar1;\n        }\n        else {\n            do {\n                piVar1 = fcn.0044a337(arg_8h_00);\n                if (*piVar1 == arg_8h) break;\n                piVar1 = fcn.0044a337(arg_8h_00);\n                arg_8h_00 = *piVar1;\n            } while (arg_8h_00 != 0);\n            if (arg_8h_00 == 0) {\n                return 0;\n            }\n            puVar2 = fcn.0044a337(arg_8h);\n            puVar3 = fcn.0044a337(arg_8h_00);\n            *puVar3 = *puVar2;\n        }\n        var_4h = 1;\n    }\n    return var_4h;\n}\n",
        "token_count": 333
    },
    "0044a537": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044a537(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    if ((0 < arg_8h) && (arg_8h < *(in_ECX + 0xc))) {\n        for (iVar3 = *(in_ECX + 0x14); iVar3 != 0; iVar3 = *(iVar3 + 4)) {\n            if (arg_8h < *(iVar3 + 8)) {\n                puVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n                if (puVar2 != NULL) {\n                    (***puVar2)(1);\n                }\n                *(*(iVar3 + 0xc) + arg_8h * 4) = 0;\n            }\n        }\n        puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n        *puVar1 = *puVar1 & 0xfffffffe;\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 297
    },
    "0044a88c": {
        "rules": [
            "contain loop",
            "get thread local storage value"
        ],
        "decompiled_code": "\nvoid fcn.0044a88c(uint param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = *0x49be94;\n    if (*0x49be94 != NULL) {\n        puVar1 = *0x49be94 + 7;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n        if (param_2 == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*puVar3);\n            if (iVar4 != 0) {\n                fcn.0044a6ef(iVar4, param_1);\n            }\n        }\n        else {\n            iVar4 = puVar3[5];\n            while (iVar4 != 0) {\n                iVar2 = *(iVar4 + 4);\n                fcn.0044a6ef(iVar4, param_1);\n                iVar4 = iVar2;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n        return;\n    }\n    return;\n}\n",
        "token_count": 257
    },
    "0044a9f2": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0044a9f2(uint32_t arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    \n    *arg_10h = arg_8h >> 4;\n    uVar2 = (arg_8h >> 4) % *(in_ECX + 8);\n    *arg_ch = uVar2;\n    if (*(in_ECX + 4) != 0) {\n        for (puVar1 = *(*(in_ECX + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == arg_8h) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 198
    },
    "0044aa2d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044aa2d(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint *puVar1;\n    \n    if (in_ECX == 0) {\n        fcn.0041638e();\n        in_ECX = extraout_ECX;\n    }\n    if (*(in_ECX + 4) != 0) {\n        for (puVar1 = *(*(in_ECX + 4) + ((arg_8h >> 4) % *(in_ECX + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == arg_8h) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 184
    },
    "0044aa9b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0044aa9b(uint32_t arg_8h)\n\n{\n    uint *puVar1;\n    uint *arg_8h_00;\n    int32_t in_ECX;\n    uint *puVar2;\n    \n    if (*(in_ECX + 4) == 0) {\n        arg_8h_00 = NULL;\n    }\n    else {\n        puVar2 = *(in_ECX + 4) + ((arg_8h >> 4) % *(in_ECX + 8)) * 4;\n        puVar1 = *puVar2;\n        while (arg_8h_00 = puVar1,  arg_8h_00 != NULL) {\n            if (arg_8h_00[1] == arg_8h) {\n                *puVar2 = *arg_8h_00;\n                fcn.0044a9d4(arg_8h_00);\n                return 0x1;\n            }\n            puVar2 = arg_8h_00;\n            puVar1 = *arg_8h_00;\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 254
    },
    "0044b175": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044b175(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar4 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar4);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != 0xffff) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar2 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar2 != 0) {\n                return hWnd;\n            }\n        }\n        uVar4 = 2;\n    } while( true );\n}\n",
        "token_count": 294
    },
    "0044b272": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b272(int32_t arg_8h, uint crColor)\n\n{\n    int32_t in_ECX;\n    \n    if (in_ECX != 0) goto code_r0x0044b286;\n    do {\n        fcn.0041638e();\ncode_r0x0044b286:\n    } while ((*(in_ECX + 4) == 0) || (arg_8h == 0));\n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    (*_sym.imp.GDI32.dll_ExtTextOutA)(*(in_ECX + 4), 0, 0, 2, arg_8h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 175
    },
    "0044b7d1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044b7d1(int32_t param_1)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    \n    if (param_1 != 0) goto code_r0x0044b7da;\n    do {\n        fcn.0041638e();\n        param_1 = extraout_ECX;\ncode_r0x0044b7da:\n        arg_8h = *(param_1 + 4);\n    } while (arg_8h == NULL);\n    iVar1 = *arg_8h;\n    iVar2 = arg_8h[2];\n    *(param_1 + 4) = iVar1;\n    if (iVar1 == 0) {\n        *(param_1 + 8) = 0;\n    }\n    else {\n        *(iVar1 + 4) = 0;\n    }\n    fcn.0044e520(arg_8h);\n    return iVar2;\n}\n",
        "token_count": 230
    },
    "0044b847": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044b847(int32_t arg_8h, uint *arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (arg_ch != NULL) goto code_r0x0044b860;\n    for (arg_ch = *(in_ECX + 4); (arg_ch != NULL && (arg_ch[2] != arg_8h)); arg_ch = *arg_ch) {\ncode_r0x0044b860:\n    }\n    return;\n}\n",
        "token_count": 107
    },
    "0044bae3": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044bae3(int16_t *arg_8h)\n\n{\n    int16_t iVar1;\n    \n    do {\n        iVar1 = *arg_8h;\n        arg_8h = arg_8h + 1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 71
    },
    "0044cc50": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044cc50(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    var_4h = (**(**(in_ECX + 4) + 0xb4))();\n    uVar1 = 0;\n    if (arg_8h != 0) {\n        do {\n            uVar1 = fcn.004270c5(&var_4h);\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != 0);\n    }\n    return uVar1;\n}\n",
        "token_count": 141
    },
    "004510c1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004510c1(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0xf, 0xf, 0);\n        if (iVar2 == 0) {\n            *(param_1 + 0x70) = *(*(param_1 + 0x68) + 0x88);\n            *(param_1 + 0x78) = *(*(param_1 + 0x68) + 0x84) & 0xf000;\n            (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0xc);\n            *(param_1 + 0x20) = 0;\n            *(param_1 + 0x1c) = 0;\n            *(param_1 + 0x24) = 0;\n            *(param_1 + 0x7c) = 0;\n            *(param_1 + 0x80) = 0;\n            uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            iVar2 = fcn.0041af14(uVar3);\n            iVar2 = (*_sym.imp.USER32.dll_LockWindowUpdate)(*(iVar2 + 0x20));\n            if (iVar2 == 0) {\n                uVar3 = 3;\n            }\n            else {\n                uVar3 = 0x403;\n            }\n            uVar3 = fcn.0044f745(0, uVar3);\n            *(param_1 + 0x84) = uVar3;\n            return;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0xf, 0xf);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n    }\n    return;\n}\n",
        "token_count": 461
    },
    "00451691": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00451691(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint lpMsg;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetCapture;\n    iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.USER32.dll_SetCapture)(*(*(param_1 + 0x68) + 0x20));\n        fcn.0041af14(uVar3);\n        uVar3 = (*pcVar1)();\n        iVar2 = fcn.0041af14(uVar3);\n        if (iVar2 == *(param_1 + 0x68)) {\n            do {\n                uVar3 = 0;\n                iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                if (iVar2 == 0) {\n                    fcn.0043e2fc(uVar3, var_14h);\n                    break;\n                }\n                if (var_18h == 0x100) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.00451355(var_14h, 1);\n                    }\n                    if (var_14h == 0x1b) break;\n                }\n                else if (var_18h == 0x101) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.00451355(var_14h, 0);\n                    }\n                }\n                else if (var_18h == 0x200) {\n                    if (*(param_1 + 0x88) == 0) {\n                        fcn.0045138b(var_8h, var_4h);\n                    }\n                    else {\n                        fcn.004512e0(var_8h, var_4h);\n                    }\n                }\n                else {\n                    if (var_18h == 0x202) {\n                        if (*(param_1 + 0x88) == 0) {\n                            fcn.0045164a();\n                        }\n                        else {\n                            fcn.00451544();\n                        }\n                        return 1;\n                    }\n                    if (var_18h == 0x204) break;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n                uVar3 = (*pcVar1)();\n                iVar2 = fcn.0041af14(uVar3);\n            } while (iVar2 == *(param_1 + 0x68));\n        }\n        fcn.00451501();\n    }\n    return 0;\n}\n",
        "token_count": 624
    },
    "00452dad": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00452dad(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < param_1[1]) {\n        do {\n            fcn.004585e6(*(*param_1 + iVar1 * 4));\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < param_1[1]);\n    }\n    fcn.00414b30(*param_1);\n    return;\n}\n",
        "token_count": 111
    },
    "0045e261": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0045e261(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0045b538(0x492740, 0xc);\n    fcn.0045fec1(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x49c1d0;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x49c1cc;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x0045e2a5;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.004585e6(arg_8h_00);\ncode_r0x0045e2a5:\n        fcn.004585e6(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0045e2c8();\n    fcn.0045b57d();\n    return;\n}\n",
        "token_count": 406
    },
    "0041e16c": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041e16c(int32_t lpName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t arg_8h;\n    uint var_4h;\n    \n    iVar3 = 0;\n    arg_8h = 0;\n    if (lpName != 0) {\n        iVar1 = fcn.0042052a();\n        uVar2 = *(iVar1 + 0xc);\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar2, lpName, 0xf0);\n        if (iVar1 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar2, iVar1);\n            if (iVar3 == 0) {\n                return 0;\n            }\n            arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar3);\n        }\n    }\n    uVar2 = fcn.0041dce6(arg_8h);\n    if ((arg_8h != 0) && (iVar3 != 0)) {\n        (*_sym.imp.KERNEL32.dll_FreeResource)(iVar3);\n    }\n    return uVar2;\n}\n",
        "token_count": 271
    },
    "0041f2c7": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: hResData\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid fcn.0041f2c7(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *arg_8h;\n    int32_t unaff_EBP;\n    uint uVar5;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hResData;\n    uint hWnd;\n    uint var_4h;\n    \n    fcn.0045af6e(0x24);\n    *(unaff_EBP + -0x20) = arg_8h;\n    *(unaff_EBP + -0x1c) = arg_8h[0x18];\n    *(unaff_EBP + -0x18) = arg_8h[0x17];\n    iVar1 = fcn.0042052a();\n    uVar5 = *(iVar1 + 0xc);\n    if (arg_8h[0x16] != 0) {\n        iVar1 = fcn.0042052a();\n        uVar5 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar5, arg_8h[0x16], 5);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar5, uVar2);\n        *(unaff_EBP + -0x18) = uVar2;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(*(unaff_EBP + -0x18));\n        *(unaff_EBP + -0x1c) = uVar2;\n    }\n    if (*(unaff_EBP + -0x1c) != 0) {\n        uVar2 = fcn.0041ee41();\n        *(unaff_EBP + -0x14) = uVar2;\n        fcn.0041afcd();\n        *(unaff_EBP + -0x28) = 0;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x24) = 0;\n        if (((*(unaff_EBP + -0x14) != 0) &&\n            (iVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)(),  *(unaff_EBP + -0x14) != iVar1)) &&\n           (iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14)),  iVar1 != 0)) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n            *(unaff_EBP + -0x2c) = 1;\n            piVar3 = fcn.00409ef0();\n            *(unaff_EBP + -0x24) = piVar3;\n            if (((piVar3 != NULL) && (iVar1 = (**(*piVar3 + 0x128))(),  iVar1 != 0)) &&\n               (iVar1 = fcn.00418187(),  iVar1 != 0)) {\n                fcn.004181a2(0);\n                *(unaff_EBP + -0x28) = 1;\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        fcn.0041ce25(arg_8h);\n        uVar2 = fcn.0041af14(*(unaff_EBP + -0x14));\n        iVar1 = fcn.0041f111(*(unaff_EBP + -0x1c), uVar2, uVar5);\n        if (iVar1 != 0) {\n            if ((*(arg_8h + 0xf) & 0x10) != 0) {\n                uVar5 = 4;\n                uVar4 = fcn.00418009();\n                if ((uVar4 & 0x100) != 0) {\n                    uVar5 = 5;\n                }\n                fcn.0041aa9d(uVar5);\n            }\n            if (arg_8h[8] != 0) {\n                fcn.0041822e(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x28) != 0) {\n            fcn.004181a2(1);\n        }\n        if (*(unaff_EBP + -0x2c) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n        }\n        if ((*(unaff_EBP + -0x14) != 0) && (iVar1 = (*_sym.imp.USER32.dll_GetActiveWindow)(),  iVar1 == arg_8h[8])) {\n            (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n        }\n        (**(*arg_8h + 0x60))();\n        fcn.0041ee7d();\n        if (arg_8h[0x16] != 0) {\n            (*_sym.imp.KERNEL32.dll_FreeResource)(*(unaff_EBP + -0x18));\n        }\n    }\n    fcn.0045b013();\n    return;\n}\n",
        "token_count": 1353
    },
    "0041f4c0": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041f4c0(uint lpName, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uint arg_8h;\n    uint var_4h;\n    \n    arg_8h = 0;\n    iVar1 = fcn.0042052a();\n    uVar3 = *(iVar1 + 0xc);\n    uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar3, lpName, 5);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar3, uVar2);\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    }\n    uVar3 = fcn.0041f111(arg_8h, arg_ch, uVar3);\n    (*_sym.imp.KERNEL32.dll_FreeResource)(iVar1);\n    return uVar3;\n}\n",
        "token_count": 219
    },
    "0041f518": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f518(uint hResData, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_8h;\n    \n    arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(hResData);\n    fcn.0041f493(arg_8h, arg_ch, 0, arg_10h);\n    return;\n}\n",
        "token_count": 85
    },
    "00409040": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00409040(uint *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_2);\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(*param_1, param_2, 0, 1, param_2, iVar1 + 1);\n    return iVar1 == 0;\n}\n",
        "token_count": 102
    },
    "004508f9": {
        "rules": [
            "log keystrokes via polling"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004508f9(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = fcn.00418009();\n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if ((uVar3 < 0) &&\n       ((((arg_8h & 0xfff0) != 0xf060 ||\n         (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x73),  iVar2 < 0 && (iVar2 = (*pcVar1)(0x12),  iVar2 < 0)) &&\n          ((uVar3 & 0x100) != 0)))) && (iVar4 = fcn.0041c5c3(arg_8h, arg_ch),  iVar4 != 0)))) {\n        return;\n    }\n    fcn.00431973(arg_8h);\n    return;\n}\n",
        "token_count": 224
    },
    "00416eac": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00416eac(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"GetLayout\");\n    if (pcVar2 == NULL) {\n        uVar1 = 0xffffffff;\n        (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n    }\n    else {\n        uVar1 = (*pcVar2)(*(param_1 + 4));\n    }\n    return uVar1;\n}\n",
        "token_count": 148
    },
    "00416ee4": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00416ee4(int32_t arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    uVar3 = 0;\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"SetLayout\");\n    if (pcVar2 == NULL) {\n        if (arg_8h != 0) {\n            uVar3 = 0xffffffff;\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n        }\n    }\n    else {\n        uVar3 = (*pcVar2)(*(in_ECX + 4), arg_8h);\n    }\n    return uVar3;\n}\n",
        "token_count": 190
    },
    "004183cd": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.004183cd(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (*0x49bbec != 0) {\n        return *0x49bbe0 != 0;\n    }\n    *0x49bbf0 = fcn.00418373();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"USER32\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (((((iVar2 != 0) && (*0x49bbd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x47a9f4),  *0x49bbd0 != 0)) &&\n         (*0x49bbd4 = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x49bbd4 != 0)) &&\n        ((*0x49bbd8 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x49bbd8 != 0 &&\n         (*0x49bbdc = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x49bbdc != 0)))) &&\n       ((*0x49bbe4 = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x49bbe4 != 0 &&\n        ((*0x49bbe0 = (*pcVar1)(iVar2, \"GetMonitorInfoA\"),  *0x49bbe0 != 0 &&\n         (*0x49bbe8 = (*pcVar1)(iVar2, \"EnumDisplayDevicesA\"),  *0x49bbe8 != 0)))))) {\n        *0x49bbec = 1;\n        return true;\n    }\n    *0x49bbd0 = 0;\n    *0x49bbd4 = 0;\n    *0x49bbd8 = 0;\n    *0x49bbdc = 0;\n    *0x49bbe0 = 0;\n    *0x49bbe4 = 0;\n    *0x49bbe8 = 0;\n    *0x49bbec = 1;\n    return false;\n}\n",
        "token_count": 475
    },
    "0041fdfa": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041fdfa(code **param_1)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    *param_1 = vtable._AFX_THREAD_STATE.0;\n    if (param_1[0xb] != NULL) {\n        (*pcVar1)(param_1[0xb]);\n    }\n    if (param_1[10] != NULL) {\n        (*pcVar1)(param_1[10]);\n    }\n    if (param_1[3] != NULL) {\n        fcn.004585e6(param_1[3]);\n    }\n    return;\n}\n",
        "token_count": 147
    },
    "0044c1ed": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.0044c1ed(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    fcn.0044c14e();\n    iVar2 = fcn.0042052a();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x3c),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.0042055d();\n    if ((*(iVar2 + 0x3c) != NULL) && (iVar3 = (**(**(iVar2 + 0x3c) + 0x144))(),  iVar3 != 0)) {\n        *(iVar2 + 0x3c) = 0;\n    }\n    iVar2 = fcn.0041ff5e();\n    iVar3 = fcn.0042052a();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar3 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x2c) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n        if (*(iVar2 + 0x28) != 0) {\n            (*pcVar1)(*(iVar2 + 0x28));\n            *(iVar2 + 0x28) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 359
    },
    "0042abaa": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042abaa(uint lpExistingFileName, uint lpNewFileName)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileA)(lpExistingFileName, lpNewFileName);\n    if (iVar1 == 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.00438850(arg_8h, lpExistingFileName);\n    }\n    return;\n}\n",
        "token_count": 110
    },
    "0042abd2": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042abd2(uint lpFileName)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileA)(lpFileName);\n    if (iVar1 == 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.00438850(arg_8h, lpFileName);\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "0042ad68": {
        "rules": [
            "write file on Windows"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ad68(uint lpBuffer, int32_t lpNumberOfBytesWritten)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    int32_t in_ECX;\n    \n    iVar1 = lpNumberOfBytesWritten;\n    if (lpNumberOfBytesWritten != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)\n                          (*(in_ECX + 4), lpBuffer, lpNumberOfBytesWritten, &lpNumberOfBytesWritten, 0);\n        if (iVar2 == 0) {\n            arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)(*(in_ECX + 0xc));\n            fcn.00438850(arg_8h, lpBuffer);\n        }\n        if (lpNumberOfBytesWritten != iVar1) {\n            fcn.0043880a(0xd, 0xffffffff, *(in_ECX + 0xc));\n        }\n    }\n    return;\n}\n",
        "token_count": 214
    },
    "0044a252": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044a252(int32_t arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *in_ECX;\n    \n    puVar1 = in_ECX + 7;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n    if ((((0 < arg_8h) && (arg_8h < in_ECX[3])) && (iVar3 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX),  iVar3 != 0))\n       && (arg_8h < *(iVar3 + 8))) {\n        uVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n        return uVar2;\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n    return 0;\n}\n",
        "token_count": 214
    }
}