{
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "0040a22f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a22f(uint32_t arg_8h)\n\n{\n    fcn.0040a210();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040a5aa();\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "0040a278": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a278(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x401598;\n    fcn.0040a210();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040a5aa();\n    }\n    return;\n}\n",
        "token_count": 81
    },
    "0040a2c7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a2c7(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x4015a4;\n    fcn.0040a210();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040a5aa();\n    }\n    return;\n}\n",
        "token_count": 85
    },
    "0040a538": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a538(uint32_t arg_8h)\n\n{\n    fcn.0040a515();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040a5aa();\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "0040a569": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a569(uint32_t arg_8h)\n\n{\n    fcn.0040a559();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040a5aa();\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "0040dc17": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040dc17(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x401f40;\n    fcn.0040a515();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040a5aa();\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "0041003d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041003d(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040fb78(0x418d68, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0040c97d();\n        *puVar2 = 0;\n        puVar2 = fcn.0040c96a();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x2c52c04)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x2c52c20;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0041453a(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0040c96a();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0040c97d();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0040ffc8(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.0041010f(0x418d68);\n                goto code_r0x00410109;\n            }\n        }\n        puVar2 = fcn.0040c97d();\n        *puVar2 = 0;\n        puVar2 = fcn.0040c96a();\n        *puVar2 = 9;\n        fcn.0040adc0(0, 0, 0, 0, 0);\n    }\ncode_r0x00410109:\n    fcn.0040fbbd();\n    return;\n}\n",
        "token_count": 641
    },
    "00413c5e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00413c5e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x41cfa4 ^ &stack0xfffffffc;\n    fcn.0040b6c1(arg_10h);\n    var_14h = fcn.004167c1(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.00415d39(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00413cb7:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00413cf7;\n        }\n        if (iVar1 != 2) {\ncode_r0x00413ce9:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00413cf7;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00413ce9;\n        goto code_r0x00413cb7;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x00413cf7:\n    fcn.0040c2f2(unaff_EBX);\n    return;\n}\n",
        "token_count": 509
    },
    "00413d06": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00413d06(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x41cfa4 ^ &stack0xfffffffc;\n    fcn.0040b6c1(arg_10h);\n    var_14h = fcn.004167c1(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0041627d(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00413d5f:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00413d9f;\n        }\n        if (iVar1 != 2) {\ncode_r0x00413d91:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00413d9f;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00413d91;\n        goto code_r0x00413d5f;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x00413d9f:\n    fcn.0040c2f2(unaff_EBX);\n    return;\n}\n",
        "token_count": 513
    },
    "00414f71": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00414f71(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040fb78(0x418f30, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0040c97d();\n        *puVar2 = 0;\n        puVar2 = fcn.0040c96a();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x2c52c04)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x2c52c20;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0041453a(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0040c96a();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0040c97d();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0041483e(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00415043(0x418f30);\n                goto code_r0x0041503d;\n            }\n        }\n        puVar2 = fcn.0040c97d();\n        *puVar2 = 0;\n        puVar2 = fcn.0040c96a();\n        *puVar2 = 9;\n        fcn.0040adc0(0, 0, 0, 0, 0);\n    }\ncode_r0x0041503d:\n    fcn.0040fbbd();\n    return;\n}\n",
        "token_count": 642
    },
    "00415475": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00415475(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0040e919();\n    var_4h = 0;\n    if (*0x2c51af4 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x402fa0);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x402f94);\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x2c51af4 = fcn.0040e8a7(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, 0x402f84);\n        *0x2c51af8 = fcn.0040e8a7(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x402f70);\n        *0x2c51afc = fcn.0040e8a7(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x402f54);\n        *0x2c51b04 = fcn.0040e8a7(uVar3);\n        if (*0x2c51b04 != 0) {\n            uVar3 = (*pcVar4)(iVar2, 0x402f3c);\n            *0x2c51b00 = fcn.0040e8a7(uVar3);\n        }\n    }\n    if ((*0x2c51b00 != iVar1) && (*0x2c51b04 != iVar1)) {\n        pcVar4 = fcn.0040e922(*0x2c51b00);\n        pcVar5 = fcn.0040e922(*0x2c51b04);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x004155b7;\n        }\n    }\n    if ((((*0x2c51af8 != iVar1) && (pcVar4 = fcn.0040e922(*0x2c51af8),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x2c51afc != iVar1 && (pcVar4 = fcn.0040e922(*0x2c51afc),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x004155b7:\n    pcVar4 = fcn.0040e922(*0x2c51af4);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 868
    },
    "00408edd": {
        "rules": [
            "hash data using aphash/d4672a7c2b8d413ab72f7529ccc05031"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408edd(uint32_t *param_1, uint *param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uchar auStack3132 [1024];\n    uchar auStack2108 [480];\n    uchar auStack1628 [544];\n    uchar auStack1084 [284];\n    uchar auStack800 [4];\n    uchar auStack796 [4];\n    uchar auStack792 [20];\n    uchar auStack772 [4];\n    uchar auStack768 [4];\n    uchar auStack764 [4];\n    uint uStack760;\n    uint uStack756;\n    uint32_t *puStack752;\n    int32_t iStack748;\n    int32_t iStack744;\n    int32_t iStack740;\n    uint uStack736;\n    uint uStack732;\n    uint32_t uStack728;\n    uint uStack724;\n    uint uStack720;\n    uint uStack716;\n    uint uStack712;\n    uint uStack708;\n    uint uStack704;\n    uint uStack700;\n    uint uStack696;\n    uint uStack692;\n    uint uStack688;\n    uint uStack684;\n    uint uStack680;\n    uint uStack676;\n    uint uStack672;\n    uint uStack668;\n    uint uStack664;\n    uint uStack660;\n    uint uStack656;\n    uint uStack652;\n    uint uStack648;\n    uint uStack644;\n    uint uStack640;\n    uint uStack636;\n    uint uStack632;\n    uint uStack628;\n    uint uStack624;\n    uint uStack620;\n    uint uStack616;\n    uint uStack612;\n    uint uStack608;\n    uint uStack604;\n    uint uStack600;\n    uint uStack596;\n    uint uStack592;\n    uint uStack588;\n    uint uStack584;\n    uint uStack580;\n    uint uStack576;\n    uint uStack572;\n    uint uStack568;\n    uint uStack564;\n    uint uStack560;\n    uint uStack556;\n    uint uStack552;\n    uint uStack548;\n    uint uStack544;\n    uint uStack540;\n    uint uStack536;\n    uint uStack532;\n    uint uStack528;\n    uint uStack524;\n    uint uStack520;\n    uint uStack516;\n    uint uStack512;\n    uint uStack508;\n    uint uStack504;\n    uint uStack500;\n    uint uStack496;\n    uint uStack492;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uint uStack476;\n    uint uStack472;\n    uint uStack468;\n    uint uStack464;\n    uint uStack460;\n    uint uStack456;\n    uint uStack452;\n    uint uStack448;\n    uint uStack444;\n    uint uStack440;\n    uint uStack436;\n    uint uStack432;\n    uint uStack428;\n    uint uStack424;\n    uint uStack420;\n    uint uStack416;\n    uint uStack412;\n    uint uStack408;\n    uint uStack404;\n    uint uStack400;\n    uint uStack396;\n    uint uStack392;\n    uint uStack388;\n    uint uStack384;\n    uint uStack380;\n    uint uStack376;\n    uint uStack372;\n    uint uStack368;\n    uint uStack364;\n    uint uStack360;\n    uint uStack356;\n    uint uStack352;\n    uint uStack348;\n    uint uStack344;\n    uint uStack340;\n    uint uStack336;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uint uStack300;\n    uint uStack296;\n    uint uStack292;\n    uint uStack288;\n    uint uStack284;\n    uint uStack280;\n    uint uStack276;\n    uint uStack272;\n    uint uStack268;\n    uint uStack264;\n    uint uStack260;\n    uint uStack256;\n    uint uStack252;\n    uint uStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uint uStack228;\n    uint uStack224;\n    uint uStack220;\n    uint uStack216;\n    uint uStack212;\n    uint uStack208;\n    uint uStack204;\n    uint uStack200;\n    uint uStack196;\n    uint uStack192;\n    uint uStack188;\n    uint uStack184;\n    uint uStack180;\n    uint uStack176;\n    uint uStack172;\n    uint uStack168;\n    uint uStack164;\n    uint uStack160;\n    uint uStack156;\n    uint uStack152;\n    uint uStack148;\n    uint uStack144;\n    uint uStack140;\n    uint uStack136;\n    uint uStack132;\n    uint uStack128;\n    uint uStack124;\n    uint uStack120;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint uStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    int32_t iStack28;\n    uint32_t uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    uStack12 = *param_1;\n    uStack728 = param_1[1];\n    puStack752 = param_1;\n    if (*0x2be935c == 0x134) {\n        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(0, &uStack736);\n        (*_sym.imp.KERNEL32.dll_SetEvent)(0);\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(auStack796);\n        (*_sym.imp.KERNEL32.dll_WriteProcessMemory)(0, 0, 0, 0, &uStack732);\n    }\n    iStack28 = 0;\n    if (*0x2be935c == 0x114e) {\n        (*_sym.imp.KERNEL32.dll_SetFileApisToANSI)();\n        sub.KERNEL32.dll_VerLanguageNameW(0, auStack3132, 0);\n    }\n    uStack732 = *param_2;\n    uStack736 = param_2[1];\n    fcn.00408ed0();\n    iStack28 = iStack28 + 0x54;\n    if (*0x2be935c == 0xb54) {\n        (*_sym.imp.KERNEL32.dll_BuildCommDCBW)(0x4012a0, auStack800);\n        (*_sym.imp.KERNEL32.dll_ReadFile)(0, 0, 0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_FindFirstVolumeA)(auStack2108, 0);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_SetConsoleCP;\n    iStack744 = param_2[2];\n    iStack748 = param_2[3];\n    iStack740 = 0x20;\n    do {\n        fcn.00408ec5();\n        if (*0x2be935c == 0x4c3) {\n            (*_sym.imp.KERNEL32.dll_FlushInstructionCache)(0, 0, 0);\n            (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4012c4);\n            (*_sym.imp.KERNEL32.dll_CancelTimerQueueTimer)(0, 0);\n            (*_sym.imp.KERNEL32.dll_EnumDateFormatsExA)(0, 0, 0);\n        }\n        if (*0x2be935c == 0x3ff) {\n            (*_sym.imp.KERNEL32.dll_GetPrivateProfileSectionW)(0, auStack3132, 0, 0);\n            (*_sym.imp.KERNEL32.dll_WritePrivateProfileSectionW)(0, 0, 0x4012e0);\n            (*_sym.imp.KERNEL32.dll_CreateFileW)(0x401338, 0, 0, 0, 0, 0, 0);\n            *0x2be6124 = 0;\n        }\n        if (*0x2be935c == 0xfa9) {\n            *0x2be9358 = 0xedeb2e40;\n        }\n        *0x2be9354 = 0x9150ce2e;\n        uStack676 = 0x23409e45;\n        uStack532 = 0x546684a8;\n        uStack536 = 0x3f378b90;\n        uStack668 = 0x26b873dc;\n        uStack356 = 0x358cf5cb;\n        uStack616 = 0x29983644;\n        uStack120 = 0x7dc6e5f5;\n        uStack228 = 0x3aa9ec81;\n        uStack524 = 0x39fd3d19;\n        uStack660 = 0x348f6274;\n        uStack288 = 0x6e41c7d3;\n        uStack652 = 0x53e187b4;\n        uStack220 = 0xfed61d6;\n        uStack644 = 0x7ada085d;\n        uStack148 = 0x4a1e8d93;\n        uStack348 = 0x456866b3;\n        uStack656 = 0x510c15d;\n        uStack140 = 0xa2eee99;\n        uStack212 = 0x778c3974;\n        uStack516 = 0x5a464473;\n        uStack508 = 0x685fa3d3;\n        uStack428 = 0x6d8c862c;\n        uStack280 = 0x6888eb1;\n        uStack636 = 0x5090d793;\n        uStack648 = 0x4abedd81;\n        uStack684 = 0x76ec4423;\n        uStack168 = 0x15e92005;\n        uStack44 = 0x70241620;\n        uStack628 = 0x131b9522;\n        uStack204 = 0x2942bb1d;\n        uStack248 = 0x2523a75b;\n        uStack284 = 0x11d08d33;\n        uStack276 = 0x4b222137;\n        uStack472 = 0x321ecfe3;\n        uStack620 = 0x575b796;\n        uStack512 = 0x1fffdd6a;\n        uStack132 = 0x75faf039;\n        uStack36 = 0x15899521;\n        uStack448 = 0x1109d039;\n        uStack240 = 0x75fcdb38;\n        uStack112 = 0x713f7202;\n        uStack692 = 0x2a34467c;\n        uStack160 = 0x7ab9969b;\n        uStack340 = 0x6e6f4f62;\n        uStack352 = 0x68a0941f;\n        uStack124 = 0x771b8962;\n        uStack420 = 0x708fef37;\n        uStack408 = 0xae5cf82;\n        uStack232 = 0x5afd073b;\n        uStack200 = 0x7da8d542;\n        uStack672 = 0x63059b8b;\n        uStack64 = 0x4e282ba7;\n        uStack600 = 0x5c4d4cf4;\n        uStack56 = 0x1a6faced;\n        uStack696 = 0x2a7bc4d0;\n        uStack488 = 0x571fe9f2;\n        uStack416 = 0x7fb79e3b;\n        uStack528 = 0x12911132;\n        uStack612 = 0x5e46be7b;\n        uStack196 = 0x3ab28b4;\n        uStack592 = 0x79ed9082;\n        uStack504 = 0x51c3c43d;\n        uStack400 = 0x4ed5ae5f;\n        uStack116 = 0x77ee5c69;\n        uStack32 = 0x699e0318;\n        uStack392 = 0x6a3df6d9;\n        uStack412 = 0x6a68727f;\n        uStack320 = 0x71a88410;\n        uStack624 = 0x72144519;\n        uStack584 = 0x7943706e;\n        uStack152 = 0x166ccf3d;\n        uStack384 = 0x5d7bef27;\n        uStack344 = 0x3fb67f18;\n        uStack604 = 0x687df6e2;\n        uStack404 = 0xb23fdac;\n        uStack272 = 0x3c0ec683;\n        uStack192 = 0x52c79ee7;\n        uStack680 = 0xea67b34;\n        uStack224 = 0x59ee28df;\n        uStack376 = 0x2817525b;\n        uStack500 = 0x41ec49cf;\n        uStack108 = 0x152f532e;\n        uStack104 = 0x6bcf2b09;\n        uStack596 = 0xd0455f;\n        uStack440 = 0x113cca32;\n        uStack96 = 0x2ca09670;\n        uStack560 = 0x1083bd57;\n        uStack188 = 0x8e56de1;\n        uStack608 = 0x357268d5;\n        uStack664 = 0x3f5a247a;\n        uStack48 = 0x7a66e545;\n        uStack576 = 0x24e4c52e;\n        uStack368 = 0x18be6c3e;\n        uStack332 = 0x3db8192e;\n        uStack700 = 0x777708fe;\n        uStack464 = 0x746719ea;\n        uStack312 = 0x70e28784;\n        uStack396 = 0x74b1451c;\n        uStack180 = 0x1fc38e1c;\n        uStack544 = 0x1a454084;\n        uStack264 = 0x6cfab315;\n        uStack324 = 0x5bcca26f;\n        uStack588 = 0xadc7db7;\n        uStack632 = 0x33be3dc9;\n        uStack580 = 0x218471aa;\n        uStack388 = 0x65649589;\n        uStack336 = 0x51dad296;\n        uStack724 = 0x3c96d833;\n        uStack184 = 0x65f5d1c;\n        uStack688 = 0x45644988;\n        uStack380 = 0x69748472;\n        uStack268 = 0x297ecfd3;\n        uStack716 = 0x4f7dbcd7;\n        uStack88 = 0x18561cab;\n        uStack172 = 0x720ef4aa;\n        uStack328 = 0x10ed17e7;\n        uStack640 = 0x3953200b;\n        uStack100 = 0x5142c32a;\n        uStack480 = 0x563d11f2;\n        uStack492 = 0x160fd461;\n        uStack572 = 0x603ca06c;\n        uStack260 = 0x13629ac1;\n        uStack316 = 0x74093f37;\n        uStack432 = 0x679680a8;\n        uStack484 = 0x207d8eeb;\n        uStack40 = 0xa216c63;\n        uStack252 = 0x2f5adecc;\n        uStack372 = 0x44a2df35;\n        uStack564 = 0x4a3c9e05;\n        uStack556 = 0x2ac010e7;\n        uStack92 = 0x67852e;\n        uStack360 = 0x483f468d;\n        uStack80 = 0xea69142;\n        uStack476 = 0x1b85e6;\n        uStack84 = 0x2e8bf091;\n        uStack144 = 0x7accba6a;\n        uStack216 = 0x70b903ac;\n        uStack720 = 0x8dfbb34;\n        uStack176 = 0x41683a2c;\n        uStack520 = 0x1c83fdd3;\n        uStack256 = 0x4ad81701;\n        uStack308 = 0x5d5c7f97;\n        uStack76 = 0x679ac91e;\n        uStack68 = 0x1899f8c7;\n        uStack164 = 0x4b6ad8c;\n        uStack304 = 0x103e9126;\n        uStack72 = 0x72b610fa;\n        uStack468 = 0x348041df;\n        uStack156 = 0x7cee9c15;\n        uStack568 = 0x18528e3a;\n        uStack460 = 0x2d0d3107;\n        uStack244 = 0x7b65c550;\n        uStack548 = 0x75ec9eda;\n        uStack424 = 0x42646a58;\n        uStack712 = 0x3ddf5eff;\n        uStack300 = 0x36dc2ee9;\n        uStack60 = 0x21b2f01a;\n        uStack552 = 0x726bed3c;\n        uStack704 = 0x6718329c;\n        uStack708 = 0x8d77509;\n        uStack136 = 0x56f4f074;\n        uStack496 = 0x6b3a3a26;\n        uStack452 = 0x6bee7b34;\n        uStack444 = 0x2a76cefe;\n        uStack52 = 0x25736362;\n        uStack436 = 0x5e24fb8f;\n        uStack296 = 0x13cc9676;\n        uStack292 = 0x145ce368;\n        uStack208 = 0x53a4e4aa;\n        uStack364 = 0x180454cc;\n        uStack456 = 0x5abc23bd;\n        uStack128 = 0x7a98d7b;\n        uStack540 = 0x48a0c18f;\n        uStack236 = 0x6e4572f2;\n        uStack20 = 0x924e26a9;\n        uStack8 = (uStack12 >> 5) + iStack748 ^ iStack28 + uStack12 ^ uStack24 + iStack744;\n        fcn.00408ed7();\n        uVar2 = uStack728;\n        uStack16 = 4;\n        uStack24 = uStack728 << 4;\n        fcn.00408eda();\n        uStack8 = uVar2 >> 5;\n        fcn.00408eda();\n        uStack24 = fcn.00408ecb();\n        uStack24 = uStack24 ^ uStack8;\n        *0x43951c = 0;\n        uStack12 = uStack12 - uStack24;\n        if (*0x2be935c == 0x22) {\n            (*_sym.imp.KERNEL32.dll_VerifyVersionInfoW)(auStack1084, 0, 0, 0);\n            (*pcVar1)(0);\n            (*_sym.imp.KERNEL32.dll_GetConsoleCP)();\n            (*_sym.imp.KERNEL32.dll_WriteConsoleA)(0, 0, 0, 0, 0);\n            sub.KERNEL32.dll_SetConsoleDisplayMode(0, 0, 0);\n            (*pcVar1)(0);\n            uStack760 = 0;\n            uStack756 = 0;\n            (*_sym.imp.KERNEL32.dll_InterlockedPopEntrySList)(&uStack760);\n            (*_sym.imp.KERNEL32.dll_ReadConsoleInputW)(0, auStack792, 0, auStack764);\n            (*_sym.imp.KERNEL32.dll_WriteConsoleInputW)(0, 0, 0, auStack772);\n            (*_sym.imp.KERNEL32.dll_GetCPInfoExW)(0, 0, auStack1628);\n            (*_sym.imp.KERNEL32.dll_CreateActCtxW)(0);\n            (*_sym.imp.KERNEL32.dll_GetUserDefaultLangID)();\n            (*_sym.imp.KERNEL32.dll_EraseTape)(0, 0, 0);\n            (*_sym.imp.KERNEL32.dll_InterlockedExchangeAdd)(auStack768, 0);\n        }\n        fcn.00408ed7();\n        iStack740 = iStack740 + -1;\n    } while (iStack740 != 0);\n    puStack752[1] = uVar2;\n    *puStack752 = uStack12;\n    return;\n}\n",
        "token_count": 4839
    },
    "0040983d": {
        "rules": [
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0",
            "hash data using aphash/10489b186fc44711a1078750698db7a9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040983d(uint param_1, uint32_t param_2)\n\n{\n    uint uStack2112;\n    uchar *puStack2108;\n    uint uStack2104;\n    uchar *puStack2100;\n    uchar auStack2076 [4];\n    uint uStack2072;\n    uchar auStack2064 [988];\n    uchar auStack1076 [1076];\n    \n    for (param_2 = param_2 >> 3; param_2 != 0; param_2 = param_2 - 1) {\n        if (*0x2be935c == 0xae9) {\n            puStack2100 = &stack0xfffff7e8;\n            uStack2104 = 0;\n            uStack2072 = 0;\n            puStack2108 = 0x409878;\n            (*_sym.imp.KERNEL32.dll_GetProcessHeaps)();\n            uStack2112 = 0;\n            puStack2108 = &stack0xfffff7f0;\n            (*_sym.imp.KERNEL32.dll_ReadConsoleOutputW)(0, &stack0xfffff7e8, 0);\n            (*_sym.imp.KERNEL32.dll_DnsHostnameToComputerNameA)(0x401378, &stack0xfffff7e4, &stack0xfffff7d0);\n            (*_sym.imp.KERNEL32.dll_HeapUnlock)(0);\n            (*_sym.imp.KERNEL32.dll_AddRefActCtx)(0);\n            (*_sym.imp.KERNEL32.dll_ZombifyActCtx)(0);\n            (*_sym.imp.KERNEL32.dll_ReadConsoleA)(0, &stack0xfffffbcc, 0, &stack0xfffff7c0, 0);\n            (*_sym.imp.KERNEL32.dll_GetConsoleAliasesLengthW)(0);\n            (*_sym.imp.KERNEL32.dll_CopyFileW)(0x4013c4, 0x4012fc, 0);\n            (*_sym.imp.KERNEL32.dll_LoadLibraryExA)(0x4013f4, 0, 0);\n            (*_sym.imp.KERNEL32.dll_FindClose)(0);\n            (*_sym.imp.KERNEL32.dll_SetConsoleTitleW)(0);\n            (*_sym.imp.KERNEL32.dll_UpdateResourceA)(0, 0x401428, 0x401410, 0, 0, 0);\n            (*_sym.imp.KERNEL32.dll_GetLastError)();\n            (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n            (*_sym.imp.KERNEL32.dll_EndUpdateResourceA)(0, 0);\n        }\n        puStack2100 = 0x409955;\n        fcn.00408edd();\n    }\n    return;\n}\n",
        "token_count": 597
    },
    "00409973": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nvoid fcn.00409973(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpBuffer;\n    uint var_438h;\n    uint lpDCB;\n    uint lpCommTimeouts;\n    uint var_18h;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint ptParentClientCoords;\n    uint lpflOldProtect;\n    \n    *0x2be9348 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0x401440);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    *0x2be9340 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x2be9348, 0x401450);\n    *0x2be6120 = (*pcVar1)(*0x2be9348, 0x40145c);\n    *0x2be6138 = (**0x2be9340)(0, *0x2be935c);\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(*0x2be6138, *0x2be935c, 0x40, &lpflOldProtect);\n    uVar2 = 0;\n    do {\n        if (uVar2 < 0x85b4) {\n            (*_sym.imp.USER32.dll_RealChildWindowFromPoint)(0, ptParentClientCoords, lpflOldProtect);\n            (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n            (*_sym.imp.USER32.dll_GetAltTabInfoA)(0, 0, 0, 0, 0);\n        }\n        (*_sym.imp.KERNEL32.dll_GetGeoInfoW)(0, 0, 0, 0, 0);\n        if (0x11c825e < uVar2) break;\n        uVar2 = uVar2 + 1;\n    } while ((uVar2 >> 0x1f < 0x3f) || ((uVar2 >> 0x1f < 0x40 && (uVar2 < 0x45b08f85))));\n    *0x2c50fec = *0x41ab0c;\n    uVar2 = 0;\n    if (*0x2be935c != 0) {\n        do {\n            (*0x2be6138)[uVar2] = *(*0x2c50fec + 0xb2d3b + uVar2);\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *0x2be935c);\n    }\n    iVar3 = 0;\n    do {\n        if (*0x2be935c + iVar3 == 0x5e) {\n            (*_sym.imp.KERNEL32.dll_HeapSize)(0, 0, 0);\n            (*_sym.imp.KERNEL32.dll_GetAtomNameW)(0, &lpBuffer, 0);\n            (*_sym.imp.KERNEL32.dll_UnmapViewOfFile)(0);\n            (*_sym.imp.KERNEL32.dll_HeapAlloc)(0, 0, 0);\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0xa69b);\n    fcn.0040983d(0x41a008);\n    iVar3 = 0;\n    do {\n        if (iVar3 == 23000) {\n            iVar3 = fcn.0040996c();\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x356d83);\n    iVar3 = 0x7b;\n    do {\n        if (*0x2be935c == 0x54d) {\n            lpCommTimeouts = 0;\n            var_18h = 0;\n            uStack24 = 0;\n            uStack20 = 0;\n            uStack16 = 0;\n            (*_sym.imp.KERNEL32.dll_BuildCommDCBAndTimeoutsW)(0x40146c, &lpDCB, &lpCommTimeouts);\n            (*_sym.imp.KERNEL32.dll_GetUserDefaultLCID)();\n            (*_sym.imp.KERNEL32.dll_GetSystemWindowsDirectoryA)(&var_438h, 0);\n        }\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    *0x2be9350 = *0x2be6138;\n    (**0x2be6138)();\n    return;\n}\n",
        "token_count": 983
    },
    "00409b21": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.00409b21(int32_t param_1, uint *param_2)\n\n{\n    uint *in_EAX;\n    uint *puVar1;\n    \n    if (param_2 != NULL) {\n        in_EAX = param_1 + 4;\n        puVar1 = in_EAX;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar1 = *in_EAX;\n        }\n        if (puVar1 <= param_2) {\n            if (0xf < *(param_1 + 0x18)) {\n                in_EAX = *in_EAX;\n            }\n            if (param_2 < *(param_1 + 0x14) + in_EAX) {\n                return CONCAT31(in_EAX >> 8, 1);\n            }\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 199
    },
    "00409c22": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409c22(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint *puVar3;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.0040a326();\n    }\n    uVar2 = *(in_ECX + 0x14) - arg_8h;\n    if (uVar2 < arg_ch) {\n        arg_ch = uVar2;\n    }\n    if (arg_ch != 0) {\n        puVar3 = in_ECX + 4;\n        puVar1 = puVar3;\n        if (0xf < *(in_ECX + 0x18)) {\n            puVar1 = *puVar3;\n            puVar3 = *puVar3;\n        }\n        fcn.00408e31(puVar3 + arg_8h, *(in_ECX + 0x18) - arg_8h, puVar1 + arg_ch + arg_8h, uVar2 - arg_ch);\n        fcn.00409bbb(*(in_ECX + 0x14) - arg_ch);\n    }\n    return;\n}\n",
        "token_count": 279
    },
    "00409c91": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch_2\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl\nfcn.00409c91(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint arg_8h_00;\n    int32_t arg_10h;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar4;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040ab10();\n    uVar4 = *(unaff_EBP + 8) | 0xf;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    if (uVar4 == 0xffffffff) {\n        uVar4 = *(unaff_EBP + 8);\n    }\n    else {\n        uVar1 = *(extraout_ECX + 0x18);\n        *(unaff_EBP + -0x14) = uVar1;\n        *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) >> 1;\n        uVar2 = *(unaff_EBP + -0x14);\n        if ((uVar4 / 3 < uVar2) && (uVar1 <= -uVar2 - 2)) {\n            uVar4 = uVar2 + uVar1;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = fcn.00409b5c();\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0xc) != 0) {\n        if (*(extraout_ECX + 0x18) < 0x10) {\n            arg_10h = extraout_ECX + 4;\n        }\n        else {\n            arg_10h = *(extraout_ECX + 4);\n        }\n        fcn.00408e15(arg_8h_00, uVar4 + 1, arg_10h, *(unaff_EBP + 0xc));\n    }\n    fcn.00409bd7(1, 0);\n    uVar3 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 4) = arg_8h_00;\n    *(extraout_ECX + 0x18) = uVar4;\n    fcn.00409bbb(uVar3);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 688
    },
    "00409d94": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00409d94(int32_t param_1, uint32_t param_2, uint param_3)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    char cVar2;\n    \n    if (param_2 == 0xffffffff) {\n        fcn.0040a2ee();\n    }\n    if (*(param_1 + 0x18) < param_2) {\n        fcn.00409c91(param_2, *(param_1 + 0x14), unaff_EDI, unaff_ESI, unaff_retaddr, param_2, param_3);\n    }\n    else if ((cVar2 == '\\0') || (0xf < param_2)) {\n        if (param_2 == 0) {\n            fcn.00409bbb(0);\n        }\n    }\n    else {\n        uVar1 = *(param_1 + 0x14);\n        if (param_2 < *(param_1 + 0x14)) {\n            uVar1 = param_2;\n        }\n        fcn.00409bd7(1, uVar1);\n    }\n    return param_2 != 0;\n}\n",
        "token_count": 277
    },
    "0040a515": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040a515(uint *param_1)\n\n{\n    *param_1 = 0x4015d8;\n    if (param_1[2] != 0) {\n        fcn.0040abfb(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "0040a81e": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040a81e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x40a8c9;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.0040a8f5;\n        uStack36 = *0x41cfa4 ^ &fcn.0040a81e::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0040a81e::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.0040eb6e();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.0040a81e::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 733
    },
    "0040c2f2": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c2f2(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x41cfa4) {\n        return;\n    }\n    *0x2c51898 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                 (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                 ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                 (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x2c5189c = &arg_8h;\n    *0x2c517d8 = 0x10001;\n    *0x2c51780 = 0xc0000409;\n    *0x2c51784 = 1;\n    var_328h = *0x41cfa4;\n    var_324h = *0x41cfa8;\n    *0x2c5178c = unaff_retaddr;\n    *0x2c51864 = in_GS;\n    *0x2c51868 = in_FS;\n    *0x2c5186c = in_ES;\n    *0x2c51870 = in_DS;\n    *0x2c51874 = unaff_EDI;\n    *0x2c51878 = unaff_ESI;\n    *0x2c5187c = unaff_EBX;\n    *0x2c51880 = in_EDX;\n    *0x2c51884 = in_ECX;\n    *0x2c51888 = in_EAX;\n    *0x2c5188c = unaff_EBP;\n    *0x2c51890 = unaff_retaddr;\n    *0x2c51894 = in_CS;\n    *0x2c518a0 = in_SS;\n    *0x2c517d0 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.0040fd6c(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x402698);\n    if (*0x2c517d0 == 0) {\n        fcn.0040fd6c(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 863
    },
    "0040ce1e": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0040ce1e(void)\n\n{\n    uint unaff_EBX;\n    uint in_stack_fffffd2c;\n    uint in_stack_fffffd30;\n    uint var_2c8h;\n    \n    fcn.004137e0();\n    fcn.0040ceaa(unaff_EBX, in_stack_fffffd2c, in_stack_fffffd30);\n    return;\n}\n",
        "token_count": 90
    },
    "0040ddac": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0040ddac(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040eb6e();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.0040eb6e();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "0040e074": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040e074(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.0040aa5c(*(unaff_EBP + -0x28));\n    iVar1 = fcn.0040eb6e();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.0040eb6e();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.0040aa35(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0040de0c(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 386
    },
    "004116bc": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x004117af: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x004117b4)\n// WARNING: Removing unreachable block (ram,0x004117e2)\n// WARNING: Removing unreachable block (ram,0x004117ba)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004116bc(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040fb78(0x418df0, 0x18);\n    fcn.0040f07f(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x2c512f4 != 1) {\n        *0x2c512f0 = 1;\n        *0x2c512ec = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.0040e922(*0x2c51bd0);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.0040e922(*0x2c51bcc);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.0040e919();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.0040e922(*piVar2);\n                        iVar3 = fcn.0040e919();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.0040e922(*0x2c51bd0);\n                        piVar1 = fcn.0040e922(*0x2c51bcc);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.004115f6(0x40125c);\n        }\n        fcn.004115f6(0x401264);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0040efa5(8);\n    }\n    return;\n}\n",
        "token_count": 806
    },
    "00413122": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.00413122(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.0040efa5(0);\n    }\n    return;\n}\n",
        "token_count": 64
    },
    "00415d39": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00415d39(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0041623a;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = str.5_v_[0] + L'\\xffffffff';\n        iVar4 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        uVar9 = str.5_v_[0] & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x00415e6e;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x00415e75;\ncode_r0x00415e6e:\n                        do {\n                            var_4h = 1;\ncode_r0x00415e75:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x00415e83;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x00415e83:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x41dd8c - str.5_v_[0]) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x41dd8c < iVar12) {\n                if (iVar12 < *0x41dd88) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + str.5_v_[3];\n                    iVar4 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = str.5_v_[3] + *0x41dd88;\n                    uVar5 = 1;\n                }\n                goto code_r0x0041623a;\n            }\n            var_10h = *0x41dd8c - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = str.5_v_[0] + L'\\xffffffff';\n            iVar12 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar10 = str.5_v_[0] & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x00416026;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x00416026:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = str.5_v_[1] + L'\\x01';\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0041623a:\n    var_20h = iVar12 << (0x1fU - str.5_v_[1] & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3667
    },
    "0041627d": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041627d(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0041677e;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = *0x41dda8 - 1;\n        iVar4 = *0x41dda8 + (*0x41dda8 >> 0x1f & 0x1fU) >> 5;\n        uVar9 = *0x41dda8 & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x004163b2;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x004163b9;\ncode_r0x004163b2:\n                        do {\n                            var_4h = 1;\ncode_r0x004163b9:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x004163c7;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x004163c7:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x41dda4 - *0x41dda8) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x41dda4 < iVar12) {\n                if (iVar12 < *0x41dda0) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + *0x41ddb4;\n                    iVar4 = *0x41ddac + (*0x41ddac >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x41ddac & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = *0x41ddac + (*0x41ddac >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x41ddac & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = *0x41ddb4 + *0x41dda0;\n                    uVar5 = 1;\n                }\n                goto code_r0x0041677e;\n            }\n            var_10h = *0x41dda4 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = *0x41dda8 - 1;\n            iVar12 = *0x41dda8 + (*0x41dda8 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = *0x41dda8 & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x0041656a;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x0041656a:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = *0x41ddac + 1;\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0041677e:\n    var_20h = iVar12 << (0x1fU - *0x41ddac & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (*0x41ddb0 == 0x40) {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (*0x41ddb0 == 0x20) {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3638
    },
    "00409b5c": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409b5c(uint32_t param_1)\n\n{\n    code *pcVar1;\n    uint var_10h;\n    uint var_4h;\n    \n    if (param_1 == 0) {\n        param_1 = 0;\n    }\n    else if (0xffffffff / param_1 == 0) {\n        var_4h = 0;\n        fcn.0040a448(&var_4h);\n        var_10h = 0x401568;\n        fcn.0040abaf(&var_10h, 0x418838);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    fcn.0040ab4a(param_1);\n    return;\n}\n",
        "token_count": 171
    },
    "00408ea0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nfloat10 fcn.00408ea0(float param_1, float param_2)\n\n{\n    float10 fVar1;\n    \n    fVar1 = fcn.0040a690(SUB84(param_1, 0), param_1 >> 0x20, SUB84(param_2, 0), param_2 >> 0x20);\n    return fVar1;\n}\n",
        "token_count": 85
    },
    "00408ed0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408ed0(int32_t *param_1)\n\n{\n    *param_1 = *param_1 + -0x3910c934;\n    return;\n}\n",
        "token_count": 43
    },
    "00408eda": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408eda(int32_t *param_1, int32_t param_2)\n\n{\n    *param_1 = *param_1 + param_2;\n    return;\n}\n",
        "token_count": 45
    },
    "0040996c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040996c(uint *param_1)\n\n{\n    *param_1 = *param_1;\n    return;\n}\n",
        "token_count": 33
    },
    "00409df2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409df2(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    int32_t arg_8h_00;\n    int32_t in_ECX;\n    uint32_t arg_14h;\n    \n    if (*(arg_8h + 0x14) < arg_ch) {\n        fcn.0040a326();\n    }\n    arg_14h = *(arg_8h + 0x14) - arg_ch;\n    if (arg_10h < arg_14h) {\n        arg_14h = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.00409c22(arg_14h + arg_ch, 0xffffffff);\n        fcn.00409c22(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.00409d94(arg_14h, 0);\n        if (cVar1 != '\\0') {\n            if (*(arg_8h + 0x18) < 0x10) {\n                arg_8h = arg_8h + 4;\n            }\n            else {\n                arg_8h = *(arg_8h + 4);\n            }\n            if (*(in_ECX + 0x18) < 0x10) {\n                arg_8h_00 = in_ECX + 4;\n            }\n            else {\n                arg_8h_00 = *(in_ECX + 4);\n            }\n            fcn.00408e15(arg_8h_00, *(in_ECX + 0x18), arg_8h + arg_ch, arg_14h);\n            fcn.00409bbb(arg_14h);\n        }\n    }\n    return;\n}\n",
        "token_count": 400
    },
    "0040a35e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040a35e(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0040c301(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.0040a4b8(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0x40158c;\n    fcn.00409ef6(arg_8h_00 + 0xc);\n    fcn.0040c36a();\n    return;\n}\n",
        "token_count": 202
    },
    "0040a690": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a690(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint var_2c8h;\n    uint var_8fh;\n    \n    fcn.0040d024(arg_8h, arg_ch);\n    fcn.0040d024(arg_10h, arg_14h);\n    fcn.00413847();\n    fcn.0040cea3();\n    return;\n}\n",
        "token_count": 106
    },
    "0040cff1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040cff1(uint arg_8h, uint arg_ch)\n\n{\n    uint var_2c8h;\n    \n    fcn.0040d024(arg_8h, arg_ch);\n    fcn.004137e0();\n    fcn.0040cea3();\n    return;\n}\n",
        "token_count": 70
    },
    "004117e8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004117e8(uint arg_8h)\n\n{\n    fcn.004116bc(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 40
    },
    "0041208d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004120a1)\n// WARNING: Removing unreachable block (ram,0x004120a7)\n// WARNING: Removing unreachable block (ram,0x004120a9)\n\nvoid fcn.0041208d(void)\n\n{\n    return;\n}\n",
        "token_count": 64
    },
    "0041860e": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0041860e(void)\n\n{\n    *0x41e118 = (*_sym.imp.KERNEL32.dll_CreateFileA)(0x4030d4, 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 65
    },
    "00409f1c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00409f1c(char *param_1)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    pcVar2 = param_1;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.00409e84(param_1, pcVar2 - (param_1 + 1));\n    return;\n}\n",
        "token_count": 104
    },
    "0040c824": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040c824(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040fb78(0x418b78, 0xc);\n    fcn.0040f07f(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x2c5114c;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x2c51148;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x0040c868;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.0040abfb(arg_8h_00);\ncode_r0x0040c868:\n        fcn.0040abfb(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0040c88b();\n    fcn.0040fbbd();\n    return;\n}\n",
        "token_count": 403
    }
}