{
    "00409590": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00409590(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.0040157d();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "004067c0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004067c0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401181();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "00404990": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404990(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401695();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 77
    },
    "0040bc00": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040bc00(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.004011fe();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "00404940": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00404940(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.00401604();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX + -0x54);\n    }\n    return in_ECX + -0x54;\n}\n",
        "token_count": 91
    },
    "004064a0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004064a0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401096();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "0040b860": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b860(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401672();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "00403e50": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403e50(uint arg_8h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    uint arg_ch;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t in_ECX;\n    int32_t arg_10h;\n    uint uVar9;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_10h = fcn.004015d2();\n    cVar1 = fcn.004014ce(&var_10h, &arg_8h);\n    if (cVar1 == '\\0') {\n        iVar3 = fcn.0040142e();\n        if (iVar3 != 0) {\n            uVar4 = fcn.0040142e();\n            uVar5 = fcn.004010ff();\n            if (uVar4 < uVar5) {\n                uVar2 = fcn.00401627(&arg_8h);\n                puVar6 = fcn.0040120d();\n                *puVar6 = uVar2;\n                return arg_8h;\n            }\n        }\n        if ((*(in_ECX + 0x44) & 2) == 0) {\n            iVar3 = fcn.00401109();\n            if (iVar3 == 0) {\n                var_18h = 0;\n            }\n            else {\n                var_18h = fcn.004010ff();\n                iVar3 = fcn.004013c5();\n                var_18h = var_18h - iVar3;\n            }\n            var_4h = var_18h;\n            var_18h = var_18h + *(in_ECX + 0x40);\n            uVar9 = 0;\n            var_ch = var_18h;\n            var_8h = fcn.004012b2(var_18h);\n            if (var_4h == 0) {\n                if (0x200 < *(in_ECX + 0x40)) {\n                    *(in_ECX + 0x40) = 0x200;\n                }\n            }\n            else {\n                iVar3 = var_4h;\n                arg_ch = fcn.004013c5(var_4h, var_18h, uVar9);\n                fcn.004015aa(var_8h, arg_ch, iVar3);\n            }\n            if ((*(in_ECX + 0x44) & 1) != 0) {\n                uVar9 = fcn.004013c5(var_4h, var_18h, uVar9);\n                fcn.004013ac(uVar9);\n            }\n            *(in_ECX + 0x44) = *(in_ECX + 0x44) | 1;\n            if (var_4h == 0) {\n                *(in_ECX + 0x3c) = var_8h;\n                fcn.00401406(var_8h, var_8h + var_ch);\n                fcn.00401532(var_8h, var_8h, var_8h);\n            }\n            else {\n                iVar3 = fcn.004013c5();\n                *(in_ECX + 0x3c) = var_8h + (*(in_ECX + 0x3c) - iVar3);\n                arg_10h = var_8h + var_ch;\n                iVar3 = fcn.0040142e();\n                iVar7 = fcn.004013c5();\n                iVar3 = var_8h + (iVar3 - iVar7);\n                iVar7 = fcn.00401334();\n                iVar8 = fcn.004013c5();\n                fcn.004012c6(var_8h + (iVar7 - iVar8), iVar3, arg_10h);\n                if ((*(in_ECX + 0x44) & 4) == 0) {\n                    iVar3 = fcn.0040142e();\n                    iVar3 = iVar3 + 1;\n                    iVar7 = fcn.00401109();\n                    iVar8 = fcn.004013c5();\n                    fcn.00401532(var_8h, var_8h + (iVar7 - iVar8), iVar3);\n                }\n                else {\n                    fcn.00401532(var_8h, var_8h, var_8h);\n                }\n            }\n            uVar2 = fcn.00401627(&arg_8h);\n            puVar6 = fcn.0040120d();\n            *puVar6 = uVar2;\n        }\n        else {\n            arg_8h = fcn.004015d2();\n        }\n    }\n    else {\n        arg_8h = fcn.0040153c(&arg_8h);\n    }\n    return arg_8h;\n}\n",
        "token_count": 1116
    },
    "00409e90": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00409e90(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401208();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "0040114a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nbool __fastcall fcn.0040114a(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    return (*(param_1 + 0x14) & 1) == 0;\n}\n",
        "token_count": 48
    },
    "00406240": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406240(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.0040118b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "004011e5": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.004011e5(void)\n\n{\n    if ((*0x49daa8 & 1) == 0) {\n        *0x49daa8 = *0x49daa8 | 1;\n    }\n    return;\n}\n",
        "token_count": 56
    },
    "00406500": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406500(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.004011b3();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "00401258": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401258(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00445627();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 77
    },
    "00404c60": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404c60(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.0041ab6d();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "00401302": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n\nvoid __fastcall fcn.00401302(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    int32_t var_8h;\n    uint var_4h;\n    \n    if ((*(param_1 + 0x44) & 1) != 0) {\n        iVar1 = fcn.0040142e();\n        if (iVar1 == 0) {\n            var_8h = fcn.004013b6();\n        }\n        else {\n            var_8h = fcn.004010ff();\n        }\n        iVar1 = fcn.004013c5(var_8h);\n        arg_8h = fcn.004013c5(var_8h - iVar1);\n        fcn.004013ac(arg_8h);\n    }\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x44) = *(param_1 + 0x44) & 0xfffffffe;\n    return;\n}\n",
        "token_count": 242
    },
    "0040a4f0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a4f0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.004014d3();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 81
    },
    "0040bba0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040bba0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401659();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 79
    },
    "0040137f": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t fcn.0040137f(char param_1)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint arg_8h;\n    uint32_t extraout_ECX;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uchar *puStack20;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b679;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puStack20 = &stack0xffffffa4;\n    cVar1 = fcn.0040103c();\n    if (cVar1 != '\\0') {\n        iVar3 = fcn.00401514();\n        if (iVar3 != 0) {\n            fcn.00401514();\n            fcn.0040162c();\n        }\n        if (param_1 == '\\0') {\n            uVar4 = fcn.00401339();\n            if ((uVar4 & 1) != 0) {\n                arg_8h = fcn.00401465(&var_1ch);\n                var_4h = 0;\n                var_14h = fcn.00401073(arg_8h, 0, 1);\n                var_4h = 0xffffffff;\n                fcn.0040105a();\n                var_4h = 1;\n                fcn.004010a5();\n                var_18h = fcn.0040106e();\n                while( true ) {\n                    var_20h = fcn.004015d2();\n                    cVar1 = fcn.004014ce(&var_20h, &var_18h);\n                    if (cVar1 != '\\0') break;\n                    uVar2 = fcn.00401627(&var_18h);\n                    cVar1 = fcn.00401578(0x48, extraout_ECX & 0xffffff00 | uVar2);\n                    if (cVar1 == '\\0') break;\n                    fcn.004010a5();\n                    var_18h = fcn.0040168b();\n                }\n                var_4h = 0xffffffff;\n            }\n        }\n        cVar1 = fcn.0040103c();\n        if (cVar1 != '\\0') {\n            uVar4 = 1;\n            goto code_r0x00404fdf;\n        }\n    }\n    uVar4 = fcn.004010be(2, 0);\n    uVar4 = uVar4 & 0xffffff00;\ncode_r0x00404fdf:\n    *in_FS_OFFSET = var_ch;\n    return uVar4;\n}\n",
        "token_count": 717
    },
    "00407bf0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407bf0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401037();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "00404400": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00404400(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint *puVar6;\n    uint var_1ch;\n    uint var_18h;\n    \n    iVar1 = fcn.0040142e();\n    if ((iVar1 != 0) && (uVar2 = fcn.0040142e(),  *(in_ECX + 0x3c) < uVar2)) {\n        uVar3 = fcn.0040142e();\n        *(in_ECX + 0x3c) = uVar3;\n    }\n    if (((arg_14h & 1) == 0) || (iVar1 = fcn.00401109(),  iVar1 == 0)) {\n        if (((arg_14h & 2) == 0) || (iVar1 = fcn.0040142e(),  iVar1 == 0)) {\n            arg_ch = -1;\n        }\n        else {\n            if (arg_10h == 2) {\n                iVar1 = fcn.004013c5();\n                arg_ch = arg_ch + (*(in_ECX + 0x3c) - iVar1);\n            }\n            else if (arg_10h == 1) {\n                iVar1 = fcn.0040142e();\n                iVar4 = fcn.004013c5();\n                arg_ch = arg_ch + (iVar1 - iVar4);\n            }\n            else if (arg_10h != 0) {\n                arg_ch = -1;\n            }\n            if ((arg_ch < 0) || (iVar1 = fcn.004013c5(),  *(in_ECX + 0x3c) - iVar1 < arg_ch)) {\n                arg_ch = -1;\n            }\n            else {\n                iVar1 = fcn.004013c5();\n                iVar4 = fcn.0040142e();\n                fcn.004013e3((iVar1 - iVar4) + arg_ch);\n            }\n        }\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.004013c5();\n            arg_ch = arg_ch + (*(in_ECX + 0x3c) - iVar1);\n        }\n        else if ((arg_10h == 1) && ((arg_14h & 2) == 0)) {\n            iVar1 = fcn.00401109();\n            iVar4 = fcn.004013c5();\n            arg_ch = arg_ch + (iVar1 - iVar4);\n        }\n        else if (arg_10h != 0) {\n            arg_ch = -1;\n        }\n        if ((arg_ch < 0) || (iVar1 = fcn.004013c5(),  *(in_ECX + 0x3c) - iVar1 < arg_ch)) {\n            arg_ch = -1;\n        }\n        else {\n            iVar1 = fcn.004013c5();\n            iVar4 = fcn.00401109();\n            fcn.00401118((iVar1 - iVar4) + arg_ch);\n            if (((arg_14h & 2) != 0) && (iVar1 = fcn.0040142e(),  iVar1 != 0)) {\n                uVar3 = fcn.004010ff();\n                arg_ch_00 = fcn.00401109();\n                arg_8h_00 = fcn.00401334();\n                fcn.004012c6(arg_8h_00, arg_ch_00, uVar3);\n            }\n        }\n    }\n    puVar5 = fcn.00401087(arg_ch);\n    puVar6 = arg_8h;\n    for (iVar1 = 6; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    return arg_8h;\n}\n",
        "token_count": 950
    },
    "00401442": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.00401442(void)\n\n{\n    if ((*0x49da95 & 1) == 0) {\n        *0x49da95 = *0x49da95 | 1;\n    }\n    return;\n}\n",
        "token_count": 52
    },
    "0040b4f0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b4f0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401528();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "004048b0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004048b0(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.0040145b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX + -8);\n    }\n    return in_ECX + -8;\n}\n",
        "token_count": 89
    },
    "004014f1": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.004014f1(void)\n\n{\n    if ((*0x49daa7 & 1) == 0) {\n        *0x49daa7 = *0x49daa7 | 1;\n    }\n    return;\n}\n",
        "token_count": 56
    },
    "00404870": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404870(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401492();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 77
    },
    "004046a0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.004046a0(uint *arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint32_t arg_24h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint *puVar6;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_4h;\n    \n    var_4h = fcn.004013bb();\n    iVar1 = fcn.0040142e();\n    if ((iVar1 != 0) && (uVar2 = fcn.0040142e(),  *(in_ECX + 0x3c) < uVar2)) {\n        uVar3 = fcn.0040142e();\n        *(in_ECX + 0x3c) = uVar3;\n    }\n    if (var_4h != -1) {\n        if (((arg_24h & 1) == 0) || (iVar1 = fcn.00401109(),  iVar1 == 0)) {\n            if (((arg_24h & 2) == 0) || (iVar1 = fcn.0040142e(),  iVar1 == 0)) {\n                var_4h = -1;\n            }\n            else if ((var_4h < 0) || (iVar1 = fcn.004013c5(),  *(in_ECX + 0x3c) - iVar1 < var_4h)) {\n                var_4h = -1;\n            }\n            else {\n                iVar1 = fcn.004013c5();\n                iVar4 = fcn.0040142e();\n                fcn.004013e3((iVar1 - iVar4) + var_4h);\n            }\n        }\n        else if ((var_4h < 0) || (iVar1 = fcn.004013c5(),  *(in_ECX + 0x3c) - iVar1 < var_4h)) {\n            var_4h = -1;\n        }\n        else {\n            iVar1 = fcn.004013c5();\n            iVar4 = fcn.00401109();\n            fcn.00401118((iVar1 - iVar4) + var_4h);\n            if (((arg_24h & 2) != 0) && (iVar1 = fcn.0040142e(),  iVar1 != 0)) {\n                uVar3 = fcn.004010ff();\n                arg_ch_00 = fcn.00401109();\n                arg_8h_00 = fcn.00401334();\n                fcn.004012c6(arg_8h_00, arg_ch_00, uVar3);\n            }\n        }\n    }\n    puVar5 = fcn.00401087(var_4h);\n    puVar6 = arg_8h;\n    for (iVar1 = 6; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    return arg_8h;\n}\n",
        "token_count": 762
    },
    "0040bce0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040bce0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.0040127b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "004015a5": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004015a5(uint32_t arg_8h)\n\n{\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    if ((arg_8h & 1) == 0) {\n        var_4h = 4;\n    }\n    if ((arg_8h & 2) == 0) {\n        var_4h = var_4h | 2;\n    }\n    return var_4h;\n}\n",
        "token_count": 115
    },
    "00403030": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403030(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00401401();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 77
    },
    "0040a910": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040a910(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.004013cf();\n    if ((arg_8h & 1) != 0) {\n        fcn.00401564(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "00404900": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404900(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.0040104b();\n    if ((arg_8h & 1) != 0) {\n        fcn.00438360(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 78
    },
    "0041114b": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041114b(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    int32_t *piVar3;\n    char cVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    int32_t *piVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar5 = arg_8h[4];\n    iVar6 = *(arg_ch - 4);\n    piVar10 = arg_ch - 4;\n    uVar11 = arg_ch - arg_8h[3] >> 0xf;\n    uVar7 = *(arg_ch - 8);\n    var_ch = iVar6 + -1;\n    piVar3 = uVar11 * 0x204 + 0x144 + uVar5;\n    uVar13 = *(var_ch + piVar10);\n    if ((uVar13 & 1) == 0) {\n        arg_ch = (uVar13 >> 4) - 1;\n        if (0x3f < arg_ch) {\n            arg_ch = 0x3f;\n        }\n        if (*(iVar6 + 3 + piVar10) == *(iVar6 + 7 + piVar10)) {\n            if (arg_ch < 0x20) {\n                pcVar1 = arg_ch + 4 + uVar5;\n                uVar12 = ~(0x80000000U >> (arg_ch & 0x1f));\n                puVar2 = uVar5 + 0x44 + uVar11 * 4;\n                *puVar2 = *puVar2 & uVar12;\n                *pcVar1 = *pcVar1 + -1;\n                if (*pcVar1 == '\\0') {\n                    *arg_8h = *arg_8h & uVar12;\n                }\n            }\n            else {\n                pcVar1 = arg_ch + 4 + uVar5;\n                uVar12 = ~(0x80000000U >> (arg_ch - 0x20 & 0x1f));\n                puVar2 = uVar5 + 0xc4 + uVar11 * 4;\n                *puVar2 = *puVar2 & uVar12;\n                *pcVar1 = *pcVar1 + -1;\n                if (*pcVar1 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar12;\n                }\n            }\n        }\n        *(*(iVar6 + 7 + piVar10) + 4) = *(iVar6 + 3 + piVar10);\n        var_ch = var_ch + uVar13;\n        *(*(iVar6 + 3 + piVar10) + 8) = *(iVar6 + 7 + piVar10);\n    }\n    uVar13 = (var_ch >> 4) - 1;\n    if (0x3f < uVar13) {\n        uVar13 = 0x3f;\n    }\n    if ((uVar7 & 1) == 0) {\n        piVar10 = piVar10 - uVar7;\n        arg_ch = (uVar7 >> 4) - 1;\n        if (0x3f < arg_ch) {\n            arg_ch = 0x3f;\n        }\n        var_ch = var_ch + uVar7;\n        uVar13 = (var_ch >> 4) - 1;\n        if (0x3f < uVar13) {\n            uVar13 = 0x3f;\n        }\n        if (arg_ch != uVar13) {\n            if (piVar10[1] == piVar10[2]) {\n                if (arg_ch < 0x20) {\n                    pcVar1 = arg_ch + 4 + uVar5;\n                    uVar12 = ~(0x80000000U >> (arg_ch & 0x1f));\n                    puVar2 = uVar5 + 0x44 + uVar11 * 4;\n                    *puVar2 = *puVar2 & uVar12;\n                    *pcVar1 = *pcVar1 + -1;\n                    if (*pcVar1 == '\\0') {\n                        *arg_8h = *arg_8h & uVar12;\n                    }\n                }\n                else {\n                    pcVar1 = arg_ch + 4 + uVar5;\n                    uVar12 = ~(0x80000000U >> (arg_ch - 0x20 & 0x1f));\n                    puVar2 = uVar5 + 0xc4 + uVar11 * 4;\n                    *puVar2 = *puVar2 & uVar12;\n                    *pcVar1 = *pcVar1 + -1;\n                    if (*pcVar1 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar12;\n                    }\n                }\n            }\n            *(piVar10[2] + 4) = piVar10[1];\n            *(piVar10[1] + 8) = piVar10[2];\n        }\n    }\n    if (((uVar7 & 1) != 0) || (arg_ch != uVar13)) {\n        piVar10[1] = piVar3[uVar13 * 2 + 1];\n        piVar10[2] = piVar3 + uVar13 * 2;\n        (piVar3 + uVar13 * 2)[1] = piVar10;\n        *(piVar10[1] + 8) = piVar10;\n        if (piVar10[1] == piVar10[2]) {\n            cVar4 = *(uVar13 + 4 + uVar5);\n            *(uVar13 + 4 + uVar5) = cVar4 + '\\x01';\n            uVar9 = uVar13;\n            if (uVar13 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                puVar2 = uVar5 + 0x44 + uVar11 * 4;\n                *puVar2 = *puVar2 | 0x80000000U >> (uVar9 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n                puVar2 = uVar5 + 0xc4 + uVar11 * 4;\n                *puVar2 = *puVar2 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n            }\n        }\n    }\n    *piVar10 = var_ch;\n    *(var_ch + -4 + piVar10) = var_ch;\n    *piVar3 = *piVar3 + -1;\n    pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n    uVar5 = *0x49ef70;\n    puVar2 = *0x49ef78;\n    if ((*piVar3 == 0) && (uVar5 = uVar11,  puVar2 = arg_8h,  *0x49ef78 != NULL)) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x49ef70 * 0x8000 + (*0x49ef78)[3], 0x8000, 0x4000);\n        (*0x49ef78)[2] = (*0x49ef78)[2] | 0x80000000U >> (*0x49ef70 & 0x1f);\n        *((*0x49ef78)[4] + 0xc4 + *0x49ef70 * 4) = 0;\n        *((*0x49ef78)[4] + 0x43) = *((*0x49ef78)[4] + 0x43) + -1;\n        if (*((*0x49ef78)[4] + 0x43) == '\\0') {\n            (*0x49ef78)[1] = (*0x49ef78)[1] & 0xfffffffe;\n        }\n        puVar2 = arg_8h;\n        if ((*0x49ef78)[2] == 0xffffffff) {\n            (*pcVar8)((*0x49ef78)[3], 0, 0x8000);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(*0x49ef84, 0, (*0x49ef78)[4]);\n            fcn.0040dde0(*0x49ef78, *0x49ef78 + 5, (*0x49ef7c * 0x14 - *0x49ef78) + -0x14 + *0x49ef80);\n            *0x49ef7c = *0x49ef7c + -1;\n            if (*0x49ef78 < arg_8h) {\n                arg_8h = arg_8h + -5;\n            }\n            *0x49ef74 = *0x49ef80;\n            puVar2 = arg_8h;\n        }\n    }\n    *0x49ef78 = puVar2;\n    *0x49ef70 = uVar5;\n    return;\n}\n",
        "token_count": 2166
    },
    "0043fda9": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0043fda9(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t *arg_8h;\n    uint32_t uVar2;\n    \n    param_1[1] = param_3;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40);\n    *param_1 = iVar1;\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n        fcn.0040cd30(arg_8h, param_3 + 0x40, param_1[1]);\n        if (*(arg_8h + 2) == -1) {\n            uVar2 = arg_8h[3];\n        }\n        else {\n            uVar2 = *arg_8h;\n        }\n        param_1[2] = ~uVar2 >> 6 & 1;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*param_1);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 256
    },
    "0044d809": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044d809(int32_t *param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    \n    param_2 = param_2 & 0x300000;\n    uVar1 = fcn.0044d7f1();\n    if (uVar1 != param_2) {\n        param_1[0x1c] = param_2 >> 0x14 & 1;\n        param_1[0x1d] = param_2 >> 0x15;\n        if (0 < param_1[0x1b]) {\n            iVar4 = 0xea00;\n            do {\n                iVar3 = iVar4;\n                iVar2 = fcn.00439ccb();\n                if (iVar2 == 0) {\n                    iVar3 = (**(*param_1 + 200))(0, iVar4);\n                    if (iVar3 == 0) {\n                        fcn.00447b03();\n                    }\n                    iVar3 = iVar4;\n                    fcn.00439ccb(iVar4);\n                }\n                fcn.0043a0a7(-(param_1[0x1c] != 0) & 5, iVar3);\n                iVar3 = iVar4 + -0xe9ff;\n                iVar4 = iVar4 + 1;\n            } while (iVar3 < param_1[0x1b]);\n        }\n        if (0 < param_1[0x1a]) {\n            iVar4 = 0xea10;\n            do {\n                iVar3 = iVar4;\n                iVar2 = fcn.00439ccb();\n                if (iVar2 == 0) {\n                    iVar3 = (**(*param_1 + 200))(1, iVar4);\n                    if (iVar3 == 0) {\n                        fcn.00447b03();\n                    }\n                    iVar3 = iVar4;\n                    fcn.00439ccb(iVar4);\n                }\n                fcn.0043a0a7(-(param_1[0x1d] != 0) & 5, iVar3);\n                iVar3 = iVar4 + -0xea0f;\n                iVar4 = iVar4 + 1;\n            } while (iVar3 < param_1[0x1a]);\n        }\n        if ((param_1[0x1d] == 0) || (param_1[0x1c] == 0)) {\n            piVar5 = fcn.00439ccb(0xea20);\n            if (piVar5 != NULL) {\n                (**(*piVar5 + 0x58))();\n            }\n        }\n        else {\n            iVar4 = fcn.00439ccb(0xea20);\n            if (iVar4 == 0) {\n                iVar4 = (**(*param_1 + 200))(0x8000008, 0xea20);\n                if (iVar4 == 0) {\n                    fcn.00447b03();\n                }\n                fcn.00439ccb(0xea20);\n            }\n            fcn.0043a0a7(5);\n        }\n    }\n    return;\n}\n",
        "token_count": 707
    },
    "00450116": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00450116(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    int32_t var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar6 = 0;\n    var_18h = 0;\n    var_10h = 0;\n    var_ch = 0;\n    uVar2 = (**(*in_ECX + 0xa0))(0x455, 0, 0);\n    if (0 < arg_10h) {\n        var_4h = arg_10h;\n        puVar7 = arg_ch + 9;\n        do {\n            arg_ch = *(puVar7 + -9);\n            uVar3 = fcn.00439ecc();\n            if (((uVar3 & 0x800) == 0) && (*0x49851c != 0x40047)) {\n                arg_ch = (arg_ch * 2) / 3;\n            }\n            if ((puVar7[-1] & 8) == 0) {\n                uVar1 = *puVar7;\n                iVar5 = in_ECX[0x24];\n                if ((uVar1 & 1) == 0) {\n                    if (((uVar1 & 8) != 0) && ((uVar2 & 1) != 0)) {\n                        iVar5 = iVar5 + *0x498520;\n                    }\n                    if (var_10h < var_18h + iVar5) {\n                        var_10h = var_18h + iVar5;\n                    }\n                    iVar4 = in_ECX[0x25] + iVar6;\ncode_r0x004501e5:\n                    if (var_ch < iVar4) {\n                        var_ch = iVar4;\n                    }\n                }\n                else {\n                    if ((puVar7[-1] & 0x20) != 0) {\n                        iVar4 = in_ECX[0x25] + iVar6 + arg_ch;\n                        goto code_r0x004501e5;\n                    }\n                    if (var_10h < *(puVar7 + -9) + var_18h) {\n                        var_10h = *(puVar7 + -9) + var_18h;\n                    }\n                }\n                if ((uVar1 & 1) != 0) {\n                    iVar5 = *(puVar7 + -9);\n                }\n                var_18h = var_18h + iVar5;\n                if ((puVar7[-1] & 0x20) != 0) {\n                    var_18h = 0;\n                    iVar6 = iVar6 + in_ECX[0x25];\n                    if ((uVar1 & 1) != 0) {\n                        iVar6 = iVar6 + arg_ch;\n                    }\n                }\n            }\n            puVar7 = puVar7 + 0x14;\n            var_4h = var_4h + -1;\n        } while (var_4h != 0);\n    }\n    *arg_8h = var_10h;\n    arg_8h[1] = var_ch;\n    return;\n}\n",
        "token_count": 772
    },
    "0045046f": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n\nvoid __cdecl fcn.0045046f(int32_t *arg_8h, uint32_t arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint32_t *puVar3;\n    int32_t *in_ECX;\n    int32_t iVar4;\n    uint *puVar5;\n    uint32_t *puVar6;\n    uint32_t *puVar7;\n    uint *arg_8h_00;\n    uint32_t uVar8;\n    uint32_t lpRect;\n    uint *var_3ch;\n    uint32_t var_38h;\n    uint32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t lprc;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t *var_14h;\n    int32_t var_10h;\n    uint32_t *var_ch;\n    uint32_t *var_8h;\n    uint32_t *var_4h;\n    \n    puVar5 = NULL;\n    arg_8h_00 = 0x418;\n    var_4h = NULL;\n    var_30h = 0;\n    var_2ch = 0;\n    iVar1 = (**(*in_ECX + 0xa0))(0x418, 0, 0);\n    var_18h = iVar1;\n    if ((iVar1 == 0) || (var_4h = fcn.00438337(iVar1 * 0x14),  puVar6 = var_4h,  iVar1 < 1)) goto code_r0x0045072c;\n    do {\n        var_8h = puVar6;\n        arg_8h_00 = puVar5;\n        fcn.0044fedf();\n        var_8h = var_8h + 5;\n        puVar5 = puVar5 + 1;\n        puVar6 = var_8h;\n    } while (puVar5 < iVar1);\n    puVar6 = NULL;\n    if (iVar1 < 1) goto code_r0x0045072c;\n    uVar8 = in_ECX[0x19];\n    if ((uVar8 & 2) == 0) {\n        var_1ch = uVar8 & 4;\n        if (var_1ch == 0) {\ncode_r0x00450558:\n            uVar8 = -((arg_ch & 2) != 0) & 0x7fff;\n        }\n        else if ((arg_ch & 4) == 0) {\n            if ((arg_ch & 8) == 0) {\n                if ((arg_ch & 0x10) == 0) {\n                    if (arg_10h == 0xffffffff) {\n                        if ((uVar8 & 1) == 0) goto code_r0x00450558;\n                        goto code_r0x00450552;\n                    }\n                    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.0045046f::lprc);\n                    var_38h = arg_ch & 2;\n                    var_3ch = &fcn.0045046f::lprc;\n                    lpRect = 0x45052f;\n                    fcn.00451e14();\n                    lpRect = arg_ch & 0x20;\n                    if (lpRect == 0) {\n                        var_24h = var_20h - lprc;\n                    }\n                    else {\n                        var_24h = var_1ch - var_24h;\n                    }\n                    uVar8 = var_24h + arg_10h;\n                }\n                else {\n                    uVar8 = 0;\n                }\n            }\n            else {\n                uVar8 = 0x7fff;\n            }\n        }\n        else {\ncode_r0x00450552:\n            uVar8 = in_ECX[0x15];\n        }\n        fcn.00450312(var_4h, iVar1, uVar8, lpRect);\n    }\n    arg_8h_00 = &fcn.0045046f::var_20h;\n    piVar2 = fcn.00450116(arg_8h_00, var_4h, iVar1);\n    var_30h = *piVar2;\n    var_2ch = piVar2[1];\n    if ((arg_ch & 0x40) != 0) {\n        var_1ch = in_ECX[0x21];\n        in_ECX[0x21] = 0;\n        var_10h = 0;\n        if (0 < iVar1) {\n            var_14h = var_4h + 1;\n            puVar3 = var_14h;\n            iVar4 = iVar1;\n            do {\n                if (((*(puVar3 + 5) & 1) != 0) && (*puVar3 != 0)) {\n                    puVar6 = puVar6 + 1;\n                }\n                puVar3 = puVar3 + 5;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n            if (0 < puVar6) {\n                var_10h = fcn.00438337(puVar6 * 0x18);\n                if (var_10h == 0) {\n                    var_10h = 0;\n                }\n                var_ch = NULL;\n                arg_10h = NULL;\n                var_8h = var_10h + 8;\n                puVar3 = var_8h;\n                do {\n                    puVar7 = puVar3;\n                    if (((*(var_14h + 5) & 1) != 0) && (*var_14h != 0)) {\n                        puVar3[-2] = arg_10h;\n                        puVar3[-1] = *var_14h;\n                        (**(*in_ECX + 0xe0))(arg_10h, &fcn.0045046f::lpRect);\n                        arg_8h_00 = &fcn.0045046f::lpRect;\n                        fcn.0044707c(arg_8h_00);\n                        var_ch = var_ch + 1;\n                        *puVar3 = lpRect;\n                        puVar3[1] = var_3ch;\n                        puVar7 = var_8h + 6;\n                        puVar3[2] = var_38h;\n                        puVar3[3] = var_34h;\n                        iVar1 = var_18h;\n                        var_8h = puVar7;\n                    }\n                    arg_10h = arg_10h + 1;\n                    var_14h = var_14h + 5;\n                    puVar6 = var_ch;\n                    puVar3 = puVar7;\n                } while (arg_10h < iVar1);\n            }\n        }\n        if (((in_ECX[0x19] & 1U) != 0) && ((in_ECX[0x19] & 4U) != 0)) {\n            in_ECX[0x15] = var_30h;\n        }\n        arg_10h = NULL;\n        if (0 < iVar1) {\n            var_ch = var_4h;\n            do {\n                arg_8h_00 = arg_10h;\n                fcn.0044fefe(arg_10h, var_ch);\n                arg_10h = arg_10h + 1;\n                var_ch = var_ch + 5;\n            } while (arg_10h < iVar1);\n        }\n        if (0 < puVar6) {\n            piVar2 = var_10h + 8;\n            var_14h = puVar6;\n            do {\n                arg_8h_00 = piVar2[-1];\n                var_18h = fcn.00439ccb();\n                if (var_18h != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(*(var_18h + 0x1c), &fcn.0045046f::lpRect);\n                    iVar4 = var_3ch - piVar2[1];\n                    iVar1 = lpRect - *piVar2;\n                    (**(*in_ECX + 0xe0))(piVar2[-2], &fcn.0045046f::lpRect);\n                    arg_8h_00 = NULL;\n                    fcn.0043a058(0, iVar1 + lpRect, iVar4 + var_3ch, 0, 0, 0x15);\n                }\n                piVar2 = piVar2 + 6;\n                var_14h = var_14h + -1;\n            } while (var_14h != NULL);\n            fcn.00438360(var_10h, arg_8h_00);\n        }\n        in_ECX[0x21] = var_1ch;\n    }\n    fcn.00438360(var_4h);\ncode_r0x0045072c:\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.0045046f::lpRect, arg_8h_00);\n    fcn.00451e14(&fcn.0045046f::lpRect, arg_ch & 2);\n    var_2ch = var_3ch + (var_2ch - var_34h);\n    var_30h = var_30h + (lpRect - var_38h);\n    piVar2 = fcn.00450fa1(&fcn.0045046f::var_20h, arg_ch & 1, arg_ch & 2);\n    if (var_30h <= *piVar2) {\n        var_30h = *piVar2;\n    }\n    if (var_2ch <= piVar2[1]) {\n        var_2ch = piVar2[1];\n    }\n    *arg_8h = var_30h;\n    arg_8h[1] = var_2ch;\n    return;\n}\n",
        "token_count": 2235
    },
    "null": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl method.CToolBar.virtual_188(uint *arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    uint var_8h;\n    \n    if (((arg_ch == -1) && ((arg_10h & 0x44) == 0)) && (((arg_10h & 8) != 0 || ((arg_10h & 0x10) != 0)))) {\n        puVar1 = (**(*in_ECX + 0xb8))(&var_8h, arg_10h & 1, arg_10h & 8);\n        *arg_8h = *puVar1;\n        arg_8h[1] = puVar1[1];\n    }\n    else {\n        puVar1 = fcn.0045046f(&var_8h, arg_10h, arg_ch);\n        *arg_8h = *puVar1;\n        arg_8h[1] = puVar1[1];\n    }\n    return;\n}\n",
        "token_count": 240
    },
    "00458cc9": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00458cc9(int32_t *arg_8h, int32_t *arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t *arg_8h_00;\n    int16_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint lpBuffer;\n    int32_t lptm;\n    int32_t var_7ch;\n    uint var_54h;\n    uint var_4ch;\n    int32_t var_44h;\n    uint32_t var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint32_t var_30h;\n    int32_t var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    arg_8h_00 = arg_8h;\n    uVar2 = fcn.00439ecc();\n    var_24h = ~uVar2 >> 7 & 1;\n    uVar2 = fcn.004592b5();\n    if (arg_10h < uVar2) {\n        var_4h = fcn.00459205();\n        if (uVar2 < arg_14h) {\n            arg_14h = uVar2;\n        }\n        (*_sym.imp.GDI32.dll_GetTextMetricsA)(arg_8h[2], &lptm);\n        var_ch = var_7ch + lptm;\n        iVar1 = (*_sym.imp.USER32.dll_GetTabbedTextExtentA)(arg_8h[2], 0x472754, 1, 0, 0);\n        var_14h = ((*(in_ECX + 0x48) * iVar1) / 8) / 4;\n        (*_sym.imp.GDI32.dll_GetCharWidthA)(arg_8h[2], 0, 0xff, &lpBuffer);\n        uVar2 = arg_ch[1];\n        var_1ch = arg_ch[2] - *arg_ch;\n        (**(*arg_8h + 0x1c))();\n        iVar3 = fcn.00446dca(arg_ch);\n        arg_8h = uVar2;\n        do {\n            uVar2 = fcn.0045896f(var_4h, arg_14h, arg_10h);\n            if (arg_10h == uVar2) {\n                arg_8h = arg_8h + var_ch;\n            }\n            else if (var_24h == 0) {\n                var_34h = *arg_ch;\n                var_2ch = arg_ch[2];\n                var_30h = arg_8h;\n                var_28h = arg_8h + var_ch;\n                var_18h = var_28h;\n                if ((iVar3 != 1) && (iVar4 = (**(*arg_8h_00 + 0x58))(&var_34h),  iVar4 != 0)) {\n                    uVar5 = fcn.004589bd(arg_8h_00, &lpBuffer, var_1ch, var_14h, var_4h, arg_10h, uVar2);\n                    if (uVar5 < uVar2) {\n                        if ((*(*(uVar5 + var_4h) + 0x49f161) & 4) != 0) {\n                            uVar5 = uVar5 + 1;\n                        }\n                        uVar5 = uVar5 + 1;\n                    }\n                    (**(*arg_8h_00 + 100))\n                              (&var_4ch, var_34h, arg_8h, arg_10h + var_4h, uVar5 - arg_10h, 1, &var_14h, var_34h);\n                }\n                arg_8h = var_18h;\n            }\n            else {\n                var_10h = arg_8h + var_ch;\n                while( true ) {\n                    var_18h = fcn.004589bd(arg_8h_00, &lpBuffer, var_1ch, var_14h, var_4h, arg_10h, uVar2);\n                    var_8h = var_18h;\n                    if (var_18h != uVar2) {\n                        while ((arg_10h < var_8h && (iVar4 = fcn.0040e59d(*(var_8h + var_4h)),  iVar4 == 0))) {\n                            var_8h = var_8h - 1;\n                        }\n                        if (var_8h == arg_10h) {\n                            var_8h = var_18h;\n                        }\n                    }\n                    var_44h = *arg_ch;\n                    var_40h = arg_8h;\n                    var_3ch = arg_ch[2];\n                    var_38h = var_10h;\n                    if ((iVar3 != 1) && (iVar4 = (**(*arg_8h_00 + 0x58))(&var_44h),  iVar4 != 0)) {\n                        (**(*arg_8h_00 + 100))\n                                  (&var_54h, var_44h, arg_8h, arg_10h + var_4h, var_8h - arg_10h, 1, &var_14h, var_44h);\n                    }\n                    arg_8h = arg_8h + var_ch;\n                    var_10h = var_10h + var_ch;\n                    arg_10h = var_8h;\n                    if (uVar2 <= var_8h) break;\n                    do {\n                        iVar4 = fcn.0040e59d(*(arg_10h + var_4h));\n                        if (iVar4 == 0) break;\n                        arg_10h = arg_10h + 1;\n                    } while (arg_10h < uVar2);\n                    if ((uVar2 <= arg_10h) || (arg_ch[3] < var_10h)) break;\n                }\n            }\n            uVar2 = fcn.00458990();\n        } while ((uVar2 < arg_14h) && (arg_10h = uVar2,  arg_8h + var_ch <= arg_ch[3]));\n        (**(*arg_8h_00 + 0x20))(0xffffffff);\n        fcn.00459293();\n        arg_ch[3] = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 1544
    },
    "0045c302": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.0045c302(void)\n\n{\n    uint8_t uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint lpvBits;\n    \n    fcn.0046255d(8);\n    if (*0x49d4f8 == 0) {\n        iVar3 = 0;\n        puVar2 = &lpvBits;\n        do {\n            uVar1 = iVar3;\n            iVar3 = iVar3 + 1;\n            *puVar2 = 0x5555 << (uVar1 & 1);\n            puVar2 = puVar2 + 2;\n        } while (iVar3 < 8);\n        iVar3 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, &lpvBits);\n        if (iVar3 != 0) {\n            *0x49d4f8 = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar3);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar3);\n        }\n    }\n    fcn.004625cd(8);\n    fcn.004478c5(*0x49d4f8);\n    return;\n}\n",
        "token_count": 263
    },
    "0040ff5b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ff5b(uint8_t *arg_8h, int32_t arg_ch, uint8_t **arg_10h, uint32_t *arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint8_t **arg_10h_00;\n    uint32_t *arg_14h_00;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint var_4h;\n    \n    arg_14h_00 = arg_14h;\n    arg_10h_00 = arg_10h;\n    uVar1 = *arg_8h;\n    do {\n        if ((uVar1 == 0) || (*arg_14h_00 == 0)) {\n            return;\n        }\n        *0x49efa0 = 0;\n        uVar1 = *arg_8h;\n        uVar5 = 0;\n        puVar3 = arg_8h + 1;\n        do {\n            arg_10h = puVar3;\n            uVar4 = uVar5;\n            uVar5 = uVar4 + 1;\n            puVar3 = arg_10h + 1;\n        } while (*arg_10h == uVar1);\n        arg_14h._1_3_ = arg_14h >> 8;\n        if (uVar1 < 'e') {\n            if (uVar1 == 100) {\n                if (uVar4 == 0) {\n                    *0x49efa0 = 1;\n                }\n                else if (uVar4 != 1) {\n                    if (uVar4 == 2) {\n                        arg_14h = CONCAT31(arg_14h._1_3_, 0x61);\n                    }\n                    else {\n                        if (uVar4 != 3) goto code_r0x0040ffdf;\n                        arg_14h = CONCAT31(arg_14h._1_3_, 0x41);\n                    }\n                    goto code_r0x00410215;\n                }\n                arg_14h = CONCAT31(arg_14h._1_3_, 100);\n                goto code_r0x00410215;\n            }\n            if (uVar1 != 0x27) {\n                if (uVar1 != 0x41) {\n                    if (uVar1 == 0x48) {\n                        if (uVar4 == 0) {\n                            *0x49efa0 = 1;\n                        }\n                        else if (uVar5 != 2) goto code_r0x0040ffdf;\n                        arg_14h = CONCAT31(arg_14h._1_3_, 0x48);\n                        goto code_r0x00410215;\n                    }\n                    if (uVar1 == 0x4d) {\n                        if (uVar4 == 0) {\n                            *0x49efa0 = 1;\n                        }\n                        else if (uVar4 != 1) {\n                            if (uVar4 == 2) {\n                                arg_14h = CONCAT31(arg_14h._1_3_, 0x62);\n                            }\n                            else {\n                                if (uVar4 != 3) goto code_r0x0040ffdf;\n                                arg_14h = CONCAT31(arg_14h._1_3_, 0x42);\n                            }\n                            goto code_r0x00410215;\n                        }\n                        arg_14h = CONCAT31(arg_14h._1_3_, 0x6d);\n                        goto code_r0x00410215;\n                    }\n                    if (uVar1 != 0x61) goto code_r0x0040ffdf;\n                }\n                iVar2 = fcn.00414f70(arg_8h, \"am/pm\");\n                if (iVar2 == 0) {\n                    arg_10h = arg_8h + 5;\n                }\n                else {\n                    iVar2 = fcn.00414f70(arg_8h, 0x475ef0);\n                    if (iVar2 == 0) {\n                        arg_10h = arg_8h + 3;\n                    }\n                }\n                arg_14h = CONCAT31(arg_14h._1_3_, 0x70);\n                goto code_r0x00410215;\n            }\n            if ((uVar5 & 1) == 0) {\n                arg_10h = arg_8h + uVar5;\n            }\n            else {\n                arg_10h = arg_8h + uVar5;\n                while( true ) {\n                    uVar1 = *arg_10h;\n                    if ((uVar1 == 0) || (*arg_14h_00 == 0)) goto code_r0x00410005;\n                    if (uVar1 == 0x27) break;\n                    if (((*(*0x498f48 + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *arg_14h_00)) {\n                        **arg_10h_00 = uVar1;\n                        *arg_10h_00 = *arg_10h_00 + 1;\n                        arg_10h = arg_10h + 1;\n                        *arg_14h_00 = *arg_14h_00 - 1;\n                    }\n                    **arg_10h_00 = *arg_10h;\n                    *arg_10h_00 = *arg_10h_00 + 1;\n                    arg_10h = arg_10h + 1;\n                    *arg_14h_00 = *arg_14h_00 - 1;\n                }\n                arg_10h = arg_10h + 1;\n            }\n        }\n        else {\n            if (uVar1 == 0x68) {\n                if (uVar4 == 0) {\n                    *0x49efa0 = 1;\n                }\n                else if (uVar5 != 2) goto code_r0x0040ffdf;\n                arg_14h = CONCAT31(arg_14h._1_3_, 0x49);\n            }\n            else if (uVar1 == 0x6d) {\n                if (uVar4 == 0) {\n                    *0x49efa0 = 1;\n                }\n                else if (uVar5 != 2) goto code_r0x0040ffdf;\n                arg_14h = CONCAT31(arg_14h._1_3_, 0x4d);\n            }\n            else if (uVar1 == 0x73) {\n                if (uVar4 == 0) {\n                    *0x49efa0 = 1;\n                }\n                else if (uVar5 != 2) goto code_r0x0040ffdf;\n                arg_14h = CONCAT31(arg_14h._1_3_, 0x53);\n            }\n            else {\n                if (uVar1 == 0x74) {\n                    if (*(arg_ch + 8) < 0xc) {\n                        puVar3 = *(arg_18h + 0x98);\n                    }\n                    else {\n                        puVar3 = *(arg_18h + 0x9c);\n                    }\n                    while ((0 < uVar5 && (*arg_14h_00 != 0))) {\n                        if (((*(*0x498f48 + 1 + *puVar3 * 2) & 0x80) != 0) && (1 < *arg_14h_00)) {\n                            **arg_10h_00 = *puVar3;\n                            *arg_10h_00 = *arg_10h_00 + 1;\n                            puVar3 = puVar3 + 1;\n                            *arg_14h_00 = *arg_14h_00 - 1;\n                        }\n                        **arg_10h_00 = *puVar3;\n                        *arg_10h_00 = *arg_10h_00 + 1;\n                        puVar3 = puVar3 + 1;\n                        *arg_14h_00 = *arg_14h_00 - 1;\n                        uVar5 = uVar5 - 1;\n                    }\n                    goto code_r0x00410005;\n                }\n                if (uVar1 != 0x79) {\ncode_r0x0040ffdf:\n                    if ((*(*0x498f48 + 1 + uVar1 * 2) & 0x80) != 0) {\n                        **arg_10h_00 = uVar1;\n                        *arg_10h_00 = *arg_10h_00 + 1;\n                        *arg_14h_00 = *arg_14h_00 - 1;\n                        arg_8h = arg_8h + 1;\n                    }\n                    **arg_10h_00 = *arg_8h;\n                    *arg_10h_00 = *arg_10h_00 + 1;\n                    arg_10h = arg_8h + 1;\n                    *arg_14h_00 = *arg_14h_00 - 1;\n                    goto code_r0x00410005;\n                }\n                if (uVar4 == 1) {\n                    arg_14h = CONCAT31(arg_14h._1_3_, 0x79);\n                }\n                else {\n                    if (uVar4 != 3) goto code_r0x0040ffdf;\n                    arg_14h = CONCAT31(arg_14h._1_3_, 0x59);\n                }\n            }\ncode_r0x00410215:\n            fcn.0040fa8d(arg_14h, arg_ch, arg_10h_00, arg_14h_00, arg_18h);\n        }\ncode_r0x00410005:\n        uVar1 = *arg_10h;\n        arg_8h = arg_10h;\n    } while( true );\n}\n",
        "token_count": 2189
    },
    "00413a0f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00413a0f(uint arg_8h, uint8_t *arg_ch, uint *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint arg_ch_00;\n    int16_t *piVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint8_t uVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint64_t uVar11;\n    uint64_t uVar12;\n    uint var_248h;\n    uint var_49h;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uchar var_16h;\n    char var_15h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    var_30h = 0;\n    uVar8 = *arg_ch;\n    arg_ch = arg_ch + 1;\n    var_ch = 0;\n    var_14h = 0;\n    do {\n        if ((uVar8 == 0) || (var_14h < 0)) {\n            return var_14h;\n        }\n        if ((uVar8 < ' ') || ('x' < uVar8)) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = *(uVar8 + 0x4762bc) & 0xf;\n        }\n        var_30h = *(var_30h + 0x4762dc + uVar2 * 8) >> 4;\n    // switch table (8 cases) at 0x414130\n        switch(var_30h) {\n        case 0:\ncode_r0x00413bae:\n            var_24h = 0;\n            if ((*(*0x498f48 + 1 + uVar8 * 2) & 0x80) != 0) {\n                fcn.00414150(uVar8, arg_8h, &var_14h);\n                uVar8 = *arg_ch;\n                arg_ch = arg_ch + 1;\n            }\n            fcn.00414150(uVar8, arg_8h, &var_14h);\n            break;\n        case 1:\n            var_10h = -1;\n            var_34h = 0;\n            var_28h = 0;\n            var_20h = 0;\n            var_1ch = 0;\n            var_4h = 0;\n            var_24h = 0;\n            break;\n        case 2:\n            if (uVar8 == 0x20) {\n                var_4h = var_4h | 2;\n            }\n            else if (uVar8 == 0x23) {\n                var_4h = var_4h | 0x80;\n            }\n            else if (uVar8 == 0x2b) {\n                var_4h = var_4h | 1;\n            }\n            else if (uVar8 == 0x2d) {\n                var_4h = var_4h | 4;\n            }\n            else if (uVar8 == 0x30) {\n                var_4h = var_4h | 8;\n            }\n            break;\n        case 3:\n            if (uVar8 == 0x2a) {\n                var_20h = fcn.004141ee(&arg_10h);\n                if (var_20h < 0) {\n                    var_4h = var_4h | 4;\n                    var_20h = -var_20h;\n                }\n            }\n            else {\n                var_20h = uVar8 + -0x30 + var_20h * 10;\n            }\n            break;\n        case 4:\n            var_10h = 0;\n            break;\n        case 5:\n            if (uVar8 == 0x2a) {\n                var_10h = fcn.004141ee(&arg_10h);\n                if (var_10h < 0) {\n                    var_10h = -1;\n                }\n            }\n            else {\n                var_10h = uVar8 + -0x30 + var_10h * 10;\n            }\n            break;\n        case 6:\n            if (uVar8 == 0x49) {\n                if ((*arg_ch != 0x36) || (arg_ch[1] != 0x34)) {\n                    var_30h = 0;\n                    goto code_r0x00413bae;\n                }\n                arg_ch = arg_ch + 2;\n                var_4h = var_4h | 0x8000;\n            }\n            else if (uVar8 == 0x68) {\n                var_4h = var_4h | 0x20;\n            }\n            else if (uVar8 == 0x6c) {\n                var_4h = var_4h | 0x10;\n            }\n            else if (uVar8 == 0x77) {\n                var_4h = var_4h | 0x800;\n            }\n            break;\n        case 7:\n            puVar4 = var_8h;\n            if (uVar8 < 'h') {\n                if (uVar8 < 'e') {\n                    if (uVar8 < 'Y') {\n                        if (uVar8 == 0x58) {\ncode_r0x00413e8e:\n                            var_2ch = 7;\ncode_r0x00413e95:\n                            var_ch = 0x10;\n                            if ((var_4h & 0x80) != 0) {\n                                var_16h = 0x30;\n                                var_15h = var_2ch + 'Q';\n                                var_1ch = 2;\n                            }\n                            goto code_r0x00413eff;\n                        }\n                        if (uVar8 != 0x43) {\n                            if ((uVar8 != 0x45) && (uVar8 != 0x47)) {\n                                if (uVar8 == 0x53) {\n                                    if ((var_4h & 0x830) == 0) {\n                                        var_4h = var_4h | 0x800;\n                                    }\n                                    goto code_r0x00413c3c;\n                                }\n                                goto code_r0x00414019;\n                            }\n                            var_34h = 1;\n                            uVar8 = uVar8 + 0x20;\n                            goto code_r0x00413c9d;\n                        }\n                        if ((var_4h & 0x830) == 0) {\n                            var_4h = var_4h | 0x800;\n                        }\ncode_r0x00413cca:\n                        if ((var_4h & 0x810) == 0) {\n                            var_248h._0_1_ = fcn.004141ee(&arg_10h);\n                            var_ch = 1;\n                        }\n                        else {\n                            arg_ch_00 = fcn.0041420b();\n                            var_ch = fcn.00416133(&var_248h, arg_ch_00);\n                            if (var_ch < 0) {\n                                var_28h = 1;\n                            }\n                        }\n                        puVar4 = &var_248h;\n                    }\n                    else if (uVar8 == 0x5a) {\n                        piVar5 = fcn.004141ee(&arg_10h);\n                        if ((piVar5 == NULL) || (puVar4 = *(piVar5 + 2),  puVar4 == NULL)) {\n                            var_8h = *0x4992c0;\n                            puVar4 = *0x4992c0;\n                            goto code_r0x00413e0f;\n                        }\n                        if ((var_4h & 0x800) == 0) {\n                            var_24h = 0;\n                            var_ch = *piVar5;\n                        }\n                        else {\n                            var_ch = *piVar5 >> 1;\n                            var_24h = 1;\n                        }\n                    }\n                    else {\n                        if (uVar8 == 99) goto code_r0x00413cca;\n                        if (uVar8 == 100) goto code_r0x00413ef4;\n                    }\n                }\n                else {\ncode_r0x00413c9d:\n                    var_4h = var_4h | 0x40;\n                    puVar4 = &var_248h;\n                    if (var_10h < 0) {\n                        var_10h = 6;\n                    }\n                    else if ((var_10h == 0) && (uVar8 == 0x67)) {\n                        var_10h = 1;\n                    }\n                    unique0x00007a00 = *arg_10h;\n                    var_44h = arg_10h[1];\n                    arg_10h = arg_10h + 2;\n                    var_8h = puVar4;\n                    (**0x499160)(&var_49h + 1, &var_248h, uVar8, var_10h, var_34h);\n                    uVar2 = var_4h & 0x80;\n                    if ((uVar2 != 0) && (var_10h == 0)) {\n                        (**0x49916c)(&var_248h);\n                    }\n                    if ((uVar8 == 0x67) && (uVar2 == 0)) {\n                        (**0x499164)(&var_248h);\n                    }\n                    if (var_248h == '-') {\n                        var_4h = var_4h | 0x100;\n                        puVar4 = &var_248h + 1;\n                        var_8h = puVar4;\n                    }\ncode_r0x00413e0f:\n                    var_ch = fcn.0040d070(puVar4);\n                    puVar4 = var_8h;\n                }\n            }\n            else {\n                if (uVar8 == 0x69) {\ncode_r0x00413ef4:\n                    var_4h = var_4h | 0x40;\n                }\n                else {\n                    if (uVar8 == 0x6e) {\n                        piVar6 = fcn.004141ee(&arg_10h);\n                        if ((var_4h & 0x20) == 0) {\n                            *piVar6 = var_14h;\n                        }\n                        else {\n                            *piVar6 = var_14h;\n                        }\n                        var_28h = 1;\n                        break;\n                    }\n                    if (uVar8 == 0x6f) {\n                        var_ch = 8;\n                        if ((var_4h & 0x80) != 0) {\n                            var_4h = var_4h | 0x200;\n                        }\n                        goto code_r0x00413eff;\n                    }\n                    if (uVar8 == 0x70) {\n                        var_10h = 8;\n                        goto code_r0x00413e8e;\n                    }\n                    if (uVar8 == 0x73) {\ncode_r0x00413c3c:\n                        iVar9 = var_10h;\n                        if (var_10h == -1) {\n                            iVar9 = 0x7fffffff;\n                        }\n                        puVar3 = fcn.004141ee(&arg_10h);\n                        if ((var_4h & 0x810) == 0) {\n                            puVar4 = puVar3;\n                            if (puVar3 == NULL) {\n                                puVar3 = *0x4992c0;\n                                puVar4 = *0x4992c0;\n                            }\n                            for (; (iVar9 != 0 && (*puVar3 != '\\0')); puVar3 = puVar3 + 1) {\n                                iVar9 = iVar9 + -1;\n                            }\n                            var_ch = puVar3 - puVar4;\n                        }\n                        else {\n                            if (puVar3 == NULL) {\n                                puVar3 = *0x4992c4;\n                            }\n                            var_24h = 1;\n                            for (puVar4 = puVar3; (iVar9 != 0 && (*puVar4 != 0)); puVar4 = puVar4 + 2) {\n                                iVar9 = iVar9 + -1;\n                            }\n                            var_ch = puVar4 - puVar3 >> 1;\n                            puVar4 = puVar3;\n                        }\n                        goto code_r0x00414019;\n                    }\n                    if (uVar8 != 0x75) {\n                        if (uVar8 != 0x78) goto code_r0x00414019;\n                        var_2ch = 0x27;\n                        goto code_r0x00413e95;\n                    }\n                }\n                var_ch = 10;\ncode_r0x00413eff:\n                if ((var_4h & 0x8000) == 0) {\n                    if ((var_4h & 0x20) == 0) {\n                        if ((var_4h & 0x40) == 0) {\n                            uVar2 = fcn.004141ee(&arg_10h);\n                            uVar11 = uVar2;\n                            goto code_r0x00413f52;\n                        }\n                        uVar2 = fcn.004141ee(&arg_10h);\n                    }\n                    else if ((var_4h & 0x40) == 0) {\n                        uVar2 = fcn.004141ee(&arg_10h);\n                        uVar2 = uVar2 & 0xffff;\n                    }\n                    else {\n                        iVar1 = fcn.004141ee(&arg_10h);\n                        uVar2 = iVar1;\n                    }\n                    uVar11 = uVar2;\n                }\n                else {\n                    uVar11 = fcn.004141fb(&arg_10h);\n                }\ncode_r0x00413f52:\n                if ((((var_4h & 0x40) != 0) && (uVar11 < 0x100000000)) && (uVar11 < 0)) {\n                    uVar11 = CONCAT44(-((uVar11 >> 0x20) + (uVar11 != 0)), -uVar11);\n                    var_4h = var_4h | 0x100;\n                }\n                uVar2 = uVar11 >> 0x20;\n                if ((var_4h & 0x8000) == 0) {\n                    uVar2 = 0;\n                }\n                uVar12 = uVar11 & 0xffffffff | uVar2 << 0x20;\n                if (var_10h < 0) {\n                    var_10h = 1;\n                }\n                else {\n                    var_4h = var_4h & 0xfffffff7;\n                }\n                if ((uVar11 | uVar2) == 0) {\n                    var_1ch = 0;\n                }\n                var_8h = &var_49h;\n                while ((iVar9 = var_10h + -1,  0 < var_10h || (uVar12 != 0))) {\n                    var_3ch = var_ch >> 0x1f;\n                    var_40h = var_ch;\n                    var_10h = iVar9;\n                    iVar9 = fcn.00416270(uVar12, var_ch, var_3ch);\n                    iVar9 = iVar9 + 0x30;\n                    uVar12 = fcn.00416200();\n                    if (0x39 < iVar9) {\n                        iVar9 = iVar9 + var_2ch;\n                    }\n                    puVar4 = var_8h + -1;\n                    *var_8h = iVar9;\n                    var_8h = puVar4;\n                }\n                var_ch = &var_49h + -var_8h;\n                puVar4 = var_8h + 1;\n                var_10h = iVar9;\n                if (((var_4h & 0x200) != 0) && ((*puVar4 != '0' || (var_ch == 0)))) {\n                    var_ch = &var_49h + -var_8h + 1;\n                    *var_8h = '0';\n                    puVar4 = var_8h;\n                }\n            }\ncode_r0x00414019:\n            var_8h = puVar4;\n            uVar2 = var_4h;\n            if (var_28h == 0) {\n                if ((var_4h & 0x40) != 0) {\n                    if ((var_4h & 0x100) == 0) {\n                        if ((var_4h & 1) == 0) {\n                            if ((var_4h & 2) == 0) goto code_r0x00414051;\n                            var_16h = 0x20;\n                        }\n                        else {\n                            var_16h = 0x2b;\n                        }\n                    }\n                    else {\n                        var_16h = 0x2d;\n                    }\n                    var_1ch = 1;\n                }\ncode_r0x00414051:\n                iVar9 = (var_20h - var_1ch) - var_ch;\n                if ((var_4h & 0xc) == 0) {\n                    fcn.00414185(0x20, iVar9, arg_8h, &var_14h);\n                }\n                fcn.004141b6(&var_16h, var_1ch, arg_8h, &var_14h);\n                if (((uVar2 & 8) != 0) && ((uVar2 & 4) == 0)) {\n                    fcn.00414185(0x30, iVar9, arg_8h, &var_14h);\n                }\n                if ((var_24h == 0) || (uVar2 = var_ch,  puVar4 = var_8h,  var_ch < 1)) {\n                    fcn.004141b6(var_8h, var_ch, arg_8h, &var_14h);\n                }\n                else {\n                    do {\n                        uVar10 = uVar2 - 1;\n                        iVar7 = fcn.00416133(&var_38h, uVar2 & 0xffff0000 | *puVar4);\n                        if (iVar7 < 1) break;\n                        fcn.004141b6(&var_38h, iVar7, arg_8h, &var_14h);\n                        uVar2 = uVar10;\n                        puVar4 = puVar4 + 2;\n                    } while (uVar10 != 0);\n                }\n                if ((var_4h & 4) != 0) {\n                    fcn.00414185(0x20, iVar9, arg_8h, &var_14h);\n                }\n            }\n        }\n        uVar8 = *arg_ch;\n        arg_ch = arg_ch + 1;\n    } while( true );\n}\n",
        "token_count": 4322
    },
    "0043985a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t fcn.0043985a(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint noname_1;\n    uint32_t uVar4;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_10h;\n    int32_t *noname_4;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hWnd;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    uint noname_13;\n    \n    noname_13 = 0x439864;\n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = &fcn.0043985a::var_20h;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    iVar2 = extraout_ECX[0x11];\n    *(unaff_EBP + -0x18) = extraout_ECX[0x12];\n    var_20h = unaff_EDI;\n    var_1ch = unaff_ESI;\n    var_18h = unaff_EBX;\n    iVar1 = fcn.00460591();\n    uVar5 = *(iVar1 + 0xc);\n    if (extraout_ECX[0x10] != 0) {\n        iVar2 = fcn.00460591();\n        uVar5 = *(iVar2 + 0xc);\n        uVar3 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar5, extraout_ECX[0x10], 5);\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar5, uVar3);\n    }\n    if (iVar2 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        *(unaff_EBP + -0x18) = uVar3;\n    }\n    if (*(unaff_EBP + -0x18) == 0) {\n        iVar2 = -1;\n    }\n    else {\n        uVar3 = fcn.004397de();\n        *(unaff_EBP + -0x14) = uVar3;\n        fcn.0043afd2();\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14));\n            if (iVar2 != 0) {\n                (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n                *(unaff_EBP + -0x20) = 1;\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        noname_4 = extraout_ECX;\n        fcn.0043af86();\n        uVar3 = *(unaff_EBP + -0x14);\n        noname_1 = fcn.0043aad3();\n        iVar2 = fcn.004394ee(*(unaff_EBP + -0x18), noname_1, uVar5, uVar3, noname_4, var_20h, var_1ch, var_18h, hWnd, \n                             in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h, noname_13, unaff_retaddr, param_1, \n                             param_2, param_3, var_10h);\n        if (iVar2 != 0) {\n            if ((*(extraout_ECX + 9) & 0x10) != 0) {\n                uVar5 = 4;\n                uVar4 = fcn.00439ecc();\n                if ((uVar4 & 0x100) != 0) {\n                    uVar5 = 5;\n                }\n                fcn.0043d523(uVar5);\n            }\n            if (extraout_ECX[7] != 0) {\n                fcn.0043a058(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x20) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar2 == extraout_ECX[7]) {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n            }\n        }\n        (**(*extraout_ECX + 0x58))();\n        fcn.00439818();\n        iVar2 = extraout_ECX[0xb];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 1305
    },
    "00439e4a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00439e4a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint32_t arg_20h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (arg_18h != 0) {\n        arg_18h = *(arg_18h + 4);\n    }\n    uVar1 = (*_sym.imp.USER32.dll_ScrollWindowEx)\n                      (*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h);\n    if ((*(in_ECX + 0x34) != NULL) && ((arg_20h & 1) != 0)) {\n        (**(**(in_ECX + 0x34) + 0x58))(arg_8h, arg_ch);\n    }\n    return uVar1;\n}\n",
        "token_count": 230
    },
    "00439e99": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00439e99(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((*(param_1 + 0x25) & 1) == 0) {\n        (*_sym.imp.USER32.dll_IsDialogMessageA)(*(param_1 + 0x1c), param_2);\n    }\n    else {\n        iVar1 = fcn.00460591();\n        (**(**(iVar1 + 0x1038) + 0x24))(param_1, param_2);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "0043d523": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0043d57b)\n// WARNING: Removing unreachable block (ram,0x0043d58a)\n// WARNING: Removing unreachable block (ram,0x0043d590)\n// WARNING: Removing unreachable block (ram,0x0043d5a2)\n// WARNING: Removing unreachable block (ram,0x0043d5a9)\n// WARNING: Removing unreachable block (ram,0x0043d5af)\n// WARNING: Removing unreachable block (ram,0x0043d5b5)\n// WARNING: Removing unreachable block (ram,0x0043d5c8)\n// WARNING: Removing unreachable block (ram,0x0043d5cf)\n// WARNING: Removing unreachable block (ram,0x0043d5eb)\n\nint32_t __thiscall fcn.0043d523(int32_t *param_1, uint8_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t unaff_EBX;\n    \n    if ((param_2 & 4) != 0) {\n        fcn.00439ecc();\n    }\n    (*_sym.imp.USER32.dll_GetParent)(param_1[7]);\n    param_1[9] = param_1[9] | 0x18;\n    iVar2 = fcn.0043ded2();\n    pcVar1 = _sym.imp.USER32.dll_UpdateWindow;\n    while( true ) {\n        piVar3 = fcn.0043ded2();\n        iVar4 = (**(*piVar3 + 0x5c))();\n        if (iVar4 == 0) {\n            fcn.0046a1d8(0);\n            return -1;\n        }\n        if ((unaff_EBX != 0) && ((*(iVar2 + 0x34) == 0x118 || (*(iVar2 + 0x34) == 0x104)))) {\n            fcn.0043a0a7(1);\n            (*pcVar1)(param_1[7]);\n            unaff_EBX = 0;\n        }\n        iVar4 = (**(*param_1 + 0x70))();\n        if (iVar4 == 0) break;\n        piVar3 = fcn.0043ded2();\n        iVar4 = (**(*piVar3 + 100))(iVar2 + 0x30);\n        if (iVar4 != 0) {\n            unaff_EBX = 0;\n        }\n        (*_sym.imp.USER32.dll_PeekMessageA)(iVar2 + 0x30, 0, 0, 0, 0);\n    }\n    param_1[9] = param_1[9] & 0xffffffe7;\n    return param_1[0xb];\n}\n",
        "token_count": 626
    },
    "0043d76a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n\nbool __cdecl fcn.0043d76a(uint32_t arg_8h)\n\n{\n    uint noname_8;\n    uint noname_11;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    bool bVar4;\n    uint *noname_0;\n    uint32_t var_34h;\n    uint var_30h;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint var_1ch;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.00460591();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.0040d6f0(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.00460591();\n        noname_11 = *0x49d0c8;\n        noname_8 = *(iVar1 + 8);\n        noname_0 = 0x8;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            noname_0 = &var_34h;\n            var_34h = 0xb;\n            iVar1 = fcn.0043b7bc(noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0xb, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, *0x49d0c8, var_18h, in_stack_ffffffe8, \n                                 \"AfxWnd42s\", 8, var_8h);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            iVar1 = fcn.0043b7bc(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, var_34h, var_30h, \n                                 in_stack_ffffffd0, in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, var_18h, \n                                 in_stack_ffffffe8, \"AfxOleControl42s\", var_ch);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            iVar1 = fcn.0043b7bc(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, 0x10, in_stack_ffffffe8, \n                                 \"AfxControlBar42s\", var_ch);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            iVar1 = fcn.0043d6b2(&var_34h, \"AfxMDIFrame42s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            iVar1 = fcn.0043d6b2(&var_34h, \"AfxFrameOrView42s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.0043d6f3(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            uVar3 = uVar3 | 0x10;\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 2178
    },
    "0043ee56": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_178h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0043ee56(int32_t arg_8h, uint32_t lpMultiByteStr, uchar *arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uchar *puVar4;\n    int32_t *piStack432;\n    int32_t *piStack428;\n    uint uStack424;\n    uint *puStack420;\n    uint var_178h;\n    uint psfi;\n    uint var_162h;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    uVar3 = 0;\n    *arg_10h = 0;\n    iVar1 = (*_sym.imp.SHELL32.dll_SHGetFileInfoA)();\n    if ((iVar1 != 0) && ((var_162h & 1) != 0)) {\n        puStack420 = 0x43eeb0;\n        iVar1 = fcn.0043ec5c(0x4745a0, 0, 0x474590, &fcn.0043ee56::var_4h);\n        if (-1 < iVar1) {\n            puStack420 = &fcn.0043ee56::var_8h;\n            uStack424 = 0x476b40;\n            piStack428 = var_4h;\n            piStack432 = 0x43eec9;\n            iVar1 = (***var_4h)();\n            if (-1 < iVar1) {\n                if (lpMultiByteStr == 0) {\n                    puVar4 = NULL;\n                }\n                else {\n                    piStack432 = lpMultiByteStr;\n                    puVar4 = &stack0xfffffe50;\n                    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n                    fcn.0040d980();\n                    piStack432 = piStack432 & 0xffff0000;\n                    (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (0, 0, lpMultiByteStr, 0xffffffff, &stack0xfffffe50, iVar1 + 1);\n                }\n                piStack432 = NULL;\n                iVar1 = (**(*var_8h + 0x14))(var_8h, puVar4);\n                if (-1 < iVar1) {\n                    if (arg_8h == 0) {\n                        uVar2 = 0;\n                    }\n                    else {\n                        uVar2 = *(arg_8h + 0x1c);\n                    }\n                    iVar1 = (**(*var_4h + 0x4c))(var_4h, uVar2, 2);\n                    if (-1 < iVar1) {\n                        (**(*var_4h + 0xc))(var_4h, arg_10h, arg_14h, 0, 0);\n                        (**(*var_8h + 8))(var_8h);\n                        uVar3 = 1;\n                        goto code_r0x0043ef5c;\n                    }\n                }\n                (**(*var_8h + 8))(var_8h);\n            }\ncode_r0x0043ef5c:\n            piStack432 = var_4h;\n            (**(*var_4h + 8))();\n            return uVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 759
    },
    "0043fab3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043fab3(uint arg_8h, int32_t *arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_24h;\n    uint var_1ch;\n    uint var_14h;\n    uint *var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    var_ch = NULL;\n    var_8h = NULL;\n    var_4h = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(arg_8h);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (var_4h == 0xffffffff) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0043f31d(uVar2);\n    }\n    if (((*(arg_ch + 4) != var_4h) && ((var_4h & 1) != 0)) &&\n       (iVar3 = (*_sym.imp.KERNEL32.dll_SetFileAttributesA)(arg_8h, *(arg_ch + 4)),  iVar3 == 0)) {\n        uVar2 = (*pcVar1)(0);\n        fcn.0043f31d(uVar2);\n    }\n    if (arg_ch[1] != 0) {\n        fcn.0043fa00(arg_ch + 1, &var_24h);\n        if (arg_ch[2] != 0) {\n            fcn.0043fa00(arg_ch + 2, &var_14h);\n            var_8h = &var_14h;\n        }\n        if (*arg_ch != 0) {\n            fcn.0043fa00(arg_ch, &var_1ch);\n            var_ch = &var_1ch;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n        if (iVar3 == -1) {\n            uVar2 = (*pcVar1)(0);\n            fcn.0043f31d(uVar2);\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar3, var_ch, var_8h, &var_24h);\n        if (iVar4 == 0) {\n            uVar2 = (*pcVar1)(0);\n            fcn.0043f31d(uVar2);\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n        if (iVar3 == 0) {\n            uVar2 = (*pcVar1)(0);\n            fcn.0043f31d(uVar2);\n        }\n    }\n    if (((*(arg_ch + 4) != var_4h) && ((var_4h & 1) == 0)) &&\n       (iVar3 = (*_sym.imp.KERNEL32.dll_SetFileAttributesA)(arg_8h, *(arg_ch + 4)),  iVar3 == 0)) {\n        uVar2 = (*pcVar1)(0);\n        fcn.0043f31d(uVar2);\n    }\n    return;\n}\n",
        "token_count": 720
    },
    "0044085d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0044085d(uint *param_1, uint8_t param_2)\n\n{\n    uint *puVar1;\n    \n    if ((param_2 & 2) == 0) {\n        fcn.00438b48();\n        puVar1 = param_1;\n        if ((param_2 & 1) != 0) {\n            fcn.00438360(param_1);\n        }\n    }\n    else {\n        puVar1 = param_1 + -1;\n        fcn.0040efe8(param_1, 4, *puVar1, fcn.00438b48);\n        if ((param_2 & 1) != 0) {\n            fcn.00438360(puVar1);\n        }\n    }\n    return puVar1;\n}\n",
        "token_count": 179
    },
    "0044543a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044543a(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    if ((~*(arg_8h + 0x14) & 1) == 0) {\n        if (arg_10h != 0) {\n            do {\n                fcn.004453a2(arg_8h, arg_ch);\n                arg_ch = arg_ch + 4;\n                arg_10h = arg_10h + -1;\n            } while (arg_10h != 0);\n        }\n    }\n    else if (arg_10h != 0) {\n        do {\n            fcn.004452d2(arg_8h, arg_ch);\n            arg_ch = arg_ch + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "0044554b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * __cdecl fcn.0044554b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *extraout_ECX;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    piVar1 = *(unaff_EBP + 8);\n    iVar2 = *piVar1;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    (**(iVar2 + 0x18))(extraout_ECX + 4);\n    uVar3 = *(unaff_EBP + 0xc);\n    extraout_ECX[3] = 0xffffffff;\n    extraout_ECX[5] = uVar3;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[8] = piVar1;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[0xd] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[1] = 1;\n    if ((~uVar3 & 1) == 0) {\n        extraout_ECX[0xf] = 0x40;\n    }\n    else {\n        extraout_ECX[0xf] = 0x10;\n    }\n    uVar3 = *(unaff_EBP + 0x14);\n    extraout_ECX[6] = 1;\n    extraout_ECX[0xb] = uVar3;\n    iVar2 = *(unaff_EBP + 0x10);\n    extraout_ECX[0x10] = 0x89;\n    extraout_ECX[2] = 0;\n    if (iVar2 < 0x80) {\n        extraout_ECX[7] = 0x80;\n        extraout_ECX[0xb] = 0;\n    }\n    else {\n        extraout_ECX[7] = iVar2;\n    }\n    iVar2 = extraout_ECX[0xb];\n    *(unaff_EBP + 0x10) = extraout_ECX[7];\n    if (iVar2 == 0) {\n        iVar2 = (**(*piVar1 + 0x50))(3, 0, 0, 0);\n        extraout_ECX[2] = iVar2;\n        if (iVar2 == 0) {\n            uVar3 = fcn.00438337(extraout_ECX[7]);\n            extraout_ECX[0xb] = uVar3;\n            extraout_ECX[6] = 0;\n        }\n        else {\n            *(unaff_EBP + 0x10) = 0;\n        }\n    }\n    iVar4 = *(unaff_EBP + 0x10) + extraout_ECX[0xb];\n    extraout_ECX[10] = iVar4;\n    iVar2 = extraout_ECX[0xb];\n    if ((*(extraout_ECX + 5) & 1) != 0) {\n        iVar2 = iVar4;\n    }\n    uVar3 = *(unaff_EBP + -0xc);\n    extraout_ECX[9] = iVar2;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 817
    },
    "0044585c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044585c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    if ((*(param_1 + 0x14) & 1) == 0) {\n        iVar1 = *(param_1 + 0x24);\n        iVar2 = *(param_1 + 0x2c);\n        if (*(param_1 + 8) == 0) {\n            if (iVar1 != iVar2) {\n                (**(**(param_1 + 0x20) + 0x38))(iVar2, iVar1 - iVar2);\n            }\n        }\n        else {\n            if (iVar1 != iVar2) {\n                (**(**(param_1 + 0x20) + 0x50))(2, iVar1 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x20) + 0x50))(1, *(param_1 + 0x1c), param_1 + 0x2c, param_1 + 0x28);\n        }\n        *(param_1 + 0x24) = *(param_1 + 0x2c);\n    }\n    else {\n        if (*(param_1 + 0x28) != *(param_1 + 0x24)) {\n            (**(**(param_1 + 0x20) + 0x28))(*(param_1 + 0x24) - *(param_1 + 0x28), 1);\n        }\n        *(param_1 + 0x24) = *(param_1 + 0x28);\n    }\n    return;\n}\n",
        "token_count": 368
    },
    "0044ce5d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch_2\n\nuint __cdecl fcn.0044ce5d(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint uVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar2 = extraout_ECX[0x17];\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    iVar1 = iVar2 + *(unaff_EBP + 8) * 0x14;\n    if ((*(iVar2 + 0xc + *(unaff_EBP + 8) * 0x14) & 1) == 0) {\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar2 = *(*(iVar1 + 0x10) + -8);\n        }\n        else {\n            iVar2 = fcn.0040dd23(*(iVar1 + 0x10), *(unaff_EBP + 0xc));\n        }\n        if (iVar2 == 0) goto code_r0x0044cf09;\n    }\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.00438ad3();\n    }\n    else {\n        fcn.00438cd1(*(unaff_EBP + 0xc));\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) == 0) {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) | 1;\n    }\n    else {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) & 0xfffffffe;\n        if ((*(iVar1 + 0xb) & 4) == 0) {\n            uVar3 = *(iVar1 + 0x10);\n        }\n        else {\n            uVar3 = 0;\n        }\n        (**(*extraout_ECX + 0xa0))(0x401, *(iVar1 + 8) | *(unaff_EBP + 8), uVar3);\n    }\ncode_r0x0044cf09:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 614
    },
    "0044f47e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044f47e(uint noname_0, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = (**(*in_ECX + 0xfc))(arg_ch, arg_10h);\n    (**(*in_ECX + 0x11c))(0);\n    uVar2 = fcn.00439ecc();\n    if ((uVar2 & 1) != 0) {\n        if (iVar1 == 1) {\n            (**(*in_ECX + 0xd0))(*(in_ECX[0x1f] + 8) / 2);\n        }\n        else if (iVar1 == 2) {\n            (**(*in_ECX + 0xd4))(*(in_ECX[0x1e] + 8) / 2);\n        }\n        else if ((iVar1 < 0x65) || (0x73 < iVar1)) {\n            if ((iVar1 < 0xc9) || (0xd7 < iVar1)) {\n                if (iVar1 < 0x12d) {\n                    return;\n                }\n                if (0x20d < iVar1) {\n                    return;\n                }\n                piVar4 = (iVar1 + -0x12d) / 0xf;\n                iVar3 = (iVar1 + -0x12d) % 0xf;\n                iVar1 = (**(*in_ECX + 0xe0))(&var_4h, &arg_10h);\n                if (iVar1 != 0) {\n                    if (arg_10h == iVar3) {\n                        iVar3 = iVar3 + 1;\n                    }\n                    if (var_4h == piVar4) {\n                        piVar4 = piVar4 + 1;\n                    }\n                }\n                (**(*in_ECX + 0xd8))(piVar4);\n                iVar1 = *in_ECX;\n            }\n            else {\n                iVar3 = iVar1 + -0xc9;\n                iVar5 = (**(*in_ECX + 0xe0))(0, &arg_10h);\n                if ((iVar5 != 0) && (iVar3 == arg_10h)) {\n                    iVar3 = iVar1 + -200;\n                }\n                iVar1 = *in_ECX;\n            }\n            (**(iVar1 + 0xdc))(iVar3);\n        }\n        else {\n            iVar5 = iVar1 + -0x65;\n            iVar3 = (**(*in_ECX + 0xe0))(&arg_10h, 0);\n            if ((iVar3 != 0) && (iVar5 == arg_10h)) {\n                iVar5 = iVar1 + -100;\n            }\n            (**(*in_ECX + 0xd8))(iVar5);\n        }\n    }\n    return;\n}\n",
        "token_count": 672
    },
    "00450056": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00450056(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    uVar1 = param_1[0x19];\n    param_1[0x21] = 0;\n    if (((uVar1 & 1) == 0) || ((uVar1 & 4) == 0)) {\n        iVar2 = *param_1;\n        if ((uVar1 & 0xa000) == 0) {\n            uVar3 = 0x50;\n        }\n        else {\n            uVar3 = 0x4a;\n        }\n    }\n    else {\n        iVar2 = *param_1;\n        uVar3 = 0x46;\n    }\n    var_8h = param_1;\n    piStack8 = param_1;\n    (**(iVar2 + 0xbc))(&var_8h, 0, uVar3);\n    return;\n}\n",
        "token_count": 240
    },
    "00450238": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00450238(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint8_t *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar6 = 0;\n    iVar5 = 0;\n    var_4h = 0;\n    if (arg_ch < 1) {\ncode_r0x00450308:\n        return var_4h + 1;\n    }\ncode_r0x00450256:\n    piVar1 = arg_8h + iVar6 * 0x14;\n    *(piVar1 + 2) = *(piVar1 + 2) & 0xdf;\n    piVar2 = piVar1 + 2;\n    if ((*piVar2 & 8) == 0) {\n        if ((*(piVar1 + 9) & 1) == 0) {\n            iVar3 = *(in_ECX + 0x90);\n        }\n        else {\n            iVar3 = *piVar1;\n        }\n        iVar5 = iVar3 + iVar5;\n        iVar3 = iVar6;\n        if (arg_10h < iVar5) {\n            for (; (-1 < iVar3 && ((*piVar2 & 0x20) == 0)); piVar2 = piVar2 + -5) {\n                if (((*(piVar2 + 1) & 1) != 0) && ((piVar2[-1] == 0 && ((*piVar2 & 8) == 0)))) goto code_r0x004502ed;\n                iVar3 = iVar3 + -1;\n            }\n            iVar3 = iVar6 + -1;\n            if (-1 < iVar3) {\n                puVar4 = arg_8h + 8 + iVar3 * 0x14;\n                do {\n                    if ((*puVar4 & 0x20) != 0) break;\n                    if (((*puVar4 & 8) == 0) && (((puVar4[1] & 1) == 0 || (*(puVar4 + -4) == 0))))\n                    goto code_r0x004502ed;\n                    iVar3 = iVar3 + -1;\n                    puVar4 = puVar4 + -0x14;\n                } while (-1 < iVar3);\n            }\n        }\n    }\n    goto code_r0x004502fd;\ncode_r0x004502ed:\n    iVar5 = 0;\n    puVar4 = arg_8h + 8 + iVar3 * 0x14;\n    *puVar4 = *puVar4 | 0x20;\n    var_4h = var_4h + 1;\n    iVar6 = iVar3;\ncode_r0x004502fd:\n    iVar6 = iVar6 + 1;\n    if (arg_ch <= iVar6) goto code_r0x00450308;\n    goto code_r0x00450256;\n}\n",
        "token_count": 698
    },
    "00451548": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451548(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(in_ECX + 0x1c), 0x46, 0, arg_8h);\n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n        var_ch = var_ch - lpRect;\n        var_4h = *(arg_8h + 0x10);\n        var_8h = var_8h - var_10h;\n        iVar1 = *(arg_8h + 0x14);\n        if ((var_4h != var_ch) && ((*(in_ECX + 0x65) & 4) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_4h - *0x49d098, 0, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_ch - *0x49d098, 0, var_ch, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n        pcVar2 = _sym.imp.USER32.dll_SetRect;\n        if ((iVar1 != var_8h) && ((*(in_ECX + 0x65) & 8) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, 0, iVar1 - *0x49d09c, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*pcVar2)(&lpRect, 0, var_8h - *0x49d09c, var_4h, var_8h);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 581
    },
    "0045190d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0045190d(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint in_stack_ffffffec;\n    \n    uVar1 = fcn.00439ecc();\n    uVar2 = param_1[0x18];\n    uVar5 = 0;\n    if (((uVar2 & 1) == 0) || ((uVar1 & 0x10000000) == 0)) {\n        if (((uVar2 & 2) != 0) && ((uVar1 & 0x10000000) == 0)) {\n            uVar5 = 0x40;\n        }\n    }\n    else {\n        uVar5 = 0x80;\n    }\n    param_1[0x18] = uVar2 & 0xfffffffc;\n    if (uVar5 != 0) {\n        in_stack_ffffffec = 0;\n        fcn.0043a058(0, 0, 0, 0, 0, uVar5 | 0x17);\n    }\n    uVar2 = fcn.00439ecc();\n    if ((uVar2 & 0x10000000) != 0) {\n        if ((param_1[0x1c] != 0) && (uVar2 = fcn.00439ecc(),  (uVar2 & 0x10000000) == 0)) {\n            return 0;\n        }\n        piVar3 = fcn.0040c345();\n        if ((piVar3 == NULL) || (iVar4 = (**(*piVar3 + 0xb0))(),  iVar4 == 0)) {\n            piVar3 = fcn.0043c183();\n        }\n        if (piVar3 != NULL) {\n            (**(*param_1 + 0xc0))(piVar3, in_stack_ffffffec);\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 463
    },
    "00451a2f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00451a2f(uint noname_0, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint8_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    bool bVar7;\n    int32_t lprcDst;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar1 = (**(*in_ECX + 0xcc))(arg_ch);\n    if (((uVar1 & 0x10000000) != 0) && ((uVar1 & 0xf000) != 0)) {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, arg_ch + 1);\n        iVar6 = var_14h - lprcDst;\n        iVar5 = var_10h - var_18h;\n        bVar7 = arg_ch[7] != 0;\n        if (((var_4h[0x19] & 4U) == 0) || ((var_4h[0x19] & 1U) == 0)) {\n            if ((uVar1 & 0xa000) == 0) {\n                uVar4 = bVar7 | 0x10;\n            }\n            else {\n                uVar4 = bVar7 | 10;\n            }\n        }\n        else {\n            uVar4 = bVar7 | 6;\n        }\n        piVar2 = (**(*var_4h + 0xbc))(&var_ch, 0xffffffff, uVar4);\n        iVar3 = *piVar2;\n        if (iVar6 <= *piVar2) {\n            iVar3 = iVar6;\n        }\n        iVar6 = piVar2[1];\n        if (iVar5 <= piVar2[1]) {\n            iVar6 = iVar5;\n        }\n        if ((uVar1 & 0xa000) == 0) {\n            if ((uVar1 & 0x5000) != 0) {\n                arg_ch[5] = arg_ch[5] + iVar3;\n                iVar5 = arg_ch[6];\n                if (arg_ch[6] <= iVar6) {\n                    iVar5 = iVar6;\n                }\n                arg_ch[6] = iVar5;\n                if ((uVar1 & 0x1000) == 0) {\n                    if ((uVar1 & 0x4000) != 0) {\n                        lprcDst = var_14h - iVar3;\n                        arg_ch[3] = arg_ch[3] - iVar3;\n                    }\n                }\n                else {\n                    arg_ch[1] = arg_ch[1] + iVar3;\n                }\n            }\n        }\n        else {\n            arg_ch[6] = arg_ch[6] + iVar6;\n            iVar5 = arg_ch[5];\n            if (arg_ch[5] <= iVar3) {\n                iVar5 = iVar3;\n            }\n            arg_ch[5] = iVar5;\n            if ((uVar1 & 0x2000) == 0) {\n                if ((uVar1 & 0x8000) != 0) {\n                    var_18h = var_10h - iVar6;\n                    arg_ch[4] = arg_ch[4] - iVar6;\n                }\n            }\n            else {\n                arg_ch[2] = arg_ch[2] + iVar6;\n            }\n        }\n        var_14h = iVar3 + lprcDst;\n        var_10h = var_18h + iVar6;\n        if (*arg_ch != 0) {\n            fcn.0043c85e(arg_ch, var_4h[7], &lprcDst);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 880
    },
    "00451e14": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00451e14(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 100);\n    if ((uVar1 & 0x100) != 0) {\n        *param_2 = *param_2 + *0x49d098;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        param_2[1] = param_2[1] + *0x49d09c;\n    }\n    if ((uVar1 & 0x400) != 0) {\n        param_2[2] = param_2[2] - *0x49d098;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        param_2[3] = param_2[3] - *0x49d09c;\n    }\n    if (param_3 == 0) {\n        *param_2 = *param_2 + *(param_1 + 0x48);\n        param_2[1] = param_2[1] + *(param_1 + 0x40);\n        param_2[2] = param_2[2] - *(param_1 + 0x4c);\n        param_2[3] = param_2[3] - *(param_1 + 0x44);\n        if ((*(param_1 + 100) & 0x400001) == 0x400000) {\n            param_2[1] = param_2[1] + 7;\n        }\n    }\n    else {\n        *param_2 = *param_2 + *(param_1 + 0x40);\n        param_2[1] = param_2[1] + *(param_1 + 0x48);\n        param_2[2] = param_2[2] - *(param_1 + 0x44);\n        param_2[3] = param_2[3] - *(param_1 + 0x4c);\n        if ((*(param_1 + 100) & 0x400001) == 0x400000) {\n            *param_2 = *param_2 + 7;\n        }\n    }\n    return;\n}\n",
        "token_count": 523
    },
    "00458921": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00458921(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if ((~*(param_1 + 0x14) & 1) == 0) {\n        uVar1 = (**(**(param_1 + 0x20) + 0x30))();\n        if (0xfffff < uVar1) {\n            fcn.0044c0d8(0xf105, 0, 0xffffffff);\n            fcn.00447b1c();\n        }\n        fcn.004587d7(param_1, uVar1);\n    }\n    else {\n        fcn.004588c0(param_1);\n    }\n    return;\n}\n",
        "token_count": 157
    },
    "0045d8de": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045d8de(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = fcn.00439ecc();\n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if (((uVar3 & 0x80000000) != 0) &&\n       ((((arg_8h & 0xfff0) != 0xf060 ||\n         (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x73),  iVar2 < 0 && (iVar2 = (*pcVar1)(0x12),  iVar2 < 0)) &&\n          ((uVar3 & 0x100) != 0)))) && (iVar4 = fcn.0043c923(arg_8h, arg_ch),  iVar4 != 0)))) {\n        return;\n    }\n    fcn.0045ab5a(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 236
    },
    "00460c78": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00460c78(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *in_ECX;\n    int32_t var_ch;\n    \n    fcn.00451e14(arg_8h, arg_ch);\n    uVar2 = fcn.00439ecc();\n    if ((uVar2 & 0x100) != 0) {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        iVar4 = (*_sym.imp.USER32.dll_IsZoomed)(uVar3);\n        if (iVar4 == 0) {\n            (**(*in_ECX + 0xa0))(0x407, 0, &var_ch);\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            iVar5 = (*_sym.imp.USER32.dll_GetSystemMetrics)(5);\n            iVar4 = *(arg_8h + 8);\n            iVar6 = (*pcVar1)(2);\n            *(arg_8h + 8) = ((iVar4 + iVar5 * -2) - var_ch) - iVar6;\n        }\n    }\n    return;\n}\n",
        "token_count": 294
    },
    "00460ce8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n\nvoid __cdecl fcn.00460ce8(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t aiStack96 [2];\n    uint *puStack88;\n    uint var_34h;\n    int32_t lpRect;\n    uint dy;\n    int32_t var_20h;\n    int32_t var_18h;\n    int32_t var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_34h = unaff_EDI;\n    if (arg_8h != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)();\n        (*_sym.imp.USER32.dll_OffsetRect)();\n        puStack88 = 0x460d2e;\n        fcn.00460c78(&fcn.00460ce8::lpRect, 1);\n        puStack88 = &fcn.00460ce8::var_18h;\n        aiStack96[1] = 0;\n        aiStack96[0] = 0x407;\n        var_ch = &stack0xffffffa0;\n        (**(*in_ECX + 0xa0))();\n        arg_8h = 0;\n        iVar4 = in_ECX[0x16];\n        iVar5 = (var_20h - lpRect) + var_10h;\n        if (0 < iVar4) {\n            piVar2 = in_ECX[0x17] + 4;\n            iVar3 = iVar4;\n            do {\n                if ((*(piVar2 + 7) & 8) != 0) {\n                    arg_8h = arg_8h + 1;\n                }\n                iVar1 = *piVar2;\n                piVar2 = piVar2 + 5;\n                iVar5 = iVar5 + ((-6 - iVar1) - var_10h);\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n        fcn.0040d980();\n        var_8h = 0;\n        if (0 < iVar4) {\n            iVar4 = in_ECX[0x17] + 8;\n            var_ch = &stack0xffffffa0;\n            var_4h = &stack0xffffffa0;\n            do {\n                var_18h = var_18h + 6 + *(iVar4 + -4);\n                if (((*(iVar4 + 3) & 8) != 0) && (0 < iVar5)) {\n                    iVar3 = iVar5 / arg_8h;\n                    var_18h = var_18h + iVar3;\n                    arg_8h = arg_8h + -1;\n                    iVar5 = iVar5 - iVar3;\n                }\n                iVar4 = iVar4 + 0x14;\n                piVar2 = var_4h + 1;\n                *var_4h = var_18h;\n                var_4h = piVar2;\n                var_18h = var_18h + var_10h;\n                var_8h = var_8h + 1;\n            } while (var_8h < in_ECX[0x16]);\n        }\n        (**(*in_ECX + 0xa0))(0x404, in_ECX[0x16], var_ch);\n    }\n    iVar4 = 0;\n    if ((arg_ch != 0) && (0 < in_ECX[0x16])) {\n        puVar6 = in_ECX[0x17] + 0x10;\n        do {\n            if ((*(puVar6 + -1) & 1) != 0) {\n                fcn.0044ce5d(iVar4, *puVar6, 1, var_34h, unaff_ESI, unaff_EBX);\n            }\n            puVar6 = puVar6 + 5;\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < in_ECX[0x16]);\n    }\n    return;\n}\n",
        "token_count": 972
    },
    "00462712": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00462712(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    \n    iVar6 = param_1 + 0x1c;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(iVar6);\n    iVar7 = *(param_1 + 4);\n    iVar8 = *(param_1 + 8);\n    if ((iVar7 <= iVar8) || ((*(*(param_1 + 0x10) + iVar8 * 8) & 1) != 0)) {\n        iVar8 = 1;\n        if (1 < iVar7) {\n            puVar3 = *(param_1 + 0x10);\n            do {\n                puVar3 = puVar3 + 8;\n                if ((*puVar3 & 1) == 0) break;\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < iVar7);\n            if (iVar8 < iVar7) goto code_r0x004627f7;\n        }\n        iVar7 = iVar7 + 0x20;\n        if (*(param_1 + 0x10) == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, iVar7 * 8);\n        }\n        else {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar5);\n            iVar4 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)(uVar5, iVar7 * 8, 0x2002);\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GlobalLock;\n        if (iVar4 == 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*pcVar2)(uVar5);\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(iVar6);\n            fcn.0042eb4c();\n        }\n        iVar6 = (*pcVar2)(iVar4);\n        fcn.0040d6f0(iVar6 + *(param_1 + 4) * 8, 0, (*(param_1 + 4) * 0x1fffffff + iVar7) * 8);\n        *(param_1 + 0x10) = iVar6;\n        *(param_1 + 4) = iVar7;\n    }\ncode_r0x004627f7:\n    if (*(param_1 + 0xc) <= iVar8) {\n        *(param_1 + 0xc) = iVar8 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar8 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar8 + 1;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1);\n    return iVar8;\n}\n",
        "token_count": 710
    },
    "00462987": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00462987(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 0x1c);\n    iVar2 = 1;\n    if (1 < *(param_1 + 0xc)) {\n        do {\n            puVar1 = *(param_1 + 0x10) + iVar2 * 8;\n            if ((*(*(param_1 + 0x10) + 4 + iVar2 * 8) == 0) && ((*puVar1 & 1) != 0)) {\n                *(puVar1 + 4) = unaff_retaddr;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0xc));\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 0x1c);\n    return;\n}\n",
        "token_count": 224
    },
    "00465d29": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.00465d29(int32_t *param_1)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = *(*param_1 + 0x5c);\n    uVar1 = *(iVar2 + 0x1c);\n    if (*(iVar2 + 0x1e) <= uVar1 && uVar1 != *(iVar2 + 0x1e)) {\n        *(iVar2 + 0x1e) = uVar1;\n    }\n    iVar2 = fcn.00460591();\n    iVar2 = *(iVar2 + 4);\n    if (((param_1[2] == 0) && (param_1[3] == 0)) && ((param_1[1] == 0 || ((*(param_1 + 0xe) & 2) != 0)))) {\n        *(*(*param_1 + 0x5c) + 0x18) = *(*(*param_1 + 0x5c) + 0x1c);\n        *(*(*param_1 + 0x5c) + 0x1a) = *(*(*param_1 + 0x5c) + 0x1e);\n        iVar3 = fcn.00466871(*param_1);\n        if (iVar3 != 1) {\n            return 0;\n        }\n    }\n    else {\n        if (*(*(*param_1 + 0x5c) + 0x10) == 0) {\n            iVar3 = fcn.00466619(*(*param_1 + 0x5c));\n            if ((iVar3 == 0) &&\n               (((param_1[1] == 0 || ((*(param_1 + 0xe) & 1) != 0)) && (iVar3 = fcn.00466871(*param_1),  iVar3 != 1))))\n            {\n                return 0;\n            }\n            if ((*(*(*param_1 + 0x5c) + 0x10) == 0) && (iVar3 = fcn.0043044d(),  iVar3 == 0)) {\n                return 0;\n            }\n        }\n        *(*(*param_1 + 0x5c) + 0x18) = *(*(*param_1 + 0x5c) + 0x1c);\n        *(*(*param_1 + 0x5c) + 0x1a) = *(*(*param_1 + 0x5c) + 0x1e);\n    }\n    if (*(*(*param_1 + 0x5c) + 0x10) == 0) {\n        return 0;\n    }\n    param_1[6] = *(iVar2 + 0xb4);\n    fcn.0043a377(0xf044);\n    return 1;\n}\n",
        "token_count": 640
    },
    "00466668": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_160h\n\nvoid __cdecl fcn.00466668(uint arg_8h)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint16_t *puVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar7;\n    uint var_160h;\n    uint var_104h;\n    uint var_bch;\n    uint var_60h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    if ((*(unaff_EBP + 8) == 0) && (*(extraout_ECX + 0x98) != 0)) {\n        puVar4 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(extraout_ECX + 0x98));\n        if ((*(puVar4 + 3) & 1) == 0) goto code_r0x00466860;\n        fcn.004302b0(0x4666bc, 0x14000c, 0);\n        *(unaff_EBP + -4) = 0;\n        fcn.00430550();\n        if (*(*(unaff_EBP + -0x60) + 0xc) == 0) {\n            if (*(extraout_ECX + 0x94) != 0) {\n                fcn.00447d7f(*(extraout_ECX + 0x94));\n            }\n            fcn.00447d7f(*(extraout_ECX + 0x98));\n            *(extraout_ECX + 0x94) = 0;\n            *(extraout_ECX + 0x98) = 0;\n        }\n        else {\n            puVar5 = fcn.00430497(unaff_EBP + -0x10);\n            pcVar3 = _sym.imp.KERNEL32.dll_lstrcmpA;\n            uVar2 = *puVar5;\n            uVar1 = *puVar4;\n            *(unaff_EBP + -4) = 1;\n            iVar6 = (*pcVar3)(uVar1 + puVar4, uVar2);\n            if (iVar6 == 0) {\n                puVar5 = fcn.004304d4(unaff_EBP + -0x14);\n                iVar6 = (*pcVar3)(puVar4[1] + puVar4, *puVar5);\n                *(unaff_EBP + 0xb) = iVar6 != 0;\n                fcn.00438b48();\n                if (*(unaff_EBP + 0xb) != '\\0') goto code_r0x00466780;\n                puVar5 = fcn.00430512(unaff_EBP + -0x18);\n                iVar6 = (*pcVar3)(puVar4[2] + puVar4, *puVar5);\n                bVar7 = iVar6 != 0;\n                fcn.00438b48();\n                if (bVar7) goto code_r0x00466780;\n            }\n            else {\ncode_r0x00466780:\n                bVar7 = true;\n            }\n            *(unaff_EBP + -4) = 0;\n            fcn.00438b48();\n            if (bVar7) {\n                if (*(extraout_ECX + 0x94) != 0) {\n                    fcn.00447d7f(*(extraout_ECX + 0x94));\n                }\n                fcn.00447d7f();\n                iVar6 = *(unaff_EBP + -0x60);\n                *(extraout_ECX + 0x94) = *(iVar6 + 8);\n                *(extraout_ECX + 0x98) = *(iVar6 + 0xc);\n            }\n            else {\n                if (*(*(unaff_EBP + -0x60) + 8) != 0) {\n                    fcn.00447d7f();\n                }\n                if (*(*(unaff_EBP + -0x60) + 0xc) != 0) {\n                    fcn.00447d7f();\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    else {\n        fcn.004302b0(1, 0x14000c, 0);\n        *(unaff_EBP + -4) = 2;\n        fcn.00430550();\n        if (*(extraout_ECX + 0x94) != 0) {\n            fcn.00447d7f(*(extraout_ECX + 0x94));\n        }\n        if (*(extraout_ECX + 0x98) != 0) {\n            fcn.00447d7f(*(extraout_ECX + 0x98));\n        }\n        iVar6 = *(unaff_EBP + -0x104);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x94) = *(iVar6 + 8);\n        *(extraout_ECX + 0x98) = *(iVar6 + 0xc);\n    }\n    fcn.00439395();\ncode_r0x00466860:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1208
    },
    "00402121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00402121(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b473;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    param_1[0x14] = 0;\n    if (((param_1[0x16] != 0) && (param_1[0x17] != 0)) && (param_1[0x19] != 0)) {\n        fcn.004015e6();\n        var_4h = 0;\n        fcn.00401474();\n        var_4h._0_1_ = 1;\n        iVar1 = fcn.0043a377(0x7d65);\n        if (iVar1 != 0) {\n            var_34h = 1;\n            uVar2 = fcn.00438d77(&var_7ch, param_1 + 0x15, &var_14h);\n            var_4h._0_1_ = 2;\n            fcn.00438c81(uVar2);\n            var_4h._0_1_ = 1;\n            fcn.00438b48();\n            fcn.004016a4(param_1[0x19]);\n            fcn.0044585c();\n        }\n        var_4h = var_4h._1_3_ << 8;\n        fcn.00438b48();\n        var_4h = 0xffffffff;\n        fcn.004013cf();\n    }\n    if (param_1[0x19] != 0) {\n        fcn.00401258(1);\n    }\n    param_1[0x19] = 0;\n    if (param_1[0x18] != 0) {\n        fcn.00401258(1);\n    }\n    param_1[0x18] = 0;\n    if (param_1[0x17] != NULL) {\n        (**(*param_1[0x17] + 4))(1);\n    }\n    param_1[0x17] = 0;\n    if (param_1[0x16] != 0) {\n        fcn.00401519(1);\n        do {\n            iVar1 = (**(*param_1[0x16] + 0x14))(&var_70h, 0x32, 0);\n        } while (0 < iVar1);\n    }\n    if (param_1[0x16] != NULL) {\n        (**(*param_1[0x16] + 4))(1);\n    }\n    param_1[0x16] = 0;\n    var_10h = (**(*param_1 + 0x60))();\n    while (var_10h != 0) {\n        var_74h = (**(*param_1 + 100))(&var_10h);\n        iVar1 = fcn.0043a281();\n        if (iVar1 != 0) {\n            var_78h = var_74h;\n            fcn.004014d8(0x49b3dc);\n            fcn.00439f62();\n        }\n    }\n    fcn.0044426f();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 956
    },
    "0040105a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040105a(int32_t *param_1)\n\n{\n    uint *puVar1;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((*param_1 != 0) && (puVar1 = fcn.00401190(),  puVar1 != NULL)) {\n        (***puVar1)(1);\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "00401069": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00401069(uint param_1, uchar *param_2)\n\n{\n    char cVar1;\n    uchar uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uchar *var_ch;\n    uint var_10h;\n    uint32_t var_6ch;\n    uint var_64h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uchar *var_18h;\n    uint32_t var_14h;\n    uchar *puStack20;\n    uint var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b769;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    puStack20 = &stack0xffffff84;\n    var_14h = 0;\n    var_18h = var_ch;\n    fcn.0040136b(var_8h, 0);\n    cVar1 = fcn.00401352();\n    if (cVar1 != '\\0') {\n        uVar3 = fcn.00401465(&var_2ch);\n        var_4h = 0;\n        var_20h = fcn.00401073(uVar3, 0, 1);\n        var_4h = 0xffffffff;\n        fcn.0040105a();\n        var_4h = 1;\n        iVar4 = fcn.00401131();\n        if (iVar4 < 1) {\n            var_44h = 0x7fffffff;\n        }\n        else {\n            var_44h = fcn.00401131();\n        }\n        var_28h = var_44h;\n        fcn.004010a5();\n        var_24h = fcn.0040106e();\n        while (var_28h = var_28h + -1,  0 < var_28h) {\n            var_30h = fcn.004015d2();\n            cVar1 = fcn.004014ce(&var_30h, &var_24h);\n            if (cVar1 != '\\0') {\n                var_14h = var_14h | 1;\n                break;\n            }\n            uVar3 = fcn.00401627(&var_24h);\n            cVar1 = fcn.00401578(0x48, uVar3);\n            if (cVar1 != '\\0') break;\n            uVar2 = fcn.00401627(&var_24h);\n            *var_18h = uVar2;\n            var_18h = var_18h + 1;\n            fcn.004010a5();\n            var_24h = fcn.0040168b();\n        }\n        var_4h = 0xffffffff;\n    }\n    *var_18h = 0;\n    fcn.0040150f(0);\n    if (var_18h == var_ch) {\n        var_6ch = var_14h | 2;\n    }\n    else {\n        var_6ch = var_14h;\n    }\n    fcn.004010be(var_6ch, 0);\n    *in_FS_OFFSET = var_ch_2;\n    return var_8h;\n}\n",
        "token_count": 852
    },
    "00401073": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00401073(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b6f4;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    var_14h = fcn.004011d6();\n    var_10h = fcn.0041b36d(var_14h, 1);\n    if (var_10h == 0) {\n        if ((arg_10h == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n            fcn.00401299(\"missing locale facet\");\n            fcn.0040d1e1(&var_24h, 0x47b670);\n        }\n        if (*0x49b3e0 == 0) {\n            iVar2 = fcn.00438337(0x18);\n            var_4h._0_1_ = 1;\n            if (iVar2 == 0) {\n                var_34h = 0;\n            }\n            else {\n                var_34h = fcn.00401384(0, 0, 0);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            *0x49b3e0 = fcn.00401032(var_34h);\n            var_10h = *0x49b3e0;\n        }\n        else {\n            var_10h = *0x49b3e0;\n        }\n    }\n    iVar2 = var_10h;\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 535
    },
    "0040a0ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040a0ba(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    if (*(param_1 + 0x74) != 0) {\n        fcn.004013a2(*(param_1 + 0x74));\n    }\n    fcn.0043b34b();\n    return;\n}\n",
        "token_count": 79
    },
    "004010af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.004010af(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b794;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    var_14h = fcn.004011d6();\n    var_10h = fcn.0041b36d(var_14h, 1);\n    if (var_10h == 0) {\n        if ((arg_10h == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n            fcn.00401299(\"missing locale facet\");\n            fcn.0040d1e1(&var_24h, 0x47b670);\n        }\n        if (*0x49b3e4 == 0) {\n            iVar2 = fcn.00438337(8);\n            var_4h._0_1_ = 1;\n            if (iVar2 == 0) {\n                var_34h = 0;\n            }\n            else {\n                var_34h = fcn.004012c1(0);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            *0x49b3e4 = fcn.0040155a(var_34h);\n            var_10h = *0x49b3e4;\n        }\n        else {\n            var_10h = *0x49b3e4;\n        }\n    }\n    iVar2 = var_10h;\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 527
    },
    "004010be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004010be(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t in_EAX;\n    uint32_t arg_ch_00;\n    uint32_t uVar1;\n    uint var_4h;\n    \n    if (arg_8h != 0) {\n        arg_ch_00 = in_EAX & 0xffffff00 | arg_ch & 0xff;\n        uVar1 = fcn.00401249();\n        fcn.00401587(uVar1 | arg_8h, arg_ch_00);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "0040aeca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040aeca(void)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bc0a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00401244(0x298);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = fcn.004010fa();\n    }\n    *in_FS_OFFSET = var_ch;\n    return var_18h;\n}\n",
        "token_count": 188
    },
    "00409930": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid fcn.00409930(void)\n\n{\n    uint *puVar1;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46ba49;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    puVar1 = fcn.00401190();\n    if (puVar1 == NULL) {\n        var_1ch = 0;\n    }\n    else {\n        var_1ch = (***puVar1)(1);\n    }\n    *0x49b3ec = 0;\n    var_4h = 0xffffffff;\n    fcn.0041af79(var_1ch);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 247
    },
    "00407a10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.00407a10(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            uint *arg_24h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint *puVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    char *pcVar6;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint *var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b919;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_10h = 1;\n    var_18h = 0;\n    while( true ) {\n        puVar3 = fcn.0040d5c8();\n        *puVar3 = 0;\n        uVar4 = fcn.00401465(&var_40h);\n        var_4h = 0;\n        uVar4 = fcn.0040113b(&var_3ch, &arg_ch, &arg_14h, 0x800, uVar4);\n        uVar4 = fcn.0040d53e(&var_3ch, &var_1ch, uVar4);\n        (&var_14h)[var_18h] = uVar4;\n        var_4h = 0xffffffff;\n        fcn.0040105a();\n        cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n        if (cVar1 != '\\0') {\n            *arg_20h = *arg_20h | 1;\n        }\n        if ((var_1ch == &var_3ch) || (piVar5 = fcn.0040d5c8(),  *piVar5 != 0)) {\n            *arg_20h = *arg_20h | 2;\n            goto code_r0x00407b55;\n        }\n        var_18h = var_18h + 1;\n        if (0 < var_18h) goto code_r0x00407b55;\n        cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n        if (cVar1 != '\\0') break;\n        pcVar6 = fcn.004014ab();\n        cVar1 = *pcVar6;\n        cVar2 = fcn.00401582(0x3a);\n        if (cVar1 != cVar2) break;\n        fcn.004011bd();\n    }\n    *arg_20h = *arg_20h | 2;\ncode_r0x00407b55:\n    if ((*arg_20h & 2) == 0) {\n        *arg_24h = var_14h;\n    }\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 760
    },
    "00403ae0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00403ae0(uchar *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    uint arg_ch_00;\n    int32_t *in_ECX;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_8h = 0;\n    do {\n        while( true ) {\n            if (arg_ch < 1) {\n                return var_8h;\n            }\n            iVar3 = fcn.00401109();\n            if (iVar3 != 0) break;\ncode_r0x00403b74:\n            var_4h = (**(*in_ECX + 0x14))();\n            var_10h = fcn.004015d2();\n            cVar1 = fcn.004014ce(&var_10h, &var_4h);\n            if (cVar1 != '\\0') {\n                return var_8h;\n            }\n            uVar2 = fcn.00401627(&var_4h);\n            *arg_8h = uVar2;\n            arg_8h = arg_8h + 1;\n            var_8h = var_8h + 1;\n            arg_ch = arg_ch + -1;\n        }\n        iVar3 = fcn.004013b6();\n        var_ch = fcn.00401109();\n        var_ch = iVar3 - var_ch;\n        if (var_ch < 1) goto code_r0x00403b74;\n        if (arg_ch < var_ch) {\n            var_ch = arg_ch;\n        }\n        iVar3 = var_ch;\n        arg_ch_00 = fcn.00401109();\n        fcn.004015aa(arg_8h, arg_ch_00, iVar3);\n        arg_8h = arg_8h + var_ch;\n        var_8h = var_8h + var_ch;\n        arg_ch = arg_ch - var_ch;\n        fcn.00401118(var_ch);\n    } while( true );\n}\n",
        "token_count": 478
    },
    "0040113b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040113b(char *arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h, uint arg_18h)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    char cVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint *in_FS_OFFSET;\n    ulong uVar6;\n    uint var_70h;\n    int32_t var_6ch;\n    uint32_t var_68h;\n    uint32_t var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    int32_t var_44h;\n    int32_t var_40h;\n    char *var_3ch;\n    char *var_38h;\n    uint var_34h;\n    uint32_t var_30h;\n    uint var_2ch;\n    char *var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b942;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_34h._0_1_ = fcn.00401582(0x30);\n    var_10h = fcn.0040146a(arg_18h, 0, 1);\n    fcn.004015ff(&var_54h);\n    var_4h = 0;\n    var_58h._0_1_ = fcn.004015cd();\n    var_1ch = arg_8h;\n    cVar2 = fcn.004012ad(arg_ch, arg_10h);\n    if (cVar2 == '\\0') {\n        pcVar4 = fcn.004014ab();\n        cVar2 = *pcVar4;\n        cVar3 = fcn.00401582(0x2b);\n        if (cVar2 == cVar3) {\n            *var_1ch = '+';\n            var_1ch = var_1ch + 1;\n            fcn.004011bd();\n        }\n        else {\n            pcVar4 = fcn.004014ab();\n            cVar2 = *pcVar4;\n            cVar3 = fcn.00401582(0x2d);\n            if (cVar2 == cVar3) {\n                *var_1ch = '-';\n                var_1ch = var_1ch + 1;\n                fcn.004011bd();\n            }\n        }\n    }\n    arg_14h = arg_14h & 0xe00;\n    if (arg_14h == 0x400) {\n        var_64h = 8;\n    }\n    else {\n        if (arg_14h == 0x800) {\n            var_68h = 0x10;\n        }\n        else {\n            var_68h = -(arg_14h != 0) & 10;\n        }\n        var_64h = var_68h;\n    }\n    var_18h = var_64h;\n    var_14h = var_14h & 0xffffff00;\n    var_30h = var_30h & 0xffffff00;\n    cVar2 = fcn.0040128a(arg_ch, arg_10h);\n    if ((cVar2 == '\\0') || (pcVar4 = fcn.004014ab(),  *pcVar4 != var_34h)) goto code_r0x00407efd;\n    var_14h = CONCAT31(var_14h._1_3_, 1);\n    fcn.004011bd();\n    cVar2 = fcn.0040128a(arg_ch, arg_10h);\n    if (cVar2 != '\\0') {\n        pcVar4 = fcn.004014ab();\n        cVar2 = *pcVar4;\n        cVar3 = fcn.00401582(0x78);\n        if (cVar2 != cVar3) {\n            pcVar4 = fcn.004014ab();\n            cVar2 = *pcVar4;\n            cVar3 = fcn.00401582(0x58);\n            if (cVar2 != cVar3) goto code_r0x00407ef0;\n        }\n        if ((var_18h == 0) || (var_18h == 0x10)) {\n            var_18h = 0x10;\n            var_14h = var_14h & 0xffffff00;\n            fcn.004011bd();\n            goto code_r0x00407efd;\n        }\n    }\ncode_r0x00407ef0:\n    if (var_18h == 0) {\n        var_18h = 8;\n    }\ncode_r0x00407efd:\n    if ((var_18h == 0) || (var_18h == 10)) {\n        var_6ch = 10;\n    }\n    else {\n        var_6ch = (-(var_18h != 8) & 0xe) + 8;\n    }\n    var_44h = var_6ch;\n    fcn.0040152d(1, (var_14h & 0xff) != 0, &var_5ch);\n    var_4h = CONCAT31(var_4h._1_3_, 1);\n    var_40h = 0;\n    var_38h = arg_8h + 0x1f;\n    while (cVar2 = fcn.0040128a(arg_ch, arg_10h),  cVar2 != '\\0') {\n        uVar6 = fcn.004014ab(var_44h);\n        cVar2 = fcn.0040126c(uVar6 >> 0x20 & 0xffffff00 | *uVar6);\n        *var_1ch = cVar2;\n        iVar5 = fcn.0040d640(\"0123456789abcdefABCDEF\", *var_1ch);\n        if (iVar5 == 0) {\n            pcVar4 = fcn.004011c7(var_40h);\n            if (((*pcVar4 == '\\0') || (var_58h == '\\0')) || (pcVar4 = fcn.004014ab(),  *pcVar4 != var_58h)) break;\n            fcn.0040130c(1, 0);\n            var_40h = var_40h + 1;\n        }\n        else {\n            if ((((var_30h & 0xff) != 0) || (*var_1ch != '0')) && (var_1ch < var_38h)) {\n                var_1ch = var_1ch + 1;\n                var_30h = CONCAT31(var_30h._1_3_, 1);\n            }\n            var_14h = CONCAT31(var_14h._1_3_, 1);\n            pcVar4 = fcn.004011c7(var_40h);\n            if (*pcVar4 != '\\x7f') {\n                pcVar4 = fcn.004011c7(var_40h);\n                *pcVar4 = *pcVar4 + '\\x01';\n            }\n        }\n        fcn.004011bd();\n    }\n    if (var_40h != 0) {\n        pcVar4 = fcn.004011c7(var_40h);\n        if (*pcVar4 < '\\x01') {\n            var_14h = var_14h & 0xffffff00;\n        }\n        else {\n            var_40h = var_40h + 1;\n        }\n    }\n    var_3ch = fcn.004011cc();\n    while (((uVar1 = var_18h,  (var_14h & 0xff) != 0 && (var_40h != 0)) && (*var_3ch != '\\x7f'))) {\n        var_40h = var_40h + -1;\n        if (((var_40h == 0) || (cVar2 = *var_3ch,  pcVar4 = fcn.004011c7(var_40h),  cVar2 == *pcVar4)) &&\n           ((var_40h != 0 || (cVar2 = *var_3ch,  pcVar4 = fcn.004011c7(0),  *pcVar4 <= cVar2)))) {\n            if ('\\0' < var_3ch[1]) {\n                var_3ch = var_3ch + 1;\n            }\n        }\n        else {\n            var_14h = var_14h & 0xffffff00;\n        }\n        var_40h = var_40h + -1;\n    }\n    if (((var_14h & 0xff) == 0) || ((var_30h & 0xff) != 0)) {\n        if ((var_14h & 0xff) == 0) {\n            var_1ch = arg_8h;\n        }\n    }\n    else {\n        *var_1ch = '0';\n        var_1ch = var_1ch + 1;\n    }\n    *var_1ch = '\\0';\n    var_4h = var_4h & 0xffffff00;\n    fcn.0040125d();\n    var_4h = 0xffffffff;\n    fcn.0040125d();\n    *in_FS_OFFSET = var_ch;\n    return uVar1;\n}\n",
        "token_count": 2144
    },
    "00401145": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401145(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b4b0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00438cd1(arg_8h);\n    iVar1 = fcn.00401244(0x18);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_4ch = 0;\n    }\n    else {\n        var_4ch = fcn.0040150a(in_ECX);\n    }\n    var_4h = 0xffffffff;\n    *(in_ECX + 0x58) = var_4ch;\n    iVar1 = fcn.00401023(0, 1, 0);\n    if (iVar1 == 0) {\n        if (*(in_ECX + 0x58) != NULL) {\n            (**(**(in_ECX + 0x58) + 4))(1);\n        }\n        *(in_ECX + 0x58) = 0;\n        fcn.0044c0d8(0x7d66, 0, 0xffffffff);\n        uVar2 = 0;\n    }\n    else {\n        do {\n            iVar1 = fcn.00468185(arg_ch, arg_10h + 700);\n            if (iVar1 != 0) {\n                iVar1 = fcn.00401244(0x18);\n                var_4h = 1;\n                if (iVar1 == 0) {\n                    var_58h = 0;\n                }\n                else {\n                    var_58h = fcn.00468bec(*(in_ECX + 0x58), 1);\n                }\n                var_4h = 0xffffffff;\n                *(in_ECX + 0x5c) = var_58h;\n                iVar1 = fcn.00438337(0x44);\n                var_4h = 2;\n                if (iVar1 == 0) {\n                    var_5ch = 0;\n                }\n                else {\n                    var_5ch = fcn.0044554b(*(in_ECX + 0x5c), 1, 0x1000, 0);\n                }\n                var_4h = 0xffffffff;\n                *(in_ECX + 0x60) = var_5ch;\n                iVar1 = fcn.00438337(0x44);\n                var_4h = 3;\n                if (iVar1 == 0) {\n                    var_60h = 0;\n                }\n                else {\n                    var_60h = fcn.0044554b(*(in_ECX + 0x5c), 0, 0x1000, 0);\n                }\n                var_4h = 0xffffffff;\n                *(in_ECX + 100) = var_60h;\n                fcn.00401474();\n                var_4h = 4;\n                iVar1 = fcn.0043a377(0x7d68);\n                if (iVar1 != 0) {\n                    fcn.004014c9(&var_10h);\n                }\n                var_4h = 0xffffffff;\n                fcn.00438b48();\n                uVar2 = 1;\n                goto code_r0x004026b0;\n            }\n            iVar1 = fcn.0044c0d8(0x7d67, 4, 0xffffffff);\n        } while (iVar1 != 7);\n        if (*(in_ECX + 0x58) != NULL) {\n            (**(**(in_ECX + 0x58) + 4))(1);\n        }\n        *(in_ECX + 0x58) = 0;\n        uVar2 = 0;\n    }\ncode_r0x004026b0:\n    *in_FS_OFFSET = var_ch;\n    return uVar2;\n}\n",
        "token_count": 1077
    },
    "004070c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl\nfcn.004070c0(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            int16_t *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint arg_18h;\n    uint arg_14h_00;\n    int32_t *piVar3;\n    uint *in_FS_OFFSET;\n    uint var_54h;\n    uint *var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint *var_1ch;\n    uint *var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b839;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    arg_18h = fcn.00401465(&var_40h);\n    var_4h = 0;\n    arg_14h_00 = fcn.00401339();\n    var_10h = fcn.0040113b(&var_3ch, &arg_ch, &arg_14h, arg_14h_00, arg_18h);\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    if (var_3ch == '-') {\n        var_50h = &var_3ch + 1;\n    }\n    else {\n        var_50h = &var_3ch;\n    }\n    var_18h = var_50h;\n    var_14h = fcn.0040d53e(var_50h, &var_1ch, var_10h);\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (((var_1ch == var_18h) || (piVar3 = fcn.0040d5c8(),  *piVar3 != 0)) || (0xffff < var_14h)) {\n        *arg_20h = *arg_20h | 2;\n    }\n    else {\n        var_54h._0_2_ = var_14h;\n        if (var_3ch == '-') {\n            var_54h._0_2_ = -var_54h;\n        }\n        *arg_24h = var_54h;\n    }\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 696
    },
    "00407790": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl\nfcn.00407790(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            uint *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    float10 fVar5;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint *var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b8d9;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    uVar3 = fcn.00401465(&var_68h);\n    var_4h = 0;\n    uVar3 = fcn.00401276(&var_64h, &arg_ch, &arg_14h, uVar3);\n    fVar5 = fcn.0041d4c7(&var_64h, &var_18h, uVar3);\n    _var_14h = fVar5;\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (var_18h != &var_64h) {\n        piVar4 = fcn.0040d5c8();\n        if (*piVar4 == 0) {\n            *arg_24h = var_14h;\n            arg_24h[1] = var_10h;\n            goto code_r0x00407867;\n        }\n    }\n    *arg_20h = *arg_20h | 2;\ncode_r0x00407867:\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 573
    },
    "00407660": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.00407660(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            float *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    float10 fVar5;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint *var_14h;\n    float var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b8b9;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    uVar3 = fcn.00401465(&var_64h);\n    var_4h = 0;\n    uVar3 = fcn.00401276(&var_60h, &arg_ch, &arg_14h, uVar3);\n    fVar5 = fcn.0041d503(&var_60h, &var_14h, uVar3);\n    var_10h = fVar5;\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (var_14h != &var_60h) {\n        piVar4 = fcn.0040d5c8();\n        if (*piVar4 == 0) {\n            *arg_24h = var_10h;\n            goto code_r0x00407731;\n        }\n    }\n    *arg_20h = *arg_20h | 2;\ncode_r0x00407731:\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 539
    },
    "00407520": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.00407520(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            uint *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint uVar3;\n    uint arg_14h_00;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b899;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    uVar3 = fcn.00401465(&var_38h);\n    var_4h = 0;\n    arg_14h_00 = fcn.00401339();\n    uVar3 = fcn.0040113b(&var_34h, &arg_ch, &arg_14h, arg_14h_00, uVar3);\n    var_10h = fcn.0040d53e(&var_34h, &var_14h, uVar3);\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (var_14h != &var_34h) {\n        piVar4 = fcn.0040d5c8();\n        if (*piVar4 == 0) {\n            *arg_24h = var_10h;\n            goto code_r0x004075fa;\n        }\n    }\n    *arg_20h = *arg_20h | 2;\ncode_r0x004075fa:\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 554
    },
    "00401168": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401168(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint32_t var_34h;\n    int32_t *var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = fcn.004012a8();\n    var_20h = *(*(iVar2 + 0xc) + 0xc);\n    do {\n        do {\n            if (var_20h[6] == 0) {\n                return 0;\n            }\n            iVar2 = var_20h[6];\n            iVar4 = *(iVar2 + *(iVar2 + 0x3c) + 0x78);\n            var_20h = *var_20h;\n        } while (iVar4 == 0);\n        iVar4 = iVar2 + iVar4;\n        uVar1 = *(iVar4 + 0x18);\n        var_30h = iVar2 + *(iVar4 + 0x20);\n        for (var_34h = 0; var_34h < uVar1; var_34h = var_34h + 1) {\n            iVar3 = *var_30h;\n            var_30h = var_30h + 1;\n            iVar3 = fcn.00401613(iVar3 + iVar2, arg_8h);\n            if (iVar3 == 0) {\n                var_28h = *(iVar2 + *(iVar4 + 0x24) + var_34h * 2);\n                return iVar2 + *(iVar2 + *(iVar4 + 0x1c) + var_28h * 4);\n            }\n        }\n    } while( true );\n}\n",
        "token_count": 490
    },
    "004073e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.004073e0(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            uint *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint uVar3;\n    uint arg_14h_00;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b879;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    uVar3 = fcn.00401465(&var_38h);\n    var_4h = 0;\n    arg_14h_00 = fcn.00401339();\n    uVar3 = fcn.0040113b(&var_34h, &arg_ch, &arg_14h, arg_14h_00, uVar3);\n    var_10h = fcn.0040d322(&var_34h, &var_14h, uVar3);\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (var_14h != &var_34h) {\n        piVar4 = fcn.0040d5c8();\n        if (*piVar4 == 0) {\n            *arg_24h = var_10h;\n            goto code_r0x004074ba;\n        }\n    }\n    *arg_20h = *arg_20h | 2;\ncode_r0x004074ba:\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 554
    },
    "00407250": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl\nfcn.00407250(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            int32_t *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint arg_18h;\n    uint arg_14h_00;\n    int32_t *piVar3;\n    uint *in_FS_OFFSET;\n    int32_t var_54h;\n    uint *var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint *var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b859;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    arg_18h = fcn.00401465(&var_40h);\n    var_4h = 0;\n    arg_14h_00 = fcn.00401339();\n    var_10h = fcn.0040113b(&var_3ch, &arg_ch, &arg_14h, arg_14h_00, arg_18h);\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    if (var_3ch == '-') {\n        var_50h = &var_3ch + 1;\n    }\n    else {\n        var_50h = &var_3ch;\n    }\n    var_18h = var_50h;\n    var_14h = fcn.0040d53e(var_50h, &var_1ch, var_10h);\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if ((var_1ch == var_18h) || (piVar3 = fcn.0040d5c8(),  *piVar3 != 0)) {\n        *arg_20h = *arg_20h | 2;\n    }\n    else {\n        if (var_3ch == '-') {\n            var_54h = -var_14h;\n        }\n        else {\n            var_54h = var_14h;\n        }\n        *arg_24h = var_54h;\n    }\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 682
    },
    "004078d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl\nfcn.004078d0(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            uint *arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    float10 fVar5;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint *var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b8f9;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0;\n    uVar3 = fcn.00401465(&var_68h);\n    var_4h = 0;\n    uVar3 = fcn.00401276(&var_64h, &arg_ch, &arg_14h, uVar3);\n    fVar5 = fcn.0041d518(&var_64h, &var_18h, uVar3);\n    _var_14h = fVar5;\n    var_4h = 0xffffffff;\n    fcn.0040105a();\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (var_18h != &var_64h) {\n        piVar4 = fcn.0040d5c8();\n        if (*piVar4 == 0) {\n            *arg_24h = var_14h;\n            arg_24h[1] = var_10h;\n            goto code_r0x004079a7;\n        }\n    }\n    *arg_20h = *arg_20h | 2;\ncode_r0x004079a7:\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 574
    },
    "00401181": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401181(code **param_1)\n\n{\n    uint var_4h;\n    \n    *param_1 = vtable.std::ctype_char_.0;\n    if (param_1[5] != NULL) {\n        fcn.0040d21b(param_1[4]);\n    }\n    fcn.004011b3();\n    return;\n}\n",
        "token_count": 83
    },
    "00401190": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00401190(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0041aedd();\n    if ((*(param_1 + 4) != 0) && (*(param_1 + 4) != -1)) {\n        *(param_1 + 4) = *(param_1 + 4) + -1;\n    }\n    iVar1 = *(param_1 + 4);\n    fcn.0041af79();\n    return ~-(iVar1 != 0) & param_1;\n}\n",
        "token_count": 146
    },
    "004011a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004011a4(uint arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b5e6;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_10h != 0) {\n        *in_ECX = 0x471120;\n        fcn.004010aa();\n        var_4h = 0;\n    }\n    fcn.00401451(in_ECX + 2, 0, 0);\n    var_4h = 1;\n    fcn.00401221(arg_8h, arg_ch | 1);\n    *(in_ECX + *(*in_ECX + 4)) = 0x47111c;\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 255
    },
    "00401d80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00401d80(void)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b3fa;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00401244(0x68);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = fcn.0040169a();\n    }\n    *in_FS_OFFSET = var_ch;\n    return var_18h;\n}\n",
        "token_count": 189
    },
    "004011c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004011c2(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_44h;\n    uint var_40h;\n    uint var_38h;\n    int32_t var_30h;\n    uint var_2ch;\n    uchar *puStack20;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b515;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puStack20 = &stack0xffffff64;\n    fcn.004015e6();\n    var_4h = 0;\n    fcn.0043a538();\n    var_4h = CONCAT31(var_4h >> 8, 2);\n    fcn.004016a4(*(param_1 + 0x60));\n    while (iVar1 = fcn.00401622(),  iVar1 == 0) {\n        fcn.00434aa9(&var_44h);\n        var_4h._0_1_ = 3;\n        arg_8h = fcn.00401573();\n        fcn.00401424(arg_8h);\n        var_4h = CONCAT31(var_4h._1_3_, 2);\n        fcn.00438b48();\n    }\n    var_4h = 0;\n    fcn.00401460();\n    if (var_30h != 0) {\n        if (*(param_1 + 0x60) != 0) {\n            fcn.00401258(1);\n        }\n        *(param_1 + 0x60) = 0;\n        if (*(param_1 + 100) != 0) {\n            fcn.00401258(1);\n        }\n        *(param_1 + 100) = 0;\n        if (*(param_1 + 0x5c) != NULL) {\n            (**(**(param_1 + 0x5c) + 4))(1);\n        }\n        *(param_1 + 0x5c) = 0;\n        if (*(param_1 + 0x58) != NULL) {\n            (**(**(param_1 + 0x58) + 4))(1);\n        }\n        *(param_1 + 0x58) = 0;\n    }\n    var_4h = 0xffffffff;\n    fcn.004013cf();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 706
    },
    "004011c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004011c7(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if ((*(in_ECX + 8) < arg_8h) || (*(in_ECX + 4) == 0)) {\n        iVar1 = fcn.0040141a();\n    }\n    else {\n        fcn.00401569();\n        iVar1 = *(in_ECX + 4) + arg_8h;\n    }\n    return iVar1;\n}\n",
        "token_count": 127
    },
    "004011cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004011cc(int32_t param_1)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(param_1 + 4) == 0) {\n        var_8h = fcn.0040141a();\n    }\n    else {\n        var_8h = *(param_1 + 4);\n    }\n    return var_8h;\n}\n",
        "token_count": 91
    },
    "004011d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004011d6(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0041aedd();\n    if (*param_1 == 0) {\n        *0x49d948 = *0x49d948 + 1;\n        *param_1 = *0x49d948;\n    }\n    iVar1 = *param_1;\n    fcn.0041af79();\n    return iVar1;\n}\n",
        "token_count": 126
    },
    "00406dd0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl\nfcn.00406dd0(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint noname_4, uint arg_1ch, uint32_t *arg_20h, \n            uint arg_24h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint *puVar4;\n    int32_t *piVar5;\n    uint *in_FS_OFFSET;\n    uint uVar6;\n    uint uVar7;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_64h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint *var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b80d;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_10h = 0xffffffff;\n    uVar2 = fcn.00401339();\n    if ((uVar2 & 0x4000) == 0) {\n        puVar4 = fcn.0040d5c8();\n        *puVar4 = 0;\n        uVar3 = fcn.00401465(&var_78h);\n        var_4h = 4;\n        uVar6 = fcn.00401339();\n        uVar3 = fcn.0040113b(&var_4ch, &arg_ch, &arg_14h, uVar6, uVar3);\n        var_28h = fcn.0040d53e(&var_4ch, &var_2ch, uVar3);\n        var_4h = 0xffffffff;\n        fcn.0040105a();\n        if (var_2ch != &var_4ch) {\n            piVar5 = fcn.0040d5c8();\n            if ((*piVar5 == 0) && (var_28h < 2)) {\n                var_10h = var_28h;\n            }\n        }\n    }\n    else {\n        uVar7 = 1;\n        uVar6 = 0;\n        puVar4 = &var_50h;\n        uVar3 = fcn.00401465(puVar4);\n        var_4h = 0;\n        var_14h = fcn.0040146a(uVar3, puVar4, uVar6);\n        var_4h = 0xffffffff;\n        fcn.0040105a(uVar7);\n        fcn.0040152d(1, 0, &var_54h);\n        var_4h = 1;\n        uVar3 = fcn.004014fb(&var_64h);\n        var_4h._0_1_ = 2;\n        fcn.004010d7(uVar3);\n        var_4h._0_1_ = 1;\n        fcn.0040125d();\n        fcn.004011d1(0);\n        uVar3 = fcn.004012a3(&var_74h);\n        var_4h._0_1_ = 3;\n        fcn.004010d7(uVar3);\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        fcn.0040125d();\n        uVar3 = fcn.004011cc();\n        var_10h = fcn.00401505(&arg_ch, &arg_14h, 2, uVar3);\n        var_4h = 0xffffffff;\n        fcn.0040125d();\n    }\n    cVar1 = fcn.004012ad(&arg_ch, &arg_14h);\n    if (cVar1 != '\\0') {\n        *arg_20h = *arg_20h | 1;\n    }\n    if (var_10h < 0) {\n        *arg_20h = *arg_20h | 2;\n    }\n    else {\n        *arg_24h = var_10h != 0;\n    }\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_10h;\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 1075
    },
    "00401217": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nbool __fastcall fcn.00401217(uint param_1)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.0040154b(param_1);\n    return *(iVar1 + 4) == 0;\n}\n",
        "token_count": 76
    },
    "00409fe1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409fe1(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bafd;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if ((arg_8h == 0xd) && (arg_ch == 1)) {\n        (*_sym.imp.SHELL32.dll_CommandLineToArgvW)(0x49b400, 0);\n        (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(0, 0, 0);\n        fcn.00401483();\n        fcn.00401474();\n        var_4h = 0;\n        fcn.004014d8(&var_10h);\n        fcn.0043b4ca();\n        fcn.004014c9(&var_10h);\n        fcn.00438cd1(0x49b404);\n        uVar1 = fcn.00401573();\n        fcn.004014d8(uVar1);\n        fcn.00439f62();\n        var_4h = 0xffffffff;\n        fcn.00438b48();\n    }\n    else {\n        fcn.00401041(arg_8h, arg_ch, arg_10h);\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 365
    },
    "0040124e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040124e(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_3ch;\n    uint var_38h;\n    uint var_18h;\n    \n    pcVar1 = fcn.00401168(\"WideCharToMultiByte\");\n    if (arg_8h == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar3 = (*pcVar1)(0xfde9, 0, arg_8h, 0xffffffff, 0, 0, 0, 0);\n        if (iVar3 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = fcn.0040d777(iVar3 + 1);\n            if (iVar2 == 0) {\n                iVar2 = 0;\n            }\n            else {\n                (*pcVar1)(0xfde9, 0, arg_8h, 0xffffffff, iVar2, iVar3, 0, 0);\n            }\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 254
    },
    "00401276": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401276(uint8_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    bool bVar1;\n    char cVar2;\n    char cVar3;\n    char cVar4;\n    uint8_t uVar5;\n    char *pcVar6;\n    uint32_t uVar7;\n    uint8_t **ppuVar8;\n    uint8_t *puVar9;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    ulong uVar10;\n    uint uVar11;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint8_t *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    cVar2 = fcn.00401582(0x30);\n    fcn.0040146a(arg_14h, 0, 1);\n    var_ch = arg_8h;\n    cVar3 = fcn.004012ad(arg_ch, arg_10h);\n    if (cVar3 == '\\0') {\n        pcVar6 = fcn.004014ab();\n        cVar3 = *pcVar6;\n        cVar4 = fcn.00401582(0x2b);\n        if (cVar3 == cVar4) {\n            *arg_8h = 0x2b;\n            var_ch = arg_8h + 1;\n            fcn.004011bd();\n        }\n        else {\n            pcVar6 = fcn.004014ab();\n            cVar3 = *pcVar6;\n            cVar4 = fcn.00401582(0x2d);\n            if (cVar3 == cVar4) {\n                *arg_8h = 0x2d;\n                var_ch = arg_8h + 1;\n                fcn.004011bd();\n            }\n        }\n    }\n    bVar1 = false;\n    while ((cVar3 = fcn.0040128a(arg_ch, arg_10h),  cVar3 != '\\0' && (pcVar6 = fcn.004014ab(),  *pcVar6 == cVar2))) {\n        bVar1 = true;\n        fcn.004011bd();\n    }\n    if (bVar1) {\n        *var_ch = 0x30;\n        var_ch = var_ch + 1;\n    }\n    var_18h = 0;\n    var_14h = 0;\n    while (cVar3 = fcn.0040128a(arg_ch, arg_10h),  cVar3 != '\\0') {\n        uVar11 = arg_14h;\n        uVar10 = fcn.004014ab();\n        uVar7 = fcn.0040126c(uVar10 >> 0x20 & 0xffffff00 | *uVar10);\n        *var_ch = uVar7;\n        cVar3 = fcn.004015b9(uVar7 & 0xffffff00 | *var_ch, uVar11);\n        if (cVar3 == '\\0') break;\n        if (var_18h < 0x24) {\n            var_ch = var_ch + 1;\n            var_18h = var_18h + 1;\n        }\n        else {\n            var_14h = var_14h + 1;\n        }\n        bVar1 = true;\n        fcn.004011bd();\n    }\n    cVar3 = fcn.0040128a(arg_ch, arg_10h);\n    if (cVar3 != '\\0') {\n        pcVar6 = fcn.004014ab();\n        cVar3 = *pcVar6;\n        cVar4 = fcn.00401064();\n        if (cVar3 == cVar4) {\n            ppuVar8 = fcn.0040d6e5();\n            *var_ch = **ppuVar8;\n            var_ch = var_ch + 1;\n            fcn.004011bd();\n        }\n    }\n    if (var_18h == 0) {\n        while ((cVar3 = fcn.0040128a(arg_ch, arg_10h),  cVar3 != '\\0' && (pcVar6 = fcn.004014ab(),  *pcVar6 == cVar2)))\n        {\n            var_14h = var_14h + -1;\n            bVar1 = true;\n            fcn.004011bd();\n        }\n        if (var_14h < 0) {\n            *var_ch = 0x30;\n            var_ch = var_ch + 1;\n            var_14h = var_14h + 1;\n        }\n    }\n    while (cVar3 = fcn.0040128a(arg_ch, arg_10h),  cVar3 != '\\0') {\n        uVar11 = arg_14h;\n        puVar9 = fcn.004014ab();\n        uVar5 = fcn.0040126c(extraout_ECX & 0xffffff00 | *puVar9);\n        *var_ch = uVar5;\n        cVar3 = fcn.004015b9(extraout_ECX_00 & 0xffffff00 | *var_ch, uVar11);\n        if (cVar3 == '\\0') break;\n        if (var_18h < 0x24) {\n            var_ch = var_ch + 1;\n            var_18h = var_18h + 1;\n        }\n        bVar1 = true;\n        fcn.004011bd();\n    }\n    if ((bVar1) && (cVar3 = fcn.0040128a(arg_ch, arg_10h),  cVar3 != '\\0')) {\n        pcVar6 = fcn.004014ab();\n        cVar3 = *pcVar6;\n        cVar4 = fcn.00401582(0x65);\n        if (cVar3 != cVar4) {\n            pcVar6 = fcn.004014ab();\n            cVar3 = *pcVar6;\n            cVar4 = fcn.00401582(0x45);\n            if (cVar3 != cVar4) goto code_r0x00408781;\n        }\n        *var_ch = 0x65;\n        puVar9 = var_ch + 1;\n        fcn.004011bd();\n        bVar1 = false;\n        var_18h = 0;\n        cVar3 = fcn.004012ad(arg_ch, arg_10h);\n        if (cVar3 == '\\0') {\n            pcVar6 = fcn.004014ab();\n            cVar3 = *pcVar6;\n            cVar4 = fcn.00401582(0x2b);\n            if (cVar3 == cVar4) {\n                *puVar9 = 0x2b;\n                fcn.004011bd();\n                puVar9 = var_ch + 2;\n            }\n            else {\n                pcVar6 = fcn.004014ab();\n                cVar3 = *pcVar6;\n                cVar4 = fcn.00401582(0x2d);\n                if (cVar3 == cVar4) {\n                    *puVar9 = 0x2d;\n                    fcn.004011bd();\n                    puVar9 = var_ch + 2;\n                }\n            }\n        }\n        while ((var_ch = puVar9,  cVar3 = fcn.0040128a(arg_ch, arg_10h),  cVar3 != '\\0' &&\n               (pcVar6 = fcn.004014ab(),  *pcVar6 == cVar2))) {\n            bVar1 = true;\n            fcn.004011bd();\n            puVar9 = var_ch;\n        }\n        if (bVar1) {\n            *var_ch = 0x30;\n            var_ch = var_ch + 1;\n        }\n        while (cVar2 = fcn.0040128a(arg_ch, arg_10h),  cVar2 != '\\0') {\n            uVar11 = arg_14h;\n            uVar10 = fcn.004014ab();\n            uVar7 = fcn.0040126c(uVar10 >> 0x20 & 0xffffff00 | *uVar10);\n            *var_ch = uVar7;\n            cVar2 = fcn.004015b9(uVar7 & 0xffffff00 | *var_ch, uVar11);\n            if (cVar2 == '\\0') break;\n            if (var_18h < 8) {\n                var_ch = var_ch + 1;\n                var_18h = var_18h + 1;\n            }\n            bVar1 = true;\n            fcn.004011bd();\n        }\n    }\ncode_r0x00408781:\n    if (!bVar1) {\n        var_ch = arg_8h;\n    }\n    *var_ch = 0;\n    return var_14h;\n}\n",
        "token_count": 1986
    },
    "00401285": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401285(int32_t arg_8h)\n\n{\n    if (arg_8h < 0) {\n        arg_8h = 0;\n    }\n    fcn.00438337(arg_8h);\n    return;\n}\n",
        "token_count": 58
    },
    "0040a660": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040a660(void)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bb8a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00401244(0x28);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = fcn.004015e6();\n    }\n    *in_FS_OFFSET = var_ch;\n    return var_18h;\n}\n",
        "token_count": 189
    },
    "004012df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040602e)\n\nuint fcn.004012df(void)\n\n{\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    return 0xffffffff;\n}\n",
        "token_count": 54
    },
    "0040a0e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a0e5(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bb10;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_10h = fcn.00401483();\n    if (*(var_10h + 0x50) == 0) {\n        fcn.004013a2(*(in_ECX + 0x74));\n        *(in_ECX + 0x74) = 0;\n    }\n    else {\n        fcn.0040a211(&var_14h);\n        var_4h = 0;\n        iVar1 = fcn.00401217();\n        if (iVar1 == 0) {\n            fcn.004014c9(&var_14h);\n        }\n        var_4h = 0xffffffff;\n        fcn.00438b48();\n    }\n    fcn.0040159b(arg_8h);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 301
    },
    "004012ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004012ee(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    do {\n        fcn.004011c2();\n        if (*(param_1 + 0x58) == 0) {\n            return;\n        }\n        iVar1 = fcn.00401389();\n    } while (iVar1 == 0);\n    return;\n}\n",
        "token_count": 92
    },
    "004012f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004012f8(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 1) == '\\0') {\n        fcn.0040132f();\n    }\n    piVar1 = *(arg_8h + 1);\n    if (piVar1 == NULL) {\n        piVar1 = fcn.0040132f();\n    }\n    if (((*in_ECX == 0) && (*arg_8h == 0)) || ((piVar1 = in_ECX,  *in_ECX != 0 && (*arg_8h != 0)))) {\n        var_8h = 1;\n    }\n    else {\n        var_8h = 0;\n    }\n    return piVar1 & 0xffffff00 | var_8h;\n}\n",
        "token_count": 215
    },
    "0040130c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040130c(uint32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t arg_8h_00;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*0x4711c4 - *(in_ECX + 8) <= arg_8h) {\n        fcn.0041af8e();\n    }\n    if (arg_8h != 0) {\n        arg_8h_00 = *(in_ECX + 8) + arg_8h;\n        cVar1 = fcn.00401370(arg_8h_00, 0);\n        if (cVar1 != '\\0') {\n            fcn.004013b1(*(in_ECX + 4) + *(in_ECX + 8), arg_8h, &arg_ch);\n            fcn.004014dd(arg_8h_00);\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 228
    },
    "00401ee1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402101)\n// WARNING: Variable defined which should be unmapped: var_228h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00401ee1(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint arg_ch;\n    uint arg_8h;\n    uint *in_FS_OFFSET;\n    uint *arg_ch_00;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_214h;\n    uint var_210h;\n    uint var_200h;\n    uint var_1a4h;\n    uint var_1a0h;\n    uint var_19ch;\n    uint var_198h;\n    uint var_118h;\n    uint var_114h;\n    uint var_8ch;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b44e;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00444dc8(param_1);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar1 = fcn.004014bf();\n        if (**(iVar1 + 0x70) == '\\0') {\n            fcn.00401398(0);\n            var_4h = 3;\n            fcn.00438c81(param_1 + 0x54);\n            fcn.00438cd1(0x49b3d8);\n            var_1a4h = 0;\n            do {\n                iVar1 = fcn.0043985a();\n                if (iVar1 != 1) {\n                    var_4h = 0xffffffff;\n                    fcn.00401208();\n                    uVar2 = 0;\n                    goto code_r0x00402113;\n                }\n                uVar2 = var_1a4h;\n                arg_ch = fcn.00401573();\n                arg_8h = fcn.00401573();\n                iVar1 = fcn.00401145(arg_8h, arg_ch, uVar2);\n                if (iVar1 != 0) {\n                    var_4h = 0xffffffff;\n                    fcn.00401208();\n                    uVar2 = 1;\n                    goto code_r0x00402113;\n                }\n                iVar1 = fcn.0044c0d8(0x7d64, 4, 0xffffffff);\n            } while (iVar1 != 7);\n            var_4h = 0xffffffff;\n            fcn.00401208();\n            uVar2 = 0;\n        }\n        else {\n            arg_ch_00 = &var_214h;\n            iVar1 = fcn.004014bf();\n            fcn.0040137a(*(iVar1 + 0x70), arg_ch_00);\n            var_4h = 0;\n            fcn.004011a4(&var_210h, 1, 1);\n            var_4h = CONCAT31(var_4h._1_3_, 2);\n            fcn.0040125d();\n            uVar2 = fcn.00401069(&var_114h, &var_198h, &var_8ch, &var_118h);\n            fcn.00401069(uVar2);\n            fcn.004015fa();\n            uVar2 = fcn.00401145(&var_198h, &var_8ch, var_118h);\n            var_4h = 0xffffffff;\n            fcn.00401604();\n        }\n    }\ncode_r0x00402113:\n    *in_FS_OFFSET = var_ch;\n    return uVar2;\n}\n",
        "token_count": 868
    },
    "0040132f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040132f(int32_t *param_1)\n\n{\n    char cVar1;\n    uchar uVar2;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        var_4h = fcn.0040106e();\n        var_8h = fcn.004015d2();\n        cVar1 = fcn.004014ce(&var_8h, &var_4h);\n        if (cVar1 == '\\0') {\n            uVar2 = fcn.00401627(&var_4h);\n            *(param_1 + 5) = uVar2;\n            goto code_r0x00408c4c;\n        }\n    }\n    *param_1 = 0;\ncode_r0x00408c4c:\n    *(param_1 + 1) = 1;\n    return param_1 & 0xffffff00 | *(param_1 + 5);\n}\n",
        "token_count": 226
    },
    "00401370": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401370(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    char *pcVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.004016b3();\n    if (uVar1 < arg_8h) {\n        fcn.0041af8e();\n    }\n    if (((*(in_ECX + 4) != 0) && (pcVar2 = fcn.00401136(*(in_ECX + 4)),  *pcVar2 != '\\0')) &&\n       (pcVar2 = fcn.00401136(*(in_ECX + 4)),  *pcVar2 != -1)) {\n        if (arg_8h == 0) {\n            pcVar2 = fcn.00401136(*(in_ECX + 4));\n            *pcVar2 = *pcVar2 + -1;\n            fcn.004013e8(0);\n            return 0;\n        }\n        fcn.004015d7(arg_8h);\n        return 1;\n    }\n    if (arg_8h == 0) {\n        if (arg_ch == '\\0') {\n            if (*(in_ECX + 4) != 0) {\n                fcn.004014dd(0);\n            }\n        }\n        else {\n            fcn.004013e8(1);\n        }\n        uVar3 = 0;\n    }\n    else {\n        if ((arg_ch == '\\0') || ((*(in_ECX + 0xc) < 0x20 && (arg_8h <= *(in_ECX + 0xc))))) {\n            if ((arg_ch == '\\0') && (*(in_ECX + 0xc) < arg_8h)) {\n                fcn.004015d7(arg_8h);\n            }\n        }\n        else {\n            fcn.004013e8(1);\n            fcn.004015d7(arg_8h);\n        }\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 475
    },
    "00401384": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\ncode ** __cdecl fcn.00401384(code *arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint arg_8h_00;\n    code **in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b72b;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.004014e2(arg_10h);\n    var_4h = 0;\n    *in_ECX = vtable.std::ctype_char_.0;\n    fcn.0041aedd();\n    var_4h._0_1_ = 1;\n    arg_8h_00 = fcn.0041c0d1(0x4840ac);\n    var_4h._0_1_ = 2;\n    fcn.00401555(arg_8h_00);\n    var_4h = CONCAT31(var_4h._1_3_, 1);\n    fcn.0041c201();\n    if (in_ECX[5] != NULL) {\n        fcn.0040d21b(in_ECX[4]);\n        in_ECX[5] = NULL;\n    }\n    if (arg_8h == NULL) {\n        in_ECX[4] = *0x49d94c;\n    }\n    else {\n        in_ECX[4] = arg_8h;\n        in_ECX[5] = arg_ch & 0xff;\n    }\n    var_4h = var_4h & 0xffffff00;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 446
    },
    "00409a90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid fcn.00409a90(void)\n\n{\n    uint *puVar1;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46ba89;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    puVar1 = fcn.00401190();\n    if (puVar1 == NULL) {\n        var_1ch = 0;\n    }\n    else {\n        var_1ch = (***puVar1)(1);\n    }\n    *0x49b3f4 = 0;\n    var_4h = 0xffffffff;\n    fcn.0041af79(var_1ch);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 249
    },
    "004013e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004013e8(uint arg_8h)\n\n{\n    char *pcVar1;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((arg_8h != '\\0') && (*(in_ECX + 4) != 0)) {\n        pcVar1 = fcn.00401136(*(in_ECX + 4));\n        if ((*pcVar1 == '\\0') || (pcVar1 = fcn.00401136(*(in_ECX + 4)),  *pcVar1 == -1)) {\n            fcn.004013ac(*(in_ECX + 4) + -1);\n        }\n        else {\n            pcVar1 = fcn.00401136(*(in_ECX + 4));\n            *pcVar1 = *pcVar1 + -1;\n        }\n    }\n    *(in_ECX + 4) = 0;\n    *(in_ECX + 8) = 0;\n    *(in_ECX + 0xc) = 0;\n    return;\n}\n",
        "token_count": 237
    },
    "00402b29": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402b29(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    int32_t *var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0040114a();\n    if (iVar1 != 0) {\n        var_4h = (**(*in_ECX + 0x60))();\n        var_10h = in_ECX;\n        while (var_4h != 0) {\n            uVar2 = (**(*var_10h + 100))(&var_4h);\n            iVar1 = fcn.0043a293(0x4716b8, uVar2);\n            if (iVar1 != 0) {\n                var_10h = arg_8h;\n                fcn.00458921();\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "00403c50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00403c50(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    int32_t arg_10h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    do {\n        while( true ) {\n            if (arg_ch < 1) {\n                return var_4h;\n            }\n            iVar2 = fcn.0040142e();\n            if (iVar2 != 0) break;\ncode_r0x00403ce4:\n            uVar3 = fcn.004012b7(arg_8h);\n            var_ch = (**(*in_ECX + 4))(uVar3);\n            var_10h = fcn.004015d2();\n            cVar1 = fcn.004014ce(&var_10h, &var_ch);\n            if (cVar1 != '\\0') {\n                return var_4h;\n            }\n            arg_8h = arg_8h + 1;\n            var_4h = var_4h + 1;\n            arg_ch = arg_ch + -1;\n        }\n        iVar2 = fcn.004010ff();\n        var_8h = fcn.0040142e();\n        var_8h = iVar2 - var_8h;\n        if (var_8h < 1) goto code_r0x00403ce4;\n        if (arg_ch < var_8h) {\n            var_8h = arg_ch;\n        }\n        iVar2 = arg_8h;\n        arg_10h = var_8h;\n        uVar3 = fcn.0040142e();\n        fcn.004015aa(uVar3, iVar2, arg_10h);\n        arg_8h = arg_8h + var_8h;\n        var_4h = var_4h + var_8h;\n        arg_ch = arg_ch - var_8h;\n        fcn.004013e3(var_8h);\n    } while( true );\n}\n",
        "token_count": 500
    },
    "00401424": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00401424(int32_t *arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0x60))();\n    var_10h = in_ECX;\n    while (var_4h != 0) {\n        uVar1 = (**(*var_10h + 100))(&var_4h);\n        iVar2 = fcn.0043a293(0x4716b8, uVar1);\n        if (iVar2 != 0) {\n            var_10h = arg_8h;\n            fcn.00401640(arg_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 215
    },
    "00401451": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.00401451(uint arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t *in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b65a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_10h != 0) {\n        *in_ECX = 0x4711b0;\n        fcn.004010aa();\n        var_4h = 0;\n    }\n    in_ECX[1] = 0;\n    uVar1 = *in_ECX;\n    *(in_ECX + *(uVar1 + 4)) = 0x47112c;\n    fcn.004014ba(arg_8h, uVar1 & 0xffffff00 | arg_ch & 0xff);\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 265
    },
    "0040b650": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040b650(void)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bcaa;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00401244(0x70);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = fcn.004010c8();\n    }\n    *in_FS_OFFSET = var_ch;\n    return var_18h;\n}\n",
        "token_count": 188
    },
    "0040146a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040146a(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b974;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    var_14h = fcn.004011d6();\n    var_10h = fcn.0041b36d(var_14h, 1);\n    if (var_10h == 0) {\n        if ((arg_10h == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n            fcn.00401299(\"missing locale facet\");\n            fcn.0040d1e1(&var_24h, 0x47b670);\n        }\n        if (*0x49b3e8 == 0) {\n            iVar2 = fcn.00438337(0x18);\n            var_4h._0_1_ = 1;\n            if (iVar2 == 0) {\n                var_34h = 0;\n            }\n            else {\n                var_34h = fcn.004014a1(0);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            *0x49b3e8 = fcn.00401479(var_34h);\n            var_10h = *0x49b3e8;\n        }\n        else {\n            var_10h = *0x49b3e8;\n        }\n    }\n    iVar2 = var_10h;\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 529
    },
    "00409ee0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00409ee0(void)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46baea;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00401244(0x78);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = fcn.0040100a();\n    }\n    *in_FS_OFFSET = var_ch;\n    return var_18h;\n}\n",
        "token_count": 188
    },
    "0040147e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040147e(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    *(in_ECX + 0x38) = 0;\n    *(in_ECX + 0x3c) = 0;\n    *(in_ECX + 0x40) = 0x20;\n    *(in_ECX + 0x44) = arg_10h;\n    if ((arg_ch == 0) || ((*(in_ECX + 0x44) & 6) == 6)) {\n        fcn.00401532(0, 0, 0);\n        fcn.00401406(0, 0);\n    }\n    else {\n        arg_8h_00 = fcn.004012b2(arg_ch);\n        fcn.004015aa(arg_8h_00, arg_8h, arg_ch);\n        *(in_ECX + 0x3c) = arg_8h_00 + arg_ch;\n        if ((*(in_ECX + 0x44) & 4) == 0) {\n            fcn.00401532(arg_8h_00, arg_8h_00, arg_8h_00 + arg_ch);\n        }\n        if ((*(in_ECX + 0x44) & 2) == 0) {\n            fcn.00401406(arg_8h_00, arg_8h_00 + arg_ch);\n            iVar1 = fcn.00401109();\n            if (iVar1 == 0) {\n                fcn.00401532(arg_8h_00, arg_8h_00, arg_8h_00);\n            }\n        }\n        *(in_ECX + 0x44) = *(in_ECX + 0x44) | 1;\n    }\n    return;\n}\n",
        "token_count": 449
    },
    "00401497": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.00401497(uint8_t *arg_8h)\n\n{\n    uchar uVar1;\n    uchar *puVar2;\n    uchar *puVar3;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_ch = fcn.0040d070(arg_8h);\n    var_ch = var_ch + 1;\n    puVar2 = fcn.00438337(var_ch);\n    puVar3 = puVar2;\n    for (; var_ch != 0; var_ch = var_ch + -1) {\n        uVar1 = fcn.00401582(puVar3 & 0xffffff00 | *arg_8h);\n        *puVar3 = uVar1;\n        puVar3 = puVar3 + 1;\n        arg_8h = arg_8h + 1;\n    }\n    return puVar2;\n}\n",
        "token_count": 210
    },
    "004014ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004014ba(uint arg_8h, uint arg_ch)\n\n{\n    uchar uVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    *(in_ECX + 0x28) = arg_8h;\n    *(in_ECX + 0x2c) = 0;\n    uVar1 = fcn.00401582(0x20);\n    *(in_ECX + 0x30) = uVar1;\n    fcn.0041acfe();\n    if (*(in_ECX + 0x28) == 0) {\n        fcn.004010be(4, 0);\n    }\n    if (arg_ch != '\\0') {\n        fcn.0041acb0();\n    }\n    return;\n}\n",
        "token_count": 174
    },
    "004014c4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004014c4(int32_t *param_1)\n\n{\n    char cVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        var_4h = fcn.004011db();\n        var_8h = fcn.004015d2();\n        cVar1 = fcn.004014ce(&var_8h, &var_4h);\n        if (cVar1 == '\\0') {\n            *(param_1 + 1) = 0;\n            return;\n        }\n    }\n    *param_1 = 0;\n    *(param_1 + 1) = 1;\n    return;\n}\n",
        "token_count": 164
    },
    "004014c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __thiscall fcn.004014c9(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_50h;\n    uint var_4ch;\n    uint var_40h;\n    uint var_38h;\n    uint var_34h;\n    uchar *puStack20;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b4e7;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puStack20 = &stack0xffffff80;\n    if (*(param_1 + 100) != 0) {\n        fcn.004015e6();\n        var_4h = 0;\n        uVar1 = fcn.00438ddd(&var_4ch, param_1 + 0x54, 0x48401c);\n        var_4h._0_1_ = 1;\n        uVar1 = fcn.00438d77(&var_50h, uVar1, var_8h);\n        var_4h._0_1_ = 2;\n        fcn.00438c81(uVar1);\n        var_4h._0_1_ = 1;\n        fcn.00438b48();\n        var_4h._0_1_ = 0;\n        fcn.00438b48();\n        fcn.0043a538();\n        var_4h = CONCAT31(var_4h._1_3_, 4);\n        fcn.004016a4(*(param_1 + 100));\n        fcn.0044585c();\n        var_4h = 0;\n        fcn.00401460();\n        var_4h = 0xffffffff;\n        fcn.004013cf();\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 495
    },
    "00401555": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401555(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_20h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b749;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    puVar1 = fcn.0040108c(&var_20h);\n    *(in_ECX + 8) = *puVar1;\n    *(in_ECX + 0xc) = puVar1[1];\n    *(in_ECX + 0x10) = puVar1[2];\n    *(in_ECX + 0x14) = puVar1[3];\n    if (*0x49d94c == 0) {\n        *0x49d94c = *(in_ECX + 0x10);\n        fcn.0040d2e1(0x4012cb);\n        *(in_ECX + 0x14) = 0;\n    }\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 323
    },
    "00401569": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401569(int32_t param_1)\n\n{\n    char *pcVar1;\n    uchar *puVar2;\n    uint var_4h;\n    \n    if (*(param_1 + 4) != 0) {\n        pcVar1 = fcn.00401136(*(param_1 + 4));\n        if (*pcVar1 != '\\0') {\n            pcVar1 = fcn.00401136(*(param_1 + 4));\n            if (*pcVar1 != -1) {\n                fcn.00401370(*(param_1 + 8), 0);\n            }\n        }\n    }\n    if (*(param_1 + 4) != 0) {\n        puVar2 = fcn.00401136(*(param_1 + 4));\n        *puVar2 = 0xff;\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "00401587": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401587(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t in_ECX;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x28) == 0) {\n        var_8h = arg_8h | 4;\n    }\n    else {\n        var_8h = arg_8h;\n    }\n    fcn.0041a7aa(var_8h, in_ECX & 0xffffff00 | arg_ch & 0xff);\n    return;\n}\n",
        "token_count": 133
    },
    "004099e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid fcn.004099e0(void)\n\n{\n    uint *puVar1;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46ba69;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    puVar1 = fcn.00401190();\n    if (puVar1 == NULL) {\n        var_1ch = 0;\n    }\n    else {\n        var_1ch = (***puVar1)(1);\n    }\n    *0x49b3f0 = 0;\n    var_4h = 0xffffffff;\n    fcn.0041af79(var_1ch);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 249
    },
    "004015af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004015af(uint wParam, uint lParam, int32_t arg_10h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0xb1, wParam, lParam);\n    if (arg_10h == 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0xb7, 0, 0);\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "004015d7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004015d7(int32_t param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint *in_FS_OFFSET;\n    uint32_t var_8h;\n    uint var_10h;\n    uint32_t var_2ch;\n    uint32_t var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b6d0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_1ch = var_8h | 0x1f;\n    uVar1 = fcn.004016b3();\n    if (uVar1 < var_1ch) {\n        var_1ch = var_8h;\n    }\n    var_4h = 0;\n    iVar2 = fcn.004012b2(var_1ch + 2);\n    var_4h = 0xffffffff;\n    if (*(param_1 + 8) != 0) {\n        if (var_1ch < *(param_1 + 8)) {\n            var_28h = var_1ch;\n        }\n        else {\n            var_28h = *(param_1 + 8);\n        }\n        fcn.004015aa(iVar2 + 1, *(param_1 + 4), var_28h);\n    }\n    var_2ch = *(param_1 + 8);\n    fcn.004013e8(1);\n    *(param_1 + 4) = iVar2 + 1;\n    puVar3 = fcn.00401136(*(param_1 + 4));\n    *puVar3 = 0;\n    *(param_1 + 0xc) = var_1ch;\n    if (var_1ch < var_2ch) {\n        var_2ch = var_1ch;\n    }\n    fcn.004014dd(var_2ch);\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 513
    },
    "004015dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004015dc(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    *in_ECX = arg_8h;\n    *(in_ECX + 1) = arg_8h == 0;\n    return in_ECX;\n}\n",
        "token_count": 75
    },
    "004015fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004015fa(int32_t *param_1, int32_t *param_2)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint arg_8h;\n    uint *puVar3;\n    uint *in_FS_OFFSET;\n    int32_t *var_8h;\n    uint var_10h;\n    uint arg_18h;\n    uint arg_20h;\n    uint var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uchar *puStack20;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b5a9;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    puStack20 = &stack0xffffffa0;\n    var_14h = 0;\n    fcn.0040136b(param_1, 0);\n    cVar1 = fcn.00401352();\n    if (cVar1 != '\\0') {\n        uVar2 = fcn.00401465(&var_24h);\n        var_4h = 0;\n        var_1ch = fcn.004010af(uVar2, 0, 1);\n        var_4h = 0xffffffff;\n        fcn.0040105a();\n        var_4h = 1;\n        if (param_1 == NULL) {\n            var_4ch = 0;\n        }\n        else {\n            var_4ch = param_1 + *(*param_1 + 4);\n        }\n        arg_8h = fcn.004010a5();\n        arg_20h = 0;\n        puVar3 = fcn.004015dc(0);\n        uVar2 = puVar3[1];\n        arg_18h = *puVar3;\n        puVar3 = fcn.004015dc(arg_8h);\n        fcn.0040151e(&var_3ch, *puVar3, puVar3[1], arg_8h, arg_18h, uVar2, arg_20h, var_4ch);\n        var_4h = 0xffffffff;\n        if (((var_14h & 2) == 0) && (0x7fffffff < var_20h)) {\n            *var_8h = var_20h;\n        }\n        else {\n            var_14h = var_14h | 2;\n        }\n    }\n    fcn.004010be(var_14h, 0);\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 668
    },
    "00401622": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00401622(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    return *(param_1 + 0xc) == 0;\n}\n",
        "token_count": 42
    },
    "0040b9c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __fastcall fcn.0040b9c0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    bool bVar2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bcda;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00467dda(0);\n    if (iVar1 == 0) {\n        fcn.0044c0d8(0x68, 0, 0xffffffff);\n        bVar2 = false;\n    }\n    else {\n        fcn.0046181b(4);\n        iVar1 = fcn.00401244(0x68);\n        var_4h = 0;\n        if (iVar1 == 0) {\n            var_20h = 0;\n        }\n        else {\n            var_20h = fcn.00446194(0x80, 0x471000, 0x471530, 0x4716b8);\n        }\n        var_4h = 0xffffffff;\n        fcn.004532db(var_20h);\n        fcn.0045314e();\n        bVar2 = *(param_1 + 0x1c) != 0;\n    }\n    *in_FS_OFFSET = var_ch;\n    return bVar2;\n}\n",
        "token_count": 360
    },
    "0040a188": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040a188(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00401483();\n    if (*(iVar1 + 0x50) == 0) {\n        *(iVar1 + 0x50) = 1;\n        uVar2 = fcn.004015f5(1, 1000, 0);\n        *(param_1 + 0x74) = uVar2;\n    }\n    else {\n        *(iVar1 + 0x50) = 0;\n        fcn.004013a2(*(param_1 + 0x74));\n    }\n    return;\n}\n",
        "token_count": 169
    },
    "0040164f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040164f(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = fcn.0040129e();\n    if (uVar2 < arg_ch) {\n        fcn.0041b1ba();\n    }\n    iVar3 = fcn.0040129e();\n    if (iVar3 - arg_ch < arg_10h) {\n        arg_10h = iVar3 - arg_ch;\n    }\n    if (*0x4711c4 - *(in_ECX + 8) <= arg_10h) {\n        fcn.0041af8e();\n    }\n    if (arg_10h != 0) {\n        iVar3 = *(in_ECX + 8) + arg_10h;\n        cVar1 = fcn.00401370(iVar3, 0);\n        if (cVar1 != '\\0') {\n            iVar4 = fcn.004011cc();\n            fcn.004015aa(*(in_ECX + 4) + *(in_ECX + 8), iVar4 + arg_ch, arg_10h);\n            fcn.004014dd(iVar3);\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 326
    },
    "004016b3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t fcn.004016b3(void)\n\n{\n    uint32_t uVar1;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.004012df();\n    if (uVar1 < 3) {\n        var_ch = 1;\n    }\n    else {\n        var_ch = uVar1 - 2;\n    }\n    return var_ch;\n}\n",
        "token_count": 98
    },
    "0040ac55": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040ac55(int16_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int16_t *var_4h;\n    \n    if (arg_8h == NULL) {\n        iVar1 = 0;\n    }\n    else {\n        for (var_4h = arg_8h; *var_4h != 0; var_4h = var_4h + 1) {\n        }\n        iVar1 = var_4h - arg_8h >> 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 127
    },
    "0040c0aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040c0aa(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    iVar2 = fcn.0040bf84();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (iVar2 == 0) {\n        if (((arg_10h & 3) == 0) &&\n           ((((arg_8h < 0 || (iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0),  iVar2 <= arg_8h)) || (arg_ch < 0)) ||\n            (iVar2 = (*pcVar1)(1),  iVar2 <= arg_ch)))) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = 0x12340042;\n        }\n        return uVar3;\n    }\n    uVar3 = (**0x49d044)(arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 241
    },
    "0040c6c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t * fcn.0040c6c2(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *extraout_ECX;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(extraout_ECX + 4);\n    if (extraout_ECX[3] == 0) {\n        iVar3 = *extraout_ECX;\n        *(unaff_EBP + -4) = 0;\n        iVar1 = fcn.004350a7(extraout_ECX + 2, extraout_ECX[1], iVar3);\n        iVar3 = extraout_ECX[1];\n        piVar2 = (iVar3 + -1) * *extraout_ECX + 4 + iVar1;\n        if (-1 < iVar3 + -1) {\n            do {\n                *piVar2 = extraout_ECX[3];\n                extraout_ECX[3] = piVar2;\n                piVar2 = piVar2 - *extraout_ECX;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    piVar2 = extraout_ECX[3];\n    extraout_ECX[3] = *piVar2;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(extraout_ECX + 4);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return piVar2;\n}\n",
        "token_count": 443
    },
    "0040cbc6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040cbc6(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    int32_t iStack16;\n    \n    iStack16 = param_1;\n    uStack24 = 0x40cba4;\n    uStack28 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack28;\n    while( true ) {\n        iVar1 = *(param_1 + 8);\n        iVar2 = *(param_1 + 0xc);\n        if ((iVar2 == -1) || (iVar2 == param_2)) break;\n        uStack20 = *(iVar1 + iVar2 * 0xc);\n        *(param_1 + 0xc) = uStack20;\n        if (*(iVar1 + 4 + iVar2 * 0xc) == 0) {\n            fcn.0040cc5a(0x101);\n            (**(iVar1 + 8 + iVar2 * 0xc))();\n        }\n    }\n    *in_FS_OFFSET = uStack28;\n    return;\n}\n",
        "token_count": 266
    },
    "0040d1be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040d1be(code **param_1)\n\n{\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.00438360(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 63
    },
    "0040d90b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0040d90b(uint param_1)\n\n{\n    if (*0x49d550 == 1) {\n        fcn.004130f0();\n    }\n    fcn.00413129(param_1);\n    (**0x498cb0)(0xff);\n    return;\n}\n",
        "token_count": 66
    },
    "0040e62c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0040e62c(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t arg_8h;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    arg_8h = param_1 * param_2;\n    uVar1 = arg_8h;\n    if (arg_8h < 0xffffffe1) {\n        if (arg_8h == 0) {\n            uVar1 = 1;\n        }\n        uVar1 = uVar1 + 0xf & 0xfffffff0;\n    }\n    do {\n        iVar2 = 0;\n        if (uVar1 < 0xffffffe1) {\n            if (arg_8h < *0x498f44 || arg_8h - *0x498f44 == 0) {\n                fcn.00410d98(9);\n                iVar2 = fcn.00411476(arg_8h);\n                fcn.00410df9(9);\n                if (iVar2 != 0) {\n                    fcn.0040d6f0(iVar2, 0, arg_8h);\n                    return iVar2;\n                }\n            }\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49ef84, 8, uVar1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n        }\n        if (*0x49d644 == 0) {\n            return iVar2;\n        }\n        iVar2 = fcn.004127da(uVar1);\n    } while (iVar2 != 0);\n    return 0;\n}\n",
        "token_count": 365
    },
    "0040efd0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040efd0(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint arg_18h)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) == 0) {\n        fcn.0040f068(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + 0x18));\n    }\n    return;\n}\n",
        "token_count": 138
    },
    "0040f050": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f050(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.0040f068(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "0040f993": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040f993(uint8_t *arg_8h, uint32_t arg_ch, uint8_t *arg_10h, uint arg_14h, uint32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    int32_t arg_18h_00;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    bool bVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_18h_00 = arg_18h;\n    if (arg_18h == 0) {\n        arg_18h_00 = *0x498db8;\n    }\n    arg_18h = arg_ch;\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(0x49ee14);\n    pcVar2 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n    bVar5 = *0x49ee04 == 0;\n    puVar3 = arg_10h;\n    if (!bVar5) {\n        (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(0x49ee14);\n        fcn.00410d98(0x13);\n        puVar3 = arg_10h;\n    }\n    while ((arg_18h != 0 && (uVar1 = *puVar3,  uVar1 != 0))) {\n        if (uVar1 == 0x25) {\n            puVar4 = puVar3 + 1;\n            uVar1 = *puVar4;\n            if (uVar1 == 0x23) {\n                puVar4 = puVar3 + 2;\n            }\n            *0x49ef90 = uVar1 == 0x23;\n            fcn.0040fa8d(*0x10 | *puVar4, arg_14h, &arg_8h, &arg_18h, arg_18h_00);\n        }\n        else {\n            if (((*(*0x498f48 + 1 + uVar1 * 2) & 0x80) != 0) && (1 < arg_18h)) {\n                *arg_8h = uVar1;\n                arg_8h = arg_8h + 1;\n                puVar3 = puVar3 + 1;\n                arg_18h = arg_18h - 1;\n            }\n            *arg_8h = *puVar3;\n            arg_8h = arg_8h + 1;\n            arg_18h = arg_18h - 1;\n            puVar4 = puVar3;\n        }\n        puVar3 = puVar4 + 1;\n    }\n    if (bVar5) {\n        (*pcVar2)(0x49ee14);\n    }\n    else {\n        fcn.00410df9(0x13);\n    }\n    if (arg_18h == 0) {\n        return 0;\n    }\n    *arg_8h = 0;\n    return arg_ch - arg_18h;\n}\n",
        "token_count": 678
    },
    "0041077b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.0041077b(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    *(unaff_ESI + -4) = *(unaff_EBP + -0x28);\n    iVar1 = fcn.00410b21();\n    *(iVar1 + 0x6c) = *(unaff_EBP + -0x1c);\n    iVar1 = fcn.00410b21();\n    *(iVar1 + 0x70) = *(unaff_EBP + -0x20);\n    if ((((*unaff_EDI == -0x1f928c9d) && (unaff_EDI[4] == 3)) && (unaff_EDI[5] == 0x19930520)) &&\n       ((*(unaff_EBP + -0x24) == 0 && (*(unaff_EBP + -0x2c) != 0)))) {\n        fcn.0040cc2e();\n        fcn.004109b7();\n    }\n    return;\n}\n",
        "token_count": 284
    },
    "00412021": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00412021(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    if (arg_8h == 0) {\n        iVar1 = fcn.0040d777(arg_ch);\n    }\n    else {\n        if (arg_ch == 0) {\n            fcn.0040d21b(arg_8h);\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (arg_ch < 0xffffffe1) {\n                    fcn.00410d98(9);\n                    arg_8h_00 = fcn.00411120(arg_8h);\n                    if (arg_8h_00 == 0) {\n                        fcn.00410df9(9);\n                        if (arg_ch == 0) {\n                            arg_ch = 1;\n                        }\n                        arg_ch = arg_ch + 0xf & 0xfffffff0;\n                        iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x49ef84, 0, arg_8h, arg_ch);\n                    }\n                    else {\n                        if (*0x498f44 < arg_ch) {\ncode_r0x004120c0:\n                            if (arg_ch == 0) {\n                                arg_ch = 1;\n                            }\n                            arg_ch = arg_ch + 0xf & 0xfffffff0;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49ef84, 0, arg_ch);\n                            if (iVar1 != 0) {\n                                uVar3 = *(arg_8h + -4) - 1;\n                                if (arg_ch <= uVar3) {\n                                    uVar3 = arg_ch;\n                                }\n                                fcn.0040cd30(iVar1, arg_8h, uVar3);\n                                fcn.0041114b(arg_8h_00, arg_8h);\n                            }\n                        }\n                        else {\n                            iVar2 = fcn.0041192b(arg_8h_00, arg_8h, arg_ch);\n                            iVar1 = arg_8h;\n                            if (iVar2 == 0) {\n                                iVar1 = fcn.00411476(arg_ch);\n                                if (iVar1 == 0) goto code_r0x004120c0;\n                                uVar3 = *(arg_8h + -4) - 1;\n                                if (arg_ch <= uVar3) {\n                                    uVar3 = arg_ch;\n                                }\n                                fcn.0040cd30(iVar1, arg_8h, uVar3);\n                                fcn.0041114b(arg_8h_00, arg_8h);\n                            }\n                            if (iVar1 == 0) goto code_r0x004120c0;\n                        }\n                        fcn.00410df9(9);\n                    }\n                    if (iVar1 != 0) {\n                        return iVar1;\n                    }\n                }\n                if (*0x49d644 == 0) {\n                    return iVar1;\n                }\n                iVar1 = fcn.004127da(arg_ch);\n            } while (iVar1 != 0);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 729
    },
    "00413129": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413129(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint var_1a4h;\n    uint var_a0h;\n    \n    iVar2 = 0;\n    piVar1 = 0x499228;\n    do {\n        if (arg_8h == *piVar1) break;\n        piVar1 = piVar1 + 2;\n        iVar2 = iVar2 + 1;\n    } while (piVar1 < 0x4992b8);\n    if (arg_8h == *(iVar2 * 8 + 0x499228)) {\n        if ((*0x49d550 == 1) || ((*0x49d550 == 0 && (*0x498cb4 == 1)))) {\n            fcn.0040d070();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (arg_8h != 0xfc) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.00410ec0();\n            }\n            iVar2 = fcn.0040d070();\n            if (0x3c < iVar2 + 1U) {\n                fcn.0040d070();\n                fcn.00415ba0();\n            }\n            fcn.00410ec0();\n            fcn.00410ed0();\n            fcn.00410ed0();\n            fcn.00410ed0();\n            fcn.00415b0a(&var_a0h, \"Microsoft Visual C++ Runtime Library\");\n        }\n    }\n    return;\n}\n",
        "token_count": 385
    },
    "00418286": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00418286(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    \n    uVar1 = fcn.00417db5(&var_ch, arg_ch, arg_10h, arg_14h, 0, 0, 0);\n    iVar2 = fcn.00415768(&var_ch, arg_8h);\n    if (iVar2 == 1) {\n        uVar1 = uVar1 | 2;\n    }\n    return uVar1;\n}\n",
        "token_count": 144
    },
    "0041f648": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041f648(code **param_1)\n\n{\n    *param_1 = vtable.std::ctype_unsigned_short_int_.0;\n    if (param_1[5] != NULL) {\n        fcn.0040d21b(param_1[4]);\n    }\n    *param_1 = vtable.std::locale::facet.0;\n    return;\n}\n",
        "token_count": 85
    },
    "00439395": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00439395(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.0043b34b();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043b18d();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 197
    },
    "0042ec2b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042ec2b(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    \n    in_ECX[0xf] = 0x700b - (arg_8h != 0);\n    in_ECX[0x1c] = in_ECX + 0x41;\n    in_ECX[0x1a] = in_ECX[0x1a] | arg_14h;\n    *(in_ECX + 0x1d) = 0x80;\n    *(in_ECX + 0x76) = 0x80;\n    if (arg_18h == 0) {\n        arg_18h = fcn.0040bd9c();\n        if (arg_18h == 0) goto code_r0x0042ec71;\n    }\n    arg_18h = *(arg_18h + 0x1c);\ncode_r0x0042ec71:\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrcpynA;\n    in_ECX[0x18] = arg_18h;\n    if (arg_ch != 0) {\n        (*pcVar1)(in_ECX + 0x21, arg_ch, 0x80);\n    }\n    if (arg_10h != 0) {\n        (*pcVar1)(in_ECX + 0x41, arg_10h, 0x80);\n    }\n    fcn.0043af86();\n    if (arg_8h == 0) {\n        iVar2 = sub.comdlg32.dll_ReplaceTextA(in_ECX + 0x17);\n    }\n    else {\n        iVar2 = sub.comdlg32.dll_FindTextA();\n    }\n    iVar3 = fcn.0043afd2();\n    if (iVar3 == 0) {\n        (**(*in_ECX + 0xa4))();\n    }\n    return iVar2 != 0;\n}\n",
        "token_count": 480
    },
    "0042ed1d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042ed1d(uint *param_1, uint param_2, int32_t param_3)\n\n{\n    uint unaff_retaddr;\n    \n    *param_1 = *0x498098;\n    if (param_3 != 0) {\n        fcn.004389b5(param_3);\n        fcn.0040cd30(*param_1, unaff_retaddr, param_2);\n    }\n    return param_1;\n}\n",
        "token_count": 107
    },
    "0042ee71": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042ee71(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (arg_8h < 0) {\n        arg_8h = 0;\n    }\n    iVar1 = *(*in_ECX + -8);\n    if ((0 < arg_ch) && (arg_8h < iVar1)) {\n        fcn.00438af1();\n        fcn.0040cd30(*in_ECX + arg_8h, *in_ECX + arg_8h + arg_ch, ((iVar1 - arg_8h) - arg_ch) + 1);\n        *(*in_ECX + -8) = iVar1 - arg_ch;\n    }\n    return iVar1;\n}\n",
        "token_count": 180
    },
    "0042eec9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042eec9(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t *in_ECX;\n    int32_t iVar1;\n    uint var_4h;\n    \n    fcn.00438af1();\n    if (arg_8h < 0) {\n        arg_8h = 0;\n    }\n    arg_ch_00 = *in_ECX;\n    iVar1 = *(arg_ch_00 + -8);\n    if (iVar1 < arg_8h) {\n        arg_8h = iVar1;\n    }\n    iVar1 = iVar1 + 1;\n    if (*(arg_ch_00 + -4) < iVar1) {\n        fcn.004389b5(iVar1);\n        fcn.0040cd30(*in_ECX, arg_ch_00, *(arg_ch_00 + -8) + 1);\n        fcn.00438ab0(arg_ch_00 + -0xc);\n    }\n    fcn.0040cd30(*in_ECX + arg_8h + 1, *in_ECX + arg_8h, iVar1 - arg_8h);\n    *(*in_ECX + arg_8h) = arg_ch;\n    *(*in_ECX + -8) = iVar1;\n    return iVar1;\n}\n",
        "token_count": 299
    },
    "0042f03f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042f03f(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t *in_ECX;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t arg_10h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n    if ((arg_8h == 0) || (iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h),  iVar2 == 0)) {\n        var_8h = 0;\n    }\n    else {\n        if (arg_ch == 0) {\n            var_4h = 0;\n        }\n        else {\n            var_4h = (*pcVar1)(arg_ch);\n        }\n        uVar6 = *in_ECX;\n        var_8h = 0;\n        uVar5 = *(uVar6 - 8) + uVar6;\n        if (uVar6 < uVar5) {\n            do {\n                while (iVar3 = fcn.0040eb7b(uVar6, arg_8h),  iVar3 != 0) {\n                    var_8h = var_8h + 1;\n                    uVar6 = iVar3 + iVar2;\n                }\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar6);\n                uVar6 = uVar6 + 1 + iVar3;\n            } while (uVar6 < uVar5);\n            if (0 < var_8h) {\n                fcn.00438af1();\n                uVar6 = *in_ECX;\n                iVar3 = *(uVar6 - 8);\n                iVar7 = (var_4h - iVar2) * var_8h + iVar3;\n                if ((*(uVar6 - 4) < iVar7) || (1 < *(uVar6 - 0xc))) {\n                    fcn.004389b5(iVar7);\n                    fcn.0040cd30(*in_ECX, uVar6, *(uVar6 - 8));\n                    fcn.00438ab0(uVar6 - 0xc);\n                }\n                uVar6 = *in_ECX;\n                uVar5 = *(uVar6 - 8) + uVar6;\n                for (; uVar6 < uVar5; uVar6 = uVar6 + 1 + iVar4) {\n                    iVar4 = fcn.0040eb7b(uVar6, arg_8h);\n                    while (iVar4 != 0) {\n                        uVar6 = iVar4 + var_4h;\n                        arg_10h = ((*in_ECX - iVar4) - iVar2) + iVar3;\n                        fcn.0040dde0(uVar6, iVar2 + iVar4, arg_10h);\n                        fcn.0040cd30(iVar4, arg_ch, var_4h);\n                        *(arg_10h + uVar6) = 0;\n                        iVar3 = iVar3 + (var_4h - iVar2);\n                        iVar4 = fcn.0040eb7b(uVar6, arg_8h);\n                    }\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar6);\n                }\n                *(*in_ECX - 8) = iVar7;\n            }\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 832
    },
    "0042f451": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042f451(uint *param_1, char *param_2, int32_t *param_3)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint unaff_retaddr;\n    int32_t iStack16;\n    uint32_t uStack12;\n    \n    iStack16 = 0;\n    cVar1 = *param_2;\n    piVar6 = param_3;\n    do {\n        if (cVar1 == '\\0') {\n            fcn.00438f78(iStack16);\n            fcn.0040ed81(*param_1, unaff_retaddr, param_1);\n            fcn.00438fc7(0xffffffff);\n            return;\n        }\n        if (*param_2 == '%') {\n            param_2 = fcn.0040e115(param_2);\n            cVar1 = *param_2;\n            if (cVar1 == '%') goto code_r0x0042f70c;\n            iVar7 = 0;\n            param_3 = NULL;\n            if (cVar1 == '\\0') {\ncode_r0x0042f4de:\n                param_3 = fcn.0040e9f1(param_2);\n                while ((piVar5 = piVar6,  *param_2 != '\\0' && (iVar2 = fcn.0040eed7(*param_2),  iVar2 != 0))) {\n                    param_2 = fcn.0040e115(param_2);\n                }\n            }\n            else {\n                do {\n                    if (cVar1 == '#') {\n                        iStack16 = iStack16 + 2;\n                    }\n                    else if (cVar1 == '*') {\n                        param_3 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                    }\n                    else if ((((cVar1 != '-') && (cVar1 != '+')) && (cVar1 != '0')) && (cVar1 != ' ')) break;\n                    param_2 = fcn.0040e115(param_2);\n                    cVar1 = *param_2;\n                } while (cVar1 != '\\0');\n                piVar5 = piVar6;\n                if (param_3 == NULL) goto code_r0x0042f4de;\n            }\n            iVar2 = 0;\n            if (*param_2 == '.') {\n                param_2 = fcn.0040e115(param_2);\n                if (*param_2 == '*') {\n                    iVar2 = *piVar5;\n                    piVar5 = piVar5 + 1;\n                    param_2 = fcn.0040e115(param_2);\n                }\n                else {\n                    iVar2 = fcn.0040e9f1(param_2);\n                    while ((*param_2 != '\\0' && (iVar3 = fcn.0040eed7(*param_2),  iVar3 != 0))) {\n                        param_2 = fcn.0040e115(param_2);\n                    }\n                }\n            }\n            uStack12 = 0;\n            iVar3 = fcn.0040ede8(param_2, 0x475188, 3);\n            if (iVar3 == 0) {\n                param_2 = param_2 + 3;\n                uStack12 = 0x40000;\n            }\n            else {\n                cVar1 = *param_2;\n                if (((cVar1 != 'F') && (cVar1 != 'L')) && (cVar1 != 'N')) {\n                    if (cVar1 == 'h') {\n                        uStack12 = 0x10000;\n                    }\n                    else {\n                        if (cVar1 != 'l') goto code_r0x0042f5b0;\n                        uStack12 = 0x20000;\n                    }\n                }\n                param_2 = fcn.0040e115(param_2);\n            }\ncode_r0x0042f5b0:\n            uVar4 = *param_2 | uStack12;\n            piVar6 = piVar5;\n            if (uVar4 < 0x10064) {\n                if ((uVar4 == 0x10063) || (uVar4 == 0x43)) {\ncode_r0x0042f668:\n                    iVar7 = 2;\n                }\n                else {\n                    if (uVar4 == 0x53) goto code_r0x0042f655;\n                    if (uVar4 == 99) goto code_r0x0042f668;\n                    if (uVar4 != 0x73) {\n                        if (uVar4 == 0x10043) goto code_r0x0042f668;\n                        if (uVar4 != 0x10053) goto code_r0x0042f5f1;\n                    }\ncode_r0x0042f670:\n                    if (*piVar5 == 0) goto code_r0x0042f67a;\n                    iVar7 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*piVar5);\ncode_r0x0042f686:\n                    if (iVar7 < 1) {\n                        iVar7 = 1;\n                    }\n                    piVar6 = piVar5 + 1;\n                    if (iVar7 == 0) goto code_r0x0042f5f1;\n                }\ncode_r0x0042f698:\n                piVar6 = piVar5 + 1;\n                if ((iVar2 != 0) && (iVar2 <= iVar7)) {\n                    iVar7 = iVar2;\n                }\n                if (iVar7 <= param_3) {\n                    iVar7 = param_3;\n                }\n            }\n            else {\n                if (uVar4 == 0x10073) goto code_r0x0042f670;\n                if (uVar4 == 0x20043) goto code_r0x0042f668;\n                if (uVar4 == 0x20053) {\ncode_r0x0042f655:\n                    if (*piVar5 != 0) {\n                        iVar7 = fcn.0040da5c(*piVar5);\n                        goto code_r0x0042f686;\n                    }\ncode_r0x0042f67a:\n                    iVar7 = 6;\n                    goto code_r0x0042f698;\n                }\n                if (uVar4 == 0x20063) goto code_r0x0042f668;\n                if (uVar4 == 0x20073) goto code_r0x0042f655;\ncode_r0x0042f5f1:\n                cVar1 = *param_2;\n                if (cVar1 < 'j') {\n                    if (cVar1 == 'i') goto code_r0x0042f6f3;\n                    if (cVar1 == 'G') goto code_r0x0042f6be;\n                    if ((cVar1 == 'X') || (cVar1 == 'd')) goto code_r0x0042f6f3;\n                    if (cVar1 == 'e') {\ncode_r0x0042f6be:\n                        piVar6 = piVar6 + 2;\n                        iVar7 = 0x80;\n                        goto code_r0x0042f6e5;\n                    }\n                    if (cVar1 != 'f') {\n                        if (cVar1 != 'g') goto code_r0x0042f702;\n                        goto code_r0x0042f6be;\n                    }\n                    piVar6 = piVar6 + 2;\n                    iVar7 = 0x80;\n                    iVar2 = iVar2 + 0x138;\n                }\n                else {\n                    if (cVar1 == 'n') {\n                        piVar6 = piVar6 + 1;\n                        goto code_r0x0042f702;\n                    }\n                    if (cVar1 == 'o') {\ncode_r0x0042f6f3:\n                        if ((uStack12 & 0x40000) == 0) goto code_r0x0042f6df;\n                        piVar6 = piVar6 + 2;\n                    }\n                    else {\n                        if (cVar1 != 'p') {\n                            if ((cVar1 != 'u') && (cVar1 != 'x')) goto code_r0x0042f702;\n                            goto code_r0x0042f6f3;\n                        }\ncode_r0x0042f6df:\n                        piVar6 = piVar6 + 1;\n                    }\n                    iVar7 = 0x20;\ncode_r0x0042f6e5:\n                    iVar2 = param_3 + iVar2;\n                }\n                if (iVar7 <= iVar2) {\n                    iVar7 = iVar2;\n                }\n            }\ncode_r0x0042f702:\n            iStack16 = iStack16 + iVar7;\n        }\n        else {\ncode_r0x0042f70c:\n            iVar7 = fcn.0040edd2(param_2);\n            iStack16 = iStack16 + iVar7;\n        }\n        param_2 = fcn.0040e115(param_2);\n        cVar1 = *param_2;\n    } while( true );\n}\n",
        "token_count": 2047
    },
    "0042f7b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f7b5(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint *var_8h;\n    int32_t var_4h;\n    \n    var_8h = &arg_10h;\n    iVar1 = (*_sym.imp.KERNEL32.dll_FormatMessageA)(0x500, arg_ch, 0, 0, &var_4h, 0, &var_8h);\n    if ((iVar1 == 0) || (var_4h == 0)) {\n        fcn.0042eb4c();\n    }\n    fcn.00438cd1(var_4h);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(var_4h);\n    return;\n}\n",
        "token_count": 177
    },
    "0043022d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043022d(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    \n    if (arg_8h != 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(arg_8h);\n        uVar2 = fcn.0043aafa(uVar2);\n        piVar3 = fcn.0043a293(0x475920, uVar2);\n        if (piVar3 != NULL) {\n            if (arg_ch == 0x400) {\n                uVar2 = (**(*piVar3 + 0xd0))(arg_10h, arg_10h >> 0x10, arg_14h);\n                return uVar2;\n            }\n            if ((0x400 < arg_ch) && (arg_ch < 0x407)) {\n                iVar1 = *piVar3;\n                uVar2 = fcn.004465de(arg_10h, arg_ch, arg_14h);\n                uVar2 = (**(iVar1 + 0xd4))(uVar2);\n                return uVar2;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 290
    },
    "00430560": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00430560(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint16_t *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (param_1 != 0) {\n        iVar4 = param_1;\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(param_1);\n        if (param_1 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = (*pcVar1)(param_1);\n        }\n        if (puVar2 != NULL) {\n            uVar3 = (*_sym.imp.GDI32.dll_CreateDCA)(*puVar2 + puVar2, puVar2[1] + puVar2, puVar2[2] + puVar2, uVar3);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar4);\n            if (param_1 == 0) {\n                return uVar3;\n            }\n            (*pcVar1)(param_1);\n            return uVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 276
    },
    "00430729": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00430729(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EDI;\n    uint uVar5;\n    \n    uVar5 = *(param_1 + 0x78);\n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar5);\n    fcn.0040d6f0(iVar3 + 1 + *(param_1 + 0x78), 0, *(param_1 + 0x7c) - (iVar3 + 1));\n    (*_sym.imp.USER32.dll_GetFocus)();\n    bVar1 = false;\n    uVar4 = fcn.004397de();\n    *(param_1 + 0x60) = uVar4;\n    fcn.0043afd2();\n    pcVar2 = _sym.imp.USER32.dll_EnableWindow;\n    if (*(param_1 + 0x60) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x60));\n        if (iVar3 != 0) {\n            bVar1 = true;\n            (*pcVar2)(*(param_1 + 0x60), 0);\n        }\n    }\n    iVar3 = fcn.00460301();\n    if ((*(param_1 + 0x92) & 8) == 0) {\n        fcn.0043af86(param_1);\n    }\n    else {\n        *(iVar3 + 0x18) = param_1;\n    }\n    if (*(param_1 + 0xa8) == 0) {\n        sub.comdlg32.dll_GetSaveFileNameA(param_1 + 0x5c);\n    }\n    else {\n        sub.comdlg32.dll_GetOpenFileNameA();\n    }\n    *(iVar3 + 0x18) = 0;\n    if (bVar1) {\n        (*pcVar2)(*(param_1 + 0x60), 1);\n    }\n    iVar3 = (*_sym.imp.USER32.dll_IsWindow)(unaff_EDI);\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n    }\n    fcn.00439818();\n    if (unaff_EDI == 0) {\n        unaff_EDI = 2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 547
    },
    "00430804": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.00430804(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = 0;\n    uVar1 = *(extraout_ECX + 0x92);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    iVar6 = extraout_ECX;\n    if (((uVar1 & 8) != 0) && (iVar2 = *(extraout_ECX + 0x1c),  iVar2 != 0)) {\n        *(unaff_EBP + -0x10) = *0x498098;\n        pcVar3 = _sym.imp.USER32.dll_GetParent;\n        *(unaff_EBP + -4) = 0;\n        uVar5 = (*pcVar3)(iVar2);\n        iVar6 = fcn.0043aad3(uVar5);\n        uVar5 = fcn.00438f78(0x104);\n        pcVar4 = _sym.imp.USER32.dll_SendMessageA;\n        iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar6 + 0x1c), 0x464, 0x104, uVar5);\n        if (iVar6 < 0) {\n            fcn.00438ad3();\n        }\n        else {\n            fcn.00438fc7(iVar2, 0xffffffff);\n        }\n        if (*(*(unaff_EBP + -0x10) + -8) != 0) {\n            uVar5 = (*pcVar3)(*(*(unaff_EBP + -0x14) + 0x1c));\n            iVar6 = fcn.0043aad3(uVar5);\n            uVar5 = fcn.00438f78(0x104);\n            iVar6 = (*pcVar4)(*(iVar6 + 0x1c), 0x465, 0x104, uVar5);\n            if (-1 < iVar6) {\n                fcn.00438fc7(0xffffffff);\n                fcn.004388bd(unaff_EBP + -0x10);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00438b48();\n                goto code_r0x004308dc;\n            }\n            fcn.00438ad3();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00438b48();\n        iVar6 = *(unaff_EBP + -0x14);\n    }\n    fcn.00438bb6(*(iVar6 + 0x78));\ncode_r0x004308dc:\n    uVar5 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 756
    },
    "00430f80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430f80(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    if (arg_8h != 0) {\n        iVar2 = fcn.00462aba(0x460619);\n        if (*(iVar2 + 0x18) != 0) {\n            fcn.0043dad6(arg_8h);\n            *(iVar2 + 0x18) = 0;\n        }\n        pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n        if (arg_ch == 0x110) {\n            *0x49d538 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"commdlg_LBSelChangedNotify\");\n            *0x49d534 = (*pcVar1)(\"commdlg_ShareViolation\");\n            *0x49d530 = (*pcVar1)(\"commdlg_FileNameOK\");\n            *0x49d52c = (*pcVar1)(\"commdlg_ColorOK\");\n            *0x49d528 = (*pcVar1)(\"commdlg_help\");\n            *0x49d524 = (*pcVar1)(\"commdlg_SetRGBColor\");\n            uVar3 = fcn.004391f9(arg_8h, 0x110, arg_10h, arg_14h);\n            return uVar3;\n        }\n        if ((arg_ch == *0x49d528) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x111, 0xe146, 0);\n            return 1;\n        }\n        if (0xbfff < arg_ch) {\n            piVar4 = fcn.0043aafa(arg_8h);\n            iVar2 = fcn.0043a281(0x475b68);\n            if ((iVar2 == 0) || ((*(piVar4 + 0x92) & 8) == 0)) {\n                if (arg_ch == *0x49d534) {\n                    uVar3 = (**(*piVar4 + 0xd0))(arg_14h);\n                    return uVar3;\n                }\n                if (arg_ch == *0x49d530) {\n                    if (*0x49d0e4 != 0) {\n                        piVar4[0x7d] = arg_14h;\n                    }\n                    uVar3 = (**(*piVar4 + 0xd4))();\n                    piVar4[0x7d] = 0;\n                    return uVar3;\n                }\n                if (arg_ch == *0x49d538) {\n                    (**(*piVar4 + 0xd8))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                }\n                else if (arg_ch == *0x49d52c) {\n                    uVar3 = (**(*piVar4 + 0xd0))();\n                    return uVar3;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 721
    },
    "00432ce7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432ce7(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_8h;\n    \n    fcn.00432f79(&var_2ch, arg_8h, arg_14h);\n    if (arg_10h != 0) {\n        fcn.0040cd30(&var_1ch, arg_10h, 0x10);\n    }\n    var_8h = arg_ch;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x404, 0, &var_2ch);\n    return;\n}\n",
        "token_count": 178
    },
    "00432d35": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432d35(uint arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_ch;\n    uint32_t var_8h;\n    \n    fcn.00432f79(&var_2ch, arg_8h, arg_14h);\n    if (arg_10h != 0) {\n        fcn.0040cd30(&var_1ch, arg_10h, 0x10);\n    }\n    iVar1 = fcn.00460591();\n    var_ch = *(iVar1 + 0xc);\n    var_8h = arg_ch & 0xffff;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x404, 0, &var_2ch);\n    return;\n}\n",
        "token_count": 221
    },
    "00432fcc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00432fcc(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    iVar1 = fcn.00460301();\n    iVar2 = *(iVar1 + 0xcc);\n    if (arg_8h == 0) {\n        if ((*(in_ECX + 0x24) & arg_ch) != 0) {\n            if (*(iVar1 + 0xd0) == in_ECX) {\n                fcn.0043b402(1);\n            }\n            if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n                fcn.0040d6f0(&var_2ch, 0, 0x2c);\n                var_24h = *(in_ECX + 0x1c);\n                var_2ch = 0x28;\n                var_28h = 1;\n                var_20h = var_24h;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_2ch);\n            }\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) & ~arg_ch;\n        }\n    }\n    else if ((*(in_ECX + 0x24) & arg_ch) == 0) {\n        iVar2 = fcn.00460591();\n        *(iVar2 + 0x1034) = 0x433110;\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) | arg_ch;\n    }\n    return 1;\n}\n",
        "token_count": 416
    },
    "00433120": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_80h\n// WARNING: Variable defined which should be unmapped: var_7ch\n\nvoid __cdecl fcn.00433120(uint arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t *extraout_ECX;\n    uint32_t uVar8;\n    int32_t unaff_EBP;\n    uint *puVar9;\n    int32_t *piVar10;\n    uint *puVar11;\n    uint *in_FS_OFFSET;\n    uint var_80h;\n    uint var_7ch;\n    uint var_60h;\n    uint var_5ch;\n    uint lParam;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint lpPoint;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    puVar9 = *(unaff_EBP + 8);\n    uVar8 = puVar9[1];\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -0x1c) = uVar8;\n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if ((((uVar8 == 0x200) || (uVar8 == 0xa0)) || (uVar8 == 0x202)) || ((uVar8 == 0x205 || (uVar8 == 0x208)))) {\n        iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar2) {\n            iVar2 = (*pcVar1)(2);\n            if (-1 < iVar2) {\n                iVar2 = (*pcVar1)(4);\n                if (-1 < iVar2) {\n                    var_80h = *puVar9;\n                    while( true ) {\n                        piVar3 = fcn.0043aad3(var_80h);\n                        if ((piVar3 == NULL) || ((*(piVar3 + 9) & 0x401) != 0)) break;\n                        var_80h = (*_sym.imp.USER32.dll_GetParent)(piVar3[7]);\n                    }\n                    if (piVar3 != extraout_ECX) {\n                        if (piVar3 == NULL) {\n                            iVar4 = fcn.00462aba(0x460619);\n                            *(iVar4 + 0xd0) = 0;\n                            *(iVar4 + 0xd4) = 0xffffffff;\n                        }\n                        goto code_r0x0043357b;\n                    }\n                    iVar4 = fcn.00462aba(0x460619);\n                    *(unaff_EBP + -0x18) = iVar4;\n                    piVar3 = *(iVar4 + 0xcc);\n                    uVar5 = fcn.0043c25e();\n                    *(unaff_EBP + -0x14) = uVar5;\n                    if (piVar3 == NULL) {\ncode_r0x00433234:\n                        iVar6 = fcn.00438337(0x58);\n                        *(unaff_EBP + -0x1c) = iVar6;\n                        piVar3 = NULL;\n                        *(unaff_EBP + -4) = 0;\n                        if (iVar6 != 0) {\n                            piVar3 = fcn.00432ac7();\n                        }\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        iVar6 = fcn.00432b1c(*(unaff_EBP + -0x14), 1);\n                        if (iVar6 == 0) {\n                            if (piVar3 != NULL) {\n                                (**(*piVar3 + 4))(1);\n                            }\n                            goto code_r0x0043357b;\n                        }\n                        (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x401, 0, 0);\n                        piVar10 = *(unaff_EBP + -0x10);\n                        *(iVar4 + 0xcc) = piVar3;\n                    }\n                    else {\n                        iVar6 = fcn.0040c345();\n                        if (iVar6 != *(unaff_EBP + -0x14)) {\n                            (**(*piVar3 + 0x58))();\n                            (**(*piVar3 + 4))(1);\n                            piVar3 = NULL;\n                            *(iVar4 + 0xcc) = 0;\n                        }\n                        piVar10 = extraout_ECX;\n                        if (piVar3 == NULL) goto code_r0x00433234;\n                    }\n                    fcn.0040d6f0(unaff_EBP + -0x54, 0, 0x2c);\n                    iVar6 = piVar10[7];\n                    *(unaff_EBP + -0x4c) = iVar6;\n                    *(unaff_EBP + -0x48) = iVar6;\n                    *(unaff_EBP + -0x54) = 0x28;\n                    *(unaff_EBP + -0x50) = 1;\n                    iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x408, 0, unaff_EBP + -0x54);\n                    if (iVar6 == 0) {\n                        (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x404, 0, unaff_EBP + -0x54);\n                    }\n                    uVar5 = *(*(unaff_EBP + 8) + 0x14);\n                    *(unaff_EBP + -0x24) = *(*(unaff_EBP + 8) + 0x18);\n                    *(unaff_EBP + -0x28) = uVar5;\n                    (*_sym.imp.USER32.dll_ScreenToClient)(piVar10[7], unaff_EBP + -0x28);\n                    fcn.0040d6f0(unaff_EBP + -0x80, 0, 0x2c);\n                    iVar6 = *piVar10;\n                    *(unaff_EBP + -0x80) = 0x28;\n                    iVar7 = (**(iVar6 + 100))(*(unaff_EBP + -0x28), *(unaff_EBP + -0x24), unaff_EBP + -0x80);\n                    *(unaff_EBP + -0x1c) = iVar7;\n                    uVar8 = -(iVar7 != -1) & piVar10;\n                    iVar6 = *(iVar4 + 0xd4);\n                    *(unaff_EBP + -0x14) = uVar8;\n                    if ((iVar6 == iVar7) && (*(iVar4 + 0xd0) == uVar8)) {\n                        if ((*(piVar10 + 0x25) & 4) == 0) {\n                            if (iVar7 != -1) {\n                                fcn.0043308e(piVar3, *(unaff_EBP + 8));\n                            }\n                        }\n                        else {\n                            (*_sym.imp.USER32.dll_GetCursorPos)(unaff_EBP + -0x20);\n                            (*_sym.imp.USER32.dll_SendMessageA)\n                                      (piVar3[7], 0x412, 0, CONCAT22(*(unaff_EBP + -0x1c), *(unaff_EBP + -0x20)));\n                        }\n                    }\n                    else {\n                        if (iVar7 == -1) {\n                            (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x401, 0, 0);\n                        }\n                        else {\n                            uVar8 = *(unaff_EBP + -0x7c) & 0x3fffffff;\n                            puVar9 = unaff_EBP + -0x80;\n                            puVar11 = unaff_EBP + -0x54;\n                            for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar11 = *puVar9;\n                                puVar9 = puVar9 + 1;\n                                puVar11 = puVar11 + 1;\n                            }\n                            *(unaff_EBP + -0x50) = uVar8;\n                            if ((*(*(unaff_EBP + -0x10) + 0x24) & 0x400) != 0) {\n                                *(unaff_EBP + -0x50) = uVar8 | 0x20;\n                            }\n                            (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x404, 0, unaff_EBP + -0x54);\n                            if ((*(unaff_EBP + -0x79) & 0x40) == 0) {\n                                iVar4 = fcn.0043c2a2();\n                                if (iVar4 != 0) goto code_r0x004333ee;\n                            }\n                            else {\ncode_r0x004333ee:\n                                (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x401, 1, 0);\n                                if ((*(*(unaff_EBP + -0x10) + 0x24) & 0x400) != 0) {\n                                    (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x411, 1, unaff_EBP + -0x54);\n                                }\n                                (*_sym.imp.USER32.dll_SetWindowPos)(piVar3[7], 0, 0, 0, 0, 0, 0x213);\n                            }\n                            iVar4 = *(unaff_EBP + -0x18);\n                        }\n                        fcn.0043308e(piVar3, *(unaff_EBP + 8));\n                        if (0x27 < *(iVar4 + 0xd8)) {\n                            (*_sym.imp.USER32.dll_SendMessageA)(piVar3[7], 0x405, 0, iVar4 + 0xd8);\n                        }\n                        *(iVar4 + 0xd0) = *(unaff_EBP + -0x14);\n                        *(iVar4 + 0xd4) = *(unaff_EBP + -0x1c);\n                        puVar9 = unaff_EBP + -0x80;\n                        puVar11 = iVar4 + 0xd8;\n                        for (iVar6 = 0xb; iVar6 != 0; iVar6 = iVar6 + -1) {\n                            *puVar11 = *puVar9;\n                            puVar9 = puVar9 + 1;\n                            puVar11 = puVar11 + 1;\n                        }\n                    }\n                    if ((*(unaff_EBP + -0x5c) != -1) && (*(unaff_EBP + -0x60) == 0)) {\n                        fcn.0040d21b(*(unaff_EBP + -0x5c));\n                    }\n                    goto code_r0x0043357b;\n                }\n            }\n        }\n        uVar8 = *(unaff_EBP + -0x1c);\n    }\n    if ((*(extraout_ECX + 9) & 0x401) != 0) {\n        var_80h = *puVar9;\n        while( true ) {\n            piVar3 = fcn.0043aad3(var_80h);\n            if (piVar3 == NULL) break;\n            if (piVar3 == extraout_ECX) goto code_r0x004334e4;\n            if ((*(piVar3 + 9) & 0x401) != 0) break;\n            var_80h = (*_sym.imp.USER32.dll_GetParent)(piVar3[7]);\n        }\n        if (piVar3 == extraout_ECX) {\ncode_r0x004334e4:\n            if (((uVar8 < 0x100) || (0x108 < uVar8)) && ((uVar8 < 0x104 || (0x107 < uVar8)))) {\n                iVar4 = 0;\n            }\n            else {\n                iVar4 = 1;\n            }\n            if (((*(extraout_ECX + 0x25) & 4) == 0) &&\n               ((((((iVar4 != 0 || (uVar8 == 0x201)) || (uVar8 == 0x203)) || ((uVar8 == 0x204 || (uVar8 == 0x206)))) ||\n                 ((((uVar8 == 0x207 || ((uVar8 == 0x209 || (uVar8 == 0xa1)))) || (uVar8 == 0xa3)) ||\n                  (((uVar8 == 0xa4 || (uVar8 == 0xa6)) || (uVar8 == 0xa7)))))) || (uVar8 == 0xa9)))) {\n                fcn.0043b402(iVar4);\n            }\n        }\n    }\ncode_r0x0043357b:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 2933
    },
    "004348db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.004348db(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar1 = fcn.004350a7(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = unaff_EDI;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    fcn.0040cd30(puVar2 + 2, 0x498098, 4);\n    return puVar2;\n}\n",
        "token_count": 333
    },
    "00434e56": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434e56(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.004350a7(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 319
    },
    "00436bab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00436bab(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        fcn.00438360(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00438337(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.0040d6f0(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 172
    },
    "00436c44": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00436c44(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.004350a7(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 304
    },
    "00436e78": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00436e78(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        fcn.00438360(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.00438337(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.0040d6f0(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 173
    },
    "00436f38": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00436f38(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.004350a7(param_1 + 0x14, *(param_1 + 0x18), 0x10);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -0xc + iVar4 * 0x10;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -4;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    fcn.0040cd30(puVar3 + 2, 0x498098, 4);\n    puVar3[3] = 0;\n    return puVar3;\n}\n",
        "token_count": 325
    },
    "004384b7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004384b7(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar5;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.00460591();\n        iVar1 = (**(**(iVar1 + 0x1038) + 4))();\n        return iVar1;\n    }\n    if (arg_ch == 0xfffffffd) {\n        arg_ch = 0;\n        iVar1 = *(arg_10h + 0x30);\n        puVar2 = (**(*in_ECX + 0x2c))();\n        do {\n            if (puVar2 == NULL) {\n                return arg_ch;\n            }\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            piVar5 = puVar2[1];\n            while (((piVar5[1] != 0 && (piVar5[2] != 0)) && (arg_ch == 0))) {\n                if (arg_8h == piVar5[1]) {\n                    if (iVar1 == 0) {\n                        iVar3 = *piVar5;\n                    }\n                    else {\n                        if (*piVar5 == 0) goto code_r0x0043855a;\n                        iVar3 = fcn.0040d9b0(iVar1, *piVar5, 0x10);\n                    }\n                    if (iVar3 == 0) {\n                        arg_ch = 1;\n                        *(arg_10h + 4) = piVar5[2];\n                    }\n                }\ncode_r0x0043855a:\n                piVar5 = piVar5 + 3;\n            }\n            puVar2 = *puVar2;\n        } while( true );\n    }\n    if (arg_ch != 0xffffffff) {\n        uVar4 = arg_ch & 0xffff;\n        arg_ch_00 = arg_ch >> 0x10;\n        arg_ch = uVar4;\n        if (arg_ch_00 != 0) goto code_r0x0043857f;\n    }\n    arg_ch_00 = 0x111;\ncode_r0x0043857f:\n    puVar2 = (**(*in_ECX + 0x28))();\n    while( true ) {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        iVar1 = fcn.0043ba3f(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n        if (iVar1 != 0) break;\n        puVar2 = *puVar2;\n    }\n    iVar1 = fcn.004383b0(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n    return iVar1;\n}\n",
        "token_count": 690
    },
    "004388bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004388bd(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *param_2;\n    if (*(iVar1 + -0xc) < 0) {\n        *param_1 = *0x498098;\n        fcn.00438cd1(*param_2);\n    }\n    else {\n        *param_1 = iVar1;\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + -0xc);\n    }\n    return param_1;\n}\n",
        "token_count": 131
    },
    "00438ad3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438ad3(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(*param_1 + -8) != 0) {\n        if (-1 < *(*param_1 + -0xc)) {\n            if (*param_1 + -0xc != *0x49809c) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n                if (iVar1 < 1) {\n                    fcn.00438a37();\n                }\n                *param_1 = *0x498098;\n            }\n            return;\n        }\n        fcn.00438cd1(0x49b5a0);\n    }\n    return;\n}\n",
        "token_count": 166
    },
    "00438af1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438af1(int32_t *param_1)\n\n{\n    int32_t arg_ch;\n    \n    arg_ch = *param_1;\n    if (1 < *(arg_ch + -0xc)) {\n        fcn.00438a7f();\n        fcn.004389b5(*(arg_ch + -8));\n        fcn.0040cd30(*param_1, arg_ch, *(arg_ch + -8) + 1);\n    }\n    return;\n}\n",
        "token_count": 109
    },
    "00438b1f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00438b1f(int32_t *param_1, int32_t param_2)\n\n{\n    if ((1 < *(*param_1 + -0xc)) || (*(*param_1 + -4) < param_2)) {\n        fcn.00438a7f();\n        fcn.004389b5(param_2);\n    }\n    return;\n}\n",
        "token_count": 87
    },
    "00438c81": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00438c81(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = *param_1;\n    iVar2 = *param_2;\n    if (iVar1 != iVar2) {\n        if (((*(iVar1 + -0xc) < 0) && (iVar1 + -0xc != *0x49809c)) || (*(iVar2 + -0xc) < 0)) {\n            fcn.00438c54(*(iVar2 + -8), iVar2);\n        }\n        else {\n            fcn.00438a7f();\n            iVar1 = *param_2;\n            *param_1 = iVar1;\n            (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + -0xc);\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 202
    },
    "00438ddd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nuint __cdecl fcn.00438ddd(uint arg_8h, uint arg_ch, uint lpString)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar1 = *0x498098;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x10) = uVar1;\n    *(unaff_EBP + -4) = 1;\n    if (*(unaff_EBP + 0x10) == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 0x10));\n    }\n    fcn.00438d39(*(**(unaff_EBP + 0xc) + -8), **(unaff_EBP + 0xc), uVar1, *(unaff_EBP + 0x10));\n    fcn.004388bd(unaff_EBP + -0x10);\n    *(unaff_EBP + -0x14) = 1;\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    uVar1 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 391
    },
    "00438ec5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00438ec5(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 != 0) {\n        iVar1 = *param_1;\n        if ((*(iVar1 + -0xc) < 2) && (*(iVar1 + -8) + param_2 <= *(iVar1 + -4))) {\n            fcn.0040cd30(*(iVar1 + -8) + iVar1, param_3, param_2);\n            *(*param_1 + -8) = *(*param_1 + -8) + param_2;\n            *(*(*param_1 + -8) + *param_1) = 0;\n        }\n        else {\n            fcn.00438d39(*(iVar1 + -8), iVar1, param_2, param_3);\n            fcn.00438ab0(iVar1 + -0xc);\n        }\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "00438f78": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00438f78(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t arg_ch;\n    int32_t iVar1;\n    \n    arg_ch = *param_1;\n    if ((1 < *(arg_ch + -0xc)) || (*(arg_ch + -4) < param_2)) {\n        iVar1 = *(arg_ch + -8);\n        if (param_2 < iVar1) {\n            param_2 = iVar1;\n        }\n        fcn.004389b5(param_2);\n        fcn.0040cd30(*param_1, arg_ch, iVar1 + 1);\n        *(*param_1 + -8) = iVar1;\n        fcn.00438ab0(arg_ch + -0xc);\n    }\n    return *param_1;\n}\n",
        "token_count": 185
    },
    "00439171": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00439171(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((param_3 == 0) && (param_1 != 0)) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, param_2, 0xffffffff, param_1, param_3);\n    if (0 < iVar1) {\n        *(param_1 + -2 + iVar1 * 2) = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 141
    },
    "004393d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004393d3(int32_t param_1, uint32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EDI;\n    \n    *(param_1 + 0x40) = param_2;\n    if ((param_2 >> 0x10 == 0) && (*(param_1 + 0x3c) == 0)) {\n        *(param_1 + 0x3c) = param_2 & 0xffff;\n    }\n    iVar2 = fcn.00460591();\n    uVar1 = *(iVar2 + 0xc);\n    uVar3 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, param_2, 5);\n    uVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, uVar3);\n    fcn.00439434(uVar3, unaff_EDI, uVar1);\n    return;\n}\n",
        "token_count": 225
    },
    "0043a1f1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043a1f1(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x38) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.00436cdc(uVar1);\n        if ((iVar2 != 0) && (*(iVar2 + 0x34) != NULL)) {\n            (**(**(iVar2 + 0x34) + 0x8c))(param_1);\n        }\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "0043a293": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043a293(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 != 0) {\n        iVar1 = fcn.0043a281(param_1);\n        if (iVar1 != 0) {\n            return param_1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 82
    },
    "0043a377": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0043a377(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_104h;\n    uint var_4h;\n    \n    iVar1 = fcn.0043a3fb(arg_8h, &var_104h, 0x100);\n    if (0x100U - iVar1 < 3) {\n        iVar2 = 0x100;\n        do {\n            iVar3 = iVar2 + 0x100;\n            fcn.00438f78(iVar2 + 0xff, iVar3);\n            iVar1 = fcn.0043a3fb();\n            iVar2 = iVar3;\n        } while (iVar3 - iVar1 < 3);\n        fcn.00438fc7(0xffffffff);\n    }\n    else {\n        fcn.00438cd1(&var_104h);\n    }\n    return 0 < iVar1;\n}\n",
        "token_count": 215
    },
    "0043a4b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043a4b0(int32_t *param_1)\n\n{\n    if ((0 < param_1[1]) && (param_1 != NULL)) {\n        (**(*param_1 + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "0043b18d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043b18d(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x49cff8)) && (extraout_ECX != 0x49cfb8)) &&\n       ((extraout_ECX != 0x49cf78 && (extraout_ECX != 0x49cf38)))) {\n        fcn.0043b34b();\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (**(*extraout_ECX[0xd] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0xe];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438385();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 352
    },
    "0043a912": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.0043a912(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.00462aba(0x460619);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x14) = iVar1;\n    puVar4 = iVar1 + 0x34;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x34) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x3c) = *(unaff_EBP + 0x14);\n    uVar2 = *(unaff_EBP + 0x18);\n    *(iVar1 + 0x38) = iVar3;\n    *(iVar1 + 0x40) = uVar2;\n    if ((iVar3 == 2) && (arg_8h[0xd] != NULL)) {\n        (**(*arg_8h[0xd] + 0x5c))(0);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.0043a79f(arg_8h, unaff_EBP + -0x24, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h + 0x98))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.0043a7c2(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 0x18);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x34;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 784
    },
    "0043aa61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0043aa61(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = fcn.004605b7();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00438325(0x447db5);\n        iVar3 = fcn.00438337(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004403d6(0x472758, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.00438325(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 348
    },
    "0043ad90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0043ad90(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    uint32_t var_10h;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.00462aba(0x460619);\n    if (arg_8h != 3) {\n        uVar2 = (*_sym.imp.USER32.dll_CallNextHookEx)(*(var_4h + 0x2c), arg_8h, arg_ch, arg_10h);\n        return uVar2;\n    }\n    piVar1 = *(var_4h + 0x14);\n    iVar6 = *arg_10h;\n    iVar3 = fcn.00460591();\n    var_8h = *(iVar3 + 0x14);\n    if ((piVar1 == NULL) && (((*(iVar6 + 0x23) & 0x40) != 0 || (var_8h != 0)))) goto code_r0x0043af59;\n    if (*0x49d4bc != 0) {\n        uVar4 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe6);\n        if ((uVar4 & 0x10000) != 0) goto code_r0x0043af59;\n        puVar5 = *(iVar6 + 0x28);\n        if (puVar5 >> 0x10 == 0) {\n            var_10h = var_10h & 0xffffff00 | var_10h & puVar5 >> 0x10;\n            (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(&var_10h & 0xffff0000 | *(iVar6 + 0x28), &var_10h, 5);\n            puVar5 = &var_10h;\n        }\n        iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(puVar5, 0x472c08);\n        if (iVar6 == 0) goto code_r0x0043af59;\n    }\n    if (piVar1 == NULL) {\n        iVar6 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n        pcVar9 = _sym.imp.USER32.dll_GetPropA;\n        if ((iVar6 != 0) && (iVar3 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc423\"),  iVar3 == 0)) {\n            (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc423\", iVar6);\n            iVar3 = (*pcVar9)(arg_ch, \"AfxOldWndProc423\");\n            if (iVar3 == iVar6) {\n                (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(\"AfxOldWndProc423\");\n                pcVar9 = fcn.0043ad14;\n                if (*(var_4h + 0x28) == 0) {\n                    pcVar9 = fcn.0043abb5;\n                }\n                (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, pcVar9);\n            }\n        }\n        goto code_r0x0043af59;\n    }\n    fcn.0043ab18(arg_ch);\n    (**(*piVar1 + 0x50))();\n    piVar7 = (**(*piVar1 + 0x80))();\n    iVar6 = *0x49d4c4;\n    if ((((*0x49d0e4 == 0) && (var_8h == 0)) && (*0x49d4c4 != 0)) &&\n       ((*(*0x49d4c4 + 0x20) != 0 && (var_10h = fcn.0043a912(piVar1, arg_ch, 0x36f, 0, 0),  var_10h != 0)))) {\n        iVar3 = fcn.0043abaf();\n        iVar8 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n        (**(iVar6 + 0x20))(arg_ch, var_10h);\n        if (iVar8 != iVar3) {\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, iVar3);\ncode_r0x0043aeed:\n            *piVar7 = iVar3;\n        }\n    }\n    else {\n        iVar6 = fcn.0043abaf();\n        iVar3 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, iVar6);\n        if (iVar3 != iVar6) goto code_r0x0043aeed;\n    }\n    *(var_4h + 0x14) = 0;\ncode_r0x0043af59:\n    iVar6 = var_4h;\n    uVar2 = (*_sym.imp.USER32.dll_CallNextHookEx)(*(var_4h + 0x2c), 3, arg_ch, arg_10h);\n    if (var_8h != 0) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar6 + 0x2c));\n        *(iVar6 + 0x2c) = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 1277
    },
    "0043af86": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043af86(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.00462aba(0x460619);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x2c) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.0043ad90, 0, uVar2);\n            *(iVar1 + 0x2c) = iVar3;\n            if (iVar3 == 0) {\n                fcn.0042eb4c();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 205
    },
    "0043afd2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043afd2(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.00462aba(0x460619);\n    iVar2 = fcn.00460591();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x2c) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x2c));\n        *(iVar1 + 0x2c) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 170
    },
    "0043b121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043b121(int32_t param_1)\n\n{\n    if (*(param_1 + 0x28) == 0) {\n        fcn.0043d76a(1);\n        *(param_1 + 0x28) = \"AfxWnd42s\";\n    }\n    return 1;\n}\n",
        "token_count": 73
    },
    "0043b227": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043b227(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    \n    iVar2 = fcn.0043ded2();\n    if (iVar2 == 0) goto code_r0x0043b272;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.00460591();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.00460591();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.0045c13e();\n                if (iVar3 == 0) goto code_r0x0043b267;\n            }\n            fcn.0046a1d8(0);\n        }\ncode_r0x0043b267:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x0043b272:\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 0x50))();\n        param_1[0xc] = 0;\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    param_1[0xd] = 0;\n    if ((*(param_1 + 9) & 1) != 0) {\n        iVar2 = fcn.00460301();\n        iVar2 = *(iVar2 + 0xcc);\n        if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n            fcn.0040d6f0(&var_2ch, 0, 0x2c);\n            var_24h = param_1[7];\n            var_2ch = 0x28;\n            var_28h = 1;\n            var_20h = var_24h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_2ch);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.0043aa3a();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0x80))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.0043ab51();\n    (**(*param_1 + 0xa4))();\n    return;\n}\n",
        "token_count": 736
    },
    "0043b34b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043b34b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x1c) == 0) {\n        return 0;\n    }\n    fcn.0043aa61(0);\n    iVar1 = fcn.00436cdc(*(param_1 + 0x1c));\n    if (*(param_1 + 0x38) == NULL) {\n        uVar2 = (*_sym.imp.USER32.dll_DestroyWindow)(*(param_1 + 0x1c));\n    }\n    else {\n        uVar2 = (**(**(param_1 + 0x38) + 0x50))();\n    }\n    if (iVar1 == 0) {\n        fcn.0043ab51();\n    }\n    return uVar2;\n}\n",
        "token_count": 192
    },
    "0043b402": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043b402(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    \n    iVar4 = fcn.00460301();\n    if ((*(iVar4 + 0xcc) != 0) && (iVar1 = *(*(iVar4 + 0xcc) + 0x1c),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar1, 0x401, 0, 0);\n    }\n    piVar2 = *(iVar4 + 0x108);\n    if ((param_1 != 0) && (piVar2 != NULL)) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar3) {\n            (**(*piVar2 + 0xdc))(0xffffffff);\n        }\n    }\n    return;\n}\n",
        "token_count": 212
    },
    "0043ba3f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0043ba3f(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 169
    },
    "0043bad8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_60h\n\nuint __cdecl fcn.0043bad8(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uint8_t uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t *arg_8h_00;\n    uint *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    code *pcVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    uint uVar12;\n    uint var_60h;\n    uint var_44h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = 0;\n    iVar4 = *(unaff_EBP + 8);\n    if (iVar4 == 0x111) {\n        iVar4 = (**(*arg_8h_00 + 0x78))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar4 != 0) {\ncode_r0x0043bf2e:\n            *(unaff_EBP + -0x10) = 1;\n            goto code_r0x0043bf72;\n        }\ncode_r0x0043bc61:\n        uVar12 = 0;\n        goto code_r0x0043bc63;\n    }\n    if (iVar4 == 0x4e) {\n        if (**(unaff_EBP + 0x10) != 0) {\n            iVar4 = (**(*arg_8h_00 + 0x7c))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x0043bb31:\n            if (iVar4 != 0) goto code_r0x0043bf72;\n        }\n        goto code_r0x0043bc61;\n    }\n    puVar7 = *(unaff_EBP + 0x10);\n    if (iVar4 == 6) {\n        uVar12 = fcn.0043aad3(puVar7);\n        fcn.0043a83b(arg_8h_00, *(unaff_EBP + 0xc), uVar12);\n    }\n    iVar11 = puVar7;\n    if ((iVar4 == 0x20) && (iVar4 = fcn.0043a89c(arg_8h_00, iVar11, puVar7 >> 0x10),  iVar4 != 0))\n    goto code_r0x0043bf2e;\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    *(unaff_EBP + -0x14) = uVar5;\n    uVar9 = uVar5 & 0x1ff ^ *(unaff_EBP + 8) & 0x1ff;\n    fcn.0046255d(7);\n    uVar5 = *(unaff_EBP + 8);\n    iVar4 = uVar9 * 0xc;\n    iVar6 = *(unaff_EBP + -0x14);\n    if ((uVar5 != *(uVar9 * 0xc + 0x49b710)) || (iVar6 != *(iVar4 + 0x49b718))) {\n        *(iVar4 + 0x49b710) = uVar5;\n        *(iVar4 + 0x49b718) = iVar6;\n        if (iVar6 != 0) {\n            while( true ) {\n                if (uVar5 < 0xc000) {\n                    iVar6 = fcn.0043ba3f(*(iVar6 + 4), uVar5, 0, 0);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 != 0) {\n                        *(iVar4 + 0x49b714) = iVar6;\n                        fcn.004625cd(7);\n                        iVar4 = *(unaff_EBP + 0x10);\n                        goto code_r0x0043bc81;\n                    }\n                }\n                else {\n                    iVar6 = fcn.0043ba3f(*(iVar6 + 4), 0xc000, 0, 0);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 != 0) {\n                        while( true ) {\n                            if (**(iVar6 + 0x10) == *(unaff_EBP + 8)) {\n                                *(iVar4 + 0x49b714) = iVar6;\n                                fcn.004625cd(7);\n                                iVar4 = *(unaff_EBP + 0x10);\n                                goto code_r0x0043bf64;\n                            }\n                            iVar6 = fcn.0043ba3f(iVar6 + 0x18, 0xc000, 0, 0);\n                            *(unaff_EBP + 0x10) = iVar6;\n                            if (iVar6 == 0) break;\n                            iVar6 = *(unaff_EBP + 0x10);\n                        }\n                    }\n                }\n                iVar6 = **(unaff_EBP + -0x14);\n                *(unaff_EBP + -0x14) = iVar6;\n                if (iVar6 == 0) break;\n                iVar6 = *(unaff_EBP + -0x14);\n                uVar5 = *(unaff_EBP + 8);\n            }\n        }\n        *(iVar4 + 0x49b714) = 0;\n        fcn.004625cd(7);\n        goto code_r0x0043bc61;\n    }\n    iVar4 = *(iVar4 + 0x49b714);\n    *(unaff_EBP + 0x10) = iVar4;\n    fcn.004625cd(7);\n    if (iVar4 == 0) goto code_r0x0043bc61;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x0043bf64:\n        pcVar10 = *(iVar4 + 0x14);\ncode_r0x0043bf67:\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x0043bf6b;\n    }\ncode_r0x0043bc81:\n    iVar6 = *(unaff_EBP + 0x10);\n    pcVar10 = *(iVar4 + 0x14);\n    iVar4 = *(iVar6 + 0x10);\n    if (*(iVar6 + 8) == 0x1a) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        iVar6 = *(unaff_EBP + 0x10);\n        iVar4 = (-(uVar2 < 4) & 0xfffffff0) + 0x2f;\n    }\n    iVar3 = puVar7 >> 0x10;\n    // switch table (49 cases) at 0x43bf86\n    switch(iVar4) {\n    case 1:\n        puVar7 = *(unaff_EBP + 0xc);\n        fcn.004465de(puVar7);\n        goto code_r0x0043bdbc;\n    case 2:\n        puVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0043bdbc;\n    case 3:\n    case 8:\n        uVar9 = puVar7 >> 0x10;\n        puVar7 = iVar11;\n        uVar5 = *(unaff_EBP + 0xc);\n        uVar9 = fcn.0043aad3(uVar5, puVar7, uVar9);\n        goto code_r0x0043bdd7;\n    case 4:\n        fcn.0044653c();\n        uVar12 = puVar7[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar12;\n        fcn.0043a6b2();\n        uVar12 = *puVar7;\n        uVar1 = puVar7[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x44) = uVar12;\n        iVar4 = fcn.0043aafa(uVar12);\n        if (iVar4 == 0) {\n            if ((arg_8h_00[0xd] != 0) && (iVar4 = fcn.00436cdc(*(unaff_EBP + -0x44)),  iVar4 != 0)) {\n                *(unaff_EBP + -0x28) = iVar4;\n            }\n            iVar4 = unaff_EBP + -0x60;\n        }\n        uVar12 = (*pcVar10)(unaff_EBP + -0x24, iVar4, uVar1);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x44) = 0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = uVar12;\n        fcn.0043b18d();\n        *(unaff_EBP + -4) = 0xffffffff;\n        goto code_r0x0043bd92;\n    case 5:\n        fcn.0044653c();\n        uVar12 = puVar7[2];\n        *(unaff_EBP + -0x20) = puVar7[1];\n        *(unaff_EBP + -4) = 2;\n        uVar12 = (*pcVar10)(unaff_EBP + -0x24, uVar12);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x10) = uVar12;\ncode_r0x0043bd92:\n        fcn.00446671();\n        break;\n    case 6:\n        uVar5 = fcn.0043aad3(puVar7, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x0043bdd2;\n    case 7:\n        puVar7 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x0043bf6b;\n    case 9:\n    case 0x2a:\ncode_r0x0043bdbc:\n        uVar12 = (*pcVar10)(puVar7);\ncode_r0x0043bf6f:\n        *(unaff_EBP + -0x10) = uVar12;\n        break;\n    case 10:\n    case 0x21:\n        goto code_r0x0043bf67;\n    case 0xb:\n        puVar7 = fcn.00440612(puVar7);\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0043bdd2:\n        uVar9 = *(unaff_EBP + 0xc);\ncode_r0x0043bdd7:\n        uVar12 = (*pcVar10)(uVar9, uVar5, puVar7);\n        goto code_r0x0043bf6f;\n    case 0xc:\n        (*pcVar10)();\n        break;\n    case 0xd:\n        puVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0043befb;\n    case 0xe:\n    case 0x12:\n    case 0x25:\n    case 0x2f:\n        goto code_r0x0043bedb;\n    case 0xf:\n        puVar8 = iVar3;\n        iVar4 = iVar11;\n        goto code_r0x0043bede;\n    case 0x10:\n    case 0x11:\n        puVar8 = puVar7 >> 0x10;\n        uVar5 = puVar7 & 0xffff;\n        goto code_r0x0043bf1c;\n    case 0x13:\n        puVar8 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.0043aad3(puVar8);\n        fcn.0043aad3(puVar7, uVar5);\n        uVar9 = arg_8h_00[7] == puVar7;\n        goto code_r0x0043bf20;\n    case 0x14:\n        puVar7 = *(unaff_EBP + 0xc);\n        fcn.004465de(puVar7);\n        goto code_r0x0043befb;\n    case 0x15:\n        puVar7 = *(unaff_EBP + 0xc);\n        fcn.00440612(puVar7);\n        goto code_r0x0043befb;\n    case 0x16:\n        puVar8 = puVar7 >> 0x10;\n        uVar5 = puVar7 & 0xffff;\n        uVar9 = fcn.00440612(*(unaff_EBP + 0xc), uVar5, puVar8);\n        goto code_r0x0043bf20;\n    case 0x17:\n        puVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0043be62;\n    case 0x18:\n        puVar8 = puVar7 >> 0x10;\n        uVar5 = puVar7 & 0xffff;\n        goto code_r0x0043be7e;\n    case 0x19:\n        uVar5 = iVar11;\n        puVar8 = iVar3;\ncode_r0x0043be7e:\n        uVar9 = fcn.0043aad3(*(unaff_EBP + 0xc), uVar5, puVar8);\n        goto code_r0x0043bf20;\n    case 0x1a:\n        iVar4 = fcn.0043aad3(*(unaff_EBP + 0xc), puVar7);\n        puVar8 = puVar7;\n        goto code_r0x0043bede;\n    case 0x1b:\n        fcn.0043aad3(puVar7);\ncode_r0x0043bedb:\n        iVar4 = *(unaff_EBP + 0xc);\n        puVar8 = puVar7;\n        goto code_r0x0043bede;\n    case 0x1c:\n        puVar8 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar5 = fcn.0043aad3(puVar7, puVar8);\n        goto code_r0x0043bf08;\n    case 0x1d:\n    case 0x1e:\n        iVar4 = *(unaff_EBP + 0xc);\n        iVar6 = *(iVar6 + 0x10);\n        *(unaff_EBP + 8) = iVar4;\n        puVar8 = *(unaff_EBP + 0xc) >> 0x10;\n        *(unaff_EBP + 0xc) = puVar8;\n        if (iVar6 == 0x1d) {\n            uVar5 = fcn.0043aad3(puVar7);\n            uVar9 = *(unaff_EBP + 0xc);\n            puVar8 = puVar7;\n            goto code_r0x0043bf20;\n        }\ncode_r0x0043bede:\n        (*pcVar10)(iVar4, puVar8);\n        break;\n    case 0x1f:\n    case 0x24:\n        goto code_r0x0043befb;\n    case 0x20:\n    case 0x2b:\n        (*pcVar10)(*(unaff_EBP + 0xc), puVar7);\n        goto code_r0x0043bf2e;\n    case 0x22:\n        uVar5 = iVar11;\n        puVar7 = iVar3;\n        goto code_r0x0043bf6b;\n    case 0x23:\n        uVar12 = (*pcVar10)();\n        goto code_r0x0043bf6f;\n    case 0x2c:\ncode_r0x0043be62:\n        fcn.0043aad3(puVar7);\ncode_r0x0043befb:\n        (*pcVar10)(puVar7);\n        break;\n    case 0x2d:\n        uVar5 = fcn.0043aad3(*(unaff_EBP + 0xc), puVar7);\ncode_r0x0043bf6b:\n        uVar12 = (*pcVar10)(uVar5, puVar7);\n        goto code_r0x0043bf6f;\n    case 0x2e:\n        iVar4 = (*pcVar10)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar7 & 0xffff, puVar7 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar4;\n        goto code_r0x0043bb31;\n    case 0x30:\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar8 = puVar7;\ncode_r0x0043bf08:\n        uVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0043bf20;\n    case 0x31:\n        uVar5 = iVar11;\n        puVar8 = iVar3;\ncode_r0x0043bf1c:\n        uVar9 = *(unaff_EBP + 0xc);\ncode_r0x0043bf20:\n        (*pcVar10)(uVar9, uVar5, puVar8);\n    }\ncode_r0x0043bf72:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar12 = 1;\ncode_r0x0043bc63:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar12;\n}\n",
        "token_count": 4139
    },
    "0043c313": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0043c313(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[7] != 0)) {\n        iVar2 = (**(*param_1 + 0xb0))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.0043c183();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.0043c183();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 186
    },
    "0043c3a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043c3a4(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.0043c3a4(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return iVar3;\n        }\n        if (arg_10h == 0) {\n            iVar2 = fcn.0043aad3();\n            return iVar2;\n        }\n        iVar2 = fcn.0043aafa(iVar2);\n        if (iVar2 != 0) {\n            return iVar2;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar3 = fcn.0043c3a4(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return iVar3;\n}\n",
        "token_count": 339
    },
    "0043c41d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c41d(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.0043aafa(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0043a912(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0043c41d(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 332
    },
    "0043c55a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043c55a(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint unaff_ESI;\n    \n    if (param_2 == 3) {\n        fcn.0043c55a(0, param_3);\n        param_2 = 1;\n    }\n    iVar1 = (**(*param_1 + 0x68))(param_2);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_ShowScrollBar)(param_1[7], param_2, unaff_ESI);\n    }\n    else {\n        fcn.0043a0e9();\n    }\n    return;\n}\n",
        "token_count": 163
    },
    "0043c59d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043c59d(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (*0x49d0dc < 0x333) {\n        uVar1 = 0;\n    }\n    else {\n        iVar3 = param_1[7];\n        if (param_2 != 2) {\n            iVar2 = (**(*param_1 + 0x68))(param_2);\n            if (iVar2 != 0) {\n                iVar3 = *(iVar2 + 0x1c);\n                param_2 = 2;\n            }\n        }\n        *param_3 = 0x1c;\n        (*_sym.imp.USER32.dll_SetScrollInfo)(iVar3, param_2, param_3, param_4);\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 222
    },
    "0043c5ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043c5ea(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (*0x49d0dc < 0x333) {\n        uVar1 = 0;\n    }\n    else {\n        iVar3 = param_1[7];\n        if (param_2 != 2) {\n            iVar2 = (**(*param_1 + 0x68))(param_2);\n            if (iVar2 != 0) {\n                iVar3 = *(iVar2 + 0x1c);\n                param_2 = 2;\n            }\n        }\n        *param_3 = 0x1c;\n        param_3[1] = param_4;\n        uVar1 = (*_sym.imp.USER32.dll_GetScrollInfo)(iVar3, param_2, param_3);\n    }\n    return uVar1;\n}\n",
        "token_count": 226
    },
    "0043c67e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c67e(int32_t XAmount, int32_t YAmount, int32_t arg_10h, int32_t lpClipRect)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    int32_t lpRect;\n    int32_t Y;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x1c));\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (((iVar2 == 0) && (arg_10h == 0)) && (lpClipRect == 0)) {\n        uVar3 = 5;\n        iVar2 = *(in_ECX + 0x1c);\n        while( true ) {\n            iVar2 = (*pcVar1)(iVar2, uVar3);\n            if (iVar2 == 0) break;\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar2, &lpRect);\n            fcn.00447040(&lpRect);\n            (*_sym.imp.USER32.dll_SetWindowPos)(iVar2, 0, lpRect + XAmount, Y + YAmount, 0, 0, 0x15);\n            uVar3 = 2;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_ScrollWindow)(*(in_ECX + 0x1c), XAmount, YAmount, arg_10h, lpClipRect);\n    }\n    if ((*(in_ECX + 0x34) != NULL) && (arg_10h == 0)) {\n        (**(**(in_ECX + 0x34) + 0x58))(XAmount, YAmount);\n    }\n    return;\n}\n",
        "token_count": 390
    },
    "0043c724": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0043c724(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, int32_t *lprcDst, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t in_ECX;\n    int32_t hWinPosInfo;\n    int32_t lprcSrc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = arg_20h;\n    var_ch = 0;\n    var_10h = 0;\n    if (arg_1ch == NULL) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lprcSrc);\n    }\n    else {\n        lprcSrc = *arg_1ch;\n        var_1ch = arg_1ch[1];\n        var_18h = arg_1ch[2];\n        var_14h = arg_1ch[3];\n    }\n    if (arg_14h == 1) {\n        hWinPosInfo = 0;\n    }\n    else {\n        hWinPosInfo = (*_sym.imp.USER32.dll_BeginDeferWindowPos)(8);\n    }\n    for (iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(*(in_ECX + 0x1c)); iVar2 != 0;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2)) {\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        uVar3 = uVar3 & 0xffff;\n        iVar4 = fcn.0043aafa(iVar2);\n        iVar1 = iVar2;\n        if ((((uVar3 != arg_10h) && (iVar1 = var_4h,  arg_8h <= uVar3)) && (uVar3 <= arg_ch)) && (iVar4 != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageA)(iVar2, 0x361, 0, &hWinPosInfo);\n            iVar1 = var_4h;\n        }\n        var_4h = iVar1;\n    }\n    if (arg_14h == 1) {\n        if (arg_20h == 0) {\n            lprcDst[2] = var_10h;\n            lprcDst[1] = 0;\n            *lprcDst = 0;\n            lprcDst[3] = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_CopyRect)(lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        if ((arg_10h != 0) && (var_4h != 0)) {\n            piVar5 = fcn.0043aad3(var_4h);\n            if (arg_14h == 2) {\n                lprcSrc = lprcSrc + *lprcDst;\n                var_1ch = var_1ch + lprcDst[1];\n                var_18h = var_18h - lprcDst[2];\n                var_14h = var_14h - lprcDst[3];\n            }\n            (**(*piVar5 + 0x60))(&lprcSrc, 0);\n            fcn.0043c85e(&hWinPosInfo, var_4h, &lprcSrc);\n        }\n        if (hWinPosInfo != 0) {\n            (*_sym.imp.USER32.dll_EndDeferWindowPos)(hWinPosInfo);\n        }\n    }\n    return;\n}\n",
        "token_count": 907
    },
    "0043c85e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c85e(int32_t *arg_8h, uint hWnd, int32_t *lprc2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint lpRect;\n    uint var_8h;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetParent)(hWnd);\n    if ((arg_8h == NULL) || (*arg_8h != 0)) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n        pcVar2 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar3, &lpRect);\n        (*pcVar2)(uVar3, &var_8h);\n        iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprc2);\n        if (iVar4 == 0) {\n            iVar4 = lprc2[1];\n            iVar1 = *lprc2;\n            if (arg_8h == NULL) {\n                (*_sym.imp.USER32.dll_SetWindowPos)(hWnd, 0, iVar1, iVar4, lprc2[2] - iVar1, lprc2[3] - iVar4, 0x14);\n            }\n            else {\n                iVar4 = (*_sym.imp.USER32.dll_DeferWindowPos)\n                                  (*arg_8h, hWnd, 0, iVar1, iVar4, lprc2[2] - iVar1, lprc2[3] - iVar4);\n                *arg_8h = iVar4;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 383
    },
    "0043c8f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043c8f8(uint param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    \n    uVar1 = fcn.00439ee6();\n    if (param_2 == 0) {\n        uVar1 = uVar1 & 0xfffffdff;\n    }\n    uVar2 = fcn.00439ecc(0, uVar1);\n    (*_sym.imp.USER32.dll_AdjustWindowRectEx)(param_1, uVar2);\n    return;\n}\n",
        "token_count": 123
    },
    "0043c923": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043c923(uint32_t wParam, int32_t lParam)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint hWnd;\n    \n    iVar4 = fcn.0043c206();\n    uVar7 = wParam & 0xfff0;\n    if ((uVar7 == 0xf040) || (uVar7 == 0xf050)) {\n        if (lParam != 0x75) {\n            return 0;\n        }\n        if (iVar4 == 0) {\n            return 0;\n        }\n        fcn.0043a110();\n    }\n    else {\n        if ((uVar7 != 0xf060) && (uVar7 != 0xf100)) {\n            return 0;\n        }\n        if (((uVar7 == 0xf060) || (lParam != 0)) && (iVar4 != 0)) {\n            uVar1 = *(in_ECX + 0x1c);\n            uVar5 = (*_sym.imp.USER32.dll_GetFocus)();\n            pcVar2 = _sym.imp.USER32.dll_SetActiveWindow;\n            uVar6 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar4 + 0x1c));\n            fcn.0043aad3(uVar6);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x1c), 0x112, wParam, lParam);\n            pcVar3 = _sym.imp.USER32.dll_IsWindow;\n            iVar4 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar4 != 0) {\n                (*pcVar2)(uVar1);\n            }\n            iVar4 = (*pcVar3)(uVar5);\n            if (iVar4 != 0) {\n                (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 459
    },
    "0043caf8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043caf8(uint32_t arg_8h, uint wParam, uint lParam, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x38) == 0) {\n        iVar1 = fcn.0043cb53(arg_8h, wParam, lParam, arg_14h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), arg_8h + 0x2000, wParam, lParam);\n        if (((arg_8h < 0x132) || (0x138 < arg_8h)) || (iVar1 != 0)) {\n            if (arg_14h != NULL) {\n                *arg_14h = iVar1;\n            }\n            iVar1 = 1;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 214
    },
    "0043cc68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043cc68(int16_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1 == 0) {\n        iVar1 = fcn.00460301();\n        if ((*(iVar1 + 0xdf) & 0x40) == 0) {\n            fcn.0043b402(1);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 90
    },
    "0043cfde": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043cfde(int32_t hdc, uint arg_ch, int32_t arg_10h, int32_t hgdiobj, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint lpvObject;\n    uint crColor;\n    \n    if ((((hdc == 0) || (hgdiobj == 0)) || (arg_10h == 1)) || ((arg_10h == 0 || (arg_10h == 5)))) {\ncode_r0x0043d04d:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.00447bad(arg_ch, 2);\n            if (iVar1 == 0) goto code_r0x0043d04d;\n        }\n        (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0xc, &lpvObject);\n        (*_sym.imp.GDI32.dll_SetBkColor)(hdc, crColor);\n        if (arg_18h == -1) {\n            arg_18h = (*_sym.imp.USER32.dll_GetSysColor)(8);\n        }\n        (*_sym.imp.GDI32.dll_SetTextColor)(hdc, arg_18h);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 306
    },
    "0043d31c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043d31c(int16_t *arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_28h;\n    uint var_24h;\n    uint *var_20h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_SendDlgItemMessageA;\n    var_4h = 1;\n    if (arg_8h != NULL) {\n        do {\n            if (*arg_8h == 0) break;\n            iVar3 = arg_8h[1];\n            iVar1 = *(arg_8h + 2);\n            puVar5 = arg_8h + 4;\n            if (iVar3 == 0x1234) {\ncode_r0x0043d37e:\n                var_24h = 0xffffffff;\n                var_28h = 1;\n                iVar3 = 0x401;\n                puVar6 = &var_28h;\n                var_20h = puVar5;\ncode_r0x0043d3ac:\n                iVar4 = (*pcVar2)(*(in_ECX + 0x1c), *arg_8h, iVar3, 0, puVar6);\n                if (iVar4 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                puVar6 = puVar5;\n                if (iVar3 == 0x401) {\n                    iVar3 = 0x180;\n                    goto code_r0x0043d3ac;\n                }\n                if (iVar3 == 0x403) {\n                    iVar3 = 0x143;\n                }\n                if (iVar3 == 0x401) goto code_r0x0043d37e;\n                if ((iVar3 == 0x180) || (iVar3 == 0x143)) goto code_r0x0043d3ac;\n            }\n            arg_8h = puVar5 + iVar1;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.0043c41d(*(in_ECX + 0x1c), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 553
    },
    "0043d3ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_74h\n\nvoid __cdecl fcn.0043d3ee(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_74h;\n    uint hWnd;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00438691();\n    fcn.0043a6b2();\n    uVar1 = *(extraout_ECX + 0x1c);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(uVar1);\n    do {\n        if (iVar2 == 0) {\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(unaff_EBP + -0x58) = 0;\n            fcn.0043b18d();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return;\n        }\n        *(unaff_EBP + -0x58) = iVar2;\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        *(unaff_EBP + -0x34) = uVar3 & 0xffff;\n        *(unaff_EBP + -0x24) = unaff_EBP + -0x74;\n        iVar4 = fcn.0043aafa(iVar2);\n        if (((iVar4 == 0) || (iVar4 = fcn.004384b7(0, 0xbd11ffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) &&\n           (iVar4 = fcn.004384b7(*(unaff_EBP + -0x34), 0xffffffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) {\n            iVar4 = *(unaff_EBP + 0xc);\n            if (iVar4 != 0) {\n                uVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(unaff_EBP + -0x58), 0x87, 0, 0);\n                if ((uVar3 & 0x2000) != 0) {\n                    uVar3 = fcn.00439ecc();\n                    uVar3 = uVar3 & 0xf;\n                    if (((uVar3 != 3) && (uVar3 != 6)) && ((uVar3 != 7 && (uVar3 != 9)))) goto code_r0x0043d4b4;\n                }\n                iVar4 = 0;\n            }\ncode_r0x0043d4b4:\n            fcn.00438856(*(unaff_EBP + 8), iVar4);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    } while( true );\n}\n",
        "token_count": 732
    },
    "0043dad6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0043dad6(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0043ab18(param_2);\n    if (iVar1 != 0) {\n        (**(*param_1 + 0x50))();\n        piVar2 = (**(*param_1 + 0x80))();\n        uVar3 = fcn.0043abaf();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(unaff_retaddr, 0xfffffffc, uVar3);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 193
    },
    "0043dcf7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043dcf7(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x98) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x98));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if (iVar2 == 0) {\n            iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0);\n            if (iVar2 != 0) {\n                if (*(in_ECX + 0x94) != 0) {\n                    fcn.00447d7f(*(in_ECX + 0x94));\n                }\n                uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n                *(in_ECX + 0x94) = uVar3;\n                uVar3 = (*pcVar1)(uVar3);\n                iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n                if (iVar2 != 1) {\n                    fcn.00447d7f(*(in_ECX + 0x94));\n                    *(in_ECX + 0x94) = 0;\n                }\n                sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 434
    },
    "0043dfc7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043dfc7(uint param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    iVar2 = fcn.004605b7();\n    piVar1 = *(iVar2 + 4);\n    if (piVar1 != NULL) {\n        if (piVar1[0x15] != NULL) {\n            (*piVar1[0x15])(1, 0);\n        }\n        if (param_2 != 0) {\n            (**(*piVar1 + 0x78))();\n        }\n        *(iVar2 + 4) = 0;\n    }\n    fcn.0043e06b(0);\n    fcn.0040e929(unaff_retaddr);\n    return;\n}\n",
        "token_count": 182
    },
    "0043e00c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043e00c(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00460591();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.00460301();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, 0x43e4b6, 0, uVar2);\n        *(iVar1 + 0x30) = uVar2;\n        iVar1 = fcn.00462b7c(0x46090f);\n        if (*(iVar1 + 0x14) != 0) {\n            iVar3 = fcn.00460591();\n            (**(iVar1 + 0x14))(*(iVar3 + 8));\n        }\n        fcn.00462aba(0x461d9f);\n    }\n    return;\n}\n",
        "token_count": 228
    },
    "0043e06b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043e06b(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_retaddr;\n    \n    fcn.004402d3();\n    fcn.004402dc(0xffffffff);\n    if (unaff_retaddr == 0) {\n        iVar1 = fcn.00462b31();\n        if ((iVar1 != 0) && (*(iVar1 + 0xcc) != NULL)) {\n            (**(**(iVar1 + 0xcc) + 0x58))();\n            if (*(iVar1 + 0xcc) != NULL) {\n                (**(**(iVar1 + 0xcc) + 4))(1);\n            }\n            *(iVar1 + 0xcc) = 0;\n        }\n    }\n    if (*0x49d484 != 0) {\n        fcn.00462a61(unaff_retaddr, 0);\n    }\n    return;\n}\n",
        "token_count": 199
    },
    "0043e491": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043e491(uint param_1, uint *param_2)\n\n{\n    uint uVar1;\n    \n    if (param_2[1] == 1) {\n        uVar1 = 0xffffffff;\n    }\n    else {\n        if (param_2[1] == 0xf) {\n            (*_sym.imp.USER32.dll_ValidateRect)(*param_2, 0);\n        }\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 109
    },
    "0043e833": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043e833(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    pcVar1 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 1;\n    if ((pcVar1 != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.0043eb0b();\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 225
    },
    "0043f10e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043f10e(char *lpString1, uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint var_618h;\n    uint var_410h;\n    uint var_208h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString2);\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString1);\n            iVar3 = (*pcVar1)(lpString2);\n            if (iVar2 != iVar3) goto code_r0x0043f1cd;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n            pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeExA;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExA)(uVar4, 1, lpString1, 0xffffffff, &var_208h);\n            (*pcVar1)(uVar4, 4, lpString1, 0xffffffff, &var_410h);\n            (*pcVar1)(uVar4, 1, lpString2, 0xffffffff, &var_618h);\n            if (*lpString1 != '\\0') {\n                iVar2 = 0;\n                do {\n                    if (((*(&var_410h + iVar2) & 0x80) != 0) && (*(&var_208h + iVar2) != *(&var_618h + iVar2)))\n                    goto code_r0x0043f1cd;\n                    iVar2 = iVar2 + 2;\n                    lpString1 = fcn.0040e115(lpString1);\n                } while (*lpString1 != '\\0');\n            }\n        }\n        uVar4 = 1;\n    }\n    else {\ncode_r0x0043f1cd:\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 491
    },
    "0043f2c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043f2c5(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0xb);\n    *(param_1 + 8) = uVar2;\n    uVar2 = (*pcVar1)(0xc);\n    *(param_1 + 0xc) = uVar2;\n    if (*(param_1 + 0x68) == 0) {\n        fcn.004621e2();\n    }\n    else {\n        fcn.004621b2();\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar2, 0x58);\n    *(param_1 + 0x18) = uVar3;\n    uVar3 = (*pcVar1)(uVar2, 0x5a);\n    *(param_1 + 0x1c) = uVar3;\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    return;\n}\n",
        "token_count": 292
    },
    "0043f31d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043f31d(int32_t param_1, uint param_2)\n\n{\n    uint arg_8h;\n    int32_t arg_10h;\n    \n    if (param_1 != 0) {\n        arg_10h = param_1;\n        arg_8h = fcn.0043f4c3(param_1, param_1, param_2);\n        fcn.0043f402(arg_8h, param_1, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 116
    },
    "0043f874": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043f874(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    fcn.0040d6f0(arg_8h, 0, 0x118);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_8h + 0x12, *(in_ECX + 0xc), 0x104);\n    if (*(in_ECX + 4) == -1) {\ncode_r0x0043f944:\n        uVar2 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetFileSize)(*(in_ECX + 4), 0);\n            arg_8h[3] = iVar1;\n            if (iVar1 != -1) {\n                if (*(*(in_ECX + 0xc) + -8) == 0) {\ncode_r0x0043f8e8:\n                    *(arg_8h + 4) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    if (iVar1 == -1) goto code_r0x0043f8e8;\n                    *(arg_8h + 4) = iVar1;\n                }\n                piVar3 = fcn.0042fc18(&lpCreationTime, 0xffffffff);\n                *arg_8h = *piVar3;\n                piVar3 = fcn.0042fc18(&lpLastAccessTime, 0xffffffff);\n                arg_8h[2] = *piVar3;\n                piVar3 = fcn.0042fc18(&lpLastWriteTime, 0xffffffff);\n                iVar1 = *piVar3;\n                arg_8h[1] = iVar1;\n                if (*arg_8h == 0) {\n                    *arg_8h = iVar1;\n                }\n                if (arg_8h[2] == 0) {\n                    arg_8h[2] = arg_8h[1];\n                }\n                goto code_r0x0043f944;\n            }\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 586
    },
    "0043f94e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0043f94e(uint lpFileName, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint lpFindFileData;\n    uint var_13ch;\n    uint var_134h;\n    uint var_12ch;\n    int32_t var_120h;\n    \n    iVar1 = fcn.0043ef78(arg_ch + 0x12, lpFileName);\n    if (iVar1 == 0) {\n        *(arg_ch + 0x12) = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(lpFileName, &lpFindFileData);\n        if (iVar1 != -1) {\n            (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n            *(arg_ch + 4) = lpFindFileData & 0x7f;\n            arg_ch[3] = var_120h;\n            piVar2 = fcn.0042fc18(&var_13ch, 0xffffffff);\n            *arg_ch = *piVar2;\n            piVar2 = fcn.0042fc18(&var_134h, 0xffffffff);\n            arg_ch[2] = *piVar2;\n            piVar2 = fcn.0042fc18(&var_12ch, 0xffffffff);\n            iVar1 = *piVar2;\n            arg_ch[1] = iVar1;\n            if (*arg_ch == 0) {\n                *arg_ch = iVar1;\n            }\n            if (arg_ch[2] == 0) {\n                arg_ch[2] = arg_ch[1];\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 391
    },
    "00440048": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00440048(uint lpMultiByteStr, uint arg_ch)\n\n{\n    uint uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    ushort *puVar4;\n    uint *in_ECX;\n    int32_t iVar5;\n    int16_t iVar6;\n    int32_t iVar7;\n    uint32_t arg_8h;\n    uint lpWideCharStr;\n    ushort *var_10h;\n    uint32_t var_ch;\n    uint *hMem;\n    uint32_t var_4h;\n    \n    if (in_ECX[1] == 0) {\n        uVar1 = 0;\n    }\n    else {\n        hMem = in_ECX;\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        var_4h = *(puVar2 + 2) == -1;\n        if (*(puVar2 + 2) == -1) {\n            var_ch = puVar2[3];\n        }\n        else {\n            var_ch = *puVar2;\n        }\n        var_ch = var_ch & 0x40;\n        iVar7 = (-(var_4h != 0) & 2) + 1;\n        if (var_4h == 0) {\n            *puVar2 = *puVar2 | 0x40;\n        }\n        else {\n            puVar2[3] = puVar2[3] | 0x40;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &lpWideCharStr, 0x20);\n        iVar3 = iVar7 * 2 + iVar3 * 2;\n        puVar4 = fcn.0043fe9d(puVar2);\n        iVar5 = 0;\n        var_10h = puVar4;\n        if (var_ch != 0) {\n            iVar5 = fcn.0040da5c(puVar4 + iVar7);\n            iVar5 = iVar7 * 2 + 2 + iVar5 * 2;\n        }\n        var_ch = iVar5 + 3 + puVar4 & 0xfffffffc;\n        arg_8h = puVar4 + iVar3 + 3 & 0xfffffffc;\n        if (var_4h == 0) {\n            iVar6 = *(puVar2 + 2);\n        }\n        else {\n            iVar6 = *(puVar2 + 4);\n        }\n        if ((iVar3 != iVar5) && (iVar6 != 0)) {\n            fcn.0040dde0(arg_8h, var_ch, puVar2 + (hMem[1] - var_ch));\n        }\n        *var_10h = arg_ch;\n        fcn.0040dde0(var_10h + iVar7, &lpWideCharStr, iVar3 + iVar7 * -2);\n        hMem[1] = hMem[1] + (arg_8h - var_ch);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*hMem);\n        hMem[2] = 0;\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 712
    },
    "00440162": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00440162(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *lpMultiByteStr;\n    int32_t lpvObject;\n    uint var_24h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uVar4 = 10;\n    lpMultiByteStr = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x004401d6;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        lpMultiByteStr = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x004401d6:\n    if (arg_8h == 0) {\n        arg_8h = uVar4;\n    }\n    fcn.00440048(lpMultiByteStr, arg_8h);\n    return;\n}\n",
        "token_count": 392
    },
    "004402dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004402dc(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.004605b7();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (arg_8h != -1) {\n                iVar2 = fcn.0043ded2();\n                if ((iVar2 != 0) && (*(iVar2 + 0x54) != NULL)) {\n                    (**(iVar2 + 0x54))(0, 0);\n                }\n            }\n            fcn.004404fa();\n            fcn.004404fa();\n            fcn.004404fa();\n            fcn.004404fa();\n            fcn.004404fa();\n        }\n        iVar2 = fcn.00460591();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.00462aba(0x460619);\n        if (iVar2 != 0) {\n            if (*(iVar3 + 0xc) != 0) {\n                uVar4 = fcn.0040eb2d(*(iVar3 + 0xc));\n                if (*(iVar2 + 0xb8) <= uVar4) goto code_r0x004403c7;\n            }\n            if (*(iVar2 + 0xb8) != 0) {\n                arg_8h = 0;\n                if (*(iVar3 + 0xc) != 0) {\n                    arg_8h = fcn.0040eb2d(*(iVar3 + 0xc));\n                    fcn.0040d21b(*(iVar3 + 0xc));\n                }\n                iVar2 = fcn.0040d777(*(iVar2 + 0xb8));\n                *(iVar3 + 0xc) = iVar2;\n                if ((iVar2 == 0) && (arg_8h != 0)) {\n                    uVar5 = fcn.0040d777(arg_8h);\n                    *(iVar3 + 0xc) = uVar5;\n                }\n            }\n        }\n    }\ncode_r0x004403c7:\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 554
    },
    "0044043b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.0044043b(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if (arg_8h_00 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = fcn.00436cdc(arg_8h_00);\n        if (iVar2 == 0) {\n            iVar2 = fcn.00436cdc(arg_8h_00);\n            if (iVar2 == 0) {\n                uVar3 = fcn.00438325(0x447db5);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + 8) = uVar3;\n                iVar2 = fcn.0043a2b3();\n                if (iVar2 == 0) {\n                    fcn.0042eb4c();\n                }\n                piVar4 = fcn.00436d31(arg_8h_00);\n                uVar3 = *(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *piVar4 = iVar2;\n                fcn.00438325(uVar3);\n                iVar1 = *(extraout_ECX + 0x40);\n                *(iVar1 + iVar2) = arg_8h_00;\n                if (*(extraout_ECX + 0x44) == 2) {\n                    *(iVar1 + iVar2 + 4) = arg_8h_00;\n                }\n            }\n            else {\n                iVar1 = *(extraout_ECX + 0x40);\n                *(iVar1 + iVar2) = arg_8h_00;\n                if (*(extraout_ECX + 0x44) == 2) {\n                    *(iVar1 + iVar2 + 4) = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 605
    },
    "004404fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004404fa(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x2c) != 0);\n        while (var_8h != 0) {\n            fcn.00436dc3(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x40) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x44) == 2) {\n                puVar1[1] = 0;\n            }\n            if (var_4h != NULL) {\n                (**(*var_4h + 4))(1);\n            }\n        }\n        fcn.00436bf0();\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "004405a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004405a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = fcn.004605b7();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00438325(0x447db5);\n        iVar3 = fcn.00438337(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004403d6(0x474ea8, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.00438325(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 346
    },
    "0044069c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044069c(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.00440672();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 86
    },
    "004406b8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004406b8(char *lpString, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint var_4h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar3 = fcn.00463d21(lpString, 0, 0);\n    iVar3 = iVar3 + -1;\n    pcVar5 = lpString + (iVar2 - iVar3);\n    if (arg_ch < iVar2) {\n        if (arg_ch < iVar3) {\n            if (arg_10h == 0) {\n                pcVar5 = 0x49b5a0;\n            }\n        }\n        else {\n            pcVar4 = lpString + 2;\n            if ((*lpString == '\\\\') && (lpString[1] == '\\\\')) {\n                for (; *pcVar4 != '\\\\'; pcVar4 = fcn.0040e115(pcVar4)) {\n                }\n            }\n            if (3 < iVar2 - iVar3) {\n                do {\n                    pcVar4 = fcn.0040e115(pcVar4);\n                } while (*pcVar4 != '\\\\');\n            }\n            iVar2 = pcVar4 - lpString;\n            if (iVar2 + 5 + iVar3 <= arg_ch) {\n                while (iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar4),  arg_ch < iVar3 + 4 + iVar2) {\n                    do {\n                        pcVar4 = fcn.0040e115(pcVar4);\n                    } while (*pcVar4 != '\\\\');\n                }\n                lpString[iVar2] = '\\0';\n                pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(lpString, \"\\\\...\");\n                (*pcVar1)(lpString, pcVar4);\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, pcVar5);\n    }\n    return;\n}\n",
        "token_count": 480
    },
    "004409b1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004409b1(uint arg_8h, int32_t arg_ch, uint lpString1, int32_t arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    int32_t lpString;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint lpString2;\n    int32_t var_4h;\n    \n    if (*(*(*(in_ECX + 8) + arg_ch * 4) + -8) == 0) {\n        return 0;\n    }\n    var_4h = in_ECX;\n    lpString = fcn.00438f78(0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, *(*(var_4h + 8) + arg_ch * 4));\n    iVar2 = fcn.00463d21(lpString, 0, 0);\n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar3 = (1 - iVar2) + iVar3;\n    if (iVar3 == arg_14h) {\n        uVar1 = *(iVar3 + lpString);\n        *(arg_14h + lpString) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString);\n        *(iVar3 + lpString) = uVar1;\n        if (iVar2 == 0) {\n            fcn.0043f1d1(arg_14h + lpString, &lpString2, 0x104);\n            (*_sym.imp.KERNEL32.dll_lstrcpynA)(lpString, &lpString2, 0x104);\n            goto code_r0x00440aa3;\n        }\n    }\n    if (*(var_4h + 0x18) != -1) {\n        fcn.0043f1d1(iVar3 + lpString, &lpString2, 0x104);\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(iVar3 + lpString, &lpString2, 0x104 - iVar3);\n        fcn.004406b8(lpString, *(var_4h + 0x18), arg_18h);\n    }\ncode_r0x00440aa3:\n    fcn.00438fc7(0xffffffff);\n    return 1;\n}\n",
        "token_count": 532
    },
    "00444231": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00444231(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x34);\n    while (iVar1 != 0) {\n        iVar1 = fcn.00434f63();\n        *(iVar1 + 0x3c) = 0;\n        iVar1 = *(param_1 + 0x34);\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "00444289": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00444289(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        iVar1 = (**(*param_1 + 100))(&var_4h);\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n        if ((iVar1 != 0) && (iVar1 = fcn.0043c183(),  iVar1 != 0)) {\n            *(iVar1 + 0x40) = 0xffffffff;\n        }\n    }\n    var_8h = 0;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        iVar1 = (**(*param_1 + 100))(&var_4h);\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n        if (((iVar1 != 0) && (iVar1 = fcn.0043c183(),  iVar1 != 0)) && (*(iVar1 + 0x40) == -1)) {\n            var_8h = var_8h + 1;\n            *(iVar1 + 0x40) = var_8h;\n        }\n    }\n    iVar1 = 1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        iVar2 = (**(*param_1 + 100))(&var_4h);\n        iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar2 + 0x1c));\n        if (((iVar2 != 0) && (piVar3 = fcn.0043c183(),  piVar3 != NULL)) && (piVar3[0x10] == iVar1)) {\n            if (var_8h == 1) {\n                piVar3[0x10] = 0;\n            }\n            (**(*piVar3 + 0xe0))(1);\n            iVar1 = iVar1 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 538
    },
    "00444376": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00444376(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    do {\n        if (var_4h == NULL) {\n            uVar2 = (**(*param_1 + 0x90))();\n            return uVar2;\n        }\n        (**(*param_1 + 100))(&var_4h);\n        iVar1 = fcn.0043c183();\n    } while ((iVar1 == 0) || (*(iVar1 + 0x40) < 1));\n    return 1;\n}\n",
        "token_count": 168
    },
    "004443c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004443c2(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint var_204h;\n    uint var_104h;\n    \n    fcn.0043ef78(&var_104h, arg_8h);\n    fcn.00438cd1(&var_104h);\n    in_ECX[0x13] = 0;\n    iVar1 = fcn.0043f1d1(&var_104h, &var_204h, 0x100);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0x50))(&var_204h);\n    }\n    if (arg_ch != 0) {\n        iVar1 = in_ECX[8];\n        iVar2 = fcn.00460591();\n        (**(**(iVar2 + 4) + 0x80))(iVar1);\n    }\n    return;\n}\n",
        "token_count": 224
    },
    "0044521d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044521d(int32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    int32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0x60))();\n    while (var_4h != 0) {\n        piVar1 = (**(*in_ECX + 100))(&var_4h);\n        if (piVar1 != arg_8h) {\n            (**(*piVar1 + 0xec))(arg_8h, arg_ch, arg_10h);\n        }\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "0044525e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044525e(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        piVar1 = (**(*param_1 + 100))(&var_4h);\n        (**(*piVar1 + 0xe0))();\n    }\n    return;\n}\n",
        "token_count": 118
    },
    "004453a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004453a2(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    bool bVar4;\n    int32_t var_4h;\n    \n    var_4h = fcn.0044534b(arg_8h);\n    bVar4 = var_4h == -1;\n    if (bVar4) {\n        var_4h = fcn.0044534b(arg_8h);\n    }\n    uVar2 = bVar4;\n    iVar3 = (uVar2 + 1) * var_4h;\n    if (var_4h == 0) {\n        fcn.00438fef(0);\n    }\n    else {\n        fcn.00438fef(iVar3 + uVar2);\n        iVar1 = fcn.004456bd(*arg_ch, iVar3);\n        if (iVar1 != iVar3) {\n            fcn.004464d7(3, 0);\n        }\n        if (uVar2 != 0) {\n            iVar3 = *arg_ch;\n            *(iVar3 + var_4h * 2) = 0;\n            *arg_ch = *0x498098;\n            fcn.00438cf8(iVar3);\n            fcn.00438360(iVar3 + -0xc);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 320
    },
    "00445627": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00445627(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x20) != 0) && ((*(extraout_ECX + 0x14) & 2) == 0)) {\n        fcn.004456af();\n    }\n    fcn.0044566d();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 216
    },
    "004456bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004456bd(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if (arg_ch == 0) {\n        iVar1 = 0;\n    }\n    else {\n        uVar3 = *(in_ECX + 0x28) - *(in_ECX + 0x24);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.0040cd30(arg_8h, *(in_ECX + 0x24), uVar3);\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x1c);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x20) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if (var_8h == iVar1) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    var_4h = uVar3;\n                    if (uVar3 <= *(in_ECX + 0x1c)) {\n                        var_4h = *(in_ECX + 0x1c);\n                    }\n                    var_8h = *(in_ECX + 0x2c);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x20) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x2c);\n                    *(in_ECX + 0x24) = iVar1;\n                    *(in_ECX + 0x28) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x20) + 0x50))(0, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n                    iVar1 = *(in_ECX + 0x2c);\n                    *(in_ECX + 0x24) = iVar1;\n                }\n                uVar4 = *(in_ECX + 0x28) - iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.0040cd30(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x24) = *(in_ECX + 0x24) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 870
    },
    "004457cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004457cc(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if (arg_ch != 0) {\n        arg_10h = *(in_ECX + 0x28) - *(in_ECX + 0x24);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.0040cd30(*(in_ECX + 0x24), arg_8h, arg_10h);\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.0044585c();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x1c);\n            (**(**(in_ECX + 0x20) + 0x38))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x20) + 0x50))(1, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n                *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n            }\n            fcn.0040cd30(*(in_ECX + 0x24), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 416
    },
    "004458d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004458d8(uint32_t arg_8h)\n\n{\n    uint32_t arg_ch;\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    arg_ch = *(in_ECX + 0x24);\n    var_4h = *(in_ECX + 0x28) - arg_ch;\n    uVar1 = arg_8h + var_4h;\n    if (*(in_ECX + 8) == 0) {\n        arg_8h_00 = *(in_ECX + 0x2c);\n        if (arg_8h_00 < arg_ch) {\n            if (0 < var_4h) {\n                fcn.0040dde0(arg_8h_00, arg_ch, var_4h);\n                arg_8h_00 = *(in_ECX + 0x2c);\n                *(in_ECX + 0x24) = arg_8h_00;\n                *(in_ECX + 0x28) = arg_8h_00 + var_4h;\n            }\n            iVar3 = *(in_ECX + 0x1c) - var_4h;\n            iVar4 = var_4h + arg_8h_00;\n            do {\n                iVar2 = (**(**(in_ECX + 0x20) + 0x34))(iVar4, iVar3);\n                var_4h = var_4h + iVar2;\n                iVar4 = iVar4 + iVar2;\n                iVar3 = iVar3 - iVar2;\n                if ((iVar2 == 0) || (iVar3 == 0)) break;\n            } while (var_4h < arg_8h);\n            *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n            *(in_ECX + 0x28) = *(in_ECX + 0x2c) + var_4h;\n        }\n    }\n    else {\n        if (var_4h != 0) {\n            (**(**(in_ECX + 0x20) + 0x28))(-var_4h, 1);\n        }\n        (**(**(in_ECX + 0x20) + 0x50))(0, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n        *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n    }\n    if (*(in_ECX + 0x28) - *(in_ECX + 0x24) < uVar1) {\n        fcn.004464d7(3, 0);\n    }\n    return;\n}\n",
        "token_count": 648
    },
    "00445bb2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00445bb2(int32_t param_1)\n\n{\n    if (*(param_1 + 0x28) == 0) {\n        fcn.0043d76a(8);\n        *(param_1 + 0x28) = \"AfxFrameOrView42s\";\n    }\n    if ((*0x49d0e4 != 0) && ((*(param_1 + 0x20) & 0x800000) != 0)) {\n        *(param_1 + 0x2d) = *(param_1 + 0x2d) | 2;\n        *(param_1 + 0x20) = *(param_1 + 0x20) & 0xff7fffff;\n    }\n    return 1;\n}\n",
        "token_count": 173
    },
    "00445e84": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00445e84(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBX;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    uVar2 = fcn.0043aad3(uVar2);\n    iVar3 = fcn.0043a281(0x472d70);\n    if (iVar3 != 0) {\n        if (unaff_EBX != 0) {\n            return uVar2;\n        }\n        do {\n            uVar4 = (*pcVar1)(*(param_1 + 0x1c));\n            param_1 = fcn.0043aad3(uVar4);\n            if (param_1 == 0) {\n                return uVar2;\n            }\n            iVar3 = (*_sym.imp.USER32.dll_IsIconic)(*(param_1 + 0x1c));\n        } while (iVar3 == 0);\n    }\n    return 0;\n}\n",
        "token_count": 260
    },
    "0044656c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0044656c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = fcn.004605b7();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00438325(0x447db5);\n        iVar3 = fcn.00438337(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004403d6(0x474708, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.00438325(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 348
    },
    "00446671": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00446671(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDC.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != NULL) {\n        uVar1 = fcn.0044662a(extraout_ECX);\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 201
    },
    "00447853": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00447853(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = fcn.004605b7();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.00438325(0x447db5);\n        iVar3 = fcn.00438337(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.004403d6(0x4746e0, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.00438325(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 346
    },
    "00447931": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00447931(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.00447907();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 86
    },
    "00447bad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00447bad(int32_t hWnd, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint lpClassName;\n    \n    if ((hWnd != 0) && (uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar1 & 0xf) == arg_ch)) {\n        (*_sym.imp.USER32.dll_GetClassNameA)(hWnd, &lpClassName, 10);\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(&lpClassName, \"combobox\");\n        return iVar2 == 0;\n    }\n    return false;\n}\n",
        "token_count": 156
    },
    "00447e9a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00447e9a(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *arg_ch;\n    uint32_t in_ECX;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    iVar2 = fcn.004480da(arg_8h, &var_8h, &var_4h);\n    if (iVar2 == 0) {\n        if (*(*(in_ECX + 0x34) + 8) - 1U < var_4h) {\n            fcn.004464d7(5, *(in_ECX + 0x10));\n        }\n        arg_ch = *(*(*(in_ECX + 0x34) + 4) + var_4h * 4);\n        if ((arg_ch != NULL) && (arg_8h != 0)) {\n            iVar2 = fcn.0043a281(arg_8h);\n            if (iVar2 == 0) {\n                fcn.004464d7(6, *(in_ECX + 0x10));\n            }\n        }\n    }\n    else {\n        arg_ch = fcn.0043a2b3();\n        if (arg_ch == NULL) {\n            fcn.0042eb4c();\n        }\n        fcn.00447e07();\n        iVar2 = *(in_ECX + 0x30);\n        *(in_ECX + 0x30) = iVar2 + 1;\n        fcn.00435683(iVar2, arg_ch, 1);\n        uVar1 = *(in_ECX + 0xc);\n        *(in_ECX + 0xc) = var_8h;\n        (**(*arg_ch + 8))();\n        *(in_ECX + 0xc) = uVar1;\n    }\n    return arg_ch;\n}\n",
        "token_count": 439
    },
    "004480da": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_eh\n\nint32_t __cdecl fcn.004480da(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint16_t uVar1;\n    int32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t arg_8h_01;\n    int32_t unaff_EBP;\n    uint32_t uVar5;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_eh;\n    uint var_4h;\n    \n    fcn.0040d954();\n    if ((*(unaff_EBP + 8) != 0) && (*(*(unaff_EBP + 8) + 8) == 0xffff)) {\n        fcn.0042eb65();\n    }\n    fcn.00447f51(0);\n    fcn.00401091(unaff_EBP + -0xe);\n    if (*(unaff_EBP + -0xe) == 0x7fff) {\n        fcn.0040be39(unaff_EBP + -0x18);\n    }\n    else {\n        uVar1 = *(unaff_EBP + -0xe);\n        *(unaff_EBP + -0x18) = CONCAT22(uVar1, uVar1 & 0xff | (uVar1 >> 8) << 8) & 0x80007fff;\n    }\n    if ((*(unaff_EBP + -0x18) & 0x80000000) == 0) {\n        puVar3 = *(unaff_EBP + 0x10);\n        if (puVar3 == NULL) {\n            fcn.004464d7(5, *(arg_8h_01 + 0x10));\n        }\n        *puVar3 = *(unaff_EBP + -0x18);\n        arg_8h_00 = 0;\n    }\n    else {\n        if (*(unaff_EBP + -0xe) == -1) {\n            arg_8h_00 = fcn.00445488(arg_8h_01, unaff_EBP + -0x14);\n            if (arg_8h_00 == 0) {\n                fcn.004464d7(6, *(arg_8h_01 + 0x10));\n            }\n            if ((*(arg_8h_00 + 8) & 0x7fffffff) != *(unaff_EBP + -0x14)) {\n                if ((*(arg_8h_00 + 8) & 0x80000000) == 0) {\n                    fcn.004464d7(7, *(arg_8h_01 + 0x10));\n                }\n                else {\n                    if (*(arg_8h_01 + 0x38) == 0) {\n                        iVar4 = fcn.00438337(0x1c);\n                        *(unaff_EBP + -0x1c) = iVar4;\n                        *(unaff_EBP + -4) = 0;\n                        if (iVar4 == 0) {\n                            uVar2 = 0;\n                        }\n                        else {\n                            uVar2 = fcn.00436b68();\n                        }\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        *(arg_8h_01 + 0x38) = uVar2;\n                    }\n                    uVar2 = *(unaff_EBP + -0x14);\n                    puVar3 = fcn.00436d31(arg_8h_00);\n                    *puVar3 = uVar2;\n                }\n            }\n            fcn.00447e07();\n            iVar4 = *(arg_8h_01 + 0x30);\n            *(arg_8h_01 + 0x30) = iVar4 + 1;\n            fcn.00435683(iVar4, arg_8h_00, 1);\n            uVar5 = *(unaff_EBP + -0x14);\n        }\n        else {\n            uVar5 = *(unaff_EBP + -0x18) & 0x7fffffff;\n            if ((uVar5 == 0) || (*(*(arg_8h_01 + 0x34) + 8) - 1U < uVar5)) {\n                fcn.004464d7(5, *(arg_8h_01 + 0x10));\n            }\n            iVar4 = *(arg_8h_01 + 0x38);\n            arg_8h_00 = *(*(*(arg_8h_01 + 0x34) + 4) + uVar5 * 4);\n            *(unaff_EBP + -0x14) = 0;\n            if ((iVar4 == 0) || (iVar4 = fcn.00436d0f(arg_8h_00, unaff_EBP + -0x1c),  iVar4 == 0)) {\n                uVar5 = *(arg_8h_00 + 8) & 0x7fffffff;\n            }\n            else {\n                uVar5 = *(unaff_EBP + -0x1c);\n            }\n            *(unaff_EBP + -0x14) = uVar5;\n        }\n        if (*(unaff_EBP + 8) != 0) {\n            iVar4 = fcn.0043a35e(*(unaff_EBP + 8));\n            if (iVar4 == 0) {\n                fcn.004464d7(6, *(arg_8h_01 + 0x10));\n            }\n            uVar5 = *(unaff_EBP + -0x14);\n        }\n        if (*(unaff_EBP + 0xc) == NULL) {\n            *(arg_8h_01 + 0xc) = uVar5;\n        }\n        else {\n            **(unaff_EBP + 0xc) = uVar5;\n        }\n        if (*(unaff_EBP + 0x10) != NULL) {\n            **(unaff_EBP + 0x10) = *(unaff_EBP + -0x18);\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return arg_8h_00;\n}\n",
        "token_count": 1451
    },
    "004482d2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.004482d2(void)\n\n{\n    int32_t iVar1;\n    uint var_8ch;\n    uint var_ch;\n    uint var_8h;\n    uint hKey;\n    \n    if (*0x49b70c != 0) {\n        return *0x49d508;\n    }\n    *0x49b70c = 1;\n    if (*0x49d504 == 0) {\n        *0x49d500 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"MSH_SCROLL_LINES_MSG\");\n        if (*0x49d500 == 0) {\n            *0x49d504 = 1;\n            goto code_r0x00448322;\n        }\n        *0x49d504 = 2;\n    }\n    if (((*0x49d504 == 2) && (iVar1 = (*_sym.imp.USER32.dll_FindWindowA)(\"MouseZ\", \"Magellan MSWHEEL\"),  iVar1 != 0)) &&\n       (*0x49d500 != 0)) {\n        *0x49d508 = (*_sym.imp.USER32.dll_SendMessageA)(iVar1, *0x49d500, 0, 0);\n        return *0x49d508;\n    }\ncode_r0x00448322:\n    *0x49d508 = 3;\n    if (*0x49d0e4 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"Control Panel\\\\Desktop\", 0, 1, &hKey);\n        if (iVar1 == 0) {\n            var_8h = 0x80;\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, \"WheelScrollLines\", 0, &var_ch, &var_8ch, &var_8h);\n            if (iVar1 == 0) {\n                *0x49d508 = fcn.0040d53e(&var_8ch, 0, 10);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        }\n    }\n    else if (*0x49d0e0 == 0) {\n        (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x68, 0, 0x49d508, 0);\n    }\n    return *0x49d508;\n}\n",
        "token_count": 535
    },
    "0044882b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044882b(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0043c4cf(1);\n    iVar2 = fcn.0043c4cf(0);\n    if (*(in_ECX + 100) != 0) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n        if (*(in_ECX + 0x4c) < var_8h - lpRect) {\n            iVar2 = ((var_8h - *(in_ECX + 0x4c)) - lpRect) / -2;\n        }\n        if (*(in_ECX + 0x50) < var_4h - var_ch) {\n            iVar1 = ((var_4h - *(in_ECX + 0x50)) - var_ch) / -2;\n        }\n    }\n    *arg_8h = iVar2;\n    arg_8h[1] = iVar1;\n    return;\n}\n",
        "token_count": 281
    },
    "00448f21": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00448f21(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.0043ca27(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x68))(0);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0xbc))(CONCAT11(0xff, arg_8h), arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 150
    },
    "00448f65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00448f65(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.0043ca27(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x68))(1);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0xbc))(CONCAT31(arg_8h, 0xff), arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 150
    },
    "00448fe1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00448fe1(uint noname_0, uint nNumber)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    int32_t iVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = fcn.00439ecc();\n    iVar4 = (**(*in_ECX + 0x68))(1);\n    if (((iVar4 == 0) || (iVar4 = fcn.0043a0ce(),  iVar4 == 0)) && ((uVar3 & 0x200000) == 0)) {\n        bVar1 = false;\n    }\n    else {\n        bVar1 = true;\n    }\n    iVar4 = (**(*in_ECX + 0x68))(0);\n    if (((iVar4 == 0) || (iVar4 = fcn.0043a0ce(),  iVar4 == 0)) && ((uVar3 & 0x100000) == 0)) {\n        bVar2 = false;\n    }\n    else {\n        bVar2 = true;\n    }\n    if ((bVar1) || (bVar2)) {\n        iVar4 = fcn.004482d2();\n        if (bVar1) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar4, 0x78);\n            if ((iVar5 == -1) || (iVar4 == -1)) {\n                iVar6 = in_ECX[0x16];\n                if (0 < nNumber) {\n                    iVar6 = -iVar6;\n                }\n            }\n            else {\n                iVar6 = in_ECX[0x18] * iVar5;\n                if (in_ECX[0x16] <= in_ECX[0x18] * iVar5) {\n                    iVar6 = in_ECX[0x16];\n                }\n            }\n            iVar5 = *in_ECX;\n            iVar4 = 0;\n        }\n        else {\n            if (!bVar2) {\n                return 0;\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar4, 0x78);\n            if ((iVar6 == -1) || (iVar4 == -1)) {\n                iVar4 = in_ECX[0x15];\n                if (0 < nNumber) {\n                    iVar4 = -iVar4;\n                }\n            }\n            else {\n                iVar4 = in_ECX[0x17] * iVar6;\n                if (in_ECX[0x15] <= in_ECX[0x17] * iVar6) {\n                    iVar4 = in_ECX[0x15];\n                }\n            }\n            iVar5 = *in_ECX;\n            iVar6 = 0;\n        }\n        iVar4 = (**(iVar5 + 0xc0))(iVar4, iVar6, 1);\n        if (iVar4 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(in_ECX[7]);\n        }\n    }\n    else {\n        iVar4 = 0;\n    }\n    return iVar4;\n}\n",
        "token_count": 709
    },
    "00449814": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00449814(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d6f0(&var_14h, 0, 0x14);\n    var_4h = 0;\n    var_10h = arg_ch;\n    if (arg_10h == 0) {\n        var_14h = 0;\n    }\n    else {\n        var_14h = *(in_ECX + 0x5c);\n    }\n    if ((*(in_ECX + 0x58) != 0) && (piVar1 = fcn.0043a2b3(),  piVar1 != NULL)) {\n        iVar2 = (**(*piVar1 + 0xb8))(*(in_ECX + 0x40), 0x44000000, arg_8h, &var_14h);\n        return -(iVar2 != 0) & piVar1;\n    }\n    return 0;\n}\n",
        "token_count": 275
    },
    "0044bfb9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044bfb9(uint lpText, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    uint *puVar4;\n    uint var_114h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t hWnd;\n    \n    fcn.0044bf8b(0);\n    var_ch = fcn.0044c131(0, &hWnd);\n    if (((var_ch == 0) || (piVar1 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x376, 0, 0),  piVar1 == NULL)) &&\n       (piVar1 = NULL,  in_ECX != 0)) {\n        piVar1 = in_ECX + 0x9c;\n    }\n    var_8h = 0;\n    if ((piVar1 != NULL) && (var_8h = *piVar1,  arg_10h != 0)) {\n        *piVar1 = arg_10h + 0x30000;\n    }\n    if (((arg_ch & 0xf0) == 0) && ((uVar2 = arg_ch & 0xf,  uVar2 < 2 || ((2 < uVar2 && (uVar2 < 5)))))) {\n        arg_ch = arg_ch | 0x30;\n    }\n    if (in_ECX == 0) {\n        puVar4 = &var_114h;\n        (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, &var_114h, 0x104);\n    }\n    else {\n        puVar4 = *(in_ECX + 0x78);\n    }\n    uVar3 = (*_sym.imp.USER32.dll_MessageBoxA)(var_ch, lpText, puVar4, arg_ch);\n    if (piVar1 != NULL) {\n        *piVar1 = var_8h;\n    }\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    fcn.0044bf8b(1);\n    return uVar3;\n}\n",
        "token_count": 515
    },
    "0044c1fc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c1fc(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00439cf5(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        fcn.0042eb65();\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = arg_8h;\n    return;\n}\n",
        "token_count": 105
    },
    "0044c22b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044c22b(int32_t *param_1)\n\n{\n    if ((*param_1 != 0) && (param_1[2] != 0)) {\n        (*_sym.imp.USER32.dll_SetFocus)(param_1[2]);\n        if (param_1[3] != 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(param_1[2], 0xb1, 0, 0xffffffff);\n        }\n    }\n    fcn.00447b1c();\n    return;\n}\n",
        "token_count": 123
    },
    "0044c260": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044c260(char *arg_8h, int32_t arg_ch, int32_t **arg_10h)\n\n{\n    char cVar1;\n    bool bVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    pcVar3 = arg_ch + 1;\n    bVar2 = false;\n    if (*pcVar3 != 'l') {\n        if (*pcVar3 != 's') goto code_r0x0044c27e;\n        bVar2 = true;\n    }\n    pcVar3 = arg_ch + 2;\ncode_r0x0044c27e:\n    for (; (*arg_8h == ' ' || (*arg_8h == '\\t')); arg_8h = arg_8h + 1) {\n    }\n    cVar1 = *arg_8h;\n    if (*pcVar3 == 'd') {\n        iVar4 = fcn.0040d322(arg_8h, &arg_8h, 10);\n    }\n    else {\n        if (cVar1 == '-') {\n            return 0;\n        }\n        iVar4 = fcn.0040d53e(arg_8h, &arg_8h, 10);\n    }\n    if ((iVar4 != 0) || (cVar1 == '0')) {\n        for (; (*arg_8h == ' ' || (*arg_8h == '\\t')); arg_8h = arg_8h + 1) {\n        }\n        if (*arg_8h == '\\0') {\n            if (bVar2) {\n                if (iVar4 != iVar4) {\n                    return 0;\n                }\n                **arg_10h = iVar4;\n            }\n            else {\n                **arg_10h = iVar4;\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 409
    },
    "0044c305": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c305(int32_t *arg_8h, uint arg_ch, uint ARG_1, uint arg_14h, uint arglist)\n\n{\n    uint hWnd;\n    int32_t iVar1;\n    uint lpString;\n    \n    hWnd = fcn.0044c1e5(arg_ch);\n    if (*arg_8h == 0) {\n        (*_sym.imp.USER32.dll_wvsprintfA)(&lpString, ARG_1, &arglist);\n        fcn.00447c97(hWnd, &lpString);\n    }\n    else {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString, 0x20);\n        iVar1 = fcn.0044c260(&lpString, ARG_1, &arglist);\n        if (iVar1 == 0) {\n            fcn.0044c0d8(arg_14h, 0, 0xffffffff);\n            fcn.0044c22b();\n        }\n    }\n    return;\n}\n",
        "token_count": 225
    },
    "0044c375": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c375(int32_t *arg_8h, uint arg_ch, uint8_t *arg_10h)\n\n{\n    uint8_t *puVar1;\n    \n    puVar1 = arg_10h;\n    arg_10h = *arg_10h;\n    if (*arg_8h == 0) {\n        fcn.0044c305(arg_8h, arg_ch, 0x472d2c, 0xf116, arg_10h);\n    }\n    else {\n        fcn.0044c305(arg_8h, arg_ch, 0x472d2c, 0xf116, &arg_10h);\n        if (0xff < arg_10h) {\n            fcn.0044c0d8(0xf116, 0, 0xffffffff);\n            fcn.0044c22b();\n        }\n        *puVar1 = arg_10h;\n    }\n    return;\n}\n",
        "token_count": 215
    },
    "0044c3e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c3e6(int32_t *arg_8h, uint arg_ch, int16_t *arg_10h)\n\n{\n    uint ARG_1;\n    \n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n        ARG_1 = 0x472d30;\n    }\n    else {\n        ARG_1 = 0x472d34;\n    }\n    fcn.0044c305(arg_8h, arg_ch, ARG_1, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 132
    },
    "0044c421": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c421(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0044c305(arg_8h, arg_ch, 0x472d38, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 95
    },
    "0044c450": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c450(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0044c305(arg_8h, arg_ch, 0x472d2c, 0xf117, arg_10h);\n    return;\n}\n",
        "token_count": 96
    },
    "0044c47f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c47f(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0044c305(arg_8h, arg_ch, 0x472d3c, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 97
    },
    "0044c4ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c4ae(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0044c305(arg_8h, arg_ch, 0x472d40, 0xf117, arg_10h);\n    return;\n}\n",
        "token_count": 96
    },
    "0044c4dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c4dd(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    uint hWnd;\n    int32_t iVar1;\n    uint uVar2;\n    \n    hWnd = fcn.0044c1e5(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.00447c97(hWnd, *arg_10h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        uVar2 = fcn.00438fef(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, uVar2);\n        fcn.00438fc7(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 176
    },
    "0044c52f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c52f(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint hWnd;\n    \n    hWnd = fcn.0044c1e5(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.00447c97(hWnd, arg_10h);\n    }\n    else {\n        (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, arg_10h, arg_14h);\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "0044c6d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c6d0(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    uVar2 = fcn.0044c1fc(arg_ch);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*arg_8h == 0) {\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(uVar2, 0x1a2, 0xffffffff, *arg_10h);\n        if (-1 < iVar3) {\n            (*pcVar1)(uVar2, 0x186, iVar3, 0);\n        }\n    }\n    else {\n        fcn.0044c650(arg_8h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "0044c721": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c721(int32_t *arg_8h, uint arg_ch, uint *lParam)\n\n{\n    uint hWnd;\n    int32_t iVar1;\n    uint uVar2;\n    \n    hWnd = fcn.0044c1fc(arg_ch);\n    if (*arg_8h == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x14d, 0xffffffff, *lParam);\n        if (iVar1 == -1) {\n            fcn.00447c97(hWnd, *lParam);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        if (iVar1 < 1) {\n            uVar2 = fcn.00438f78(0xff, 0x100);\n        }\n        else {\n            uVar2 = fcn.00438fef(iVar1, iVar1 + 1);\n        }\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, uVar2);\n        fcn.00438fc7(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 252
    },
    "0044c7a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c7a0(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    code *pcVar1;\n    uint hWnd;\n    int32_t iVar2;\n    \n    hWnd = fcn.0044c1fc(arg_ch);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*arg_8h == 0) {\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x158, 0xffffffff, *arg_10h);\n        if (iVar2 < 0) {\n            fcn.00447c97(hWnd, *arg_10h);\n        }\n        else {\n            (*pcVar1)(hWnd, 0x14e, iVar2, 0);\n        }\n    }\n    else {\n        fcn.0044c721(arg_8h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 213
    },
    "0044c900": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4ch\n\nvoid __cdecl fcn.0044c900(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint var_2ch;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    pcVar1 = _sym.imp.USER32.dll_wsprintfA;\n    if (**(unaff_EBP + 8) != 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(unaff_EBP + -0x4c, *(unaff_EBP + 0x14), *(unaff_EBP + 0xc));\n        (*pcVar1)(unaff_EBP + -0x2c, *(unaff_EBP + 0x14), *(unaff_EBP + 0x10));\n        *(unaff_EBP + 8) = *0x498098;\n        *(unaff_EBP + -4) = 0;\n        fcn.004534ab(unaff_EBP + 8, *(unaff_EBP + 0x18), unaff_EBP + -0x4c, unaff_EBP + -0x2c);\n        fcn.0044c0a0(*(unaff_EBP + 8), 0x30, *(unaff_EBP + 0x18));\n        fcn.00438ad3();\n        fcn.0044c22b();\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00438b48();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 409
    },
    "0044caa3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044caa3(int32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if ((*arg_8h != 0) || ((arg_10h <= arg_ch && (arg_ch <= arg_14h)))) {\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h[2], 0x407, 0, arg_10h);\n        (*pcVar1)(arg_8h[2], 0x407, 1, arg_14h);\n    }\n    return;\n}\n",
        "token_count": 161
    },
    "0044cda1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044cda1(int32_t arg_8h, uint arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    bool bVar2;\n    uint var_4h;\n    \n    bVar2 = false;\n    puVar1 = *(in_ECX + 0x5c) + arg_8h * 0x14;\n    *puVar1 = arg_ch;\n    if (puVar1[2] != arg_10h) {\n        bVar2 = ((puVar1[2] ^ arg_10h) & 0x8000000) == 0;\n        if (bVar2) {\n            puVar1[3] = puVar1[3] | 1;\n            puVar1[2] = arg_10h;\n            fcn.0044ce5d(arg_8h, puVar1[4], 1, unaff_EDI, unaff_ESI, unaff_EBX);\n        }\n        bVar2 = !bVar2;\n        puVar1[2] = arg_10h;\n    }\n    if (arg_14h != puVar1[1]) {\n        puVar1[1] = arg_14h;\n        bVar2 = true;\n    }\n    if (bVar2) {\n        fcn.00460ce8(1, 0);\n    }\n    return;\n}\n",
        "token_count": 349
    },
    "0044d28a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0044d28a(code **param_1)\n\n{\n    fcn.0043a6b2();\n    *param_1 = vtable.CSplitterWnd.0;\n    fcn.0040d6f0(param_1 + 0xf, 0, 0x88);\n    if (*0x49d0e4 == 0) {\n        param_1[0x13] = 0x4;\n        param_1[0x12] = 0x4;\n        param_1[0x15] = 0x1;\n        param_1[0x14] = 0x1;\n        param_1[0x17] = 0x6;\n        param_1[0x16] = 0x6;\n    }\n    else {\n        param_1[0x15] = NULL;\n        param_1[0x14] = NULL;\n        param_1[0x13] = 0x7;\n        param_1[0x12] = 0x7;\n        param_1[0x17] = 0x7;\n        param_1[0x16] = 0x7;\n        param_1[0x19] = 0x2;\n        param_1[0x18] = 0x2;\n    }\n    return param_1;\n}\n",
        "token_count": 305
    },
    "0044d7f1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0044d7f1(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (*(param_1 + 0x70) != 0) {\n        uVar1 = 0x100000;\n    }\n    if (*(param_1 + 0x74) != 0) {\n        uVar1 = uVar1 | 0x200000;\n    }\n    return uVar1;\n}\n",
        "token_count": 111
    },
    "0044ea9d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044ea9d(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint var_24h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n    if (*0x49d0e4 != 0) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x1c), &var_24h);\n        var_4h = param_1;\n        uVar3 = fcn.00439ecc();\n        if ((uVar3 & 0x40000) == 0) {\n            uVar4 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n            var_4h = fcn.0043aad3(uVar4);\n        }\n        uVar3 = fcn.00439ecc();\n        iVar2 = var_4h;\n        if ((uVar3 & 0x1040000) == 0x40000) {\n            (*pcVar1)(*(var_4h + 0x1c), &var_14h);\n            fcn.0044707c(&var_14h);\n            fcn.00447040(&var_14h);\n            if ((var_1ch == var_ch) && (var_18h == var_8h)) {\n                return iVar2;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 385
    },
    "0044f5de": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044f5de(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_8h);\n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x11);\n    iVar3 = 0;\n    iVar5 = ((-1 < iVar2) - 1 & 0xfffffff1) + 0x10;\n    iVar6 = 0;\n    if (arg_8h == 0xd) {\n        iVar3 = *in_ECX;\n        uVar7 = 1;\n    }\n    else {\n        if (arg_8h != 0x1b) {\n            if (arg_8h == 0x25) {\n                iVar6 = -1;\n            }\n            else if (arg_8h == 0x26) {\n                iVar3 = -1;\n            }\n            else if (arg_8h == 0x27) {\n                iVar6 = 1;\n            }\n            else {\n                if (arg_8h != 0x28) {\n                    fcn.0043aa3a();\n                    return;\n                }\n                iVar3 = 1;\n            }\n            iVar1 = in_ECX[0x30];\n            if ((iVar1 == 1) || ((100 < iVar1 && (iVar1 < 0x74)))) {\n                iVar6 = 0;\n            }\n            if ((iVar1 == 2) || ((200 < iVar1 && (iVar1 < 0xd8)))) {\n                iVar3 = 0;\n            }\n            var_4h = var_4h + iVar3 * iVar5;\n            var_8h = var_8h + iVar6 * iVar5;\n            (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[7], &var_8h);\n            piVar4 = in_ECX[0x25];\n            if ((var_4h < piVar4) || (piVar4 = in_ECX[0x27],  piVar4 < var_4h)) {\n                var_4h = piVar4;\n            }\n            piVar4 = in_ECX[0x24];\n            if ((var_8h < piVar4) || (piVar4 = in_ECX[0x26],  piVar4 < var_8h)) {\n                var_8h = piVar4;\n            }\n            (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &var_8h);\n            (*_sym.imp.USER32.dll_SetCursorPos)(var_8h, var_4h);\n            return;\n        }\n        iVar3 = *in_ECX;\n        uVar7 = 0;\n    }\n    (**(iVar3 + 0x11c))(uVar7);\n    return;\n}\n",
        "token_count": 716
    },
    "0044f7b1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044f7b1(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    uint uVar5;\n    uint uVar6;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    if (0 < *(in_ECX + 0x68)) {\n        do {\n            var_4h = 0;\n            if (0 < *(in_ECX + 0x6c)) {\n                do {\n                    uVar1 = fcn.0044d6c1(var_8h, var_4h);\n                    piVar2 = fcn.0043a293(0x474f30, uVar1);\n                    if ((piVar2 != NULL) &&\n                       ((iVar3 = (**(*piVar2 + 0x68))(1),  iVar3 != 0 || (iVar3 = (**(*piVar2 + 0x68))(0),  iVar3 != 0))\n                       )) {\n                        uVar4 = (*_sym.imp.USER32.dll_GetScrollPos)(*(iVar3 + 0x1c), 2);\n                        uVar1 = arg_8h;\n                        uVar5 = arg_ch;\n                        uVar6 = arg_10h;\n                        fcn.00448fe1(arg_8h, arg_ch);\n                        if (var_4h < *(in_ECX + 0x6c) + -1) {\n                            (*_sym.imp.USER32.dll_SetScrollPos)(*(iVar3 + 0x1c), 2, uVar4, 0, uVar1, uVar5, uVar6);\n                        }\n                    }\n                    var_4h = var_4h + 1;\n                } while (var_4h < *(in_ECX + 0x6c));\n            }\n            var_8h = var_8h + 1;\n        } while (var_8h < *(in_ECX + 0x68));\n    }\n    return 1;\n}\n",
        "token_count": 496
    },
    "0044f877": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044f877(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar2 = arg_10h;\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_10h + 0x1c));\n    uVar4 = (*_sym.imp.USER32.dll_GetScrollPos)(*(arg_10h + 0x1c), 2);\n    arg_10h = 0;\n    if (0 < *(in_ECX + 0x68)) {\n        do {\n            uVar1 = *(iVar2 + 0x1c);\n            iVar5 = fcn.0044d6c1(arg_10h, (uVar3 & 0xffff) - 0xea00);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar5 + 0x1c), 0x114, arg_8h & 0xffff | arg_ch << 0x10, uVar1);\n            if (arg_10h < *(in_ECX + 0x68) + -1) {\n                (*_sym.imp.USER32.dll_SetScrollPos)(*(iVar2 + 0x1c), 2, uVar4, 0);\n            }\n            arg_10h = arg_10h + 1;\n        } while (arg_10h < *(in_ECX + 0x68));\n    }\n    return;\n}\n",
        "token_count": 373
    },
    "0044f90d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044f90d(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar2 = arg_10h;\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_10h + 0x1c));\n    uVar4 = (*_sym.imp.USER32.dll_GetScrollPos)(*(arg_10h + 0x1c), 2);\n    arg_10h = 0;\n    if (0 < *(in_ECX + 0x6c)) {\n        do {\n            uVar1 = *(iVar2 + 0x1c);\n            iVar5 = fcn.0044d6c1((uVar3 & 0xffff) - 0xea10, arg_10h);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar5 + 0x1c), 0x115, arg_8h & 0xffff | arg_ch << 0x10, uVar1);\n            if (arg_10h < *(in_ECX + 0x6c) + -1) {\n                (*_sym.imp.USER32.dll_SetScrollPos)(*(iVar2 + 0x1c), 2, uVar4, 0);\n            }\n            arg_10h = arg_10h + 1;\n        } while (arg_10h < *(in_ECX + 0x6c));\n    }\n    return;\n}\n",
        "token_count": 377
    },
    "0044fd73": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044fd73(uint hModule, int32_t hResInfo, int32_t arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uchar uVar4;\n    uchar extraout_AH;\n    int32_t iVar5;\n    int32_t *arg_ch;\n    int32_t *arg_8h;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint var_ch;\n    uint var_8h;\n    uint nIndex;\n    \n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if ((iVar5 != 0) && (arg_ch = (*_sym.imp.KERNEL32.dll_LockResource)(iVar5),  arg_ch != NULL)) {\n        iVar5 = *arg_ch;\n        arg_8h = fcn.0040d777(iVar5 + 0x40);\n        if (arg_8h != NULL) {\n            fcn.0040cd30(arg_8h, arg_ch, iVar5 + 0x40);\n            puVar12 = arg_8h + *arg_8h;\n            hResInfo = 0x10;\n            do {\n                iVar5 = 0;\n                puVar11 = 0x473b80;\n                do {\n                    if (*puVar12 == *puVar11) {\n                        if (arg_10h == 0) {\n                            puVar1 = iVar5 * 8 + 0x473b84;\n                            (*_sym.imp.USER32.dll_GetSysColor)(*(iVar5 * 8 + 0x473b84));\n                            uVar4 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            uVar6 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            *puVar12 = CONCAT11(uVar4, extraout_AH) << 8 | uVar6 >> 0x10 & 0xff;\n                        }\n                        else if (*(iVar5 * 8 + 0x473b84) != 0x12) {\n                            *puVar12 = 0xffffff;\n                        }\n                        break;\n                    }\n                    puVar11 = puVar11 + 2;\n                    iVar5 = iVar5 + 1;\n                } while (puVar11 < 0x473ba0);\n                puVar12 = puVar12 + 1;\n                hResInfo = hResInfo + -1;\n                if (hResInfo == 0) {\n                    iVar5 = arg_8h[1];\n                    iVar2 = arg_8h[2];\n                    uVar7 = (*_sym.imp.USER32.dll_GetDC)(0);\n                    iVar8 = (*_sym.imp.GDI32.dll_CreateCompatibleBitmap)(uVar7, iVar5, iVar2);\n                    if (iVar8 != 0) {\n                        uVar9 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(uVar7);\n                        pcVar3 = _sym.imp.GDI32.dll_SelectObject;\n                        uVar10 = (*_sym.imp.GDI32.dll_SelectObject)(uVar9, iVar8);\n                        (*_sym.imp.GDI32.dll_StretchDIBits)\n                                  (uVar9, 0, 0, iVar5, iVar2, 0, 0, iVar5, iVar2, \n                                   arg_ch + (1 << (*(arg_8h + 0xe) & 0x1f)) + 10, arg_8h, 0, 0xcc0020);\n                        (*pcVar3)(uVar9, uVar10);\n                        (*_sym.imp.GDI32.dll_DeleteDC)(uVar9);\n                    }\n                    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar7);\n                    fcn.0040d21b(arg_8h);\n                    return iVar8;\n                }\n            } while( true );\n        }\n    }\n    return 0;\n}\n",
        "token_count": 900
    },
    "00450b20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00450b20(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    int32_t iVar2;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    if (*(extraout_ECX + 0x98) != 0) {\n        iVar2 = *(unaff_EBP + 8);\n        fcn.0044fedf(iVar2, unaff_EBP + -0x28);\n        iVar1 = *(*(extraout_ECX + 0x98) + 0xc);\n        *(unaff_EBP + 8) = *0x498098;\n        iVar1 = -(iVar1 != 0);\n        *(unaff_EBP + -0x10) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        while (iVar1 != 0) {\n            iVar2 = unaff_EBP + -0x10;\n            fcn.00437123();\n            if (*(unaff_EBP + -0x14) == *(unaff_EBP + -0x18)) {\n                fcn.00438c81(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00438b48();\n                goto code_r0x00450b9f;\n            }\n            iVar1 = *(unaff_EBP + -0x10);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00438b48(iVar2);\n    }\n    fcn.00438ad3();\ncode_r0x00450b9f:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 440
    },
    "0045103f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045103f(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t *piVar7;\n    int32_t *in_ECX;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar2 < 0) {\n        return;\n    }\n    iVar3 = fcn.00460301();\n    var_8h = iVar3;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[7], &var_10h);\n    var_4h = (**(*in_ECX + 100))(var_10h, var_ch, 0);\n    if (var_4h < 0) {\n        *(iVar3 + 0x104) = 0xffffffff;\n    }\n    else {\n        iVar4 = fcn.0043c206();\n        iVar5 = fcn.0043c2a2();\n        if ((iVar5 == 0) || (iVar5 = fcn.0043a0ce(),  iVar5 == 0)) {\n            var_4h = -1;\n        }\n        if (*(iVar3 + 0xcc) == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *(*(iVar3 + 0xcc) + 0x1c);\n        }\n        uVar6 = (*_sym.imp.USER32.dll_GetCapture)();\n        piVar7 = fcn.0043aad3(uVar6);\n        if (piVar7 != in_ECX) {\n            if (piVar7 == NULL) {\n                iVar5 = 0;\n            }\n            else {\n                iVar5 = piVar7[7];\n            }\n            if ((iVar5 != iVar3) && (iVar3 = fcn.0043c206(),  iVar3 == iVar4)) {\n                var_4h = -1;\n            }\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_KillTimer;\n    if (-1 < var_4h) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &var_10h);\n        iVar3 = (*_sym.imp.USER32.dll_WindowFromPoint)(var_10h, var_ch);\n        if (iVar3 == 0) {\ncode_r0x0045114f:\n            var_4h = -1;\n            *(var_8h + 0x104) = 0xffffffff;\n        }\n        else if ((iVar3 != in_ECX[7]) && (iVar4 = (*_sym.imp.USER32.dll_IsChild)(in_ECX[7], iVar3),  iVar4 == 0)) {\n            iVar4 = *(var_8h + 0xcc);\n            if (iVar4 != 0) {\n                iVar4 = *(iVar4 + 0x1c);\n            }\n            if (iVar4 != iVar3) goto code_r0x0045114f;\n        }\n        if (-1 < var_4h) goto code_r0x00451185;\n    }\n    if (*(var_8h + 0x104) == -1) {\n        (*pcVar1)(in_ECX[7], 0xe001);\n    }\n    (**(*in_ECX + 0xdc))(0xffffffff);\ncode_r0x00451185:\n    if ((arg_8h == 0xe000) && ((*pcVar1)(in_ECX[7], 0xe000),  -1 < var_4h)) {\n        (**(*in_ECX + 0xdc))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 870
    },
    "004516d2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004516d2(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    if (*(param_1 + 0x1c) != 0) {\n        iVar1 = fcn.0045bd54();\n        if (iVar1 != 0) {\n            piVar2 = fcn.0045bd43();\n            (**(*piVar2 + 0x58))();\n            return;\n        }\n    }\n    fcn.0043b34b();\n    return;\n}\n",
        "token_count": 123
    },
    "00451895": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451895(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x1c] != 0) && (iVar1 = (**(*in_ECX + 100))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &arg_ch);\n        (***in_ECX[0x1d])(arg_ch, arg_10h);\n        return;\n    }\n    fcn.0043aa3a();\n    return;\n}\n",
        "token_count": 154
    },
    "00451bed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00451bed(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    int32_t in_ECX;\n    int32_t iVar7;\n    uint var_34h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = *(in_ECX + 100);\n    if ((uVar1 & 0xf00) != 0) {\n        var_2ch = arg_ch[2];\n        var_28h = arg_ch[3];\n        var_20h = arg_ch[1];\n        iVar7 = arg_ch[3];\n        uVar5 = *0x49d0b4;\n        if (*0x49d0e4 == 0) {\n            uVar5 = *0x49d0c0;\n        }\n        if ((uVar1 & 0x80) != 0) {\n            var_2ch = var_2ch + -1;\n            var_28h = var_28h + -1;\n        }\n        uVar2 = uVar1 & 0x200;\n        if (uVar2 != 0) {\n            var_20h = var_20h + *0x49d09c;\n        }\n        uVar3 = uVar1 & 0x800;\n        if (uVar3 != 0) {\n            iVar7 = iVar7 - *0x49d09c;\n        }\n        uVar4 = uVar1 & 0x100;\n        if (uVar4 != 0) {\n            fcn.0045c6a3(0, var_20h, 1, iVar7 - var_20h, uVar5);\n        }\n        if (uVar2 != 0) {\n            fcn.0045c6a3(0, 0, arg_ch[2], 1, uVar5);\n        }\n        uVar6 = uVar1 & 0x400;\n        if (uVar6 != 0) {\n            fcn.0045c6a3(var_2ch, var_20h, 0xffffffff, iVar7 - var_20h, uVar5);\n        }\n        if (uVar3 != 0) {\n            fcn.0045c6a3(0, var_28h, arg_ch[2], 0xffffffff, uVar5);\n        }\n        uVar5 = *0x49d0b8;\n        if ((uVar1 & 0x80) != 0) {\n            if (uVar4 != 0) {\n                fcn.0045c6a3(1, var_20h, 1, iVar7 - var_20h, *0x49d0b8);\n            }\n            if (uVar2 != 0) {\n                fcn.0045c6a3(0, 1, arg_ch[2], 1, uVar5);\n            }\n            if (uVar6 != 0) {\n                fcn.0045c6a3(arg_ch[2], var_20h, 0xffffffff, iVar7 - var_20h, uVar5);\n            }\n            if (uVar3 != 0) {\n                fcn.0045c6a3(0, arg_ch[3], arg_ch[2], 0xffffffff, uVar5);\n            }\n        }\n        if (uVar4 != 0) {\n            *arg_ch = *arg_ch + *0x49d098;\n        }\n        if (uVar2 != 0) {\n            arg_ch[1] = arg_ch[1] + *0x49d09c;\n        }\n        if (uVar6 != 0) {\n            arg_ch[2] = arg_ch[2] - *0x49d098;\n        }\n        if (uVar3 != 0) {\n            arg_ch[3] = arg_ch[3] - *0x49d09c;\n        }\n    }\n    return;\n}\n",
        "token_count": 981
    },
    "0045229e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045229e(int32_t arg_8h, int32_t lprcSrc)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    ushort uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    uint var_124h;\n    uint lpRect;\n    int32_t lprcDst;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n    if (*(arg_8h + 0x70) == in_ECX) {\n        if (lprcSrc == 0) {\n            return;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprcSrc);\n        if (iVar4 != 0) {\n            return;\n        }\n    }\n    if ((*(in_ECX + 0x78) != 0) && ((*(arg_8h + 0x68) & 0x40) != 0)) {\n        *(in_ECX + 100) = *(in_ECX + 100) | 0x40;\n    }\n    *(in_ECX + 100) = *(in_ECX + 100) & 0xfffffff9;\n    uVar5 = *(in_ECX + 100);\n    *(in_ECX + 100) = *(arg_8h + 100) & 6 | uVar5;\n    if ((uVar5 & 0x40) == 0) {\n        fcn.00439f89(&var_124h, 0x104);\n        fcn.00447c97(*(in_ECX + 0x1c), &var_124h);\n    }\n    uVar5 = *(arg_8h + 100);\n    uVar2 = uVar5 >> 8;\n    uVar1 = CONCAT11((*(in_ECX + 100) >> 8 ^ uVar2) & 0xf0 ^ uVar2, uVar5);\n    if (*(in_ECX + 0x78) == 0) {\n        uVar5 = uVar5 & 0xffff0000 | uVar1 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar5 = uVar5 & 0xffff0000 | uVar1 | 0xf01;\n    }\n    fcn.00461602(uVar5);\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n    iVar4 = fcn.00452bbb(uVar3);\n    if (0 < iVar4) {\n        *(*(in_ECX + 0x80) + iVar4 * 4) = arg_8h;\n    }\n    if (lprcSrc == 0) {\n        if (iVar4 < 1) {\n            fcn.0043565c(*(in_ECX + 0x84), arg_8h);\n            fcn.0043565c(*(in_ECX + 0x84), 0);\n        }\n        uVar6 = 0x115;\n        var_4h = 0;\n        var_ch = -*0x49d09c;\n        var_8h = 0;\n        lprcDst = -*0x49d098;\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, lprcSrc);\n        fcn.00447040();\n        if (iVar4 < 1) {\n            fcn.00452c46(arg_8h, lprcDst, var_ch, var_8h, var_4h, (var_8h - lprcDst) / 2 + lprcDst, \n                         (var_4h - var_ch) / 2 + var_ch);\n        }\n        uVar6 = 0x114;\n        var_4h = var_4h - var_ch;\n        var_8h = var_8h - lprcDst;\n    }\n    fcn.0043a058(0, lprcDst, var_ch, var_8h, var_4h, uVar6);\n    uVar6 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x1c));\n    iVar4 = fcn.0043aad3(uVar6);\n    if (iVar4 != in_ECX) {\n        if (in_ECX == 0) {\n            uVar6 = 0;\n        }\n        else {\n            uVar6 = *(in_ECX + 0x1c);\n        }\n        uVar6 = (*_sym.imp.USER32.dll_SetParent)(*(arg_8h + 0x1c), uVar6);\n        fcn.0043aad3(uVar6);\n    }\n    if (*(arg_8h + 0x70) != 0) {\n        fcn.004524e6(arg_8h, 0xffffffff, 0);\n    }\n    *(arg_8h + 0x70) = in_ECX;\n    iVar4 = fcn.0045bd43();\n    *(iVar4 + 0xb8) = *(iVar4 + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 1211
    },
    "00452485": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00452485(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 >> 0x10 != 0) {\n        param_2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_2 + 0x1c));\n        param_2 = param_2 & 0xffff;\n    }\n    iVar1 = fcn.00452bbb(param_2, 0xffffffff);\n    if (0 < iVar1) {\n        fcn.00435715(iVar1, 1);\n        if ((*(*(param_1 + 0x80) + -4 + iVar1 * 4) == 0) && (*(*(param_1 + 0x80) + iVar1 * 4) == 0)) {\n            fcn.00435715(iVar1, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 207
    },
    "004524e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004524e6(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    iVar4 = arg_8h;\n    iVar2 = fcn.00452bbb(arg_8h, arg_ch);\n    if (arg_10h == 1) {\n        iVar1 = in_ECX[0x20];\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c));\n        *(iVar1 + iVar2 * 4) = uVar3 & 0xffff;\n        iVar4 = fcn.00452bbb(iVar4, iVar2);\n        if (0 < iVar4) {\n            fcn.00435715();\n            if ((*(in_ECX[0x20] + -4 + iVar2 * 4) == 0) && (*(in_ECX[0x20] + iVar2 * 4) == 0)) {\n                fcn.00435715(iVar2, 1);\n            }\n        }\n    }\n    else {\n        fcn.00435715(iVar2, 1);\n        if ((*(in_ECX[0x20] + -4 + iVar2 * 4) == 0) && (*(in_ECX[0x20] + iVar2 * 4) == 0)) {\n            fcn.00435715(iVar2, 1);\n        }\n        if (arg_10h != -1) {\n            fcn.00452485(arg_8h);\n        }\n    }\n    if (*(arg_8h + 0x74) != 0) {\n        piVar5 = fcn.0045bd43();\n        if ((in_ECX[0x1e] == 0) || (iVar4 = (**(*in_ECX + 0xe0))(),  iVar4 != 0)) {\n            piVar5[0x2e] = piVar5[0x2e] | 0xc;\n        }\n        else {\n            iVar4 = fcn.0045200b();\n            if (iVar4 == 0) {\n                (**(*piVar5 + 0x58))();\n                return 1;\n            }\n            fcn.0043a0a7(0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 558
    },
    "00452d85": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00452d85(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(extraout_ECX + 0x68) = *(unaff_EBP + 8);\n    if (*(extraout_ECX + 0x74) == 0) {\n        iVar1 = fcn.00438337(0xb0);\n        *(unaff_EBP + 8) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.00453512(extraout_ECX);\n        }\n        *(extraout_ECX + 0x74) = uVar2;\n    }\n    if (*(extraout_ECX + 0x20) == 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(extraout_ECX + 0x1c));\n        *(extraout_ECX + 0x20) = uVar2;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 321
    },
    "00453057": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00453057(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    uint uVar3;\n    \n    if (arg_8h == 2) {\n        fcn.0043c2d6();\n        if ((*(in_ECX + 0x130) & 0x40) == 0) {\n            uVar3 = 1;\n            iVar1 = 0;\n            iVar2 = 1;\n            do {\n                if (*(in_ECX + 0x150) <= iVar2) break;\n                iVar1 = fcn.00452c2a(uVar3, iVar2);\n                iVar2 = iVar2 + 1;\n            } while (iVar1 == 0);\n            (****(iVar1 + 0x74))(arg_ch, arg_10h);\n            return;\n        }\n    }\n    else if ((9 < arg_8h) && (arg_8h < 0x12)) {\n        fcn.0043c2d6();\n        uVar3 = 1;\n        iVar1 = 0;\n        iVar2 = 1;\n        do {\n            if (*(in_ECX + 0x150) <= iVar2) break;\n            iVar1 = fcn.00452c2a(uVar3, iVar2);\n            iVar2 = iVar2 + 1;\n        } while (iVar1 == 0);\n        (**(**(iVar1 + 0x74) + 4))(arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    fcn.0045d103(arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 390
    },
    "004532db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004532db(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    if (*(extraout_ECX + 0x80) == 0) {\n        iVar1 = fcn.00438337(0x20);\n        *(unaff_EBP + -0x10) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.004634a1();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x80) = uVar2;\n    }\n    (**(**(extraout_ECX + 0x80) + 0xc))(*(unaff_EBP + 8));\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 283
    },
    "00453395": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00453395(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '0') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x004533ee;\n                if (uVar1 < ':') goto code_r0x004533cc;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x004533cc:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x004533fd;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x004533ee:\n            if ((*(*puVar5 + 0x49f161) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x004533fd:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.00438f78(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.00438fc7(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x0045346b:\n            if ((*(uVar1 + 0x49f161) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '0') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x0045346b;\n            if (uVar2 < ':') goto code_r0x0045343b;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x0045343b:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 886
    },
    "004538e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004538e5(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_OffsetRect;\n    iVar4 = arg_8h - *(in_ECX + 4);\n    iVar2 = arg_ch - *(in_ECX + 8);\n    (*_sym.imp.USER32.dll_OffsetRect)(in_ECX + 0x28, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x48, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x38, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x58, iVar4, iVar2);\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    if (*(in_ECX + 0x80) == 0) {\n        uVar3 = fcn.004540e3();\n    }\n    else {\n        uVar3 = 0;\n    }\n    *(in_ECX + 0x74) = uVar3;\n    fcn.00453f7b(0);\n    return;\n}\n",
        "token_count": 309
    },
    "00453995": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00453995(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    uint arg_ch;\n    uint arg_10h;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    fcn.00453f32();\n    if (*(param_1 + 0x74) == 0) {\n        uVar1 = *(param_1 + 0x78);\n        if ((((uVar1 & 4) == 0) && (((uVar1 & 0xa000) == 0 || (*(param_1 + 0x7c) != 0)))) &&\n           (((uVar1 & 0x5000) == 0 || (*(param_1 + 0x7c) == 0)))) {\n            *(param_1 + 0xa8) = *(param_1 + 0x58);\n            arg_10h = *(param_1 + 0x5c);\n            uVar1 = CONCAT11(0x10, *(param_1 + 0x70) & 0x40);\n            arg_ch = *(param_1 + 0x58);\n            *(param_1 + 0xa4) = uVar1;\n            *(param_1 + 0xac) = arg_10h;\n        }\n        else {\n            *(param_1 + 0xa8) = *(param_1 + 0x48);\n            arg_10h = *(param_1 + 0x4c);\n            uVar1 = CONCAT11(0x20, *(param_1 + 0x70) & 0x40);\n            arg_ch = *(param_1 + 0x48);\n            *(param_1 + 0xa4) = uVar1;\n            *(param_1 + 0xac) = arg_10h;\n        }\n        fcn.0045bf4e(*(param_1 + 0x68), arg_ch, arg_10h, uVar1);\n    }\n    else {\n        var_4h = fcn.004541fa(*(param_1 + 0x74));\n        puVar2 = param_1 + 0x38;\n        if ((*(param_1 + 0x75) & 0x50) == 0) {\n            puVar2 = param_1 + 0x28;\n        }\n        var_14h = *puVar2;\n        uStack20 = puVar2[1];\n        uStack16 = puVar2[2];\n        uStack12 = puVar2[3];\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(var_4h + 0x1c));\n        uVar1 = uVar1 & 0xffff;\n        if ((0xe81a < uVar1) && (uVar1 < 0xe81f)) {\n            *(param_1 + 0x90) = uVar1;\n            *(param_1 + 0x94) = var_14h;\n            *(param_1 + 0x98) = uStack20;\n            *(param_1 + 0x9c) = uStack16;\n            *(param_1 + 0xa0) = uStack12;\n            fcn.00447040(param_1 + 0x94);\n        }\n        fcn.0045be74(*(param_1 + 0x68), var_4h, &var_14h);\n        (**(**(param_1 + 0x6c) + 200))(1);\n    }\n    return;\n}\n",
        "token_count": 809
    },
    "00453f7b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00453f7b(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_24h;\n    int32_t in_ECX;\n    uint *puVar3;\n    uint lprc;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 1;\n    var_10h = 1;\n    uVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0);\n    var_8h = fcn.004478c5(uVar2);\n    var_ch = var_8h;\n    var_4h = fcn.0045c302();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if ((*(in_ECX + 0x74) & 0xa000) == 0) {\n        if ((*(in_ECX + 0x74) & 0x5000) == 0) {\n            var_14h = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x20);\n            var_14h = var_14h + -1;\n            var_10h = (*pcVar1)(0x21);\n            var_10h = var_10h + -1;\n            if ((((*(in_ECX + 0x78) & 0xa000) == 0) || (*(in_ECX + 0x7c) != 0)) &&\n               (((*(in_ECX + 0x78) & 0x5000) == 0 || (*(in_ECX + 0x7c) == 0)))) {\n                puVar3 = in_ECX + 0x58;\n            }\n            else {\n                puVar3 = in_ECX + 0x48;\n            }\n            lprc = *puVar3;\n            uStack36 = puVar3[1];\n            uStack32 = puVar3[2];\n            uStack28 = puVar3[3];\n            var_8h = var_4h;\n            goto code_r0x00454012;\n        }\n        puVar3 = in_ECX + 0x38;\n    }\n    else {\n        puVar3 = in_ECX + 0x28;\n    }\n    lprc = *puVar3;\n    uStack36 = puVar3[1];\n    uStack32 = puVar3[2];\n    uStack28 = puVar3[3];\ncode_r0x00454012:\n    if (arg_8h != 0) {\n        var_10h = 0;\n        var_14h = 0;\n    }\n    if ((*0x49d0e4 != 0) && ((*(in_ECX + 0x75) & 0xf0) != 0)) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 0xffffffff, 0xffffffff);\n    }\n    arg_24h = var_4h;\n    if (*(in_ECX + 0x24) == 0) {\n        arg_24h = var_ch;\n    }\n    fcn.0045c375(&lprc, var_14h, var_10h, in_ECX + 0xc, *(in_ECX + 0x1c), *(in_ECX + 0x20), var_8h, arg_24h);\n    *(in_ECX + 0xc) = lprc;\n    *(in_ECX + 0x1c) = var_14h;\n    *(in_ECX + 0x10) = uStack36;\n    *(in_ECX + 0x14) = uStack32;\n    *(in_ECX + 0x20) = var_10h;\n    *(in_ECX + 0x18) = uStack28;\n    *(in_ECX + 0x24) = var_8h == var_4h;\n    return;\n}\n",
        "token_count": 918
    },
    "00454091": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00454091(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*param_2 != param_3) {\n        *param_2 = param_3;\n        if ((((*(param_1 + 0x70) & 0xa000) == 0) || ((*(param_1 + 0x70) & 0x5000) == 0)) || (*(param_1 + 0x7c) == 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        *(param_1 + 0x7c) = uVar1;\n        if (*(param_1 + 0x80) == 0) {\n            uVar1 = fcn.004540e3();\n        }\n        else {\n            uVar1 = 0;\n        }\n        *(param_1 + 0x74) = uVar1;\n        fcn.00453f7b(0);\n    }\n    return;\n}\n",
        "token_count": 245
    },
    "004540e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004540e3(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    uVar1 = 0;\n    uVar2 = *(param_1 + 0x78) & 0xa000;\n    if (*(param_1 + 0x7c) != 0) {\n        uVar2 = uVar2 == 0;\n    }\n    if ((uVar2 == 0) || ((*(param_1 + 0x70) & 0xa000) == 0)) {\n        if ((*(param_1 + 0x70) & 0x5000) == 0) goto code_r0x0045413e;\n        uVar1 = *(param_1 + 0x70) & 0xffff5fff;\n        puVar3 = param_1 + 0x38;\n    }\n    else {\n        uVar1 = *(param_1 + 0x70) & 0xffffafff;\n        puVar3 = param_1 + 0x28;\n    }\n    uVar1 = fcn.0045c04b(*puVar3, puVar3[1], puVar3[2], puVar3[3], uVar1, 0);\ncode_r0x0045413e:\n    if ((*(param_1 + 0x7c) == 0) && (uVar1 == 0)) {\n        if ((*(param_1 + 0x70) & 0xa000) != 0) {\n            fcn.0045c04b(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), \n                         *(param_1 + 0x70) & 0xffffafff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffffafff;\n            uVar1 = fcn.0045c04b(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n            if (uVar1 != 0) {\n                return uVar1;\n            }\n        }\n        if ((*(param_1 + 0x70) & 0x5000) != 0) {\n            fcn.0045c04b(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), \n                         *(param_1 + 0x70) & 0xffff5fff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffff5fff;\n            uVar1 = fcn.0045c04b(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 763
    },
    "0045435d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0045435d(uint lpAppName, uint lpValueName, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint lpString;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, 0x472d38, arg_10h);\n        uVar1 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, &lpString, *(in_ECX + 0x90))\n        ;\n    }\n    else {\n        uVar1 = fcn.004630a5(lpAppName);\n        if (uVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(uVar1, lpValueName, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uVar1);\n            uVar1 = iVar2 == 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 258
    },
    "004543d2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004543d2(uint lpAppName, int32_t lpValueName, int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, lpString, *(in_ECX + 0x90));\n        return uVar3;\n    }\n    if (lpValueName == 0) {\n        iVar1 = fcn.00463011();\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(iVar1, lpAppName);\n            goto code_r0x00454445;\n        }\n    }\n    else if (lpString == 0) {\n        iVar1 = fcn.004630a5(lpAppName);\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(iVar1, lpValueName);\ncode_r0x00454445:\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            return iVar2 == 0;\n        }\n    }\n    else {\n        iVar1 = fcn.004630a5(lpAppName);\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 1, lpString, iVar2 + 1);\n            goto code_r0x00454445;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 400
    },
    "00454472": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00454472(uint arg_8h, uint arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    char *lpString;\n    uint8_t *puVar3;\n    int32_t in_ECX;\n    char *pcVar4;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        lpString = fcn.00438337(arg_14h * 2 + 1);\n        uVar1 = 0;\n        pcVar4 = lpString;\n        if (arg_14h != 0) {\n            do {\n                puVar3 = arg_10h + uVar1;\n                *pcVar4 = (*puVar3 & 0xf) + 0x41;\n                uVar1 = uVar1 + 1;\n                pcVar4[1] = (*puVar3 >> 4) + 0x41;\n                pcVar4 = pcVar4 + 2;\n            } while (uVar1 < arg_14h);\n        }\n        lpString[uVar1 * 2] = '\\0';\n        uVar1 = fcn.004543d2(arg_8h, arg_ch, lpString);\n        fcn.00438360(lpString);\n    }\n    else {\n        uVar1 = fcn.004630a5(arg_8h);\n        if (uVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(uVar1, arg_ch, 0, 3, arg_10h, arg_14h);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uVar1);\n            uVar1 = iVar2 == 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 419
    },
    "0045499e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0045499e(int32_t param_1)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    puVar3 = *(param_1 + 8);\n    var_4h = param_1;\n    while (puVar3 != NULL) {\n        puVar1 = *puVar3;\n        piVar2 = puVar3[2];\n        var_4h = (**(*piVar2 + 0x54))();\n        while (puVar3 = puVar1,  var_4h != 0) {\n            (**(*piVar2 + 0x58))(&var_4h);\n            iVar4 = iVar4 + 1;\n        }\n    }\n    return iVar4;\n}\n",
        "token_count": 199
    },
    "004587d7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004587d7(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_LocalAlloc)();\n    if (iVar3 == 0) {\n        fcn.0042eb4c();\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_LocalLock)();\n    iVar5 = fcn.004456bd(uVar4, param_3);\n    pcVar2 = _sym.imp.KERNEL32.dll_LocalFree;\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalUnlock;\n    if (iVar5 != param_3) {\n        (*_sym.imp.KERNEL32.dll_LocalUnlock)(iVar3);\n        (*pcVar2)(iVar3);\n        fcn.004464d7(3, 0);\n    }\n    *(param_3 + 1 + unaff_EBP) = 0;\n    if (*0x49d0e0 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowTextA)(*(param_1 + 0x1c), param_3 + 1);\n        (*pcVar1)(iVar3);\n        (*pcVar2)(iVar3);\n        if ((iVar3 == 0) || (iVar3 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(param_1 + 0x1c)),  iVar3 < 2)) {\n            fcn.0042eb4c();\n        }\n        fcn.00438360(*(param_1 + 0x4c));\n        *(param_1 + 0x4c) = 0;\n        *(param_1 + 0x50) = 0;\n        return;\n    }\n    (*pcVar1)(iVar3);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    uVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0xbd, 0, 0);\n    (*pcVar2)(uVar4);\n    (*pcVar1)(*(param_1 + 0x1c), 0xbc, iVar3, 0);\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(param_1 + 0x1c), 0, 1);\n    return;\n}\n",
        "token_count": 551
    },
    "004589bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.004589bd(uint8_t *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, uint8_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int16_t iVar5;\n    int32_t iVar6;\n    uint lptm;\n    int32_t var_24h;\n    \n    iVar4 = arg_8h;\n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(arg_8h + 4), &lptm);\n    pcVar3 = _sym.imp.USER32.dll_GetTabbedTextExtentA;\n    iVar6 = 0;\n    puVar1 = arg_18h + arg_1ch;\n    arg_1ch = arg_18h + arg_20h;\n    arg_8h = puVar1;\n    do {\n        if (arg_1ch <= arg_8h) break;\n        uVar2 = *arg_8h;\n        if (uVar2 == 9) {\n            iVar6 = iVar6 + (arg_14h - iVar6 % arg_14h);\n        }\n        else if ((*0x49d4bc == 0) || ((*(uVar2 + 0x49f161) & 4) == 0)) {\n            iVar6 = iVar6 + *(arg_ch + uVar2 * 4);\n        }\n        else {\n            arg_8h = arg_8h + 1;\n            iVar6 = iVar6 + var_24h;\n        }\n        arg_8h = arg_8h + 1;\n    } while (iVar6 <= arg_10h);\n    iVar5 = (*_sym.imp.USER32.dll_GetTabbedTextExtentA)(*(iVar4 + 8), puVar1, arg_8h - puVar1, 1, &arg_14h);\n    if (arg_10h < iVar5) {\n        do {\n            if (*0x49d4bc == 0) {\n                arg_8h = arg_8h + -1;\n            }\n            else {\n                arg_8h = fcn.0040e12c(puVar1, arg_8h);\n            }\n            iVar5 = (*pcVar3)(*(iVar4 + 8), puVar1, arg_8h - puVar1, 1, &arg_14h);\n        } while (arg_10h < iVar5);\n    }\n    else if ((iVar5 < arg_10h) && (arg_8h < arg_1ch)) {\n        do {\n            arg_8h = fcn.0040e115(arg_8h);\n            iVar5 = (*pcVar3)(*(iVar4 + 8), puVar1, arg_8h - puVar1, 1, &arg_14h);\n            if (arg_10h < iVar5) {\n                if (*0x49d4bc == 0) {\n                    arg_8h = arg_8h + -1;\n                }\n                else {\n                    arg_8h = fcn.0040e12c(puVar1, arg_8h);\n                }\n                break;\n            }\n        } while (arg_8h < arg_1ch);\n    }\n    return arg_8h - arg_18h;\n}\n",
        "token_count": 774
    },
    "004597ce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: wParam\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nbool __cdecl fcn.004597ce(uint lpString, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar2;\n    uint wParam;\n    uint lParam;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0xb0, unaff_EBP + -0x18, unaff_EBP + -0x14);\n    if (iVar1 == *(unaff_EBP + -0x14) - *(unaff_EBP + -0x18)) {\n        *(unaff_EBP + -0x10) = *0x498098;\n        *(unaff_EBP + -4) = 0;\n        fcn.004592d3(unaff_EBP + -0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(*(unaff_EBP + 8), *(unaff_EBP + -0x10));\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)();\n        }\n        bVar2 = iVar1 == 0;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00438b48();\n    }\n    else {\n        bVar2 = false;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return bVar2;\n}\n",
        "token_count": 454
    },
    "00459868": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: wParam\n// WARNING: Variable defined which should be unmapped: var_24h\n\nuint __cdecl fcn.00459868(uint lpString, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint8_t *puVar10;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint8_t *puVar11;\n    int32_t iVar12;\n    uint *in_FS_OFFSET;\n    bool bVar13;\n    uint uStackY96;\n    uint lParam;\n    uint var_24h;\n    uint wParam;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    uVar5 = fcn.004592b5();\n    *(unaff_EBP + -0x1c) = uVar5;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0xb0, unaff_EBP + -0x20, unaff_EBP + -0x28);\n    uVar7 = *(unaff_EBP + -0x20);\n    iVar12 = (-(*(unaff_EBP + 0xc) != 0) & 2) - 1;\n    *(unaff_EBP + -0x24) = iVar12;\n    if ((uVar7 != 0) || (-1 < iVar12)) {\n        fcn.00460591();\n        fcn.004385df();\n        *(unaff_EBP + -4) = 0;\n        iVar6 = fcn.00459205();\n        *(unaff_EBP + -0x10) = iVar6;\n        if (iVar12 < 0) {\n            iVar6 = fcn.0040e12c(iVar6, iVar6 + uVar7);\n            uVar7 = iVar6 - *(unaff_EBP + -0x10);\n        }\n        else if ((*(unaff_EBP + -0x20) != *(unaff_EBP + -0x28)) &&\n                (iVar6 = fcn.004597ce(*(unaff_EBP + 8), *(unaff_EBP + 0x10)),  iVar6 != 0)) {\n            if ((*(*(*(unaff_EBP + -0x10) + uVar7) + 0x49f161) & 4) != 0) {\n                uVar7 = uVar7 + 1;\n            }\n            uVar7 = uVar7 + iVar12;\n        }\n        uVar8 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n        uVar9 = *(unaff_EBP + -0x1c);\n        if ((uVar8 - 1) + uVar7 < uVar9) {\ncode_r0x00459970:\n            puVar10 = *(unaff_EBP + -0x10);\n            puVar11 = puVar10 + uVar7;\n            uVar5 = _sym.imp.KERNEL32.dll_lstrcmpA;\n            if (*(unaff_EBP + 0x10) == 0) {\n                uVar5 = _sym.imp.KERNEL32.dll_lstrcmpiA;\n            }\n            bVar13 = *0x49d4bc == 0;\n            *(unaff_EBP + -0x1c) = uVar5;\n            if (bVar13) {\n                if (iVar12 < 0) {\n                    puVar10 = puVar11 + (1 - puVar10);\n                    *(unaff_EBP + 0xc) = puVar10;\n                }\n                else {\n                    puVar10 = puVar10 + uVar9 + (-uVar8 - puVar11) + 1;\n                    *(unaff_EBP + 0xc) = puVar10;\n                }\n                while (puVar10 != NULL) {\n                    uVar5 = *(unaff_EBP + 8);\n                    uVar3 = puVar11[uVar8];\n                    puVar11[uVar8] = 0;\n                    puVar2 = puVar11 + uVar8;\n                    *(unaff_EBP + 0x13) = uVar3;\n                    iVar12 = (**(unaff_EBP + -0x1c))(puVar11, uVar5);\n                    uVar3 = *(unaff_EBP + 0x13);\n                    *puVar2 = uVar3;\n                    if (iVar12 == 0) {\n                        iVar12 = *(unaff_EBP + -0x14);\n                        fcn.00459293();\n                        iVar6 = puVar11 - *(unaff_EBP + -0x10);\n                        goto code_r0x00459aab;\n                    }\n                    *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + -1;\n                    puVar11 = puVar11 + *(unaff_EBP + -0x24);\n                    puVar10 = *(unaff_EBP + 0xc);\n                    *puVar2 = uVar3;\n                }\n                goto code_r0x00459a6d;\n            }\n            if (iVar12 < 1) {\n                *(unaff_EBP + -0x18) = puVar11;\n            }\n            else {\n                *(unaff_EBP + -0x18) = puVar10 + uVar9 + (1 - uVar8);\n                puVar10 = puVar11;\n            }\n            *(unaff_EBP + -0x24) = 0;\n            for (; puVar10 < *(unaff_EBP + -0x18) || puVar10 == *(unaff_EBP + -0x18); puVar10 = fcn.0040e115(puVar10)) {\n                if (*(unaff_EBP + 0x10) == 0) {\n                    puVar11 = *(unaff_EBP + 8);\ncode_r0x004599dc:\n                    uVar3 = puVar10[uVar8];\n                    puVar10[uVar8] = 0;\n                    *(unaff_EBP + 0xf) = uVar3;\n                    iVar6 = (**(unaff_EBP + -0x1c))(puVar10, puVar11);\n                    puVar10[uVar8] = *(unaff_EBP + 0xf);\n                    if ((iVar6 == 0) && (*(unaff_EBP + -0x24) = puVar10,  0 < iVar12)) break;\n                }\n                else {\n                    puVar11 = *(unaff_EBP + 8);\n                    if ((*puVar10 == *puVar11) && (((*(*puVar10 + 0x49f161) & 4) == 0 || (puVar10[1] == puVar11[1]))))\n                    goto code_r0x004599dc;\n                }\n            }\n            iVar12 = *(unaff_EBP + -0x14);\n            fcn.00459293();\n            if (*(unaff_EBP + -0x24) != 0) {\n                iVar6 = *(unaff_EBP + -0x24) - *(unaff_EBP + -0x10);\ncode_r0x00459aab:\n                pcVar4 = _sym.imp.USER32.dll_SendMessageA;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(iVar12 + 0x1c), 0xb1, iVar6, iVar6 + uVar8);\n                (*pcVar4)(*(iVar12 + 0x1c), 0xb7, 0, 0);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00460591();\n                fcn.004385f4();\n                uStackY96 = 1;\n                goto code_r0x00459a88;\n            }\n        }\n        else {\n            if ((iVar12 < 0) && (uVar8 <= uVar9)) {\n                if (*0x49d4bc == 0) {\n                    uVar7 = uVar9 - uVar8;\n                }\n                else {\n                    uVar7 = uVar9;\n                    if (uVar8 != 0) {\n                        *(unaff_EBP + 0xc) = uVar8;\n                        do {\n                            iVar6 = fcn.0040e12c(*(unaff_EBP + -0x10), *(unaff_EBP + -0x10) + uVar7);\n                            uVar7 = iVar6 - *(unaff_EBP + -0x10);\n                            piVar1 = unaff_EBP + 0xc;\n                            *piVar1 = *piVar1 + -1;\n                        } while (*piVar1 != 0);\n                        uVar9 = *(unaff_EBP + -0x1c);\n                    }\n                }\n                goto code_r0x00459970;\n            }\ncode_r0x00459a6d:\n            fcn.00459293();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00460591();\n        fcn.004385f4();\n    }\n    uStackY96 = 0;\ncode_r0x00459a88:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uStackY96;\n}\n",
        "token_count": 2176
    },
    "0045a147": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0045a19f)\n// WARNING: Removing unreachable block (ram,0x0045a1ab)\n\nvoid fcn.0045a147(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    iVar4 = (*_sym.imp.USER32.dll_GetWindow)(uVar3);\n    pcVar2 = _sym.imp.USER32.dll_ShowWindow;\n    for (; iVar4 != 0; iVar4 = (*pcVar1)(iVar4, 2)) {\n        iVar5 = fcn.0043aafa(iVar4);\n        if ((((iVar5 != 0) && (*0x21 != iVar4)) && (iVar6 = fcn.00459f9c(*0x21, iVar4),  iVar6 != 0)) &&\n           ((uVar7 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar4, 0xfffffff0),  (uVar7 & 0x18000000) == 0 &&\n            ((*(iVar5 + 0x24) & 2) != 0)))) {\n            (*pcVar2)(iVar4, 4);\n            *(iVar5 + 0x24) = *(iVar5 + 0x24) & 0xfffffffd;\n        }\n    }\n    return;\n}\n",
        "token_count": 354
    },
    "0045a33f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0045a33f(int32_t param_1)\n\n{\n    if (*(param_1 + 0x28) == 0) {\n        fcn.0043d76a(8);\n        *(param_1 + 0x28) = \"AfxFrameOrView42s\";\n    }\n    if ((*(param_1 + 0x20) & 0x8000) != 0) {\n        if (*0x49d0e4 == 0) {\n            return 1;\n        }\n        *(param_1 + 0x20) = *(param_1 + 0x20) | 0x4000;\n    }\n    if (*0x49d0e4 != 0) {\n        *(param_1 + 0x2d) = *(param_1 + 0x2d) | 2;\n    }\n    return 1;\n}\n",
        "token_count": 199
    },
    "0045a513": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0045a513(uint arg_8h, uint lpIconName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_58h;\n    uint var_38h;\n    int32_t lpClassName;\n    uint lpWndClass;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar1 = fcn.00460591();\n    iVar1 = (*_sym.imp.USER32.dll_LoadIconA)(*(iVar1 + 0xc), lpIconName);\n    if (iVar1 != 0) {\n        fcn.0040d6f0(&var_58h, 0, 0x30);\n        var_38h = arg_8h;\n        (**(*in_ECX + 0x5c))(&var_58h);\n        if (lpClassName != 0) {\n            iVar2 = fcn.00460591();\n            iVar2 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar2 + 8), lpClassName, &lpWndClass);\n            if ((iVar2 != 0) && (var_14h != iVar1)) {\n                uVar3 = fcn.0043b85d(lpWndClass, var_10h, var_ch, iVar1);\n                return uVar3;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 321
    },
    "0045a75c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0045a75c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if ((param_1[0x27] != NULL) && (iVar1 = (*param_1[0x27])(param_1),  iVar1 == 0)) {\n        return;\n    }\n    piVar2 = (**(*param_1 + 0xbc))();\n    if ((piVar2 != NULL) && (iVar1 = (**(*piVar2 + 0x8c))(param_1),  iVar1 == 0)) {\n        return;\n    }\n    iVar1 = fcn.00460591();\n    piVar3 = *(iVar1 + 4);\n    if ((piVar3 != NULL) && (piVar3[7] == param_1)) {\n        if ((piVar2 == NULL) && (iVar1 = (**(*piVar3 + 0x88))(),  iVar1 == 0)) {\n            return;\n        }\n        fcn.0045318a();\n        fcn.00453256();\n        iVar1 = fcn.0045c13e();\n        if (iVar1 == 0) {\n            fcn.0045c177(0);\n            return;\n        }\n        iVar1 = fcn.00460591();\n        if ((*(iVar1 + 0x14) == '\\0') && (piVar3[7] == 0)) {\n            fcn.0046a1d8(0);\n            return;\n        }\n    }\n    if ((piVar2 != NULL) && (piVar2[0x12] != 0)) {\n        var_4h = (**(*piVar2 + 0x60))();\n        do {\n            if (var_4h == NULL) {\n                (**(*piVar2 + 0x7c))();\n                return;\n            }\n            (**(*piVar2 + 100))(&var_4h);\n            piVar3 = fcn.0043c183();\n        } while (piVar3 == param_1);\n        (**(*piVar2 + 0x94))(param_1);\n    }\n    (**(*param_1 + 0x58))();\n    return;\n}\n",
        "token_count": 523
    },
    "0045aa4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045aa4f(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    fcn.0043aa3a();\n    uVar2 = fcn.00439ecc();\n    piVar5 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        piVar5 = fcn.0043c313();\n    }\n    if (arg_8h != 0) {\n        arg_ch = in_ECX;\n    }\n    if ((piVar5 == arg_ch) ||\n       ((piVar3 = fcn.0043c313(),  piVar5 == piVar3 &&\n        (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(arg_ch[7], 0x36d, 0x40, 0),  iVar4 != 0)))) {\n        bVar1 = true;\n    }\n    else {\n        bVar1 = false;\n    }\n    piVar5[9] = piVar5[9] & 0xffffffdf;\n    if (bVar1) {\n        piVar5[9] = piVar5[9] | 0x20;\n    }\n    fcn.0045a295((-bVar1 & 0xfffffffc) + 8);\n    piVar5 = fcn.0045ae37();\n    if (piVar5 == NULL) {\n        (**(*in_ECX + 0xc0))();\n        piVar5 = fcn.0045ae37();\n        if (piVar5 == NULL) {\n            return;\n        }\n    }\n    if ((arg_8h != 0) && (arg_10h == 0)) {\n        (**(*piVar5 + 0xe4))(1, piVar5, piVar5);\n    }\n    (**(*piVar5 + 0xe8))(arg_8h);\n    return;\n}\n",
        "token_count": 475
    },
    "0045ab5a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045ab5a(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.0043c313();\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    param_2 = param_2 & 0xfff0;\n    if (*(iVar2 + 0x50) == 0) {\ncode_r0x0045abe3:\n        fcn.0043aa3a();\n    }\n    else {\n        if (param_2 < 0xf041) {\n            if (((param_2 != 0xf040) && (param_2 != 0xf000)) && (param_2 != 0xf010)) {\n                iVar2 = param_2 - 0xf020;\ncode_r0x0045aba4:\n                if ((iVar2 != 0) && (iVar2 != 0x10)) goto code_r0x0045abe3;\n            }\n        }\n        else if ((param_2 != 0xf050) && (param_2 != 0xf060)) {\n            iVar2 = param_2 - 0xf120;\n            goto code_r0x0045aba4;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x365, 0, (param_2 - 0xf000 >> 4) + 0x1ef00);\n        if (iVar2 == 0) {\n            (*pcVar1)(*(param_1 + 0x1c), 0x111, 0xe147, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 381
    },
    "0045acbe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0045acbe(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int16_t iVar5;\n    uint var_108h;\n    int32_t var_4h;\n    \n    uVar4 = fcn.00460591();\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalGetAtomNameA;\n    iVar1 = *(uVar4 + 4);\n    if ((((iVar1 != 0) && (arg_ch != 0)) && (iVar5 = arg_ch >> 0x10,  iVar5 != 0)) &&\n       ((arg_ch == *(iVar1 + 0xb0) && (iVar5 == *(iVar1 + 0xb2))))) {\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(uVar4 & 0xffff0000 | *(iVar1 + 0xb0), &var_108h, 0x103);\n        pcVar3 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&var_108h);\n        (*pcVar2)(&var_108h & 0xffff0000 | *(iVar1 + 0xb2), &var_108h, 0x103);\n        (*pcVar3)(&var_108h);\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x3e4, *(var_4h + 0x1c), *(iVar1 + 0xb0));\n    }\n    return 0;\n}\n",
        "token_count": 370
    },
    "0045ae3e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045ae3e(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *(param_1 + 0x98);\n    if (param_2 != piVar1) {\n        *(param_1 + 0x98) = 0;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0xe4))(0, param_2, piVar1);\n        }\n        if (((*(param_1 + 0x98) == 0) && (*(param_1 + 0x98) = param_2,  param_2 != NULL)) && (param_3 != 0)) {\n            (**(*param_2 + 0xe4))(1, param_2, piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "0045aec3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045aec3(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    piVar1 = fcn.0045bd43();\n    if (arg_10h == 0) {\n        fcn.0043a058(0, 0, 0, 0, 0, (-(arg_ch != 0) & 0xffffffc0) + 0x80 | 0x17);\n        (**(*arg_8h + 0xc4))(arg_ch);\n        if ((arg_ch != 0) || (iVar2 = fcn.0045bd54(),  iVar2 == 0)) {\n            (**(*piVar1 + 200))(0);\n        }\n    }\n    else {\n        (**(*arg_8h + 0xc4))(arg_ch);\n        piVar1[0x2e] = piVar1[0x2e] | 0xc;\n    }\n    iVar2 = fcn.0045bd54();\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_8h[0x1c] == NULL) {\n        uVar3 = arg_ch != 0;\n    }\n    else {\n        uVar3 = (**(*arg_8h[0x1c] + 0xe0))();\n    }\n    if (uVar3 == 1) {\n        if (arg_ch != 0) {\n            piVar1[0x22] = -1;\n            if (arg_10h == 0) {\n                uVar4 = 8;\n                goto code_r0x0045af81;\n            }\n            piVar1[0x22] = 8;\n            goto code_r0x0045afac;\n        }\n    }\n    else if (uVar3 == 0) {\n        piVar1[0x22] = -1;\n        if (arg_10h != 0) {\n            piVar1[0x22] = 0;\n            return;\n        }\n        uVar4 = 0;\ncode_r0x0045af81:\n        fcn.0043a0a7(uVar4);\n        return;\n    }\n    if (arg_10h != 0) {\n        return;\n    }\ncode_r0x0045afac:\n    (**(*piVar1 + 200))(0);\n    return;\n}\n",
        "token_count": 562
    },
    "0045afdc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045afdc(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t in_ECX;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00447d08(*(in_ECX + 0x1c));\n    if ((arg_10h == 0) &&\n       ((*(in_ECX + 0x68) == NULL || (iVar2 = (**(**(in_ECX + 0x68) + 0x74))(arg_8h, arg_ch, 0),  iVar2 == 0)))) {\n        fcn.00438691();\n        iVar2 = fcn.00460301();\n        pcVar1 = _sym.imp.USER32.dll_GetMenu;\n        if ((*(iVar2 + 0x54) != *(arg_8h + 4)) &&\n           (((iVar2 = (*_sym.imp.USER32.dll_GetMenu)(*(in_ECX + 0x1c)),  iVar2 != 0 &&\n             (iVar2 = fcn.0043c206(),  iVar2 != 0)) && (iVar2 = (*pcVar1)(*(iVar2 + 0x1c)),  iVar2 != 0)))) {\n            iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar2);\n            iVar8 = 0;\n            if (0 < iVar3) {\n                do {\n                    iVar9 = iVar8;\n                    iVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(iVar2, iVar8);\n                    if (iVar4 == *(arg_8h + 4)) {\n                        fcn.00440612(iVar9, iVar2);\n                        break;\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < iVar3);\n            }\n        }\n        var_ch = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n        pcVar1 = _sym.imp.USER32.dll_GetMenuItemID;\n        var_24h = 0;\n        if (var_ch != 0) {\n            do {\n                var_28h = (*pcVar1)(*(arg_8h + 4), var_24h);\n                uVar6 = var_ch;\n                if (var_28h != 0) {\n                    if (var_28h == 0xffffffff) {\n                        uVar5 = (*_sym.imp.USER32.dll_GetSubMenu)(*(arg_8h + 4), var_24h);\n                        iVar2 = fcn.00440612(uVar5);\n                        if (((iVar2 == 0) || (var_28h = (*pcVar1)(*(iVar2 + 4), 0),  var_28h == 0)) ||\n                           (var_28h == 0xffffffff)) goto code_r0x0045b147;\n                        uVar5 = 0;\n                    }\n                    else if ((*(in_ECX + 0x3c) == 0) || (0xefff < var_28h)) {\n                        uVar5 = 0;\n                    }\n                    else {\n                        uVar5 = 1;\n                    }\n                    fcn.00438856(in_ECX, uVar5);\n                    uVar6 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n                    if (uVar6 < var_ch) {\n                        var_24h = var_24h + (uVar6 - var_ch);\n                        while ((var_24h < uVar6 && (uVar7 = (*pcVar1)(*(arg_8h + 4), var_24h),  uVar7 == var_28h))) {\n                            var_24h = var_24h + 1;\n                        }\n                    }\n                }\ncode_r0x0045b147:\n                var_ch = uVar6;\n                var_24h = var_24h + 1;\n            } while (var_24h < var_ch);\n        }\n    }\n    return;\n}\n",
        "token_count": 989
    },
    "0045b15d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045b15d(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.0043c313();\n    if ((in_ECX[0x1a] != NULL) && (iVar2 = (**(*in_ECX[0x1a] + 0x7c))(arg_8h, arg_ch, arg_10h),  iVar2 != 0)) {\n        return;\n    }\n    if (arg_ch == 0xffff) {\n        in_ECX[9] = in_ECX[9] & 0xffffffbf;\n        if (*(iVar1 + 0x50) == 0) {\n            in_ECX[0x24] = 0xe001;\n        }\n        else {\n            in_ECX[0x24] = 0xe002;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[7], 0x362, in_ECX[0x24], 0);\n        iVar1 = (**(*in_ECX + 0xd4))();\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar1 + 0x1c));\n        }\n        goto code_r0x0045b234;\n    }\n    if ((arg_8h == 0) || ((arg_ch & 0x810) != 0)) {\n        in_ECX[0x24] = 0;\n    }\n    else {\n        if ((arg_8h < 0xf000) || (0xf1ef < arg_8h)) {\n            if (0xfeff < arg_8h) {\n                in_ECX[0x24] = 0xef1f;\n                goto code_r0x0045b230;\n            }\n        }\n        else {\n            arg_8h = (arg_8h - 0xf000 >> 4) + 0xef00;\n        }\n        in_ECX[0x24] = arg_8h;\n    }\ncode_r0x0045b230:\n    *(iVar1 + 0x24) = *(iVar1 + 0x24) | 0x40;\ncode_r0x0045b234:\n    if (in_ECX[0x24] != in_ECX[0x25]) {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        iVar1 = fcn.0043aad3(uVar3);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_PostMessageA)(in_ECX[7], 0x36a, 0, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 630
    },
    "0045b40f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid fcn.0045b40f(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_24h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    fcn.00434dce(10);\n    puVar4 = *(extraout_ECX + 0x70);\n    *(unaff_EBP + -4) = 0;\n    while (puVar4 != NULL) {\n        puVar1 = *puVar4;\n        iVar2 = (**(*puVar4[2] + 0xd0))();\n        puVar4 = puVar1;\n        if (iVar2 != 0) {\n            fcn.00434ef1();\n        }\n    }\n    puVar4 = *(unaff_EBP + -0x24);\n    while (puVar4 != NULL) {\n        puVar1 = *puVar4;\n        if (puVar4[2][0x1e] == 0) {\n            (**(*puVar4[2] + 0x58))();\n            puVar4 = puVar1;\n        }\n        else {\n            piVar3 = fcn.0043c183();\n            (**(*piVar3 + 0x58))();\n            puVar4 = puVar1;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00434e2d();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 401
    },
    "0045b49a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0045b49a(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (param_2 == 0) {\ncode_r0x0045b4c7:\n        iVar3 = 0;\n    }\n    else {\n        puVar4 = *(param_1 + 0x70);\n        do {\n            if (puVar4 == NULL) goto code_r0x0045b4c7;\n            puVar1 = *puVar4;\n            iVar3 = puVar4[2];\n            uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar3 + 0x1c));\n            puVar4 = puVar1;\n        } while ((uVar2 & 0xffff) != param_2);\n    }\n    return iVar3;\n}\n",
        "token_count": 214
    },
    "0045b6e7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045b6e7(int32_t lpString2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint lpString1;\n    \n    uVar2 = fcn.00439ecc();\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n    if ((uVar2 & 0x4000) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, *(in_ECX + 0xac));\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n        if (lpString2 != 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcatA)(&lpString1, 0x4734e0);\n            (*pcVar1)(&lpString1, lpString2);\n            if (0 < *(in_ECX + 0x40)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString1, 0x4734e4, *(in_ECX + 0x40));\n                (*_sym.imp.USER32.dll_wsprintfA)(&lpString1 + iVar3);\n            }\n        }\n    }\n    else {\n        lpString1._0_1_ = 0;\n        if (lpString2 != 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, lpString2);\n            if (0 < *(in_ECX + 0x40)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString1, 0x4734e4, *(in_ECX + 0x40));\n                (*_sym.imp.USER32.dll_wsprintfA)(&lpString1 + iVar3);\n            }\n            (*pcVar1)(&lpString1, 0x4734e0);\n        }\n        (*pcVar1)(&lpString1, *(in_ECX + 0xac));\n    }\n    fcn.00447c97(*(in_ECX + 0x1c), &lpString1);\n    return;\n}\n",
        "token_count": 480
    },
    "0045bd54": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0045bd54(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_1 + 0xd0))();\n    if (iVar1 != 0) {\n        return param_1[0x1e];\n    }\n    if ((param_1[0x1c] != 0) && (*(param_1[0x1c] + 0x78) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 120
    },
    "0045bf4e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045bf4e(int32_t arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uint var_4h;\n    \n    if ((((*(arg_8h + 0x6c) == 0) || (iVar1 = *(arg_8h + 0x70),  iVar1 == 0)) || (*(iVar1 + 0x78) == 0)) ||\n       ((iVar2 = fcn.0045200b(),  iVar2 != 1 || ((*(iVar1 + 100) & arg_14h & 0xf000) == 0)))) {\n        uVar5 = arg_14h;\n        if (((*(arg_8h + 100) & 4) != 0) && (uVar5 = arg_14h | 4,  (arg_14h & 0x5000) != 0)) {\n            uVar5 = arg_14h & 0xffff2fff | 0x2004;\n        }\n        arg_14h = uVar5;\n        piVar4 = fcn.0045bd7e(arg_14h);\n        fcn.0043a058(0, arg_ch, arg_10h, 0, 0, 0x15);\n        if (piVar4[8] == 0) {\n            piVar4[8] = *(arg_8h + 0x1c);\n        }\n        fcn.00439ccb(0xe81f);\n        fcn.00452073(arg_8h, 0);\n        (**(*piVar4 + 200))(1);\n        uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_8h + 0x1c), 0xfffffff0);\n        if ((uVar5 & 0x10000000) == 0) {\n            return;\n        }\n        fcn.0043a0a7(8);\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar1 + 0x1c));\n        piVar4 = fcn.0043aad3(uVar3);\n        fcn.0043a058(0, arg_ch, arg_10h, 0, 0, 0x15);\n        (**(*piVar4 + 200))(1);\n    }\n    (*_sym.imp.USER32.dll_UpdateWindow)(piVar4[7]);\n    return;\n}\n",
        "token_count": 588
    },
    "0045c04b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.0045c04b(uint lprcSrc2, uint noname_1, uint noname_2, uint noname_3, uint32_t arg_18h, int32_t **arg_1ch)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    int32_t lprcSrc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar3 = arg_1ch;\n    arg_18h = arg_18h & 0xf040;\n    if (arg_1ch != NULL) {\n        *arg_1ch = NULL;\n    }\n    puVar5 = *(in_ECX + 0x70);\n    do {\n        do {\n            if (puVar5 == NULL) {\n                return 0;\n            }\n            puVar1 = *puVar5;\n            piVar2 = puVar5[2];\n            iVar4 = (**(*piVar2 + 0xd0))();\n            puVar5 = puVar1;\n        } while ((((iVar4 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowVisible)(piVar2[7]),  iVar4 == 0)) ||\n                 ((piVar2[0x19] & arg_18h & 0xf000) == 0)) ||\n                ((piVar2[0x1e] != 0 && ((piVar2[0x19] & arg_18h & 0x40) == 0))));\n        (*_sym.imp.USER32.dll_GetWindowRect)(piVar2[7], &lprcSrc1);\n        if (var_8h == lprcSrc1) {\n            var_8h = var_8h + 1;\n        }\n        if (var_4h == var_ch) {\n            var_4h = var_4h + 1;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcSrc1, &lprcSrc1, &lprcSrc2);\n    } while (iVar4 == 0);\n    if (ppiVar3 != NULL) {\n        *ppiVar3 = piVar2;\n    }\n    return piVar2[0x19] & arg_18h;\n}\n",
        "token_count": 547
    },
    "0045c1b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045c1b0(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x49d0a4;\n    uVar3 = *0x49d0a0;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.004475c9(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, 0x9ec, uVar3);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], 0x9ec, uVar4);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 360
    },
    "0045c23e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045c23e(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x49d0a4;\n    uVar3 = *0x49d0a0;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.00447560(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, uVar3, 0x9ec);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], uVar4, 0x9ec);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 358
    },
    "0045cd9e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0045cd9e(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    uint uVar4;\n    \n    if (*0x49d0ec == 0) {\n        uVar2 = fcn.00439ecc();\n        pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n        if ((uVar2 & 0x40600) == 0) {\n            iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(6);\n            uVar4 = 5;\n        }\n        else {\n            iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n            uVar4 = 0x20;\n        }\n        iVar3 = (*pcVar1)(uVar4, -iVar3);\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_retaddr, -iVar3);\n        if ((uVar2 & 0xc00000) != 0) {\n            *(unaff_retaddr + 4) = *(unaff_retaddr + 4) + *0x49d514;\n        }\n    }\n    else {\n        fcn.0043aa3a();\n    }\n    return;\n}\n",
        "token_count": 278
    },
    "0045ce04": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0045ce04(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t in_ECX;\n    int32_t lprcSrc;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint lprcDst;\n    int32_t lpRect;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t dx;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dy;\n    uint32_t var_4h;\n    \n    var_4h = fcn.00439ecc();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n    dy = iVar4;\n    dx = (*pcVar2)(0x20);\n    pcVar1 = _sym.imp.USER32.dll_PtInRect;\n    if (*0x49d0ec == 0) {\n        iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, arg_8h, arg_ch);\n        if (iVar4 == 0) {\n            return 0;\n        }\n        iVar4 = (*pcVar2)(6);\n        var_10h = iVar4;\n        iVar6 = (*pcVar2)(5);\n        var_68h = var_24h;\n        lprcSrc = lpRect;\n        var_60h = var_1ch;\n        var_64h = var_20h;\n        fcn.0045cd9e(0, &lprcSrc);\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        iVar7 = (*pcVar1)(&lprcDst, arg_8h, arg_ch);\n        if (iVar7 != 0) {\n            return 1;\n        }\n        if ((var_4h & 0x40600) == 0) {\ncode_r0x0045d0c1:\n            var_1ch = iVar4 + *0x49d514 + var_24h;\n            iVar4 = (*pcVar1)(&lpRect, arg_8h, arg_ch);\n            if (iVar4 == 0) {\n                return 0xfffffffe;\n            }\n            if ((arg_8h < *0x49d510 + -2 + lpRect) && ((var_4h & 0x80000) != 0)) {\n                return 3;\n            }\n        }\n        else {\n            iVar6 = *0x49d510 + iVar6 * -3 + dx;\n            iVar4 = dy + iVar4 * -2 + *0x49d514;\n            if (arg_ch < var_24h + dy) {\n                if ((var_4h & 0x200) == 0) {\n                    if (lpRect + iVar6 < arg_8h) {\n                        uVar5 = ((arg_8h < var_20h - iVar6) - 1 & 2) + 0xc;\n                    }\n                    else {\ncode_r0x0045cfdf:\n                        uVar5 = 0xd;\n                    }\n                }\n                else {\n                    uVar5 = 0xc;\n                }\n            }\n            else if (arg_ch < var_1ch - dy) {\n                if (arg_8h < lpRect + dx) {\n                    if ((var_4h & 0x200) == 0) {\n                        if (arg_ch <= var_24h + iVar4) goto code_r0x0045cfdf;\n                        uVar5 = ((arg_ch < var_1ch - iVar4) - 1 & 6) + 10;\n                    }\n                    else {\n                        uVar5 = 10;\n                    }\n                }\n                else {\n                    if (arg_8h < var_20h - dx) {\n                        (*_sym.imp.USER32.dll_InflateRect)(&lpRect, -dx, -dy);\n                        iVar4 = var_10h;\n                        goto code_r0x0045d0c1;\n                    }\n                    if ((var_4h & 0x200) == 0) {\n                        if (var_24h + iVar4 < arg_ch) {\n                            uVar5 = ((arg_ch < var_1ch - iVar4) - 1 & 6) + 0xb;\n                        }\n                        else {\n                            uVar5 = 0xe;\n                        }\n                    }\n                    else {\n                        uVar5 = 0xb;\n                    }\n                }\n            }\n            else if ((var_4h & 0x200) == 0) {\n                if (lpRect + iVar6 < arg_8h) {\n                    uVar5 = ((arg_8h < var_20h - iVar6) - 1 & 2) + 0xf;\n                }\n                else {\n                    uVar5 = 0x10;\n                }\n            }\n            else {\n                uVar5 = 0xf;\n            }\n            if ((var_4h & 0x800) == 0) {\n                return uVar5;\n            }\n        }\n        return 2;\n    }\n    uVar5 = fcn.0043aa3a();\n    if ((*0x49d0e4 != 0) && ((var_4h & 0x1000) != 0)) {\n        if (uVar5 == 3) {\n            uVar5 = 2;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(2);\n        if (iVar3 < 0) {\n            return 0;\n        }\n    }\n    if (((uVar5 < 10) || (0x11 < uVar5)) && (uVar5 != 4)) {\n        return uVar5;\n    }\n    if ((var_4h & 0x800) != 0) {\n        return 2;\n    }\n    (*_sym.imp.USER32.dll_InflateRect)(&lpRect, -dx, -iVar4);\n    if ((var_4h & 0x200) == 0) {\n        return uVar5;\n    }\n    if (uVar5 == 4) {\ncode_r0x0045cf02:\n        uVar5 = (arg_ch <= var_1ch) - 1 & 4;\ncode_r0x0045cf11:\n        uVar5 = uVar5 + 0xb;\n    }\n    else {\n        if (uVar5 == 0xd) {\n            uVar5 = (var_24h <= arg_ch) - 1 & 2;\n        }\n        else {\n            if (uVar5 == 0xe) {\n                uVar5 = arg_ch < var_24h;\n                goto code_r0x0045cf11;\n            }\n            if (uVar5 != 0x10) {\n                if (uVar5 != 0x11) {\n                    return uVar5;\n                }\n                goto code_r0x0045cf02;\n            }\n            uVar5 = (arg_ch <= var_1ch) - 1 & 5;\n        }\n        uVar5 = uVar5 + 10;\n    }\n    return uVar5;\n}\n",
        "token_count": 1683
    },
    "0045d103": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045d103(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((*0x49d0ec == 0) && (param_2 == 3)) {\n        *(param_1 + 0xbc) = 1;\n        *(param_1 + 0xc0) = 1;\n        uVar1 = (*_sym.imp.USER32.dll_SetCapture)(*(param_1 + 0x1c));\n        fcn.0043aad3(uVar1);\n        fcn.0045d22f();\n    }\n    else {\n        fcn.0043aa3a();\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "0045d9ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045d9ae(int32_t lpRect, uint32_t dwStyle)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (*0x49d0ec == 0) {\n        if ((dwStyle & 0x40600) == 0) {\n            uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(6);\n            uVar3 = 5;\n        }\n        else {\n            uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n            uVar3 = 0x20;\n        }\n        uVar2 = (*pcVar1)(uVar3, uVar2);\n        (*_sym.imp.USER32.dll_InflateRect)(lpRect, uVar2);\n        if ((dwStyle & 0xc00000) != 0) {\n            fcn.0045c9fb();\n            *(lpRect + 4) = *(lpRect + 4) - *0x49d514;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_AdjustWindowRectEx)(lpRect, dwStyle, 0, 0x188);\n    }\n    return;\n}\n",
        "token_count": 282
    },
    "0046042f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0046042f(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 0xc);\n    while (iVar1 != 0) {\n        fcn.00436dc3();\n        if (var_8h != arg_8h) {\n            fcn.00438360(var_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 123
    },
    "004604ad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004604ad(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    code *pcVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_THREAD_STATE.0;\n    puVar1 = extraout_ECX[5];\n    *(unaff_EBP + -4) = 0;\n    if (puVar1 != NULL) {\n        (***puVar1)(1);\n    }\n    if (extraout_ECX[6] != NULL) {\n        (***extraout_ECX[6])(1);\n    }\n    if (extraout_ECX[7] != NULL) {\n        (***extraout_ECX[7])(1);\n    }\n    if (extraout_ECX[8] != NULL) {\n        (***extraout_ECX[8])(1);\n    }\n    if (extraout_ECX[9] != NULL) {\n        (***extraout_ECX[9])(1);\n    }\n    pcVar3 = extraout_ECX[0xe];\n    if (pcVar3 != NULL) {\n        while (*(pcVar3 + 0xc) != 0) {\n            uVar2 = fcn.00434f63();\n            fcn.00438360(uVar2);\n            pcVar3 = extraout_ECX[0xe];\n        }\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        (**(*extraout_ECX[0xc] + 4))(1);\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (**(*extraout_ECX[0xd] + 4))(1);\n    }\n    if (extraout_ECX[0xe] != NULL) {\n        (**(*extraout_ECX[0xe] + 4))(1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 510
    },
    "00462bd7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00462bd7(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00461235": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00461235(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t *arg_8h_00;\n    uint16_t *puVar4;\n    uint32_t *puVar5;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar2 = fcn.00460591();\n    uVar1 = *(iVar2 + 0xc);\n    iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, arg_8h, 0xf1);\n    if (((iVar2 == 0) || (iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, iVar2),  iVar2 == 0)) ||\n       (iVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2),  iVar2 == 0)) {\n        iVar3 = 0;\n    }\n    else {\n        arg_8h_00 = fcn.00438337(*(iVar2 + 6) << 2);\n        var_4h = 0;\n        if (*(iVar2 + 6) != 0) {\n            puVar4 = iVar2 + 8;\n            puVar5 = arg_8h_00;\n            do {\n                var_4h = var_4h + 1;\n                *puVar5 = *puVar4;\n                puVar5 = puVar5 + 1;\n                puVar4 = puVar4 + 1;\n            } while (var_4h < *(iVar2 + 6));\n        }\n        iVar3 = fcn.004613f9(arg_8h_00, *(iVar2 + 6));\n        fcn.00438360(arg_8h_00);\n        if (iVar3 != 0) {\n            fcn.0046114b(*(iVar2 + 2) + 7, *(iVar2 + 4) + 7, *(iVar2 + 2), *(iVar2 + 4));\n            iVar3 = fcn.004612f9(arg_8h);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 480
    },
    "0046158f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0046158f(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    unkuint3 Var2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    \n    iVar3 = fcn.0043b121(param_2);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    *(param_2 + 0x23) = *(param_2 + 0x23) | 4;\n    if (*0x49d0e4 == 0) {\n        return 1;\n    }\n    uVar1 = *(param_1 + 100);\n    if ((uVar1 & 0x80) != 0) {\n        return 1;\n    }\n    uVar4 = uVar1 & 0xff00;\n    if (uVar4 != 0x1400) {\n        if (uVar4 == 0x2800) {\n            Var2 = 2;\n            goto code_r0x004615f0;\n        }\n        if (uVar4 != 0x4100) {\n            if (uVar4 != 0x8200) {\n                return 1;\n            }\n            Var2 = 8;\n            goto code_r0x004615f0;\n        }\n    }\n    Var2 = 10;\ncode_r0x004615f0:\n    *(param_1 + 100) = uVar1 & 0xff | (uVar1 >> 8 & 0xfffff0 | Var2) << 8 | 0x80;\n    return 1;\n}\n",
        "token_count": 360
    },
    "0046181b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0046181b(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    if (*(unaff_EBP + 8) != 0) {\n        iVar2 = fcn.00438337(0x20);\n        *(unaff_EBP + -0x10) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            piVar3 = NULL;\n        }\n        else {\n            piVar3 = fcn.00440789(0, \"Recent File List\", \"File%d\", *(unaff_EBP + 8), 0x1e);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0xa8) = piVar3;\n        (**(*piVar3 + 0xc))();\n    }\n    uVar4 = fcn.004630eb(\"Settings\", \"PreviewPages\", 0);\n    uVar1 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 0xb4) = uVar4;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 382
    },
    "00461a83": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00461a83(int32_t param_1, uint param_2)\n\n{\n    if ((*(*(param_1 + 0x14) + -8) == 0) ||\n       ((*(param_1 + 0x10) == 3 &&\n        (((*(*(param_1 + 0x18) + -8) == 0 || (*(*(param_1 + 0x1c) + -8) == 0)) || (*(*(param_1 + 0x20) + -8) == 0))))))\n    {\n        fcn.00438cd1(param_2);\n    }\n    return;\n}\n",
        "token_count": 145
    },
    "004621b2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004621b2(void)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (*0x49d0e4 != 0) {\n        *0x49d088 = (*_sym.imp.USER32.dll_GetSystemMetrics)(2);\n        *0x49d088 = *0x49d088 + 1;\n        *0x49d08c = (*pcVar1)(3);\n        *0x49d08c = *0x49d08c + 1;\n        *0x49d0f0 = 1;\n    }\n    return;\n}\n",
        "token_count": 144
    },
    "004624ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "get OS version"
        ],
        "decompiled_code": "\nint32_t fcn.004624ca(void)\n\n{\n    uint32_t uVar1;\n    \n    if (*0x49d47c == 0) {\n        *0x49d47c = 1;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if ((uVar1 < 4) && ((uVar1 & 0x80000000) != 0)) {\n            *0x49d478 = 1;\n        }\n        else {\n            *0x49d478 = 0;\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x49d2c8);\n        }\n    }\n    return *0x49d47c;\n}\n",
        "token_count": 155
    },
    "0046250f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0046250f(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_DeleteCriticalSection;\n    if ((*0x49d47c != 0) && (*0x49d47c = *0x49d47c + -1,  *0x49d478 == 0)) {\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(0x49d2c8);\n        piVar3 = 0x49d280;\n        iVar2 = 0x49d2e0;\n        do {\n            if (*piVar3 != 0) {\n                (*pcVar1)(iVar2);\n                *piVar3 = *piVar3 + -1;\n            }\n            iVar2 = iVar2 + 0x18;\n            piVar3 = piVar3 + 1;\n        } while (iVar2 < 0x49d478);\n    }\n    return;\n}\n",
        "token_count": 224
    },
    "0046255d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0046255d(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x49d47c == 0) {\n        fcn.004624ca();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    if (*0x49d478 == 0) {\n        piVar1 = param_1 * 4 + 0x49d280;\n        if (*(param_1 * 4 + 0x49d280) == 0) {\n            (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x49d2c8);\n            if (*piVar1 == 0) {\n                (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x49d2e0);\n                *piVar1 = *piVar1 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x49d2c8);\n        }\n        (*pcVar2)(param_1 * 0x18 + 0x49d2e0);\n    }\n    return;\n}\n",
        "token_count": 258
    },
    "004625cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004625cd(int32_t param_1)\n\n{\n    if (*0x49d478 == 0) {\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 * 0x18 + 0x49d2e0);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00462665": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00462665(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 49
    },
    "00462881": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00462881(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code **ppcVar1;\n    code *pcVar2;\n    uint *in_ECX;\n    code **ppcVar3;\n    uint var_4h;\n    \n    ppcVar1 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX);\n    if (ppcVar1 == NULL) {\n        ppcVar1 = fcn.00462647(0x10);\n        if (ppcVar1 == NULL) {\n            ppcVar1 = NULL;\n        }\n        else {\n            *ppcVar1 = vtable.CThreadData.0;\n        }\n        ppcVar1[2] = NULL;\n        ppcVar1[3] = NULL;\n        ppcVar3 = ppcVar1 + 2;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n        fcn.004625ee(ppcVar1);\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    }\n    else {\n        ppcVar3 = ppcVar1 + 2;\n        if ((arg_8h < *ppcVar3) || (arg_ch == 0)) goto code_r0x00462958;\n    }\n    if (ppcVar1[3] == NULL) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, in_ECX[3] << 2);\n    }\n    else {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(ppcVar1[3], in_ECX[3] << 2, 2);\n    }\n    ppcVar1[3] = pcVar2;\n    if (pcVar2 == NULL) {\n        fcn.0042eb4c();\n    }\n    fcn.0040d6f0(ppcVar1[3] + *ppcVar3 * 4, 0, (*ppcVar3 * 0x3fffffff + in_ECX[3]) * 4);\n    *ppcVar3 = in_ECX[3];\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, ppcVar1);\ncode_r0x00462958:\n    *(ppcVar1[3] + arg_8h * 4) = arg_ch;\n    return;\n}\n",
        "token_count": 535
    },
    "004629c8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004629c8(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.00462601(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    if (arg_8h != NULL) {\n        (***arg_8h)(1);\n    }\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 373
    },
    "00462a61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00462a61(uint *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if (param_2 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if (iVar2 != 0) {\n            fcn.004629c8(iVar2, unaff_retaddr);\n        }\n    }\n    else {\n        iVar2 = param_1[5];\n        while (iVar2 != 0) {\n            iVar1 = *(iVar2 + 4);\n            fcn.004629c8(iVar2, param_3);\n            iVar2 = iVar1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 219
    },
    "00462aba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00462ae1)\n\nint32_t __fastcall fcn.00462aba(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    code *unaff_retaddr;\n    \n    if (*param_1 == 0) {\n        if (*0x49d484 == NULL) {\n            *0x49d484 = fcn.00462679();\n        }\n        iVar1 = fcn.00462712();\n        *param_1 = iVar1;\n    }\n    iVar1 = *param_1;\n    iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(**0x49d484);\n    if ((iVar2 == 0) || (*(iVar2 + 8) <= iVar1)) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = *(*(iVar2 + 0xc) + iVar1 * 4);\n    }\n    if (iVar1 == 0) {\n        iVar1 = (*unaff_retaddr)();\n        fcn.00462881(*param_1, iVar1);\n    }\n    return iVar1;\n}\n",
        "token_count": 253
    },
    "004630eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004630eb(uint lpAppName, uint lpValueName, int32_t nDefault)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        nDefault = (*_sym.imp.KERNEL32.dll_GetPrivateProfileIntA)(lpAppName, lpValueName, nDefault, *(in_ECX + 0x90));\n    }\n    else {\n        var_4h = in_ECX;\n        iVar1 = fcn.004630a5(lpAppName);\n        if (iVar1 != 0) {\n            lpAppName = 4;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(iVar1, lpValueName, 0, &var_8h, &var_4h, &lpAppName);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            if (iVar2 == 0) {\n                return var_4h;\n            }\n        }\n    }\n    return nDefault;\n}\n",
        "token_count": 260
    },
    "00463420": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00463420(uint phkResult, uint lpString, int32_t lpValueName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    bool bVar4;\n    \n    if (lpValueName == 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)(0x80000000, phkResult, 1, lpString, uVar1);\n        bVar4 = iVar2 == 0;\n    }\n    else {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(0x80000000, phkResult, &phkResult);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(phkResult, lpValueName, 0, 1, lpString, iVar2 + 1);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n            if ((iVar3 == 0) && (iVar2 == 0)) {\n                return true;\n            }\n        }\n        bVar4 = false;\n    }\n    return bVar4;\n}\n",
        "token_count": 304
    },
    "0046216b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid fcn.0046216b(void)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar5 = *0x498098;\n    *(unaff_EBP + -0x20) = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = uVar5;\n    *(unaff_EBP + -4) = 1;\n    iVar4 = fcn.00460591();\n    fcn.0043f227(*(iVar4 + 8), unaff_EBP + -0x20);\n    puVar3 = *(extraout_ECX + 8);\n    uVar5 = *0x498098;\n    while (*0x498098 = uVar5,  puVar3 != NULL) {\n        puVar1 = *puVar3;\n        piVar2 = puVar3[2];\n        *(unaff_EBP + -0x18) = uVar5;\n        *(unaff_EBP + -0x14) = uVar5;\n        *(unaff_EBP + -0x1c) = uVar5;\n        iVar4 = *piVar2;\n        *(unaff_EBP + -4) = 4;\n        iVar4 = (**(iVar4 + 100))(unaff_EBP + -0x14, 5);\n        if ((iVar4 != 0) && (*(*(unaff_EBP + -0x14) + -8) != 0)) {\n            iVar4 = (**(*piVar2 + 100))(unaff_EBP + -0x1c, 6);\n            if (iVar4 == 0) {\n                fcn.00438c81(unaff_EBP + -0x14);\n            }\n            fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\DefaultIcon\", *(unaff_EBP + -0x14));\n            fcn.0046338a(*(unaff_EBP + -0x10));\n            iVar4 = (**(*piVar2 + 100))(unaff_EBP + -0x10, 0);\n            if ((iVar4 == 0) || (*(*(unaff_EBP + -0x10) + -8) == 0)) {\n                fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\shell\\\\open\\\\%s\", *(unaff_EBP + -0x14), \"ddeexec\");\n                fcn.0046338a(*(unaff_EBP + -0x10));\n                fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\shell\\\\print\\\\%s\", *(unaff_EBP + -0x14), \"ddeexec\");\n                fcn.0046338a(*(unaff_EBP + -0x10));\n                fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\shell\\\\printto\\\\%s\", *(unaff_EBP + -0x14), \"ddeexec\");\n                fcn.0046338a(*(unaff_EBP + -0x10));\n            }\n            fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\shell\\\\open\\\\%s\", *(unaff_EBP + -0x14), \"command\");\n            fcn.0046338a(*(unaff_EBP + -0x10));\n            fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\shell\\\\print\\\\%s\", *(unaff_EBP + -0x14), \"command\");\n            fcn.0046338a(*(unaff_EBP + -0x10));\n            fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\shell\\\\printto\\\\%s\", *(unaff_EBP + -0x14), \"command\");\n            fcn.0046338a(*(unaff_EBP + -0x10));\n            (**(*piVar2 + 100))(unaff_EBP + -0x18, 4);\n            iVar4 = *(unaff_EBP + -0x18);\n            if (*(iVar4 + -8) != 0) {\n                *(unaff_EBP + -0x24) = 0x208;\n                uVar5 = fcn.00438f78(0x208, unaff_EBP + -0x24);\n                iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueA)(0x80000000, iVar4, uVar5);\n                fcn.00438fc7();\n                if (((iVar4 != 0) || (*(*(unaff_EBP + -0x10) + -8) == 0)) ||\n                   (iVar4 = fcn.0040dd23(*(unaff_EBP + -0x10), *(unaff_EBP + -0x14)),  iVar4 == 0)) {\n                    fcn.0042f759(unaff_EBP + -0x10, \"%s\\\\ShellNew\", *(unaff_EBP + -0x18));\n                    fcn.0046338a(*(unaff_EBP + -0x10));\n                    fcn.0046338a(*(unaff_EBP + -0x18));\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 3;\n        fcn.00438b48();\n        *(unaff_EBP + -4) = 2;\n        fcn.00438b48();\n        *(unaff_EBP + -4) = 1;\n        fcn.00438b48();\n        puVar3 = puVar1;\n        uVar5 = *0x498098;\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1497
    },
    "00463ba1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00463ba1(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.00460591();\n    *(iVar3 + 8) = unaff_ESI;\n    *(iVar3 + 0xc) = unaff_ESI;\n    iVar3 = fcn.00460591();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x68) = unaff_ESI;\n        *(iVar3 + 0x6c) = unaff_retaddr;\n        *(iVar3 + 0x70) = param_1;\n        *(iVar3 + 0x74) = param_2;\n        fcn.00463c04();\n    }\n    iVar3 = fcn.00460591();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.0043e00c();\n    }\n    return 1;\n}\n",
        "token_count": 299
    },
    "00463c04": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00463c04(int32_t param_1)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_30ch;\n    uint lpFilename;\n    uint var_108h;\n    uchar *var_4h;\n    \n    iVar2 = fcn.00460591();\n    *(iVar2 + 8) = *(param_1 + 0x68);\n    *(iVar2 + 0xc) = *(param_1 + 0x68);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x68), &lpFilename, 0x104);\n    var_4h = fcn.0040ed0f(&lpFilename, 0x2e);\n    *var_4h = 0;\n    fcn.00463d21(&lpFilename, &var_108h, 0x104);\n    if (*(param_1 + 0x88) == 0) {\n        uVar3 = fcn.0040e6b9(&var_108h);\n        *(param_1 + 0x88) = uVar3;\n    }\n    if (*(param_1 + 0x78) == 0) {\n        iVar4 = fcn.0043a3fb(0xe000, &var_30ch, 0x100);\n        if (iVar4 == 0) {\n            puVar5 = *(param_1 + 0x88);\n        }\n        else {\n            puVar5 = &var_30ch;\n        }\n        uVar3 = fcn.0040e6b9(puVar5);\n        *(param_1 + 0x78) = uVar3;\n    }\n    puVar1 = var_4h;\n    *(iVar2 + 0x10) = *(param_1 + 0x78);\n    if (*(param_1 + 0x8c) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(var_4h, \".HLP\");\n        uVar3 = fcn.0040e6b9(&lpFilename);\n        *(param_1 + 0x8c) = uVar3;\n        *puVar1 = 0;\n    }\n    if (*(param_1 + 0x90) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcatA)(&var_108h, \".INI\");\n        uVar3 = fcn.0040e6b9(&var_108h);\n        *(param_1 + 0x90) = uVar3;\n    }\n    return;\n}\n",
        "token_count": 600
    },
    "00463d21": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00463d21(char *param_1, int32_t param_2, uint param_3)\n\n{\n    char cVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    \n    pcVar2 = param_1;\n    for (; *param_1 != '\\0'; param_1 = fcn.0040e115(param_1)) {\n        cVar1 = *param_1;\n        if (((cVar1 == '\\\\') || (cVar1 == '/')) || (cVar1 == ':')) {\n            pcVar2 = fcn.0040e115(param_1);\n        }\n    }\n    if (param_2 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar2);\n        iVar3 = iVar3 + 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(param_2, pcVar2, param_3);\n        iVar3 = 0;\n    }\n    return iVar3;\n}\n",
        "token_count": 231
    },
    "00466871": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00466871(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *unaff_retaddr;\n    \n    fcn.00466668(0);\n    *(unaff_retaddr[0x17] + 8) = *(param_1 + 0x94);\n    *(unaff_retaddr[0x17] + 0xc) = *(param_1 + 0x98);\n    do {\n        iVar1 = (**(*unaff_retaddr + 0xb8))();\n        if ((iVar1 == 1) || (iVar1 == 2)) {\n            *(param_1 + 0x94) = *(unaff_retaddr[0x17] + 8);\n            *(param_1 + 0x98) = *(unaff_retaddr[0x17] + 0xc);\n            return iVar1;\n        }\n        uVar2 = sub.comdlg32.dll_CommDlgExtendedError();\n        if (uVar2 != 0x1009) {\n            if (uVar2 < 0x100b) {\n                return iVar1;\n            }\n            if (0x100c < uVar2) {\n                return iVar1;\n            }\n        }\n        if (*(unaff_retaddr[0x17] + 0xc) != 0) {\n            fcn.00447d7f();\n            *(unaff_retaddr[0x17] + 0xc) = 0;\n            *(param_1 + 0x98) = 0;\n        }\n        if (*(unaff_retaddr[0x17] + 8) != 0) {\n            fcn.00447d7f();\n            *(unaff_retaddr[0x17] + 8) = 0;\n            *(param_1 + 0x94) = 0;\n        }\n    } while( true );\n}\n",
        "token_count": 422
    },
    "00467dda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_19ch\n\nuint __cdecl fcn.00467dda(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint *in_FS_OFFSET;\n    uint var_19ch;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = fcn.00462b7c(0x4606b2);\n    if (*(iVar1 + 0xc) == 0) {\n        pcVar4 = *(unaff_EBP + 8);\n        if (pcVar4 == NULL) {\n            pcVar4 = unaff_EBP + -0x19c;\n        }\n        iVar2 = sub.WSOCK32.dll_WSAStartup(0x101, pcVar4);\n        if (iVar2 == 0) {\n            if ((*pcVar4 == '\\x01') && (pcVar4[1] == '\\x01')) {\n                *(iVar1 + 0xc) = 0x467da8;\n                iVar1 = fcn.004605b7();\n                if (*(iVar1 + 0x30) == 0) {\n                    iVar2 = fcn.00438337(0x1c);\n                    *(unaff_EBP + 8) = iVar2;\n                    *(unaff_EBP + -4) = 0;\n                    if (iVar2 == 0) {\n                        uVar3 = 0;\n                    }\n                    else {\n                        uVar3 = fcn.00436b68(10);\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    *(iVar1 + 0x30) = uVar3;\n                }\n                if (*(iVar1 + 0x34) == 0) {\n                    iVar2 = fcn.00438337(0x1c);\n                    *(unaff_EBP + 8) = iVar2;\n                    *(unaff_EBP + -4) = 1;\n                    if (iVar2 == 0) {\n                        uVar3 = 0;\n                    }\n                    else {\n                        uVar3 = fcn.00436b68(10);\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    *(iVar1 + 0x34) = uVar3;\n                }\n                if (*(iVar1 + 0x38) == 0) {\n                    iVar2 = fcn.00438337(0x1c);\n                    *(unaff_EBP + 8) = iVar2;\n                    *(unaff_EBP + -4) = 2;\n                    if (iVar2 == 0) {\n                        uVar3 = 0;\n                    }\n                    else {\n                        uVar3 = fcn.00434dce(10);\n                    }\n                    *(iVar1 + 0x38) = uVar3;\n                }\n                goto code_r0x00467ed2;\n            }\n            sub.WSOCK32.dll_WSACleanup();\n        }\n        uVar3 = 0;\n    }\n    else {\ncode_r0x00467ed2:\n        uVar3 = 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 730
    },
    "004680f2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __cdecl fcn.004680f2(uint hostshort, int32_t cp)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint name;\n    int32_t var_ch;\n    \n    fcn.0040d6f0(&name, 0, 0x10);\n    name._0_2_ = 2;\n    if (cp == 0) {\n        var_ch = sub.WSOCK32.dll_htonl(0);\n    }\n    else {\n        var_ch = sub.WSOCK32.dll_inet_addr(cp);\n        if (var_ch == -1) {\n            sub.WSOCK32.dll_WSASetLastError(0x2726);\n            return false;\n        }\n    }\n    name._2_2_ = sub.WSOCK32.dll_htons(hostshort);\n    iVar1 = sub.WSOCK32.dll_bind(*(in_ECX + 4), &name, 0x10);\n    return iVar1 != -1;\n}\n",
        "token_count": 225
    },
    "0046828b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0046828b(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, uint arg_18h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint var_10h;\n    int32_t var_ch;\n    \n    fcn.0040d6f0(&var_10h, 0, 0x10);\n    var_10h._0_2_ = 2;\n    if (arg_14h == 0) {\n        var_ch = sub.WSOCK32.dll_htonl(0xffffffff);\n    }\n    else {\n        var_ch = sub.WSOCK32.dll_inet_addr(arg_14h);\n        if (var_ch == -1) {\n            iVar2 = sub.WSOCK32.dll_gethostbyname(arg_14h);\n            if (iVar2 == 0) {\n                sub.WSOCK32.dll_WSASetLastError(0x2726);\n                return 0xffffffff;\n            }\n            var_ch = ***(iVar2 + 0xc);\n        }\n    }\n    var_10h._2_2_ = sub.WSOCK32.dll_htons(arg_10h);\n    uVar1 = (**(*in_ECX + 0x3c))(arg_8h, arg_ch, &var_10h, 0x10, arg_18h);\n    return uVar1;\n}\n",
        "token_count": 331
    },
    "00468380": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00468380(uint param_1)\n\n{\n    fcn.004605b7();\n    fcn.00436cdc(param_1);\n    return;\n}\n",
        "token_count": 38
    },
    "004689d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.004689d0(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.004605b7();\n    if (*(*(iVar1 + 0x38) + 0xc) == 0) {\n        return 0;\n    }\n    iVar3 = 0;\n    do {\n        iVar3 = iVar3 + 1;\n        iVar2 = fcn.00434f63();\n        if (*(iVar2 + 4) == 0x373) {\n            fcn.0046854e(*(iVar2 + 8), *(iVar2 + 0xc));\n        }\n        else {\n            fcn.0046846d(*(iVar2 + 8), 1);\n        }\n        fcn.00438360(iVar2);\n    } while (*(*(iVar1 + 0x38) + 0xc) != 0);\n    return iVar3;\n}\n",
        "token_count": 212
    },
    "0046a254": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.0046a254(void)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDocManager.0;\n    puVar1 = extraout_ECX[2];\n    *(unaff_EBP + -4) = 1;\n    while (puVar3 = puVar1,  puVar3 != NULL) {\n        puVar1 = *puVar3;\n        piVar2 = puVar3[2];\n        if ((piVar2[7] != 0) && (fcn.00435027(puVar3),  piVar2 != NULL)) {\n            (**(*piVar2 + 4))(1);\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00434e2d();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 326
    },
    "0041af79": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0041af79(void)\n\n{\n    if (*0x49d938 == 2) {\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x49d920);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "004066c0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004066c0(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.0041d158(arg_8h & 0xff, in_ECX + 8);\n    return;\n}\n",
        "token_count": 64
    },
    "0040126c": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuchar __cdecl fcn.0040126c(uint arg_8h)\n\n{\n    return arg_8h;\n}\n",
        "token_count": 26
    },
    "0040128a": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040128a(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    \n    cVar1 = fcn.004012ad(arg_8h, arg_ch);\n    return cVar1 == '\\0';\n}\n",
        "token_count": 58
    },
    "00403a20": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00403a20(int32_t *param_1)\n\n{\n    char cVar1;\n    uint arg_8h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = (**(*param_1 + 0x10))();\n    var_8h = fcn.004015d2();\n    cVar1 = fcn.004014ce(&var_8h, &var_4h);\n    if (cVar1 == '\\0') {\n        arg_8h = fcn.0040111d();\n        var_10h = fcn.004012b7(arg_8h);\n    }\n    else {\n        var_10h = fcn.004015d2();\n    }\n    return var_10h;\n}\n",
        "token_count": 187
    },
    "00406740": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406740(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.0041d367(arg_8h & 0xff, in_ECX + 8);\n    return;\n}\n",
        "token_count": 63
    },
    "0040148d": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040148d(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    cVar1 = fcn.00401370(arg_ch, 1);\n    if (cVar1 != '\\0') {\n        fcn.004015aa(*(in_ECX + 4), arg_8h, arg_ch);\n        fcn.004014dd(arg_ch);\n    }\n    return in_ECX;\n}\n",
        "token_count": 116
    },
    "00401505": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00401505(uint arg_8h, uint arg_ch, uint32_t arg_10h, char *arg_14h)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    char *pcVar3;\n    uchar *puVar4;\n    uint *in_FS_OFFSET;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint32_t var_34h;\n    int32_t var_30h;\n    uint32_t var_2ch;\n    uint32_t var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b999;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    for (var_24h = 0; arg_14h[var_24h] != '\\0'; var_24h = var_24h + 1) {\n        if (arg_14h[var_24h] == *arg_14h) {\n            arg_10h = arg_10h + 1;\n        }\n    }\n    fcn.0040152d(arg_10h, 0, &var_38h);\n    var_4h = 0;\n    var_10h = 0xfffffffe;\n    var_28h = 1;\n    while( true ) {\n        var_30h = 0;\n        var_2ch = var_2ch & 0xffffff00;\n        for (var_34h = 0; var_34h < arg_10h; var_34h = var_34h + 1) {\n            for (; (arg_14h[var_30h] != '\\0' && (arg_14h[var_30h] != *arg_14h)); var_30h = var_30h + 1) {\n            }\n            pcVar3 = fcn.004011c7(var_34h);\n            if (*pcVar3 == '\\0') {\n                var_30h = var_30h + var_28h;\n                if ((arg_14h[var_30h] == *arg_14h) || (arg_14h[var_30h] == '\\0')) {\n                    if (var_28h < 0x7f) {\n                        var_40h._0_1_ = var_28h;\n                    }\n                    else {\n                        var_40h._0_1_ = 0x7f;\n                    }\n                    puVar4 = fcn.004011c7(var_34h);\n                    *puVar4 = var_40h;\n                    var_10h = var_34h;\n                }\n                else {\n                    cVar2 = fcn.004012ad(arg_8h, arg_ch);\n                    if ((cVar2 == '\\0') && (cVar2 = arg_14h[var_30h],  pcVar3 = fcn.004014ab(),  cVar2 == *pcVar3)) {\n                        var_2ch = CONCAT31(var_2ch._1_3_, 1);\n                    }\n                    else {\n                        if (var_28h < 0x7f) {\n                            var_44h._0_1_ = var_28h;\n                        }\n                        else {\n                            var_44h._0_1_ = 0x7f;\n                        }\n                        puVar4 = fcn.004011c7(var_34h);\n                        *puVar4 = var_44h;\n                    }\n                }\n            }\n            else {\n                pcVar3 = fcn.004011c7(var_34h);\n                var_30h = var_30h + *pcVar3;\n            }\n        }\n        if (((var_2ch & 0xff) == 0) || (cVar2 = fcn.004012ad(arg_8h, arg_ch),  cVar2 != '\\0')) break;\n        var_28h = var_28h + 1;\n        fcn.004011bd();\n        var_10h = 0xffffffff;\n    }\n    uVar1 = var_10h;\n    var_4h = 0xffffffff;\n    fcn.0040125d();\n    *in_FS_OFFSET = var_ch;\n    return uVar1;\n}\n",
        "token_count": 1000
    },
    "00401578": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401578(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    return (*(*(in_ECX + 0x10) + (arg_ch & 0xff) * 2) & arg_8h) != 0;\n}\n",
        "token_count": 76
    },
    "004015e1": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004015e1(int32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if (arg_8h == *0x4711c4) {\n        fcn.0041af8e();\n    }\n    cVar1 = fcn.00401370(arg_8h, 1);\n    if (cVar1 != '\\0') {\n        fcn.004013b1(*(in_ECX + 4), arg_8h, &arg_ch);\n        fcn.004014dd(arg_8h);\n    }\n    return in_ECX;\n}\n",
        "token_count": 153
    },
    "00404190": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00404190(uint arg_8h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    int32_t in_ECX;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.00401109();\n    if (iVar3 != 0) {\n        uVar4 = fcn.00401109();\n        uVar5 = fcn.004013c5();\n        if (uVar5 < uVar4) {\n            var_4h = fcn.004015d2();\n            cVar1 = fcn.004014ce(&var_4h, &arg_8h);\n            if (cVar1 == '\\0') {\n                var_8h._0_1_ = fcn.00401627(&arg_8h);\n                iVar3 = fcn.00401109();\n                cVar1 = fcn.004011f9(&var_8h, iVar3 + -1);\n                if ((cVar1 == '\\0') && ((*(in_ECX + 0x44) & 2) != 0)) goto code_r0x0040421b;\n            }\n            fcn.00401118(0xffffffff);\n            var_ch = fcn.004015d2();\n            cVar1 = fcn.004014ce(&var_ch, &arg_8h);\n            if (cVar1 == '\\0') {\n                uVar2 = fcn.00401627(&arg_8h);\n                puVar6 = fcn.00401109();\n                *puVar6 = uVar2;\n            }\n            fcn.0040153c(&arg_8h);\n            return;\n        }\n    }\ncode_r0x0040421b:\n    fcn.004015d2();\n    return;\n}\n",
        "token_count": 449
    },
    "0040162c": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040162c(uint param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    cVar1 = fcn.004013f7();\n    if (cVar1 == '\\0') {\n        fcn.004010a5();\n        iVar2 = fcn.00401262();\n        if (iVar2 == -1) {\n            var_4h = 4;\n        }\n    }\n    fcn.004010be(var_4h, 0);\n    return param_1;\n}\n",
        "token_count": 143
    },
    "0040168b": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nuint fcn.0040168b(void)\n\n{\n    char cVar1;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = fcn.004011db();\n    var_8h = fcn.004015d2();\n    cVar1 = fcn.004014ce(&var_8h, &var_4h);\n    if (cVar1 == '\\0') {\n        var_10h = fcn.0040106e();\n    }\n    else {\n        var_10h = fcn.004015d2();\n    }\n    return var_10h;\n}\n",
        "token_count": 149
    },
    "00447d7f": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.00447d7f(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "0043e8f0": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043e8f0(uint lpFileName, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    uint uVar4;\n    char cVar5;\n    uint uVar6;\n    uint var_110h;\n    uint lpSecurityAttributes;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    *(in_ECX + 8) = 0;\n    *(in_ECX + 4) = 0xffffffff;\n    fcn.00438ad3();\n    fcn.0043ef78(&var_110h, lpFileName);\n    fcn.00438cd1(&var_110h);\n    uVar3 = 0;\n    uVar1 = arg_ch & 3;\n    if (uVar1 == 0) {\n        uVar3 = 0x80000000;\n    }\n    else if (uVar1 == 1) {\n        uVar3 = 0x40000000;\n    }\n    else if (uVar1 == 2) {\n        uVar3 = 0xc0000000;\n    }\n    uVar1 = arg_ch & 0x70;\n    uVar4 = 1;\n    if ((uVar1 != 0) && (uVar1 != 0x10)) {\n        uVar6 = uVar4;\n        if (uVar1 == 0x20) goto code_r0x0043e987;\n        if (uVar1 == 0x30) {\n            uVar6 = 2;\n            goto code_r0x0043e987;\n        }\n        if (uVar1 == 0x40) {\n            uVar6 = 3;\n            goto code_r0x0043e987;\n        }\n    }\n    uVar6 = 0;\ncode_r0x0043e987:\n    var_8h = 0;\n    var_4h = ~(arg_ch & 0xffff7fff) >> 7 & 1;\n    lpSecurityAttributes = 0xc;\n    if ((arg_ch & 0x1000) == 0) {\n        cVar5 = '\\x03';\n    }\n    else {\n        cVar5 = (-((arg_ch & 0x2000) != 0) & 2U) + 2;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileA)(lpFileName, uVar3, uVar6, &lpSecurityAttributes, cVar5, 0x80, 0);\n    if (iVar2 == -1) {\n        if (arg_10h != 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            *(arg_10h + 0xc) = uVar3;\n            uVar3 = fcn.0043f4c3(uVar3);\n            *(arg_10h + 8) = uVar3;\n            fcn.00438cd1(lpFileName);\n        }\n        uVar4 = 0;\n    }\n    else {\n        *(in_ECX + 4) = iVar2;\n        *(in_ECX + 8) = 1;\n    }\n    return uVar4;\n}\n",
        "token_count": 728
    },
    "0043fef3": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nint32_t fcn.0043fef3(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint16_t *puVar3;\n    uint16_t uVar4;\n    uint32_t uVar5;\n    bool bVar6;\n    \n    bVar6 = *(param_1 + 2) == -1;\n    iVar1 = fcn.0043fe9d(param_1);\n    if (*(param_1 + 2) == -1) {\n        uVar5 = param_1[3];\n    }\n    else {\n        uVar5 = *param_1;\n    }\n    if ((uVar5 & 0x40) != 0) {\n        iVar1 = iVar1 + ((-bVar6 & 2) + 1) * 2;\n        iVar2 = fcn.0040da5c(iVar1);\n        iVar1 = iVar1 + 2 + iVar2 * 2;\n    }\n    if (bVar6) {\n        uVar4 = *(param_1 + 4);\n    }\n    else {\n        uVar4 = *(param_1 + 2);\n    }\n    if (uVar4 != 0) {\n        uVar5 = uVar4;\n        do {\n            puVar3 = (iVar1 + 3U & 0xfffffffc) + (-bVar6 & 6) + 0x12;\n            uVar4 = *puVar3;\n            if (uVar4 == 0xffff) {\n                puVar3 = puVar3 + 2;\n            }\n            else {\n                while (puVar3 = puVar3 + 1,  uVar4 != 0) {\n                    uVar4 = *puVar3;\n                }\n            }\n            uVar4 = *puVar3;\n            if (uVar4 == 0xffff) {\n                puVar3 = puVar3 + 2;\n            }\n            else {\n                while (puVar3 = puVar3 + 1,  uVar4 != 0) {\n                    uVar4 = *puVar3;\n                }\n            }\n            uVar5 = uVar5 - 1;\n            iVar1 = puVar3 + *puVar3 + 2;\n        } while (uVar5 != 0);\n    }\n    return iVar1 - param_1;\n}\n",
        "token_count": 517
    },
    "0043ffab": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nuint fcn.0043ffab(uint32_t *param_1, uint param_2, ushort *param_3)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    ushort *puVar3;\n    uint uVar4;\n    \n    if (*(param_1 + 2) == -1) {\n        uVar2 = param_1[3];\n    }\n    else {\n        uVar2 = *param_1;\n    }\n    if ((uVar2 & 0x40) == 0) {\n        return 0;\n    }\n    puVar3 = fcn.0043fe9d(param_1);\n    *param_3 = *puVar3;\n    iVar1 = *(param_1 + 2);\n    uVar4 = fcn.00438fef(0x20, 0x20, 0, 0);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar3 + ((iVar1 != -1) - 1 & 2) + 1, 0xffffffff, uVar4);\n    fcn.00438fc7(0xffffffff);\n    return 1;\n}\n",
        "token_count": 261
    },
    "00453bed": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00453bed(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint uVar5;\n    uint lprcSrc1;\n    int32_t lprcSrc2;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint lprcDst;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = arg_8h - *(in_ECX + 4);\n    iVar4 = arg_ch - *(in_ECX + 8);\n    iVar2 = *(in_ECX + 0x8c);\n    uVar5 = 2;\n    if (iVar2 == 10) {\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + iVar1;\n    }\n    else {\n        if (iVar2 != 0xb) {\n            uVar5 = 0x22;\n            if (iVar2 == 0xc) {\n                *(in_ECX + 0x2c) = *(in_ECX + 0x2c) + iVar4;\n            }\n            else {\n                *(in_ECX + 0x34) = *(in_ECX + 0x34) + iVar4;\n            }\n            iVar2 = *(in_ECX + 0x34) - *(in_ECX + 0x2c);\n            goto code_r0x00453c45;\n        }\n        *(in_ECX + 0x30) = *(in_ECX + 0x30) + iVar1;\n    }\n    iVar2 = *(in_ECX + 0x30) - *(in_ECX + 0x28);\ncode_r0x00453c45:\n    if (iVar2 < 0) {\n        iVar2 = 0;\n    }\n    piVar3 = (**(**(in_ECX + 0x68) + 0xbc))(&var_10h, iVar2, uVar5);\n    var_8h = *piVar3;\n    var_4h = piVar3[1];\n    uVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    (*_sym.imp.USER32.dll_GetWindowRect)(uVar5, &lprcSrc1);\n    lprcSrc2 = *(in_ECX + 0x48);\n    var_24h = *(in_ECX + 0x4c);\n    var_20h = *(in_ECX + 0x50);\n    var_1ch = *(in_ECX + 0x54);\n    if ((*(in_ECX + 0x8c) == 10) || (*(in_ECX + 0x8c) == 0xc)) {\n        lprcSrc2 = ((*(in_ECX + 0x58) - *(in_ECX + 0x60)) - var_8h) + var_20h;\n        var_24h = ((*(in_ECX + 0x5c) - *(in_ECX + 100)) - var_4h) + var_1ch;\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar2 != 0) {\n            *(in_ECX + 0x38) = *(in_ECX + 0x40) - var_8h;\n            *(in_ECX + 0x3c) = *(in_ECX + 0x44) - var_4h;\n            *(in_ECX + 0x48) = lprcSrc2;\n            *(in_ECX + 0x4c) = var_24h;\n        }\n    }\n    else {\n        var_20h = (*(in_ECX + 0x60) - *(in_ECX + 0x58)) + lprcSrc2 + var_8h;\n        var_1ch = (*(in_ECX + 100) - *(in_ECX + 0x5c)) + var_24h + var_4h;\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar2 != 0) {\n            *(in_ECX + 0x40) = *(in_ECX + 0x38) + var_8h;\n            *(in_ECX + 0x44) = *(in_ECX + 0x3c) + var_4h;\n            *(in_ECX + 0x50) = var_20h;\n            *(in_ECX + 0x54) = var_1ch;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    fcn.00453f7b(0);\n    return;\n}\n",
        "token_count": 1140
    },
    "00458990": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nint32_t fcn.00458990(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    \n    pcVar1 = param_3 + param_1;\n    pcVar2 = param_2 + param_1;\n    if (pcVar1 < pcVar2) {\n        do {\n            if (*pcVar1 != '\\r') break;\n            pcVar1 = pcVar1 + 1;\n        } while (pcVar1 < pcVar2);\n        if ((pcVar1 < pcVar2) && (*pcVar1 == '\\n')) {\n            pcVar1 = pcVar1 + 1;\n        }\n    }\n    return pcVar1 - param_1;\n}\n",
        "token_count": 172
    },
    "00438a37": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438a37(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 8);\n    if ((((iVar1 != 0x40) && (iVar1 != 0x80)) && (iVar1 != 0x100)) && (iVar1 != 0x200)) {\n        fcn.00438360(param_1);\n        return;\n    }\n    fcn.0040c751(param_1);\n    return;\n}\n",
        "token_count": 113
    },
    "0045bd14": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045bd14(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((((param_2 != 0) && (param_2 != 6)) && (param_2 != 7)) && ((param_2 != 8 && (param_2 != 4)))) {\n        uVar1 = (*_sym.imp.USER32.dll_GetLastActivePopup)(*(param_1 + 0x1c));\n        (*_sym.imp.USER32.dll_BringWindowToTop)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "004013c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004013c0(int32_t param_1)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0041aedd();\n    if (*(param_1 + 4) != -1) {\n        *(param_1 + 4) = *(param_1 + 4) + 1;\n    }\n    fcn.0041af79();\n    return;\n}\n",
        "token_count": 95
    },
    "00401519": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401519(uint how)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = sub.WSOCK32.dll_shutdown(*(in_ECX + 4), how);\n    return iVar1 != -1;\n}\n",
        "token_count": 67
    },
    "0040b04a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b04a(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00401690(0xeb, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    pcVar2 = fcn.00401168(uVar1);\n    (*pcVar2)();\n    iVar3 = fcn.0045a4b5(arg_8h);\n    if ((((iVar3 != -1) && (iVar3 = fcn.00460fe8(in_ECX, 0x50002800, 0xe800),  iVar3 != 0)) &&\n        (iVar3 = fcn.0040119a(0x80),  iVar3 != 0)) && (iVar3 = fcn.004613f9(0x494a34, 4),  iVar3 != 0)) {\n        iVar3 = fcn.00460a26(in_ECX, 0x50008200, 0xe801);\n        if ((iVar3 != 0) && (iVar3 = fcn.00460adb(0x494a44, 3),  iVar3 != 0)) {\n            fcn.00452d85(0xf000);\n            fcn.0045bdb7(0xf000);\n            fcn.0045be4c(in_ECX + 0x1fc, 0, 0);\n            uVar4 = fcn.0040139d();\n            fcn.00461602(uVar4 & 0xffffff00 | uVar4 & 0xff | 0x10 | 0x20);\n            return 0;\n        }\n        return 0xffffffff;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 427
    },
    "0041057f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.0041057f(int32_t param_1, uint param_2, int32_t param_3, int32_t param_4)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    int32_t var_8h;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_1ch;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x475f00;\n    pcStack16 = fcn.00413018;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    for (iVar2 = *(var_8h + 8); var_4h = 0xffffffff,  iVar2 != var_14h; iVar2 = *(*(var_18h + 8) + iVar2 * 8)) {\n        if ((iVar2 < 0) || (*(var_18h + 4) <= iVar2)) {\n            fcn.00410cad();\n        }\n        var_4h = 0;\n        iVar1 = *(*(var_18h + 8) + 4 + iVar2 * 8);\n        if (iVar1 != 0) {\n            fcn.00410a50(iVar1, var_8h, 0x103);\n        }\n    }\n    *(var_8h + 8) = iVar2;\n    *in_FS_OFFSET = var_10h;\n    return;\n}\n",
        "token_count": 352
    },
    "00414150": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414150(uint32_t arg_8h, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = arg_ch + 1;\n    *piVar1 = *piVar1 + -1;\n    if (*piVar1 < 0) {\n        arg_8h = fcn.004138f7(arg_8h, arg_ch);\n    }\n    else {\n        **arg_ch = arg_8h;\n        *arg_ch = *arg_ch + 1;\n        arg_8h = arg_8h & 0xff;\n    }\n    if (arg_8h == 0xffffffff) {\n        *arg_10h = -1;\n        return;\n    }\n    *arg_10h = *arg_10h + 1;\n    return;\n}\n",
        "token_count": 194
    },
    "00432bd2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432bd2(uint arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_2ch;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    puVar1 = arg_ch;\n    puVar3 = &var_2ch;\n    for (iVar2 = 0xb; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    if (((var_ch == 0) && (var_8h != -1)) && (var_8h != 0)) {\n        iVar2 = fcn.00437019(var_8h, &arg_ch);\n        if (iVar2 == 0) {\n            puVar1 = fcn.0043705d(var_8h);\n            *puVar1 = 0;\n        }\n        fcn.0043703b(var_8h, &var_8h);\n    }\n    (**(*in_ECX + 0xa0))(0x404, arg_8h, &var_2ch);\n    return;\n}\n",
        "token_count": 298
    },
    "0043513d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043513d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_ch != -1) {\n        *(in_ECX + 0x10) = arg_ch;\n    }\n    if (arg_8h == 0) {\n        fcn.00438360(*(in_ECX + 4));\n        *(in_ECX + 4) = 0;\n        *(in_ECX + 0xc) = 0;\n        *(in_ECX + 8) = 0;\n        return;\n    }\n    if (*(in_ECX + 4) == 0) {\n        uVar1 = fcn.00438337(arg_8h << 2);\n        *(in_ECX + 4) = uVar1;\n        fcn.0040d6f0(uVar1, 0, arg_8h << 2);\n        *(in_ECX + 0xc) = arg_8h;\ncode_r0x00435194:\n        *(in_ECX + 8) = arg_8h;\n        return;\n    }\n    if (arg_8h <= *(in_ECX + 0xc)) {\n        iVar2 = *(in_ECX + 8);\n        if (iVar2 < arg_8h) {\n            fcn.0040d6f0(*(in_ECX + 4) + iVar2 * 4, 0, (iVar2 * 0x3fffffff + arg_8h) * 4);\n        }\n        goto code_r0x00435194;\n    }\n    arg_ch = *(in_ECX + 0x10);\n    if (arg_ch != 0) goto code_r0x004351f2;\n    arg_ch = *(in_ECX + 8) / 8;\n    if (3 < arg_ch) {\n        if (0x400 < arg_ch) {\n            arg_ch = 0x400;\n            goto code_r0x004351f2;\n        }\n        if (3 < arg_ch) goto code_r0x004351f2;\n    }\n    arg_ch = 4;\ncode_r0x004351f2:\n    arg_ch = arg_ch + *(in_ECX + 0xc);\n    if (arg_ch <= arg_8h) {\n        arg_ch = arg_8h;\n    }\n    iVar2 = fcn.00438337(arg_ch << 2);\n    fcn.0040cd30(iVar2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.0040d6f0(iVar2 + *(in_ECX + 8) * 4, 0, (*(in_ECX + 8) * 0x3fffffff + arg_8h) * 4);\n    fcn.00438360(*(in_ECX + 4));\n    *(in_ECX + 4) = iVar2;\n    *(in_ECX + 8) = arg_8h;\n    *(in_ECX + 0xc) = arg_ch;\n    return;\n}\n",
        "token_count": 695
    },
    "00435498": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435498(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_ch != -1) {\n        *(in_ECX + 0x10) = arg_ch;\n    }\n    if (arg_8h == 0) {\n        fcn.00438360(*(in_ECX + 4));\n        *(in_ECX + 4) = 0;\n        *(in_ECX + 0xc) = 0;\n        *(in_ECX + 8) = 0;\n        return;\n    }\n    if (*(in_ECX + 4) == 0) {\n        uVar1 = fcn.00438337(arg_8h << 2);\n        *(in_ECX + 4) = uVar1;\n        fcn.0040d6f0(uVar1, 0, arg_8h << 2);\n        *(in_ECX + 0xc) = arg_8h;\ncode_r0x004354ef:\n        *(in_ECX + 8) = arg_8h;\n        return;\n    }\n    if (arg_8h <= *(in_ECX + 0xc)) {\n        iVar2 = *(in_ECX + 8);\n        if (iVar2 < arg_8h) {\n            fcn.0040d6f0(*(in_ECX + 4) + iVar2 * 4, 0, (iVar2 * 0x3fffffff + arg_8h) * 4);\n        }\n        goto code_r0x004354ef;\n    }\n    arg_ch = *(in_ECX + 0x10);\n    if (arg_ch != 0) goto code_r0x0043554d;\n    arg_ch = *(in_ECX + 8) / 8;\n    if (3 < arg_ch) {\n        if (0x400 < arg_ch) {\n            arg_ch = 0x400;\n            goto code_r0x0043554d;\n        }\n        if (3 < arg_ch) goto code_r0x0043554d;\n    }\n    arg_ch = 4;\ncode_r0x0043554d:\n    arg_ch = arg_ch + *(in_ECX + 0xc);\n    if (arg_ch <= arg_8h) {\n        arg_ch = arg_8h;\n    }\n    iVar2 = fcn.00438337(arg_ch << 2);\n    fcn.0040cd30(iVar2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.0040d6f0(iVar2 + *(in_ECX + 8) * 4, 0, (*(in_ECX + 8) * 0x3fffffff + arg_8h) * 4);\n    fcn.00438360(*(in_ECX + 4));\n    *(in_ECX + 4) = iVar2;\n    *(in_ECX + 8) = arg_8h;\n    *(in_ECX + 0xc) = arg_ch;\n    return;\n}\n",
        "token_count": 694
    },
    "00436dc3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00436dc3(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 == 0xffffffff) {\n        uVar4 = 0;\n        if (*(param_1 + 8) != 0) {\n            ppiVar1 = *(param_1 + 4);\n            do {\n                piVar3 = *ppiVar1;\n                if (piVar3 != NULL) break;\n                uVar4 = uVar4 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar4 < *(param_1 + 8));\n        }\n    }\n    piVar5 = *piVar3;\n    if (piVar5 == NULL) {\n        uVar4 = *(param_1 + 8);\n        uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n        if (uVar2 < uVar4) {\n            ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n            do {\n                piVar5 = *ppiVar1;\n                if (piVar5 != NULL) break;\n                uVar2 = uVar2 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar2 < uVar4);\n        }\n    }\n    *param_2 = piVar5;\n    *param_3 = piVar3[1];\n    *param_4 = piVar3[2];\n    return;\n}\n",
        "token_count": 412
    },
    "00437123": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00437123(int32_t param_1, int32_t **param_2, int32_t *param_3)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    \n    piVar3 = *param_2;\n    if (piVar3 == 0xffffffff) {\n        uVar4 = 0;\n        if (*(param_1 + 8) != 0) {\n            ppiVar1 = *(param_1 + 4);\n            do {\n                piVar3 = *ppiVar1;\n                if (piVar3 != NULL) break;\n                uVar4 = uVar4 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar4 < *(param_1 + 8));\n        }\n    }\n    piVar2 = *piVar3;\n    if (piVar2 == NULL) {\n        uVar4 = piVar3[1] + 1;\n        if (uVar4 < *(param_1 + 8)) {\n            ppiVar1 = *(param_1 + 4) + uVar4 * 4;\n            do {\n                piVar2 = *ppiVar1;\n                if (piVar2 != NULL) break;\n                uVar4 = uVar4 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar4 < *(param_1 + 8));\n        }\n    }\n    *param_2 = piVar2;\n    fcn.00438c81(piVar3 + 2);\n    *param_3 = piVar3[3];\n    return;\n}\n",
        "token_count": 384
    },
    "00438fc7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00438fc7(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.00438af1();\n    if (param_2 == -1) {\n        param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*param_1);\n    }\n    *(*param_1 + -8) = param_2;\n    *(*param_1 + param_2) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "0043eb0b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043eb0b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar3 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.00438ad3();\n    if (bVar3) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0043f31d(uVar2);\n    }\n    return;\n}\n",
        "token_count": 179
    },
    "0043eb4c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043eb4c(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        *(param_1 + 4) = 0xffffffff;\n    }\n    fcn.00438ad3();\n    return;\n}\n",
        "token_count": 84
    },
    "0043ef78": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpFindFileData\n\nuint __cdecl fcn.0043ef78(uint lpRootPathName, uint lpFileName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpFindFileData;\n    uint lpString2;\n    uint var_18h;\n    uint lpFilePart;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar1 = *(unaff_EBP + 8);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, uVar1, unaff_EBP + -0x14);\n    if (iVar2 == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, *(unaff_EBP + 0xc), 0x104);\n        uVar3 = 0;\n    }\n    else {\n        *(unaff_EBP + 8) = *0x498098;\n        uVar3 = 0;\n        *(unaff_EBP + -4) = 0;\n        fcn.0043f048(uVar1, unaff_EBP + 8);\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                          (*(unaff_EBP + 8), 0, 0, 0, unaff_EBP + -0x18, unaff_EBP + -0x10, 0, 0);\n        if (iVar2 != 0) {\n            if ((*(unaff_EBP + -0x10) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(uVar1);\n            }\n            if ((*(unaff_EBP + -0x10) & 4) == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + 0xc), unaff_EBP + -0x158);\n                if (iVar2 != -1) {\n                    (*_sym.imp.KERNEL32.dll_FindClose)(iVar2);\n                    (*_sym.imp.KERNEL32.dll_lstrcpyA)(*(unaff_EBP + -0x14), unaff_EBP + -300);\n                }\n            }\n            uVar3 = 1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00438b48();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 597
    },
    "00445bf1": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00445bf1(uint param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0043aa3a();\n    if (iVar1 != -1) {\n        if ((*param_2 != 0) && (*(*param_2 + 4) != 0)) {\n            fcn.004451b6(param_1);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 113
    },
    "0044c0d8": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.0044c0d8(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_10h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    fcn.0043a377(*(unaff_EBP + 8));\n    arg_10h_00 = *(unaff_EBP + 0x10);\n    if (arg_10h_00 == -1) {\n        arg_10h_00 = *(unaff_EBP + 8);\n    }\n    uVar1 = fcn.0044c0a0(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), arg_10h_00);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 329
    },
    "0044c650": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c650(int32_t *arg_8h, uint arg_ch, uint *lParam)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    uVar2 = fcn.0044c1fc(arg_ch);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*arg_8h == 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(uVar2, 0x18c, 0xffffffff, *lParam);\n    }\n    else {\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageA)(uVar2, 0x188, 0, 0);\n        if (iVar3 == -1) {\n            fcn.00438ad3();\n        }\n        else {\n            uVar4 = (*pcVar1)(uVar2, 0x18a, iVar3, 0);\n            uVar4 = fcn.00438fef(uVar4);\n            (*pcVar1)(uVar2, 0x189, iVar3, uVar4);\n        }\n        fcn.00438fc7(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 272
    },
    "0045a4c4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0045a4c4(int32_t *param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0043aa3a();\n    if ((iVar1 != -1) && (iVar1 = (**(*param_1 + 0xdc))(param_2, param_3),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_PostMessageA)(param_1[7], 0x362, 0xe001, 0);\n        (**(*param_1 + 200))(1);\n        return 0;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 151
    },
    "00460e28": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00460e28(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar4 = *0x49851c;\n    if (*0x49851c == -1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"DllGetVersion\");\n        iVar4 = 0x40000;\n        if (pcVar2 != NULL) {\n            fcn.0040d6f0(&var_14h, 0, 0x14);\n            var_14h = 0x14;\n            iVar3 = (*pcVar2)(&var_14h);\n            if (-1 < iVar3) {\n                iVar4 = CONCAT22(var_10h, var_ch);\n            }\n        }\n    }\n    *0x49851c = iVar4;\n    return iVar4;\n}\n",
        "token_count": 260
    },
    "00460e96": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.00460e96(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    if (*0x498520 == -1) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n        uVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x48, 0, 0, 0, 400, 0, 0, 0, 2, 0, 0, 0, 0, \"Marlett\");\n        iVar4 = (*_sym.imp.GDI32.dll_CreateFontA)(uVar3);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        if (iVar4 != 0) {\n            iVar4 = (*_sym.imp.GDI32.dll_SelectObject)(uVar2, iVar4);\n        }\n        (*_sym.imp.GDI32.dll_GetCharWidthA)(uVar2, 0x36, 0x36, 0x498520);\n        if (iVar4 != 0) {\n            (*pcVar1)(uVar2, iVar4);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar4);\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    return *0x498520;\n}\n",
        "token_count": 301
    },
    "00462679": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00462679(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar1;\n    if (iVar1 == -1) {\n        fcn.0042eb4c();\n    }\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 + 7);\n    return param_1;\n}\n",
        "token_count": 181
    },
    "004626bb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004626bb(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.004629c8(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 229
    },
    "00467fad": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00467fad(uint arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    uint var_14h;\n    ushort var_10h;\n    ushort uStack18;\n    uint var_4h;\n    \n    fcn.0040d6f0(&var_14h, 0, 0x10);\n    var_4h = 0x10;\n    iVar1 = sub.WSOCK32.dll_getpeername(*(in_ECX + 4), &var_14h, &var_4h);\n    if (iVar1 != -1) {\n        uVar2 = sub.WSOCK32.dll_ntohs(CONCAT22(var_10h, var_14h._2_2_));\n        *arg_ch = uVar2 & 0xffff;\n        uVar3 = sub.WSOCK32.dll_inet_ntoa(CONCAT22(uStack18, var_10h));\n        fcn.00438cd1(uVar3);\n    }\n    return iVar1 != -1;\n}\n",
        "token_count": 253
    },
    "00468013": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00468013(uint arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    uint var_14h;\n    ushort var_10h;\n    ushort uStack18;\n    uint var_4h;\n    \n    fcn.0040d6f0(&var_14h, 0, 0x10);\n    var_4h = 0x10;\n    iVar1 = sub.WSOCK32.dll_getsockname(*(in_ECX + 4), &var_14h, &var_4h);\n    if (iVar1 != -1) {\n        uVar2 = sub.WSOCK32.dll_ntohs(CONCAT22(var_10h, var_14h._2_2_));\n        *arg_ch = uVar2 & 0xffff;\n        uVar3 = sub.WSOCK32.dll_inet_ntoa(CONCAT22(uStack18, var_10h));\n        fcn.00438cd1(uVar3);\n    }\n    return iVar1 != -1;\n}\n",
        "token_count": 253
    },
    "00468165": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00468165(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != -1) {\n        sub.WSOCK32.dll_closesocket(*(param_1 + 4));\n        fcn.0046850f(*(param_1 + 4), param_1);\n        *(param_1 + 4) = 0xffffffff;\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "00468185": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00468185(uint name, uint hostshort)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    uint var_10h;\n    int32_t var_ch;\n    \n    fcn.0040d6f0(&var_10h, 0, 0x10);\n    var_10h._0_2_ = 2;\n    var_ch = sub.WSOCK32.dll_inet_addr(name);\n    if (var_ch == -1) {\n        iVar1 = sub.WSOCK32.dll_gethostbyname(name);\n        if (iVar1 == 0) {\n            sub.WSOCK32.dll_WSASetLastError(0x2726);\n            return 0;\n        }\n        var_ch = ***(iVar1 + 0xc);\n    }\n    var_10h._2_2_ = sub.WSOCK32.dll_htons(hostshort);\n    uVar2 = (**(*in_ECX + 0x34))(&var_10h, 0x10);\n    return uVar2;\n}\n",
        "token_count": 248
    },
    "0046820d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0046820d(uint arg_8h, uint arg_ch, uint arg_10h, uint32_t *arg_14h, uint arg_18h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_14h;\n    ushort var_10h;\n    ushort uStack18;\n    uint var_4h;\n    \n    fcn.0040d6f0(&var_14h, 0, 0x10);\n    var_4h = 0x10;\n    iVar1 = (**(*in_ECX + 0x38))(arg_8h, arg_ch, &var_14h, &var_4h, arg_18h);\n    if (iVar1 != -1) {\n        uVar2 = sub.WSOCK32.dll_ntohs(CONCAT22(var_10h, var_14h._2_2_));\n        *arg_14h = uVar2 & 0xffff;\n        uVar3 = sub.WSOCK32.dll_inet_ntoa(CONCAT22(uStack18, var_10h));\n        fcn.00438cd1(uVar3);\n    }\n    return iVar1;\n}\n",
        "token_count": 281
    },
    "00468315": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00468315(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004605b7();\n    iVar1 = sub.WSOCK32.dll_WSAAsyncSelect(*(param_1 + 4), *(iVar1 + 0x2c), 0x373, param_2);\n    return iVar1 != -1;\n}\n",
        "token_count": 94
    },
    "00468351": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00468351(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CAsyncSocket.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != 0xffffffff) {\n        fcn.00468165(extraout_ECX);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 161
    },
    "0046854e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0046854e(int32_t arg_8h, uint32_t argp)\n\n{\n    int32_t iVar1;\n    int32_t *arg_ch;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_8h != 0) || (argp != 0)) {\n        iVar1 = fcn.00468380(arg_8h, 1);\n        if (iVar1 == 0) {\n            arg_ch = fcn.00468380(arg_8h, 0);\n            if (arg_ch == NULL) {\n                arg_ch = fcn.00468380(0xffffffff, 0);\n                arg_ch[1] = arg_8h;\n                fcn.0046846d(0xffffffff, 0);\n                fcn.004683a4(arg_ch[1], arg_ch, 0);\n            }\n            uVar2 = argp & 0xffff;\n            uVar3 = argp >> 0x10;\n            if (uVar2 == 1) {\n                iVar1 = sub.WSOCK32.dll_ioctlsocket(arg_ch[1], 0x4004667f, &argp);\n                if (iVar1 == -1) {\n                    uVar3 = sub.WSOCK32.dll_WSAGetLastError();\n                }\n                if ((argp != 0) || (uVar3 != 0)) {\n                    (**(*arg_ch + 0x1c))(uVar3);\n                }\n            }\n            else if (uVar2 == 2) {\n                (**(*arg_ch + 0x20))(uVar3);\n            }\n            else if (uVar2 == 4) {\n                (**(*arg_ch + 0x24))(uVar3);\n            }\n            else if (uVar2 == 8) {\n                (**(*arg_ch + 0x28))(uVar3);\n            }\n            else if (uVar2 == 0x10) {\n                (**(*arg_ch + 0x2c))(uVar3);\n            }\n            else if (uVar2 == 0x20) {\n                (**(*arg_ch + 0x30))(uVar3);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 488
    },
    "0046862c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0046862c(int32_t param_1, uint param_2, uint param_3, uint param_4, uint param_5)\n\n{\n    int32_t arg_8h;\n    uint uVar1;\n    \n    arg_8h = sub.WSOCK32.dll_socket(param_5, param_2, param_4);\n    *(param_1 + 4) = arg_8h;\n    if (arg_8h == -1) {\n        uVar1 = 0;\n    }\n    else {\n        fcn.004683a4(arg_8h, param_1, 0);\n        uVar1 = fcn.00468315(param_5);\n    }\n    return uVar1;\n}\n",
        "token_count": 165
    },
    "004686a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool __thiscall fcn.004686a0(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = sub.WSOCK32.dll_connect(*(param_1 + 4), param_2, param_3);\n    return iVar1 != -1;\n}\n",
        "token_count": 74
    },
    "00468733": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00468733(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CSocket.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != 0xffffffff) {\n        fcn.004687c2();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00468351();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 196
    },
    "004687c2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004687c2(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != -1) {\n        fcn.004686fa();\n        fcn.00468315(0);\n        fcn.00468165();\n        *(param_1 + 4) = 0xffffffff;\n    }\n    return;\n}\n",
        "token_count": 80
    },
    "00468884": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00468884(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    do {\n        iVar1 = fcn.00468274(arg_8h, arg_ch, arg_10h);\n        if (iVar1 != -1) {\n            return iVar1;\n        }\n        iVar1 = sub.WSOCK32.dll_WSAGetLastError();\n    } while ((iVar1 == 0x2733) && (iVar1 = (**(*in_ECX + 0x44))(2),  iVar1 != 0));\n    return -1;\n}\n",
        "token_count": 148
    },
    "00401208": {
        "rules": [
            "PEB access/35f28d23090149119036cdb16976bf66"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __fastcall fcn.00401208(uint param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    uStack12 = 0x46b585;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_4h = 1;\n    fcn.00438b48(param_1);\n    var_4h = var_4h & 0xffffff00;\n    fcn.00438b48();\n    var_4h = 0xffffffff;\n    fcn.00439395();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 175
    },
    "00401398": {
        "rules": [
            "PEB access/35f28d23090149119036cdb16976bf66"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl fcn.00401398(uint arg_8h)\n\n{\n    uint *in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bac1;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0043976a(0x82, arg_8h);\n    var_4h = 0;\n    fcn.00401474();\n    var_4h._0_1_ = 1;\n    fcn.00401474();\n    var_4h = CONCAT31(var_4h._1_3_, 2);\n    *in_ECX = 0x4711f0;\n    in_ECX[0x17] = 0;\n    fcn.00438cd1(0x49b3f8);\n    fcn.00438cd1(0x49b3fc);\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 262
    },
    "00409d3f": {
        "rules": [
            "PEB access/35f28d23090149119036cdb16976bf66"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409d3f(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.00401410(arg_8h);\n    fcn.0044c421(arg_8h, 0x3e9, in_ECX + 0x5c);\n    fcn.0044c9f3(arg_8h, *(in_ECX + 0x5c), 0, 99);\n    fcn.0044c4dd(arg_8h, 1000, in_ECX + 0x60);\n    fcn.0044cae6(arg_8h, in_ECX + 0x60, 0x32);\n    fcn.0044c4dd(arg_8h, 0x3ea, in_ECX + 100);\n    fcn.0044cae6(arg_8h, in_ECX + 100, 0xff);\n    return;\n}\n",
        "token_count": 218
    },
    "004472e7": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004472e7(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h, int32_t *arg_18h)\n\n{\n    uint16_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    uint var_40h;\n    uint var_38h;\n    uint var_30h;\n    uint var_28h;\n    uint var_20h;\n    uint var_18h;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = *(arg_10h + 4);\n    if (uVar1 < 0x20c) {\n        if (uVar1 == 0x20b) {\n            fcn.00446b78(&var_10h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x1e) {\n            (**(*arg_18h + 0x1c))();\n            return 1;\n        }\n        if (uVar1 == 0x103) {\n            (**(*arg_18h + 0x34))(*(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x127) {\n            (**(*arg_18h + 0x20))(*(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x12d) {\n            uVar5 = *(arg_ch + *(arg_10h + 6) * 4);\n            iVar3 = (*_sym.imp.GDI32.dll_GetObjectType)(uVar5);\n            if (iVar3 == 0) {\n                var_4h = (*_sym.imp.GDI32.dll_GetStockObject)(0xd);\n                pcVar2 = _sym.imp.GDI32.dll_SelectObject;\n                uVar4 = (*_sym.imp.GDI32.dll_SelectObject)(arg_18h[1], var_4h);\n                var_8h = (*pcVar2)(arg_18h[1], uVar5);\n                if (var_8h == var_4h) {\n                    iVar3 = *arg_18h;\n                    uVar5 = fcn.004478c5(uVar5);\n                    (**(iVar3 + 0x28))(uVar5);\n                    return 1;\n                }\n                (*pcVar2)(arg_18h[1], uVar4);\n                (*pcVar2)(arg_18h[1], var_8h);\n            }\n            else if (iVar3 == 6) {\n                iVar3 = *arg_18h;\n                uVar5 = fcn.004478c5(uVar5);\n                (**(iVar3 + 0x28))(uVar5);\n                return 1;\n            }\n        }\n        else {\n            if (uVar1 == 0x201) {\n                (**(*arg_18h + 0x2c))(*(arg_10h + 6));\n                return 1;\n            }\n            if (uVar1 == 0x209) {\n                (**(*arg_18h + 0x30))(*(arg_10h + 6));\n                return 1;\n            }\n        }\n    }\n    else {\n        if (uVar1 == 0x20c) {\n            (**(*arg_18h + 0x48))(&var_40h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x20d) {\n            (**(*arg_18h + 0x38))(&var_38h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x20e) {\n            (**(*arg_18h + 0x40))(&var_30h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x211) {\n            (**(*arg_18h + 0x3c))(&var_28h, *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x410) {\n            (**(*arg_18h + 0x4c))(&var_20h, *(arg_10h + 0xc), *(arg_10h + 10), *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n        if (uVar1 == 0x412) {\n            (**(*arg_18h + 0x44))(&var_18h, *(arg_10h + 0xc), *(arg_10h + 10), *(arg_10h + 8), *(arg_10h + 6));\n            return 1;\n        }\n    }\n    (*_sym.imp.GDI32.dll_PlayMetaFileRecord)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return 1;\n}\n",
        "token_count": 1181
    },
    "004014ab": {
        "rules": [
            "64-bit execution via heavens gate/d0eb93f2c5e64800b89b59bc3f7592fa"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004014ab(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    if (*(param_1 + 4) == '\\0') {\n        fcn.0040132f();\n    }\n    return param_1 + 5;\n}\n",
        "token_count": 64
    },
    "0040c37c": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040c37c(int32_t *param_1, uint param_2)\n\n{\n    *param_1 = param_2;\n    param_1[1] = param_2 >> 0x10;\n    return;\n}\n",
        "token_count": 58
    },
    "00438bb6": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00438bb6(uint *param_1, uint32_t param_2)\n\n{\n    int32_t arg_10h;\n    \n    *param_1 = *0x498098;\n    if (param_2 != 0) {\n        if (param_2 >> 0x10 == 0) {\n            fcn.0043a377(param_2 & 0xffff);\n        }\n        else {\n            arg_10h = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_2);\n            if (arg_10h != 0) {\n                fcn.004389b5(arg_10h);\n                fcn.0040cd30(*param_1, param_2, arg_10h);\n            }\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 179
    },
    "0043aa05": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.0043aa05(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.00462aba(0x460619);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x44) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x48) = uVar2;\n    *(iVar1 + 0x4c) = uVar2 >> 0x10;\n    return iVar1 + 0x34;\n}\n",
        "token_count": 138
    },
    "0043abb5": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0043abb5(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint hWnd)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint arg_8h;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar4;\n    uint Msg;\n    uint wParam;\n    uint lParam;\n    uint var_10h;\n    uint var_30h;\n    uint var_1ch;\n    uint lpPrevWndFunc;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffb4;\n    uVar1 = (*_sym.imp.USER32.dll_GetPropA)(uVar2, \"AfxOldWndProc423\");\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x18) = uVar1;\n    iVar3 = *(unaff_EBP + 0xc);\n    bVar4 = true;\n    if (iVar3 == 6) {\n        uVar1 = fcn.0043aad3(*(unaff_EBP + 0x14));\n        arg_8h = fcn.0043aad3(uVar2);\n        fcn.0043a83b(arg_8h, *(unaff_EBP + 0x10), uVar1);\ncode_r0x0043acb9:\n        if (!bVar4) goto code_r0x0043ac46;\n    }\n    else {\n        if (iVar3 == 0x20) {\n            uVar1 = fcn.0043aad3(uVar2);\n            iVar3 = fcn.0043a89c(uVar1, *(unaff_EBP + 0x14), *(unaff_EBP + 0x14) >> 0x10);\n            bVar4 = iVar3 == 0;\n            goto code_r0x0043acb9;\n        }\n        if (iVar3 == 0x82) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(uVar2, 0xfffffffc, *(unaff_EBP + -0x18));\n            (*_sym.imp.USER32.dll_RemovePropA)(uVar2, \"AfxOldWndProc423\");\n            uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(\"AfxOldWndProc423\");\n            (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar1);\n        }\n        else if (iVar3 == 0x110) {\n            uVar1 = fcn.0043aad3(uVar2);\n            fcn.0043a79f(uVar1, unaff_EBP + -0x30, unaff_EBP + -0x1c);\n            uVar2 = (*_sym.imp.USER32.dll_CallWindowProcA)\n                              (*(unaff_EBP + -0x18), uVar2, 0x110, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n            *(unaff_EBP + -0x14) = uVar2;\n            fcn.0043a7c2(uVar1, unaff_EBP + -0x30);\n            goto code_r0x0043ac46;\n        }\n    }\n    uVar2 = (*_sym.imp.USER32.dll_CallWindowProcA)\n                      (*(unaff_EBP + -0x18), uVar2, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    *(unaff_EBP + -0x14) = uVar2;\ncode_r0x0043ac46:\n    uVar2 = *(unaff_EBP + -0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 1010
    },
    "0043c07d": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043c07d(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == 0) {\n        if (uVar3 == 0) {\n            return 0;\n        }\n        fcn.0043c04a();\n        var_28h = uVar3;\n        (**(*in_ECX + 0xc))(uVar3, 0xffffffff, &var_2ch, 0);\n        if (var_4h != 0) {\n            arg_8h = 0;\ncode_r0x0043c0c1:\n            uVar1 = (**(*in_ECX + 0xc))(uVar3, arg_8h, 0, 0);\n            return uVar1;\n        }\n    }\n    else {\n        iVar2 = fcn.00462aba(0x460619);\n        if ((*(iVar2 + 0xb8) != in_ECX[7]) && (iVar2 = fcn.0043ca54(arg_ch, 0),  iVar2 == 0)) {\n            if (uVar3 == 0) {\n                return 0;\n            }\n            goto code_r0x0043c0c1;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 366
    },
    "0043cb53": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043cb53(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0x112) {\n        if (arg_8h == 0x111) {\n            iVar2 = fcn.004384b7(0, arg_ch >> 0x10 | 0xbd110000, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 1;\n                return 1;\n            }\n            return 1;\n        }\n        if (0x2a < arg_8h) {\n            if ((arg_8h < 0x30) || (arg_8h == 0x39)) goto code_r0x0043cbe7;\n            if (arg_8h == 0x4e) {\n                var_8h = arg_14h;\n                var_4h = arg_10h;\n                uVar1 = fcn.004384b7(0, *(arg_10h + 8) & 0xffff | 0xbc4e0000, &var_8h, 0);\n                return uVar1;\n            }\n        }\n    }\n    else if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) {\ncode_r0x0043cbe7:\n        uVar1 = fcn.0043bad8(arg_8h + 0xbc00, arg_ch, arg_10h, arg_14h);\n        return uVar1;\n    }\n    if ((0x131 < arg_8h) && (arg_8h < 0x139)) {\n        var_4h = arg_8h - 0x132;\n        var_8h = arg_ch;\n        uVar1 = fcn.0043bad8(0xbc19, 0, &var_ch, arg_14h);\n        if (*arg_14h != 0) {\n            return uVar1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 537
    },
    "0043e50e": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint fcn.0043e50e(int32_t param_1)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if ((((*(param_1 + 4) == 0x100) && (*(param_1 + 8) == 0x70)) && ((*(param_1 + 0xc) >> 0x10 & 0x4000) == 0)) &&\n       (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x10),  -1 < iVar2 && (iVar2 = (*pcVar1)(0x11),  -1 < iVar2)) &&\n        (iVar2 = (*pcVar1)(0x12),  -1 < iVar2)))) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 191
    },
    "0043fc00": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043fc00(uint lpString2, uint nNumber, uint arg_10h, uint arg_14h, uint *arg_18h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t var_80h;\n    uint var_70h;\n    uint var_69h;\n    uint lpString1;\n    int32_t lptm;\n    int32_t var_34h;\n    int32_t var_ch;\n    uint32_t var_4h;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n    fcn.0040d6f0(&var_80h, 0, 0x3c);\n    uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a, 0x48);\n    var_80h = (*_sym.imp.KERNEL32.dll_MulDiv)(nNumber, uVar4);\n    var_70h = 400;\n    var_80h = -var_80h;\n    var_69h._0_1_ = 1;\n    (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, lpString2);\n    iVar5 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&var_80h);\n    pcVar2 = _sym.imp.USER32.dll_GetDialogBaseUnits;\n    pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n    if (iVar5 == 0) {\n        uVar6 = (*_sym.imp.USER32.dll_GetDialogBaseUnits)();\n        uVar6 = uVar6 & 0xffff;\n        uVar7 = (*pcVar2)();\n        uVar7 = uVar7 >> 0x10;\n    }\n    else {\n        uVar4 = (*_sym.imp.GDI32.dll_SelectObject)(uVar3, iVar5);\n        (*_sym.imp.GDI32.dll_GetTextMetricsA)(uVar3, &lptm);\n        uVar7 = var_34h + lptm;\n        (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                  (uVar3, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 0x34, &var_ch);\n        var_4h = (var_ch + 0x1a) / 0x34;\n        (*pcVar1)(uVar3, uVar4);\n        (*_sym.imp.GDI32.dll_DeleteObject)(iVar5);\n        uVar6 = var_4h;\n    }\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_10h, uVar6, 4);\n    *arg_18h = uVar3;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_14h, uVar7, 8);\n    arg_18h[1] = uVar3;\n    return;\n}\n",
        "token_count": 703
    },
    "004500c9": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004500c9(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_14h;\n    char var_ch;\n    uint var_bh;\n    \n    fcn.0044fedf(arg_8h, &var_14h);\n    cVar1 = arg_ch >> 0x10;\n    if ((var_bh != arg_ch) || (var_ch != cVar1)) {\n        var_ch = cVar1;\n        var_bh._0_1_ = arg_ch;\n        fcn.0044fefe(arg_8h, &var_14h);\n        *(in_ECX + 0x84) = 1;\n    }\n    return;\n}\n",
        "token_count": 175
    },
    "0045088c": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0045088c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_28h;\n    uint var_14h;\n    uint var_10h;\n    uchar var_ch;\n    uint var_bh;\n    \n    fcn.0044fedf(arg_8h, &var_14h);\n    fcn.0040cd30(&var_28h, &var_14h, 0x14);\n    var_10h = arg_ch;\n    var_14h = arg_14h;\n    var_bh._0_1_ = arg_10h;\n    var_ch = arg_10h >> 0x10;\n    iVar1 = fcn.0040d9b0(&var_28h, &var_14h, 0x14);\n    if (iVar1 != 0) {\n        fcn.0044fefe(arg_8h, &var_14h);\n        *(in_ECX + 0x84) = 1;\n    }\n    return;\n}\n",
        "token_count": 263
    },
    "00450cf0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00450cf0(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint uVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 0;\n    uVar2 = 0;\n    if (0x40046 < *0x49851c) {\n        uVar2 = fcn.00439ecc();\n        iVar3 = fcn.00439f00(0, 0x8800, 0);\n    }\n    iVar1 = fcn.0043aa3a();\n    if (iVar1 != 0) {\n        *arg_8h = arg_ch;\n        arg_8h[1] = arg_ch >> 0x10;\n    }\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(in_ECX + 0x1c), 0xfffffff0, uVar2);\n    }\n    return iVar1;\n}\n",
        "token_count": 235
    },
    "00452c2a": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.00452c2a(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(*(param_1 + 0x80) + param_2 * 4);\n    return uVar1 & -(uVar1 >> 0x10 != 0);\n}\n",
        "token_count": 83
    },
    "0046016f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.0046016f(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint lpvBits;\n    int32_t nHeight;\n    int32_t var_8h;\n    uint8_t *var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    nHeight = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < nHeight) {\n        nHeight = 0x20;\n    }\n    fcn.0040d6f0(&lpvBits, 0xff, 0x80);\n    var_4h = 0x471c74;\n    var_8h = 5;\n    puVar4 = &lpvBits + (nHeight + -6 >> 1) * iVar6 * 2;\n    do {\n        uVar1 = *var_4h;\n        uVar3 = var_4h & 0xffff0000;\n        var_4h = var_4h + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        puVar4[1] = uVar3;\n        *puVar4 = uVar3 >> 8;\n        puVar4 = puVar4 + iVar6 * 2;\n        var_8h = var_8h + -1;\n    } while (var_8h != 0);\n    *0x49d0d8 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, nHeight, 1, 1, &lpvBits);\n    if (*0x49d0d8 == 0) {\n        *0x49d0d8 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    return;\n}\n",
        "token_count": 537
    },
    "004302b0": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.004302b0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0043976a(0, *(unaff_EBP + 0x10));\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0x17] = extraout_ECX + 0x18;\n    *extraout_ECX = vtable.CPrintDialog.0;\n    fcn.0040d6f0(extraout_ECX + 0x18, 0, 0x42);\n    uVar1 = *(unaff_EBP + 0xc);\n    *extraout_ECX[0x17] = 0x42;\n    *(extraout_ECX[0x17] + 0x14) = uVar1;\n    if (*0x49d0e4 == 0) {\n        iVar2 = fcn.00439a8a();\n        if (iVar2 != 0) {\n            extraout_ECX[0x17][0x15] = extraout_ECX[0x17][0x15] | 0x38;\n            *(extraout_ECX[0x17] + 0x2a) = fcn.00430f80;\n            *(extraout_ECX[0x17] + 0x2e) = fcn.00430f80;\n        }\n    }\n    if (*(unaff_EBP + 8) == 0) {\n        extraout_ECX[0xf] = 0x7008;\n        extraout_ECX[0x17][0x15] = extraout_ECX[0x17][0x15] | 1;\n    }\n    else {\n        extraout_ECX[0xf] = 0x7009;\n        *(extraout_ECX[0x17] + 0x14) = *(extraout_ECX[0x17] + 0x14) | 0x40;\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[0x17][0x15] = extraout_ECX[0x17][0x15] & 0xfd;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 636
    },
    "00452073": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00452073(int32_t arg_8h, int32_t lprcSrc)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint arg_ch;\n    uint var_12ch;\n    uint lpRect;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t lprcDst;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n    if (*(arg_8h + 0x70) == in_ECX) {\n        if (lprcSrc == 0) {\n            return;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprcSrc);\n        if (iVar3 != 0) {\n            return;\n        }\n    }\n    if ((*(in_ECX + 0x78) != 0) && ((*(arg_8h + 0x68) & 0x40) != 0)) {\n        *(in_ECX + 100) = *(in_ECX + 100) | 0x40;\n    }\n    *(in_ECX + 100) = *(in_ECX + 100) & 0xfffffff9;\n    uVar4 = *(in_ECX + 100);\n    *(in_ECX + 100) = *(arg_8h + 100) & 6 | uVar4;\n    if ((uVar4 & 0x40) == 0) {\n        fcn.00439f89(&var_12ch, 0x104);\n        fcn.00447c97(*(in_ECX + 0x1c), &var_12ch);\n    }\n    uVar4 = *(arg_8h + 100);\n    uVar2 = uVar4 >> 8;\n    uVar1 = CONCAT11((*(in_ECX + 100) >> 8 ^ uVar2) & 0xf0 ^ uVar2, uVar4);\n    if (*(in_ECX + 0x78) == 0) {\n        uVar4 = uVar4 & 0xffff0000 | uVar1 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar4 = uVar4 & 0xffff0000 | uVar1 | 0xf01;\n    }\n    fcn.00461602(uVar4);\n    var_18h = 0;\n    if ((*(arg_8h + 0x70) != in_ECX) && (iVar3 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(arg_8h + 0x1c)),  iVar3 != 0))\n    {\n        fcn.0043a058(0, 0, 0, 0, 0, 0x97);\n        var_18h = 1;\n    }\n    var_14h = 0xffffffff;\n    if (lprcSrc == 0) {\n        fcn.0043565c(*(in_ECX + 0x84), arg_8h);\n        fcn.0043565c(*(in_ECX + 0x84), 0);\n        fcn.0043a058(0, -*0x49d098, -*0x49d09c, 0, 0, 0x115);\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, lprcSrc);\n        fcn.00447040(&lprcDst);\n        var_14h = fcn.00452c46(arg_8h, lprcDst, var_ch, var_8h, var_4h, (var_8h - lprcDst) / 2 + lprcDst, \n                               (var_4h - var_ch) / 2 + var_ch);\n        fcn.0043a058(0, lprcDst, var_ch, var_8h - lprcDst, var_4h - var_ch, 0x114);\n    }\n    uVar5 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x1c));\n    iVar3 = fcn.0043aad3(uVar5);\n    if (iVar3 != in_ECX) {\n        if (in_ECX == 0) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(in_ECX + 0x1c);\n        }\n        uVar5 = (*_sym.imp.USER32.dll_SetParent)(*(arg_8h + 0x1c), uVar5);\n        fcn.0043aad3(uVar5);\n    }\n    iVar3 = *(arg_8h + 0x70);\n    if (iVar3 == in_ECX) {\n        uVar5 = 0;\n        arg_ch = var_14h;\n    }\n    else {\n        if (iVar3 == 0) goto code_r0x0045226b;\n        if ((*(in_ECX + 0x78) == 0) || (*(iVar3 + 0x78) != 0)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = 1;\n        }\n        arg_ch = 0xffffffff;\n    }\n    fcn.004524e6(arg_8h, arg_ch, uVar5);\ncode_r0x0045226b:\n    *(arg_8h + 0x70) = in_ECX;\n    if (var_18h != 0) {\n        fcn.0043a058(0, 0, 0, 0, 0, 0x57);\n    }\n    fcn.00452485(arg_8h);\n    iVar3 = fcn.0045bd43();\n    *(iVar3 + 0xb8) = *(iVar3 + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 1370
    },
    "0041af8e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3ch\n\ncode ** fcn.0041af8e(void)\n\n{\n    uchar *arg_8h;\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_3ch;\n    uint var_20h;\n    uint var_dh;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x20) = *(unaff_EBP + -0xd);\n    fcn.004013e8(0);\n    uVar1 = fcn.0040d070(\"string too long\");\n    fcn.0040148d(\"string too long\", uVar1);\n    *(unaff_EBP + -4) = 0;\n    fcn.0041afe8(unaff_EBP + -0x20);\n    *(unaff_EBP + -0x3c) = vtable.std::length_error.0;\n    fcn.0040d1e1(unaff_EBP + -0x3c, 0x47f120);\n    fcn.0040d954();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -0x10) = 0x474650;\n    fcn.0040d118(unaff_EBP + -0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 3) = *arg_8h;\n    fcn.004013e8(0);\n    fcn.0041ad78(arg_8h, 0, *0x4711c4);\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::logic_error.0;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 450
    },
    "0041b1ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3ch\n\nvoid fcn.0041b1ba(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    int32_t arg_8h;\n    code **ppcVar2;\n    uint var_3ch;\n    uint var_20h;\n    uint var_dh;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x20) = *(unaff_EBP + -0xd);\n    fcn.004013e8(0);\n    uVar1 = fcn.0040d070(\"invalid string position\");\n    fcn.0040148d(\"invalid string position\", uVar1);\n    *(unaff_EBP + -4) = 0;\n    fcn.0041afe8(unaff_EBP + -0x20);\n    arg_8h = unaff_EBP + -0x3c;\n    *(unaff_EBP + -0x3c) = vtable.std::out_of_range.0;\n    fcn.0040d1e1(arg_8h, 0x47f248);\n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::logic_error.0;\n    *(unaff_EBP + -4) = 0;\n    uVar1 = 1;\n    ppcVar2 = extraout_ECX;\n    fcn.004013e8(1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040d1be(uVar1, arg_8h, ppcVar2);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 421
    },
    "0043b05b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.0043b05b(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    bool bVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpWindowName;\n    uint lpClassName;\n    uint dwExStyle;\n    \n    dwExStyle = arg_8h;\n    lpClassName = arg_ch;\n    lpWindowName = arg_10h;\n    var_10h = arg_14h;\n    var_14h = arg_18h;\n    var_18h = arg_1ch;\n    var_1ch = arg_20h;\n    var_20h = arg_24h;\n    var_24h = arg_28h;\n    var_28h = arg_2ch;\n    iVar1 = fcn.00460591();\n    var_2ch = *(iVar1 + 8);\n    var_30h = arg_30h;\n    iVar1 = (**(*in_ECX + 0x5c))(&var_30h);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0xa4))();\n        bVar3 = false;\n    }\n    else {\n        fcn.0043af86();\n        iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                          (dwExStyle, lpClassName, lpWindowName, var_10h, var_14h, var_18h, var_1ch, var_20h, var_24h, \n                           var_28h, var_2ch, var_30h);\n        iVar2 = fcn.0043afd2();\n        if (iVar2 == 0) {\n            (**(*in_ECX + 0xa4))();\n        }\n        bVar3 = iVar1 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 527
    },
    "0043b7bc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0043b7bc(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpWndClass;\n    uint var_ah;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffc4;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x38);\n    if (iVar4 == 0) {\n        iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n        if (iVar3 == 0) {\n            uVar5 = 0;\n            goto code_r0x0043b83c;\n        }\n        iVar4 = fcn.00460591();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.0046255d(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.00460591();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            (*_sym.imp.KERNEL32.dll_lstrcatA)(iVar4 + 0x34, *(iVar1 + 0x24));\n            *(unaff_EBP + 10) = 10;\n            *(unaff_EBP + 0xb) = 0;\n            (*pcVar2)(iVar4 + 0x34, unaff_EBP + 10);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004625cd(1);\n        }\n    }\n    uVar5 = 1;\ncode_r0x0043b83c:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 573
    },
    "0043f46d": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint fcn.0043f46d(int32_t param_1)\n\n{\n    uint uStack4;\n    \n    if (param_1 < 0x17) {\n        if (param_1 == 0x16) {\n            return 10;\n        }\n        if (param_1 != 1) {\n            if (param_1 == 2) goto code_r0x0043f4bd;\n            if (param_1 == 5) {\n                return 10;\n            }\n            if (param_1 == 9) {\n                return 6;\n            }\n            if (param_1 != 0xd) {\n                return 1;\n            }\n        }\n        uStack4 = 5;\n    }\n    else {\n        if (param_1 != 0x17) {\n            if (param_1 == 0x18) {\n                return 4;\n            }\n            if (param_1 != 0x1c) {\n                if (param_1 != 0x24) {\n                    return 1;\n                }\n                return 0xb;\n            }\n            return 0xd;\n        }\ncode_r0x0043f4bd:\n        uStack4 = 2;\n    }\n    return uStack4;\n}\n",
        "token_count": 270
    },
    "0040c915": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040c915(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.0041022a(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 104
    },
    "0042fb63": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042fb63(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    int32_t var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = (arg_ch & 0x1f) << 1;\n    var_1ch = arg_ch >> 0xb;\n    var_20h = arg_ch >> 5 & 0xf83f;\n    var_18h = arg_8h & 0x1f;\n    var_10h = (arg_8h >> 9) + 0x50;\n    var_4h = arg_10h;\n    var_14h = (arg_8h >> 5 & 0xf80f) - 1;\n    uVar1 = fcn.0040f0dc(&var_24h);\n    *in_ECX = uVar1;\n    return;\n}\n",
        "token_count": 265
    },
    "0043308e": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043308e(int32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_18h;\n    uint var_10h;\n    uint32_t lpPoint;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    puVar3 = arg_ch;\n    puVar4 = &var_24h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    var_24h = (*_sym.imp.USER32.dll_SendMessageA)(*(arg_8h + 0x1c), 0x410, 0, &var_10h);\n    lpPoint = arg_ch[5];\n    var_4h = arg_ch[6];\n    if ((0x1ff < var_20h) && (var_20h < 0x20a)) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(var_24h, &lpPoint);\n    }\n    var_18h = lpPoint & 0xffff | var_4h << 0x10;\n    (*pcVar1)(*(arg_8h + 0x1c), 0x407, 0, &var_24h);\n    return;\n}\n",
        "token_count": 371
    },
    "004500a6": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.004500a6(uint arg_8h)\n\n{\n    uint var_14h;\n    uint var_ch;\n    \n    fcn.0044fedf(arg_8h, &var_14h);\n    return var_ch << 0x10 | var_ch._1_1_;\n}\n",
        "token_count": 80
    },
    "00450854": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00450854(uint arg_8h, uint *arg_ch, uint32_t *arg_10h, uint *arg_14h)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    fcn.0044fedf(arg_8h, &var_14h);\n    *arg_ch = var_10h;\n    *arg_10h = var_ch << 0x10 | var_ch._1_1_;\n    *arg_14h = var_14h;\n    return;\n}\n",
        "token_count": 135
    },
    "0045bc21": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0045bc21(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x11);\n    if (iVar2 < 0) {\n        uVar7 = 8;\n    }\n    else {\n        uVar7 = 0;\n    }\n    iVar2 = (*pcVar1)(0x10);\n    if (iVar2 < 0) {\n        uVar3 = 4;\n    }\n    else {\n        uVar3 = 0;\n    }\n    iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    if (iVar4 == 0) {\n        iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x20a, arg_8h << 0x10 | uVar7 | uVar3, arg_ch);\n    }\n    else {\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x20a, arg_8h << 0x10 | uVar7 | uVar3, arg_ch);\n            iVar4 = (*_sym.imp.USER32.dll_GetParent)(iVar4);\n            if (iVar6 != 0) {\n                return iVar6;\n            }\n            if (iVar4 == 0) {\n                return 0;\n            }\n        } while (iVar4 != iVar5);\n    }\n    return iVar6;\n}\n",
        "token_count": 420
    },
    "0046114b": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0046114b(uint32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x1c));\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (iVar2 == 0) {\n        *(in_ECX + 0x90) = arg_8h;\n        *(in_ECX + 0x94) = arg_ch;\n        *(in_ECX + 0x88) = arg_10h;\n        *(in_ECX + 0x8c) = arg_14h;\n    }\n    else {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x420, 0, arg_10h & 0xffff | arg_14h << 0x10);\n        (*pcVar1)(*(in_ECX + 0x1c), 0x41f, 0, arg_8h & 0xffff | arg_ch << 0x10);\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 315
    },
    "00436fc3": {
        "rules": [
            "hash data using djb2/6ad21e310d674441ba35d7276afbe57d",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00436fc3(int32_t param_1, char *param_2, uint32_t *param_3)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char cVar4;\n    char *pcVar5;\n    uint *puVar6;\n    \n    uVar2 = 0;\n    cVar4 = *param_2;\n    pcVar5 = param_2;\n    while (cVar4 != '\\0') {\n        uVar2 = uVar2 * 0x21 + cVar4;\n        pcVar1 = pcVar5 + 1;\n        pcVar5 = pcVar5 + 1;\n        cVar4 = *pcVar1;\n    }\n    uVar2 = uVar2 % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar6 = *(*(param_1 + 4) + uVar2 * 4); puVar6 != NULL; puVar6 = *puVar6) {\n            iVar3 = fcn.0040dd23(puVar6[2], param_2);\n            if (iVar3 == 0) {\n                return puVar6;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 301
    },
    "004460dd": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.004460dd(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00445b68();\n    uVar1 = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 0x40) = uVar1;\n    *(unaff_EBP + -4) = 1;\n    fcn.00438cd1(*(unaff_EBP + 8));\n    uVar1 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 0x44) = *(unaff_EBP + 0xc);\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 255
    },
    "0045864b": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0045864b(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEditView.0;\n    pcVar1 = extraout_ECX[0x13];\n    *(unaff_EBP + -4) = 1;\n    fcn.00438360(pcVar1);\n    *(unaff_EBP + -4) = 0;\n    fcn.00435110();\n    *(unaff_EBP + -4) = 2;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00445b78();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 249
    },
    "00462192": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint fcn.00462192(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x49d0dc = (uVar2 >> 8 & 0xff) + (uVar2 & 0xff) * 0x100;\n    *0x49d0e0 = uVar2 >> 0x1f;\n    *0x49d0e4 = 3 < uVar2;\n    *0x49d0e8 = 1 - *0x49d0e4;\n    *0x49d0f0 = 0;\n    *0x49d0ec = *0x49d0e4;\n    if (*0x49d0e4 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessVersion)(0);\n        *0x49d0f0 = 0x3ffff < uVar2;\n    }\n    fcn.0043f2c5();\n    *0x49d0ac = 0;\n    fcn.0043f281();\n    pcVar1 = _sym.imp.USER32.dll_LoadCursorA;\n    *0x49d0c4 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f02);\n    *0x49d0c8 = (*pcVar1)(0, 0x7f00);\n    *0x49d098 = (*0x49d0e4 != 0) + 1;\n    *0x49d09c = *0x49d098;\n    *0x49d0cc = 0;\n    *0x49d0d8 = 0;\n    return 0x49d088;\n}\n",
        "token_count": 402
    },
    "00460a3c": {
        "rules": [
            "check for trap flag exception/d5d4160e77a5474aa5157e4631e4f1b3"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00460a3c(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    uint lprc;\n    \n    uVar2 = CONCAT31(arg_10h >> 8 & 0xffbf00, 0x4e);\n    *(in_ECX + 100) = arg_10h & 0x40ffff;\n    uVar1 = fcn.00439ecc();\n    if ((uVar1 & 0x40000) != 0) {\n        uVar2 = uVar2 | 0x100;\n    }\n    fcn.0043d76a(0x1000);\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n    fcn.0043b141(\"msctls_statusbar32\", 0, arg_ch | uVar2, &lprc, arg_8h, arg_14h, 0);\n    return;\n}\n",
        "token_count": 244
    },
    "00401028": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401028(uint arg_8h)\n\n{\n    uint arg_ch;\n    uint var_4h;\n    \n    arg_ch = fcn.004014b5(arg_8h);\n    fcn.0040148d(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 66
    },
    "00401032": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401032(uint arg_8h)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b9e9;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    *0x49b3ec = arg_8h;\n    fcn.004013c0();\n    fcn.0040d2e1(0x4010cd);\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 194
    },
    "0040104b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040104b(uint *param_1)\n\n{\n    uint var_4h;\n    \n    *param_1 = 0x471170;\n    fcn.0040105a();\n    return;\n}\n",
        "token_count": 51
    },
    "0040106e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040106e(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00401109();\n    if (iVar1 != 0) {\n        uVar2 = fcn.00401109();\n        uVar3 = fcn.004013b6();\n        if (uVar2 < uVar3) {\n            uVar4 = fcn.00401109();\n            uVar4 = fcn.004012b7(uVar4);\n            return uVar4;\n        }\n    }\n    uVar4 = (**(*param_1 + 0x10))();\n    return uVar4;\n}\n",
        "token_count": 184
    },
    "0040108c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0040108c(uint *arg_8h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint var_24h;\n    uint var_20h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar4 = fcn.0041d2bf(&var_20h);\n    uVar1 = puVar4[1];\n    uVar2 = puVar4[2];\n    uVar3 = puVar4[3];\n    *arg_8h = *puVar4;\n    arg_8h[1] = uVar1;\n    arg_8h[2] = uVar2;\n    arg_8h[3] = uVar3;\n    return arg_8h;\n}\n",
        "token_count": 197
    },
    "00401091": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401091(ushort *arg_8h)\n\n{\n    int32_t in_ECX;\n    uint32_t uVar1;\n    uint var_4h;\n    \n    uVar1 = *(in_ECX + 0x24) + 2;\n    if (*(in_ECX + 0x28) <= uVar1 && uVar1 != *(in_ECX + 0x28)) {\n        fcn.004458d8(2 - (*(in_ECX + 0x28) - *(in_ECX + 0x24)));\n    }\n    *arg_8h = **(in_ECX + 0x24);\n    *(in_ECX + 0x24) = *(in_ECX + 0x24) + 2;\n    return in_ECX;\n}\n",
        "token_count": 181
    },
    "004066f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.004066f0(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    for (; arg_8h != arg_ch; arg_8h = arg_8h + 1) {\n        cVar1 = fcn.0041d158(*arg_8h, in_ECX + 8);\n        *arg_8h = cVar1;\n    }\n    return arg_8h;\n}\n",
        "token_count": 118
    },
    "004010fa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __fastcall fcn.004010fa(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bc3b;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00459b8b();\n    var_4h = 0;\n    fcn.0044d28a();\n    var_4h._0_1_ = 1;\n    fcn.00460992();\n    var_4h = CONCAT31(var_4h._1_3_, 2);\n    fcn.00460f17();\n    *param_1 = 0x471590;\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 211
    },
    "004010ff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004010ff(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    return **(param_1 + 0x20) + **(param_1 + 0x30);\n}\n",
        "token_count": 54
    },
    "00401104": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401104(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    *(param_1 + 8) = 0;\n    fcn.00438cd1(0x49b408);\n    fcn.0043487d();\n    return;\n}\n",
        "token_count": 67
    },
    "00401118": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401118(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    **(in_ECX + 0x2c) = **(in_ECX + 0x2c) - arg_8h;\n    **(in_ECX + 0x1c) = **(in_ECX + 0x1c) + arg_8h;\n    return;\n}\n",
        "token_count": 103
    },
    "0040111d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040111d(int32_t param_1)\n\n{\n    uint uVar1;\n    uint var_4h;\n    \n    **(param_1 + 0x2c) = **(param_1 + 0x2c) + -1;\n    uVar1 = **(param_1 + 0x1c);\n    **(param_1 + 0x1c) = **(param_1 + 0x1c) + 1;\n    return uVar1;\n}\n",
        "token_count": 117
    },
    "004011db": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004011db(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00401109();\n    if (iVar1 != 0) {\n        uVar2 = fcn.00401109();\n        uVar3 = fcn.004013b6();\n        if (uVar2 < uVar3) {\n            uVar4 = fcn.0040111d();\n            uVar4 = fcn.004012b7(uVar4);\n            return uVar4;\n        }\n    }\n    uVar4 = (**(*param_1 + 0x14))();\n    return uVar4;\n}\n",
        "token_count": 184
    },
    "004042e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004042e0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint arg_ch;\n    uint arg_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00401109();\n    if (iVar1 == 0) {\n        fcn.004015d2();\n        return;\n    }\n    uVar2 = fcn.00401109();\n    uVar3 = fcn.004013b6();\n    if (uVar3 <= uVar2) {\n        if (((*(param_1 + 0x44) & 4) == 0) && (iVar1 = fcn.0040142e(),  iVar1 != 0)) {\n            uVar2 = fcn.0040142e();\n            uVar3 = fcn.00401109();\n            if ((uVar3 < uVar2) || (uVar2 = fcn.00401109(),  uVar2 <= *(param_1 + 0x3c) && *(param_1 + 0x3c) != uVar2))\n            {\n                uVar2 = fcn.0040142e();\n                if (*(param_1 + 0x3c) < uVar2) {\n                    uVar4 = fcn.0040142e();\n                    *(param_1 + 0x3c) = uVar4;\n                }\n                uVar4 = *(param_1 + 0x3c);\n                arg_ch = fcn.00401109();\n                arg_8h = fcn.004013c5();\n                fcn.00401532(arg_8h, arg_ch, uVar4);\n                uVar4 = fcn.00401109();\n                fcn.004012b7(uVar4);\n                return;\n            }\n        }\n        fcn.004015d2();\n        return;\n    }\n    uVar4 = fcn.00401109();\n    fcn.004012b7(uVar4);\n    return;\n}\n",
        "token_count": 463
    },
    "0040120d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040120d(int32_t param_1)\n\n{\n    uint uVar1;\n    uint var_4h;\n    \n    **(param_1 + 0x30) = **(param_1 + 0x30) + -1;\n    uVar1 = **(param_1 + 0x20);\n    **(param_1 + 0x20) = **(param_1 + 0x20) + 1;\n    return uVar1;\n}\n",
        "token_count": 112
    },
    "0040122b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0040122b(code **param_1)\n\n{\n    uint var_4h;\n    \n    fcn.004012fd(0);\n    param_1[9] = NULL;\n    *param_1 = vtable.std::ios_base.0;\n    return param_1;\n}\n",
        "token_count": 69
    },
    "00406770": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.00406770(char *arg_8h, char *arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    for (; arg_8h != arg_ch; arg_8h = arg_8h + 1) {\n        cVar1 = fcn.0041d367(*arg_8h, in_ECX + 8);\n        *arg_8h = cVar1;\n    }\n    return arg_8h;\n}\n",
        "token_count": 117
    },
    "00401244": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401244(uint arg_8h)\n\n{\n    fcn.00438337(arg_8h);\n    return;\n}\n",
        "token_count": 33
    },
    "004012b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004012b2(uint arg_8h)\n\n{\n    uint var_4h;\n    \n    fcn.00401285(arg_8h);\n    return;\n}\n",
        "token_count": 42
    },
    "004066a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004066a0(void)\n\n{\n    fcn.0040d21b(*0x49d94c);\n    return;\n}\n",
        "token_count": 33
    },
    "0040b18e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b18e(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    uint uVar4;\n    uint var_3ch;\n    uint var_38h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_18h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0044d3cc(in_ECX, 2, 1, 0x50000000, 0xe900);\n    if (iVar1 != 0) {\n        fcn.00401316();\n        fcn.004015a0(&var_18h);\n        puVar2 = fcn.00401311(&var_20h);\n        var_8h = *puVar2;\n        var_4h = puVar2[1] + -0x96;\n        iVar1 = (**(*(in_ECX + 0xbc) + 0xb8))(0, 0, 0x4716b8, var_8h, var_4h, arg_ch);\n        if (iVar1 != 0) {\n            uVar4 = 0;\n            uVar3 = 0;\n            puVar2 = fcn.00401226(0, 0);\n            iVar1 = (**(*(in_ECX + 0xbc) + 0xb8))(1, 0, 0x4712f0, *puVar2, puVar2[1], uVar3, uVar4, arg_ch);\n            if (iVar1 != 0) {\n                uVar3 = fcn.0044d6c1(1, 0, 1);\n                fcn.0045ae3e(uVar3);\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 449
    },
    "004013ac": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004013ac(uint arg_8h)\n\n{\n    uint var_4h;\n    \n    fcn.00438360(arg_8h);\n    return;\n}\n",
        "token_count": 41
    },
    "004013b1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004013b1(uint arg_8h, uint arg_ch, char *arg_10h)\n\n{\n    fcn.0040d6f0(arg_8h, *arg_10h, arg_ch);\n    return;\n}\n",
        "token_count": 57
    },
    "004013b6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004013b6(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    return **(param_1 + 0x1c) + **(param_1 + 0x2c);\n}\n",
        "token_count": 57
    },
    "004013bb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004013bb(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    return *param_1 + param_1[2];\n}\n",
        "token_count": 43
    },
    "004013cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004013cf(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    uStack12 = 0x46bbd4;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    *param_1 = 0x47151c;\n    var_4h = 1;\n    fcn.004348b2();\n    var_4h = var_4h & 0xffffff00;\n    fcn.00438b48();\n    var_4h = 0xffffffff;\n    fcn.00401537();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 171
    },
    "004013e3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004013e3(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    **(in_ECX + 0x30) = **(in_ECX + 0x30) - arg_8h;\n    **(in_ECX + 0x20) = **(in_ECX + 0x20) + arg_8h;\n    return;\n}\n",
        "token_count": 100
    },
    "00401401": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401401(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x46b420;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    *param_1 = 0x471044;\n    var_4h = 0;\n    fcn.00438b48();\n    var_4h = 0xffffffff;\n    fcn.004441c6();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 143
    },
    "00401429": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401429(int32_t param_1)\n\n{\n    uint var_4h;\n    \n    *(param_1 + 0xc) = param_1 + 4;\n    *(param_1 + 0x10) = param_1 + 8;\n    *(param_1 + 0x1c) = param_1 + 0x14;\n    *(param_1 + 0x20) = param_1 + 0x18;\n    *(param_1 + 0x2c) = param_1 + 0x24;\n    *(param_1 + 0x30) = param_1 + 0x28;\n    fcn.00401406(0, 0);\n    fcn.00401532(0, 0, 0);\n    return;\n}\n",
        "token_count": 182
    },
    "0040145b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.0040145b(uint param_1)\n\n{\n    uint var_4h;\n    \n    fcn.00401253(param_1);\n    fcn.00401492();\n    return;\n}\n",
        "token_count": 64
    },
    "00401465": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401465(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00401541(in_ECX + 0x20);\n    return arg_8h;\n}\n",
        "token_count": 64
    },
    "00401479": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401479(uint arg_8h)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46ba29;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    *0x49b3f4 = arg_8h;\n    fcn.004013c0();\n    fcn.0040d2e1(0x4013d9);\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 194
    },
    "00401488": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401488(uint arg_8h)\n\n{\n    uchar uVar1;\n    uint8_t **ppuVar2;\n    uint uVar3;\n    uint32_t in_ECX;\n    ulong uVar4;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar4 = fcn.0040161d();\n    ppuVar2 = uVar4;\n    uVar1 = fcn.00401582(uVar4 >> 0x20 & 0xffffff00 | **ppuVar2);\n    *(in_ECX + 0xc) = uVar1;\n    uVar1 = fcn.00401582(in_ECX & 0xffffff00 | *ppuVar2[1]);\n    *(in_ECX + 0xd) = uVar1;\n    uVar3 = fcn.00401497(ppuVar2[2]);\n    *(in_ECX + 8) = uVar3;\n    uVar3 = fcn.0040105f(0);\n    uVar3 = fcn.00401497(uVar3);\n    *(in_ECX + 0x10) = uVar3;\n    uVar3 = fcn.004011a9(0);\n    uVar3 = fcn.00401497(uVar3);\n    *(in_ECX + 0x14) = uVar3;\n    return;\n}\n",
        "token_count": 308
    },
    "004014b5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004014b5(uint arg_8h)\n\n{\n    fcn.0040d070(arg_8h);\n    return;\n}\n",
        "token_count": 35
    },
    "004014dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004014dd(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h._0_1_ = 0;\n    *(in_ECX + 8) = arg_8h;\n    fcn.004014b0(*(in_ECX + 4) + arg_8h, &var_4h);\n    return;\n}\n",
        "token_count": 113
    },
    "00401528": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00401528(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    uStack12 = 0x46bc6c;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    *param_1 = 0x471590;\n    var_4h = 2;\n    fcn.00460f94();\n    var_4h._0_1_ = 1;\n    fcn.004609eb();\n    var_4h = var_4h._1_3_ << 8;\n    fcn.0044d311();\n    var_4h = 0xffffffff;\n    fcn.00459c69();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 206
    },
    "0040155a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040155a(uint arg_8h)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46ba09;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0041aedd();\n    var_4h = 0;\n    *0x49b3f0 = arg_8h;\n    fcn.004013c0();\n    fcn.0040d2e1(0x401591);\n    var_4h = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 193
    },
    "00401564": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401564(uint arg_8h)\n\n{\n    fcn.00438360(arg_8h);\n    return;\n}\n",
        "token_count": 33
    },
    "0040156e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040156e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    code *var_34h;\n    code *var_30h;\n    code *var_14h;\n    code *var_10h;\n    code *var_ch;\n    code *var_8h;\n    code *var_4h;\n    \n    uVar1 = fcn.00401690(0x173, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_14h = fcn.00401168(uVar1);\n    uVar1 = fcn.00401690(0x1e3, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_34h = fcn.00401168(uVar1);\n    uVar1 = fcn.00401690(0x22d, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_30h = fcn.00401168(uVar1);\n    uVar1 = fcn.00401690(0x27c, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_10h = fcn.00401168(uVar1);\n    uVar1 = fcn.00401690(0x24b, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_ch = fcn.00401168(uVar1);\n    uVar1 = fcn.00401690(0x264, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_8h = fcn.00401168(uVar1);\n    uVar1 = fcn.00401690(0x3b9, 0);\n    uVar1 = fcn.0040124e(uVar1);\n    var_4h = fcn.00401168(uVar1);\n    iVar2 = (*var_30h)(&var_38h, 0, 0, 1, 0);\n    if (((iVar2 == 0) && (iVar2 = (*var_30h)(&var_38h, 0, 0, 1, 8),  iVar2 == 0)) &&\n       (iVar2 = (*var_30h)(&var_38h, 0, 0, 1, 0xf0000000),  iVar2 == 0)) {\n        var_40h = 0;\n    }\n    else {\n        iVar2 = (*var_ch)(var_38h, 0x8003, 0, 0, &var_44h);\n        if (iVar2 == 0) {\n            var_40h = 0;\n        }\n        else {\n            iVar2 = (*var_8h)(var_44h, arg_10h, 0x10, 1);\n            if (iVar2 == 0) {\n                var_40h = 0;\n            }\n            else {\n                iVar2 = (*var_4h)(var_38h, 0x6801, var_44h, 1, &var_3ch);\n                if (iVar2 == 0) {\n                    var_40h = 0;\n                }\n                else {\n                    var_40h = (*var_34h)(0, arg_ch, 0x1000, 0x40);\n                    (*var_14h)(var_40h, arg_8h, arg_ch);\n                    iVar2 = (*var_10h)(var_3ch, 0, 1, 0, var_40h, &arg_ch, arg_ch);\n                    if (iVar2 == 0) {\n                        var_40h = 0;\n                    }\n                }\n            }\n        }\n    }\n    return var_40h;\n}\n",
        "token_count": 902
    },
    "0040157d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040157d(code **param_1)\n\n{\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    *param_1 = vtable.std::numpunct_char_.0;\n    fcn.00438360(param_1[2]);\n    fcn.00438360(param_1[4]);\n    fcn.00438360(param_1[5]);\n    fcn.00401096();\n    return;\n}\n",
        "token_count": 113
    },
    "004015aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004015aa(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    fcn.0040cd30(arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 52
    },
    "004015b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004015b9(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t in_EAX;\n    uint32_t arg_ch_00;\n    uint arg_8h_00;\n    \n    arg_ch_00 = in_EAX & 0xffffff00 | arg_8h & 0xff;\n    arg_8h_00 = 4;\n    fcn.00401073(arg_ch, 0, 1);\n    fcn.00401578(arg_8h_00, arg_ch_00);\n    return;\n}\n",
        "token_count": 125
    },
    "004015e6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __fastcall fcn.004015e6(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bbb5;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.004016ae();\n    var_4h = 0;\n    fcn.00401474();\n    var_4h._0_1_ = 1;\n    fcn.0043483e(10);\n    var_4h = CONCAT31(var_4h._1_3_, 2);\n    *param_1 = 0x47151c;\n    fcn.00401104();\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 210
    },
    "00401604": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.00401604(uint param_1)\n\n{\n    uint var_4h;\n    \n    fcn.0040123f(param_1);\n    fcn.00401492();\n    return;\n}\n",
        "token_count": 64
    },
    "00401613": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401613(uint8_t *arg_8h, uint8_t *arg_ch)\n\n{\n    for (; (*arg_8h != 0 && (*arg_8h == *arg_ch)); arg_8h = arg_8h + 1) {\n        arg_ch = arg_ch + 1;\n    }\n    return *arg_8h - *arg_ch;\n}\n",
        "token_count": 90
    },
    "0040169a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.0040169a(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b40d;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0044416c();\n    var_4h = 0;\n    fcn.00401474();\n    *param_1 = 0x471044;\n    param_1[0x14] = 0;\n    param_1[0x16] = 0;\n    param_1[0x17] = 0;\n    param_1[0x18] = 0;\n    param_1[0x19] = 0;\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 213
    },
    "0040169f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.0040169f(uint *param_1)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46b6bc;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00401361();\n    var_4h = 0;\n    *param_1 = 0x471170;\n    fcn.00401429();\n    *in_FS_OFFSET = var_ch;\n    return param_1;\n}\n",
        "token_count": 147
    },
    "004016a4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004016a4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    ushort extraout_var;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar1 = fcn.0040114a();\n    if (iVar1 == 0) {\n        fcn.00401091(&var_4h);\n        *(in_ECX + 8) = var_4h & 0xffff;\n        fcn.004453a2(arg_8h, in_ECX + 4);\n    }\n    else {\n        fcn.004016a9(CONCAT22(extraout_var, *(in_ECX + 8)));\n        fcn.004452d2(arg_8h, in_ECX + 4);\n    }\n    (**(*(in_ECX + 0xc) + 8))(arg_8h);\n    return;\n}\n",
        "token_count": 204
    },
    "004016a9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004016a9(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint32_t uVar1;\n    uint var_4h;\n    \n    uVar1 = *(in_ECX + 0x24) + 2;\n    if (*(in_ECX + 0x28) <= uVar1 && uVar1 != *(in_ECX + 0x28)) {\n        fcn.0044585c();\n    }\n    **(in_ECX + 0x24) = arg_8h;\n    *(in_ECX + 0x24) = *(in_ECX + 0x24) + 2;\n    return in_ECX;\n}\n",
        "token_count": 157
    },
    "00402bb5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402bb5(void)\n\n{\n    fcn.0040d2e1(0x4011ea);\n    return;\n}\n",
        "token_count": 33
    },
    "00402bc7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402bc7(void)\n\n{\n    fcn.0040d2e1(0x4014f6);\n    return;\n}\n",
        "token_count": 34
    },
    "00402bd9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402bd9(void)\n\n{\n    fcn.0040d2e1(0x401447);\n    return;\n}\n",
        "token_count": 32
    },
    "0040a211": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040a211(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x46bb4c;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00401474();\n    var_4h = 1;\n    iVar1 = fcn.0040d755();\n    iVar2 = fcn.0040d755();\n    fcn.00401474();\n    var_4h._0_1_ = 2;\n    fcn.00401474();\n    var_4h._0_1_ = 3;\n    iVar1 = fcn.0043a377(iVar1 % 0x24 + 0x7d6b);\n    if (iVar1 == 0) {\n        fcn.004388bd(&var_18h);\n        var_4h._0_1_ = 2;\n        fcn.00438b48();\n        var_4h._0_1_ = 1;\n        fcn.00438b48();\n        var_4h = var_4h._1_3_ << 8;\n        fcn.00438b48();\n    }\n    else {\n        iVar1 = fcn.0043a377(iVar2 % 6 + 0x7d8f);\n        if (iVar1 == 0) {\n            fcn.004388bd(&var_18h);\n            var_4h._0_1_ = 2;\n            fcn.00438b48();\n            var_4h._0_1_ = 1;\n            fcn.00438b48();\n            var_4h = var_4h._1_3_ << 8;\n            fcn.00438b48();\n        }\n        else {\n            uVar3 = fcn.00401573();\n            uVar3 = fcn.00401573(uVar3);\n            iVar1 = fcn.004010b4(uVar3);\n            iVar2 = fcn.004010b4();\n            uVar3 = fcn.00438f78(iVar1 + iVar2);\n            (*_sym.imp.USER32.dll_wsprintfA)(uVar3);\n            fcn.00438fc7(0xffffffff);\n            fcn.004388bd(&var_18h);\n            var_4h._0_1_ = 2;\n            fcn.00438b48();\n            var_4h._0_1_ = 1;\n            fcn.00438b48();\n            var_4h = var_4h._1_3_ << 8;\n            fcn.00438b48();\n        }\n    }\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 712
    },
    "0040b2b5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040b2b5(void)\n\n{\n    fcn.0040d2e1(0x4011ea);\n    return;\n}\n",
        "token_count": 35
    },
    "0040b99f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040b99f(void)\n\n{\n    fcn.0040d2e1(fcn.0040b9b1);\n    return;\n}\n",
        "token_count": 37
    },
    "0040bd54": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040bd54(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFileException.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48(extraout_ECX);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 145
    },
    "0040bde4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040bde4(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 0x24) + 4;\n    if (*(param_1 + 0x28) <= uVar1 && uVar1 != *(param_1 + 0x28)) {\n        fcn.0044585c();\n    }\n    **(param_1 + 0x24) = param_2;\n    *(param_1 + 0x24) = *(param_1 + 0x24) + 4;\n    return param_1;\n}\n",
        "token_count": 149
    },
    "0040be39": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040be39(int32_t param_1)\n\n{\n    uint *unaff_retaddr;\n    \n    if (*(param_1 + 0x28) < *(param_1 + 0x24) + 4U) {\n        fcn.004458d8((*(param_1 + 0x24) - *(param_1 + 0x28)) + 4);\n    }\n    *unaff_retaddr = **(param_1 + 0x24);\n    *(param_1 + 0x24) = *(param_1 + 0x24) + 4;\n    return param_1;\n}\n",
        "token_count": 146
    },
    "0040c1c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040c1c1(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.0040bf84();\n    if (iVar2 == 0) {\n        if ((((arg_8h == 0x12340042) && (arg_ch != NULL)) && (0x27 < *arg_ch)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar4;\n            uVar4 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            uVar3 = 1;\n            arg_ch[4] = uVar4;\n            arg_ch[9] = 1;\n            if (0x47 < *arg_ch) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(arg_ch + 10, \"DISPLAY\");\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n    }\n    else {\n        uVar3 = (**0x49d048)(arg_8h, arg_ch);\n    }\n    return uVar3;\n}\n",
        "token_count": 416
    },
    "0040c3c4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040c3c4(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CArchiveException.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48(extraout_ECX);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 147
    },
    "0040d21b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040d21b(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    \n    if (param_1 != 0) {\n        fcn.00410d98(9);\n        arg_8h = fcn.00411120(param_1);\n        if (arg_8h != 0) {\n            fcn.0041114b(arg_8h, param_1);\n            fcn.00410df9(9);\n            return;\n        }\n        fcn.00410df9(9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x49ef84, 0, param_1);\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "0040d555": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040d555(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    \n    puVar1 = fcn.0040d5d1();\n    iVar3 = 0;\n    *puVar1 = param_1;\n    puVar1 = 0x498ae8;\n    do {\n        if (param_1 == *puVar1) {\n            puVar2 = fcn.0040d5c8();\n            *puVar2 = *(iVar3 * 8 + 0x498aec);\n            return;\n        }\n        puVar1 = puVar1 + 2;\n        iVar3 = iVar3 + 1;\n    } while (puVar1 < 0x498c50);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        puVar2 = fcn.0040d5c8();\n        *puVar2 = 0xd;\n        return;\n    }\n    if ((0xbb < param_1) && (param_1 < 0xcb)) {\n        puVar2 = fcn.0040d5c8();\n        *puVar2 = 8;\n        return;\n    }\n    puVar2 = fcn.0040d5c8();\n    *puVar2 = 0x16;\n    return;\n}\n",
        "token_count": 310
    },
    "0040d7b5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040d7b5(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1 <= *0x498f44) {\n        fcn.00410d98(9);\n        iVar1 = fcn.00411476(param_1);\n        fcn.00410df9(9);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n    }\n    if (param_1 == 0) {\n        param_1 = 1;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x49ef84, 0, param_1 + 0xf & 0xfffffff0);\n    return iVar1;\n}\n",
        "token_count": 165
    },
    "0040eab6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040eab6(uint param_1, uint32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if (param_2 < 0xffffffe1) {\n        fcn.00410d98(9);\n        iVar2 = fcn.00411120(param_1);\n        if (iVar2 == 0) {\n            fcn.00410df9(9);\n            if (param_2 == 0) {\n                param_2 = 1;\n            }\n            uVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x49ef84, 0x10, param_1, param_2 + 0xf & 0xfffffff0);\n        }\n        else {\n            uVar1 = 0;\n            if (param_2 <= *0x498f44) {\n                iVar2 = fcn.0041192b(iVar2, param_1, param_2);\n                if (iVar2 != 0) {\n                    uVar1 = param_1;\n                }\n            }\n            fcn.00410df9(9);\n        }\n    }\n    else {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 274
    },
    "0040f978": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040f978(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    fcn.0040f993(param_1, param_2, param_3, param_4, 0);\n    return;\n}\n",
        "token_count": 61
    },
    "00410ed0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00410ed0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x00410f1f;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00410f31;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00410f31;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00410f31;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x00410f1f:\n    puVar5 = puVar3 + -1;\ncode_r0x00410f31:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00410fa8;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x00410fa8:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 754
    },
    "00410ec0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.00410ec0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00410fa8;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x00410fa8:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 439
    },
    "004133ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004133ba(uint param_1, uint32_t param_2, uint param_3, int32_t param_4, uint param_5, int32_t param_6, \n                    int32_t param_7, int32_t param_8)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint Locale;\n    uint32_t lpWideCharStr;\n    uint lpSrcStr;\n    int32_t cchSrc;\n    uint lpDestStr;\n    int32_t cchDest;\n    int32_t var_20h_3;\n    int32_t var_24h_4;\n    uint var_1ch;\n    uint var_18h_2;\n    uint var_10h;\n    uint dwMapFlags;\n    uint var_10h_3;\n    uint var_4h;\n    uint var_20h;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint CodePage;\n    uint dwFlags;\n    uint uStack132;\n    uint32_t uStack128;\n    uchar *puStack124;\n    int32_t iStack120;\n    uint uStack116;\n    uint uStack112;\n    int32_t iStack108;\n    uint uStack104;\n    uint uStack100;\n    int32_t iStack96;\n    uchar *puStack92;\n    int32_t iStack88;\n    int32_t iStack84;\n    uint32_t uStack80;\n    uint uStack76;\n    int32_t iStack72;\n    uint uStack68;\n    int32_t iStack64;\n    uint var_24h_3;\n    uint var_20h_2;\n    uint var_1ch_2;\n    uint uStack20;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h_2;\n    \n    var_4h_2 = 0xffffffff;\n    uStack12 = 0x4762b8;\n    pcStack16 = fcn.00413018;\n    uStack20 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xffffffec;\n    if (*0x49d758 == 0) {\n        iStack64 = 0;\n        uStack68 = 0;\n        iStack72 = 1;\n        uStack76 = 0x4762b4;\n        uStack80 = 0x100;\n        iStack84 = 0;\n        iStack88 = 0x413402;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 != 0) {\n            *0x49d758 = 1;\n            goto code_r0x00413430;\n        }\n        iStack64 = 0;\n        uStack68 = 0;\n        iStack72 = 1;\n        uStack76 = 0x4762b0;\n        uStack80 = 0x100;\n        iStack84 = 0;\n        iStack88 = 0x41341e;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        if (iVar1 != 0) {\n            *0x49d758 = 2;\n            goto code_r0x00413430;\n        }\n    }\n    else {\ncode_r0x00413430:\n        if (0 < cchSrc) {\n            iStack64 = cchSrc;\n            uStack68 = lpSrcStr;\n            iStack72 = 0x413440;\n            cchSrc = fcn.004135de();\n        }\n        if (*0x49d758 == 2) {\n            iStack64 = cchDest;\n            uStack68 = lpDestStr;\n            iStack72 = cchSrc;\n            uStack76 = lpSrcStr;\n            uStack80 = lpWideCharStr;\n            iStack84 = Locale;\n            iStack88 = 0x413467;\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            goto code_r0x0041354a;\n        }\n        if (*0x49d758 == 1) {\n            if (var_20h_3 == 0) {\n                var_20h_3 = *0x49d774;\n            }\n            iStack64 = 0;\n            uStack68 = 0;\n            iStack72 = cchSrc;\n            uStack76 = lpSrcStr;\n            uStack80 = (-(var_24h_4 != 0) & 8) + 1;\n            iStack84 = var_20h_3;\n            iStack88 = 0x41349f;\n            puStack92 = &stack0xffffffac;\n            puStack124 = &stack0xffffffac;\n            iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n            if (iVar2 != 0) {\n                var_4h_2 = 0;\n                iStack88 = 0x4134bc;\n                fcn.0040d980();\n                var_4h_2 = 0xffffffff;\n                if (*0x10 != 0x54) {\n                    iStack96 = cchSrc;\n                    uStack100 = lpSrcStr;\n                    uStack104 = 1;\n                    iStack108 = var_20h_3;\n                    uStack112 = 0x4134f7;\n                    iStack88 = iVar2;\n                    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n                    if (iVar1 != 0) {\n                        uStack112 = 0;\n                        uStack116 = 0;\n                        uStack128 = lpWideCharStr;\n                        uStack132 = Locale;\n                        iStack120 = iVar2;\n                        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n                        if (iVar1 != 0) {\n                            if ((lpWideCharStr & 0x400) == 0) {\n                                var_4h_2 = 1;\n                                fcn.0040d980();\n                                var_4h_2 = 0xffffffff;\n                                if ((*0x10 != 0x84) &&\n                                   (iVar2 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                                      (Locale, lpWideCharStr, &stack0xffffffac, iVar2, &stack0xffffff7c\n                                                       , iVar1),  iVar2 != 0)) {\n                                    if (cchDest == 0) {\n                                        cchDest = 0;\n                                        lpDestStr = 0;\n                                    }\n                                    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                                      (var_20h_3, 0x220, &stack0xffffff7c, iVar1, lpDestStr, cchDest, 0\n                                                       , 0);\n                                    iVar2 = iVar1;\njoined_r0x004135d1:\n                                    if (iVar2 != 0) goto code_r0x0041354a;\n                                }\n                            }\n                            else {\n                                if (cchDest == 0) goto code_r0x0041354a;\n                                if (iVar1 <= cchDest) {\n                                    iVar2 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                                      (Locale, lpWideCharStr, &stack0xffffffac, iVar2, lpDestStr, \n                                                       cchDest);\n                                    goto joined_r0x004135d1;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    iVar1 = 0;\ncode_r0x0041354a:\n    *in_FS_OFFSET = uStack20;\n    return iVar1;\n}\n",
        "token_count": 1665
    },
    "0041573c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041573c(uint param_1, uint param_2)\n\n{\n    fcn.004155d0(param_1, param_2, 0x499540);\n    return;\n}\n",
        "token_count": 46
    },
    "00415752": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00415752(uint param_1, uint param_2)\n\n{\n    fcn.004155d0(param_1, param_2, 0x499558);\n    return;\n}\n",
        "token_count": 45
    },
    "004157e2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004157e2(uint arg_8h, uint arg_ch)\n\n{\n    uint var_ch;\n    \n    fcn.00417db5(&var_ch, &arg_ch, arg_ch, 0, 0, 0, 0);\n    fcn.0041573c(&var_ch, arg_8h);\n    return;\n}\n",
        "token_count": 80
    },
    "0041583d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041583d(uint arg_8h, uint arg_ch)\n\n{\n    uint var_ch;\n    \n    fcn.00417db5(&var_ch, &arg_ch, arg_ch, 0, 0, 0, 0);\n    fcn.00415752(&var_ch, arg_8h);\n    return;\n}\n",
        "token_count": 79
    },
    "00418ca9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00418ca9(uint param_1, uint param_2, int32_t param_3, uint param_4, int32_t param_5, int32_t param_6)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *in_FS_OFFSET;\n    uint dwInfoType;\n    uint lpSrcStr;\n    int32_t cchSrc;\n    uint var_14h;\n    int32_t var_28h;\n    int32_t var_4h_2;\n    uint var_18h_3;\n    uint var_ch_2;\n    uint var_10h;\n    uint var_18h_4;\n    uint var_4h;\n    uint lpWideCharStr;\n    uint var_10h_2;\n    uint CodePage;\n    uint var_18h;\n    int32_t iStack124;\n    uint uStack120;\n    uint uStack116;\n    int32_t iStack112;\n    uchar *puStack108;\n    uchar *puStack104;\n    uint uStack100;\n    int32_t iStack96;\n    int32_t iStack92;\n    uint uStack88;\n    uint uStack84;\n    int32_t iStack80;\n    uint uStack76;\n    uint uStack72;\n    int32_t iStack68;\n    uint *puStack64;\n    uchar *var_2ch_2;\n    int32_t var_28h_2;\n    uint var_24h;\n    uint var_20h;\n    uint lpCharType;\n    uchar *puStack28;\n    uint uStack20;\n    code *var_2ch;\n    uint uStack12;\n    uint var_4h_3;\n    \n    var_4h_3 = 0xffffffff;\n    uStack12 = 0x476ad0;\n    var_2ch = fcn.00413018;\n    uStack20 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xffffffec;\n    puStack28 = &stack0xffffffc4;\n    iVar4 = *0x49d8d8;\n    puVar1 = &stack0xffffffc4;\n    if (*0x49d8d8 == 0) {\n        puStack64 = &fcn.00418ca9::lpCharType;\n        iStack68 = 1;\n        uStack72 = 0x4762b4;\n        uStack76 = 1;\n        iStack80 = 0x418cee;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        iVar4 = 1;\n        puVar1 = puStack28;\n        if (iVar2 != 0) goto code_r0x00418d18;\n        puStack64 = &fcn.00418ca9::lpCharType;\n        iStack68 = 1;\n        uStack72 = 0x4762b0;\n        uStack76 = 1;\n        iStack80 = 0;\n        uStack84 = 0x418d08;\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n        if (iVar4 != 0) {\n            iVar4 = 2;\n            puVar1 = puStack28;\n            goto code_r0x00418d18;\n        }\n    }\n    else {\ncode_r0x00418d18:\n        puStack28 = puVar1;\n        *0x49d8d8 = iVar4;\n        if (*0x49d8d8 == 1) {\n            puStack64 = var_14h;\n            iStack68 = cchSrc;\n            uStack72 = lpSrcStr;\n            uStack76 = dwInfoType;\n            iStack80 = 0x418d2f;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n            goto code_r0x00418e5c;\n        }\n        if (*0x49d8d8 == 2) {\n            if (var_28h == 0) {\n                var_28h = *0x49d774;\n            }\n            puStack64 = NULL;\n            iStack68 = 0;\n            uStack72 = 0;\n            uStack76 = 0;\n            iStack80 = cchSrc;\n            uStack84 = lpSrcStr;\n            uStack88 = 0x220;\n            iStack92 = var_28h;\n            iStack96 = 0x418d62;\n            var_2ch_2 = &stack0xffffffa4;\n            puStack104 = &stack0xffffffa4;\n            var_28h_2 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)();\n            if (var_28h_2 != 0) {\n                var_4h_3 = 0;\n                iStack96 = 0x418d7c;\n                fcn.0040d980();\n                uStack100 = 0;\n                puStack108 = 0x418d8c;\n                iStack96 = var_28h_2;\n                puStack28 = &stack0xffffffa4;\n                fcn.0040d6f0();\n                var_4h_3 = 0xffffffff;\n                if (*0x10 != 0x5c) {\n                    iStack96 = 0;\n                    uStack100 = 0;\n                    iStack112 = cchSrc;\n                    uStack116 = lpSrcStr;\n                    uStack120 = 0x220;\n                    iStack124 = var_28h;\n                    puStack108 = &stack0xffffffa4;\n                    puStack104 = var_28h_2;\n                    iVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)();\n                    if (iVar4 != 0) {\n                        var_4h_3 = 1;\n                        fcn.0040d980();\n                        var_4h_3 = 0xffffffff;\n                        if (*0x10 != 0x7c) {\n                            if (var_4h_2 == 0) {\n                                var_4h_2 = *0x49d764;\n                            }\n                            cchSrc = cchSrc * 2;\n                            puStack28 = &stack0xffffff84;\n                            *(&stack0xffffff84 + cchSrc) = -1;\n                            *(&stack0xffffff82 + cchSrc) = 0xffff;\n                            uVar3 = (*_sym.imp.KERNEL32.dll_GetStringTypeA)\n                                              (var_4h_2, dwInfoType, var_2ch_2, var_28h_2, &stack0xffffff84);\n                            if ((*(&stack0xffffff82 + cchSrc) != -1) && (*(&stack0xffffff84 + cchSrc) == -1)) {\n                                fcn.0040dde0(var_14h, &stack0xffffff84, cchSrc);\n                                goto code_r0x00418e5c;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    uVar3 = 0;\ncode_r0x00418e5c:\n    *in_FS_OFFSET = uStack20;\n    return uVar3;\n}\n",
        "token_count": 1569
    },
    "004194bd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.004194bd(uint param_1, uint param_2, uint8_t *param_3, int32_t param_4, uint8_t *param_5, int32_t param_6, \n                   int32_t param_7)\n\n{\n    code *pcVar1;\n    uchar *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint uVar6;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint Locale;\n    uint dwCmpFlags;\n    uint8_t *lpString1;\n    int32_t lpCPInfo;\n    uint8_t *lpString2;\n    int32_t cbMultiByte;\n    int32_t var_20h_4;\n    uint var_4h_2;\n    uint var_1ch_2;\n    uint var_18h_2;\n    uint var_10h;\n    uint var_18h_3;\n    uint var_4h;\n    uint var_20h_2;\n    uint lpMultiByteStr;\n    uint var_14h;\n    uint var_1ch;\n    uint CodePage;\n    uint var_18h;\n    int32_t iStack152;\n    uint uStack148;\n    uint8_t *puStack144;\n    int32_t iStack140;\n    uint uStack136;\n    uint uStack132;\n    int32_t iStack128;\n    uint uStack124;\n    uint8_t *puStack120;\n    int32_t iStack116;\n    uchar *puStack112;\n    int32_t iStack108;\n    int32_t iStack104;\n    uint uStack100;\n    uint8_t *puStack96;\n    int32_t iStack92;\n    uint8_t *puStack88;\n    uint *puStack84;\n    uint32_t var_3ch_2;\n    uint var_36h;\n    uchar *var_28h;\n    uchar *var_24h_2;\n    int32_t iStack36;\n    int32_t cchCount1;\n    uchar *puStack28;\n    uint uStack20;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h_3;\n    \n    var_4h_3 = 0xffffffff;\n    uStack12 = 0x476ae8;\n    pcStack16 = fcn.00413018;\n    uStack20 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xffffffec;\n    puStack28 = &stack0xffffffb0;\n    uVar6 = 1;\n    puVar2 = &stack0xffffffb0;\n    if (*0x49d8dc == 0) {\n        puStack84 = 0x1;\n        puStack88 = 0x4762b4;\n        iStack92 = 1;\n        puStack96 = 0x4762b4;\n        uStack100 = 0;\n        iStack104 = 0;\n        iStack108 = 0x419501;\n        iVar3 = (*_sym.imp.KERNEL32.dll_CompareStringW)();\n        if (iVar3 != 0) {\n            *0x49d8dc = 1;\n            puVar2 = puStack28;\n            goto code_r0x00419530;\n        }\n        puStack84 = 0x1;\n        puStack88 = 0x4762b0;\n        iStack92 = 1;\n        puStack96 = 0x4762b0;\n        uStack100 = 0;\n        iStack104 = 0;\n        iStack108 = 0x41951e;\n        iVar3 = (*_sym.imp.KERNEL32.dll_CompareStringA)();\n        if (iVar3 != 0) {\n            *0x49d8dc = 2;\n            puVar2 = puStack28;\n            goto code_r0x00419530;\n        }\n    }\n    else {\ncode_r0x00419530:\n        puStack28 = puVar2;\n        if (0 < lpCPInfo) {\n            puStack84 = lpCPInfo;\n            puStack88 = lpString1;\n            iStack92 = 0x419540;\n            lpCPInfo = fcn.0041973a();\n        }\n        if (0 < cbMultiByte) {\n            puStack84 = cbMultiByte;\n            puStack88 = lpString2;\n            iStack92 = 0x419557;\n            cbMultiByte = fcn.0041973a();\n        }\n        if (*0x49d8dc == 2) {\n            puStack84 = cbMultiByte;\n            puStack88 = lpString2;\n            puStack96 = lpString1;\n            uStack100 = dwCmpFlags;\n            iStack104 = Locale;\n            iStack108 = 0x41957c;\n            iStack92 = lpCPInfo;\n            puStack84 = (*_sym.imp.KERNEL32.dll_CompareStringA)();\n            goto code_r0x00419728;\n        }\n        if (*0x49d8dc == 1) {\n            if (var_20h_4 == 0) {\n                var_20h_4 = *0x49d774;\n            }\n            if ((lpCPInfo == 0) || (cbMultiByte == 0)) {\n                if (lpCPInfo == cbMultiByte) {\ncode_r0x004195a8:\n                    puStack84 = 0x2;\n                    goto code_r0x00419728;\n                }\n                puStack84 = uVar6;\n                if (1 < cbMultiByte) goto code_r0x00419728;\n                if (lpCPInfo < 2) {\n                    puStack84 = &fcn.004194bd::var_3ch_2;\n                    puStack88 = var_20h_4;\n                    iStack92 = 0x4195cd;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n                    if (iVar3 == 0) goto code_r0x00419726;\n                    if (lpCPInfo < 1) {\n                        if (0 < cbMultiByte) {\n                            puStack84 = uVar6;\n                            if (1 < var_3ch_2) {\n                                puVar4 = &fcn.004194bd::var_36h;\n                                while ((var_36h != 0 && (*(puVar4 + 1) != 0))) {\n                                    if ((*puVar4 <= *lpString2) && (*lpString2 <= *(puVar4 + 1))) goto code_r0x004195a8;\n                                    puVar4 = puVar4 + 2;\n                                    var_36h._0_1_ = *puVar4;\n                                }\n                            }\n                            goto code_r0x00419728;\n                        }\n                        goto code_r0x0041963b;\n                    }\n                    if (1 < var_3ch_2) {\n                        puVar4 = &fcn.004194bd::var_36h;\n                        while ((var_36h != 0 && (*(puVar4 + 1) != 0))) {\n                            if ((*puVar4 <= *lpString1) && (*lpString1 <= *(puVar4 + 1))) goto code_r0x004195a8;\n                            puVar4 = puVar4 + 2;\n                            var_36h._0_1_ = *puVar4;\n                        }\n                    }\n                }\n                puStack84 = 0x3;\n                goto code_r0x00419728;\n            }\ncode_r0x0041963b:\n            puStack84 = NULL;\n            puStack88 = NULL;\n            puStack96 = lpString1;\n            uStack100 = 9;\n            iStack104 = var_20h_4;\n            iStack108 = 0x41964c;\n            puStack112 = &stack0xffffff98;\n            var_24h_2 = &stack0xffffff98;\n            iStack92 = lpCPInfo;\n            cchCount1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n            if (cchCount1 != 0) {\n                var_4h_3 = 0;\n                iStack108 = 0x419666;\n                fcn.0040d980();\n                pcVar1 = _sym.imp.KERNEL32.dll_MultiByteToWideChar;\n                var_4h_3 = 0xffffffff;\n                if (*0x10 != 0x68) {\n                    iStack108 = cchCount1;\n                    puStack120 = lpString1;\n                    uStack124 = 1;\n                    iStack128 = var_20h_4;\n                    uStack132 = 0x4196a9;\n                    iStack116 = lpCPInfo;\n                    puStack28 = &stack0xffffff98;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n                    if (iVar3 != 0) {\n                        uStack132 = 0;\n                        uStack136 = 0;\n                        iStack140 = cbMultiByte;\n                        puStack144 = lpString2;\n                        uStack148 = 9;\n                        iStack152 = var_20h_4;\n                        var_28h = &stack0xffffff68;\n                        iVar3 = (*pcVar1)();\n                        if (iVar3 != 0) {\n                            var_4h_3 = 1;\n                            iStack36 = iVar3;\n                            fcn.0040d980();\n                            var_4h_3 = 0xffffffff;\n                            if ((*0x10 != 0x98) &&\n                               (puStack28 = &stack0xffffff68, \n                               iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                                 (var_20h_4, 1, lpString2, cbMultiByte, &stack0xffffff68, iVar3), \n                               iVar5 != 0)) {\n                                puStack84 = (*_sym.imp.KERNEL32.dll_CompareStringW)\n                                                      (Locale, dwCmpFlags, var_24h_2, cchCount1, &stack0xffffff68, iVar3\n                                                      );\n                                goto code_r0x00419728;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\ncode_r0x00419726:\n    puStack84 = 0;\ncode_r0x00419728:\n    *in_FS_OFFSET = uStack20;\n    return puStack84;\n}\n",
        "token_count": 2269
    },
    "0041a92d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0041a92d(uint arg_8h)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0040d155(iVar2);\n    uVar1 = *(iVar2 + 0xc);\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 3) = uVar1;\n    fcn.004013e8(0);\n    fcn.0041ad78(iVar2 + 0xc, 0, *0x4711c4);\n    uVar3 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::runtime_error.0;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 310
    },
    "0041b0cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0041b0cf(uint arg_8h)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0040d155(iVar2);\n    uVar1 = *(iVar2 + 0xc);\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 3) = uVar1;\n    fcn.004013e8(0);\n    fcn.0041ad78(iVar2 + 0xc, 0, *0x4711c4);\n    uVar3 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::logic_error.0;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 310
    },
    "0041f700": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041f700(code **param_1)\n\n{\n    *param_1 = vtable.std::numpunct_unsigned_short_int_.0;\n    fcn.00438360(param_1[2]);\n    fcn.00438360(param_1[4]);\n    fcn.00438360(param_1[5]);\n    *param_1 = vtable.std::locale::facet.0;\n    return;\n}\n",
        "token_count": 96
    },
    "0041f850": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041f850(code **param_1)\n\n{\n    *param_1 = vtable.std::_Mpunct_unsigned_short_int_.0;\n    fcn.00438360(param_1[2]);\n    fcn.00438360(param_1[4]);\n    fcn.00438360(param_1[5]);\n    fcn.00438360(param_1[6]);\n    *param_1 = vtable.std::locale::facet.0;\n    return;\n}\n",
        "token_count": 108
    },
    "00421f0e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl\nfcn.00421f0e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    ushort *puVar4;\n    int32_t extraout_ECX;\n    ushort *puVar5;\n    uint32_t uVar6;\n    int32_t unaff_EBP;\n    uint32_t uVar7;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar7 = *(unaff_EBP + 8) | 0x1f;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (0x7ffffffd < uVar7) {\n        uVar7 = *(unaff_EBP + 8);\n    }\n    *(unaff_EBP + -4) = 0;\n    iVar2 = uVar7 + 2;\n    if (iVar2 < 0) {\n        iVar2 = 0;\n    }\n    uVar3 = fcn.00438337(iVar2 * 2);\n    *(unaff_EBP + 8) = uVar3;\n    uVar1 = *(extraout_ECX + 8);\n    if (uVar1 != 0) {\n        uVar6 = uVar7;\n        if (uVar1 <= uVar7) {\n            uVar6 = uVar1;\n        }\n        puVar4 = *(unaff_EBP + 8);\n        puVar5 = *(extraout_ECX + 4);\n        for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n            puVar4 = puVar4 + 1;\n            *puVar4 = *puVar5;\n            puVar5 = puVar5 + 1;\n        }\n    }\n    uVar1 = *(extraout_ECX + 8);\n    fcn.00421cf8(1);\n    iVar2 = *(unaff_EBP + 8);\n    *(extraout_ECX + 4) = iVar2 + 2;\n    *(iVar2 + 1) = 0;\n    *(extraout_ECX + 0xc) = uVar7;\n    if (uVar1 <= uVar7) {\n        uVar7 = uVar1;\n    }\n    uVar3 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 8) = uVar7;\n    *(*(extraout_ECX + 4) + uVar7 * 2) = 0;\n    *in_FS_OFFSET = uVar3;\n    return;\n}\n",
        "token_count": 681
    },
    "00422ef2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_50h\n\ncode ** __cdecl fcn.00422ef2(uint arg_8h)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_50h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.std::messages_unsigned_short_int_.0;\n    fcn.0041c0d1(0x4840ac);\n    *(unaff_EBP + -4) = 1;\n    pcVar1 = fcn.00422cfb(0x476f30, 0);\n    extraout_ECX[2] = pcVar1;\n    pcVar1 = fcn.00422cfb(0x476f2c, 0);\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[3] = pcVar1;\n    fcn.0041c201();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 319
    },
    "004246f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004246f0(code **param_1)\n\n{\n    *param_1 = vtable.std::_Mpunct_char_.0;\n    fcn.00438360(param_1[2]);\n    fcn.00438360(param_1[4]);\n    fcn.00438360(param_1[5]);\n    fcn.00438360(param_1[6]);\n    *param_1 = vtable.std::locale::facet.0;\n    return;\n}\n",
        "token_count": 106
    },
    "0042476b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042476b(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00401497(0x476f30);\n    *(param_1 + 8) = uVar1;\n    uVar1 = fcn.00401497(0x476f2c);\n    *(param_1 + 0xc) = uVar1;\n    return;\n}\n",
        "token_count": 96
    },
    "00426055": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_50h\n\ncode ** __cdecl fcn.00426055(uint arg_8h)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_50h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.std::messages_char_.0;\n    fcn.0041c0d1(0x4840ac);\n    *(unaff_EBP + -4) = 1;\n    pcVar1 = fcn.00401497(0x476f30);\n    extraout_ECX[2] = pcVar1;\n    pcVar1 = fcn.00401497(0x476f2c);\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[3] = pcVar1;\n    fcn.0041c201();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 308
    },
    "0042eb4c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** fcn.0042eb4c(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_4h;\n    uint *arg_8h;\n    uint uStack24;\n    code *pcStack20;\n    uint uStack8;\n    \n    uStack8 = 0x49b660;\n    pcStack20 = fcn.0042eb65;\n    fcn.0040d1e1(&uStack8, 0x47c7f0);\n    arg_8h = &uStack24;\n    uStack24 = 0x49b5c8;\n    pcStack20 = &stack0xfffffffc;\n    fcn.0040d1e1(arg_8h, 0x47c838);\n    fcn.0040d954();\n    fcn.0043976a(0, 0);\n    uStack24 = 0;\n    *extraout_ECX = vtable.CFindReplaceDialog.0;\n    fcn.0040d6f0(extraout_ECX + 0x17, 0, 0x28);\n    *(extraout_ECX + 0x41) = 0;\n    extraout_ECX[0x1a] = 0x100;\n    *(extraout_ECX + 0x21) = 0;\n    if (*0x49d0e4 == 0) {\n        iVar1 = fcn.00439a8a();\n        if (iVar1 != 0) {\n            *(extraout_ECX + 0x1a) = *(extraout_ECX + 0x1a) | 0x80;\n        }\n    }\n    extraout_ECX[0x1b] = extraout_ECX + 0x21;\n    extraout_ECX[0x1f] = fcn.00430f80;\n    extraout_ECX[0x17] = 0x28;\n    *in_FS_OFFSET = arg_8h;\n    return extraout_ECX;\n}\n",
        "token_count": 455
    },
    "0042eb65": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** fcn.0042eb65(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t *in_FS_OFFSET;\n    uint *arg_8h;\n    uint var_4h_2;\n    \n    arg_8h = &var_4h_2;\n    var_4h_2 = 0x49b5c8;\n    fcn.0040d1e1(arg_8h, 0x47c838);\n    fcn.0040d954();\n    fcn.0043976a(0, 0);\n    var_4h_2 = 0;\n    *extraout_ECX = vtable.CFindReplaceDialog.0;\n    fcn.0040d6f0(extraout_ECX + 0x17, 0, 0x28);\n    *(extraout_ECX + 0x41) = 0;\n    extraout_ECX[0x1a] = 0x100;\n    *(extraout_ECX + 0x21) = 0;\n    if (*0x49d0e4 == 0) {\n        iVar1 = fcn.00439a8a();\n        if (iVar1 != 0) {\n            *(extraout_ECX + 0x1a) = *(extraout_ECX + 0x1a) | 0x80;\n        }\n    }\n    extraout_ECX[0x1b] = extraout_ECX + 0x21;\n    extraout_ECX[0x1f] = fcn.00430f80;\n    extraout_ECX[0x17] = 0x28;\n    *in_FS_OFFSET = arg_8h;\n    return extraout_ECX;\n}\n",
        "token_count": 386
    },
    "0042eb7e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h_2\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** fcn.0042eb7e(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h_2;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0043976a(0, 0);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CFindReplaceDialog.0;\n    fcn.0040d6f0(extraout_ECX + 0x17, 0, 0x28);\n    *(extraout_ECX + 0x41) = 0;\n    extraout_ECX[0x1a] = 0x100;\n    *(extraout_ECX + 0x21) = 0;\n    if (*0x49d0e4 == 0) {\n        iVar2 = fcn.00439a8a();\n        if (iVar2 != 0) {\n            *(extraout_ECX + 0x1a) = *(extraout_ECX + 0x1a) | 0x80;\n        }\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[0x1b] = extraout_ECX + 0x21;\n    extraout_ECX[0x1f] = fcn.00430f80;\n    extraout_ECX[0x17] = 0x28;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 434
    },
    "0042ecdf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0042ecdf(int32_t param_1)\n\n{\n    return param_1 + -0x5c;\n}\n",
        "token_count": 32
    },
    "0042ef4d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042ef4d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t *in_ECX;\n    int32_t iVar1;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0) {\n        arg_8h = 0;\n    }\n    if (arg_ch == 0) {\n        var_4h = 0;\n    }\n    else {\n        var_4h = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n    }\n    iVar1 = *(*in_ECX + -8);\n    if (0 < var_4h) {\n        fcn.00438af1();\n        if (iVar1 < arg_8h) {\n            arg_8h = iVar1;\n        }\n        iVar1 = iVar1 + var_4h;\n        arg_ch_00 = *in_ECX;\n        if (*(arg_ch_00 + -4) < iVar1) {\n            fcn.004389b5(iVar1);\n            fcn.0040cd30(*in_ECX, arg_ch_00, *(arg_ch_00 + -8) + 1);\n            fcn.00438ab0(arg_ch_00 + -0xc);\n        }\n        fcn.0040cd30(*in_ECX + var_4h + arg_8h, *in_ECX + arg_8h, ((iVar1 - var_4h) - arg_8h) + 1);\n        fcn.0040cd30(*in_ECX + arg_8h, arg_ch, var_4h);\n        *(*in_ECX + -8) = iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 396
    },
    "0042f1a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f1a2(uint arg_8h)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char **in_ECX;\n    char *pcVar3;\n    uint var_4h;\n    \n    fcn.00438af1();\n    pcVar1 = *in_ECX;\n    pcVar3 = pcVar1 + *(pcVar1 + -8);\n    for (pcVar2 = pcVar1; pcVar2 < pcVar3; pcVar2 = fcn.0040e115(pcVar2)) {\n        if (*pcVar2 != arg_8h) {\n            *pcVar1 = *pcVar2;\n            pcVar1 = fcn.0040e115(pcVar1);\n        }\n    }\n    *pcVar1 = '\\0';\n    *(*in_ECX + -8) = *(*in_ECX + -8) - (pcVar2 - pcVar1);\n    return;\n}\n",
        "token_count": 212
    },
    "0042f426": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042f426(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((param_3 <= *(*param_1 + -8)) && (iVar1 = fcn.0040eb7b(*param_1 + param_3, param_2),  iVar1 != 0)) {\n        return iVar1 - *param_1;\n    }\n    return -1;\n}\n",
        "token_count": 110
    },
    "0042fab4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042fab4(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    if (arg_10h != 0) {\n        do {\n            fcn.00438c81();\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "0042fb17": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0042fb17(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    uVar1 = fcn.0040f0dc(&var_24h);\n    *in_ECX = uVar1;\n    return;\n}\n",
        "token_count": 240
    },
    "0042fef1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0042fef1(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    uint var_84h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.0040f4c2(in_ECX);\n    if (iVar1 != 0) {\n        iVar1 = fcn.0040f978(&var_84h, 0x80, arg_ch, iVar1);\n        if (iVar1 != 0) goto code_r0x0042ff2c;\n    }\n    var_84h._0_1_ = 0;\ncode_r0x0042ff2c:\n    fcn.00438bb6(&var_84h);\n    return arg_8h;\n}\n",
        "token_count": 192
    },
    "0042ff42": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0042ff42(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_84h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.0040f3b8();\n    if (iVar1 != 0) {\n        iVar1 = fcn.0040f978(&var_84h, 0x80, arg_ch, iVar1);\n        if (iVar1 != 0) goto code_r0x0042ff7d;\n    }\n    var_84h._0_1_ = 0;\ncode_r0x0042ff7d:\n    fcn.00438bb6(&var_84h);\n    return arg_8h;\n}\n",
        "token_count": 183
    },
    "0043012b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0043012b(uint arg_8h)\n\n{\n    uint16_t *puVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x68) == 0) {\n        fcn.004388bd(0x498098);\n    }\n    else {\n        puVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x68), 0);\n        fcn.00438bb6(*puVar1 + puVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 150
    },
    "00430165": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00430165(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x68) == 0) {\n        fcn.004388bd(0x498098);\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x68), 0);\n        fcn.00438bb6(*(iVar1 + 2) + iVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 148
    },
    "004301a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004301a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x68) == 0) {\n        fcn.004388bd(0x498098);\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x68), 0);\n        fcn.00438bb6(*(iVar1 + 4) + iVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 149
    },
    "00430497": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00430497(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x5c) + 0xc);\n    if (iVar1 == 0) {\n        fcn.004388bd(0x498098);\n    }\n    else {\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        fcn.00438bb6(*puVar2 + puVar2);\n    }\n    return arg_8h;\n}\n",
        "token_count": 163
    },
    "004304d4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004304d4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x5c) + 0xc);\n    if (iVar1 == 0) {\n        fcn.004388bd(0x498098);\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        fcn.00438bb6(*(iVar1 + 2) + iVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 156
    },
    "00430512": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00430512(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x5c) + 0xc);\n    if (iVar1 == 0) {\n        fcn.004388bd(0x498098);\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        fcn.00438bb6(*(iVar1 + 4) + iVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 155
    },
    "004305c7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.004305c7(uint arg_8h, uint arg_ch, uint lpString2, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code **ppcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0043976a(0, *(unaff_EBP + 0x1c));\n    pcVar2 = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0x2b] = pcVar2;\n    *(unaff_EBP + -4) = 1;\n    *extraout_ECX = vtable.CFileDialog.0;\n    fcn.0040d6f0(extraout_ECX + 0x17, 0, 0x4c);\n    pcVar2 = *(unaff_EBP + 8);\n    extraout_ECX[0x2a] = pcVar2;\n    ppcVar1 = extraout_ECX + 0x3c;\n    *ppcVar1 = 0;\n    extraout_ECX[0xf] = 0x7005 - (pcVar2 != NULL);\n    extraout_ECX[0x26] = *(unaff_EBP + 0xc);\n    uVar3 = *(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x2c) = 0;\n    extraout_ECX[0x24] = extraout_ECX[0x24] | uVar3 | 0x800020;\n    extraout_ECX[0x7d] = NULL;\n    extraout_ECX[0x17] = 0x4c;\n    extraout_ECX[0x1e] = ppcVar1;\n    extraout_ECX[0x1f] = 0x104;\n    extraout_ECX[0x20] = extraout_ECX + 0x2c;\n    extraout_ECX[0x21] = 0x40;\n    if (*0x49d0e4 == 0) {\n        iVar4 = fcn.00439a8a();\n        if (iVar4 != 0) {\n            extraout_ECX[0x24] = extraout_ECX[0x24] | 0x10;\n        }\n        if (*0x49d0e4 == 0) goto code_r0x004306a1;\n    }\n    *(extraout_ECX + 0x92) = *(extraout_ECX + 0x92) | 8;\n    iVar4 = fcn.00460591();\n    extraout_ECX[0x19] = *(iVar4 + 0xc);\ncode_r0x004306a1:\n    iVar4 = *(unaff_EBP + 0x10);\n    extraout_ECX[0x28] = fcn.00430f80;\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(ppcVar1, *(unaff_EBP + 0x10), 0x104);\n    }\n    if (*(unaff_EBP + 0x18) != 0) {\n        fcn.00438cd1(*(unaff_EBP + 0x18));\n        puVar5 = fcn.00438f78(0);\n        while( true ) {\n            puVar5 = fcn.0040da79(puVar5, 0x7c);\n            if (puVar5 == NULL) break;\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        extraout_ECX[0x1a] = extraout_ECX[0x2b];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 993
    },
    "00432e3d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00432e3d(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    \n    fcn.0040d6f0(&var_38h, 0, 0x38);\n    var_2ch = 0x28;\n    if (arg_8h == 0) {\n        var_38h = 0;\n    }\n    else {\n        var_38h = *(arg_8h + 0x1c);\n    }\n    var_34h = arg_ch;\n    var_30h = arg_10h;\n    iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x40a, 0, &var_38h);\n    if (iVar1 != 0) {\n        fcn.0040cd30(arg_14h, &var_2ch, 0x28);\n    }\n    return iVar1 != 0;\n}\n",
        "token_count": 268
    },
    "00432eb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432eb0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_1ch;\n    \n    fcn.00432f79(&var_2ch, arg_8h, arg_ch);\n    fcn.0040cd30(&var_1ch, arg_10h, 0x10);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x406, 0, &var_2ch);\n    return;\n}\n",
        "token_count": 138
    },
    "00432f79": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00432f79(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    uint uVar2;\n    \n    fcn.0040d6f0(param_1, 0, 0x28);\n    *param_1 = 0x28;\n    if (param_2 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = *(param_2 + 0x1c);\n    }\n    if (param_3 == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(uVar2);\n        param_1[2] = uVar1;\n        param_1[1] = 1;\n        param_1[3] = uVar2;\n    }\n    else {\n        param_1[1] = 0;\n        param_1[2] = uVar2;\n        param_1[3] = param_3;\n    }\n    return;\n}\n",
        "token_count": 229
    },
    "004350a7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004350a7(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = fcn.00438337(param_2 * param_3 + 4);\n    *puVar1 = *param_1;\n    *param_1 = puVar1;\n    return;\n}\n",
        "token_count": 85
    },
    "00435328": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435328(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 8);\n    if (arg_8h < iVar1) {\n        fcn.0043513d(iVar1 + arg_10h, 0xffffffff);\n        fcn.0040dde0(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, *(in_ECX + 4) + arg_8h * 4, \n                     (arg_8h * 0x3fffffff + iVar1) * 4);\n        fcn.0040d6f0(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n    }\n    else {\n        fcn.0043513d(arg_8h + arg_10h, 0xffffffff);\n    }\n    if (arg_10h != 0) {\n        arg_8h = arg_8h << 2;\n        do {\n            *(*(in_ECX + 4) + arg_8h) = arg_ch;\n            arg_8h = arg_8h + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 331
    },
    "00435683": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435683(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 8);\n    if (arg_8h < iVar1) {\n        fcn.00435498(iVar1 + arg_10h, 0xffffffff);\n        fcn.0040dde0(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, *(in_ECX + 4) + arg_8h * 4, \n                     (arg_8h * 0x3fffffff + iVar1) * 4);\n        fcn.0040d6f0(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n    }\n    else {\n        fcn.00435498(arg_8h + arg_10h, 0xffffffff);\n    }\n    if (arg_10h != 0) {\n        arg_8h = arg_8h << 2;\n        do {\n            *(*(in_ECX + 4) + arg_8h) = arg_ch;\n            arg_8h = arg_8h + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 329
    },
    "00435715": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00435715(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*(param_1 + 8) - param_2) - param_3;\n    if (iVar1 != 0) {\n        fcn.0040dde0(*(param_1 + 4) + param_2 * 4, *(param_1 + 4) + (param_2 + param_3) * 4, iVar1 * 4);\n    }\n    *(param_1 + 8) = *(param_1 + 8) - param_3;\n    return;\n}\n",
        "token_count": 154
    },
    "00436d31": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00436d31(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.00436caa(arg_8h, &arg_8h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.00436bab(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.00436c44();\n        puVar2[1] = iVar1;\n        *puVar2 = *(*(in_ECX + 4) + arg_8h * 4);\n        *(*(in_ECX + 4) + arg_8h * 4) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 204
    },
    "00438385": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00438385(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    iVar1 = *(extraout_ECX + 0x10);\n    *(unaff_EBP + -4) = 0;\n    if (iVar1 != 0) {\n        (**(iVar1 + 0x1c))(extraout_ECX);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 168
    },
    "004389b5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004389b5(uint *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (param_2 == 0) {\n        *param_1 = *0x498098;\n    }\n    else {\n        uVar2 = 0x40;\n        if ((((param_2 < 0x41) || (uVar2 = 0x80,  param_2 < 0x81)) || (uVar2 = 0x100,  param_2 < 0x101)) ||\n           (uVar2 = 0x200,  param_2 < 0x201)) {\n            puVar1 = fcn.0040c6c2();\n            puVar1[2] = uVar2;\n        }\n        else {\n            puVar1 = fcn.00438337(param_2 + 0xd);\n            puVar1[2] = param_2;\n        }\n        *puVar1 = 1;\n        *(puVar1 + param_2 + 0xc) = 0;\n        puVar1[1] = param_2;\n        *param_1 = puVar1 + 3;\n    }\n    return;\n}\n",
        "token_count": 278
    },
    "00438a7f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438a7f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*param_1 + -0xc != *0x49809c) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n        if (iVar1 < 1) {\n            fcn.00438a37();\n        }\n        *param_1 = *0x498098;\n    }\n    return;\n}\n",
        "token_count": 112
    },
    "00438b48": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438b48(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*param_1 + -0xc != *0x49809c) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n        if (iVar1 < 1) {\n            fcn.00438a37();\n        }\n    }\n    return;\n}\n",
        "token_count": 99
    },
    "00438b72": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438b72(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t *in_ECX;\n    \n    if (arg_14h + arg_ch == 0) {\n        *arg_8h = *0x498098;\n    }\n    else {\n        fcn.004389b5(arg_14h + arg_ch);\n        fcn.0040cd30(*arg_8h, *in_ECX + arg_10h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "00438c54": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00438c54(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.00438b1f(param_2);\n    fcn.0040cd30(*param_1, param_2, param_2);\n    *(*param_1 + -8) = param_2;\n    *(*param_1 + param_2) = 0;\n    return;\n}\n",
        "token_count": 94
    },
    "00438cf8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00438cf8(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.0040da5c(param_2);\n    }\n    fcn.00438b1f(iVar1 * 2);\n    fcn.0043913b(*param_1, param_2, iVar1 * 2 + 1);\n    fcn.00438fc7(0xffffffff);\n    return param_1;\n}\n",
        "token_count": 137
    },
    "00438d39": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00438d39(int32_t *param_1, int32_t param_2, uint param_3, int32_t param_4)\n\n{\n    if (param_2 + param_4 != 0) {\n        fcn.004389b5(param_2 + param_4);\n        fcn.0040cd30(*param_1, param_2, param_2);\n        fcn.0040cd30(*param_1 + param_2, param_4, param_4);\n    }\n    return;\n}\n",
        "token_count": 123
    },
    "00439077": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00439077(int32_t *param_1, uint8_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((param_3 < *(*param_1 + -8)) && (iVar1 = fcn.0040da79(*param_1 + param_3, param_2),  iVar1 != 0)) {\n        return iVar1 - *param_1;\n    }\n    return -1;\n}\n",
        "token_count": 110
    },
    "00439357": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00439357(code **param_1)\n\n{\n    fcn.0043a6b2();\n    *param_1 = vtable.CDialog.0;\n    fcn.0040d6f0(param_1 + 0xf, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 75
    },
    "004394ee": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_34h\n\nuint __cdecl\nfcn.004394ee(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpTemplate;\n    uint var_ch_2;\n    uint hInstance;\n    uint var_10h;\n    uint var_40h;\n    uint var_34h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hWnd;\n    uint hMem;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar2 = fcn.00460591();\n        *(unaff_EBP + 0x10) = *(iVar2 + 8);\n    }\n    iVar2 = fcn.00460591();\n    piVar1 = *(iVar2 + 0x1038);\n    *(unaff_EBP + -0x28) = piVar1;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0043d76a(0x10);\n    fcn.0043d76a(0x3c000);\n    if (piVar1 == NULL) {\ncode_r0x0043956b:\n        if (*(unaff_EBP + 8) != 0) {\n            *(unaff_EBP + -0x1c) = *0x498098;\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x20) = 0;\n            iVar2 = fcn.0043ffab(*(unaff_EBP + 8), unaff_EBP + -0x1c, unaff_EBP + -0x20);\n            if (iVar2 == 0) {\ncode_r0x004395f6:\n                fcn.0043fd39(*(unaff_EBP + 8));\n                *(unaff_EBP + -4) = 2;\n                fcn.00440162(*(unaff_EBP + -0x20));\n                uVar3 = fcn.0043fe6c();\n                *(unaff_EBP + -0x14) = uVar3;\n                *(unaff_EBP + -4) = 1;\n                fcn.0043fe09();\n                if (*(unaff_EBP + -0x14) != 0) {\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n                    *(unaff_EBP + 8) = uVar3;\n                }\n            }\n            else {\n                iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n                if (iVar2 != 0) {\n                    iVar2 = fcn.0040dd23(*(unaff_EBP + -0x1c), \"MS Shell Dlg\");\n                    if (iVar2 != 0) {\n                        iVar2 = fcn.0040dd23(*(unaff_EBP + -0x1c), 0x471f3c);\n                        if (iVar2 != 0) {\n                            iVar2 = fcn.0040dd23(*(unaff_EBP + -0x1c), \"Helv\");\n                            if (iVar2 != 0) goto code_r0x00439638;\n                        }\n                    }\n                    if (*(unaff_EBP + -0x20) == 8) {\n                        *(unaff_EBP + -0x20) = 0;\n                    }\n                    goto code_r0x004395f6;\n                }\n            }\ncode_r0x00439638:\n            extraout_ECX[0xb] = -1;\n            extraout_ECX[9] = extraout_ECX[9] | 0x10;\n            fcn.0043af86(extraout_ECX);\n            if (*(unaff_EBP + 0xc) == 0) {\n                uVar3 = 0;\n            }\n            else {\n                uVar3 = *(*(unaff_EBP + 0xc) + 0x1c);\n            }\n            uVar3 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamA)\n                              (*(unaff_EBP + 0x10), *(unaff_EBP + 8), uVar3, fcn.004391f9, 0);\n            *(unaff_EBP + -0x18) = uVar3;\n            *(unaff_EBP + -4) = 0;\n            fcn.00438b48();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (piVar1 != NULL) {\n                (**(*piVar1 + 0x14))(unaff_EBP + -0x34);\n                if (*(unaff_EBP + -0x18) != 0) {\n                    (**(*extraout_ECX + 0xb4))(0);\n                }\n            }\n            iVar2 = fcn.0043afd2();\n            if (iVar2 == 0) {\n                (**(*extraout_ECX + 0xa4))();\n            }\n            if ((*(unaff_EBP + -0x18) != 0) && ((*(extraout_ECX + 9) & 0x10) == 0)) {\n                (*_sym.imp.USER32.dll_DestroyWindow)(*(unaff_EBP + -0x18));\n                *(unaff_EBP + -0x18) = 0;\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n            }\n            if ((*(unaff_EBP + -0x18) != 0) || ((*(extraout_ECX + 9) & 0x10) == 0)) {\n                uVar3 = 1;\n                goto code_r0x0043970a;\n            }\n        }\n    }\n    else {\n        iVar2 = (**(*extraout_ECX + 0xb4))(unaff_EBP + -0x34);\n        if (iVar2 != 0) {\n            uVar3 = (**(*piVar1 + 0x10))(unaff_EBP + -0x34, *(unaff_EBP + 8));\n            *(unaff_EBP + 8) = uVar3;\n            goto code_r0x0043956b;\n        }\n    }\n    uVar3 = 0;\ncode_r0x0043970a:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 1722
    },
    "0043976a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0043976a(code **param_1, code *param_2, code *param_3)\n\n{\n    fcn.0043a6b2();\n    *param_1 = vtable.CDialog.0;\n    fcn.0040d6f0(param_1 + 0xf, 0, 0x20);\n    param_1[0x14] = param_3;\n    param_1[0xf] = param_2;\n    param_1[0x10] = param_2 & 0xffff;\n    return param_1;\n}\n",
        "token_count": 134
    },
    "0043a422": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043a422(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (arg_ch == 0) {\ncode_r0x0043a476:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h != 0) {\n            do {\n                arg_10h = arg_10h + -1;\n                arg_ch = fcn.0040da79(arg_ch, arg_14h);\n                if (arg_ch == 0) {\n                    fcn.00438ad3();\n                    goto code_r0x0043a476;\n                }\n                arg_ch = arg_ch + 1;\n            } while (arg_10h != 0);\n        }\n        iVar1 = fcn.0040da79(arg_ch, arg_14h);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n        }\n        else {\n            iVar1 = iVar1 - arg_ch;\n        }\n        uVar2 = fcn.00438fef(iVar1, arg_ch, iVar1);\n        fcn.0040cd30(uVar2, iVar1, arg_ch);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 309
    },
    "0043a6b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0043a6b2(code **param_1)\n\n{\n    fcn.0043836b();\n    *param_1 = vtable.CWnd.0;\n    fcn.0040d6f0(param_1 + 7, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 75
    },
    "0043a6f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0043a6f0(code **param_1, code *param_2)\n\n{\n    fcn.0043836b();\n    *param_1 = vtable.CWnd.0;\n    fcn.0040d6f0(param_1 + 7, 0, 0x20);\n    param_1[7] = param_2;\n    return param_1;\n}\n",
        "token_count": 94
    },
    "0043aafa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0043aafa(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0043aa61(0);\n    uVar2 = 0;\n    if (iVar1 != 0) {\n        uVar2 = fcn.00436cdc(unaff_retaddr);\n    }\n    return uVar2;\n}\n",
        "token_count": 90
    },
    "0043b85d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n\nint32_t __cdecl fcn.0043b85d(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_1;\n    uint *noname_3;\n    uint lpWndClass;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.00460301();\n    iVar1 = iVar1 + 0x58;\n    iVar2 = fcn.00460591();\n    var_18h = *(iVar2 + 8);\n    if (((arg_ch == 0) && (arg_10h == 0)) && (arg_14h == 0)) {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar1, \"Afx:%x:%x\", var_18h, arg_8h);\n    }\n    else {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar1, \"Afx:%x:%x:%x:%x:%x\", var_18h, arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    noname_3 = &lpWndClass;\n    noname_1 = var_18h;\n    iVar2 = iVar1;\n    iVar3 = (*_sym.imp.USER32.dll_GetClassInfoA)();\n    if (iVar3 == 0) {\n        lpWndClass = arg_8h;\n        var_24h = _sym.imp.USER32.dll_DefWindowProcA;\n        var_1ch = 0;\n        var_20h = 0;\n        var_8h = 0;\n        var_14h = arg_14h;\n        var_10h = arg_ch;\n        var_ch = arg_10h;\n        var_4h = iVar1;\n        iVar2 = fcn.0043b7bc(&lpWndClass, noname_1, iVar2, noname_3, unaff_EDI, unaff_ESI, unaff_EBX, arg_8h, \n                             _sym.imp.USER32.dll_DefWindowProcA, 0, 0, var_18h, arg_14h, arg_ch, arg_10h, 0);\n        if (iVar2 == 0) {\n            fcn.00447b03();\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 752
    },
    "0043d113": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043d113(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t lpPoints;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.00439ecc();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        }\n        if ((iVar5 != 0) && (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x36b, 0, 0),  iVar4 != 0)) {\n            iVar5 = iVar4;\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x1c);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &var_28h);\n    if ((var_4h & 0x40000000) == 0) {\n        if ((iVar5 != 0) &&\n           ((uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0),  (uVar2 & 0x10000000) == 0 ||\n            ((uVar2 & 0x20000000) != 0)))) {\n            iVar5 = 0;\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.0040bd9c();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x1c);\n            }\n            uVar3 = fcn.0040c156(iVar5, 1);\n            fcn.0040c1c1(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.0040c156(iVar5, 2);\n            fcn.0040c1c1(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_30h) / 2 - (var_20h - var_28h) / 2;\n    iVar4 = (var_34h + var_2ch) / 2 - (var_1ch - var_24h) / 2;\n    if ((lprcDst <= iVar5) && (lprcDst = iVar5,  var_10h < (var_20h - var_28h) + iVar5)) {\n        lprcDst = (var_10h - var_20h) + var_28h;\n    }\n    if ((var_14h <= iVar4) && (var_14h = iVar4,  var_ch < (var_1ch - var_24h) + iVar4)) {\n        var_14h = (var_24h - var_1ch) + var_ch;\n    }\n    fcn.0043a058(0, lprcDst, var_14h, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1088
    },
    "0043e0cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043e0cf(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t hHandle;\n    int32_t hEvent;\n    int32_t var_4h;\n    \n    fcn.0040d6f0(&var_1ch, 0, 0x1c);\n    var_1ch = fcn.00460301();\n    pcVar1 = _sym.imp.KERNEL32.dll_CreateEventA;\n    hHandle = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 1, 0, 0);\n    hEvent = (*pcVar1)(0, 1, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n    var_14h = arg_8h;\n    if (hHandle != 0) {\n        if (hEvent != 0) {\n            iVar2 = fcn.0040e822(arg_10h, arg_ch, 0x43dda4, &var_1ch, arg_8h | 4, in_ECX + 0x2c);\n            *(in_ECX + 0x28) = iVar2;\n            if (iVar2 == 0) {\n                return 0;\n            }\n            (*_sym.imp.KERNEL32.dll_ResumeThread)(iVar2);\n            (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(hHandle, 0xffffffff);\n            (*pcVar1)(hHandle);\n            if ((arg_8h & 4) != 0) {\n                (*_sym.imp.KERNEL32.dll_SuspendThread)(*(in_ECX + 0x28));\n            }\n            if (var_4h == 0) {\n                (*_sym.imp.KERNEL32.dll_SetEvent)(hEvent);\n                return 1;\n            }\n            (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(in_ECX + 0x28), 0xffffffff);\n            (*pcVar1)(*(in_ECX + 0x28));\n            *(in_ECX + 0x28) = 0;\n            goto code_r0x0043e1a3;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hHandle);\n    }\n    if (hEvent == 0) {\n        return 0;\n    }\ncode_r0x0043e1a3:\n    (*pcVar1)(hEvent);\n    return 0;\n}\n",
        "token_count": 586
    },
    "0043e2a2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.0043e2a2(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    int32_t arg_8h;\n    \n    if (param_2 < 1) {\n        iVar3 = *(param_1 + 0x1c);\n        if ((iVar3 != 0) && (*(iVar3 + 0x1c) != 0)) {\n            iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x1c));\n            if (iVar1 != 0) {\n                fcn.0043a912(iVar3, *(iVar3 + 0x1c), 0x363, 1, 0);\n                fcn.0043c41d(*(iVar3 + 0x1c), 0x363, 1, 0, 1, 1);\n            }\n        }\n        fcn.00460591();\n        arg_8h = 0x460603;\n        iVar1 = fcn.00462aba(0x460603);\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x54)) {\n            if ((*(iVar1 + 0x1c) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0x88) == 0) {\n                    fcn.0043a0a7(0, arg_8h);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0x88))) {\n                    fcn.0043a912(iVar1, *(iVar1 + 0x1c), 0x363, 1, 0);\n                    arg_8h = *(iVar1 + 0x1c);\n                    fcn.0043c41d(arg_8h, 0x363, 1, 0, 1, 1);\n                }\n                iVar2 = *(iVar1 + 0x88);\n                if (0 < iVar2) {\n                    fcn.0043a0a7();\n                    arg_8h = iVar2;\n                }\n                *(iVar1 + 0x88) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.00460591();\n        iVar3 = fcn.00462aba(0x460603);\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.004402d3();\n            fcn.004402dc(1);\n        }\n    }\n    return unaff_EBX < 0;\n}\n",
        "token_count": 630
    },
    "0043e3b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043e3b9(int32_t *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint arg_10h;\n    uint arg_14h;\n    \n    puVar1 = (**(*param_1 + 0x28))();\n    do {\n        if (puVar1 == NULL) {\n            return 0;\n        }\n        if (*(param_2 + 4) < 0xc000) {\n            iVar2 = fcn.0043ba3f(puVar1[1], *(param_2 + 4), 0, 0);\n            if (iVar2 != 0) {\ncode_r0x0043e418:\n                (**(iVar2 + 0x14))(*(param_2 + 8), *(param_2 + 0xc));\n                return 1;\n            }\n        }\n        else {\n            iVar2 = puVar1[1];\n            arg_14h = 0;\n            arg_10h = 0;\n            while (iVar2 = fcn.0043ba3f(iVar2, 0xc000, arg_10h, arg_14h),  iVar2 != 0) {\n                if (**(iVar2 + 0x10) == *(param_2 + 4)) goto code_r0x0043e418;\n                iVar2 = iVar2 + 0x18;\n            }\n        }\n        puVar1 = *puVar1;\n    } while( true );\n}\n",
        "token_count": 338
    },
    "0043ed3b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043ed3b(uint arg_8h, uint *arg_ch)\n\n{\n    uint var_104h;\n    uint var_4h;\n    \n    var_4h = 0;\n    (*_sym.imp.USER32.dll_wsprintfA)\n              (&var_104h, \"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", *arg_ch, *(arg_ch + 1), *(arg_ch + 6), \n               *(arg_ch + 2), *(arg_ch + 9), *(arg_ch + 10), *(arg_ch + 0xb), *(arg_ch + 3), *(arg_ch + 0xd), \n               *(arg_ch + 0xe), *(arg_ch + 0xf));\n    fcn.00438bb6(&var_104h);\n    return arg_8h;\n}\n",
        "token_count": 206
    },
    "0043f048": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0043f048(void)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char cVar3;\n    uint unaff_retaddr;\n    \n    pcVar1 = fcn.00438f78(0x104);\n    fcn.0040d6f0(pcVar1, 0, 0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(pcVar1, unaff_retaddr, 0x104);\n    cVar3 = *pcVar1;\n    pcVar2 = pcVar1;\n    while ((cVar3 != '\\0' && (((cVar3 != '\\\\' && (cVar3 != '/')) || ((pcVar2[1] != '\\\\' && (pcVar2[1] != '/'))))))) {\n        pcVar2 = fcn.0040e115(pcVar2);\n        cVar3 = *pcVar2;\n    }\n    if (*pcVar2 == '\\0') {\n        cVar3 = *pcVar1;\n        while (((cVar3 != '\\0' && (cVar3 != '\\\\')) && (cVar3 != '/'))) {\n            pcVar1 = fcn.0040e115(pcVar1);\n            cVar3 = *pcVar1;\n        }\n    }\n    else {\n        for (pcVar1 = pcVar2 + 2; ((cVar3 = *pcVar1,  cVar3 != '\\0' && (cVar3 != '\\\\')) && (cVar3 != '/'));\n            pcVar1 = fcn.0040e115(pcVar1)) {\n        }\n        if (*pcVar1 == '\\0') goto code_r0x0043f0c9;\n        do {\n            pcVar1 = fcn.0040e115(pcVar1);\ncode_r0x0043f0c9:\n            cVar3 = *pcVar1;\n        } while (((cVar3 != '\\0') && (cVar3 != '\\\\')) && (cVar3 != '/'));\n    }\n    if (*pcVar1 != '\\0') {\n        pcVar1[1] = '\\0';\n    }\n    fcn.00438fc7(0xffffffff);\n    return;\n}\n",
        "token_count": 483
    },
    "0043f4c3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0043f4c3(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (0x10b < param_1) {\n        if (param_1 == 0x3e3) {\n            return 10;\n        }\n        if (param_1 == 0x3e4) {\n            return 10;\n        }\n        if (param_1 == 0x3e5) {\n            return 10;\n        }\n        if (param_1 == 999) {\n            return 5;\n        }\n        return 1;\n    }\n    if (param_1 == 0x10b) {\n        return 3;\n    }\n    if (param_1 < 0x3f) {\n        if (param_1 == 0x3e) {\n            return 8;\n        }\n        if (param_1 < 0x1a) {\n    // switch table (25 cases) at 0x43f6b9\n            switch(param_1) {\n            case 0:\n                return 0;\n            case 1:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 0xd:\n            case 0xe:\n                goto code_r0x0043f5c5;\n            case 2:\n            case 6:\n            case 0x12:\n                goto code_r0x0043f5c5;\n            case 3:\n            case 0xf:\n            case 0x11:\n                goto code_r0x0043f5c5;\n            case 4:\n                return 4;\n            case 5:\n            case 0xc:\n            case 0x13:\ncode_r0x0043f5c5:\n                return 5;\n            case 0xb:\ncode_r0x0043f5c5:\n                return 6;\n            case 0x10:\n                return 7;\n            case 0x14:\n            case 0x15:\n            case 0x16:\n            case 0x17:\ncode_r0x0043f5c5:\n                return 10;\n            default:\n                goto code_r0x0043f5c5;\n            }\n        }\n        if (0x27 < param_1) {\n    // switch table (9 cases) at 0x43f71d\n            switch(param_1) {\n            case 0x34:\n            case 0x35:\n            case 0x37:\n                goto code_r0x0043f5c5;\n            case 0x36:\n            case 0x3a:\n                goto code_r0x0043f5c5;\n            default:\n                return 1;\n            case 0x39:\n            case 0x3b:\n                goto code_r0x0043f5c5;\n            case 0x3c:\n                goto code_r0x0043f5c5;\n            }\n        }\n        if (param_1 == 0x27) {\n            return 0xd;\n        }\n        if (0x20 < param_1) {\n            if (param_1 == 0x21) {\n                return 0xc;\n            }\n            if (param_1 == 0x22) {\n                return 3;\n            }\n            if (param_1 == 0x24) {\n                return 4;\n            }\n            if (param_1 == 0x26) {\n                return 0xe;\n            }\n            return 1;\n        }\n        if (param_1 == 0x20) {\n            return 0xb;\n        }\n        if (param_1 == 0x1a) {\n            return 6;\n        }\n        if (param_1 == 0x1b) {\n            return 9;\n        }\n        iVar1 = param_1 - 0x1d;\n        if (iVar1 == 0) {\n            return 5;\n        }\ncode_r0x0043f53b:\n        if (iVar1 == 1) {\ncode_r0x0043f5c5:\n            return 9;\n        }\n    }\n    else {\n        if (param_1 < 0x6c) {\n            if (param_1 == 0x6b) {\ncode_r0x0043f5c5:\n                return 2;\n            }\n            if (0x47 < param_1) {\n                if (param_1 == 0x50) {\n                    return 5;\n                }\n                if (param_1 == 0x52) {\n                    return 5;\n                }\n                if (param_1 == 0x55) {\n                    return 3;\n                }\n                if (param_1 != 0x56) {\n                    if (param_1 == 0x58) {\n                        return 10;\n                    }\n                    return 1;\n                }\n                return 5;\n            }\n            if (param_1 == 0x47) {\n                return 5;\n            }\n            if (param_1 == 0x40) {\n                return 5;\n            }\n            if (param_1 == 0x41) {\n                return 5;\n            }\n            if (param_1 == 0x42) {\n                return 6;\n            }\n            if (param_1 == 0x43) {\n                return 3;\n            }\n            iVar1 = param_1 - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\n        }\n        else {\n            if (param_1 < 0x91) {\n                if (param_1 == 0x90) {\n                    return 3;\n                }\n                if (param_1 < 0x76) {\n                    if (param_1 == 0x75) {\n                        return 10;\n                    }\n                    if (param_1 == 0x6c) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0x6f) {\n                        return 3;\n                    }\n                    if (param_1 == 0x70) {\n                        return 0xd;\n                    }\n                    if (param_1 == 0x71) {\n                        return 4;\n                    }\n                    if (param_1 != 0x72) {\n                        return 1;\n                    }\n                    return 6;\n                }\n                if (param_1 == 0x7b) {\n                    return 3;\n                }\n                if (param_1 == 0x7c) {\n                    return 3;\n                }\n                if (param_1 == 0x7d) {\n                    return 3;\n                }\n                iVar1 = param_1 - 0x83;\n                if (iVar1 == 0) {\n                    return 9;\n                }\n                goto code_r0x0043f53b;\n            }\n            if (param_1 < 0xb7) {\n                if (param_1 == 0xb6) {\n                    return 6;\n                }\n                if (param_1 == 0x91) {\n                    return 7;\n                }\n                if (param_1 == 0x9a) {\n                    return 3;\n                }\n                if (param_1 != 0xa1) {\n                    if (param_1 == 0xa7) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0xaa) {\n                        return 5;\n                    }\n                    return 1;\n                }\n                return 3;\n            }\n            if (param_1 == 0xb7) {\n                return 5;\n            }\n            if (param_1 == 0xbf) {\n                return 6;\n            }\n            if (param_1 == 0xc1) {\n                return 6;\n            }\n            iVar1 = param_1 - 0xce;\n            if (iVar1 == 0) {\n                return 3;\n            }\n        }\n        if (iVar1 == 2) {\ncode_r0x0043f5c5:\n            return 3;\n        }\n    }\ncode_r0x0043f5c5:\n    return 1;\n}\n",
        "token_count": 1769
    },
    "0043fa00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043fa00(uint arg_8h, uint lpFileTime)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort *puVar3;\n    uint uVar4;\n    uint lpSystemTime;\n    uint var_12h;\n    ushort var_eh;\n    ushort var_ch;\n    uint var_ah;\n    \n    iVar2 = fcn.0042fca3(0);\n    lpSystemTime._0_2_ = *(iVar2 + 0x14) + 0x76c;\n    iVar2 = fcn.0042fca3(0);\n    lpSystemTime._2_2_ = *(iVar2 + 0x10) + 1;\n    iVar2 = fcn.0042fca3(0);\n    var_12h._0_2_ = *(iVar2 + 0xc);\n    iVar2 = fcn.0042fca3(0);\n    var_12h._2_2_ = *(iVar2 + 8);\n    iVar2 = fcn.0042fca3(0);\n    var_eh = *(iVar2 + 4);\n    puVar3 = fcn.0042fca3(0);\n    var_ch = *puVar3;\n    var_ah._0_2_ = 0;\n    iVar2 = (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, &var_ah + 2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar2 == 0) {\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0043f31d(uVar4);\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalFileTimeToFileTime)(&var_ah + 2, lpFileTime);\n    if (iVar2 == 0) {\n        uVar4 = (*pcVar1)(0);\n        fcn.0043f31d(uVar4);\n    }\n    return;\n}\n",
        "token_count": 461
    },
    "0043fe9d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0043fe9d(int32_t param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    \n    if (*(param_1 + 2) == -1) {\n        piVar1 = param_1 + 0x1a;\n    }\n    else {\n        piVar1 = param_1 + 0x12;\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    do {\n        iVar2 = *piVar1;\n        piVar1 = piVar1 + 1;\n    } while (iVar2 != 0);\n    return;\n}\n",
        "token_count": 266
    },
    "0044001a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0044001a(uint *param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint unaff_retaddr;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*param_1);\n    uVar1 = fcn.0043ffab(uVar1, unaff_retaddr, param_2);\n    (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*param_1);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "00440627": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00440627(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.004405a0(0);\n    uVar2 = 0;\n    if (iVar1 != 0) {\n        uVar2 = fcn.00436cdc(unaff_retaddr);\n    }\n    return uVar2;\n}\n",
        "token_count": 89
    },
    "00440789": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\ncode ** __cdecl fcn.00440789(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **ppcVar3;\n    code *pcVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    pcVar1 = *0x498098;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[3] = pcVar1;\n    pcVar1 = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[4] = pcVar1;\n    extraout_ECX[7] = *0x498098;\n    pcVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 2;\n    *extraout_ECX = vtable.CRecentFileList.0;\n    ppcVar3 = fcn.00438337(pcVar1 * 4 + 4);\n    *(unaff_EBP + -0x14) = ppcVar3;\n    *(unaff_EBP + -4) = 3;\n    if (ppcVar3 == NULL) {\n        pcVar4 = NULL;\n    }\n    else {\n        *ppcVar3 = pcVar1;\n        *(unaff_EBP + 0x14) = ppcVar3 + 1;\n        fcn.0040ef66(ppcVar3 + 1, 4, pcVar1, fcn.00401474);\n        pcVar4 = *(unaff_EBP + 0x14);\n    }\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[2] = pcVar4;\n    pcVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    extraout_ECX[1] = pcVar1;\n    extraout_ECX[5] = pcVar4;\n    fcn.00438cd1(uVar2);\n    fcn.00438cd1(*(unaff_EBP + 0x10));\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x18);\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 638
    },
    "004466c5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004466c5(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_14h;\n    uint var_10h;\n    \n    fcn.0040d6f0(&var_14h, 0, 0x14);\n    var_10h = arg_8h;\n    var_14h = 0x14;\n    (*_sym.imp.GDI32.dll_StartDocA)(*(in_ECX + 4), &var_14h);\n    return;\n}\n",
        "token_count": 118
    },
    "00447b35": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00447b35(uint param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint uVar3;\n    uint var_8h;\n    uint *var_4h_2;\n    uint lpString2;\n    \n    iVar1 = fcn.0043a3fb(var_8h, &lpString2, 0x100);\n    if (iVar1 != 0) {\n        puVar2 = fcn.0040da79(&lpString2, 10);\n        if (puVar2 != NULL) {\n            uVar3 = fcn.0040e9f1(puVar2 + 1);\n            *var_4h_2 = uVar3;\n            uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(uVar3, *0x49d0a4, 0x48);\n            *var_4h_2 = uVar3;\n            *puVar2 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(var_4h_2 + 7, &lpString2, 0x20);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 278
    },
    "004489b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004489b2(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(in_ECX[7], &var_18h);\n    var_38h = var_18h;\n    var_34h = var_14h;\n    var_30h = var_10h;\n    var_2ch = var_ch;\n    (**(*in_ECX + 0x60))(&var_38h, 0);\n    pcVar1 = _sym.imp.USER32.dll_OffsetRect;\n    var_14h = var_14h * 2 - var_34h;\n    var_10h = var_10h * 2 - var_30h;\n    var_18h = var_18h * 2 - var_38h;\n    var_ch = var_ch * 2 - var_2ch;\n    (*_sym.imp.USER32.dll_OffsetRect)(&var_18h, -var_18h, -var_14h);\n    var_20h = in_ECX[0x13];\n    var_1ch = in_ECX[0x14];\n    var_28h = 0;\n    var_24h = 0;\n    if (arg_8h != 0) {\n        if (var_10h <= var_20h) {\n            var_20h = var_10h;\n        }\n        if (var_ch <= var_1ch) {\n            var_1ch = var_ch;\n        }\n    }\n    (**(*in_ECX + 0x60))(&var_28h, 1);\n    (*pcVar1)(&var_28h, -var_28h, -var_24h);\n    if (arg_8h != 0) {\n        if (var_10h <= in_ECX[0x13]) {\n            var_20h = var_10h;\n        }\n        if (var_ch <= in_ECX[0x14]) {\n            var_1ch = var_ch;\n        }\n    }\n    iVar2 = fcn.0043c183();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(iVar2 + 0x1c), &var_48h);\n    var_8h = var_40h - var_48h;\n    fcn.0043a058(0, 0, 0, (var_8h - var_10h) + var_20h, (var_3ch - var_44h) + (var_1ch - var_ch), 0x16);\n    return;\n}\n",
        "token_count": 742
    },
    "00448beb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00448beb(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    uVar1 = fcn.00439ecc();\n    fcn.00448b91(arg_ch);\n    if ((*arg_ch != 0) && ((uVar1 & 0x200000) != 0)) {\n        *arg_8h = *arg_8h + *arg_ch;\n    }\n    if ((arg_ch[1] != 0) && ((uVar1 & 0x100000) != 0)) {\n        arg_8h[1] = arg_8h[1] + arg_ch[1];\n    }\n    if ((*arg_ch < *arg_8h) && (arg_ch[1] < arg_8h[1])) {\n        uVar2 = 1;\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 304
    },
    "00448c60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00448c60(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h, int32_t *arg_14h, int32_t *arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.00448b91(&var_8h);\n    piVar2 = arg_14h;\n    iVar1 = *(in_ECX + 0x50);\n    *arg_14h = *(in_ECX + 0x4c) - arg_8h;\n    arg_14h[1] = iVar1 - arg_ch;\n    piVar3 = fcn.0044882b(&arg_8h);\n    *arg_18h = *piVar3;\n    arg_18h[1] = piVar3[1];\n    arg_14h = 0 < *piVar2;\n    if (arg_14h == NULL) {\n        *arg_18h = 0;\n    }\n    else if (arg_1ch != 0) {\n        piVar2[1] = piVar2[1] + var_4h;\n    }\n    uVar4 = 0 < piVar2[1];\n    if (uVar4 == 0) {\n        arg_18h[1] = 0;\n    }\n    else {\n        if (arg_1ch != 0) {\n            *piVar2 = *piVar2 + var_8h;\n        }\n        if ((arg_14h == NULL) && (0 < *piVar2)) {\n            arg_14h = 0x1;\n            piVar2[1] = piVar2[1] + var_4h;\n        }\n    }\n    iVar1 = *piVar2;\n    if ((0 < iVar1) && (iVar1 <= *arg_18h)) {\n        *arg_18h = iVar1;\n    }\n    iVar1 = piVar2[1];\n    if ((0 < iVar1) && (iVar1 <= arg_18h[1])) {\n        arg_18h[1] = iVar1;\n    }\n    *arg_10h = arg_14h;\n    arg_10h[1] = uVar4;\n    return;\n}\n",
        "token_count": 577
    },
    "0044cae6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: ARG_0\n\nvoid __cdecl fcn.0044cae6(uint arg_8h, uint arg_ch, uint wParam)\n\n{\n    int32_t *piVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint ARG_0;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    piVar1 = *(unaff_EBP + 8);\n    if ((*piVar1 == 0) || (*(**(unaff_EBP + 0xc) + -8) <= *(unaff_EBP + 0x10))) {\n        if ((piVar1[2] != 0) && (piVar1[3] != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageA)(piVar1[2], 0xc5, *(unaff_EBP + 0x10), 0);\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_wsprintfA)(unaff_EBP + -0x2c, 0x472d38, *(unaff_EBP + 0x10));\n        *(unaff_EBP + 0x10) = *0x498098;\n        *(unaff_EBP + -4) = 0;\n        fcn.00453494(unaff_EBP + 0x10, 0xf114, unaff_EBP + -0x2c);\n        fcn.0044c0a0(*(unaff_EBP + 0x10), 0x30, 0xf114);\n        fcn.00438ad3();\n        fcn.0044c22b();\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00438b48();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 420
    },
    "0044ccb6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0044ccb6(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar1 = *(param_1 + 0x58);\n    if (0 < iVar1) {\n        piVar3 = *(param_1 + 0x5c);\n        iVar2 = 0;\n        if (0 < iVar1) {\n            do {\n                if (*piVar3 == param_2) {\n                    return iVar2;\n                }\n                iVar2 = iVar2 + 1;\n                piVar3 = piVar3 + 5;\n            } while (iVar2 < iVar1);\n        }\n    }\n    return -1;\n}\n",
        "token_count": 172
    },
    "0044cff7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044cff7(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.00451e14(&var_10h, 1);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 168
    },
    "0044d6ae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0044d6ae(int32_t param_1, int32_t param_2)\n\n{\n    return (param_1 + 0xe90) * 0x10 + param_2;\n}\n",
        "token_count": 50
    },
    "0044e8d5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044e8d5(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (arg_10h < 0) {\n        arg_10h = 0;\n    }\n    iVar3 = arg_ch + -1;\n    piVar2 = arg_8h;\n    if (0 < iVar3) {\n        do {\n            if (piVar2[1] < *piVar2) {\n                piVar2[1] = 0;\n            }\n            piVar2[2] = piVar2[1];\n            piVar2 = piVar2 + 3;\n            iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n    }\n    iVar3 = 0;\n    piVar2[2] = 0x7fffffff;\n    if (0 < arg_ch) {\n        arg_8h = arg_8h + 2;\n        do {\n            if (arg_10h == 0) {\n                *arg_8h = 0;\n            }\n            else {\n                if ((arg_10h < arg_8h[-2]) && (iVar3 != 0)) {\n                    *arg_8h = 0;\n                    arg_8h[-3] = arg_8h[-3] + *0x49d098 + arg_10h;\ncode_r0x0044e93b:\n                    arg_10h = 0;\n                }\n                else {\n                    iVar1 = *arg_8h;\n                    if (iVar1 == 0) {\n                        if (iVar3 != 0) {\n                            *arg_8h = 0;\n                        }\n                    }\n                    else {\n                        if (arg_10h < iVar1) {\n                            *arg_8h = arg_10h;\n                            goto code_r0x0044e93b;\n                        }\n                        arg_10h = arg_10h - iVar1;\n                    }\n                }\n                if (iVar3 != arg_ch + -1) {\n                    if (arg_14h < arg_10h) {\n                        arg_10h = arg_10h - arg_14h;\n                    }\n                    else {\n                        arg_10h = arg_10h + *arg_8h;\n                        *arg_8h = arg_10h;\n                        if (arg_14h - *0x49d098 < arg_10h) {\n                            *arg_8h = (arg_10h - arg_14h) + *0x49d09c;\n                        }\n                        arg_10h = 0;\n                    }\n                }\n            }\n            iVar3 = iVar3 + 1;\n            arg_8h = arg_8h + 3;\n        } while (iVar3 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 647
    },
    "0044e995": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0044e995(uint arg_8h, int32_t *arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    int32_t lprc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (arg_20h != 0) {\n        uVar1 = 1;\n        if ((1 < arg_18h) && (1 < arg_1ch)) {\n            uVar1 = 0;\n        }\n        fcn.00439f00((-uVar1 & 0xff800000) + 0x800000, -uVar1 & 0x800000, 0);\n    }\n    pcVar2 = _sym.imp.USER32.dll_InflateRect;\n    lprc1 = arg_10h;\n    var_ch = arg_14h;\n    var_8h = arg_10h + arg_18h;\n    var_4h = arg_14h + arg_1ch;\n    if (*0x49d0e4 == 0) {\n        if (arg_20h == 0) {\n            (**(*arg_ch + 0x60))(&lprc1, 0);\n        }\n        else {\n            (*_sym.imp.USER32.dll_InflateRect)(&lprc1, 1, 1);\n        }\n    }\n    uVar3 = fcn.00439ee6();\n    if ((uVar3 & 0x200) == 0) {\n        iVar4 = fcn.0043a281(0x472d70);\n        if (iVar4 == 0) goto code_r0x0044ea4e;\n    }\n    (*pcVar2)(&lprc1, *0x49d098, *0x49d09c);\ncode_r0x0044ea4e:\n    (*_sym.imp.USER32.dll_GetWindowRect)(arg_ch[7], &lpRect);\n    uVar5 = (*_sym.imp.USER32.dll_GetParent)(arg_ch[7]);\n    fcn.0043aad3(uVar5);\n    fcn.00447040(&lpRect);\n    iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lprc1, &lpRect);\n    if (iVar4 == 0) {\n        fcn.0043c85e(arg_8h, arg_ch[7], &lprc1);\n    }\n    return;\n}\n",
        "token_count": 619
    },
    "0044fefe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0044fefe(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint *puVar3;\n    int32_t var_24h;\n    uint8_t var_1bh;\n    uint var_1ah;\n    uint var_10h;\n    \n    (**(*in_ECX + 0xa0))(0x417, arg_8h, &var_24h);\n    var_1ah._0_1_ = 0;\n    var_1ah._1_1_ = 0;\n    *(arg_ch + 2) = *(arg_ch + 2) ^ 4;\n    *(arg_ch + 10) = 0;\n    *(arg_ch + 0xb) = 0;\n    iVar1 = fcn.0040d9b0(arg_ch, &var_24h, 0x14);\n    if (iVar1 != 0) {\n        uVar2 = fcn.00439ecc();\n        fcn.00439f00(0x10000000, 0, 0);\n        (**(*in_ECX + 0xa0))(0x416, arg_8h, 0);\n        (**(*in_ECX + 0xa0))(0x415, arg_8h, arg_ch);\n        fcn.00439f00(0, uVar2 & 0x10000000, 0);\n        if ((((*(arg_ch + 9) ^ var_1bh) & 1) == 0) && (((*(arg_ch + 9) & 1) == 0 || (*arg_ch == var_24h)))) {\n            iVar1 = (**(*in_ECX + 0xa0))(0x41d, arg_8h, &var_10h);\n            if (iVar1 == 0) {\n                return;\n            }\n            puVar3 = &var_10h;\n        }\n        else {\n            puVar3 = NULL;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(in_ECX[7], puVar3, 1);\n    }\n    return;\n}\n",
        "token_count": 495
    },
    "00450312": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00450312(uint arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    if (arg_14h == 0) {\n        arg_14h = arg_10h;\n        var_4h = fcn.00450238(arg_8h, arg_ch, arg_10h);\n        iVar1 = fcn.00450238(arg_8h, arg_ch, 0);\n        if ((iVar1 != var_4h) && (0 < arg_10h)) {\n            do {\n                iVar1 = (arg_14h + iVar4) / 2;\n                iVar2 = fcn.00450238(arg_8h, arg_ch, iVar1);\n                if ((iVar2 != var_4h) && (bVar5 = iVar4 == iVar1,  iVar4 = iVar1,  iVar1 = arg_14h,  bVar5)) {\n                    fcn.00450238(arg_8h, arg_ch, arg_14h);\n                    break;\n                }\n                arg_14h = iVar1;\n            } while (iVar4 < arg_14h);\n        }\n        piVar3 = fcn.00450116(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        var_ch = piVar3[1];\ncode_r0x0045045b:\n        fcn.00450238(arg_8h, arg_ch, iVar4);\n    }\n    else {\n        fcn.00450238(arg_8h, arg_ch, 0);\n        piVar3 = fcn.00450116(&var_10h, arg_8h, arg_ch);\n        iVar1 = *piVar3;\n        var_4h = piVar3[1];\n        fcn.00450238(arg_8h, arg_ch, 0x7fff);\n        piVar3 = fcn.00450116(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        while( true ) {\n            var_ch = piVar3[1];\n            while( true ) {\n                if (iVar4 <= iVar1) {\n                    return;\n                }\n                fcn.00450238(arg_8h, arg_ch, (iVar1 + iVar4) / 2);\n                piVar3 = fcn.00450116(&var_18h, arg_8h, arg_ch);\n                var_10h = *piVar3;\n                if (piVar3[1] <= arg_10h) break;\n                if ((iVar1 == *piVar3) && (var_4h == piVar3[1])) goto code_r0x0045045b;\n                iVar1 = *piVar3;\n                var_4h = piVar3[1];\n            }\n            if (arg_10h <= piVar3[1]) break;\n            iVar4 = *piVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 738
    },
    "00450bdc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00450bdc(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.00451e14(&var_10h, (*(in_ECX + 100) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    if (*0x49851c < 0x40047) {\n        arg_ch[1] = arg_ch[1] + -2;\n    }\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 222
    },
    "00451d9b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00451d9b(int32_t param_1, uint param_2, int32_t *param_3)\n\n{\n    int32_t iVar1;\n    int32_t arg_ch;\n    int32_t arg_14h;\n    int32_t arg_10h;\n    \n    if ((*(param_1 + 100) & 0x400001) == 0x400000) {\n        iVar1 = *(param_1 + 0x48);\n        if ((*(param_1 + 100) & 0xa000) == 0) {\n            arg_10h = ((param_3[2] - *(param_1 + 0x4c)) - *param_3) - iVar1;\n            arg_14h = 3;\n            arg_ch = param_3[1] + 2;\n            iVar1 = *param_3 + iVar1;\n        }\n        else {\n            arg_14h = ((param_3[3] - *(param_1 + 0x4c)) - param_3[1]) - iVar1;\n            arg_ch = param_3[1] + iVar1;\n            arg_10h = 3;\n            iVar1 = *param_3 + 2;\n        }\n        fcn.0045c71a(iVar1, arg_ch, arg_10h, arg_14h, *0x49d0b8, *0x49d0b4);\n    }\n    return;\n}\n",
        "token_count": 327
    },
    "00452aed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00452aed(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.00451e14(&var_10h, *(in_ECX + 100) & 0xa000);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 183
    },
    "00452c46": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.00452c46(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint noname_3, uint noname_4, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    bool bVar5;\n    bool bVar6;\n    int32_t lpRect;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_8h = 0;\n    uVar4 = *(in_ECX + 100) & 0xa000;\n    var_10h = 0;\n    var_4h = 0;\n    if (0 < *(in_ECX + 0x84)) {\n        do {\n            iVar3 = var_4h;\n            piVar1 = fcn.00452c2a();\n            if ((piVar1 == NULL) || (iVar2 = (**(*piVar1 + 200))(),  iVar2 == 0)) {\n                iVar3 = var_8h - *0x49d09c;\n                var_8h = 0;\n                var_10h = var_10h + iVar3;\n                iVar3 = arg_20h;\n                if (uVar4 == 0) {\n                    iVar3 = arg_1ch;\n                }\n                if (iVar3 < var_10h) {\n                    if (var_4h == 0) {\n                        fcn.00435683(var_ch + 1, 0, 1);\n                    }\n                    iVar3 = var_ch + 1;\n                    goto code_r0x00452d4e;\n                }\ncode_r0x00452d18:\n                var_ch = var_4h;\n            }\n            else {\n                (*_sym.imp.USER32.dll_GetWindowRect)(piVar1[7], &lpRect, iVar3);\n                fcn.00447040(&lpRect);\n                if (uVar4 == 0) {\n                    iVar3 = (var_18h - lpRect) + -1;\n                }\n                else {\n                    iVar3 = var_14h - var_1ch;\n                }\n                if (var_8h <= iVar3) {\n                    if (uVar4 == 0) {\n                        var_8h = (var_18h - lpRect) + -1;\n                    }\n                    else {\n                        var_8h = var_14h - var_1ch;\n                    }\n                }\n                if (uVar4 == 0) {\n                    bVar6 = SBORROW4(arg_10h, var_1ch);\n                    iVar3 = arg_10h - var_1ch;\n                    bVar5 = arg_10h == var_1ch;\n                }\n                else {\n                    bVar6 = SBORROW4(arg_ch, lpRect);\n                    iVar3 = arg_ch - lpRect;\n                    bVar5 = arg_ch == lpRect;\n                }\n                if (!bVar5 && bVar6 == iVar3 < 0) goto code_r0x00452d18;\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < *(in_ECX + 0x84));\n    }\n    iVar3 = var_ch + 1;\n    fcn.00435683(iVar3, 0, 1);\ncode_r0x00452d4e:\n    fcn.00435683(iVar3, arg_8h, 1);\n    return iVar3;\n}\n",
        "token_count": 854
    },
    "00453e71": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00453e71(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uchar *puStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uchar auStack28 [28];\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        puStack64 = auStack28;\n        uStack52 = 0xf;\n        uStack56 = 0xf;\n        uStack48 = 0;\n        uStack60 = 0;\n        iVar2 = (*pcVar1)();\n        if (iVar2 == 0) {\n            *(param_1 + 0x70) = *(*(param_1 + 0x68) + 0x68);\n            *(param_1 + 0x78) = *(*(param_1 + 0x68) + 100) & 0xf000;\n            (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0xc);\n            *(param_1 + 0x20) = 0;\n            *(param_1 + 0x1c) = 0;\n            *(param_1 + 0x24) = 0;\n            *(param_1 + 0x7c) = 0;\n            *(param_1 + 0x80) = 0;\n            uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            iVar2 = fcn.0043aad3(uVar3);\n            iVar4 = (*_sym.imp.USER32.dll_LockWindowUpdate)(*(iVar2 + 0x1c));\n            if (iVar4 == 0) {\n                uVar3 = 3;\n            }\n            else {\n                uVar3 = 0x403;\n            }\n            uVar3 = (*_sym.imp.USER32.dll_GetDCEx)(*(iVar2 + 0x1c), 0, uVar3);\n            uVar3 = fcn.004465de(uVar3);\n            *(param_1 + 0x84) = uVar3;\n            return;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&uStack48, 0, 0xf, 0xf);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&puStack64);\n    }\n    return;\n}\n",
        "token_count": 557
    },
    "00453f32": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00453f32(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    fcn.00453f7b(1);\n    (*_sym.imp.USER32.dll_ReleaseCapture)();\n    uVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    iVar2 = fcn.0043aad3(uVar1);\n    (*_sym.imp.USER32.dll_LockWindowUpdate)(0);\n    if (*(param_1 + 0x84) != 0) {\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(iVar2 + 0x1c), *(*(param_1 + 0x84) + 4));\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 176
    },
    "0045896f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0045896f(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    char *pcVar1;\n    \n    for (pcVar1 = param_3 + param_1; (pcVar1 < param_2 + param_1 && (*pcVar1 != '\\r')); pcVar1 = pcVar1 + 1) {\n    }\n    return pcVar1 - param_1;\n}\n",
        "token_count": 102
    },
    "004592d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004592d3(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    int32_t arg_ch;\n    int32_t lParam;\n    int32_t wParam;\n    \n    lParam = in_ECX;\n    wParam = in_ECX;\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0xb0, &wParam, &lParam);\n    iVar1 = fcn.00459205();\n    iVar2 = fcn.0045896f(iVar1, lParam, wParam);\n    iVar2 = iVar2 - wParam;\n    iVar1 = iVar1 + wParam;\n    arg_ch = iVar2;\n    arg_8h_00 = fcn.00438f78(iVar2, iVar1, iVar2);\n    fcn.0040cd30(arg_8h_00, arg_ch, iVar1);\n    fcn.00438fc7(iVar2);\n    fcn.00459293();\n    return;\n}\n",
        "token_count": 244
    },
    "00459cd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00459cd0(uint param_1)\n\n{\n    fcn.00460591();\n    fcn.00462aba(0x460603);\n    fcn.004625ee(param_1);\n    return;\n}\n",
        "token_count": 53
    },
    "00459cf4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00459cf4(uint param_1)\n\n{\n    fcn.00460591();\n    fcn.00462aba(0x460603);\n    fcn.00462601(param_1);\n    return;\n}\n",
        "token_count": 53
    },
    "0045bdb7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0045bdb7(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_10h;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint32_t *puVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    puVar3 = 0x473e84;\n    *(arg_8h_00 + 0xb4) = 0x473ea0;\n    do {\n        if (((*(unaff_EBP + 8) & *puVar3 & 0xf000) != 0) && (iVar2 = fcn.0045b49a(puVar3[-1]),  iVar2 == 0)) {\n            iVar2 = fcn.00438337(0xa4);\n            *(unaff_EBP + -0x10) = iVar2;\n            *(unaff_EBP + -4) = 0;\n            if (iVar2 != 0) {\n                fcn.00451ebd(0);\n            }\n            uVar1 = *puVar3;\n            arg_10h = puVar3[-1];\n            *(unaff_EBP + -4) = 0xffffffff;\n            iVar2 = fcn.00451fc0(arg_8h_00, uVar1 | 0x56000000, arg_10h);\n            if (iVar2 == 0) {\n                fcn.00447b03();\n            }\n        }\n        puVar3 = puVar3 + 2;\n    } while (puVar3 < 0x473ea4);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 454
    },
    "0045be74": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045be74(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        iVar2 = 0;\n        puVar1 = 0x473e84;\n        do {\n            if (((*puVar1 ^ *(arg_8h + 100)) & 0xf000) == 0) {\n                fcn.0045b49a(*(iVar2 * 8 + 0x473e80));\n                break;\n            }\n            puVar1 = puVar1 + 2;\n            iVar2 = iVar2 + 1;\n        } while (puVar1 < 0x473ea4);\n    }\n    fcn.00452073(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 204
    },
    "0045bec9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045bec9(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    \n    if (arg_ch == 0) {\n        puVar3 = 0x473e80;\n        do {\n            uVar2 = *puVar3;\n            iVar1 = fcn.0045b49a();\n            if (iVar1 != 0) {\n                uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n                uVar2 = uVar2 & 0xffff;\n                iVar1 = fcn.00452bbb(uVar2);\n                if (0 < iVar1) break;\n            }\n            if (((puVar3[1] ^ *(arg_8h + 100)) & 0xf000) == 0) {\n                fcn.0045b49a(*puVar3, uVar2);\n            }\n            puVar3 = puVar3 + 2;\n        } while (puVar3 < 0x473ea0);\n    }\n    fcn.0045229e(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 288
    },
    "0045c6a3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045c6a3(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t Y, uint crColor)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    var_10h = arg_8h;\n    var_8h = arg_8h + arg_10h;\n    var_ch = arg_ch;\n    var_4h = arg_ch + Y;\n    (*_sym.imp.GDI32.dll_ExtTextOutA)(*(in_ECX + 4), 0, 0, 2, &var_10h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 209
    },
    "0045c71a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045c71a(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint var_4h;\n    \n    fcn.0045c6a3(arg_8h, arg_ch, arg_10h + -1, 1, arg_18h);\n    fcn.0045c6a3(arg_8h, arg_ch, 1, arg_14h + -1, arg_18h);\n    fcn.0045c6a3(arg_8h + arg_10h, arg_ch, 0xffffffff, arg_14h, arg_1ch);\n    fcn.0045c6a3(arg_8h, arg_ch + arg_14h, arg_10h, 0xffffffff, arg_1ch);\n    return;\n}\n",
        "token_count": 209
    },
    "0045c784": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0045c784(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint var_3ch;\n    uint var_25h;\n    uint var_20h;\n    \n    fcn.0040d6f0(&var_3ch, 0, 0x3c);\n    var_3ch = arg_8h;\n    var_25h._0_1_ = 1;\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(&var_20h, arg_ch, 0x20);\n    fcn.0045c7c9(&var_3ch, arg_10h);\n    return;\n}\n",
        "token_count": 164
    },
    "0045c9fb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lptm\n// WARNING: Variable defined which should be unmapped: var_a4h\n\nvoid fcn.0045c9fb(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar4;\n    char *lptm;\n    uint var_a4h;\n    uint lpvObject;\n    uint var_74h;\n    uint var_70h;\n    uint var_60h;\n    uint var_50h;\n    uint var_49h;\n    uint lpString1;\n    uint var_24h;\n    uint var_20h;\n    uint hdc;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    if (*0x49d0ec != 0) goto code_r0x0045cb5a;\n    fcn.0046255d(10);\n    if (*0x49d51c == 0) {\n        iVar2 = fcn.00460591();\n        *0x49d51c = (*_sym.imp.USER32.dll_LoadBitmapA)(*(iVar2 + 0xc), 0x7912);\n        iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(*0x49d51c, 0x18, unaff_EBP + -0x78);\n        if (iVar2 != 0) {\n            *0x49d510 = *(unaff_EBP + -0x74);\n            *0x49d514 = *(unaff_EBP + -0x70);\n        }\n    }\n    if (*0x49d518 == 0) {\n        fcn.0040d6f0(unaff_EBP + -0x60, 0, 0x3c);\n        *(unaff_EBP + -0x49) = 1;\n        *(unaff_EBP + -0x50) = 400;\n        *(unaff_EBP + -0x60) = 1 - *0x49d514;\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        if (iVar2 == 0) {\n            lptm = \"Small Fonts\";\n        }\n        else {\n            lptm = \"Terminal\";\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(unaff_EBP + -0x44, lptm);\n        iVar2 = fcn.00447b35(0xf233, unaff_EBP + -0x60);\n        if (iVar2 == 0) {\n            *(unaff_EBP + -0x45) = 0x20;\n        }\n        *0x49d518 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(unaff_EBP + -0x60);\n        if (*0x49d518 != 0) goto code_r0x0045cadc;\n    }\n    else {\ncode_r0x0045cadc:\n        fcn.00447632(0);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        iVar2 = *0x49d518;\n        bVar4 = *0x49d518 == 0;\n        *(unaff_EBP + -4) = 0;\n        if (bVar4) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = (*pcVar1)(*(unaff_EBP + -0x20), iVar2);\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(unaff_EBP + -0x1c), unaff_EBP + -0xb0);\n        *(unaff_EBP + -0x10) = uVar3;\n        if (iVar2 != 0) {\n            (*pcVar1)(*(unaff_EBP + -0x20), iVar2);\n        }\n        if ((*(unaff_EBP + -0x10) == 0) || (*0x49d514 < *(unaff_EBP + -0xb0) - *(unaff_EBP + -0xa4))) {\n            fcn.00447cef(0x49d518);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004476a4();\n    }\n    fcn.004625cd(10);\ncode_r0x0045cb5a:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1011
    },
    "0045d2c7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045d2c7(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_CopyRect;\n    (*_sym.imp.USER32.dll_CopyRect)(&var_10h, arg_ch);\n    pcVar1 = _sym.imp.USER32.dll_FillRect;\n    var_8h = var_10h + arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*_sym.imp.USER32.dll_FillRect)(*(arg_8h + 4), &var_10h, iVar3);\n    var_8h = *(arg_ch + 8);\n    var_10h = var_8h - arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, iVar3);\n    (*pcVar2)(&var_10h, arg_ch);\n    var_4h = var_ch + arg_14h;\n    var_10h = var_10h + arg_10h;\n    var_8h = var_8h - arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, iVar3);\n    var_4h = *(arg_ch + 0xc);\n    var_ch = var_4h - arg_14h;\n    if (arg_18h != 0) {\n        arg_18h = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, arg_18h);\n    return;\n}\n",
        "token_count": 536
    },
    "004605b7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004605b7(void)\n\n{\n    fcn.00460591();\n    fcn.00462aba(0x460603);\n    return;\n}\n",
        "token_count": 37
    },
    "00460adb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: hdc\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_30h\n\nint32_t __cdecl fcn.00460adb(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t *piVar5;\n    uint unaff_EDI;\n    int32_t *piVar6;\n    uint *in_FS_OFFSET;\n    uint var_38h;\n    uint hdc;\n    uint var_30h;\n    uint in_stack_ffffffd4;\n    uint lpSize;\n    uint var_1ch;\n    uint var_18h;\n    uint hgdiobj;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    iVar2 = fcn.00460c14(*(unaff_EBP + 0xc));\n    if (iVar2 != 0) {\n        *(unaff_EBP + -0x18) = 1;\n        if (*(unaff_EBP + 8) != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(extraout_ECX + 0x1c), 0x31, 0, 0);\n            fcn.00447632(0);\n            *(unaff_EBP + -4) = 0;\n            *(unaff_EBP + -0x14) = 0;\n            if (iVar2 != 0) {\n                uVar3 = (*_sym.imp.GDI32.dll_SelectObject)(*(unaff_EBP + -0x34), iVar2);\n                *(unaff_EBP + -0x14) = uVar3;\n            }\n            piVar6 = *(extraout_ECX + 0x5c);\n            *(unaff_EBP + -0x10) = 0;\n            if (0 < *(unaff_EBP + 0xc)) {\n                piVar5 = piVar6 + 4;\n                do {\n                    piVar1 = *(unaff_EBP + 8);\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + 4;\n                    iVar2 = *piVar1;\n                    piVar5[-1] = piVar5[-1] | 1;\n                    *piVar6 = iVar2;\n                    if (iVar2 != 0) {\n                        iVar2 = fcn.0043a377(iVar2);\n                        if (iVar2 != 0) {\n                            (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                                      (*(unaff_EBP + -0x30), *piVar5, *(*piVar5 + -8), unaff_EBP + -0x24);\n                            piVar5[-3] = *(unaff_EBP + -0x24);\n                            iVar2 = fcn.0044ce5d(*(unaff_EBP + -0x10), *piVar5, 0, 0x14, unaff_EDI, in_stack_ffffffd4);\n                            if (iVar2 != 0) goto code_r0x00460bbf;\n                        }\n                        *(unaff_EBP + -0x18) = 0;\n                        break;\n                    }\n                    iVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n                    iVar2 = *(unaff_EBP + -0x10);\n                    piVar5[-3] = iVar4 / 4;\n                    if (iVar2 == 0) {\n                        piVar5[-2] = piVar5[-2] | 0x8000100;\n                    }\ncode_r0x00460bbf:\n                    piVar6 = piVar6 + 5;\n                    piVar5 = piVar5 + 5;\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n                } while (*(unaff_EBP + -0x10) < *(unaff_EBP + 0xc));\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.GDI32.dll_SelectObject)(*(unaff_EBP + -0x34), *(unaff_EBP + -0x14));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.004476a4();\n        }\n        fcn.00460ce8(1, 1);\n        iVar2 = *(unaff_EBP + -0x18);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 1081
    },
    "00460c14": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00460c14(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x58)) {\n        do {\n            fcn.00438b48();\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x58));\n    }\n    iVar1 = fcn.00461633(param_2, param_3);\n    if (iVar1 != 0) {\n        iVar1 = 0;\n        if (0 < *(param_1 + 0x58)) {\n            arg_8h = *(param_1 + 0x5c) + 0x10;\n            do {\n                fcn.0040cd30(arg_8h, 0x498098, 4);\n                arg_8h = arg_8h + 0x14;\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < *(param_1 + 0x58));\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 272
    },
    "004613f9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004613f9(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    int32_t *piVar4;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar4 = arg_8h;\n    for (iVar1 = (**(*in_ECX + 0xa0))(0x418, 0, 0); iVar1 != 0; iVar1 = iVar1 + -1) {\n        (**(*in_ECX + 0xa0))(0x416, 0, 0);\n    }\n    fcn.0040d6f0(&var_18h, 0, 0x14);\n    var_8h = 0xffffffff;\n    if (arg_8h == NULL) {\n        iVar1 = 0;\n        var_10h._0_1_ = 4;\n        if (0 < arg_ch) {\n            do {\n                iVar3 = (**(*in_ECX + 0xa0))(0x414, 1, &var_18h);\n                if (iVar3 == 0) {\n                    return 0;\n                }\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < arg_ch);\n        }\n    }\n    else {\n        arg_8h = NULL;\n        var_4h = 0;\n        if (0 < arg_ch) {\n            do {\n                var_14h = *piVar4;\n                piVar4 = piVar4 + 1;\n                var_10h._0_1_ = 4;\n                if (var_14h == 0) {\n                    var_10h._1_1_ = 1;\n                    uVar2 = fcn.00439ecc();\n                    if (((uVar2 & 0x800) == 0) && (*0x49851c != 0x40047)) {\n                        var_18h = 8;\n                    }\n                    else {\n                        var_18h = 6;\n                    }\n                }\n                else {\n                    var_10h._1_1_ = 0;\n                    var_18h = arg_8h;\n                    arg_8h = arg_8h + 1;\n                }\n                iVar1 = (**(*in_ECX + 0xa0))(0x414, 1, &var_18h);\n                if (iVar1 == 0) {\n                    return 0;\n                }\n                var_4h = var_4h + 1;\n            } while (var_4h < arg_ch);\n        }\n    }\n    iVar1 = (**(*in_ECX + 0xa0))(0x418, 0, 0);\n    in_ECX[0x16] = iVar1;\n    in_ECX[0x21] = 1;\n    return 1;\n}\n",
        "token_count": 684
    },
    "00461b02": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00461b02(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint32_t uVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWinApp.0;\n    piVar1 = extraout_ECX[0x20];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n    }\n    if (extraout_ECX[0x2a] != NULL) {\n        (**(*extraout_ECX[0x2a] + 0x14))(1);\n    }\n    iVar3 = fcn.00460591();\n    if (*(iVar3 + 0x14) == '\\0') {\n        if (*0x49d084 != NULL) {\n            (**(**0x49d084 + 4))(1);\n            *0x49d084 = NULL;\n        }\n        if (*0x49d080 != NULL) {\n            (**(**0x49d080 + 4))(1);\n            *0x49d080 = NULL;\n        }\n    }\n    if (extraout_ECX[0x25] != NULL) {\n        fcn.00447d7f(extraout_ECX[0x25]);\n    }\n    pcVar4 = extraout_ECX[0x26];\n    if (pcVar4 != NULL) {\n        pcVar4 = fcn.00447d7f(pcVar4);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalDeleteAtom;\n    uVar5 = pcVar4 & 0xffff0000 | *(extraout_ECX + 0x2c);\n    if (*(extraout_ECX + 0x2c) != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar5);\n    }\n    if (*(extraout_ECX + 0xb2) != 0) {\n        (*pcVar2)(uVar5 & 0xffff0000 | *(extraout_ECX + 0xb2));\n    }\n    if (extraout_ECX[0x2b] != NULL) {\n        (**(*extraout_ECX[0x2b] + 4))(1);\n    }\n    iVar3 = fcn.00460591();\n    if (*(iVar3 + 0x10) == extraout_ECX[0x1e]) {\n        *(iVar3 + 0x10) = 0;\n    }\n    if (*(iVar3 + 4) == extraout_ECX) {\n        *(iVar3 + 4) = 0;\n    }\n    fcn.0040d21b(extraout_ECX[0x1e]);\n    fcn.0040d21b(extraout_ECX[0x1f]);\n    fcn.0040d21b(extraout_ECX[0x22]);\n    fcn.0040d21b(extraout_ECX[0x23]);\n    fcn.0040d21b(extraout_ECX[0x24]);\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[10] = NULL;\n    fcn.0046a1fb();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 856
    },
    "00462fa3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00462fa3(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    fcn.0040d21b(*(param_1 + 0x7c));\n    uVar1 = fcn.0040e6b9(param_2);\n    *(param_1 + 0x7c) = uVar1;\n    fcn.0040d21b(*(param_1 + 0x90));\n    uVar1 = fcn.0040e6b9(*(param_1 + 0x78));\n    *(param_1 + 0x90) = uVar1;\n    return;\n}\n",
        "token_count": 150
    },
    "0046338a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "delete registry key",
            "query or enumerate registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0046338a(uint phkResult)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uchar *puVar2;\n    uint lpName;\n    \n    arg_8h = fcn.0040e6b9(phkResult);\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h);\n    puVar2 = iVar1 + arg_8h;\n    while (puVar2 != NULL) {\n        *puVar2 = 0;\n        fcn.0040e12c(arg_8h, puVar2);\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, arg_8h, &phkResult);\n        if (iVar1 != 0) break;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(phkResult, 0, &lpName, 0x105);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n        if (iVar1 == 0) break;\n        (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(0x80000000, arg_8h);\n        puVar2 = fcn.0040ed0f(arg_8h, 0x5c);\n    }\n    fcn.0040d21b(arg_8h);\n    return 1;\n}\n",
        "token_count": 316
    },
    "00465c91": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.00465c91(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar1 = fcn.00462b7c(0x4608de);\n    while ((*(iVar1 + 0xc) == 0 &&\n           (iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(&stack0xffffffe0, 0, 0, 0, 0),  iVar2 != 0))) {\n        piVar3 = fcn.0043ded2();\n        iVar2 = (**(*piVar3 + 0x5c))();\n        if (iVar2 == 0) {\n            return false;\n        }\n    }\n    return *(iVar1 + 0xc) == 0;\n}\n",
        "token_count": 178
    },
    "0046a1ab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0046a1ab(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable._AFX_WIN_STATE.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00447cef(extraout_ECX + 1, extraout_ECX);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 170
    },
    "0046a2bf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.0046a2bf(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    char *arg_8h;\n    \n    iVar2 = fcn.00460591();\n    fcn.0046255d(1);\n    arg_8h = iVar2 + 0x34;\n    while (*arg_8h != '\\0') {\n        puVar3 = fcn.0040da79(arg_8h, 10);\n        *puVar3 = 0;\n        iVar4 = fcn.00460591();\n        (*_sym.imp.USER32.dll_UnregisterClassA)(arg_8h, *(iVar4 + 8));\n        arg_8h = puVar3 + 1;\n    }\n    *(iVar2 + 0x34) = '\\0';\n    fcn.004625cd(1);\n    iVar2 = fcn.00460591();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x54),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.00460301();\n    if (*(iVar2 + 0xcc) != NULL) {\n        iVar4 = (**(**(iVar2 + 0xcc) + 0xb8))();\n        if (iVar4 != 0) {\n            *(iVar2 + 0xcc) = 0;\n        }\n    }\n    iVar4 = fcn.00460591();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar4 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x30) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x30));\n            *(iVar2 + 0x30) = 0;\n        }\n        if (*(iVar2 + 0x2c) != 0) {\n            (*pcVar1)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 496
    },
    "00422615": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00422a7d: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00422a82)\n// WARNING: Variable defined which should be unmapped: var_5ch\n\ncode ** __cdecl fcn.00422615(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    uint uVar2;\n    code **ppcVar3;\n    int32_t iVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    code **ppcVar5;\n    uint *in_FS_OFFSET;\n    ulong uVar6;\n    uint var_5ch;\n    uint var_1ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    fcn.0041aedd();\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004011d6();\n    ppcVar3 = fcn.0041b36d(uVar2, 1);\n    if (ppcVar3 == NULL) {\n        if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n            *(unaff_EBP + 0x10) = \"missing locale facet\";\n            fcn.0040d118(unaff_EBP + 0x10);\n            *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n            fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n            fcn.0040d954();\n            fcn.0041aedd(0);\n            *(unaff_EBP + -4) = 0;\n            uVar2 = fcn.004011d6();\n            ppcVar3 = fcn.0041b36d(uVar2, 1);\n            if (ppcVar3 == NULL) {\n                if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                    *(unaff_EBP + 0x10) = \"missing locale facet\";\n                    fcn.0040d118(unaff_EBP + 0x10);\n                    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                    fcn.0040d954();\n                    fcn.0041aedd(0);\n                    *(unaff_EBP + -4) = 0;\n                    uVar2 = fcn.004011d6();\n                    ppcVar3 = fcn.0041b36d(uVar2, 1);\n                    if (ppcVar3 == NULL) {\n                        if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                            *(unaff_EBP + 0x10) = \"missing locale facet\";\n                            fcn.0040d118(unaff_EBP + 0x10);\n                            *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                            fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                            fcn.0040d954();\n                            fcn.0041aedd(0);\n                            *(unaff_EBP + -4) = 0;\n                            uVar2 = fcn.004011d6();\n                            ppcVar3 = fcn.0041b36d(uVar2, 1);\n                            if (ppcVar3 == NULL) {\n                                if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                                    *(unaff_EBP + 0x10) = \"missing locale facet\";\n                                    fcn.0040d118(unaff_EBP + 0x10);\n                                    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                                    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                                    fcn.0040d954();\n                                    fcn.0041aedd(0);\n                                    *(unaff_EBP + -4) = 0;\n                                    uVar2 = fcn.004011d6();\n                                    ppcVar3 = fcn.0041b36d(uVar2, 1);\n                                    if (ppcVar3 == NULL) {\n                                        if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                                            *(unaff_EBP + 0x10) = \"missing locale facet\";\n                                            fcn.0040d118(unaff_EBP + 0x10);\n                                            *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                                            fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                                            fcn.0040d954();\n                                            fcn.0041aedd(0);\n                                            *(unaff_EBP + -4) = 0;\n                                            uVar2 = fcn.004011d6();\n                                            ppcVar3 = fcn.0041b36d(uVar2, 1);\n                                            if (ppcVar3 == NULL) {\n                                                if ((*(unaff_EBP + 0x10) == '\\0') ||\n                                                   (cVar1 = fcn.0041b3c3(),  ppcVar5 = *0x49d9f0,  cVar1 == '\\0')) {\n                                                    *(unaff_EBP + 0x10) = \"missing locale facet\";\n                                                    fcn.0040d118(unaff_EBP + 0x10);\n                                                    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                                                    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                                                    ppcVar5 = ppcVar3;\ncode_r0x00422adb:\n                                                    fcn.0040d954();\n                                                    *(unaff_EBP + -0x10) = extraout_ECX;\n                                                    extraout_ECX[1] = *(unaff_EBP + 8);\n                                                    *(unaff_EBP + -4) = 0;\n                                                    uVar2 = 0x4840ac;\n                                                    *extraout_ECX = vtable.std::codecvt_unsigned_short_int__char__int_.0\n                                                    ;\n                                                    fcn.0041c0d1(0x4840ac);\n                                                    uVar6 = fcn.004267b7(uVar2, ppcVar5);\n                                                    extraout_ECX[2] = uVar6;\n                                                    extraout_ECX[3] = uVar6 >> 0x20;\n                                                    fcn.0041c201();\n                                                    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                                                    return extraout_ECX;\n                                                }\n                                                ppcVar3 = *0x49d9f0;\n                                                if (*0x49d9f0 == NULL) {\n                                                    iVar4 = fcn.00438337(0x10);\n                                                    *(unaff_EBP + 0x10) = iVar4;\n                                                    *(unaff_EBP + -4) = 1;\n                                                    if (iVar4 != 0) goto code_r0x00422adb;\n                                                    *(unaff_EBP + -4) = 0;\n                                                    ppcVar3 = fcn.00423365(0);\n                                                    *0x49d9f0 = ppcVar3;\n                                                }\n                                            }\n                                            *(unaff_EBP + -4) = 0xffffffff;\n                                            fcn.0041af79();\n                                            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                                            return ppcVar3;\n                                        }\n                                        ppcVar3 = *0x49d9ec;\n                                        if (*0x49d9ec == NULL) {\n                                            iVar4 = fcn.00438337(0xc);\n                                            *(unaff_EBP + 0x10) = iVar4;\n                                            *(unaff_EBP + -4) = 1;\n                                            if (iVar4 == 0) {\n                                                uVar2 = 0;\n                                            }\n                                            else {\n                                                uVar2 = fcn.00422d99(0);\n                                            }\n                                            *(unaff_EBP + -4) = 0;\n                                            ppcVar3 = fcn.00423317(uVar2);\n                                            *0x49d9ec = ppcVar3;\n                                        }\n                                    }\n                                    *(unaff_EBP + -4) = 0xffffffff;\n                                    fcn.0041af79();\n                                    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                                    return ppcVar3;\n                                }\n                                ppcVar3 = *0x49d9e8;\n                                if (*0x49d9e8 == NULL) {\n                                    iVar4 = fcn.00438337(0x10);\n                                    *(unaff_EBP + 0x10) = iVar4;\n                                    *(unaff_EBP + -4) = 1;\n                                    if (iVar4 == 0) {\n                                        uVar2 = 0;\n                                    }\n                                    else {\n                                        uVar2 = fcn.00422f64(0);\n                                    }\n                                    *(unaff_EBP + -4) = 0;\n                                    ppcVar3 = fcn.004232c9(uVar2);\n                                    *0x49d9e8 = ppcVar3;\n                                }\n                            }\n                            *(unaff_EBP + -4) = 0xffffffff;\n                            fcn.0041af79();\n                            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                            return ppcVar3;\n                        }\n                        ppcVar3 = *0x49d9e4;\n                        if (*0x49d9e4 == NULL) {\n                            ppcVar3 = fcn.00438337(0x2c);\n                            *(unaff_EBP + 0x10) = ppcVar3;\n                            *(unaff_EBP + -4) = 1;\n                            if (ppcVar3 == NULL) {\n                                ppcVar3 = NULL;\n                            }\n                            else {\n                                fcn.004233b3(0, 1);\n                                *ppcVar3 = vtable.std::moneypunct_unsigned_short_int__1_.0;\n                            }\n                            *(unaff_EBP + -4) = 0;\n                            ppcVar3 = fcn.0042327b(ppcVar3);\n                            *0x49d9e4 = ppcVar3;\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.0041af79();\n                    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                    return ppcVar3;\n                }\n                ppcVar3 = *0x49d9e0;\n                if (*0x49d9e0 == NULL) {\n                    ppcVar3 = fcn.00438337(0x2c);\n                    *(unaff_EBP + 0x10) = ppcVar3;\n                    *(unaff_EBP + -4) = 1;\n                    if (ppcVar3 == NULL) {\n                        ppcVar3 = NULL;\n                    }\n                    else {\n                        fcn.004233b3(0, 0);\n                        *ppcVar3 = vtable.std::moneypunct_unsigned_short_int__0_.0;\n                    }\n                    *(unaff_EBP + -4) = 0;\n                    ppcVar3 = fcn.0042322d(ppcVar3);\n                    *0x49d9e0 = ppcVar3;\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041af79();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return ppcVar3;\n        }\n        ppcVar3 = *0x49d9dc;\n        if (*0x49d9dc == NULL) {\n            ppcVar3 = fcn.00438337(8);\n            *(unaff_EBP + 0x10) = ppcVar3;\n            if (ppcVar3 == NULL) {\n                ppcVar3 = NULL;\n            }\n            else {\n                ppcVar3[1] = NULL;\n                *(unaff_EBP + -4) = 2;\n                *ppcVar3 = \n                vtable.std::money_put_unsigned_short_int__class_std::ostreambuf_iterator_unsigned_short_int__struct_std::char_traits_unsigned_short_int___.0\n                ;\n                fcn.0041c0d1(0x4840ac);\n                fcn.0041c201();\n            }\n            *(unaff_EBP + -4) = 0;\n            ppcVar3 = fcn.004231df(ppcVar3);\n            *0x49d9dc = ppcVar3;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return ppcVar3;\n}\n",
        "token_count": 3039
    },
    "004226f1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00422a7d: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00422a82)\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\ncode ** __cdecl fcn.004226f1(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    uint uVar2;\n    code **ppcVar3;\n    int32_t iVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    code **ppcVar5;\n    uint *in_FS_OFFSET;\n    ulong uVar6;\n    uint var_1ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    fcn.0041aedd();\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004011d6();\n    ppcVar3 = fcn.0041b36d(uVar2, 1);\n    if (ppcVar3 == NULL) {\n        if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n            *(unaff_EBP + 0x10) = \"missing locale facet\";\n            fcn.0040d118(unaff_EBP + 0x10);\n            *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n            fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n            fcn.0040d954();\n            fcn.0041aedd(0);\n            *(unaff_EBP + -4) = 0;\n            uVar2 = fcn.004011d6();\n            ppcVar3 = fcn.0041b36d(uVar2, 1);\n            if (ppcVar3 == NULL) {\n                if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                    *(unaff_EBP + 0x10) = \"missing locale facet\";\n                    fcn.0040d118(unaff_EBP + 0x10);\n                    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                    fcn.0040d954();\n                    fcn.0041aedd(0);\n                    *(unaff_EBP + -4) = 0;\n                    uVar2 = fcn.004011d6();\n                    ppcVar3 = fcn.0041b36d(uVar2, 1);\n                    if (ppcVar3 == NULL) {\n                        if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                            *(unaff_EBP + 0x10) = \"missing locale facet\";\n                            fcn.0040d118(unaff_EBP + 0x10);\n                            *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                            fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                            fcn.0040d954();\n                            fcn.0041aedd(0);\n                            *(unaff_EBP + -4) = 0;\n                            uVar2 = fcn.004011d6();\n                            ppcVar3 = fcn.0041b36d(uVar2, 1);\n                            if (ppcVar3 == NULL) {\n                                if ((*(unaff_EBP + 0x10) == '\\0') || (cVar1 = fcn.0041b3c3(),  cVar1 == '\\0')) {\n                                    *(unaff_EBP + 0x10) = \"missing locale facet\";\n                                    fcn.0040d118(unaff_EBP + 0x10);\n                                    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                                    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                                    fcn.0040d954();\n                                    fcn.0041aedd(0);\n                                    *(unaff_EBP + -4) = 0;\n                                    uVar2 = fcn.004011d6();\n                                    ppcVar3 = fcn.0041b36d(uVar2, 1);\n                                    if (ppcVar3 == NULL) {\n                                        if ((*(unaff_EBP + 0x10) == '\\0') ||\n                                           (cVar1 = fcn.0041b3c3(),  ppcVar5 = *0x49d9f0,  cVar1 == '\\0')) {\n                                            *(unaff_EBP + 0x10) = \"missing locale facet\";\n                                            fcn.0040d118(unaff_EBP + 0x10);\n                                            *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n                                            fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n                                            ppcVar5 = ppcVar3;\ncode_r0x00422adb:\n                                            fcn.0040d954();\n                                            *(unaff_EBP + -0x10) = extraout_ECX;\n                                            extraout_ECX[1] = *(unaff_EBP + 8);\n                                            *(unaff_EBP + -4) = 0;\n                                            uVar2 = 0x4840ac;\n                                            *extraout_ECX = vtable.std::codecvt_unsigned_short_int__char__int_.0;\n                                            fcn.0041c0d1(0x4840ac);\n                                            uVar6 = fcn.004267b7(uVar2, ppcVar5);\n                                            extraout_ECX[2] = uVar6;\n                                            extraout_ECX[3] = uVar6 >> 0x20;\n                                            fcn.0041c201();\n                                            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                                            return extraout_ECX;\n                                        }\n                                        ppcVar3 = *0x49d9f0;\n                                        if (*0x49d9f0 == NULL) {\n                                            iVar4 = fcn.00438337(0x10);\n                                            *(unaff_EBP + 0x10) = iVar4;\n                                            *(unaff_EBP + -4) = 1;\n                                            if (iVar4 != 0) goto code_r0x00422adb;\n                                            *(unaff_EBP + -4) = 0;\n                                            ppcVar3 = fcn.00423365(0);\n                                            *0x49d9f0 = ppcVar3;\n                                        }\n                                    }\n                                    *(unaff_EBP + -4) = 0xffffffff;\n                                    fcn.0041af79();\n                                    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                                    return ppcVar3;\n                                }\n                                ppcVar3 = *0x49d9ec;\n                                if (*0x49d9ec == NULL) {\n                                    iVar4 = fcn.00438337(0xc);\n                                    *(unaff_EBP + 0x10) = iVar4;\n                                    *(unaff_EBP + -4) = 1;\n                                    if (iVar4 == 0) {\n                                        uVar2 = 0;\n                                    }\n                                    else {\n                                        uVar2 = fcn.00422d99(0);\n                                    }\n                                    *(unaff_EBP + -4) = 0;\n                                    ppcVar3 = fcn.00423317(uVar2);\n                                    *0x49d9ec = ppcVar3;\n                                }\n                            }\n                            *(unaff_EBP + -4) = 0xffffffff;\n                            fcn.0041af79();\n                            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                            return ppcVar3;\n                        }\n                        ppcVar3 = *0x49d9e8;\n                        if (*0x49d9e8 == NULL) {\n                            iVar4 = fcn.00438337(0x10);\n                            *(unaff_EBP + 0x10) = iVar4;\n                            *(unaff_EBP + -4) = 1;\n                            if (iVar4 == 0) {\n                                uVar2 = 0;\n                            }\n                            else {\n                                uVar2 = fcn.00422f64(0);\n                            }\n                            *(unaff_EBP + -4) = 0;\n                            ppcVar3 = fcn.004232c9(uVar2);\n                            *0x49d9e8 = ppcVar3;\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.0041af79();\n                    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n                    return ppcVar3;\n                }\n                ppcVar3 = *0x49d9e4;\n                if (*0x49d9e4 == NULL) {\n                    ppcVar3 = fcn.00438337(0x2c);\n                    *(unaff_EBP + 0x10) = ppcVar3;\n                    *(unaff_EBP + -4) = 1;\n                    if (ppcVar3 == NULL) {\n                        ppcVar3 = NULL;\n                    }\n                    else {\n                        fcn.004233b3(0, 1);\n                        *ppcVar3 = vtable.std::moneypunct_unsigned_short_int__1_.0;\n                    }\n                    *(unaff_EBP + -4) = 0;\n                    ppcVar3 = fcn.0042327b(ppcVar3);\n                    *0x49d9e4 = ppcVar3;\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0041af79();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return ppcVar3;\n        }\n        ppcVar3 = *0x49d9e0;\n        if (*0x49d9e0 == NULL) {\n            ppcVar3 = fcn.00438337(0x2c);\n            *(unaff_EBP + 0x10) = ppcVar3;\n            *(unaff_EBP + -4) = 1;\n            if (ppcVar3 == NULL) {\n                ppcVar3 = NULL;\n            }\n            else {\n                fcn.004233b3(0, 0);\n                *ppcVar3 = vtable.std::moneypunct_unsigned_short_int__0_.0;\n            }\n            *(unaff_EBP + -4) = 0;\n            ppcVar3 = fcn.0042322d(ppcVar3);\n            *0x49d9e0 = ppcVar3;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return ppcVar3;\n}\n",
        "token_count": 2560
    },
    "00425cdb": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\ncode ** __cdecl fcn.00425cdb(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    uint uVar2;\n    code **ppcVar3;\n    int32_t iVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    ulong uVar5;\n    uint var_1ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    fcn.0041aedd();\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004011d6();\n    ppcVar3 = fcn.0041b36d(uVar2, 1);\n    if (ppcVar3 != NULL) {\ncode_r0x00425d66:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041af79();\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return ppcVar3;\n    }\n    if (*(unaff_EBP + 0x10) != '\\0') {\n        cVar1 = fcn.0041b3c3();\n        if (cVar1 != '\\0') {\n            ppcVar3 = *0x49da58;\n            if (*0x49da58 == NULL) {\n                ppcVar3 = fcn.00438337(0x2c);\n                *(unaff_EBP + 0x10) = ppcVar3;\n                *(unaff_EBP + -4) = 1;\n                if (ppcVar3 == NULL) {\n                    ppcVar3 = NULL;\n                }\n                else {\n                    fcn.004263fd(0, 0);\n                    *ppcVar3 = vtable.std::moneypunct_char__0_.0;\n                }\n                *(unaff_EBP + -4) = 0;\n                ppcVar3 = fcn.004262c5(ppcVar3);\n                *0x49da58 = ppcVar3;\n            }\n            goto code_r0x00425d66;\n        }\n    }\n    *(unaff_EBP + 0x10) = \"missing locale facet\";\n    fcn.0040d118(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n    fcn.0040d954();\n    fcn.0041aedd(0);\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004011d6();\n    ppcVar3 = fcn.0041b36d(uVar2, 1);\n    if (ppcVar3 != NULL) {\ncode_r0x00425e36:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041af79();\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return ppcVar3;\n    }\n    if (*(unaff_EBP + 0x10) != '\\0') {\n        cVar1 = fcn.0041b3c3();\n        if (cVar1 != '\\0') {\n            ppcVar3 = *0x49da5c;\n            if (*0x49da5c == NULL) {\n                ppcVar3 = fcn.00438337(0x2c);\n                *(unaff_EBP + 0x10) = ppcVar3;\n                *(unaff_EBP + -4) = 1;\n                if (ppcVar3 == NULL) {\n                    ppcVar3 = NULL;\n                }\n                else {\n                    fcn.004263fd(0, 1);\n                    *ppcVar3 = vtable.std::moneypunct_char__1_.0;\n                }\n                *(unaff_EBP + -4) = 0;\n                ppcVar3 = fcn.00426313(ppcVar3);\n                *0x49da5c = ppcVar3;\n            }\n            goto code_r0x00425e36;\n        }\n    }\n    *(unaff_EBP + 0x10) = \"missing locale facet\";\n    fcn.0040d118(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n    fcn.0040d954();\n    fcn.0041aedd(0);\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004011d6();\n    ppcVar3 = fcn.0041b36d(uVar2, 1);\n    if (ppcVar3 != NULL) {\ncode_r0x00425efa:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041af79();\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return ppcVar3;\n    }\n    if (*(unaff_EBP + 0x10) != '\\0') {\n        cVar1 = fcn.0041b3c3();\n        if (cVar1 != '\\0') {\n            ppcVar3 = *0x49da60;\n            if (*0x49da60 == NULL) {\n                iVar4 = fcn.00438337(0x10);\n                *(unaff_EBP + 0x10) = iVar4;\n                *(unaff_EBP + -4) = 1;\n                if (iVar4 == 0) {\n                    uVar2 = 0;\n                }\n                else {\n                    uVar2 = fcn.004260c7(0);\n                }\n                *(unaff_EBP + -4) = 0;\n                ppcVar3 = fcn.00426361(uVar2);\n                *0x49da60 = ppcVar3;\n            }\n            goto code_r0x00425efa;\n        }\n    }\n    *(unaff_EBP + 0x10) = \"missing locale facet\";\n    fcn.0040d118(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n    fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n    fcn.0040d954();\n    fcn.0041aedd(0);\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004011d6();\n    ppcVar3 = fcn.0041b36d(uVar2, 1);\n    if (ppcVar3 == NULL) {\n        if (*(unaff_EBP + 0x10) != '\\0') {\n            cVar1 = fcn.0041b3c3();\n            if (cVar1 != '\\0') {\n                ppcVar3 = *0x49da64;\n                if (*0x49da64 == NULL) {\n                    iVar4 = fcn.00438337(0xc);\n                    *(unaff_EBP + 0x10) = iVar4;\n                    *(unaff_EBP + -4) = 1;\n                    if (iVar4 == 0) {\n                        uVar2 = 0;\n                    }\n                    else {\n                        uVar2 = fcn.00426120(0);\n                    }\n                    *(unaff_EBP + -4) = 0;\n                    ppcVar3 = fcn.004263af(uVar2);\n                    *0x49da64 = ppcVar3;\n                }\n                goto code_r0x00425fbe;\n            }\n        }\n        *(unaff_EBP + 0x10) = \"missing locale facet\";\n        fcn.0040d118(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x1c) = vtable.std::bad_cast.0;\n        fcn.0040d1e1(unaff_EBP + -0x1c, 0x47b670);\n        fcn.0040d954();\n        *(unaff_EBP + -0x10) = extraout_ECX;\n        extraout_ECX[1] = *(unaff_EBP + 8);\n        *(unaff_EBP + -4) = 0;\n        uVar2 = 0x4840ac;\n        *extraout_ECX = vtable.std::collate_char_.0;\n        fcn.0041c0d1(0x4840ac);\n        uVar5 = fcn.00426ab9(uVar2, ppcVar3);\n        extraout_ECX[2] = uVar5;\n        extraout_ECX[3] = uVar5 >> 0x20;\n        fcn.0041c201();\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return extraout_ECX;\n    }\ncode_r0x00425fbe:\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041af79();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return ppcVar3;\n}\n",
        "token_count": 2136
    },
    "0043a2b3": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint fcn.0043a2b3(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar2 = 0;\n    iVar1 = *(extraout_ECX + 0xc);\n    *(unaff_EBP + -0x10) = &var_14h;\n    if (iVar1 != 0) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -4) = 0;\n        uVar2 = (**(extraout_ECX + 0xc))();\n        *(unaff_EBP + -0x14) = uVar2;\n        uVar2 = *(unaff_EBP + -0x14);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 274
    },
    "0043c109": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043c109(uint noname_0, uint *hWnd, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = *hWnd;\n    var_4h = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar3);\n    var_4h = var_4h & 0xffff;\n    uVar1 = hWnd[2];\n    iVar2 = fcn.00462aba(0x460619);\n    if ((*(iVar2 + 0xb8) != in_ECX[7]) && (iVar2 = fcn.0043ca54(uVar3, arg_10h),  iVar2 == 0)) {\n        var_ch = arg_10h;\n        var_8h = hWnd;\n        uVar3 = (**(*in_ECX + 0xc))(var_4h, uVar1 & 0xffff | 0x4e0000, &var_ch, 0);\n        return uVar3;\n    }\n    return 1;\n}\n",
        "token_count": 275
    },
    "0043c637": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043c637(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    int32_t var_14h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.0043c52a(arg_8h, &var_8h, &var_4h);\n    iVar1 = fcn.0043c5ea(arg_8h, &var_24h, 2);\n    if (iVar1 != 0) {\n        var_4h = var_4h - (-(var_14h != 1) & var_14h - 1U);\n    }\n    return var_4h;\n}\n",
        "token_count": 163
    },
    "00444898": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpPathName\n\nuint __cdecl fcn.00444898(uint arg_8h, uint lpFilePart, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpPathName;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar1 = *0x498098;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x10) = uVar1;\n    *(unaff_EBP + -4) = 1;\n    (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, unaff_EBP + -0x118, unaff_EBP + 0xc);\n    **(unaff_EBP + 0xc) = 0;\n    uVar1 = fcn.00438f78(0x105);\n    (*_sym.imp.KERNEL32.dll_GetTempFileNameA)(unaff_EBP + -0x118, 0x471bc0, 0, uVar1);\n    fcn.00438fc7(0xffffffff);\n    if (*(unaff_EBP + 0x10) == 0) {\n        fcn.0043ec3e(*(unaff_EBP + -0x10));\n    }\n    fcn.004388bd(unaff_EBP + -0x10);\n    *(unaff_EBP + -0x14) = 1;\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    uVar1 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 429
    },
    "00445488": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __cdecl fcn.00445488(uint arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint lpString1;\n    uint var_4h;\n    \n    fcn.00401091(&var_4h);\n    *arg_ch = var_4h;\n    fcn.00401091(&var_4h + 2);\n    if (var_4h._2_2_ < 0x40) {\n        uVar1 = fcn.004456bd(&lpString1, var_4h._2_2_);\n        if (uVar1 == var_4h._2_2_) {\n            *(&lpString1 + var_4h._2_2_) = 0;\n            iVar2 = fcn.00460591();\n            fcn.0046255d(0);\n            for (puVar3 = *(iVar2 + 0x1c); puVar3 != NULL; puVar3 = puVar3[5]) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, *puVar3);\n                if (iVar2 == 0) goto code_r0x00445501;\n            }\n            puVar3 = NULL;\ncode_r0x00445501:\n            fcn.004625cd(0);\n            return puVar3;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 333
    },
    "00447c97": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447c97(uint hWnd, uint lpString2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpString1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString2);\n    if (((uVar1 < 0x101) && (uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString1, 0x100),  uVar2 == uVar1))\n       && (iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, lpString2),  iVar3 == 0)) {\n        return;\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(hWnd, lpString2);\n    return;\n}\n",
        "token_count": 185
    },
    "0044853c": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044853c(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *(in_ECX + 0x40) = 0xffffffff;\n    *(in_ECX + 0x44) = arg_8h;\n    *(in_ECX + 0x48) = arg_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        uVar1 = fcn.00439ecc();\n        if ((uVar1 & 0x300000) != 0) {\n            fcn.0043c49f(0, 0, 1);\n            fcn.0043c49f(1, 0, 1);\n            fcn.0043c55a(3, 0);\n        }\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *(in_ECX + 0x4c) = var_8h - lpRect;\n    *(in_ECX + 0x50) = var_4h - var_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        fcn.00448d25();\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 351
    },
    "00448d25": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00448d25(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint lpRect;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t lParam;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    if (*(param_1 + 0x68) != 0) {\n        return;\n    }\n    *(param_1 + 0x68) = 1;\n    var_4h = 1;\n    uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    iVar2 = fcn.0043aad3(uVar1);\n    if ((iVar2 == 0) || (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x368, 0, &lParam),  iVar2 == 0))\n    {\n        iVar2 = fcn.00448beb(&var_ch, &var_1ch);\n        if (iVar2 == 0) {\n            (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x1c), &lpRect);\n            if ((0 < var_44h) && (0 < var_40h)) {\n                fcn.0043c55a(3, 0);\n            }\n            goto code_r0x00448e92;\n        }\n    }\n    else {\n        var_4h = 0;\n        fcn.00448b91();\n        var_ch = var_34h - lParam;\n        var_8h = var_30h - var_38h;\n    }\n    fcn.00448c60(var_ch, var_8h, &var_14h, &var_2ch, &var_24h, var_4h);\n    if (var_14h != 0) {\n        var_8h = var_8h - var_18h;\n    }\n    if (var_10h != 0) {\n        var_ch = var_ch - var_1ch;\n    }\n    fcn.004488dd(var_24h, var_20h);\n    var_64h = 3;\n    var_60h = 0;\n    fcn.0043c55a(0, var_14h);\n    if (var_14h != 0) {\n        var_58h = var_ch;\n        var_5ch = *(param_1 + 0x4c) + -1;\n        iVar2 = fcn.0043c59d(0, &var_68h, 1);\n        if (iVar2 == 0) {\n            fcn.0043c4f7(0, 0, var_2ch, 1);\n        }\n    }\n    fcn.0043c55a(1, var_10h);\n    if (var_10h != 0) {\n        var_58h = var_8h;\n        var_5ch = *(param_1 + 0x50) + -1;\n        iVar2 = fcn.0043c59d(1, &var_68h, 1);\n        if (iVar2 == 0) {\n            fcn.0043c4f7(1, 0, var_28h, 1);\n        }\n    }\ncode_r0x00448e92:\n    *(param_1 + 0x68) = 0;\n    return;\n}\n",
        "token_count": 917
    },
    "0044d3ff": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint __cdecl\nfcn.0044d3ff(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint arg_18h, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t arg_14h_00;\n    uint *in_FS_OFFSET;\n    bool bVar5;\n    uint var_10h;\n    uint var_ch_2;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    arg_14h_00 = *(unaff_EBP + 0x14) & 0xffcfffff;\n    bVar5 = *0x49d0e4 != 0;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (bVar5) {\n        arg_14h_00 = *(unaff_EBP + 0x14) & 0xff4fffff;\n    }\n    fcn.0043d76a(4);\n    iVar1 = fcn.0043b05b(0, \"AfxMDIFrame42s\", 0, arg_14h_00, 0, 0, 0, 0, *(*(unaff_EBP + 8) + 0x1c), *(unaff_EBP + 0x18)\n                         , 0);\n    if (iVar1 == 0) {\n        uVar4 = 0;\n    }\n    else {\n        iVar1 = *(extraout_ECX + 0x44);\n        *(unaff_EBP + -4) = 0;\n        uVar2 = fcn.00438337(iVar1 * 0xc);\n        uVar4 = *(unaff_EBP + 0xc);\n        *(extraout_ECX + 0x78) = uVar2;\n        for (iVar1 = 0; iVar1 < *(extraout_ECX + 0x44); iVar1 = iVar1 + 1) {\n            iVar3 = iVar1 * 0xc;\n            *(*(extraout_ECX + 0x78) + 4 + iVar3) = uVar4;\n            *(*(extraout_ECX + 0x78) + iVar3) = uVar4;\n            *(*(extraout_ECX + 0x78) + 8 + iVar3) = 0xffffffff;\n        }\n        uVar2 = fcn.00438337(*(extraout_ECX + 0x40) * 0xc);\n        uVar4 = *(unaff_EBP + 0x10);\n        *(extraout_ECX + 0x7c) = uVar2;\n        for (iVar1 = 0; iVar1 < *(extraout_ECX + 0x40); iVar1 = iVar1 + 1) {\n            iVar3 = iVar1 * 0xc;\n            *(*(extraout_ECX + 0x7c) + 4 + iVar3) = uVar4;\n            *(*(extraout_ECX + 0x7c) + iVar3) = uVar4;\n            *(*(extraout_ECX + 0x7c) + 8 + iVar3) = 0xffffffff;\n        }\n        fcn.0044d809(*(unaff_EBP + 0x14));\n        uVar4 = 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 898
    },
    "0044da9d": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t fcn.0044da9d(int32_t *param_1, int32_t param_2, int32_t param_3)\n\n{\n    if ((param_2 < *param_1) || (param_3 = (param_1[2] - param_2) - param_3,  param_3 < param_1[3])) {\n        param_3 = -1;\n    }\n    return param_3;\n}\n",
        "token_count": 99
    },
    "00452a87": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00452a87(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar6 = *(in_ECX + 0x90);\n    puVar1 = in_ECX + 0x94;\n    uVar2 = *puVar1;\n    uVar3 = *(in_ECX + 0x98);\n    uVar4 = *(in_ECX + 0x9c);\n    uVar5 = *(in_ECX + 0xa0);\n    *(in_ECX + 0x90) = *arg_ch == 0;\n    (*_sym.imp.USER32.dll_CopyRect)(puVar1, arg_ch + 1);\n    fcn.00451a2f(arg_8h, arg_ch);\n    *puVar1 = uVar2;\n    *(in_ECX + 0x98) = uVar3;\n    *(in_ECX + 0x9c) = uVar4;\n    *(in_ECX + 0xa0) = uVar5;\n    *(in_ECX + 0x90) = uVar6;\n    return;\n}\n",
        "token_count": 313
    },
    "00459386": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00459386(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint extraout_ECX;\n    uint32_t arg_14h;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    iVar1 = fcn.00462b7c(0x4607e5);\n    arg_8h_00 = *(unaff_EBP + 8);\n    iVar3 = *(iVar1 + 4);\n    if (iVar3 != 0) {\n        if (*(iVar1 + 8) == arg_8h_00) {\n            uVar2 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar3 + 0x1c));\n            fcn.0043aad3(uVar2);\n            fcn.0043a0a7(5);\n            goto code_r0x004594ad;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(*(iVar3 + 0x1c), 0x10, 0, 0);\n    }\n    *(unaff_EBP + -0x10) = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    fcn.004592d3(unaff_EBP + -0x10);\n    if (*(*(unaff_EBP + -0x10) + -8) == 0) {\n        fcn.00438c81(iVar1 + 0xc);\n    }\n    fcn.004388bd(iVar1 + 0x10);\n    *(unaff_EBP + -4) = 1;\n    iVar3 = fcn.00438337(0x184);\n    *(unaff_EBP + 8) = iVar3;\n    *(unaff_EBP + -4) = 2;\n    if (iVar3 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.0042eb7e();\n    }\n    iVar3 = *(iVar1 + 0x18);\n    *(unaff_EBP + -4) = 1;\n    *(iVar1 + 4) = uVar2;\n    arg_14h = 0x10000;\n    if (iVar3 != 0) {\n        arg_14h = 0x10001;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        arg_14h = arg_14h | 4;\n    }\n    iVar3 = fcn.0042ec2b(arg_8h_00, *(unaff_EBP + -0x10), *(unaff_EBP + -0x14), arg_14h, *(unaff_EBP + -0x18));\n    if (iVar3 == 0) {\n        *(iVar1 + 4) = 0;\n    }\n    else {\n        uVar2 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(*(iVar1 + 4) + 0x1c));\n        fcn.0043aad3(uVar2);\n        fcn.0043a0a7(5);\n        *(iVar1 + 8) = arg_8h_00;\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438b48();\ncode_r0x004594ad:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 921
    },
    "0045a41b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0045a41b(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = fcn.0043a2b3();\n    if (piVar1 != NULL) {\n        var_14h = 0;\n        var_10h = 0;\n        var_ch = 0;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x54))(0, 0, 0x50800000, &var_14h, var_4h, arg_ch, arg_8h);\n        if (iVar2 != 0) {\n            if (*0x49d0e4 == 0) {\n                return piVar1;\n            }\n            uVar3 = fcn.00439ee6();\n            if ((uVar3 & 0x200) == 0) {\n                return piVar1;\n            }\n            fcn.00439f31(0x200, 0, 0x20);\n            return piVar1;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 296
    },
    "0045abef": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045abef(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint32_t uVar5;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    uVar3 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(in_ECX + 0x1c));\n    fcn.0043aad3(uVar3);\n    pcVar2 = _sym.imp.SHELL32.dll_DragQueryFileA;\n    uVar5 = 0;\n    var_4h = (*_sym.imp.SHELL32.dll_DragQueryFileA)(arg_8h, 0xffffffff, 0, 0);\n    iVar4 = fcn.00460591();\n    piVar1 = *(iVar4 + 4);\n    if (var_4h != 0) {\n        do {\n            (*pcVar2)(arg_8h, uVar5, &var_108h, 0x104);\n            (**(*piVar1 + 0x7c))(&var_108h);\n            uVar5 = uVar5 + 1;\n        } while (uVar5 < var_4h);\n    }\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    return;\n}\n",
        "token_count": 312
    },
    "0045ba85": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045ba85(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_ECX[0x2c] == 0) {\n        in_ECX[0x2c] = 1;\n        if ((in_ECX[0x2e] & 4U) != 0) {\n            arg_8h = 1;\n        }\n        in_ECX[0x2e] = in_ECX[0x2e] & 0xfffffff3;\n        if ((arg_8h != 0) && (in_ECX[0x1a] != NULL)) {\n            (**(*in_ECX[0x1a] + 0x50))();\n        }\n        uVar1 = fcn.00439ecc();\n        if ((uVar1 & 0x2000) == 0) {\n            fcn.0043c724(0, 0xffff, 0xe900, 2, in_ECX + 0x16, 0, 1);\n        }\n        else {\n            var_8h = 0x7fff;\n            var_4h = 0x7fff;\n            var_10h = 0;\n            var_ch = 0;\n            fcn.0043c724(0, 0xffff, 0xe900, 1, &var_10h, &var_10h, 0);\n            fcn.0043c724(0, 0xffff, 0xe900, 2, in_ECX + 0x16, &var_10h, 1);\n            (**(*in_ECX + 0x60))(&var_10h, 0);\n            fcn.0043a058(0, 0, 0, var_8h - var_10h, var_4h - var_ch, 0x16);\n        }\n        in_ECX[0x2c] = 0;\n    }\n    return;\n}\n",
        "token_count": 485
    },
    "0045c375": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: nLeftRect\n// WARNING: Variable defined which should be unmapped: nBottomRect\n// WARNING: Variable defined which should be unmapped: nRightRect\n// WARNING: Variable defined which should be unmapped: nTopRect\n\nvoid __cdecl\nfcn.0045c375(uint lprcSrc2, uint dx, uint dy, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, uint arg_24h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint nLeftRect;\n    uint nTopRect;\n    uint nRightRect;\n    uint nBottomRect;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint hrgnDest;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hrgnSrc1;\n    uint var_14h;\n    uint hrgnSrc2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    fcn.0040c82b();\n    *(unaff_EBP + -0x2c) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0040c82b();\n    *(unaff_EBP + -0x1c) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.0040c82b();\n    *(unaff_EBP + -0x14) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 2;\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(*(unaff_EBP + 8));\n    fcn.004478da(uVar2);\n    (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, *(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0xc), -*(unaff_EBP + 0x10));\n    (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 8));\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(unaff_EBP + -0x44);\n    fcn.004478da(uVar2);\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n    fcn.004478da(uVar2);\n    (*_sym.imp.GDI32.dll_CombineRgn)\n              (*(unaff_EBP + -0x28), -(unaff_EBP != 0x1c) & *(unaff_EBP + -0x18), \n               -(unaff_EBP != 0x14) & *(unaff_EBP + -0x10), 3);\n    if (*(unaff_EBP + 0x20) == 0) {\n        uVar2 = fcn.0045c302();\n        *(unaff_EBP + 0x20) = uVar2;\n    }\n    if (*(unaff_EBP + 0x24) == 0) {\n        *(unaff_EBP + 0x24) = *(unaff_EBP + 0x20);\n    }\n    fcn.0040c82b();\n    *(unaff_EBP + -0x24) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.0040c82b();\n    *(unaff_EBP + -0x34) = vtable.CRgn.0;\n    puVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 4;\n    if (puVar1 != NULL) {\n        uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n        fcn.004478da(uVar2);\n        (*_sym.imp.GDI32.dll_SetRectRgn)(*(unaff_EBP + -0x18), *puVar1, puVar1[1], puVar1[2], puVar1[3]);\n        (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, puVar1);\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0x18), -*(unaff_EBP + 0x1c));\n        (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, puVar1);\n        (*_sym.imp.GDI32.dll_SetRectRgn)\n                  (*(unaff_EBP + -0x10), *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c), \n                   *(unaff_EBP + -0x38));\n        (*_sym.imp.GDI32.dll_CombineRgn)\n                  (*(unaff_EBP + -0x20), -(unaff_EBP != 0x1c) & *(unaff_EBP + -0x18), \n                   -(unaff_EBP != 0x14) & *(unaff_EBP + -0x10), 3);\n        if (*(*(unaff_EBP + 0x20) + 4) == *(*(unaff_EBP + 0x24) + 4)) {\n            uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n            fcn.004478da(uVar2);\n            (*_sym.imp.GDI32.dll_CombineRgn)\n                      (*(unaff_EBP + -0x30), -(unaff_EBP != 0x24) & *(unaff_EBP + -0x20), \n                       -(unaff_EBP != 0x2c) & *(unaff_EBP + -0x28), 3);\n        }\n    }\n    if ((*(*(unaff_EBP + 0x20) + 4) != *(*(unaff_EBP + 0x24) + 4)) && (puVar1 != NULL)) {\n        fcn.00446cc4(unaff_EBP + -0x24);\n        (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n        uVar2 = fcn.00446805(*(unaff_EBP + 0x24));\n        (*_sym.imp.GDI32.dll_PatBlt)\n                  (extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), \n                   *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n        fcn.00446805(uVar2);\n    }\n    iVar3 = unaff_EBP + -0x34;\n    if (*(unaff_EBP + -0x30) == 0) {\n        iVar3 = unaff_EBP + -0x2c;\n    }\n    fcn.00446cc4(iVar3);\n    (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n    iVar3 = fcn.00446805(*(unaff_EBP + 0x20));\n    (*_sym.imp.GDI32.dll_PatBlt)\n              (extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44)\n               , *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n    if (iVar3 != 0) {\n        fcn.00446805(iVar3);\n    }\n    fcn.00446cc4(0);\n    *(unaff_EBP + -0x34) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 5;\n    fcn.00447931();\n    *(unaff_EBP + -0x24) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 6;\n    fcn.00447931();\n    *(unaff_EBP + -0x14) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 7;\n    fcn.00447931();\n    *(unaff_EBP + -0x1c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 8;\n    fcn.00447931();\n    *(unaff_EBP + -0x2c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 9;\n    fcn.00447931();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 2141
    },
    "0045c7c9": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0045c7c9(uint *arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t var_50h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n    }\n    else {\n        uVar2 = *(arg_ch + 8);\n    }\n    puVar4 = &var_50h;\n    for (iVar3 = 0xf; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = *arg_8h;\n        arg_8h = arg_8h + 1;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar2, 0x5a);\n    pcVar1 = _sym.imp.GDI32.dll_DPtoLP;\n    var_10h = (iVar3 * var_50h) / 0x2d0;\n    (*_sym.imp.GDI32.dll_DPtoLP)(uVar2, &var_14h, 1);\n    var_ch = 0;\n    var_8h = 0;\n    (*pcVar1)(uVar2, &var_ch, 1);\n    var_50h = fcn.0040e95b(var_10h - var_8h);\n    var_50h = -var_50h;\n    if (arg_ch == 0) {\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    uVar2 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&var_50h);\n    fcn.004478da(uVar2);\n    return;\n}\n",
        "token_count": 453
    },
    "00461355": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00461355(int32_t hgdiobj)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint lpvObject;\n    int32_t var_30h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0x18, &lpvObject);\n    if (in_ECX[0x20] == 0) {\n        var_8h = 0;\n        var_4h = hgdiobj;\n        iVar1 = (**(*in_ECX + 0xa0))(0x413, var_30h / in_ECX[0x22], &var_8h);\n        uVar2 = iVar1 == 0;\n    }\n    else {\n        var_ch = var_30h / in_ECX[0x22];\n        var_1ch = 0;\n        var_14h = 0;\n        var_10h = hgdiobj;\n        var_18h = in_ECX[0x20];\n        uVar2 = (**(*in_ECX + 0xa0))(0x42e, 0, &var_1ch);\n    }\n    if (uVar2 != 0) {\n        fcn.00447cef(in_ECX + 0x20);\n        in_ECX[0x20] = hgdiobj;\n    }\n    return uVar2;\n}\n",
        "token_count": 372
    },
    "00462c67": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool fcn.00462c67(void)\n\n{\n    uint uVar1;\n    uint32_t var_14h;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)(&var_14h);\n    (*_sym.imp.KERNEL32.dll_GetCPInfo)(uVar1);\n    return 1 < var_14h;\n}\n",
        "token_count": 80
    },
    "004012a8": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\nuint fcn.004012a8(void)\n\n{\n    int32_t in_FS_OFFSET;\n    uint var_4h;\n    \n    return *(in_FS_OFFSET + 0x30);\n}\n",
        "token_count": 41
    },
    "0041c201": {
        "rules": [
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access",
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041c201(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    iVar1 = *(extraout_ECX + 0x28);\n    *(unaff_EBP + -4) = 2;\n    if (iVar1 != 0) {\n        iVar1 = *(extraout_ECX + 0x24);\n        if (iVar1 == 0) {\n            iVar1 = 0x4711bc;\n        }\n        fcn.004148f2(0, iVar1);\n    }\n    fcn.004013e8(1);\n    *(unaff_EBP + -4) = 1;\n    fcn.004013e8(1);\n    *(unaff_EBP + -4) = 0;\n    fcn.004013e8(1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004013e8(1);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 337
    },
    "0042eae0": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042eae0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.0043a3fb(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 100
    },
    "0043483e": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043483e(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CStringList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 105
    },
    "0043487d": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043487d(int32_t param_1)\n\n{\n    uint *puVar1;\n    \n    for (puVar1 = *(param_1 + 4); puVar1 != NULL; puVar1 = *puVar1) {\n        fcn.00438b48();\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.004350c7();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 152
    },
    "00434dce": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00434dce(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CPtrList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 105
    },
    "00434e0d": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434e0d(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.004350c7();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "00436b68": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00436b68(code **param_1, code *param_2)\n\n{\n    param_1[1] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CMapPtrToPtr.0;\n    param_1[2] = 0x11;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 110
    },
    "00436bf0": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00436bf0(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.00438360(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.004350c7();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 121
    },
    "00436e35": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00436e35(code **param_1, code *param_2)\n\n{\n    param_1[1] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CMapStringToPtr.0;\n    param_1[2] = 0x11;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 110
    },
    "00436ebd": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00436ebd(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    if (*(param_1 + 4) != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 8) != 0) {\n            do {\n                for (puVar2 = *(*(param_1 + 4) + uVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    fcn.00438b48();\n                }\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < *(param_1 + 8));\n        }\n        fcn.00438360(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.004350c7();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 244
    },
    "0043836b": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043836b(int32_t param_1)\n\n{\n    *(param_1 + 4) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 0x18) = 0;\n    return;\n}\n",
        "token_count": 108
    },
    "00438691": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00438691(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 125
    },
    "004618ea": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004618ea(code **param_1)\n\n{\n    param_1[5] = *0x498098;\n    param_1[6] = *0x498098;\n    param_1[7] = *0x498098;\n    param_1[8] = *0x498098;\n    *param_1 = vtable.CCommandLineInfo.0;\n    param_1[1] = 0x1;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    return;\n}\n",
        "token_count": 134
    },
    "00466536": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t * fcn.00466536(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    iVar2 = *0x498098;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[7] = iVar2;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.00438337(0xa4);\n    *(unaff_EBP + -0x14) = iVar2;\n    *(unaff_EBP + -4) = 1;\n    if (iVar2 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = fcn.004302b0(0, 0x40004, 0);\n    }\n    *extraout_ECX = iVar2;\n    uVar1 = *(unaff_EBP + -0xc);\n    *(*(iVar2 + 0x5c) + 0x1c) = 1;\n    *(*(*extraout_ECX + 0x5c) + 0x1e) = 0xffff;\n    extraout_ECX[8] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[1] = 0;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[0xd] = 0;\n    extraout_ECX[5] = 1;\n    extraout_ECX[4] = 1;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 471
    },
    "00468a27": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00468a27(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    fcn.004605b7();\n    iVar1 = fcn.00438337(0x1c);\n    *(iVar1 + 4) = param_1;\n    *(iVar1 + 8) = param_2;\n    *(iVar1 + 0xc) = param_3;\n    fcn.00434ef1(iVar1);\n    return;\n}\n",
        "token_count": 114
    },
    "00468bec": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00468bec(code **param_1, code *param_2, code *param_3)\n\n{\n    fcn.0043e73e();\n    *param_1 = vtable.CSocketFile.0;\n    param_1[4] = param_2;\n    param_1[5] = param_3;\n    return param_1;\n}\n",
        "token_count": 86
    },
    "004488dd": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.004488dd(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_EDI;\n    int32_t unaff_retaddr;\n    int32_t iVar3;\n    \n    iVar1 = fcn.0043c4cf(0);\n    iVar3 = 0;\n    fcn.0043c49f(0, unaff_retaddr, 1);\n    iVar2 = fcn.0043c4cf(1);\n    fcn.0043c49f(1, unaff_EDI, 1);\n    fcn.0043c67e(iVar1 - iVar3, iVar2 - unaff_retaddr, 0, 0);\n    return;\n}\n",
        "token_count": 160
    },
    "00454513": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00454513(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    uVar3 = *0x498098;\n    *(unaff_EBP + -0x10) = *0x498098;\n    *(unaff_EBP + -0x14) = uVar3;\n    *(unaff_EBP + -4) = 0;\n    piVar1 = *(unaff_EBP + 0x10);\n    iVar4 = *piVar1;\n    *(unaff_EBP + -4) = 1;\n    iVar4 = (**(iVar4 + 100))(unaff_EBP + -0x10, 4);\n    if ((iVar4 != 0) && (*(*(unaff_EBP + -0x10) + -8) != 0)) {\n        iVar4 = (**(*piVar1 + 100))(unaff_EBP + -0x14, 3);\n        if ((iVar4 != 0) && (*(*(unaff_EBP + -0x14) + -8) != 0)) {\n            iVar4 = *(unaff_EBP + 0xc);\n            puVar2 = *(unaff_EBP + 0x14);\n            if (puVar2 != NULL) {\n                fcn.00438cd1();\n                *(iVar4 + 0x3c) = *puVar2;\n                *(iVar4 + 0x18) = *(iVar4 + 0x14) + 1;\n            }\n            fcn.00438f60(unaff_EBP + -0x14);\n            fcn.00438f4b(0);\n            fcn.00438f4b(0x2a);\n            fcn.00438f60(unaff_EBP + -0x10);\n            fcn.00438f4b(0);\n            *(iVar4 + 0x14) = *(iVar4 + 0x14) + 1;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 651
    },
    "00460337": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00460337(code **param_1, uchar param_2)\n\n{\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    param_1[10] = NULL;\n    param_1[0x40f] = NULL;\n    param_1[0x410] = NULL;\n    param_1[0x413] = 0xffffffff;\n    param_1[0x414] = NULL;\n    param_1[0x419] = NULL;\n    param_1[0x41a] = NULL;\n    *param_1 = vtable.AFX_MODULE_STATE.0;\n    param_1[10] = 0x1c;\n    param_1[8] = 0x14;\n    param_1[6] = NULL;\n    *(param_1 + 5) = param_2;\n    param_1[0xc] = 0x1;\n    param_1[0x410] = 0x18;\n    return;\n}\n",
        "token_count": 238
    },
    "00461945": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00461945(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CCommandLineInfo.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 2;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 1;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 225
    },
    "0042fbcc": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042fbcc(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint16_t **in_ECX;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = NULL;\n    }\n    else {\n        fcn.0042fb17(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = arg_8h;\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "0044955c": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044955c(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    \n    if (*(*(param_1 + 0x60) + -8) == 0) {\n        fcn.0043a377(*(param_1 + 0x3c));\n    }\n    pcVar2 = _sym.imp.USER32.dll_LoadMenuA;\n    pcVar1 = _sym.imp.USER32.dll_LoadAcceleratorsA;\n    if ((*(param_1 + 0x44) != 0) && (*(param_1 + 0x2c) == 0)) {\n        iVar3 = fcn.00460591();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x2c) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x30) = uVar5;\n    }\n    if ((*(param_1 + 0x40) != 0) && (*(param_1 + 0x34) == 0)) {\n        iVar3 = fcn.00460591();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x34) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x38) = uVar5;\n    }\n    if ((*(param_1 + 0x48) != 0) && (*(param_1 + 0x24) == 0)) {\n        iVar3 = fcn.00460591();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar2)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x24) = uVar4;\n        uVar5 = (*pcVar1)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x28) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 550
    },
    "0044c990": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044c990(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if ((arg_ch < arg_10h) || (arg_14h < arg_ch)) {\n        fcn.0044c900(arg_8h, arg_10h, arg_14h, 0x472d2c, 0xf112);\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "00432dc0": {
        "rules": [
            "capture webcam image/8f9bddbfc62a47b78ef3c85708336261"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432dc0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_8h;\n    \n    fcn.00432f79(&var_2ch, arg_ch, arg_10h);\n    var_8h = fcn.00438f78(0x100);\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x40b, 0, &var_2ch);\n    fcn.00438fc7(0xffffffff);\n    return;\n}\n",
        "token_count": 145
    },
    "00439c99": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439c99(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x34) == NULL) {\n        (*_sym.imp.USER32.dll_CheckRadioButton)(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n    }\n    else {\n        (**(**(in_ECX + 0x34) + 0x68))(arg_8h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "0043c49f": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c49f(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x68))(arg_8h);\n    if (iVar1 == 0) {\n        iVar1 = in_ECX[7];\n    }\n    else {\n        arg_8h = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_SetScrollPos)(iVar1, arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 148
    },
    "0043c4cf": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043c4cf(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = (**(*param_1 + 0x68))(param_2);\n    if (iVar1 == 0) {\n        iVar1 = param_1[7];\n    }\n    else {\n        unaff_retaddr = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_GetScrollPos)(iVar1, unaff_retaddr);\n    return;\n}\n",
        "token_count": 135
    },
    "0043c4f7": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c4f7(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x68))(arg_8h);\n    if (iVar1 == 0) {\n        iVar1 = in_ECX[7];\n    }\n    else {\n        arg_8h = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_SetScrollRange)(iVar1, arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 160
    },
    "0043c52a": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c52a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x68))(arg_8h);\n    if (iVar1 == 0) {\n        iVar1 = in_ECX[7];\n    }\n    else {\n        arg_8h = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_GetScrollRange)(iVar1, arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 148
    },
    "0043e1c6": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043e1c6(int32_t *param_1)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iStack4;\n    \n    bVar1 = true;\n    iStack4 = 0;\n    do {\n        if (bVar1) {\n            do {\n                iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(param_1 + 0xc, 0, 0, 0, 0);\n                if (iVar2 != 0) break;\n                iVar2 = iStack4 + 1;\n                iVar3 = (**(*param_1 + 0x60))(iStack4);\n                if (iVar3 == 0) {\n                    bVar1 = false;\n                }\n                iStack4 = iVar2;\n            } while (bVar1);\n        }\n        do {\n            iVar2 = (**(*param_1 + 0x5c))();\n            if (iVar2 == 0) {\n                (**(*param_1 + 0x68))();\n                return;\n            }\n            iVar2 = (**(*param_1 + 100))(param_1 + 0xc);\n            if (iVar2 != 0) {\n                bVar1 = true;\n            }\n            iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(param_1 + 0xc, 0, 0, 0, 0);\n        } while (iVar2 != 0);\n    } while( true );\n}\n",
        "token_count": 337
    },
    "00440e14": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint fcn.00440e14(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    uVar4 = 0xffffffff;\n    piVar2 = fcn.0043ded2();\n    iVar3 = fcn.00460591();\n    piVar1 = *(iVar3 + 4);\n    iVar3 = fcn.00463ba1(param_1, param_2, param_3, param_4);\n    if ((iVar3 != 0) && ((piVar1 == NULL || (iVar3 = (**(*piVar1 + 0x84))(),  iVar3 != 0)))) {\n        iVar3 = (**(*piVar2 + 0x50))();\n        if (iVar3 == 0) {\n            if (piVar2[7] != NULL) {\n                (**(*piVar2[7] + 0x58))();\n            }\n            uVar4 = (**(*piVar2 + 0x68))();\n        }\n        else {\n            uVar4 = (**(*piVar2 + 0x54))();\n        }\n    }\n    fcn.0046a2bf();\n    return uVar4;\n}\n",
        "token_count": 292
    },
    "004451b6": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004451b6(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.00434ef1(param_2);\n    *(param_2 + 0x3c) = param_1;\n    (**(*param_1 + 0x68))();\n    return;\n}\n",
        "token_count": 74
    },
    "004451d6": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004451d6(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00435084(param_2, 0);\n    fcn.00435027(uVar1);\n    *(param_2 + 0x3c) = 0;\n    (**(*param_1 + 0x68))();\n    return;\n}\n",
        "token_count": 97
    },
    "00448b91": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00448b91(int32_t *param_1, int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    param_2[1] = 0;\n    *param_2 = 0;\n    uVar1 = fcn.00439ecc();\n    iVar2 = (**(*param_1 + 0x68))(1);\n    if ((iVar2 == 0) && (*param_2 = *0x49d088,  (uVar1 & 0x800000) != 0)) {\n        *param_2 = *param_2 + -1;\n    }\n    iVar2 = (**(*param_1 + 0x68))(0);\n    if ((iVar2 == 0) && (param_2[1] = *0x49d08c,  (uVar1 & 0x800000) != 0)) {\n        param_2[1] = param_2[1] + -1;\n    }\n    return;\n}\n",
        "token_count": 233
    },
    "00453d55": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00453d55(int32_t param_1)\n\n{\n    int32_t iStack8;\n    int32_t iStack4;\n    \n    iStack8 = param_1;\n    iStack4 = param_1;\n    fcn.00453f32();\n    (**(**(param_1 + 0x68) + 0xbc))(&iStack8, *(param_1 + 0x40) - *(param_1 + 0x38), 0x42);\n    fcn.0045bf4e(*(param_1 + 0x68), *(param_1 + 0x48), *(param_1 + 0x4c), *(param_1 + 0x70) & 0x40 | 0x2004);\n    return;\n}\n",
        "token_count": 178
    },
    "0043df68": {
        "rules": [
            "resume thread"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0043df68(uint arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.0043a2b3();\n    if (piVar1 == NULL) {\n        fcn.0042eb4c();\n    }\n    piVar1[0x13] = 0;\n    iVar2 = fcn.0043e0cf(arg_14h | 4, arg_10h, arg_18h);\n    if (iVar2 == 0) {\n        (**(*piVar1 + 0x78))();\n        piVar1 = NULL;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_SetThreadPriority)(piVar1[10], arg_ch);\n        if ((arg_14h & 4) == 0) {\n            (*_sym.imp.KERNEL32.dll_ResumeThread)(piVar1[10]);\n        }\n    }\n    return piVar1;\n}\n",
        "token_count": 245
    },
    "0043edaa": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0043edaa(uint hKey, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    bool bVar5;\n    uint lpType;\n    uint lpcbData;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.ADVAPI32.dll_RegOpenKeyA;\n    bVar5 = false;\n    var_8h = 0;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, \"CLSID\", &var_8h);\n    if (iVar3 == 0) {\n        var_4h = 0;\n        iVar3 = (*pcVar1)(var_8h, hKey, &var_4h);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar3 == 0) {\n            hKey = 0;\n            iVar3 = (*pcVar1)(var_4h, \"InProcServer32\", &hKey);\n            if (iVar3 == 0) {\n                uVar4 = fcn.00438f78(0x104);\n                lpcbData = 0x104;\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0x474650, 0, &lpType, uVar4, &lpcbData);\n                fcn.00438fc7(0xffffffff);\n                bVar5 = iVar3 == 0;\n                (*pcVar2)(hKey);\n            }\n            (*pcVar2)(var_4h);\n        }\n        (*pcVar2)(var_8h);\n    }\n    return bVar5;\n}\n",
        "token_count": 395
    },
    "00463011": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00463011(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExA;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)\n                          (var_4h, *(param_1 + 0x7c), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 0x90), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 381
    },
    "004630a5": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004630a5(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.00463011();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 164
    },
    "00417668": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.00417668(int16_t param_1)\n\n{\n    int16_t *piVar1;\n    \n    piVar1 = 0x499c94;\n    do {\n        if (param_1 == *piVar1) {\n            return 0;\n        }\n        piVar1 = piVar1 + 1;\n    } while (piVar1 < 0x499ca8);\n    return 1;\n}\n",
        "token_count": 94
    },
    "00435084": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00435084(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    if (param_3 != NULL) goto code_r0x00435091;\n    param_3 = *(param_1 + 4);\n    while( true ) {\n        if (param_3 == NULL) {\n            return NULL;\n        }\n        if (param_3[2] == param_2) break;\ncode_r0x00435091:\n        param_3 = *param_3;\n    }\n    return param_3;\n}\n",
        "token_count": 129
    },
    "004350c7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004350c7(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.00438360(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00436caa": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00436caa(int32_t param_1, uint32_t param_2, uint32_t *param_3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    \n    uVar2 = (param_2 >> 4) % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 170
    },
    "00436cdc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00436cdc(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 138
    },
    "00436d81": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00436d81(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    \n    iVar1 = *(param_1 + 4);\n    if (iVar1 != 0) {\n        uVar4 = (param_2 >> 4) % *(param_1 + 8);\n        puVar2 = *(iVar1 + uVar4 * 4);\n        puVar5 = iVar1 + uVar4 * 4;\n        while (puVar3 = puVar2,  puVar3 != NULL) {\n            if (puVar3[1] == param_2) {\n                *puVar5 = *puVar3;\n                fcn.00436c91(puVar3);\n                return 1;\n            }\n            puVar5 = puVar3;\n            puVar2 = *puVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 233
    },
    "00438337": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00438337(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040d777(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x498070 == NULL) break;\n        iVar1 = (**0x498070)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 113
    },
    "0043a35e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043a35e(int32_t param_1, int32_t param_2)\n\n{\n    while( true ) {\n        if (param_1 == 0) {\n            return 0;\n        }\n        if (param_1 == param_2) break;\n        param_1 = *(param_1 + 0x10);\n    }\n    return 1;\n}\n",
        "token_count": 88
    },
    "0043b6e1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0043b6e1(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(param_1 + 4));\n    iVar4 = 0;\n    if (0 < iVar1) {\n        do {\n            uVar2 = (*_sym.imp.USER32.dll_GetSubMenu)(*(param_1 + 4), iVar4);\n            iVar3 = fcn.00440612(uVar2);\n            if (iVar3 == 0) {\n                iVar3 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(param_1 + 4), iVar4);\n                if (iVar3 == param_1) {\n                    iVar1 = fcn.00440627(*(param_1 + 4));\n                    return iVar1;\n                }\n            }\n            else {\n                iVar3 = fcn.0043b6e1(iVar3, param_3);\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 286
    },
    "0043c183": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0043c183(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if ((param_1 != 0) && (iVar4 = *(param_1 + 0x1c),  iVar4 != 0)) {\n        while( true ) {\n            uVar2 = (*pcVar1)(iVar4);\n            piVar3 = fcn.0043aad3(uVar2);\n            if (piVar3 == NULL) break;\n            iVar4 = (**(*piVar3 + 0xb0))();\n            if (iVar4 != 0) {\n                return piVar3;\n            }\n            iVar4 = piVar3[7];\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 199
    },
    "0043c206": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043c206(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x1c),  *(param_1 + 0x1c) != 0)) {\n        do {\n            iVar3 = iVar1;\n            iVar1 = fcn.0043c1c1(iVar3);\n        } while (iVar1 != 0);\n        uVar2 = fcn.0043aad3(iVar3);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 150
    },
    "0043c25e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043c25e(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    if ((param_1 == 0) || (iVar5 = *(param_1 + 0x1c),  iVar5 == 0)) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0);\n    while ((uVar2 & 0x40000000) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar5);\n        if (iVar3 == 0) break;\n        uVar2 = (*pcVar1)(iVar3, 0xfffffff0);\n        iVar5 = iVar3;\n    }\n    uVar4 = fcn.0043aad3(iVar5);\n    return uVar4;\n}\n",
        "token_count": 237
    },
    "0043c9e5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0043c9e5(uint param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar3 = *param_2;\n    while( true ) {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        piVar1 = fcn.0043aafa(iVar3);\n        if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x90))(param_2),  iVar2 != 0)) break;\n        if (iVar3 == unaff_retaddr) {\n            return 0;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar3);\n    }\n    return 1;\n}\n",
        "token_count": 188
    },
    "0043cf0a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0043cf0a(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n    }\n    fcn.0043aa3a();\n    return;\n}\n",
        "token_count": 129
    },
    "00447c22": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00447c22(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar5 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar5);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != -1) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar4 != 0) {\n                return hWnd;\n            }\n        }\n        uVar5 = 2;\n    } while( true );\n}\n",
        "token_count": 300
    },
    "0044c131": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0044c131(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = param_1;\n    if (param_1 != 0) goto code_r0x0044c1aa;\n    iVar3 = fcn.0044c1d9();\n    if ((iVar3 == 0) && (iVar3 = fcn.0040bd9c(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar4 = iVar3;\n        iVar5 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x1c); iVar4 = iVar3,  iVar5 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x0044c1aa:\n            uVar6 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            iVar4 = iVar3;\n            iVar5 = iVar3;\n            if ((uVar6 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar4,  iVar1 != 0) {\n        iVar4 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((param_1 == 0) && (iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar5);\n    }\n    if (param_2 != NULL) {\n        if (((iVar3 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar4 == 0)) || (iVar3 == iVar5))\n        {\n            *param_2 = 0;\n        }\n        else {\n            *param_2 = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar5;\n}\n",
        "token_count": 490
    },
    "00451f54": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00451f54(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockBar.0;\n    iVar2 = 0;\n    *(unaff_EBP + -4) = 1;\n    if (0 < extraout_ECX[0x21]) {\n        do {\n            iVar1 = fcn.00452c2a();\n            if ((iVar1 != 0) && (*(iVar1 + 0x70) == extraout_ECX)) {\n                *(iVar1 + 0x70) = 0;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < extraout_ECX[0x21]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0043546b();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00450f0a();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 318
    },
    "0045200b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0045200b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = 0;\n    iVar3 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            iVar1 = fcn.00452c2a();\n            if (iVar1 != 0) {\n                iVar2 = iVar2 + 1;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(param_1 + 0x84));\n    }\n    return iVar2;\n}\n",
        "token_count": 146
    },
    "00452bbb": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00452bbb(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            if ((iVar1 != param_3) && (*(*(param_1 + 0x80) + iVar1 * 4) == param_2)) {\n                return iVar1;\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x84));\n    }\n    return -1;\n}\n",
        "token_count": 146
    },
    "00452be9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00452be9(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            arg_8h = fcn.00452c2a(iVar1);\n            if (arg_8h != 0) {\n                fcn.0045bd43();\n                fcn.0045aec3(arg_8h, unaff_retaddr, 1);\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x84));\n    }\n    return;\n}\n",
        "token_count": 164
    },
    "00454242": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00454242(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint lpMsg;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetCapture;\n    iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.USER32.dll_SetCapture)(*(*(param_1 + 0x68) + 0x1c));\n        fcn.0043aad3(uVar3);\n        uVar3 = (*pcVar1)();\n        iVar2 = fcn.0043aad3(uVar3);\n        if (iVar2 == *(param_1 + 0x68)) {\n            do {\n                uVar4 = 0;\n                uVar3 = 0;\n                iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                if (iVar2 == 0) {\n                    fcn.0046a1d8(uVar4, var_14h);\n                    break;\n                }\n                if (var_18h == 0x100) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.00453961(uVar3, 1, var_14h);\n                    }\n                    if (var_14h == 0x1b) break;\n                }\n                else if (var_18h == 0x101) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.00453961(uVar3, 0, var_14h);\n                    }\n                }\n                else if (var_18h == 0x200) {\n                    if (*(param_1 + 0x88) == 0) {\n                        fcn.00453bed(var_8h, var_4h);\n                    }\n                    else {\n                        fcn.004538e5(var_8h, var_4h);\n                    }\n                }\n                else {\n                    if (var_18h == 0x202) {\n                        if (*(param_1 + 0x88) == 0) {\n                            fcn.00453d55();\n                        }\n                        else {\n                            fcn.00453995();\n                        }\n                        return 1;\n                    }\n                    if (var_18h == 0x204) break;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n                uVar3 = (*pcVar1)();\n                iVar2 = fcn.0043aad3(uVar3);\n            } while (iVar2 == *(param_1 + 0x68));\n        }\n        fcn.00453f32();\n    }\n    return 0;\n}\n",
        "token_count": 648
    },
    "00458bd4": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00458bd4(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    int32_t *in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint lpPoints;\n    \n    puVar1 = arg_ch + 0x24;\n    uVar6 = *(arg_ch + 0x14);\n    uVar2 = *puVar1;\n    uVar3 = *(arg_ch + 0x28);\n    uVar4 = *(arg_ch + 0x2c);\n    uVar5 = *(arg_ch + 0x30);\n    (**(*arg_8h + 0x1c))();\n    fcn.00446d88(0, 0, 0, 0);\n    uVar9 = in_ECX[0x17];\n    while (*(arg_ch + 0x14) = uVar9,  uVar9 < uVar6) {\n        (**(*in_ECX + 0xdc))(arg_8h, arg_ch);\n        uVar7 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 10);\n        uVar8 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(arg_8h[2], 8);\n        (*_sym.imp.USER32.dll_SetRect)(puVar1, 0, 0, uVar8, uVar7);\n        (*_sym.imp.GDI32.dll_DPtoLP)(arg_8h[2], puVar1, 2);\n        (**(*in_ECX + 0xfc))(arg_8h, arg_ch);\n        if (*(arg_ch + 0x14) == in_ECX[0x17]) break;\n        uVar9 = *(arg_ch + 0x14) + 1;\n    }\n    uVar9 = *(arg_ch + 0x14);\n    (**(*arg_8h + 0x20))(0xffffffff);\n    *puVar1 = uVar2;\n    *(arg_ch + 0x28) = uVar3;\n    *(arg_ch + 0x2c) = uVar4;\n    *(arg_ch + 0x30) = uVar5;\n    *(arg_ch + 0x14) = uVar6;\n    return uVar9 == uVar6;\n}\n",
        "token_count": 571
    },
    "00459f9c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.00459f9c(int32_t param_1, int32_t param_2)\n\n{\n    do {\n        if (param_1 == param_2) {\n            return 1;\n        }\n        param_2 = fcn.0043c1c1();\n    } while (param_2 != 0);\n    return 0;\n}\n",
        "token_count": 79
    },
    "0045a295": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0045a295(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    \n    uVar3 = fcn.00439ecc();\n    iVar4 = param_1;\n    if ((uVar3 & 0x40000000) == 0) {\n        iVar4 = fcn.0043c313();\n    }\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    if ((param_2 & 0xc) != 0) {\n        iVar5 = fcn.0043a0ce();\n        if ((((~param_2 & 8) == 0) || (iVar5 == 0)) || (iVar4 == param_1)) {\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 0, 0);\n        }\n        else {\n            *(param_1 + 0x25) = *(param_1 + 0x25) | 2;\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 1, 0);\n            *(param_1 + 0x25) = *(param_1 + 0x25) & 0xfd;\n        }\n    }\n    uVar7 = 5;\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    while (iVar5 = (*pcVar1)(iVar5, uVar7),  iVar5 != 0) {\n        iVar6 = fcn.00459f9c(*(iVar4 + 0x1c), iVar5);\n        if (iVar6 != 0) {\n            (*pcVar2)(iVar5, 0x36d, param_2, 0);\n        }\n        uVar7 = 2;\n    }\n    return;\n}\n",
        "token_count": 461
    },
    "00462601": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00462601(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *param_1;\n    if (iVar3 == 0) {\n        return 0;\n    }\n    if (iVar3 == param_2) {\n        *param_1 = *(param_1[1] + param_2);\n    }\n    else {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar1 = param_1[1];\n        do {\n            iVar2 = *(iVar1 + iVar3);\n            if (iVar2 == param_2) break;\n            iVar3 = iVar2;\n        } while (iVar2 != 0);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        *(iVar1 + iVar3) = *(iVar1 + param_2);\n    }\n    return 1;\n}\n",
        "token_count": 221
    },
    "00462824": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00462824(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    uint lpCriticalSection;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    for (iVar2 = *(in_ECX + 0x14); iVar2 != 0; iVar2 = *(iVar2 + 4)) {\n        if (arg_8h < *(iVar2 + 8)) {\n            puVar3 = *(*(iVar2 + 0xc) + arg_8h * 4);\n            if (puVar3 != NULL) {\n                (***puVar3)(1);\n            }\n            *(*(iVar2 + 0xc) + arg_8h * 4) = 0;\n        }\n    }\n    puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n    *puVar1 = *puVar1 & 0xfffffffe;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 265
    },
    "0046846d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0046846d(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    \n    iVar1 = fcn.004605b7();\n    if (arg_ch == 0) {\n        fcn.00436d81(arg_8h);\n        if (*(*(iVar1 + 0x30) + 0xc) == 0) {\n            piVar2 = fcn.0043aafa(*(iVar1 + 0x2c));\n            (**(*piVar2 + 0x58))();\n            if (piVar2 != NULL) {\n                (**(*piVar2 + 4))(1);\n            }\n            *(iVar1 + 0x2c) = 0;\n            fcn.00436bf0();\n            while (*(*(iVar1 + 0x38) + 0xc) != 0) {\n                uVar3 = fcn.00434f63();\n                fcn.00438360(uVar3);\n            }\n        }\n    }\n    else {\n        iVar1 = fcn.00436d0f(arg_8h, &arg_ch);\n        if (iVar1 != 0) {\n            iVar1 = arg_ch + -1;\n            arg_ch = iVar1;\n            if (iVar1 == 0) {\n                fcn.00436d81(arg_8h);\n            }\n            else {\n                piVar2 = fcn.00436d31(arg_8h);\n                *piVar2 = iVar1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 354
    },
    "0040bf84": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.0040bf84(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    bool bVar3;\n    \n    if (*0x49d050 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"USER32\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((((iVar2 != 0) &&\n             (*0x49d038 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"GetSystemMetrics\"),  *0x49d038 != 0)) &&\n            (*0x49d03c = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x49d03c != 0)) &&\n           (((*0x49d040 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x49d040 != 0 &&\n             (*0x49d044 = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x49d044 != 0)) &&\n            ((*0x49d04c = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x49d04c != 0 &&\n             (*0x49d048 = (*pcVar1)(iVar2, \"GetMonitorInfoA\"),  *0x49d048 != 0)))))) {\n            *0x49d050 = 1;\n            return true;\n        }\n        *0x49d038 = 0;\n        *0x49d03c = 0;\n        *0x49d040 = 0;\n        *0x49d044 = 0;\n        *0x49d048 = 0;\n        *0x49d04c = 0;\n        *0x49d050 = 1;\n        bVar3 = false;\n    }\n    else {\n        bVar3 = *0x49d048 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 433
    },
    "0043d6f3": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint32_t fcn.0043d6f3(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t unaff_ESI;\n    uint unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"COMCTL32.DLL\");\n    uVar5 = uVar2;\n    if (uVar2 != 0) {\n        pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, \"InitCommonControlsEx\");\n        uVar5 = 0;\n        if (pcVar3 == NULL) {\n            if ((unaff_ESI & 0x3fc0) == unaff_ESI) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = 0x3fc0;\n            }\n        }\n        else {\n            iVar4 = (*pcVar3)(unaff_EDI);\n            if ((iVar4 != 0) && (uVar5 = unaff_ESI,  iVar1 == 0)) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = unaff_ESI | 0x3fc0;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar2);\n    }\n    return uVar5;\n}\n",
        "token_count": 335
    },
    "0043ec9e": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0043ec9e(uint arg_8h, uint arg_ch, uint lpLibFileName)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t unaff_EBP;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    puVar1 = *(unaff_EBP + 0x10);\n    uVar4 = *(unaff_EBP + 8);\n    *puVar1 = 0;\n    fcn.0043ed3b(unaff_EBP + -0x10, uVar4);\n    uVar4 = *0x498098;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + 0x10) = uVar4;\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0043edaa(*(unaff_EBP + -0x10), unaff_EBP + 0x10);\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(*(unaff_EBP + 0x10));\n        if (iVar2 != 0) {\n            pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"DllGetClassObject\");\n            if (pcVar3 == NULL) {\n                uVar4 = 0x800401f9;\n            }\n            else {\n                uVar4 = (*pcVar3)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), puVar1);\n            }\n            goto code_r0x0043ed12;\n        }\n    }\n    uVar4 = 0x80040154;\ncode_r0x0043ed12:\n    *(unaff_EBP + -4) = 0;\n    fcn.00438b48();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00438b48();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 537
    },
    "00446fc4": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00446fc4(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"GetLayout\");\n    if (pcVar2 == NULL) {\n        uVar1 = 0xffffffff;\n        (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n    }\n    else {\n        uVar1 = (*pcVar2)(*(param_1 + 4));\n    }\n    return uVar1;\n}\n",
        "token_count": 148
    },
    "00446ffa": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00446ffa(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t unaff_EDI;\n    uint uVar3;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    uVar3 = 0;\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"SetLayout\");\n    if (pcVar2 == NULL) {\n        if (unaff_EDI != 0) {\n            uVar3 = 0xffffffff;\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n        }\n    }\n    else {\n        uVar3 = (*pcVar2)(*(param_1 + 4), unaff_EDI);\n    }\n    return uVar3;\n}\n",
        "token_count": 189
    },
    "0040e88d": {
        "rules": [
            "set thread local storage value"
        ],
        "decompiled_code": "\nuint fcn.0040e88d(uint *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    uint *var_8h;\n    uint var_18h;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x475d90;\n    pcStack16 = fcn.00413018;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    iVar1 = (*_sym.imp.KERNEL32.dll_TlsSetValue)(*0x498e70, var_8h);\n    if (iVar1 == 0) {\n        fcn.0040d90b(0x10);\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n    *var_8h = uVar2;\n    if (*0x498c5c != NULL) {\n        (**0x498c5c)();\n    }\n    var_4h = 0;\n    uVar2 = (*var_8h[0x12])(var_8h[0x13]);\n    fcn.0040e929(uVar2);\n    *in_FS_OFFSET = var_10h;\n    return 0;\n}\n",
        "token_count": 304
    },
    "00439434": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid fcn.00439434(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_LockResource)(param_1);\n    fcn.0043946d(uVar1, param_1, 0, param_2);\n    return;\n}\n",
        "token_count": 74
    },
    "0043d2cc": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint fcn.0043d2cc(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    uVar3 = 0;\n    if (param_1 != 0) {\n        iVar2 = fcn.00460591();\n        uVar1 = *(iVar2 + 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, param_1, 0xf0);\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, iVar2);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        }\n    }\n    uVar3 = fcn.0043d31c(uVar3);\n    return uVar3;\n}\n",
        "token_count": 207
    },
    "00439f89": {
        "rules": [
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00439f89(int32_t param_1, uint param_2, uint param_3)\n\n{\n    if (*(param_1 + 0x38) == NULL) {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), param_2, param_3);\n    }\n    else {\n        (**(**(param_1 + 0x38) + 0x84))(param_2, param_3);\n    }\n    return;\n}\n",
        "token_count": 115
    },
    "0043b4ca": {
        "rules": [
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043b4ca(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x38) == NULL) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(param_1 + 0x1c));\n        uVar2 = fcn.00438fef(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), uVar2);\n        fcn.00438fc7(0xffffffff);\n    }\n    else {\n        (**(**(param_1 + 0x38) + 0x88))(param_2);\n    }\n    return;\n}\n",
        "token_count": 177
    },
    "0046028d": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0046028d(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable._AFX_THREAD_STATE.0;\n    piVar1 = extraout_ECX[0x33];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0x58))();\n        if (extraout_ECX[0x33] != NULL) {\n            (**(*extraout_ECX[0x33] + 4))(1);\n        }\n    }\n    pcVar2 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (extraout_ECX[0xc] != NULL) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(extraout_ECX[0xc]);\n    }\n    if (extraout_ECX[0xb] != NULL) {\n        (*pcVar2)(extraout_ECX[0xb]);\n    }\n    if (extraout_ECX[3] != NULL) {\n        fcn.0040d21b(extraout_ECX[3]);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 373
    },
    "0043ec1c": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nvoid fcn.0043ec1c(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileA)(param_1, param_2);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0043f31d(uVar2);\n    }\n    return;\n}\n",
        "token_count": 106
    },
    "0043ec3e": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nvoid fcn.0043ec3e(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileA)(param_1);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0043f31d(uVar2);\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "00463157": {
        "rules": [
            "query or enumerate registry value",
            "read .ini file"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: hKey\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00463157(uint arg_8h, uint lpAppName, uint lpKeyName, uint lpDefault)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpReturnedString;\n    uint var_18h;\n    uint var_14h;\n    uint hKey;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040d954();\n    fcn.0040d980();\n    iVar2 = *(extraout_ECX + 0x7c);\n    *(unaff_EBP + -0x14) = 0;\n    if (iVar2 == 0) {\n        if (*(unaff_EBP + 0x14) == 0) {\n            *(unaff_EBP + 0x14) = 0x49b5a0;\n        }\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringA)\n                  (*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), unaff_EBP + -0x1018, 0x1000, \n                   *(extraout_ECX + 0x90));\n        iVar2 = unaff_EBP + -0x1018;\n    }\n    else {\n        iVar2 = fcn.004630a5(*(unaff_EBP + 0xc));\n        *(unaff_EBP + -0x10) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + 0xc) = *0x498098;\n            pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = (*pcVar1)(iVar2, *(unaff_EBP + 0x10), 0, unaff_EBP + -0x14, 0, unaff_EBP + -0x18);\n            if (iVar2 == 0) {\n                uVar3 = fcn.00438f78(*(unaff_EBP + -0x18), unaff_EBP + -0x18);\n                iVar2 = (*pcVar1)(*(unaff_EBP + -0x10), *(unaff_EBP + 0x10), 0, unaff_EBP + -0x14, uVar3);\n                fcn.00438fc7(0xffffffff);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x10));\n            if (iVar2 == 0) {\n                fcn.004388bd(unaff_EBP + 0xc);\n            }\n            else {\n                fcn.00438bb6(*(unaff_EBP + 0x14));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00438b48();\n            goto code_r0x00463256;\n        }\n        iVar2 = *(unaff_EBP + 0x14);\n    }\n    fcn.00438bb6(iVar2);\ncode_r0x00463256:\n    uVar3 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 827
    },
    "00462b31": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00462b31(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = *param_1;\n    if ((iVar1 != 0) && (*0x49d484 != NULL)) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(**0x49d484);\n        if ((iVar2 != 0) && (iVar1 < *(iVar2 + 8))) {\n            return *(*(iVar2 + 0xc) + iVar1 * 4);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 137
    },
    "004681f6": {
        "rules": [
            "receive data on socket",
            "receive data"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004681f6(int32_t param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    sub.WSOCK32.dll_recv(*(param_1 + 4), param_2, param_3, param_4);\n    return;\n}\n",
        "token_count": 67
    },
    "00468274": {
        "rules": [
            "send data on socket",
            "send data"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00468274(int32_t param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    sub.WSOCK32.dll_send(*(param_1 + 4), param_2, param_3, param_4);\n    return;\n}\n",
        "token_count": 66
    }
}