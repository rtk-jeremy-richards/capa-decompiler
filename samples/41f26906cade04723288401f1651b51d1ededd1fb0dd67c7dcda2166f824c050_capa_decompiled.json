{
    "0040102b": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040102b(uchar *param_1, uchar *param_2)\n\n{\n    uint8_t uVar1;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint8_t *puVar9;\n    uint8_t *puStack24;\n    uint8_t *puStack20;\n    \n    *param_2 = *param_1;\n    puStack20 = param_2 + 1;\n    bVar2 = false;\n    bVar3 = false;\n    puStack24 = param_1 + 1;\n    bVar4 = false;\n    puVar8 = param_2;\n    do {\n        iVar5 = fcn.004011dd();\n        if (iVar5 == 0) {\n            *puStack20 = *puStack24;\n            puStack24 = puStack24 + 1;\ncode_r0x004011a1:\n            puStack20 = puStack20 + 1;\n            bVar2 = false;\n        }\n        else {\n            iVar5 = fcn.004011dd();\n            if (iVar5 == 0) {\n                iVar5 = fcn.004011bc();\n                if (bVar2) {\n                    iVar7 = -2;\n                }\n                else {\n                    if (iVar5 == 2) {\n                        iVar5 = fcn.004011bc();\n                        if (iVar5 != 0) {\n                            puVar9 = puStack20 + -puVar8;\n                            do {\n                                *puStack20 = *puVar9;\n                                puStack20 = puStack20 + 1;\n                                puVar9 = puVar9 + 1;\n                                iVar5 = iVar5 + -1;\n                            } while (iVar5 != 0);\n                        }\n                        goto code_r0x0040118a;\n                    }\n                    iVar7 = -3;\n                }\n                puVar8 = (iVar5 + iVar7) * 0x100 + *puStack24;\n                puStack24 = puStack24 + 1;\n                iVar5 = fcn.004011bc();\n                if (0x7cff < puVar8) {\n                    iVar5 = iVar5 + 1;\n                }\n                if (0x4ff < puVar8) {\n                    iVar5 = iVar5 + 1;\n                }\n                if (puVar8 < 0x80) {\n                    iVar5 = iVar5 + 2;\n                }\n                if (iVar5 != 0) {\n                    puVar9 = puStack20 + -puVar8;\n                    do {\n                        *puStack20 = *puVar9;\n                        puStack20 = puStack20 + 1;\n                        puVar9 = puVar9 + 1;\n                        iVar5 = iVar5 + -1;\n                    } while (iVar5 != 0);\n                }\n            }\n            else {\n                iVar5 = fcn.004011dd();\n                if (iVar5 != 0) {\n                    iVar5 = 0;\n                    iVar7 = 4;\n                    do {\n                        iVar6 = fcn.004011dd();\n                        iVar5 = iVar6 + iVar5 * 2;\n                        iVar7 = iVar7 + -1;\n                    } while (iVar7 != 0);\n                    bVar3 = bVar4;\n                    if (iVar5 == 0) {\n                        *puStack20 = 0;\n                    }\n                    else {\n                        *puStack20 = puStack20[-iVar5];\n                    }\n                    goto code_r0x004011a1;\n                }\n                uVar1 = *puStack24;\n                puStack24 = puStack24 + 1;\n                iVar5 = (uVar1 & 1) + 2;\n                puVar8 = uVar1 >> 1;\n                if (puVar8 == NULL) {\n                    bVar3 = true;\n                    bVar4 = true;\n                }\n                else if (iVar5 != 0) {\n                    puVar9 = puStack20 + -puVar8;\n                    do {\n                        *puStack20 = *puVar9;\n                        puStack20 = puStack20 + 1;\n                        puVar9 = puVar9 + 1;\n                        iVar5 = iVar5 + -1;\n                    } while (iVar5 != 0);\n                }\n            }\ncode_r0x0040118a:\n            bVar2 = true;\n        }\n        if (bVar3) {\n            return puStack20 - param_2;\n        }\n    } while( true );\n}\n",
        "token_count": 994
    },
    "004011dd": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004011dd(uint8_t **param_1)\n\n{\n    uint8_t *puVar1;\n    \n    puVar1 = param_1[3];\n    param_1[3] = puVar1 + -1;\n    if (puVar1 == NULL) {\n        param_1[3] = 0x7;\n        param_1[2] = **param_1;\n        *param_1 = *param_1 + 1;\n    }\n    puVar1 = param_1[2];\n    param_1[2] = puVar1 * 2;\n    return puVar1 >> 7 & 1;\n}\n",
        "token_count": 148
    },
    "0040167e": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.0040167e(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t *piVar5;\n    int32_t in_EDX;\n    uint32_t uVar6;\n    uint32_t uStack36;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(arg_8h + 0x88);\n    if ((iVar3 != 0) && (*(arg_8h + 0x8c) != 0)) {\n        iVar4 = *(arg_8h + 0x1c);\n        piVar5 = iVar3 + in_ECX;\n        if (piVar5 + (-in_ECX - iVar3) < *(arg_8h + 0x8c)) {\n            do {\n                uStack36 = 0;\n                uVar6 = piVar5[1] - 8U >> 1;\n                if (uVar6 != 0) {\n                    do {\n                        uVar2 = *(piVar5 + uStack36 * 2 + 8);\n                        if ((uVar2 & 0xf000) == 0x3000) {\n                            piVar1 = (uVar2 & 0xfff) + *piVar5 + in_ECX;\n                            *piVar1 = *piVar1 + (in_EDX - iVar4);\n                        }\n                        uStack36 = uStack36 + 1;\n                    } while (uStack36 < uVar6);\n                }\n                piVar5 = piVar5 + piVar5[1];\n            } while (piVar5 + (-in_ECX - *(arg_8h + 0x88)) < *(arg_8h + 0x8c));\n        }\n    }\n    return;\n}\n",
        "token_count": 448
    },
    "004013c0": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004013c0(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    uint32_t *in_ECX;\n    uint32_t in_EDX;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    uVar3 = in_EDX & 3;\n    for (uVar2 = in_EDX >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n        uVar1 = arg_ch + uVar2 & 0x1f;\n        *in_ECX = ((*in_ECX >> uVar1 | *in_ECX << 0x20 - uVar1) ^ arg_8h) - uVar2;\n        in_ECX = in_ECX + 1;\n    }\n    for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *in_ECX = *in_ECX ^ arg_8h;\n        in_ECX = in_ECX + 1;\n    }\n    return;\n}\n",
        "token_count": 239
    },
    "00401730": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401730(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uchar *puVar2;\n    uint *in_ECX;\n    uint32_t uVar3;\n    int32_t in_EDX;\n    uint *puVar4;\n    int32_t iVar5;\n    uint var_4h;\n    \n    uVar1 = arg_8h >> 2;\n    if (uVar1 != 0) {\n        uVar3 = uVar1;\n        puVar4 = in_ECX;\n        do {\n            *puVar4 = *((in_EDX - in_ECX) + puVar4);\n            puVar4 = puVar4 + 1;\n            uVar3 = uVar3 - 1;\n        } while (uVar3 != 0);\n    }\n    if ((arg_8h & 0xfffffffc) < arg_8h) {\n        puVar2 = (arg_8h & 0xfffffffc) + in_ECX;\n        iVar5 = arg_8h + uVar1 * -4;\n        do {\n            *puVar2 = puVar2[in_EDX - in_ECX];\n            puVar2 = puVar2 + 1;\n            iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n    }\n    return;\n}\n",
        "token_count": 296
    },
    "0040143f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040143f(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    uint lpFileName;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t lpNumberOfBytesRead;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpFileName._0_2_ = 0;\n    iVar5 = 0;\n    var_14h = 0;\n    var_10h = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &lpFileName, 0x400);\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(&lpFileName, 0x80000000, 1, 0, 3, 0x8000000, 0);\n    uVar4 = extraout_ECX;\n    if (iVar2 != -1) {\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar2, 0);\n        var_14h = iVar5;\n        var_10h = fcn.00401720();\n        iVar3 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar2, var_10h, iVar5, &lpNumberOfBytesRead, 0);\n        if ((iVar3 == 0) || (lpNumberOfBytesRead != iVar5)) {\n            fcn.00401790();\n            iVar5 = 0;\n            var_10h = 0;\n            var_14h = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        uVar4 = extraout_ECX_00;\n    }\n    fcn.00401271(uVar4, &var_4h, &var_8h);\n    fcn.00401213(&var_ch, &var_1ch);\n    var_18h = *(var_ch + 0x3c) + var_ch;\n    var_1ch = *(var_18h + 0x50);\n    iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_1ch + 0x18 + iVar5, 0x3000, 0x40);\n    var_8h = iVar2;\n    if (iVar2 != 0) {\n        fcn.00401730(0x40);\n        iVar5 = var_18h;\n        var_4h = *(iVar2 + 0x3c) + iVar2;\n        fcn.00401730(*(var_18h + 0x14));\n        uVar7 = *(iVar5 + 6);\n        var_28h = *(iVar5 + 0x14) + iVar5 + 0x18;\n        var_24h = uVar7;\n        if (uVar7 != 0) {\n            do {\n                fcn.00401730(0x28);\n                iVar2 = var_8h;\n                uVar7 = uVar7 - 1;\n            } while (uVar7 != 0);\n            if (var_24h != 0) {\n                iVar5 = var_28h + 0x14;\n                uVar7 = var_24h;\n                do {\n                    fcn.00401730(*(iVar5 + -4));\n                    iVar5 = iVar5 + 0x28;\n                    uVar7 = uVar7 - 1;\n                } while (uVar7 != 0);\n            }\n        }\n        fcn.0040167e(var_4h + 0x18);\n        puVar6 = iVar2 + var_1ch;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"KERNEL32\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        *puVar6 = uVar4;\n        uVar4 = (*pcVar1)(uVar4, 0x402048);\n        puVar6[3] = uVar4;\n        uVar4 = (*pcVar1)(*puVar6, \"LoadLibraryA\");\n        puVar6[2] = uVar4;\n        uVar4 = (*pcVar1)(*puVar6, \"OutputDebugStringW\");\n        puVar6[1] = uVar4;\n        puVar6[4] = 0x18;\n        puVar6[5] = var_14h;\n        fcn.00401730(var_14h);\n        iVar2 = var_8h;\n        (*(*(*(*(var_4h + 0x78) + 0x1c + var_8h) + *(*(var_4h + 0x78) + 0x10 + var_8h) * -4 + 4 + var_8h) + var_8h))\n                  (var_8h);\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar2, 0, 0x8000);\n    }\n    fcn.00401790();\n    fcn.00401790();\n    return 1;\n}\n",
        "token_count": 1206
    },
    "00401271": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401271(uint noname_0, int32_t *arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    int32_t iVar10;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    uVar6 = 0;\n    iVar8 = *(in_ECX + 0x3c);\n    *arg_ch = 0;\n    iVar8 = iVar8 + in_ECX;\n    *arg_10h = 0;\n    iVar10 = 0;\n    if (*(iVar8 + 4) != 0x14c) {\n        return 0;\n    }\n    iVar1 = *(iVar8 + 0x88);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*(iVar8 + 0x8c) == 0) {\n        return 0;\n    }\n    iVar2 = *(iVar8 + 0x14) + 0x18 + iVar8;\n    if (*(iVar8 + 6) == 0) {\n        return 0;\n    }\n    while (*(iVar2 + 0xc) != iVar1) {\n        uVar6 = uVar6 + 1;\n        iVar2 = iVar2 + 0x28;\n        if (*(iVar8 + 6) <= uVar6) {\n            return 0;\n        }\n    }\n    iVar8 = *(iVar2 + 0x14) + in_ECX;\n    uVar6 = *(iVar8 + 0xe) + *(iVar8 + 0xc);\n    uVar9 = 0;\n    if (uVar6 == 0) {\n        return 0;\n    }\n    uVar3 = 0;\n    do {\n        iVar2 = (*(iVar8 + 0x14 + uVar3 * 8) & 0x7fffffff) + iVar8;\n        uVar3 = *(iVar2 + 0xe) + *(iVar2 + 0xc);\n        var_ch = 0;\n        if (uVar3 != 0) {\n            uVar4 = 0;\n            do {\n                if (*(iVar2 + 0x10 + uVar4 * 8) == 0x65) {\n                    iVar7 = (*(iVar2 + 0x14 + uVar4 * 8) & 0x7fffffff) + iVar8;\n                    var_8h = 0;\n                    uVar4 = *(iVar7 + 0xe) + *(iVar7 + 0xc);\n                    if (uVar4 != 0) {\n                        uVar5 = 0;\n                        do {\n                            if (*(iVar7 + 0x10 + uVar5 * 8) == 0x409) {\n                                iVar10 = *(iVar7 + 0x14 + uVar5 * 8);\n                                *arg_ch = (*(iVar10 + iVar8) - iVar1) + iVar8;\n                                *arg_10h = *(iVar10 + 4 + iVar8);\n                                iVar10 = 1;\n                                break;\n                            }\n                            var_8h = var_8h + 1;\n                            uVar5 = var_8h & 0xffff;\n                        } while (uVar5 < uVar4);\n                    }\n                    if (iVar10 != 0) {\n                        return iVar10;\n                    }\n                }\n                var_ch = var_ch + 1;\n                uVar4 = var_ch & 0xffff;\n            } while (uVar4 < uVar3);\n            if (iVar10 != 0) {\n                return iVar10;\n            }\n        }\n        uVar9 = uVar9 + 1;\n        uVar3 = uVar9 & 0xffff;\n        if (uVar6 <= uVar3) {\n            return iVar10;\n        }\n    } while( true );\n}\n",
        "token_count": 938
    },
    "004011bc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.004011bc(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 1;\n    do {\n        iVar1 = fcn.004011dd();\n        iVar2 = iVar1 + iVar2 * 2;\n        iVar1 = fcn.004011dd();\n    } while (iVar1 != 0);\n    return iVar2;\n}\n",
        "token_count": 89
    },
    "null": {
        "rules": [
            "terminate process"
        ],
        "decompiled_code": "\nuint entry0(void)\n\n{\n    uint uVar1;\n    \n    *0x403000 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    fcn.0040143f();\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1, 0);\n    return 0;\n}\n",
        "token_count": 86
    }
}