{
    "0083e077": {
        "rules": [
            "hash data using aphash/d4672a7c2b8d413ab72f7529ccc05031"
        ],
        "decompiled_code": "\nvoid fcn.0083e077(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t *extraout_ECX;\n    uint *extraout_EDX;\n    uchar auStack6072 [2048];\n    uchar auStack4024 [1024];\n    uchar auStack3000 [1024];\n    uchar auStack1976 [480];\n    uchar auStack1496 [544];\n    uchar auStack952 [156];\n    uchar auStack796 [8];\n    uchar auStack788 [20];\n    uchar auStack768 [4];\n    uchar auStack764 [4];\n    uchar auStack760 [4];\n    uint uStack756;\n    uint uStack752;\n    uint uStack748;\n    int32_t *piStack744;\n    uint uStack740;\n    uint uStack736;\n    uint uStack732;\n    int32_t iStack728;\n    uint32_t uStack724;\n    uint uStack720;\n    uint uStack716;\n    uint uStack712;\n    uint uStack708;\n    uint uStack704;\n    uint uStack700;\n    uint uStack696;\n    uint uStack692;\n    uint uStack688;\n    uint uStack684;\n    uint uStack680;\n    uint uStack676;\n    uint uStack672;\n    uint uStack668;\n    uint uStack664;\n    uint uStack660;\n    uint uStack656;\n    uint uStack652;\n    uint uStack648;\n    uint uStack644;\n    uint uStack640;\n    uint uStack636;\n    uint uStack632;\n    uint uStack628;\n    uint uStack624;\n    uint uStack620;\n    uint uStack616;\n    uint uStack612;\n    uint uStack608;\n    uint uStack604;\n    uint uStack600;\n    uint uStack596;\n    uint uStack592;\n    uint uStack588;\n    uint uStack584;\n    uint uStack580;\n    uint uStack576;\n    uint uStack572;\n    uint uStack568;\n    uint uStack564;\n    uint uStack560;\n    uint uStack556;\n    uint uStack552;\n    uint uStack548;\n    uint uStack544;\n    uint uStack540;\n    uint uStack536;\n    uint uStack532;\n    uint uStack528;\n    uint uStack524;\n    uint uStack520;\n    uint uStack516;\n    uint uStack512;\n    uint uStack508;\n    uint uStack504;\n    uint uStack500;\n    uint uStack496;\n    uint uStack492;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uint uStack476;\n    uint uStack472;\n    uint uStack468;\n    uint uStack464;\n    uint uStack460;\n    uint uStack456;\n    uint uStack452;\n    uint uStack448;\n    uint uStack444;\n    uint uStack440;\n    uint uStack436;\n    uint uStack432;\n    uint uStack428;\n    uint uStack424;\n    uint uStack420;\n    uint uStack416;\n    uint uStack412;\n    uint uStack408;\n    uint uStack404;\n    uint uStack400;\n    uint uStack396;\n    uint uStack392;\n    uint uStack388;\n    uint uStack384;\n    uint uStack380;\n    uint uStack376;\n    uint uStack372;\n    uint uStack368;\n    uint uStack364;\n    uint uStack360;\n    uint uStack356;\n    uint uStack352;\n    uint uStack348;\n    uint uStack344;\n    uint uStack340;\n    uint uStack336;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uint uStack300;\n    uint uStack296;\n    uint uStack292;\n    uint uStack288;\n    uint uStack284;\n    uint uStack280;\n    uint uStack276;\n    uint uStack272;\n    uint uStack268;\n    uint uStack264;\n    uint uStack260;\n    uint uStack256;\n    uint uStack252;\n    uint uStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uint uStack228;\n    uint uStack224;\n    uint uStack220;\n    uint uStack216;\n    uint uStack212;\n    uint uStack208;\n    uint uStack204;\n    uint uStack200;\n    uint uStack196;\n    uint uStack192;\n    uint uStack188;\n    uint uStack184;\n    uint uStack180;\n    uint uStack176;\n    uint uStack172;\n    uint uStack168;\n    uint uStack164;\n    uint uStack160;\n    uint uStack156;\n    uint uStack152;\n    uint uStack148;\n    uint uStack144;\n    uchar *puStack140;\n    uint uStack136;\n    uint uStack132;\n    uint uStack128;\n    uint uStack124;\n    uchar *puStack120;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    uchar *puStack104;\n    uint uStack100;\n    uchar *puStack96;\n    uint uStack92;\n    uchar *puStack88;\n    uint uStack84;\n    uchar *puStack80;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uchar *puStack60;\n    uint uStack56;\n    uchar *puStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uchar *puStack32;\n    uchar *puStack28;\n    uchar *puStack24;\n    uint uStack20;\n    uchar *puVar4;\n    \n    fcn.0083ee70();\n    puVar4 = *extraout_ECX;\n    uStack724 = extraout_ECX[1];\n    piStack744 = extraout_ECX;\n    if (*0x2f8bcc4 == 0x134) {\n        uStack20 = 0;\n        puStack24 = 0x83e0b4;\n        (**0x401088)();\n        puStack24 = NULL;\n        puStack28 = 0x83e0bb;\n        (**0x401084)();\n        puStack28 = NULL;\n        puStack32 = 0x83e0c2;\n        (**0x401080)();\n        puStack32 = &stack0xfffffd24;\n        uStack36 = 0;\n        uStack40 = 0;\n        uStack44 = 0;\n        uStack48 = 0;\n        puStack52 = 0x83e0d3;\n        (**0x40107c)();\n    }\n    if (*0x2f8bcc4 == 0x114e) {\n        uStack20 = 0x83e0e8;\n        (**0x401078)();\n        puVar4 = &stack0xfffff048;\n        uStack20 = 0x83e0f6;\n        fcn.0083ee60();\n    }\n    uStack736 = *extraout_EDX;\n    uStack732 = extraout_EDX[1];\n    uStack20 = 0x83e10f;\n    fcn.0083e06a();\n    if (*0x2f8bcc4 == 0xb54) {\n        uStack20 = 0;\n        puStack24 = NULL;\n        puStack28 = 0x83e129;\n        (**0x401004)();\n        puStack28 = &stack0xfffffce4;\n        puStack32 = 0x401290;\n        uStack36 = 0x83e13b;\n        (**0x401070)();\n        uStack36 = 0;\n        uStack40 = 0;\n        uStack44 = 0;\n        uStack48 = 0;\n        puStack52 = NULL;\n        uStack56 = 0x83e146;\n        (**0x40106c)();\n        uStack56 = 0;\n        puStack60 = &stack0xfffff848;\n        uStack64 = 0x83e154;\n        (**0x401068)();\n        uStack64 = 0;\n        uStack68 = 0;\n        uStack72 = 0;\n        uStack76 = 0;\n        puStack80 = NULL;\n        uStack84 = 0;\n        puStack88 = 0x83e160;\n        (**0x401000)();\n    }\n    uStack740 = extraout_EDX[2];\n    uStack748 = extraout_EDX[3];\n    iStack728 = 0x20;\n    do {\n        uStack20 = 0x83e187;\n        fcn.0083e05f();\n        if (*0x2f8bcc4 == 0x4c3) {\n            uStack20 = 0;\n            puStack24 = 0x83e19a;\n            (**0x401064)();\n            puStack24 = 0x4012d0;\n            puStack28 = 0x83e1a5;\n            (**0x401060)();\n            puStack28 = NULL;\n            puStack32 = NULL;\n            uStack36 = 0x83e1ad;\n            (**0x40105c)();\n            uStack36 = 0;\n            uStack40 = 0;\n            uStack44 = 0;\n            uStack48 = 0x83e1b6;\n            (**0x401058)();\n        }\n        if (*0x2f8bcc4 == 0x3ff) {\n            uStack20 = 0;\n            puStack24 = NULL;\n            puStack28 = &stack0xfffff848;\n            puStack32 = NULL;\n            uStack36 = 0x83e1d2;\n            (**0x401054)();\n            uStack36 = 0x4012e0;\n            uStack40 = 0;\n            uStack44 = 0;\n            uStack48 = 0x83e1df;\n            (**0x401050)();\n            uStack48 = 0;\n            puStack52 = NULL;\n            uStack56 = 0;\n            puStack60 = NULL;\n            uStack64 = 0;\n            uStack68 = 0;\n            uStack72 = 0x40135c;\n            uStack76 = 0x83e1f0;\n            (*_fcn.0040104c)();\n            *0x2f20e08 = 0;\n        }\n        if (*0x2f8bcc4 == 0xfa9) {\n            *0x2f24034 = 0xedeb2e40;\n        }\n        *0x2f24030 = 0x9150ce2e;\n        uStack476 = 0x23409e45;\n        uStack520 = 0x546684a8;\n        uStack660 = 0x3f378b90;\n        uStack344 = 0x358cf5cb;\n        uStack452 = 0x29983644;\n        uStack116 = 0x7dc6e5f5;\n        uStack216 = 0x3aa9ec81;\n        uStack512 = 0x39fd3d19;\n        uStack648 = 0x348f6274;\n        uStack284 = 0x6e41c7d3;\n        uStack640 = 0x53e187b4;\n        uStack208 = 0xfed61d6;\n        uStack632 = 0x7ada085d;\n        uStack136 = 0x4a1e8d93;\n        uStack336 = 0x456866b3;\n        uStack532 = 0x510c15d;\n        uStack128 = 0xa2eee99;\n        uStack200 = 0x778c3974;\n        uStack504 = 0x5a464473;\n        uStack496 = 0x685fa3d3;\n        uStack416 = 0x6d8c862c;\n        uStack276 = 0x6888eb1;\n        uStack624 = 0x5090d793;\n        uStack516 = 0x4abedd81;\n        uStack492 = 0x76ec4423;\n        uStack164 = 0x15e92005;\n        uStack36 = 0x70241620;\n        uStack616 = 0x131b9522;\n        uStack192 = 0x2942bb1d;\n        uStack244 = 0x2523a75b;\n        uStack272 = 0x11d08d33;\n        uStack264 = 0x4b222137;\n        uStack628 = 0x321ecfe3;\n        uStack608 = 0x575b796;\n        uStack704 = 0x1fffdd6a;\n        puStack120 = 0x75faf039;\n        uStack596 = 0x15899521;\n        uStack672 = 0x1109d039;\n        uStack236 = 0x75fcdb38;\n        uStack108 = 0x713f7202;\n        uStack508 = 0x2a34467c;\n        uStack156 = 0x7ab9969b;\n        uStack328 = 0x6e6f4f62;\n        uStack348 = 0x68a0941f;\n        uStack112 = 0x771b8962;\n        uStack408 = 0x708fef37;\n        uStack404 = 0xae5cf82;\n        uStack228 = 0x5afd073b;\n        uStack196 = 0x7da8d542;\n        uStack564 = 0x63059b8b;\n        puStack60 = 0x4e282ba7;\n        uStack420 = 0x5c4d4cf4;\n        puStack52 = 0x1a6faced;\n        uStack444 = 0x2a7bc4d0;\n        uStack636 = 0x571fe9f2;\n        uStack692 = 0x7fb79e3b;\n        uStack712 = 0x12911132;\n        uStack600 = 0x5e46be7b;\n        uStack184 = 0x3ab28b4;\n        puStack32 = 0x79ed9082;\n        uStack644 = 0x51c3c43d;\n        uStack396 = 0x4ed5ae5f;\n        puStack104 = 0x77ee5c69;\n        uStack588 = 0x699e0318;\n        uStack388 = 0x6a3df6d9;\n        uStack400 = 0x6a68727f;\n        uStack316 = 0x71a88410;\n        uStack468 = 0x72144519;\n        uStack684 = 0x7943706e;\n        uStack148 = 0x166ccf3d;\n        uStack380 = 0x5d7bef27;\n        uStack340 = 0x3fb67f18;\n        uStack592 = 0x687df6e2;\n        uStack392 = 0xb23fdac;\n        uStack268 = 0x3c0ec683;\n        uStack188 = 0x52c79ee7;\n        uStack580 = 0xea67b34;\n        uStack220 = 0x59ee28df;\n        uStack372 = 0x2817525b;\n        uStack488 = 0x41ec49cf;\n        puStack96 = 0x152f532e;\n        uStack100 = 0x6bcf2b09;\n        uStack584 = 0xd0455f;\n        uStack612 = 0x113cca32;\n        uStack92 = 0x2ca09670;\n        uStack708 = 0x1083bd57;\n        uStack176 = 0x8e56de1;\n        uStack436 = 0x357268d5;\n        uStack548 = 0x3f5a247a;\n        uStack44 = 0x7a66e545;\n        uStack700 = 0x24e4c52e;\n        uStack364 = 0x18be6c3e;\n        uStack320 = 0x3db8192e;\n        uStack524 = 0x777708fe;\n        uStack680 = 0x746719ea;\n        uStack308 = 0x70e28784;\n        uStack384 = 0x74b1451c;\n        uStack168 = 0x1fc38e1c;\n        uStack720 = 0x1a454084;\n        uStack260 = 0x6cfab315;\n        uStack312 = 0x5bcca26f;\n        uStack576 = 0xadc7db7;\n        uStack484 = 0x33be3dc9;\n        uStack568 = 0x218471aa;\n        uStack376 = 0x65649589;\n        uStack332 = 0x51dad296;\n        uStack572 = 0x3c96d833;\n        uStack180 = 0x65f5d1c;\n        uStack412 = 0x45644988;\n        uStack368 = 0x69748472;\n        uStack256 = 0x297ecfd3;\n        uStack556 = 0x4f7dbcd7;\n        uStack84 = 0x18561cab;\n        uStack160 = 0x720ef4aa;\n        uStack324 = 0x10ed17e7;\n        uStack500 = 0x3953200b;\n        puStack88 = 0x5142c32a;\n        uStack688 = 0x563d11f2;\n        uStack480 = 0x160fd461;\n        uStack560 = 0x603ca06c;\n        uStack248 = 0x13629ac1;\n        uStack304 = 0x74093f37;\n        uStack664 = 0x679680a8;\n        uStack472 = 0x207d8eeb;\n        uStack656 = 0xa216c63;\n        uStack240 = 0x2f5adecc;\n        uStack360 = 0x44a2df35;\n        uStack552 = 0x4a3c9e05;\n        uStack544 = 0x2ac010e7;\n        puStack80 = 0x67852e;\n        uStack356 = 0x483f468d;\n        uStack76 = 0xea69142;\n        uStack464 = 0x1b85e6;\n        uStack72 = 0x2e8bf091;\n        puStack140 = 0x7accba6a;\n        uStack212 = 0x70b903ac;\n        uStack428 = 0x8dfbb34;\n        uStack172 = 0x41683a2c;\n        uStack652 = 0x1c83fdd3;\n        uStack252 = 0x4ad81701;\n        uStack296 = 0x5d5c7f97;\n        uStack64 = 0x679ac91e;\n        uStack56 = 0x1899f8c7;\n        uStack152 = 0x4b6ad8c;\n        uStack300 = 0x103e9126;\n        uStack68 = 0x72b610fa;\n        uStack456 = 0x348041df;\n        uStack144 = 0x7cee9c15;\n        uStack676 = 0x18528e3a;\n        uStack448 = 0x2d0d3107;\n        uStack232 = 0x7b65c550;\n        uStack536 = 0x75ec9eda;\n        uStack604 = 0x42646a58;\n        uStack460 = 0x3ddf5eff;\n        uStack288 = 0x36dc2ee9;\n        uStack48 = 0x21b2f01a;\n        uStack668 = 0x726bed3c;\n        uStack716 = 0x6718329c;\n        uStack540 = 0x8d77509;\n        uStack132 = 0x56f4f074;\n        uStack696 = 0x6b3a3a26;\n        uStack440 = 0x6bee7b34;\n        uStack432 = 0x2a76cefe;\n        uStack40 = 0x25736362;\n        uStack424 = 0x5e24fb8f;\n        uStack292 = 0x13cc9676;\n        uStack280 = 0x145ce368;\n        uStack204 = 0x53a4e4aa;\n        uStack352 = 0x180454cc;\n        uStack620 = 0x5abc23bd;\n        uStack124 = 0x7a98d7b;\n        uStack528 = 0x48a0c18f;\n        uStack224 = 0x6e4572f2;\n        puStack24 = 0x924e26a9;\n        uStack20 = 0x83e889;\n        fcn.0083e071();\n        if (*0x2f8bcc4 == 0xa2) {\n            uStack20 = 0x83e89b;\n            (**0x401048)();\n            uStack20 = 0;\n            puStack24 = &stack0xfffffd04;\n            puStack28 = NULL;\n            puStack32 = &stack0xfffff848;\n            uStack36 = 0;\n            uStack40 = 0x83e8b2;\n            (**0x401044)();\n        }\n        uVar1 = uStack724;\n        puStack28 = uStack724 << 4;\n        uStack20 = 0x83e8eb;\n        fcn.0083e074();\n        uVar2 = uVar1 >> 5;\n        uStack20 = 0x83e901;\n        fcn.0083e074();\n        uStack20 = 0x83e90c;\n        uVar3 = fcn.0083e065();\n        puStack28 = uVar3 ^ uVar2;\n        *0x866b1c = 0;\n        puVar4 = puVar4 + -puStack28;\n        if (*0x2f8bcc4 == 0xcb6) {\n            uStack20 = 0x401384;\n            puStack24 = NULL;\n            puStack28 = NULL;\n            puStack32 = 0x83e93b;\n            (**0x401040)();\n            puStack32 = NULL;\n            uStack36 = 0;\n            uStack40 = 0x83e943;\n            (**0x40103c)();\n            uStack40 = 0;\n            uStack44 = 0;\n            uStack48 = 0;\n            puStack52 = &stack0xfffffc48;\n            uStack56 = 0x83e953;\n            (**0x401038)();\n            uStack56 = 0;\n            puStack60 = 0x83e95a;\n            (**0x401034)();\n            puStack60 = &stack0xfffffd0c;\n            uStack756 = 0;\n            uStack752 = 0;\n            uStack64 = 0x83e973;\n            (**0x401134)();\n            uStack64 = 0;\n            uStack68 = 0;\n            uStack72 = 0x83e97b;\n            (**0x401030)();\n            uStack72 = 0;\n            uStack76 = 0;\n            puStack80 = &stack0xffffe848;\n            uStack84 = 0;\n            puStack88 = 0x83e98b;\n            (**0x40102c)();\n            puStack88 = &stack0xfffffd08;\n            uStack92 = 0;\n            puStack96 = &stack0xfffffcec;\n            uStack100 = 0;\n            puStack104 = 0x83e9a1;\n            (**0x401028)();\n            puStack104 = &stack0xfffffd00;\n            uStack108 = 0;\n            uStack112 = 0;\n            uStack116 = 0;\n            puStack120 = 0x83e9b1;\n            (**0x401024)();\n            puStack120 = &stack0xfffffa28;\n            uStack124 = 0;\n            uStack128 = 0;\n            uStack132 = 0x83e9c0;\n            (**0x401020)();\n            uStack132 = 0;\n            uStack136 = 0x83e9c7;\n            (**0x40101c)();\n            uStack136 = 0x83e9cd;\n            (**0x401018)();\n            uStack136 = 0;\n            puStack140 = &stack0xfffff448;\n            uStack144 = 0x4013bc;\n            uStack148 = 0x83e9e0;\n            (**0x401014)();\n            uStack148 = 0;\n            uStack152 = 0;\n            uStack156 = 0;\n            uStack160 = 0x83e9e9;\n            (**0x4010a0)();\n        }\n        iStack728 = iStack728 + -1;\n    } while (iStack728 != 0);\n    piStack744[1] = uVar1;\n    *piStack744 = puVar4;\n    return;\n}\n",
        "token_count": 5689
    },
    "0083ea11": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "set console window title"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0083ea11(uint param_1, uint32_t param_2)\n\n{\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uchar *puStack80;\n    uint uStack76;\n    uint uStack72;\n    uchar *puStack68;\n    uchar auStack40 [4];\n    uchar auStack36 [36];\n    \n    for (param_2 = param_2 >> 3; param_2 != 0; param_2 = param_2 - 1) {\n        if (*0x2f8bcc4 == 0x319) {\n            puStack68 = &stack0xffffffdc;\n            uStack72 = 0;\n            puStack80 = &stack0xffffffd8;\n            uStack76 = 0;\n            uStack84 = 0;\n            uStack88 = 0x83ea6a;\n            (**0x4010b4)();\n            uStack88 = 0;\n            uStack92 = 0x83ea71;\n            (**0x4010b0)();\n            uStack92 = 0;\n            (**0x4010ac)();\n            (**0x4010a8)(0);\n            (**0x4010a4)(0, 0);\n            (**0x401130)(0, 0, &stack0xffffffbc);\n            (**0x40109c)(0, 0);\n            (**0x401098)(0);\n            (**0x401094)(0, 0);\n            (**0x401048)();\n            (**0x401090)(0, &stack0xffffffa4);\n            (**0x40108c)(0, 0);\n        }\n        puStack68 = 0x83ead0;\n        fcn.0083e077();\n    }\n    return;\n}\n",
        "token_count": 391
    },
    "0083eaeb": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nvoid fcn.0083eaeb(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_834h;\n    uint var_434h;\n    uint var_34h;\n    uint var_18h;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    *0x2f24024 = (**0x4010e4)(0x4013ec);\n    pcVar1 = _fcn.004010e0;\n    *0x2f2401c = (*_fcn.004010e0)(*0x2f24024, 0x4013fc);\n    *0x2f20dfc = (*pcVar1)(*0x2f24024, 0x401408);\n    *0x2f20e14 = (**0x2f2401c)(0, *0x2f8bcc4);\n    (**0x2f20dfc)(*0x2f20e14, *0x2f8bcc4, 0x40, &var_4h);\n    uVar2 = 0;\n    do {\n        if (uVar2 < 0x85b4) {\n            (*_fcn.004010dc)();\n            (**0x40100c)(0, 0, 0, 0);\n            (**0x401210)(0, 0, 0, 0, 0);\n        }\n        (**0x4010d8)(0, 0, 0, 0, 0);\n        if (0x11c825e < uVar2) break;\n        uVar2 = uVar2 + 1;\n    } while ((uVar2 >> 0x1f < 0x3f) || ((uVar2 >> 0x1f < 0x40 && (uVar2 < 0x45b08f85))));\n    *0x2f8bcc8 = *0x848724;\n    uVar2 = 0;\n    if (*0x2f8bcc4 != 0) {\n        do {\n            (*0x2f20e14)[uVar2] = *(*0x2f8bcc8 + 0xb2d3b + uVar2);\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < *0x2f8bcc4);\n    }\n    iVar3 = 0;\n    do {\n        if (*0x2f8bcc4 + iVar3 == 0x5e) {\n            (**0x4010d4)(0, 0, 0);\n            (**0x4010d0)(0, 0, 0, 0);\n            (**0x4010cc)(0, &var_834h, 0);\n            (**0x4010c8)(0);\n            (**0x4010c4)(0, 0, 0);\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0xa69b);\n    fcn.0083ea11(0x848008);\n    iVar3 = 0;\n    do {\n        if (iVar3 == 23000) {\n            iVar3 = fcn.0083eae4();\n        }\n        iVar3 = iVar3 + 1;\n    } while (iVar3 < 0x356d83);\n    iVar3 = 0x7b;\n    do {\n        if (*0x2f8bcc4 == 0x54d) {\n            var_18h = 0;\n            var_14h = 0;\n            uStack20 = 0;\n            uStack16 = 0;\n            uStack12 = 0;\n            (**0x4010c0)(0x401418, &var_34h, &var_18h);\n            (**0x4010bc)(0, 0, 0, 0);\n            (**0x4010b8)(&var_434h, 0);\n        }\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    *0x2f2402c = *0x2f20e14;\n    (**0x2f20e14)();\n    return;\n}\n",
        "token_count": 953
    },
    "00840810": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00840903: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00840908)\n// WARNING: Removing unreachable block (ram,0x00840936)\n// WARNING: Removing unreachable block (ram,0x0084090e)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00840810(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0084047c(0x8469a0, 0x18);\n    fcn.0083f985(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x2f8be68 != 1) {\n        *0x2f8be64 = 1;\n        *0x2f8be60 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.00841e23(*0x2f8d96c);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.00841e23(*0x2f8d968);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.00841e1a();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.00841e23(*piVar2);\n                        iVar3 = fcn.00841e1a();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.00841e23(*0x2f8d96c);\n                        piVar1 = fcn.00841e23(*0x2f8d968);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.0084074a(0x401250);\n        }\n        fcn.0084074a(0x401258);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0083f8ab(8);\n    }\n    return;\n}\n",
        "token_count": 812
    },
    "00840dc5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.00840dc5(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.0083f8ab(0);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00840e01": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00840e01(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x84aba8) {\n        return;\n    }\n    *0x2f8c510 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                 (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                 ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                 (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x2f8c514 = &arg_8h;\n    *0x2f8c450 = 0x10001;\n    *0x2f8c3f8 = 0xc0000409;\n    *0x2f8c3fc = 1;\n    var_328h = *0x84aba8;\n    var_324h = *0x84abac;\n    *0x2f8c404 = unaff_retaddr;\n    *0x2f8c4dc = in_GS;\n    *0x2f8c4e0 = in_FS;\n    *0x2f8c4e4 = in_ES;\n    *0x2f8c4e8 = in_DS;\n    *0x2f8c4ec = unaff_EDI;\n    *0x2f8c4f0 = unaff_ESI;\n    *0x2f8c4f4 = unaff_EBX;\n    *0x2f8c4f8 = in_EDX;\n    *0x2f8c4fc = in_ECX;\n    *0x2f8c500 = in_EAX;\n    *0x2f8c504 = unaff_EBP;\n    *0x2f8c508 = unaff_retaddr;\n    *0x2f8c50c = in_CS;\n    *0x2f8c518 = in_SS;\n    *0x2f8c448 = (*_fcn.00401178)();\n    fcn.0084412e(1);\n    (*_fcn.0040113c)(0);\n    (*_fcn.00401138)(0x401b7c);\n    if (*0x2f8c448 == 0) {\n        fcn.0084412e(1);\n    }\n    uVar1 = (*_fcn.004010dc)(0xc0000409);\n    (*_fcn.00401174)(uVar1);\n    return;\n}\n",
        "token_count": 868
    },
    "00842d94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00842d94(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.00841e1a();\n    var_4h = 0;\n    if (*0x2f8c3e0 == 0) {\n        iVar2 = (**0x401060)(0x401b70);\n        pcVar4 = _fcn.004010e0;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_fcn.004010e0)(iVar2, 0x401b64);\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x2f8c3e0 = fcn.00841da8(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, 0x401b54);\n        *0x2f8c3e4 = fcn.00841da8(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x401b40);\n        *0x2f8c3e8 = fcn.00841da8(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x401b24);\n        *0x2f8c3f0 = fcn.00841da8(uVar3);\n        if (*0x2f8c3f0 != 0) {\n            uVar3 = (*pcVar4)(iVar2, 0x401b0c);\n            *0x2f8c3ec = fcn.00841da8(uVar3);\n        }\n    }\n    if ((*0x2f8c3ec != iVar1) && (*0x2f8c3f0 != iVar1)) {\n        pcVar4 = fcn.00841e23(*0x2f8c3ec);\n        pcVar5 = fcn.00841e23(*0x2f8c3f0);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x00842ed6;\n        }\n    }\n    if ((((*0x2f8c3e4 != iVar1) && (pcVar4 = fcn.00841e23(*0x2f8c3e4),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x2f8c3e8 != iVar1 && (pcVar4 = fcn.00841e23(*0x2f8c3e8),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x00842ed6:\n    pcVar4 = fcn.00841e23(*0x2f8c3e0);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 882
    },
    "00840e85": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00840e85(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0084047c(0x8469e0, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0083f6b5();\n        *puVar2 = 0;\n        puVar2 = fcn.0083f6a2();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x2f8c828)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x2f8c840;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.008436d8(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0083f6a2();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0083f6b5();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.00840e10(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00840f57(0x8469e0);\n                goto code_r0x00840f51;\n            }\n        }\n        puVar2 = fcn.0083f6b5();\n        *puVar2 = 0;\n        puVar2 = fcn.0083f6a2();\n        *puVar2 = 9;\n        fcn.0084140c(0, 0, 0, 0, 0);\n    }\ncode_r0x00840f51:\n    fcn.008404c1();\n    return;\n}\n",
        "token_count": 650
    },
    "00843ed2": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00843ed2(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0084047c(0x846b78, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0083f6b5();\n        *puVar2 = 0;\n        puVar2 = fcn.0083f6a2();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x2f8c828)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x2f8c840;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.008436d8(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0083f6a2();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0083f6b5();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0084379f(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00843fa4(0x846b78);\n                goto code_r0x00843f9e;\n            }\n        }\n        puVar2 = fcn.0083f6b5();\n        *puVar2 = 0;\n        puVar2 = fcn.0083f6a2();\n        *puVar2 = 9;\n        fcn.0084140c(0, 0, 0, 0, 0);\n    }\ncode_r0x00843f9e:\n    fcn.008404c1();\n    return;\n}\n",
        "token_count": 650
    },
    "0044b68a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0044b63f) overlaps instruction at (ram,0x0044b63c)\n// \n\nvoid __fastcall int.0044b68a(uint32_t *param_1, uchar *param_2)\n\n{\n    uint8_t *puVar1;\n    uint32_t *puVar2;\n    char *pcVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    code *pcVar6;\n    uint8_t uVar7;\n    char cVar9;\n    uint16_t uVar8;\n    uint32_t in_EAX;\n    char cVar10;\n    uchar *puVar11;\n    uint8_t *unaff_EBX;\n    uint32_t unaff_EBP;\n    uint *puVar12;\n    uint *unaff_ESI;\n    uint32_t *puVar13;\n    uint *puVar14;\n    uint32_t *unaff_EDI;\n    ushort in_DS;\n    uint8_t in_CF;\n    bool in_PF;\n    uint8_t in_AF;\n    char in_ZF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uchar in_OF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uchar in_XMM3 [16];\n    uchar in_XMM7 [16];\n    \n    if (in_PF) goto code_r0x0044b64a;\n    puVar12 = unaff_ESI + 1;\n    in_EAX = in_EAX & 0xffffff00 | *unaff_ESI;\n    in_DS = unaff_EBP;\n    puVar1 = unaff_EBX + -0x66;\n    in_CF = 0;\n    in_OF = false;\n    *puVar1 = *puVar1 | unaff_EBX;\n    in_ZF = *puVar1 == 0;\n    if (param_1 == NULL) {\n        unaff_EBP = (in_NT & 1) * 0x4000 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 | (*puVar1 < '\\0') * 0x80 |\n                    ((POPCOUNT(*puVar1) & 1U) == 0) * 4 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 |\n                    (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n        puVar11 = param_2;\n        puVar13 = unaff_EDI;\n        while( true ) {\n            unaff_EDI = puVar13 + 1;\n            *puVar13 = in_EAX;\n            param_2 = puVar11;\n            unaff_ESI = puVar12;\ncode_r0x0044b64a:\n            puVar11 = &stack0xfffffffc;\n            puVar13 = unaff_EDI;\n            if (in_OF) break;\n            *0x54ada3c = in_EAX;\n            if (in_CF || in_ZF) {\n                uVar4 = in(param_2);\n                *unaff_EDI = uVar4;\n                pcVar6 = swi(1);\n                (*pcVar6)();\n                return;\n            }\n            cVar9 = in_EAX >> 8;\n            cVar10 = param_1;\n            param_1 = param_1 & 0xffffff00 | cVar10 - cVar9;\n            puVar12 = unaff_ESI + 2;\n            uVar8 = *unaff_ESI;\n            in_EAX = in_EAX & 0xffff0000 | uVar8;\n            in_AF = (uVar8 & 0x1000) != 0;\n            if (SBORROW1(cVar10, cVar9) == ((uVar8 & 0x8000) != 0)) {\n                in_AF = 9 < (unaff_EBP & 0xf) || in_AF;\n                uVar8 = CONCAT11((unaff_EBP >> 8) - in_AF, unaff_EBP + in_AF * -6) & 0xff0f;\n                in_EAX = unaff_EBP & 0xffff0000 | uVar8;\n                puVar11 = segment(in_DS, 0xa0ad);\n                *puVar11 = uVar8;\n                puVar2 = unaff_EDI + 0x27207e31;\n                uVar4 = in_AF;\n                uVar5 = *puVar2 + 0x639af787;\n                in_CF = *puVar2 < 0x9c650879 || uVar5 < uVar4;\n                in_OF = SBORROW4(*puVar2, -0x639af787) != SBORROW4(uVar5, uVar4);\n                *puVar2 = uVar5 - uVar4;\n                in_ZF = *puVar2 == 0;\n                puVar11 = &stack0xfffffffc;\n            }\n            else {\n                while( true ) {\n                    uVar7 = in_EAX;\n                    puVar2 = puVar12 + 8;\n                    in_OF = false;\n                    *0x9f81a0ad = uVar7;\n                    *puVar2 = *puVar2 ^ unaff_EDI;\n                    in_ZF = *puVar2 == 0;\n                    in_AF = 9 < (uVar7 & 0xf) | in_AF;\n                    uVar7 = uVar7 + in_AF * '\\x06';\n                    in_CF = 0x90 < (uVar7 & 0xf0) | in_AF * (0xf9 < uVar7);\n                    in_EAX = in_EAX & 0xffffff00 | uVar7 + in_CF * '`';\n                    if (*puVar2 < 0) break;\ncode_r0x0044b64f:\n                    param_1 = param_1 + -1;\n                    if (param_1 == NULL || in_ZF != '\\0') {\n                        puVar14 = unaff_EDI & 0xffff0000 | in_EAX & 0xffff;\n                        *unaff_EBX = *unaff_EBX & unaff_EDI & 0xffff;\n                        if ((in_EAX & 0xffff0000 | unaff_EDI & 0xffff | 0xa89995fb) != 0) {\n                            *puVar14 = *puVar12;\n                            return;\n                        }\n                        *(puVar11 + (-(puVar14 < *(puVar11 + 0x1223224a)) - puVar12)) =\n                             *(puVar11 + (-(puVar14 < *(puVar11 + 0x1223224a)) - puVar12)) >> 0x11;\n                        *0x6319015d = *0x6319015d & 0x534b9f0d;\n    // WARNING: Bad instruction - Truncating control flow here\n                        halt_baddata();\n                    }\n                }\n            }\n        }\n        unaff_EBX = CONCAT31(unaff_EBX >> 8, 99);\n        puVar11 = param_2;\n        puVar12 = unaff_ESI;\n        goto code_r0x0044b64f;\n    }\n    pcVar3 = (unaff_EBX & 0xffff0000 | CONCAT11(0xb4, unaff_EBX)) + 0xa54107a8;\n    *pcVar3 = *pcVar3 + -0x11;\n    *param_1 = *param_1 ^ 0x708a257a;\n    pcVar3 = param_1 + 0x14a44dff;\n    cVar9 = *pcVar3;\n    cVar10 = param_1 >> 8;\n    *pcVar3 = *pcVar3 + cVar10;\n    if (SCARRY1(cVar9, cVar10) == *pcVar3 < '\\0') {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    divps(in_XMM3, in_XMM7);\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 1844
    },
    "0083e06a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0083e06a(int32_t *param_1)\n\n{\n    *param_1 = *param_1 + -0x3910c934;\n    return;\n}\n",
        "token_count": 44
    },
    "0083e074": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0083e074(int32_t *param_1, int32_t param_2)\n\n{\n    *param_1 = *param_1 + param_2;\n    return;\n}\n",
        "token_count": 46
    },
    "0083eae4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0083eae4(uint *param_1)\n\n{\n    *param_1 = *param_1;\n    return;\n}\n",
        "token_count": 34
    },
    "0083eca4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0083eca4(void)\n\n{\n    char cVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    uint var_714h;\n    uint var_314h;\n    uint var_f4h;\n    uint var_ech;\n    uint var_58h;\n    uint var_54h;\n    uint var_24h;\n    uint var_20h;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*0x2f8bcc4 == 0x598) {\n        (**0x401124)(0x401428, &var_8h, &var_10h, &var_ch, &var_4h);\n        (**0x401078)();\n        var_24h = 0;\n        var_20h = 0;\n        uStack32 = 0;\n        uStack28 = 0;\n        uStack24 = 0;\n        (**0x401120)(0, 0, 0, &var_24h);\n        fcn.0083f3b7(0);\n        fcn.0083f195(0, 0, 0);\n        fcn.0083eff4();\n    }\n    iVar3 = 0xa4808;\n    do {\n        if (*0x2f8bcc4 == 0x57c) {\n            (**0x40111c)();\n            (**0x40102c)(0, 0, 0, 0);\n            var_58h = 0;\n            fcn.0083f430(&var_54h, 0, 0x30);\n            (**0x401118)(0, 0, &var_58h);\n            (**0x401114)(0, 0);\n            (**0x401110)(0, 0, &var_714h);\n            (**0x40110c)(0, 0);\n            (**0x401020)(0, 0, &var_314h);\n            (**0x401108)(0, 0, 0, 0, 0);\n            (**0x401104)(0, 0);\n            var_4h = 0;\n            (**0x401100)(0, 0, 0, 0, &var_8h);\n        }\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    *0x2f8bcc4 = *0x8496d4 + 0xb2d3b;\n    pcVar2 = 0x84b720;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    if (pcVar2 == 0x84cc36) {\n        if (*0x2f8bcc4 == 0x18) {\n            (**0x401038)(&var_f4h, 0, 0, 0);\n            fcn.0083ee66(0);\n            (**0x4010f8)(0, 0);\n            (**0x4010f4)(0, 0, 0, 0);\n            (**0x4010f0)();\n        }\n        if (*0x2f8bcc4 == 0x9e6) {\n            (**0x4010ec)(&var_ech);\n            (**0x4010e8)(0, 0, 0, 0, 0, &var_8h);\n        }\n        fcn.0083ef2a(0);\n        fcn.0083ee9b(0, 0);\n        fcn.0083f3b7(0);\n    }\n    fcn.0083eaeb();\n    return 0;\n}\n",
        "token_count": 854
    },
    "0084093c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0084093c(uint arg_8h)\n\n{\n    fcn.00840810(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 40
    },
    "00841d5c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00841d70)\n// WARNING: Removing unreachable block (ram,0x00841d76)\n// WARNING: Removing unreachable block (ram,0x00841d78)\n\nvoid fcn.00841d5c(void)\n\n{\n    return;\n}\n",
        "token_count": 65
    },
    "0084605c": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0084605c(void)\n\n{\n    *0x84b604 = (*_fcn.0040104c)(0x402540, 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 60
    }
}