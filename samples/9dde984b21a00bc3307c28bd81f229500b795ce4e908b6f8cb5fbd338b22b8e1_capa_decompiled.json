{
    "00401000": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00401000(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_EAX;\n    uint32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    int32_t iVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    // [00] -r-x section size 995328 named .text\n    iVar1 = in_EAX;\n    if (unaff_EBX <= *(unaff_EBX + 0x4f53f4)) {\n        arg_ch = arg_ch + 1;\n        iVar1 = in_EAX + 1;\n    }\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) & 1;\n    if (0x1239 < iVar1) {\n        *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) | 0xfffff947;\n        in_ECX = in_ECX - 1;\n    }\n    iVar1 = (in_ECX ^ 1) - 0x5e4;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + 1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + -1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) ^ -iVar1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + 1;\n    arg_ch = iVar1 + in_ECX & arg_ch;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + -1;\n    *(unaff_EBX + 0x4f53f4) = 1;\n    *(unaff_EBX + 0x4f53f4) = 1;\n    *(unaff_EBX + 0x4f53f4) = arg_ch ^ 0xffffffff;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + -1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + -1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) ^ (arg_ch + 1 | 0x661);\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + -1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4);\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4);\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) & 1;\n    *(unaff_EBX + 0x4f53f4) = 1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) ^ 1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) + -1;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4) | 0xfffffffc;\n    *(unaff_EBX + 0x4f53f4) = 0x78;\n    *(unaff_EBX + 0x4f53f4) = 0xfffff868;\n    *(unaff_EBX + 0x4f53f4) = *(unaff_EBX + 0x4f53f4);\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 1006
    },
    "0040131e": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040131e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t extraout_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_EDI;\n    uint32_t uVar1;\n    uint arg_10h_00;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = unaff_EDI - 1U | 0x7bc;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + 1;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + 1;\n    *(unaff_EBX + 0x4f5234) = *(unaff_EBX + 0x4f5234) & uVar1;\n    *(unaff_EBX + 0x4f5164) = *(unaff_EBX + 0x4f5164);\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + -1;\n    *(unaff_EBX + 0x4f5234) = 1;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284);\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) | uVar1 - 1;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + 1;\n    *(unaff_EBX + 0x4f5164) = 0xffffffff;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284);\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + 1;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) & 1;\n    *(unaff_EBX + 0x4f5284) = 0xffffffff;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) ^ 0x2ab;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + -1;\n    *(unaff_EBX + 0x4f5164) = 0xffffffff;\n    *(unaff_EBX + 0x4f5164) = *(unaff_EBX + 0x4f5164) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5164) = *(unaff_EBX + 0x4f5164) + -1;\n    *(unaff_EBX + 0x4f5164) = *(unaff_EBX + 0x4f5164) + -1;\n    *(unaff_EBX + 0x4f5164) = 0xfffffc13;\n    *(unaff_EBX + 0x4f5234) = *(unaff_EBX + 0x4f5234) + (0x9b4U - *(unaff_EBX + 0x4f5234) & 2);\n    *(unaff_EBX + 0x4f5284) = 0;\n    fcn.00407b8c(*(unaff_EBX + 0x4f5428));\n    *(unaff_EBX + 0x4f5284) = 0;\n    arg_10h_00 = *(unaff_EBX + 0x4f5438);\n    fcn.00409272(unaff_EBX, *(unaff_EBX + 0x4f51cc), arg_10h_00);\n    *(unaff_EBX + 0x4f5234) = *(unaff_EBX + 0x4f5234) | extraout_ECX;\n    *(unaff_EBX + 0x4f5234) = *(unaff_EBX + 0x4f5234) ^ extraout_ECX - *(unaff_EBX + 0x4f5284);\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284);\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + -1;\n    *(unaff_EBX + 0x4f5164) = 0xfffff877;\n    *(unaff_EBX + 0x4f5284) = *(unaff_EBX + 0x4f5284) + -1;\n    return CONCAT44(arg_10h_00, unaff_EDI);\n}\n",
        "token_count": 1150
    },
    "0040168b": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040168b(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint in_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar4;\n    uint32_t unaff_EDI;\n    uint32_t var_4h;\n    \n    if (in_EAX < 0x5cc8) {\n        *(unaff_EBX + 0x4f54e8) = in_EAX;\n        var_4h = var_4h | in_EDX;\n    }\n    else {\n        *(unaff_EBX + 0x4f54e8) = 0xfffff9b0;\n    }\n    uVar2 = in_EAX - 0x5c3;\n    *(unaff_EBX + 0x4f54e8) = in_EDX;\n    if (var_4h < 0x4914) {\n        uVar3 = unaff_ESI - 1;\n    }\n    else {\n        uVar2 = 0;\n        uVar3 = unaff_ESI;\n    }\n    uVar4 = uVar3 ^ uVar2 | 0x391;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) | uVar4;\n    iVar1 = *(unaff_EBX + 0x4f54e8);\n    uVar3 = ((uVar2 ^ 0xffffffff) - 3 & 0xfffff984) - 0x47b ^ 0xffffffff;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + -0x7ac;\n    uVar2 = unaff_EDI - iVar1 | 1;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) | uVar2;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + (uVar2 - (uVar3 - 0x200));\n    uVar2 = *(unaff_EBX + 0x4f54e8);\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8);\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + -1;\n    uVar2 = ((in_EDX & unaff_EDI) + uVar4 + (uVar3 - 0x90d) & uVar2) - 0x15c & *(unaff_EBX + 0x4f54e8);\n    *(unaff_EBX + 0x4f54e8) = 0;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) - uVar2;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8);\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) | uVar4 - 1;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8);\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + 1;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + 1;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + 1;\n    fcn.0040d730(uVar2 - 1);\n    *(unaff_EBX + 0x4f54e8) = 1;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + 1;\n    *(unaff_EBX + 0x4f54e8) = *(unaff_EBX + 0x4f54e8) + 0x639;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 1078
    },
    "004019d4": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004019d4(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t in_EAX;\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar4;\n    uint arg_8h_00;\n    uint arg_ch_00;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (var_4h < unaff_ESI) {\n        uVar1 = in_EAX - 1;\n    }\n    else {\n        uVar1 = in_EAX ^ 1;\n    }\n    if ((POPCOUNT(uVar1 - 0xfdff & 0xff) & 1U) != 0) {\n        fcn.0040783f(*(unaff_EBX + 0x4f5368));\n        in_EDX = extraout_EDX;\n    }\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) ^ in_EDX;\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) + -1;\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc);\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc);\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) ^ 0xffffffff;\n    fcn.00410a3a(*(unaff_EBX + 0x4f518c));\n    arg_ch_00 = *(unaff_EBX + 0x4f514c);\n    fcn.00405174(*(unaff_EBX + 0x4f5088), arg_ch_00, unaff_EBX);\n    arg_8h_00 = *(unaff_EBX + 0x4f504c);\n    iVar2 = fcn.00406930(arg_8h_00);\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) + 1;\n    uVar4 = iVar2 + 0x6cfU ^ 0xcf;\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) + 1;\n    *(unaff_EBX + 0x4f52dc) = uVar4;\n    uVar1 = *(unaff_EBX + 0x4f52dc);\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) | uVar4;\n    uVar3 = fcn.00402d9c((uVar1 ^ (extraout_ECX | 1)) - 1, extraout_ECX | 1);\n    *(unaff_EBX + 0x4f52dc) = uVar3;\n    *(unaff_EBX + 0x4f52dc) = *(unaff_EBX + 0x4f52dc) + extraout_ECX_00;\n    return CONCAT44(arg_8h_00, arg_ch_00);\n}\n",
        "token_count": 813
    },
    "0040200a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040200a(uint arg_8h, uint arg_ch)\n\n{\n    uint in_EAX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) + 0x20f;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) | unaff_EDI;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) & 1;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) ^ unaff_EDI;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) ^ 1;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) + 1;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464);\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) + 0x2af;\n    *(unaff_EBX + 0x4f5464) = 0x642;\n    *(unaff_EBX + 0x4f5464) = 0;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464);\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) + -1;\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464);\n    *(unaff_EBX + 0x4f5464) = *(unaff_EBX + 0x4f5464) & 1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 554
    },
    "0040235c": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: arg_8h\n\nulong __cdecl fcn.0040235c(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t in_ECX;\n    int32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (&stack0xfffffffc <= unaff_EDI) {\n        in_EDX = in_EDX + -1;\n        in_ECX = in_ECX - 1;\n    }\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) | unaff_ESI;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) ^ unaff_EDI - 1U;\n    *(unaff_EBX + 0x4f5394) = 1;\n    *(unaff_EBX + 0x4f5394) = 0;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) & in_EDX + 1U;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) & in_ECX;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) + 1;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394);\n    arg_8h_00 = *(unaff_EBX + 0x4f5134);\n    fcn.0040fa15(arg_8h_00);\n    arg_ch_00 = *(unaff_EBX + 0x4f5044);\n    fcn.0040c76e(*(unaff_EBX + 0x4f534c), arg_ch_00, *(unaff_EBX + 0x4f5440));\n    *(unaff_EBX + 0x4f5394) = (unaff_ESI & arg_10h) - in_ECX | (var_4h - in_ECX) - 1;\n    *(unaff_EBX + 0x4f5394) = 0;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) ^ 1;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) + 1;\n    fcn.00407b8c(&stack0xfffffffc);\n    *(unaff_EBX + 0x4f5394) = (extraout_EDX ^ 0xffffffff) - 2;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) + -1;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394) + -1;\n    *(unaff_EBX + 0x4f5394) = *(unaff_EBX + 0x4f5394);\n    return CONCAT44(arg_ch_00, arg_8h_00);\n}\n",
        "token_count": 815
    },
    "004026fd": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004026fd(int32_t arg_8h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar2;\n    uint32_t unaff_EDI;\n    int32_t var_4h;\n    \n    if (in_EAX < 0x2c0b) {\n        in_EAX = in_EAX + 1;\n        uVar2 = 0;\n    }\n    else {\n        unaff_EDI = unaff_EDI + 1;\n        uVar2 = unaff_ESI;\n    }\n    if (0x9ce9 < *(unaff_EBX + 0x4f53b8)) {\n        arg_8h = -1;\n        uVar2 = 0;\n    }\n    arg_8h = in_EAX + 0x2b5 + arg_8h;\n    iVar1 = fcn.0040a6e3(0, *(unaff_EBX + 0x4f5398), arg_8h);\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) + -1;\n    *(unaff_EBX + 0x4f5198) = 0xffffffff;\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8);\n    *(unaff_EBX + 0x4f5198) = *(unaff_EBX + 0x4f5198) + (iVar1 + 1U | var_4h + unaff_EDI | uVar2);\n    *(unaff_EBX + 0x4f5340) = 0;\n    uVar2 = (uVar2 | *(unaff_EBX + 0x4f53b8)) ^ unaff_EDI;\n    *(unaff_EBX + 0x4f5198) = 0;\n    *(unaff_EBX + 0x4f5198) = *(unaff_EBX + 0x4f5198) + 1;\n    *(unaff_EBX + 0x4f5198) = *(unaff_EBX + 0x4f5198) - uVar2;\n    *(unaff_EBX + 0x4f5340) = *(unaff_EBX + 0x4f5340);\n    *(unaff_EBX + 0x4f5198) = 1;\n    *(unaff_EBX + 0x4f5198) = 0xfffffbe0;\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) | 0xf7;\n    iVar1 = uVar2 + extraout_ECX + -0x207;\n    *(unaff_EBX + 0x4f5340) = *(unaff_EBX + 0x4f5340);\n    *(unaff_EBX + 0x4f53b8) = 0;\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) + iVar1;\n    *(unaff_EBX + 0x4f5340) = *(unaff_EBX + 0x4f5340) + -1;\n    *(unaff_EBX + 0x4f5340) = *(unaff_EBX + 0x4f5340);\n    *(unaff_EBX + 0x4f5340) = *(unaff_EBX + 0x4f5340) + 0x570;\n    *(unaff_EBX + 0x4f5340) = *(unaff_EBX + 0x4f5340) + 0xb5;\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) + 1;\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) ^ 0x5aa;\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) & iVar1 - 0x702U;\n    *(unaff_EBX + 0x4f5198) = 0x534;\n    *(unaff_EBX + 0x4f5198) = *(unaff_EBX + 0x4f5198);\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8);\n    *(unaff_EBX + 0x4f53b8) = *(unaff_EBX + 0x4f53b8) + 1;\n    *(unaff_EBX + 0x4f5340) = 0xffffffff;\n    return CONCAT44(arg_8h, unaff_ESI);\n}\n",
        "token_count": 1155
    },
    "00402aaa": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00402aaa(uint arg_8h, int32_t arg_ch)\n\n{\n    uint in_EAX;\n    int32_t in_ECX;\n    uint32_t in_EDX;\n    uint32_t uVar1;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    if (unaff_ESI != *(unaff_EBX + 0x4f519c)) {\n        *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + -1;\n    }\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = 0xfffffe88;\n    uVar1 = in_EDX;\n    if (in_EDX <= arg_ch) {\n        uVar1 = in_EDX | 0x7fd;\n    }\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) | unaff_ESI;\n    *(unaff_EBX + 0x4f519c) = 0;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + in_ECX + 2;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + -1;\n    *(unaff_EBX + 0x4f519c) = uVar1 + 1;\n    *(unaff_EBX + 0x4f519c) = 0x7fe;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + -1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + -1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) ^ 0xfffffa6d;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c) + 1;\n    *(unaff_EBX + 0x4f519c) = 0;\n    *(unaff_EBX + 0x4f519c) = 0xffffffff;\n    *(unaff_EBX + 0x4f519c) = 0x217;\n    *(unaff_EBX + 0x4f519c) = *(unaff_EBX + 0x4f519c);\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 893
    },
    "00402d9c": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00402d9c(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_EDX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_EDI;\n    int32_t iVar1;\n    uint in_stack_ffffffd4;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(unaff_EBX + 0x4f5108) < 0xa68e) {\n        iVar1 = unaff_EDI + in_EDX;\n        fcn.00408f8a(*(unaff_EBX + 0x4f5500));\n        in_stack_ffffffd4 = *(unaff_EBX + 0x4f52ec);\n        fcn.0040822e(*(unaff_EBX + 0x4f5414), *(unaff_EBX + 0x4f5214), in_stack_ffffffd4);\n        in_EDX = extraout_EDX;\n    }\n    else {\n        *(unaff_EBX + 0x4f50f4) = *(unaff_EBX + 0x4f50f4) + in_EDX;\n        iVar1 = unaff_EDI;\n    }\n    if (var_ch + -0x3cab < 0) {\n        *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) & in_EDX + 1U;\n    }\n    *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) + 1;\n    *(unaff_EBX + 0x4f5108) = 0x78f;\n    *(unaff_EBX + 0x4f50f4) = *(unaff_EBX + 0x4f50f4) + -1;\n    *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) + iVar1;\n    *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) + -1;\n    *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) + 1;\n    *(unaff_EBX + 0x4f50f4) = 1;\n    *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) + 1;\n    *(unaff_EBX + 0x4f5108) = *(unaff_EBX + 0x4f5108) + 4;\n    *(unaff_EBX + 0x4f50f4) = *(unaff_EBX + 0x4f50f4) ^ 4;\n    *(unaff_EBX + 0x4f5108) = 1;\n    *(unaff_EBX + 0x4f5108) = 0xffffffff;\n    *(unaff_EBX + 0x4f50f4) = *(unaff_EBX + 0x4f50f4) + -1;\n    return CONCAT44(in_stack_ffffffd4, unaff_EDI);\n}\n",
        "token_count": 751
    },
    "0040313d": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040313d(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t in_EAX;\n    int32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint32_t uVar1;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (var_4h + -0xb2cd < 0) {\n        uVar1 = unaff_EDI ^ 0xfffffc37;\n        unaff_EDI = uVar1;\n    }\n    else {\n        uVar1 = (in_EAX & 0x584) + unaff_EDI;\n    }\n    uVar1 = uVar1 - 1;\n    if ((POPCOUNT(var_8h - 0x2101U & 0xff) & 1U) != 0) {\n        uVar1 = uVar1 ^ unaff_EDI;\n        *(unaff_EBX + 0x4f51b4) = *(unaff_EBX + 0x4f51b4) + -1;\n    }\n    *(unaff_EBX + 0x4f5018) = *(unaff_EBX + 0x4f5018) + uVar1;\n    *(unaff_EBX + 0x4f51b4) = *(unaff_EBX + 0x4f51b4) + -1;\n    *(unaff_EBX + 0x4f5018) = *(unaff_EBX + 0x4f5018) & (unaff_ESI | 0xfffffc2b);\n    *(unaff_EBX + 0x4f54f4) = unaff_ESI | 0xfffffc2b;\n    *(unaff_EBX + 0x4f5018) = *(unaff_EBX + 0x4f5018) + -1;\n    *(unaff_EBX + 0x4f51b4) = *(unaff_EBX + 0x4f51b4) + 0x791;\n    *(unaff_EBX + 0x4f51b4) = *(unaff_EBX + 0x4f51b4) | in_ECX - 1U & 0x45f;\n    *(unaff_EBX + 0x4f54f4) = *(unaff_EBX + 0x4f54f4);\n    *(unaff_EBX + 0x4f5018) = *(unaff_EBX + 0x4f5018) & var_4h - 0x22cU;\n    uVar1 = *(unaff_EBX + 0x4f51b4);\n    *(unaff_EBX + 0x4f5018) = *(unaff_EBX + 0x4f5018) + -0x3d1;\n    *(unaff_EBX + 0x4f51b4) = 0x8d1;\n    *(unaff_EBX + 0x4f54f4) = *(unaff_EBX + 0x4f54f4) + 1;\n    *(unaff_EBX + 0x4f51b4) = *(unaff_EBX + 0x4f51b4) ^ uVar1;\n    *(unaff_EBX + 0x4f51b4) = *(unaff_EBX + 0x4f51b4);\n    *(unaff_EBX + 0x4f54f4) = *(unaff_EBX + 0x4f54f4) + -1;\n    *(unaff_EBX + 0x4f54f4) = *(unaff_EBX + 0x4f54f4) + -1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 876
    },
    "00403457": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nulong __cdecl fcn.00403457(uint arg_8h, uint arg_ch)\n\n{\n    uint in_EAX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint arg_ch_00;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00401ce8(in_EAX, *(unaff_EBX + 0x4f528c), unaff_EBX);\n    arg_ch_00 = *(unaff_EBX + 0x4f52b0);\n    fcn.00405513(*(unaff_EBX + 0x4f5478), arg_ch_00);\n    uVar1 = (unaff_ESI + -0x7e3) - *(unaff_EBX + 0x4f51f8);\n    *(unaff_EBX + 0x4f50f0) = *(unaff_EBX + 0x4f50f0) + uVar1;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) + -1;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) ^ uVar1;\n    *(unaff_EBX + 0x4f51f8) = 0;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) + -1;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) + 1;\n    *(unaff_EBX + 0x4f50f0) = *(unaff_EBX + 0x4f50f0) & 0xfffff81b;\n    *(unaff_EBX + 0x4f50f0) = 0xfffffdf1;\n    *(unaff_EBX + 0x4f50f0) = 0xfffffbda;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) + -1;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) + 1;\n    *(unaff_EBX + 0x4f51f8) = *(unaff_EBX + 0x4f51f8) & 0xfffffe68;\n    iVar2 = unaff_EBX;\n    fcn.0040445b(&stack0xfffffffc, *(unaff_EBX + 0x4f5338), unaff_EBX);\n    *(unaff_EBX + 0x4f50f0) = *(unaff_EBX + 0x4f50f0) + -1;\n    *(unaff_EBX + 0x4f50f0) = 0xffffffff;\n    *(unaff_EBX + 0x4f50f0) = *(unaff_EBX + 0x4f50f0) + -0x555;\n    return CONCAT44(iVar2, arg_ch_00);\n}\n",
        "token_count": 765
    },
    "0040376a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040376a(uint arg_8h, uint arg_ch)\n\n{\n    uint in_ECX;\n    int32_t extraout_ECX;\n    uint32_t uVar1;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    ulong uVar2;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if (var_4h < 0xb725) {\n        var_8h = var_8h + -1;\n    }\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + 1;\n    if (*(unaff_EBX + 0x4f51e4) + -0xe395 < 0) {\n        var_8h = var_8h + -1;\n    }\n    *(unaff_EBX + 0x4f5468) = *(unaff_EBX + 0x4f5468) + 1;\n    *(unaff_EBX + 0x4f5468) = 1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + 0x55e;\n    *(unaff_EBX + 0x4f5468) = *(unaff_EBX + 0x4f5468);\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + -1;\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + -1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + 1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) | -var_8h;\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + 1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) & var_4h - 1;\n    *(unaff_EBX + 0x4f5468) = 0;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + -0x725;\n    *(unaff_EBX + 0x4f5468) = *(unaff_EBX + 0x4f5468) ^ var_4h;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + 1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + -1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4);\n    uVar2 = fcn.0040b9c7(*(unaff_EBX + 0x4f513c));\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + extraout_ECX;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) + 1;\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + uVar2;\n    uVar1 = (uVar2 >> 0x20) - 0xdb2U & 1;\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + uVar1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) | 1;\n    *(unaff_EBX + 0x4f51e4) = 1;\n    *(unaff_EBX + 0x4f5468) = 0xffffffff;\n    *(unaff_EBX + 0x4f5468) = *(unaff_EBX + 0x4f5468) + -1;\n    *(unaff_EBX + 0x4f5468) = *(unaff_EBX + 0x4f5468) + 1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) ^ uVar1;\n    *(unaff_EBX + 0x4f51f4) = *(unaff_EBX + 0x4f51f4) + 1;\n    *(unaff_EBX + 0x4f51e4) = *(unaff_EBX + 0x4f51e4) ^ 0xfffff827;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 1214
    },
    "00403ab9": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00403ab9(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint32_t in_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint unaff_EDI;\n    uint var_4h;\n    \n    if (!SBORROW4(*(unaff_EBX + 0x4f54b8), 0x54a1)) {\n        in_ECX = in_ECX ^ in_EDX;\n    }\n    *(unaff_EBX + 0x4f54b8) = in_ECX;\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) + 1;\n    *(unaff_EBX + 0x4f54b8) = *(unaff_EBX + 0x4f54b8) + 1;\n    *(unaff_EBX + 0x4f5278) = in_ECX;\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) ^ 1;\n    uVar2 = fcn.00401000(*(unaff_EBX + 0x4f502c), *(unaff_EBX + 0x4f51dc));\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) & 1;\n    *(unaff_EBX + 0x4f54b8) = *(unaff_EBX + 0x4f54b8) + -1;\n    *(unaff_EBX + 0x4f5278) = 0xfffff8c9;\n    *(unaff_EBX + 0x4f5278) = 0xffffffff;\n    *(unaff_EBX + 0x4f54b8) = *(unaff_EBX + 0x4f54b8) - (uVar2 & 0x72a ^ 1);\n    uVar1 = *(unaff_EBX + 0x4f5278);\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) + 1;\n    *(unaff_EBX + 0x4f54b8) = 0xffffffff;\n    *(unaff_EBX + 0x4f54b8) = uVar1;\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) | ((uVar2 & 0x72a) + 0x69d ^ 0x254) - 0x4fc;\n    *(unaff_EBX + 0x4f54b8) = *(unaff_EBX + 0x4f54b8) + -1;\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) + -1;\n    *(unaff_EBX + 0x4f54b8) = 0;\n    *(unaff_EBX + 0x4f54b8) = *(unaff_EBX + 0x4f54b8) ^ 0xfffffea4;\n    *(unaff_EBX + 0x4f54b8) = *(unaff_EBX + 0x4f54b8) | 1;\n    *(unaff_EBX + 0x4f5278) = *(unaff_EBX + 0x4f5278) & 1;\n    *(unaff_EBX + 0x4f54b8) = 0x52a;\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 864
    },
    "00403e0f": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00403e0f(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    int32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint var_8h;\n    uint var_4h;\n    \n    if (unaff_EDI - in_ECX < 0) {\n        *(unaff_EBX + 0x4f5020) = *(unaff_EBX + 0x4f5020) - in_EAX;\n    }\n    else {\n        unaff_EDI = unaff_EDI + 1;\n    }\n    if (*(unaff_EBX + 0x4f5020) < 0x7bc7) {\n        *(unaff_EBX + 0x4f5208) = unaff_EDI;\n    }\n    else {\n        *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) & unaff_EDI;\n    }\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) & 0x66e;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) + 1;\n    *(unaff_EBX + 0x4f5020) = *(unaff_EBX + 0x4f5020) + -1;\n    *(unaff_EBX + 0x4f5020) = *(unaff_EBX + 0x4f5020);\n    uVar1 = *(unaff_EBX + 0x4f5208);\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) + -1;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) | 1;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) ^ 1;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) + 1;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) | 0x260;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) & uVar1;\n    *(unaff_EBX + 0x4f5208) = *(unaff_EBX + 0x4f5208) + -1;\n    *(unaff_EBX + 0x4f5020) = *(unaff_EBX + 0x4f5020) + -1;\n    *(unaff_EBX + 0x4f5208) = 0;\n    *(unaff_EBX + 0x4f5020) = *(unaff_EBX + 0x4f5020) + -1;\n    *(unaff_EBX + 0x4f5020) = *(unaff_EBX + 0x4f5020) & 10;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 772
    },
    "00404125": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00404179)\n// WARNING: Variable defined which should be unmapped: arg_8h\n\nulong __cdecl fcn.00404125(uint arg_8h)\n\n{\n    uint32_t in_EAX;\n    int32_t in_ECX;\n    uint32_t uVar1;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (0x4635 < in_EAX) {\n        *(unaff_EBX + 0x4f5270) = *(unaff_EBX + 0x4f5270) | in_EDX;\n        unaff_ESI = unaff_ESI + var_ch;\n    }\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + -1;\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) + 0x791;\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + ((unaff_ESI - unaff_EDI ^ 0xffffffff) - 1);\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) + 1;\n    uVar1 = in_ECX - (unaff_EDI & 0x7b4);\n    *(unaff_EBX + 0x4f5270) = *(unaff_EBX + 0x4f5270) - (uVar1 | (uVar1 ^ 1) - 1 | *(unaff_EBX + 0x4f5270));\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) & 1;\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + -1;\n    *(unaff_EBX + 0x4f545c) = 1;\n    *(unaff_EBX + 0x4f545c) = 0xfffff8dc;\n    *(unaff_EBX + 0x4f5270) = *(unaff_EBX + 0x4f5270) + 0x607;\n    *(unaff_EBX + 0x4f5270) = *(unaff_EBX + 0x4f5270) + ((unaff_EDI & 0x7b4) - 1);\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + 0xcab;\n    *(unaff_EBX + 0x4f50b8) = 0;\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) & 0xfffffffe;\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + -1;\n    *(unaff_EBX + 0x4f5270) = 0xffffffff;\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + -1;\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) & 0xfffffffd;\n    *(unaff_EBX + 0x4f50b8) = *(unaff_EBX + 0x4f50b8) + -1;\n    *(unaff_EBX + 0x4f545c) = *(unaff_EBX + 0x4f545c) + -0x422;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 973
    },
    "004047c6": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: arg_8h\n\nulong __cdecl fcn.004047c6(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t iVar3;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if ((POPCOUNT(in_EAX - 0xf95a & 0xff) & 1U) == 0) {\n        uVar2 = in_EAX ^ 0xfffffba9;\n        iVar3 = -1;\n    }\n    else {\n        uVar2 = in_EAX ^ 0x3b8;\n        iVar3 = unaff_EDI;\n        var_4h = in_EDX;\n    }\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + 1;\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c) + -1;\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + -1;\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c) + 1;\n    uVar1 = *(unaff_EBX + 0x4f5308);\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + 1;\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c) & iVar3 - 1U & unaff_ESI + 1U;\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c) + -0x56d;\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f527c) =\n         *(unaff_EBX + 0x4f527c) & ((in_ECX + -1) - (iVar3 - 1U) ^ (unaff_ESI + 1U) - (uVar2 + var_4h + -1) ^ uVar1);\n    *(unaff_EBX + 0x4f527c) = 0;\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c);\n    uVar2 = fcn.0040f328(*(unaff_EBX + 0x4f51a4));\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c) & uVar2;\n    *(unaff_EBX + 0x4f527c) = 1;\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + -1;\n    *(unaff_EBX + 0x4f5308) = 0xffffffff;\n    *(unaff_EBX + 0x4f5308) = 0xffffffff;\n    *(unaff_EBX + 0x4f527c) = *(unaff_EBX + 0x4f527c) + -1;\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + -1;\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + 1;\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308);\n    *(unaff_EBX + 0x4f5308) = *(unaff_EBX + 0x4f5308) + -1;\n    fcn.0040f328(*(unaff_EBX + 0x4f50ec));\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 1013
    },
    "00404ae9": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00404ae9(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    int32_t in_ECX;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    uint var_4h;\n    \n    if (unaff_EBX != in_EAX) {\n        *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + -1;\n    }\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + in_EDX;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) - in_ECX;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + 1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + in_ECX + -1;\n    *(unaff_EBX + 0x4f5048) = 1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + -0xa3;\n    iVar1 = *(unaff_EBX + 0x4f5048);\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) & (iVar1 + 2U ^ 0xfffffc5b);\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) | 0x2c1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + -1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + -1;\n    *(unaff_EBX + 0x4f5048) = 0xffffffff;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) | (iVar1 - 0xd9U & 1) + 1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048);\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + -1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) - (*(unaff_EBX + 0x4f5048) ^ 0xfffffe2e);\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048);\n    *(unaff_EBX + 0x4f5048) = 0xffffffff;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) ^ 6;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + 1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + -1;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) | 0x7de;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048);\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + 1;\n    *(unaff_EBX + 0x4f5048) = 1;\n    *(unaff_EBX + 0x4f5048) = 0xfffff940;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) | 0xfffffe9c;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5048) = 0xfffff8ee;\n    *(unaff_EBX + 0x4f5048) = *(unaff_EBX + 0x4f5048) + 0x2d5;\n    *(unaff_EBX + 0x4f5048) = 1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 1162
    },
    "00404e60": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00404e60(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    int32_t var_4h;\n    \n    if (var_4h < 0x8d9b) {\n        unaff_EDI = unaff_EDI | 1;\n        in_ECX = in_ECX + 1;\n        uVar2 = in_EAX;\n    }\n    else {\n        uVar2 = 0;\n    }\n    *(unaff_EBX + 0x4f51d8) = *(unaff_EBX + 0x4f51d8) + 1;\n    *(unaff_EBX + 0x4f5508) = *(unaff_EBX + 0x4f5508) | uVar2;\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) - uVar2;\n    *(unaff_EBX + 0x4f54c0) = 0xffffffff;\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) + 0x7dd;\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) + 1;\n    *(unaff_EBX + 0x4f54c0) = 1;\n    *(unaff_EBX + 0x4f51d8) = unaff_EDI - 1;\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) + 1;\n    uVar2 = *(unaff_EBX + 0x4f5508);\n    *(unaff_EBX + 0x4f5508) = *(unaff_EBX + 0x4f5508) + -1;\n    uVar1 = *(unaff_EBX + 0x4f54c0);\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) + -1;\n    *(unaff_EBX + 0x4f51d8) = *(unaff_EBX + 0x4f51d8) + 0x555;\n    *(unaff_EBX + 0x4f51d8) = *(unaff_EBX + 0x4f51d8) + 1;\n    *(unaff_EBX + 0x4f54c0) =\n         *(unaff_EBX + 0x4f54c0) &\n         ((unaff_EDI + ((in_ECX + 1U ^ 1) - 1 | uVar2) + 0x30d) - *(unaff_EBX + 0x4f5508)) - (unaff_EDI - 6 ^ uVar1);\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) + 1;\n    *(unaff_EBX + 0x4f54c0) = 0;\n    *(unaff_EBX + 0x4f54c0) = *(unaff_EBX + 0x4f54c0) | 1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 825
    },
    "00405174": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00405174(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t in_ECX;\n    uint32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint32_t in_EDX;\n    uint32_t uVar1;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint in_stack_ffffffd4;\n    uint in_stack_ffffffdc;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    if (var_4h == 0xa03a) {\n        *(unaff_EBX + 0x4f51a0) = *(unaff_EBX + 0x4f51a0) ^ 0xffffffe7;\n        in_stack_ffffffdc = *(unaff_EBX + 0x4f50c8);\n        in_stack_ffffffd4 = *(unaff_EBX + 0x4f5288);\n        fcn.00411727(in_stack_ffffffd4, in_EDX | var_8h, in_stack_ffffffdc);\n        in_ECX = extraout_ECX;\n    }\n    else {\n        unaff_EDI = unaff_EDI ^ in_ECX;\n        *(unaff_EBX + 0x4f550c) = 0xfffff9eb;\n    }\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + 0x357;\n    if (var_8h == 0x4087) {\n        *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + 1;\n    }\n    *(unaff_EBX + 0x4f51a0) = *(unaff_EBX + 0x4f51a0) + 1;\n    *(unaff_EBX + 0x4f51a0) = *(unaff_EBX + 0x4f51a0) + 1;\n    fcn.0040a35a(&stack0xffffffd0, *(unaff_EBX + 0x4f51ec));\n    *(unaff_EBX + 0x4f550c) = *(unaff_EBX + 0x4f550c) + 1;\n    *(unaff_EBX + 0x4f5310) = 0xfffffe44;\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + 1;\n    *(unaff_EBX + 0x4f550c) = *(unaff_EBX + 0x4f550c) ^ 0xffffffff;\n    uVar1 = (((unaff_EDI + 1 | 0x7ec) - in_ECX) + 1 & 0x585) - 1 ^ var_4h + 0x752U;\n    *(unaff_EBX + 0x4f51a0) = uVar1;\n    *(unaff_EBX + 0x4f51a0) = 0xffffffff;\n    *(unaff_EBX + 0x4f550c) = *(unaff_EBX + 0x4f550c) + -1;\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + 1;\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) - uVar1;\n    *(unaff_EBX + 0x4f550c) = *(unaff_EBX + 0x4f550c);\n    *(unaff_EBX + 0x4f550c) = *(unaff_EBX + 0x4f550c) + 0x113;\n    *(unaff_EBX + 0x4f550c) = *(unaff_EBX + 0x4f550c);\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + -1;\n    *(unaff_EBX + 0x4f51a0) = *(unaff_EBX + 0x4f51a0) & extraout_ECX_00 + 3U;\n    *(unaff_EBX + 0x4f51a0) = 1;\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + 1;\n    *(unaff_EBX + 0x4f5310) = *(unaff_EBX + 0x4f5310) + 1;\n    *(unaff_EBX + 0x4f51a0) = *(unaff_EBX + 0x4f51a0) + 1;\n    return CONCAT44(in_stack_ffffffd4, in_stack_ffffffdc);\n}\n",
        "token_count": 1131
    },
    "00405513": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00405513(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint in_EDX;\n    uint extraout_EDX;\n    uint32_t uVar2;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint32_t uVar3;\n    ulong uVar4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (0x4a24 < arg_ch) {\n        *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) & 0xfffffa72;\n    }\n    *(unaff_EBX + 0x4f5128) = 1;\n    uVar3 = unaff_EDI ^ var_4h;\n    if (arg_ch - 0x8338 < 0) {\n        arg_8h = arg_8h ^ 0xffffffff;\n    }\n    else {\n        arg_8h = 0xffffffff;\n    }\n    *(unaff_EBX + 0x4f5240) = *(unaff_EBX + 0x4f5240) + 1;\n    fcn.004047c6(*(unaff_EBX + 0x4f5038));\n    *(unaff_EBX + 0x4f5240) = extraout_EDX;\n    *(unaff_EBX + 0x4f5240) = *(unaff_EBX + 0x4f5240) ^ unaff_ESI;\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) + -0x3a6;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) - extraout_ECX;\n    uVar4 = fcn.004047c6(*(unaff_EBX + 0x4f51c8));\n    uVar2 = uVar4 >> 0x20;\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) ^ uVar2;\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) & uVar4;\n    *(unaff_EBX + 0x4f5240) = unaff_ESI | 1;\n    uVar2 = uVar2 - 1;\n    *(unaff_EBX + 0x4f5128) = 0x6b2;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) | uVar2;\n    *(unaff_EBX + 0x4f5240) = 0;\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) + -1;\n    iVar1 = *(unaff_EBX + 0x4f5008);\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) + -1;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) ^ 1;\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) + uVar3;\n    *(unaff_EBX + 0x4f5240) = *(unaff_EBX + 0x4f5240) + -1;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) & 0x735;\n    uVar3 = ((((arg_8h - 1) - (unaff_ESI | 1) | 0xfffffffe) & 0xfffff8b2) - 1) - (arg_ch | 0x3cc);\n    *(unaff_EBX + 0x4f5008) = uVar3;\n    *(unaff_EBX + 0x4f5240) = 1;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) & ((extraout_ECX_00 + 1) - iVar1 ^ 1U);\n    *(unaff_EBX + 0x4f5128) = 1;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) - (-1 - ((uVar2 & 0xfffffc53) - 1));\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) + -0x465;\n    *(unaff_EBX + 0x4f5008) = *(unaff_EBX + 0x4f5008) & ((uVar3 & 3) + 1 & 1) + 0x72f;\n    *(unaff_EBX + 0x4f5128) = *(unaff_EBX + 0x4f5128) + 1;\n    *(unaff_EBX + 0x4f5240) = 0xfffffdbb;\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 1271
    },
    "0040584c": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040584c(uint32_t arg_8h)\n\n{\n    uint32_t in_EAX;\n    int32_t extraout_ECX;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    uint32_t uVar1;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar2;\n    uint32_t unaff_EDI;\n    uint arg_10h;\n    uint arg_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (in_EAX <= &stack0xfffffffc) {\n        unaff_ESI = arg_8h;\n        unaff_EDI = in_EAX;\n    }\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) & 1;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c);\n    uVar2 = unaff_ESI - 1;\n    *(unaff_EBX + 0x4f53f0) = 0xffffffff;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) | in_EDX;\n    *(unaff_EBX + 0x4f53f0) = uVar2;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) + 1;\n    arg_ch = *(unaff_EBX + 0x4f5318);\n    fcn.00405513(&stack0xfffffffc, arg_ch);\n    uVar1 = extraout_EDX ^ unaff_EDI ^ in_EDX;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) - (extraout_ECX + -1);\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) ^ uVar1;\n    *(unaff_EBX + 0x4f533c) = 0xfffffb2a;\n    *(unaff_EBX + 0x4f533c) = 0x6f5;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) + 1;\n    uVar1 = uVar2 & 0x6f5 & uVar1 & 0xc45;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) + 0x68c;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) + 1;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) | 1;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) + -1;\n    uVar2 = (((arg_8h ^ uVar2) - 1 ^ 0xffffffff) & 1) + 1 | 0xa75;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) - uVar1;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) & uVar2;\n    *(unaff_EBX + 0x4f53f0) = 0;\n    arg_10h = *(unaff_EBX + 0x4f5118);\n    fcn.0040a02c(*(unaff_EBX + 0x4f5290), *(unaff_EBX + 0x4f509c), arg_10h);\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) ^ uVar2;\n    uVar1 = uVar1 - 2;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0);\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) + 0x335;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) ^ uVar1;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) & uVar1;\n    *(unaff_EBX + 0x4f533c) = *(unaff_EBX + 0x4f533c) + 1;\n    *(unaff_EBX + 0x4f53f0) = *(unaff_EBX + 0x4f53f0) + 1;\n    return CONCAT44(arg_10h, arg_ch);\n}\n",
        "token_count": 1191
    },
    "00405b77": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00405b77(uint arg_8h, uint arg_ch)\n\n{\n    int32_t extraout_EDX;\n    uint32_t arg_ch_00;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint arg_10h;\n    uint arg_ch_01;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(unaff_EBX + 0x4f548c) == 0xb2ec) {\n        unaff_EDI = 0xffffffff;\n    }\n    else {\n        fcn.00402d9c(*(unaff_EBX + 0x4f54e0), *(unaff_EBX + 0x4f537c));\n    }\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) | unaff_EDI;\n    *(unaff_EBX + 0x4f548c) = *(unaff_EBX + 0x4f548c) + 1;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) + 1;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc);\n    *(unaff_EBX + 0x4f548c) = 0x59e;\n    *(unaff_EBX + 0x4f548c) = 0xffffffff;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) | 0x200;\n    *(unaff_EBX + 0x4f548c) = 0xffffffff;\n    *(unaff_EBX + 0x4f548c) = *(unaff_EBX + 0x4f548c) + -1;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) ^ 0xfffffabe;\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268) & 1;\n    *(unaff_EBX + 0x4f548c) = *(unaff_EBX + 0x4f548c) + 1;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) + -1;\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268) | 0x47a;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) + -1;\n    *(unaff_EBX + 0x4f5268) = 0xfffff87d;\n    *(unaff_EBX + 0x4f51bc) = 0xfffffc2a;\n    arg_ch_01 = *(unaff_EBX + 0x4f5454);\n    fcn.0040ca73(*(unaff_EBX + 0x4f51e0), arg_ch_01);\n    *(unaff_EBX + 0x4f548c) = 0xfffff8fe;\n    arg_ch_00 = (extraout_EDX + 0x4c4) - *(unaff_EBX + 0x4f51bc);\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268);\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268) ^ arg_ch_00;\n    *(unaff_EBX + 0x4f5268) = 0xffffffff;\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268) + -1;\n    *(unaff_EBX + 0x4f51bc) = *(unaff_EBX + 0x4f51bc) + -1;\n    *(unaff_EBX + 0x4f548c) = 0x786;\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268) | 1;\n    *(unaff_EBX + 0x4f5268) = *(unaff_EBX + 0x4f5268) + 1;\n    arg_10h = *(unaff_EBX + 0x4f5520);\n    fcn.0040c483(*(unaff_EBX + 0x4f5300), arg_ch_00, arg_10h);\n    return CONCAT44(arg_10h, arg_ch_01);\n}\n",
        "token_count": 1103
    },
    "00405f43": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00405f43(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t in_EAX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t iVar1;\n    uint arg_10h_00;\n    uint var_8h;\n    uint var_4h;\n    \n    if (in_EAX < 0x83f) {\n        iVar1 = 0;\n        in_EDX = in_EDX + 1;\n    }\n    else {\n        *(unaff_EBX + 0x4f515c) = 0xffffffff;\n        in_EAX = in_EAX ^ 0xffffffff;\n        iVar1 = unaff_ESI;\n    }\n    *(unaff_EBX + 0x4f515c) = in_EAX;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) | in_EDX;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + 1;\n    *(unaff_EBX + 0x4f515c) = iVar1 + 1;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + -1;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + 1;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c);\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + -1;\n    iVar1 = *(unaff_EBX + 0x4f515c);\n    *(unaff_EBX + 0x4f515c) = 0xfffff881;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) - iVar1;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + 0x6cc;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + 3;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c) + -1;\n    *(unaff_EBX + 0x4f515c) = 0x509;\n    *(unaff_EBX + 0x4f515c) = *(unaff_EBX + 0x4f515c);\n    arg_10h_00 = *(unaff_EBX + 0x4f5370);\n    fcn.00403ab9(0xd3, *(unaff_EBX + 0x4f52a4), arg_10h_00);\n    return CONCAT44(arg_10h_00, unaff_ESI);\n}\n",
        "token_count": 722
    },
    "004065e0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: arg_8h\n\nulong __cdecl fcn.004065e0(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint32_t unaff_EDI;\n    uint32_t in_stack_ffffffd8;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (!SBORROW4(in_EAX, 0xdc35)) {\n        in_stack_ffffffd8 = in_EDX ^ 1;\n        fcn.0040bfe5(*(unaff_EBX + 0x4f52a8), &stack0xffffffd8, in_stack_ffffffd8);\n        in_EDX = extraout_EDX;\n    }\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + -1;\n    *(unaff_EBX + 0x4f53bc) = in_EDX;\n    uVar1 = ((unaff_EDI ^ 0xffffffff | 1099) ^ unaff_EDI) + 1;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc);\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + 1;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) | (uVar1 ^ 0x285) + 0x234;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc);\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) & uVar1 + (arg_ch & in_EDX);\n    *(unaff_EBX + 0x4f53bc) = 0xffffffff;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + 1;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc);\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + (arg_ch & in_EDX & 1);\n    *(unaff_EBX + 0x4f53bc) = 0;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + 1;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc);\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + 1;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + -5;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc);\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) ^ 1;\n    *(unaff_EBX + 0x4f53bc) = *(unaff_EBX + 0x4f53bc) + 1;\n    return CONCAT44(in_stack_ffffffd8, unaff_ESI);\n}\n",
        "token_count": 940
    },
    "00406930": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00406930(uint arg_8h)\n\n{\n    uint32_t in_EAX;\n    uint uVar1;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint arg_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((POPCOUNT(in_EAX - 0xdc0c & 0xff) & 1U) != 0) {\n        unaff_EDI = unaff_EDI & in_EAX;\n    }\n    if (SBORROW4(in_EDX, &stack0xfffffffc)) {\n        fcn.0040e789(*(unaff_EBX + 0x4f53ac));\n        *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) + -1;\n        in_EDX = extraout_EDX;\n    }\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) - in_EDX;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) & in_EDX;\n    *(unaff_EBX + 0x4f549c) = 1;\n    *(unaff_EBX + 0x4f549c) = 0;\n    *(unaff_EBX + 0x4f549c) = 1;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) ^ unaff_EDI;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) & 1;\n    *(unaff_EBX + 0x4f549c) = 0xffffffff;\n    uVar1 = 1;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) ^ (unaff_EDI - 1 | unaff_EDI) + 1;\n    fcn.0040376a(*(unaff_EBX + 0x4f5244), 1);\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) + -1;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) + 1;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c);\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c);\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) ^ 1;\n    arg_10h = *(unaff_EBX + 0x4f5498);\n    fcn.00409991(*(unaff_EBX + 0x4f52bc), *(unaff_EBX + 0x4f52f8), arg_10h);\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c);\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) + 1;\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c);\n    *(unaff_EBX + 0x4f549c) = *(unaff_EBX + 0x4f549c) + 1;\n    return CONCAT44(arg_10h, uVar1);\n}\n",
        "token_count": 890
    },
    "00406ecf": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00406ecf(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    uint32_t in_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    if (!SBORROW4(in_EAX, 0x7611)) {\n        *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) - unaff_ESI;\n    }\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -1;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) | in_ECX;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -1;\n    *(unaff_EBX + 0x4f54b0) = 0xffffffff;\n    *(unaff_EBX + 0x4f54b0) = 0;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) ^ 0x626;\n    *(unaff_EBX + 0x4f54b0) = 0xffffffff;\n    uVar1 = *(unaff_EBX + 0x4f54b0);\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + 1;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) - ((unaff_ESI + 2U | 0x5ff) & uVar1);\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + 1;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0);\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -0x51d;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -1;\n    *(unaff_EBX + 0x4f54b0) = 0xffffffff;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + 1;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -1;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0);\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -1;\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) ^ 0xfffffbcd;\n    fcn.0040f328(*(unaff_EBX + 0x4f5274));\n    *(unaff_EBX + 0x4f54b0) = *(unaff_EBX + 0x4f54b0) + -1;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 904
    },
    "00407201": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00407201(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint32_t in_ECX;\n    uint in_EDX;\n    uint32_t unaff_EBX;\n    int32_t unaff_EDI;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = in_EAX;\n    if (arg_8h <= unaff_EBX) {\n        iVar2 = in_EAX + -1;\n    }\n    uVar1 = *(unaff_EBX + 0x4f53d8);\n    *(unaff_EBX + 0x4f50a0) = 1;\n    *(unaff_EBX + 0x4f53d8) = *(unaff_EBX + 0x4f53d8) - (unaff_EDI + -1);\n    *(unaff_EBX + 0x4f53d8) = *(unaff_EBX + 0x4f53d8) + 1;\n    *(unaff_EBX + 0x4f53d8) = *(unaff_EBX + 0x4f53d8) + -1;\n    *(unaff_EBX + 0x4f5090) = *(unaff_EBX + 0x4f5090);\n    *(unaff_EBX + 0x4f53d8) = *(unaff_EBX + 0x4f53d8) & (iVar2 + 0x53U ^ 1) - 0x33b & in_ECX & uVar1;\n    *(unaff_EBX + 0x4f53d8) = *(unaff_EBX + 0x4f53d8) + -1;\n    *(unaff_EBX + 0x4f50a0) = *(unaff_EBX + 0x4f50a0) & (unaff_EDI + -1) * 2 + 1U;\n    *(unaff_EBX + 0x4f53d8) = 1;\n    *(unaff_EBX + 0x4f5090) = *(unaff_EBX + 0x4f5090) | 1;\n    *(unaff_EBX + 0x4f53d8) = *(unaff_EBX + 0x4f53d8) + -1;\n    *(unaff_EBX + 0x4f53d8) = 0x532;\n    *(unaff_EBX + 0x4f50a0) = *(unaff_EBX + 0x4f50a0) ^ 0x2f4;\n    *(unaff_EBX + 0x4f5090) = *(unaff_EBX + 0x4f5090) + -1;\n    *(unaff_EBX + 0x4f50a0) = *(unaff_EBX + 0x4f50a0) + -1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 699
    },
    "00407519": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00407519(uint arg_8h, int32_t arg_ch)\n\n{\n    uint32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint32_t uVar2;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = in_EAX;\n    if (arg_ch < 0x373e) {\n        *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) ^ unaff_EDI;\n        uVar1 = in_EAX - 1;\n    }\n    if (*(unaff_EBX + 0x4f5200) < 0x3678) {\n        uVar1 = uVar1 & 1;\n        unaff_EDI = unaff_EDI ^ 0xffffffff;\n    }\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200);\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + -1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) | in_EDX ^ 1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) ^ in_EDX ^ 1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + 0x27a;\n    uVar2 = unaff_EDI - 1 & 0xfffffc22;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + 1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + -1;\n    *(unaff_EBX + 0x4f5200) = 0;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + -1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + 1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200);\n    *(unaff_EBX + 0x4f5200) = 0xffffffff;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) & 0x5c8;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + 1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + -1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) - ((uVar2 + 1 & 0xf1 | (uVar1 - 1 ^ 0x230) & uVar2) ^ 0xfffffa25);\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200) + 1;\n    *(unaff_EBX + 0x4f5200) = *(unaff_EBX + 0x4f5200);\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 906
    },
    "0040783f": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040783f(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    uint unaff_EDI;\n    uint arg_8h_00;\n    uint var_8h;\n    uint var_4h;\n    \n    if (in_ECX != arg_8h) {\n        *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + -1;\n    }\n    if (SBORROW4(in_EAX, 0x8d86)) {\n        uVar2 = in_EAX - (in_EDX + 0x46a);\n    }\n    else {\n        uVar2 = in_EAX ^ 0xfffffff2;\n    }\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) + 1;\n    *(unaff_EBX + 0x4f5384) = uVar2;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + -1;\n    arg_8h_00 = *(unaff_EBX + 0x4f52e0);\n    fcn.0040f02d(arg_8h_00, *(unaff_EBX + 0x4f5524));\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154);\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154);\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) + 1;\n    *(unaff_EBX + 0x4f5154) = 0;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + 1;\n    *(unaff_EBX + 0x4f5384) = 0xffffffff;\n    uVar2 = fcn.0040fd4a(&stack0xfffffffc, *(unaff_EBX + 0x4f52d0));\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) | uVar2;\n    *(unaff_EBX + 0x4f5384) = 0x588;\n    *(unaff_EBX + 0x4f5154) = 1;\n    iVar1 = *(unaff_EBX + 0x4f5384);\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + 1;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) ^ 0xfffffd9a;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384);\n    *(unaff_EBX + 0x4f5384) = 0xfffffa78;\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) & 0xfffffffe;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + 1;\n    *(unaff_EBX + 0x4f5384) =\n         *(unaff_EBX + 0x4f5384) +\n         ((((((uVar2 - 0x36a & 1) - iVar1) + 1 & 0xfffffe3a) - 0x77 & 0xfffffc42) + 199 & 0x382) - 0x1f8);\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + -1;\n    *(unaff_EBX + 0x4f5384) = 0xffffffff;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) ^ 0xfffffffe;\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) + -2;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) + -1;\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) + 1;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384) ^ 1;\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) + -1;\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154) & 0xfffffc33;\n    *(unaff_EBX + 0x4f5384) = *(unaff_EBX + 0x4f5384);\n    *(unaff_EBX + 0x4f5154) = *(unaff_EBX + 0x4f5154);\n    return CONCAT44(arg_8h_00, unaff_EDI);\n}\n",
        "token_count": 1304
    },
    "00407efd": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00407efd(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t in_EAX;\n    int32_t in_ECX;\n    uint32_t uVar1;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint32_t var_4h;\n    \n    uVar1 = in_EAX;\n    if (!SBORROW4(*(unaff_EBX + 0x4f53ec), 0xd734)) {\n        uVar1 = in_EAX + 0x29;\n    }\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + -0x4c9;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) & unaff_EDI;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + -1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + 1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) & (uVar1 & var_4h) - 0x369;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) ^ (in_ECX - var_4h) - 1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + -1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec);\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) & (unaff_EDI - 2 ^ 0x5ea);\n    uVar1 = 0x5ea - *(unaff_EBX + 0x4f53ec);\n    *(unaff_EBX + 0x4f53ec) = 0xffffffff;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec);\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) & uVar1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec);\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) ^ 0x10d;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + -1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + uVar1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + 1;\n    *(unaff_EBX + 0x4f53ec) = 0xfffff92b;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + 1;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) | 0xbe6;\n    *(unaff_EBX + 0x4f53ec) = 0x6a;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + -1;\n    *(unaff_EBX + 0x4f53ec) = 0xffffffff;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + 2;\n    *(unaff_EBX + 0x4f53ec) = *(unaff_EBX + 0x4f53ec) + -1;\n    *(unaff_EBX + 0x4f53ec) = 0;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 1024
    },
    "0040822e": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040822e(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    uint32_t extraout_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t uVar2;\n    uint32_t unaff_EDI;\n    uint32_t uVar3;\n    uint arg_ch_00;\n    int32_t iVar4;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (in_EAX < 0x8866) {\n        *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) & unaff_EDI;\n    }\n    if (-1 < arg_ch + -0x7d56) {\n        *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) ^ 1;\n        *(unaff_EBX + 0x4f50cc) = 0xffffffff;\n    }\n    *(unaff_EBX + 0x4f5138) = 0x511;\n    *(unaff_EBX + 0x4f5138) = 0xffffffff;\n    arg_ch_00 = *(unaff_EBX + 0x4f53cc);\n    iVar4 = unaff_ESI;\n    fcn.00405513(unaff_EBX, arg_ch_00);\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc);\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) | unaff_ESI - 1U;\n    iVar1 = *(unaff_EBX + 0x4f5138);\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) | 1;\n    uVar3 = unaff_ESI - 2;\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) ^ uVar3;\n    uVar2 = iVar1 - (extraout_ECX | 1);\n    iVar1 = *(unaff_EBX + 0x4f50cc);\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) | uVar3;\n    uVar3 = uVar3 ^ uVar2;\n    *(unaff_EBX + 0x4f5138) = 0xffffffff;\n    *(unaff_EBX + 0x4f5138) = 0;\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) ^ uVar3;\n    uVar2 = uVar2 ^ *(unaff_EBX + 0x4f50cc);\n    *(unaff_EBX + 0x4f50cc) = uVar3;\n    fcn.0040b9c7(*(unaff_EBX + 0x4f5404));\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) & (uVar3 ^ (extraout_ECX | 1) & iVar1 - 1U ^ 0xfffff8bc) - uVar2;\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) + uVar2;\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) + -1;\n    iVar1 = *(unaff_EBX + 0x4f5138);\n    *(unaff_EBX + 0x4f5138) = 0;\n    uVar2 = *(unaff_EBX + 0x4f5138);\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) | 0x4d4;\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) + 1;\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) ^ uVar2;\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) + -1;\n    *(unaff_EBX + 0x4f50cc) = 0xffffffff;\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc);\n    *(unaff_EBX + 0x4f50cc) = *(unaff_EBX + 0x4f50cc) + 1;\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) ^ (iVar1 + 2U & 0x5fd) + 1;\n    *(unaff_EBX + 0x4f5138) = *(unaff_EBX + 0x4f5138) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5138) = 0xffffffff;\n    return CONCAT44(arg_ch_00, iVar4);\n}\n",
        "token_count": 1268
    },
    "004088a5": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004088a5(uint arg_8h)\n\n{\n    uint32_t in_EAX;\n    uint32_t extraout_ECX;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint32_t uVar1;\n    uint arg_10h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (0xec32 < var_4h) {\n        in_EAX = in_EAX ^ 1;\n        *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) + 1;\n    }\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) + 1;\n    uVar1 = (unaff_EDI - 0x379U & var_4h) - 0x48c | unaff_ESI + 0x168U;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) & in_EAX + 0xfc1;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) + uVar1;\n    *(unaff_EBX + 0x4f5430) = *(unaff_EBX + 0x4f5430) + uVar1;\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) + 1;\n    *(unaff_EBX + 0x4f5430) = 0xffffffff;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) | 1;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) & 0xfffffead;\n    uVar1 = in_EDX + in_EAX + 0x141d & 0x6f8;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) & uVar1;\n    *(unaff_EBX + 0x4f50d0) = 0;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) | 1;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) + -1;\n    *(unaff_EBX + 0x4f5430) = *(unaff_EBX + 0x4f5430);\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) ^ (uVar1 | 1);\n    arg_10h = *(unaff_EBX + 0x4f530c);\n    fcn.0040e470(*(unaff_EBX + 0x4f5028), *(unaff_EBX + 0x4f5360), arg_10h);\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) + 1;\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) + -1;\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) ^ extraout_ECX;\n    *(unaff_EBX + 0x4f5430) = *(unaff_EBX + 0x4f5430) | 1;\n    *(unaff_EBX + 0x4f50d0) = *(unaff_EBX + 0x4f50d0) + -1;\n    *(unaff_EBX + 0x4f5430) = *(unaff_EBX + 0x4f5430) - (extraout_ECX + 1);\n    *(unaff_EBX + 0x4f5430) = 1;\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) | 0xfffffffd;\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5060) = *(unaff_EBX + 0x4f5060) + -1;\n    return CONCAT44(arg_10h, unaff_ESI);\n}\n",
        "token_count": 1122
    },
    "00408c30": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00408c30(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t extraout_EDX;\n    uint32_t unaff_EBX;\n    uint arg_10h;\n    uint arg_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h < unaff_EBX) {\n        *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + -1;\n    }\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8);\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + in_ECX + 1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8);\n    fcn.0040b345(*(unaff_EBX + 0x4f516c), *(unaff_EBX + 0x4f51e8), *(unaff_EBX + 0x4f535c));\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + -1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + 1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) - extraout_EDX;\n    uVar1 = *(unaff_EBX + 0x4f52d8);\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) | uVar1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + -1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8);\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8);\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + -1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + 1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) | uVar1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) | 1;\n    arg_ch = *(unaff_EBX + 0x4f5054);\n    fcn.0040a6e3(*(unaff_EBX + 0x4f5080), arg_ch, *(unaff_EBX + 0x4f5444));\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) - (uVar1 + 2);\n    *(unaff_EBX + 0x4f52d8) = 0xffffffff;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + -1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + -1;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) & 0xfffffffe;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) | 0x403;\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + 1;\n    arg_10h = *(unaff_EBX + 0x4f5470);\n    fcn.0040235c(*(unaff_EBX + 0x4f5344), *(unaff_EBX + 0x4f51b0), arg_10h);\n    *(unaff_EBX + 0x4f52d8) = *(unaff_EBX + 0x4f52d8) + 1;\n    *(unaff_EBX + 0x4f52d8) = 0xffffffff;\n    return CONCAT44(arg_10h, arg_ch);\n}\n",
        "token_count": 1137
    },
    "00408f8a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00408f8a(uint arg_8h)\n\n{\n    uint in_ECX;\n    int32_t extraout_ECX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    fcn.00404ae9(*(unaff_EBX + 0x4f5188));\n    *(unaff_EBX + 0x4f51ac) = *(unaff_EBX + 0x4f51ac) + -1;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210);\n    *(unaff_EBX + 0x4f5210) = 1;\n    *(unaff_EBX + 0x4f51ac) = *(unaff_EBX + 0x4f51ac) + -1;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210) + 1;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210) - ((extraout_ECX + extraout_EDX & 1U & var_8h) - 1);\n    *(unaff_EBX + 0x4f51ac) = *(unaff_EBX + 0x4f51ac) + 1;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210) + 1;\n    *(unaff_EBX + 0x4f51ac) = 1;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210) & 0xffffffb3;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210);\n    *(unaff_EBX + 0x4f5210) = 0;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210);\n    *(unaff_EBX + 0x4f51ac) = *(unaff_EBX + 0x4f51ac) + 1;\n    *(unaff_EBX + 0x4f51ac) = 0;\n    *(unaff_EBX + 0x4f5210) = *(unaff_EBX + 0x4f5210) + 1;\n    *(unaff_EBX + 0x4f51ac) = 1;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 627
    },
    "00409272": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00409272(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t in_EAX;\n    int32_t in_ECX;\n    uint32_t extraout_ECX;\n    uint32_t uVar3;\n    int32_t in_EDX;\n    uint32_t extraout_EDX;\n    uint32_t uVar4;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(unaff_EBX + 0x4f525c) < in_EAX) {\n        unaff_ESI = unaff_ESI + 1;\n    }\n    else {\n        *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + -1;\n    }\n    if (SBORROW4(in_EDX, unaff_ESI + -1)) {\n        *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) & 1;\n    }\n    else {\n        *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) ^ 0xffffffff;\n    }\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + 0x43f;\n    iVar5 = unaff_EDI + *(unaff_EBX + 0x4f52cc);\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc) + 1;\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + 1;\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c);\n    uVar1 = *(unaff_EBX + 0x4f52cc);\n    *(unaff_EBX + 0x4f52cc) = 0;\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc);\n    fcn.00404e60(unaff_EBX, *(unaff_EBX + 0x4f54c4));\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc) - (iVar5 + 0x63b);\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) | extraout_ECX;\n    *(unaff_EBX + 0x4f525c) = 0;\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc) + -1;\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc) + -1;\n    uVar4 = ((extraout_EDX | 0xfffffffe) + 1) - *(unaff_EBX + 0x4f525c);\n    *(unaff_EBX + 0x4f525c) = 0x15a;\n    uVar1 = (in_ECX - 1U ^ uVar1) - 1 | uVar4;\n    uVar3 = uVar1 ^ 0xffffffff;\n    *(unaff_EBX + 0x4f52cc) = 1;\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc) ^ 0xfffffecb;\n    *(unaff_EBX + 0x4f52cc) = 0xfffffee4;\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc);\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) & uVar4;\n    uVar2 = *(unaff_EBX + 0x4f525c);\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + 1;\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + (uVar3 - 1);\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + 1;\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + 1;\n    *(unaff_EBX + 0x4f52cc) = *(unaff_EBX + 0x4f52cc) + (((uVar1 ^ uVar4 ^ uVar2) & 1) - uVar3);\n    *(unaff_EBX + 0x4f525c) = *(unaff_EBX + 0x4f525c) + 1;\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 1241
    },
    "0040965c": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040965c(uint arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    uint arg_10h;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) + -1;\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) + -1;\n    *(unaff_EBX + 0x4f50b0) = 0xffffffff;\n    uVar1 = *(unaff_EBX + 0x4f50b0);\n    *(unaff_EBX + 0x4f505c) = 0xfffff9bd;\n    *(unaff_EBX + 0x4f505c) = *(unaff_EBX + 0x4f505c) + 1;\n    *(unaff_EBX + 0x4f505c) = *(unaff_EBX + 0x4f505c) + -1;\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) | 1;\n    arg_10h = *(unaff_EBX + 0x4f5074);\n    fcn.0040857b(*(unaff_EBX + 0x4f54ac), *(unaff_EBX + 0x4f5150), arg_10h);\n    *(unaff_EBX + 0x4f50b0) = 0x4eb;\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) + -1;\n    *(unaff_EBX + 0x4f50b0) =\n         *(unaff_EBX + 0x4f50b0) &\n         ((unaff_EDI + 1U | uVar1 | 1) + 1 | (arg_ch + 1U | unaff_EDI + 1U | 0x52a) & 0x623) - 1;\n    *(unaff_EBX + 0x4f505c) = 0xffffffff;\n    *(unaff_EBX + 0x4f505c) = *(unaff_EBX + 0x4f505c) + -1;\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) + -1;\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0);\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) + -1;\n    *(unaff_EBX + 0x4f50b0) = *(unaff_EBX + 0x4f50b0) + -0x542;\n    *(unaff_EBX + 0x4f505c) = *(unaff_EBX + 0x4f505c) + 1;\n    *(unaff_EBX + 0x4f505c) = *(unaff_EBX + 0x4f505c) | 1;\n    *(unaff_EBX + 0x4f505c) = *(unaff_EBX + 0x4f505c) + 1;\n    return CONCAT44(arg_10h, unaff_ESI);\n}\n",
        "token_count": 834
    },
    "00409991": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00409991(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint32_t in_ECX;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint arg_10h_00;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) ^ 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) | 0xfffffb09;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0);\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0);\n    *(unaff_EBX + 0x4f54f0) = 0x2dc;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) & in_ECX & 0xfffff86a;\n    *(unaff_EBX + 0x4f54f0) = 0xffffffff;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + 0x48f;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -2;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -0x2c4;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0);\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) & 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) & 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) & 0xfffff82d;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + 1;\n    arg_10h_00 = *(unaff_EBX + 0x4f50f8);\n    fcn.0040eaba(*(unaff_EBX + 0x4f52f4), 0, arg_10h_00);\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + -1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0);\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) & extraout_ECX - 2U;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0) + 1;\n    *(unaff_EBX + 0x4f54f0) = *(unaff_EBX + 0x4f54f0);\n    *(unaff_EBX + 0x4f54f0) = 0;\n    return CONCAT44(arg_10h_00, unaff_ESI);\n}\n",
        "token_count": 1124
    },
    "00409d09": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00409d09(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar2;\n    int32_t unaff_EDI;\n    uint arg_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (unaff_ESI < unaff_EBX) {\n        in_ECX = in_ECX + unaff_EDI;\n    }\n    else {\n        *(unaff_EBX + 0x4f50e0) = 0;\n    }\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    uVar2 = unaff_ESI;\n    if (var_4h < 0xa9a1) {\n        *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + 1;\n        var_8h = var_8h + 1 + (unaff_ESI - 1);\n        uVar2 = unaff_ESI - 1;\n    }\n    *(unaff_EBX + 0x4f50e0) = in_EDX;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) - ((in_ECX + 1) - (var_8h - 1U ^ uVar2));\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) | 1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) | 0xfffff858;\n    *(unaff_EBX + 0x4f50e0) = 0xfffffb6e;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + 1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + 0x580;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = 0xffffffff;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + 1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0);\n    *(unaff_EBX + 0x4f50e0) = 0xffffffff;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    iVar1 = *(unaff_EBX + 0x4f50e0);\n    arg_10h = *(unaff_EBX + 0x4f50c0);\n    fcn.0040e470(*(unaff_EBX + 0x4f53e4), *(unaff_EBX + 0x4f5068), arg_10h);\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f50e0) = -0xc0d - iVar1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -1;\n    *(unaff_EBX + 0x4f50e0) = *(unaff_EBX + 0x4f50e0) + -0x7d5;\n    return CONCAT44(arg_10h, unaff_ESI);\n}\n",
        "token_count": 1143
    },
    "0040a02c": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040a02c(uint arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t in_ECX;\n    int32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint arg_ch_00;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    if (var_8h < 0x7b83) {\n        arg_ch = arg_ch - 1;\n    }\n    else {\n        arg_ch = arg_ch ^ in_ECX;\n    }\n    uVar1 = (in_EAX ^ 0xffffffff) + 0x18c;\n    if (uVar1 < 0xdb90) {\n        uVar1 = (in_EAX ^ 0xffffffff) + 0x18b;\n    }\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + in_EDX;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + 1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) & 0xfffff8de;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c);\n    arg_ch_00 = *(unaff_EBX + 0x4f53c8);\n    fcn.0040376a(uVar1 & 0xfffffc68 | arg_ch, arg_ch_00);\n    *(unaff_EBX + 0x4f531c) = 1;\n    *(unaff_EBX + 0x4f531c) = 1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) | extraout_EDX;\n    fcn.0040d10e(*(unaff_EBX + 0x4f50a8));\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + 1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + -1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + 1;\n    *(unaff_EBX + 0x4f531c) = 0;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c);\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + -0x6b9;\n    *(unaff_EBX + 0x4f531c) = 0xffffffff;\n    *(unaff_EBX + 0x4f531c) = 0xffffffff;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) & (extraout_EDX ^ 0x4ca) - 1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + 1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + 0x3eb;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + -1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + 1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + -1;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) ^ 0xfffffffd;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) | 0xfffffde4;\n    *(unaff_EBX + 0x4f531c) = *(unaff_EBX + 0x4f531c) + -1;\n    return CONCAT44(arg_ch_00, unaff_ESI);\n}\n",
        "token_count": 1107
    },
    "0040a35a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040a35a(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_EAX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t iVar1;\n    uint arg_8h_00;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = unaff_ESI;\n    if (!SBORROW4(in_EAX, 0x5fad)) {\n        iVar1 = unaff_ESI + 1;\n    }\n    *(unaff_EBX + 0x4f54e4) = iVar1;\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4) + -1;\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4) + -1;\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4) + -0x6c0;\n    *(unaff_EBX + 0x4f54e4) = 0;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) + -1;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) & 1;\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4);\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450);\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4) + 1;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) + -1;\n    *(unaff_EBX + 0x4f54e4) = 0;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) + -1;\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4);\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) ^ 0xfffffa6c;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) & 0x1fa;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) + 1;\n    arg_8h_00 = *(unaff_EBX + 0x4f50fc);\n    fcn.00408f8a(arg_8h_00);\n    *(unaff_EBX + 0x4f54e4) = *(unaff_EBX + 0x4f54e4) + -1;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) + 1;\n    *(unaff_EBX + 0x4f54e4) = 0x74b;\n    *(unaff_EBX + 0x4f5450) = extraout_EDX + 1;\n    *(unaff_EBX + 0x4f5450) = *(unaff_EBX + 0x4f5450) + -1;\n    fcn.0040da9d(*(unaff_EBX + 0x4f5480), *(unaff_EBX + 0x4f5218));\n    return CONCAT44(arg_8h_00, unaff_ESI);\n}\n",
        "token_count": 920
    },
    "0040a6e3": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040a6e3(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t in_EAX;\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    int32_t unaff_EDI;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    int32_t iVar2;\n    \n    iVar2 = in_EAX;\n    if (unaff_EDI != in_ECX) {\n        iVar2 = in_EAX + 1;\n    }\n    uVar1 = iVar2 + 1;\n    if (arg_10h + -0xbec1 < 0) {\n        uVar1 = 0;\n    }\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) ^ uVar1;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 1;\n    *(unaff_EBX + 0x4f51f0) = *(unaff_EBX + 0x4f51f0);\n    *(unaff_EBX + 0x4f51f0) = 0;\n    *(unaff_EBX + 0x4f51f0) = *(unaff_EBX + 0x4f51f0) + 1;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 1;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 1;\n    *(unaff_EBX + 0x4f51f0) = *(unaff_EBX + 0x4f51f0) + 1;\n    *(unaff_EBX + 0x4f5094) = 0;\n    *(unaff_EBX + 0x4f51f0) = *(unaff_EBX + 0x4f51f0) | (var_ch + (unaff_ESI ^ 0xfffffb95)) - 1 & 0x697;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 2;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 1;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 2;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094);\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) + 1;\n    *(unaff_EBX + 0x4f51f0) = *(unaff_EBX + 0x4f51f0) + 1;\n    *(unaff_EBX + 0x4f51f0) = *(unaff_EBX + 0x4f51f0);\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5094) = *(unaff_EBX + 0x4f5094) - *(unaff_EBX + 0x4f5094);\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 856
    },
    "0040ac05": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040ac05(int32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t in_EAX;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t uVar4;\n    ulong uVar5;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_EAX - 0x2e74 < 0) {\n        in_EAX = in_EAX & 1;\n    }\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) ^ 1;\n    if ((POPCOUNT(in_EAX - 0x6eda & 0xff) & 1U) != 0) {\n        *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + 0x378;\n    }\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + -1;\n    iVar3 = *(unaff_EBX + 0x4f5184);\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + arg_8h + in_ECX;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + -1;\n    uVar4 = (var_4h + unaff_ESI + -1 | unaff_ESI - 2U) + iVar3;\n    uVar2 = iVar3 + 1;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + -1;\n    uVar1 = *(unaff_EBX + 0x4f5184);\n    *(unaff_EBX + 0x4f5184) = 0xfffffe87;\n    *(unaff_EBX + 0x4f5184) = 0x20b;\n    uVar5 = fcn.0040b9c7(*(unaff_EBX + 0x4f539c));\n    iVar3 = uVar5 >> 0x20;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184);\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + 1;\n    *(unaff_EBX + 0x4f5184) = 0xffffffff;\n    *(unaff_EBX + 0x4f5184) = 0xffffffff;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + 1;\n    *(unaff_EBX + 0x4f5184) = 0;\n    *(unaff_EBX + 0x4f5184) = 0;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184);\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) + iVar3;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) ^ iVar3 - 1U;\n    *(unaff_EBX + 0x4f5184) = 0;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) ^ 1;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184);\n    uVar4 = ((((uVar5 + (var_ch + 1U & 0xffffff19) + (uVar2 & uVar1) + uVar4) - 0x7fb & 0xffffff36) + 0x1c9 & 0x6cc) - 1\n            & (arg_ch & ((var_8h + -1) - uVar2 & uVar4) - 1 ^ 1)) - 1;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) ^ uVar4;\n    *(unaff_EBX + 0x4f5184) = *(unaff_EBX + 0x4f5184) ^ uVar4;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 1153
    },
    "0040b019": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040b019(int32_t arg_8h)\n\n{\n    int32_t in_EAX;\n    int32_t in_ECX;\n    int32_t unaff_EBX;\n    uint32_t uVar1;\n    uint unaff_EDI;\n    uint arg_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (!SBORROW4(arg_8h, 0xd2cc)) {\n        *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) + 1;\n    }\n    uVar1 = 0xffffffff;\n    if (in_EAX != 0xb8e0) {\n        uVar1 = var_8h ^ 0xffffffff;\n    }\n    *(unaff_EBX + 0x4f52c0) = *(unaff_EBX + 0x4f52c0) + 1;\n    *(unaff_EBX + 0x4f54f8) = *(unaff_EBX + 0x4f54f8) | uVar1;\n    *(unaff_EBX + 0x4f54f8) = 1;\n    *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) + -1;\n    *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) + in_ECX + 0x5cc;\n    *(unaff_EBX + 0x4f54f8) = *(unaff_EBX + 0x4f54f8) + -1;\n    *(unaff_EBX + 0x4f54f8) = 0;\n    *(unaff_EBX + 0x4f52c0) = *(unaff_EBX + 0x4f52c0) + 1;\n    *(unaff_EBX + 0x4f54f8) = *(unaff_EBX + 0x4f54f8) + -1;\n    *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) | 1;\n    arg_ch = *(unaff_EBX + 0x4f50d8);\n    fcn.0040857b(1, arg_ch, *(unaff_EBX + 0x4f5264));\n    *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) + 1;\n    *(unaff_EBX + 0x4f54f8) = *(unaff_EBX + 0x4f54f8) | 1;\n    *(unaff_EBX + 0x4f52c0) = 0;\n    *(unaff_EBX + 0x4f54f8) = 1;\n    *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) + 1;\n    *(unaff_EBX + 0x4f54f8) = *(unaff_EBX + 0x4f54f8) ^ 1;\n    *(unaff_EBX + 0x4f5400) = *(unaff_EBX + 0x4f5400) + -1;\n    *(unaff_EBX + 0x4f54f8) = 0xffffffff;\n    fcn.004088a5(*(unaff_EBX + 0x4f532c));\n    return CONCAT44(arg_ch, unaff_EDI);\n}\n",
        "token_count": 824
    },
    "0040b345": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040b345(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t in_EAX;\n    uint32_t uVar2;\n    uint32_t extraout_ECX;\n    int32_t in_EDX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint arg_ch_00;\n    int32_t iVar3;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (!SBORROW4(arg_10h, 0xd587)) {\n        in_EAX = in_EAX + 0x37b;\n    }\n    uVar2 = ((in_EAX ^ 0x70b) - 0x284) - in_EDX;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) ^ uVar2;\n    arg_ch_00 = *(unaff_EBX + 0x4f5050);\n    iVar3 = unaff_ESI;\n    fcn.00405513(*(unaff_EBX + 0x4f51c0), arg_ch_00);\n    fcn.004047c6(unaff_ESI + 0x68e);\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + 1;\n    *(unaff_EBX + 0x4f5030) = 1;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + 1;\n    *(unaff_EBX + 0x4f5030) =\n         *(unaff_EBX + 0x4f5030) - (extraout_EDX + (unaff_ESI + 0x68eU & 0xfffff9b5 | *(unaff_EBX + 0x4f5030)) + -1);\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) & 0xfffffffd;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) & extraout_ECX;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + -1;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + 0x7df;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030);\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030);\n    uVar1 = *(unaff_EBX + 0x4f5030);\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + -1;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + -1;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) + -1;\n    *(unaff_EBX + 0x4f5030) = ((extraout_ECX | (arg_10h & uVar2 & 1 ^ 1) - 1) - 1 ^ uVar1) + 0x1e4;\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) ^ 1;\n    *(unaff_EBX + 0x4f5030) = 1 - *(unaff_EBX + 0x4f5030);\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030);\n    *(unaff_EBX + 0x4f5030) = *(unaff_EBX + 0x4f5030) & 0xfffffe8c;\n    return CONCAT44(arg_ch_00, iVar3);\n}\n",
        "token_count": 998
    },
    "0040b6ac": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040b6ac(uint arg_8h)\n\n{\n    uint32_t extraout_ECX;\n    uint32_t uVar1;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    int32_t var_8h;\n    uint var_4h;\n    \n    if (SBORROW4(var_8h, 0xa325)) {\n        *(unaff_EBX + 0x4f522c) = 0xffffffea;\n        var_8h = var_8h + -1;\n    }\n    else {\n        *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + 1;\n    }\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) | 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) & unaff_EDI;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) & unaff_ESI - 1U;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + 1;\n    *(unaff_EBX + 0x4f522c) = 0x717;\n    *(unaff_EBX + 0x4f522c) = 0;\n    fcn.0040313d(*(unaff_EBX + 0x4f50bc), *(unaff_EBX + 0x4f50b4));\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) & 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) & 1;\n    *(unaff_EBX + 0x4f522c) = 0;\n    *(unaff_EBX + 0x4f522c) = 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + -0x621;\n    uVar1 = (extraout_ECX & 1) - 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) ^ uVar1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + -1;\n    *(unaff_EBX + 0x4f522c) = 0xffffffff;\n    *(unaff_EBX + 0x4f522c) = 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + 0x754;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) + 1;\n    *(unaff_EBX + 0x4f522c) = *(unaff_EBX + 0x4f522c) & (((uVar1 ^ (var_8h + 1U | uVar1) + 1) - 0x3ef) * 2 + 1 | 1) + 1;\n    *(unaff_EBX + 0x4f522c) = 0x260;\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 917
    },
    "0040b9c7": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040b9c7(uint32_t arg_8h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t in_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h < 0xba17) {\n        iVar1 = 0;\n    }\n    else {\n        arg_8h = arg_8h - unaff_EDI;\n        iVar1 = in_EAX + -1;\n        *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) ^ in_ECX;\n    }\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    uVar2 = iVar1 + 2;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) ^ uVar2;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) | 0xfffffbc8;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334);\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) & uVar2 & 0xfffff856;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) ^ 0xfffffcfb;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) | 0x49d;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    iVar1 = *(unaff_EBX + 0x4f5334);\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    *(unaff_EBX + 0x4f5334) = 1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) = 0xffffffff;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) & 0xfffff84f;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334);\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334);\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) =\n         *(unaff_EBX + 0x4f5334) & 0xfffffffe - (((in_EDX ^ uVar2) + (arg_8h | unaff_EDI) + 2) - iVar1);\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) = 0xfffff95b;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) | 0xfffffffe;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    uVar2 = *(unaff_EBX + 0x4f5334);\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + -1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) ^ uVar2 & 1;\n    *(unaff_EBX + 0x4f5334) = *(unaff_EBX + 0x4f5334) + 1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 1273
    },
    "0040bcfc": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nulong __cdecl fcn.0040bcfc(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) + 1;\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) + -1;\n    uVar3 = *(unaff_EBX + 0x4f5460) & 0xfffffb36;\n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) | uVar3;\n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) + -1;\n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) - unaff_EDI;\n    uVar4 = unaff_EDI + *(unaff_EBX + 0x4f5460);\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) + 1;\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) - uVar4;\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) + 0x46;\n    iVar1 = ((in_EAX + -1) * 2 ^ unaff_ESI) - unaff_ESI;\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) | (uVar4 ^ uVar3) + 1;\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) + -1;\n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) + -1;\n    iVar5 = unaff_EBX;\n    iVar6 = unaff_EBX;\n    iVar2 = fcn.0040e15b(unaff_EBX, &stack0xffffffe0, unaff_EBX);\n    uVar3 = *(unaff_EBX + 0x4f5460);\n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) ^ 1;\n    fcn.00403457(*(unaff_EBX + 0x4f5358), 0);\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) + -1;\n    *(unaff_EBX + 0x4f5388) = *(unaff_EBX + 0x4f5388) & 1;\n    *(unaff_EBX + 0x4f5484) = *(unaff_EBX + 0x4f5484) + 1;\n    *(unaff_EBX + 0x4f5388) = *(unaff_EBX + 0x4f5388) + -1;\n    *(unaff_EBX + 0x4f5460) =\n         *(unaff_EBX + 0x4f5460) |\n         (unaff_ESI | 0x5e5) ^\n         (((iVar1 - 0x6c1U & uVar3) + iVar2 + 1 | (iVar1 - 0x6c0U | unaff_ESI | 0x5e5) - 2) - 1 | 0xfffff926);\n    *(unaff_EBX + 0x4f5460) = *(unaff_EBX + 0x4f5460) + 2;\n    return CONCAT44(iVar5, iVar6);\n}\n",
        "token_count": 1003
    },
    "0040bfe5": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040bfe5(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t in_EAX;\n    uint in_ECX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint32_t unaff_EDI;\n    uint var_8h;\n    uint var_4h;\n    \n    if (SBORROW4(in_EAX, 0x5688)) {\n        *(unaff_EBX + 0x4f5178) = *(unaff_EBX + 0x4f5178) + -1;\n    }\n    *(unaff_EBX + 0x4f5178) = unaff_EDI;\n    *(unaff_EBX + 0x4f544c) = 0;\n    *(unaff_EBX + 0x4f544c) = *(unaff_EBX + 0x4f544c);\n    *(unaff_EBX + 0x4f544c) = *(unaff_EBX + 0x4f544c) + 1;\n    *(unaff_EBX + 0x4f5078) = *(unaff_EBX + 0x4f5078) ^ ((arg_10h & 1) - ((unaff_EDI ^ 0x361) + 1 | 1)) - 1;\n    *(unaff_EBX + 0x4f5178) = 0xffffffff;\n    *(unaff_EBX + 0x4f544c) = *(unaff_EBX + 0x4f544c) & 0x6fe;\n    *(unaff_EBX + 0x4f544c) = *(unaff_EBX + 0x4f544c) + 0x566;\n    *(unaff_EBX + 0x4f5078) = *(unaff_EBX + 0x4f5078) + 1;\n    *(unaff_EBX + 0x4f5178) = *(unaff_EBX + 0x4f5178) + -1;\n    *(unaff_EBX + 0x4f544c) = *(unaff_EBX + 0x4f544c) + -1;\n    *(unaff_EBX + 0x4f5078) = *(unaff_EBX + 0x4f5078);\n    *(unaff_EBX + 0x4f544c) = 0;\n    *(unaff_EBX + 0x4f5178) = *(unaff_EBX + 0x4f5178) + -1;\n    fcn.00406ecf(0xffffffff);\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 610
    },
    "0040c483": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040c483(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    uint32_t in_ECX;\n    uint32_t extraout_ECX;\n    uint32_t uVar2;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    uint32_t uVar3;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((POPCOUNT(in_EAX - 0xb8fcU & 0xff) & 1U) == 0) {\n        fcn.0040b6ac(*(unaff_EBX + 0x4f5320));\n        *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) + 1;\n        uVar2 = extraout_ECX;\n    }\n    else {\n        *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) - in_EAX;\n        uVar2 = in_ECX;\n    }\n    *(unaff_EBX + 0x4f54d0) = *(unaff_EBX + 0x4f54d0) - unaff_EDI;\n    uVar3 = unaff_EDI + 1;\n    if (&stack0xffffffd8 + -arg_8h < 0) {\n        uVar2 = uVar2 & 1;\n    }\n    *(unaff_EBX + 0x4f5070) = *(unaff_EBX + 0x4f5070) | uVar3;\n    iVar1 = *(unaff_EBX + 0x4f5070);\n    *(unaff_EBX + 0x4f54d0) = *(unaff_EBX + 0x4f54d0) + -1;\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) | 1;\n    *(unaff_EBX + 0x4f5070) = *(unaff_EBX + 0x4f5070) ^ uVar3;\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4);\n    *(unaff_EBX + 0x4f5070) = *(unaff_EBX + 0x4f5070) | uVar3;\n    uVar3 = (uVar3 & 0xfffffe8a) - 1;\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) & iVar1 * 2;\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) + uVar3;\n    *(unaff_EBX + 0x4f54d0) = *(unaff_EBX + 0x4f54d0) ^ (uVar2 | uVar3) + 1;\n    *(unaff_EBX + 0x4f54d0) = *(unaff_EBX + 0x4f54d0) + -1;\n    *(unaff_EBX + 0x4f54d0) = *(unaff_EBX + 0x4f54d0) + -1;\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) + uVar2 + *(unaff_EBX + 0x4f52b4);\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4);\n    *(unaff_EBX + 0x4f52b4) = 0;\n    *(unaff_EBX + 0x4f5070) = *(unaff_EBX + 0x4f5070);\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) + -1;\n    *(unaff_EBX + 0x4f5070) = *(unaff_EBX + 0x4f5070) + 1;\n    *(unaff_EBX + 0x4f52b4) = *(unaff_EBX + 0x4f52b4) + 1;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 1056
    },
    "0040c76e": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040c76e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    int32_t arg_10h_00;\n    uint arg_8h_00;\n    int32_t iVar3;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (&stack0xfffffffc + -var_4h < 0) {\n        *(unaff_EBX + 0x4f53e8) = *(unaff_EBX + 0x4f53e8) + -1;\n    }\n    else {\n        *(unaff_EBX + 0x4f53e8) = 0;\n    }\n    *(unaff_EBX + 0x4f5314) = *(unaff_EBX + 0x4f5314) & unaff_ESI;\n    *(unaff_EBX + 0x4f53e8) = 1;\n    *(unaff_EBX + 0x4f53e8) = *(unaff_EBX + 0x4f53e8) + 1;\n    *(unaff_EBX + 0x4f5314) = *(unaff_EBX + 0x4f5314) + 1;\n    arg_10h_00 = ((var_ch ^ 1) - 0xeb) - var_4h;\n    arg_8h_00 = *(unaff_EBX + 0x4f5098);\n    iVar3 = arg_10h_00;\n    fcn.0040445b(arg_8h_00, *(unaff_EBX + 0x4f541c), arg_10h_00);\n    uVar1 = *(unaff_EBX + 0x4f53e8);\n    *(unaff_EBX + 0x4f5314) = 0xffffffff;\n    *(unaff_EBX + 0x4f53e8) = 0x3d3;\n    *(unaff_EBX + 0x4f53e8) = *(unaff_EBX + 0x4f53e8) + 1;\n    iVar2 = *(unaff_EBX + 0x4f53e8);\n    *(unaff_EBX + 0x4f53e8) = arg_10h_00 - 1U ^ uVar1;\n    *(unaff_EBX + 0x4f5314) = *(unaff_EBX + 0x4f5314) - (((extraout_ECX ^ arg_10h_00 - 1U) + 1) - iVar2);\n    *(unaff_EBX + 0x4f53e8) = *(unaff_EBX + 0x4f53e8) + 1;\n    *(unaff_EBX + 0x4f53e8) = 0;\n    *(unaff_EBX + 0x4f5314) = 1;\n    fcn.00407efd(*(unaff_EBX + 0x4f5228), *(unaff_EBX + 0x4f5174));\n    *(unaff_EBX + 0x4f53e8) = *(unaff_EBX + 0x4f53e8) | 0xfffffe29;\n    *(unaff_EBX + 0x4f5314) = *(unaff_EBX + 0x4f5314) & 1;\n    return CONCAT44(arg_8h_00, iVar3);\n}\n",
        "token_count": 829
    },
    "0040ca73": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040ca73(uint arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    int32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t arg_10h;\n    uint32_t uVar2;\n    uint arg_ch_00;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_ECX < var_8h) {\n        *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + 1;\n    }\n    else {\n        arg_ch = arg_ch & 0xfffffa88;\n    }\n    if (-1 < arg_ch - 0x6d08) {\n        in_ECX = in_ECX - unaff_ESI;\n    }\n    uVar1 = *(unaff_EBX + 0x4f53a8);\n    *(unaff_EBX + 0x4f53a8) = 0xfffffe69;\n    uVar2 = *(unaff_EBX + 0x4f53a8);\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    arg_ch_00 = *(unaff_EBX + 0x4f503c);\n    uVar1 = fcn.0040313d((unaff_ESI | uVar1) + 1, arg_ch_00);\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + extraout_ECX;\n    arg_10h = (uVar2 | uVar1) ^ 0xffffffff;\n    uVar2 = arg_10h;\n    fcn.0040ac05(*(unaff_EBX + 0x4f5084), *(unaff_EBX + 0x4f53e0), arg_10h);\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + (arg_ch & in_ECX - 1U) + 2;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) ^ extraout_EDX;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + 1;\n    *(unaff_EBX + 0x4f53a8) = 0xffffffff;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + 1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + 0x50c;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8);\n    uVar1 = *(unaff_EBX + 0x4f53a8);\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + 1;\n    *(unaff_EBX + 0x4f53a8) =\n         *(unaff_EBX + 0x4f53a8) & ((arg_10h - ((var_4h - 1U ^ in_EDX - 0x196U) + 0x793) | 2) + 0x702 | uVar1);\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + -1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) + 1;\n    *(unaff_EBX + 0x4f53a8) = *(unaff_EBX + 0x4f53a8) & 0xfffffc5c;\n    return CONCAT44(uVar2, arg_ch_00);\n}\n",
        "token_count": 1181
    },
    "0040cdd4": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040cdd4(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint32_t in_ECX;\n    uint32_t uVar3;\n    int32_t extraout_ECX;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint unaff_EDI;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (unaff_EBX < in_EDX) {\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = in_ECX & 1;\n    }\n    if (in_EAX + -0xed37 < 0) {\n        uVar3 = uVar3 + 1;\n        in_EAX = in_EAX + -1;\n    }\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + -1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) | in_EAX - 1U;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + 1;\n    uVar1 = *(unaff_EBX + 0x4f5140);\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + 1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + 1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) - uVar3;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + 1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + -1;\n    *(unaff_EBX + 0x4f5140) = 1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) ^ 0xfffffffd;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + 1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + -1;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140);\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + 1;\n    iVar2 = fcn.004110ce(1 - ((unaff_ESI ^ uVar1) + 0x1b9) & 1, *(unaff_EBX + 0x4f54c8));\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) + extraout_ECX;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) ^ iVar2 + 1U;\n    *(unaff_EBX + 0x4f5140) = *(unaff_EBX + 0x4f5140) ^ iVar2 - 0x889U;\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 868
    },
    "0040d10e": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n\nulong __cdecl fcn.0040d10e(int32_t arg_8h)\n\n{\n    uint in_EAX;\n    uint32_t in_ECX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_8h;\n    uint var_4h;\n    \n    if (unaff_ESI <= arg_8h + 0xa1U) {\n        *(unaff_EBX + 0x4f51c4) = *(unaff_EBX + 0x4f51c4) ^ in_ECX;\n        *(unaff_EBX + 0x4f51c4) = *(unaff_EBX + 0x4f51c4) + 1;\n    }\n    *(unaff_EBX + 0x4f53b4) = *(unaff_EBX + 0x4f53b4) ^ 0x3ea;\n    *(unaff_EBX + 0x4f51c4) = *(unaff_EBX + 0x4f51c4) + unaff_EDI;\n    *(unaff_EBX + 0x4f53b4) = *(unaff_EBX + 0x4f53b4) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f53b4) = *(unaff_EBX + 0x4f53b4) + 1;\n    *(unaff_EBX + 0x4f53b4) = *(unaff_EBX + 0x4f53b4);\n    *(unaff_EBX + 0x4f53b4) = *(unaff_EBX + 0x4f53b4) + 1;\n    *(unaff_EBX + 0x4f51c4) = 1;\n    *(unaff_EBX + 0x4f53b4) = *(unaff_EBX + 0x4f53b4);\n    *(unaff_EBX + 0x4f53b4) = 1;\n    *(unaff_EBX + 0x4f51c4) = *(unaff_EBX + 0x4f51c4);\n    *(unaff_EBX + 0x4f51c4) = *(unaff_EBX + 0x4f51c4) + 1;\n    *(unaff_EBX + 0x4f51c4) = *(unaff_EBX + 0x4f51c4) + 1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 601
    },
    "0040d730": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040d76f)\n\nulong __cdecl fcn.0040d730(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t uVar2;\n    int32_t unaff_EDI;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (SBORROW4(in_EAX, 0xe2b7)) {\n        unaff_EDI = unaff_EDI + -0x5bd;\n    }\n    *(unaff_EBX + 0x4f52f0) = *(unaff_EBX + 0x4f52f0) + 1;\n    iVar1 = *(unaff_EBX + 0x4f52f0);\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac) + -1;\n    *(unaff_EBX + 0x4f52f0) = *(unaff_EBX + 0x4f52f0) + 1;\n    uVar2 = ((var_8h & -(unaff_EDI + 1 + iVar1 * -2) - (unaff_ESI + 1)) - 2) - *(unaff_EBX + 0x4f5170) | 0xfffff99d;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac) + 1;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac);\n    *(unaff_EBX + 0x4f5170) = *(unaff_EBX + 0x4f5170) + -1;\n    *(unaff_EBX + 0x4f5170) = *(unaff_EBX + 0x4f5170) + 1;\n    *(unaff_EBX + 0x4f5170) = *(unaff_EBX + 0x4f5170) + -1;\n    *(unaff_EBX + 0x4f52f0) = *(unaff_EBX + 0x4f52f0) | uVar2 + 1;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac) + 1;\n    *(unaff_EBX + 0x4f5170) = *(unaff_EBX + 0x4f5170) + 1;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac);\n    *(unaff_EBX + 0x4f52f0) = *(unaff_EBX + 0x4f52f0) + -1;\n    *(unaff_EBX + 0x4f5170) = *(unaff_EBX + 0x4f5170) & 0xffffffff - uVar2;\n    *(unaff_EBX + 0x4f5170) = 1;\n    *(unaff_EBX + 0x4f52f0) = *(unaff_EBX + 0x4f52f0) & 1;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac) + 1;\n    *(unaff_EBX + 0x4f5170) = 0x2a9;\n    *(unaff_EBX + 0x4f52f0) = *(unaff_EBX + 0x4f52f0) | 0x455;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac) + -1;\n    *(unaff_EBX + 0x4f50ac) = 0xfffffee1;\n    *(unaff_EBX + 0x4f50ac) = *(unaff_EBX + 0x4f50ac) + -1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 966
    },
    "0040da9d": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040da9d(uint arg_8h, uint arg_ch)\n\n{\n    int32_t unaff_EBX;\n    uint uVar1;\n    uint arg_ch_00;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5488) = *(unaff_EBX + 0x4f5488) + -1;\n    *(unaff_EBX + 0x4f546c) = *(unaff_EBX + 0x4f546c) | 0xfffffe2d;\n    *(unaff_EBX + 0x4f5488) = *(unaff_EBX + 0x4f5488) + -1;\n    *(unaff_EBX + 0x4f546c) = *(unaff_EBX + 0x4f546c) ^ 0xc1e;\n    *(unaff_EBX + 0x4f546c) = 1;\n    arg_ch_00 = *(unaff_EBX + 0x4f52c8);\n    fcn.00409d09(&stack0xfffffffc, arg_ch_00);\n    uVar1 = 1;\n    fcn.00404125(1);\n    *(unaff_EBX + 0x4f546c) = *(unaff_EBX + 0x4f546c) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f546c) = *(unaff_EBX + 0x4f546c) + -1;\n    fcn.0040cdd4(*(unaff_EBX + 0x4f512c), *(unaff_EBX + 0x4f54a8));\n    return CONCAT44(uVar1, arg_ch_00);\n}\n",
        "token_count": 394
    },
    "0040dda8": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040dda8(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t in_EAX;\n    int32_t in_EDX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((POPCOUNT(-arg_8h - 4U & 0xff) & 1U) == 0) {\n        *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + 1;\n        *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + 1;\n    }\n    else {\n        in_EAX = in_EAX ^ 1;\n        *(unaff_EBX + 0x4f54ec) = *(unaff_EBX + 0x4f54ec) + 1;\n    }\n    *(unaff_EBX + 0x4f54ec) = *(unaff_EBX + 0x4f54ec) + 1;\n    if (SBORROW4(in_EAX, 0x7b39)) {\n        *(unaff_EBX + 0x4f5304) = unaff_ESI;\n    }\n    *(unaff_EBX + 0x4f53fc) = *(unaff_EBX + 0x4f53fc) + 1;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304);\n    *(unaff_EBX + 0x4f54ec) = *(unaff_EBX + 0x4f54ec) & unaff_ESI - 1U;\n    *(unaff_EBX + 0x4f54ec) = *(unaff_EBX + 0x4f54ec) + 1;\n    *(unaff_EBX + 0x4f53fc) = *(unaff_EBX + 0x4f53fc) + 1;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + 1;\n    *(unaff_EBX + 0x4f53fc) = *(unaff_EBX + 0x4f53fc);\n    *(unaff_EBX + 0x4f53fc) = 0xffffffff;\n    *(unaff_EBX + 0x4f5304) = 0xffffffff;\n    *(unaff_EBX + 0x4f54ec) = 0xffffffff;\n    iVar1 = *(unaff_EBX + 0x4f5304);\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) ^ 0xfffffdec;\n    *(unaff_EBX + 0x4f54ec) = *(unaff_EBX + 0x4f54ec) + -1;\n    *(unaff_EBX + 0x4f53fc) = *(unaff_EBX + 0x4f53fc) + -0x198;\n    *(unaff_EBX + 0x4f53fc) = 0xfffffb58;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + -2;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + -1;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) | (in_EDX - iVar1) + 0x5fdU;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + 2;\n    *(unaff_EBX + 0x4f5304) = 0xffffffff;\n    fcn.0040965c(0, *(unaff_EBX + 0x4f5058));\n    *(unaff_EBX + 0x4f54ec) = 1;\n    *(unaff_EBX + 0x4f53fc) = 0xffffffff;\n    *(unaff_EBX + 0x4f53fc) = *(unaff_EBX + 0x4f53fc) + -1;\n    *(unaff_EBX + 0x4f5304) = *(unaff_EBX + 0x4f5304) + extraout_EDX + -0xcf;\n    *(unaff_EBX + 0x4f54ec) = *(unaff_EBX + 0x4f54ec);\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 1118
    },
    "0040e15b": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nulong __cdecl fcn.0040e15b(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    uint in_EDX;\n    uint32_t uVar2;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    ulong uVar3;\n    uint in_stack_ffffffd8;\n    uint32_t uVar4;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar4 = unaff_ESI;\n    if (var_ch - 0x3302 < 0) {\n        in_stack_ffffffd8 = *(unaff_EBX + 0x4f501c);\n        in_EAX = fcn.0040313d(in_EDX, in_stack_ffffffd8);\n        var_ch = unaff_ESI;\n    }\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8);\n    *(unaff_EBX + 0x4f54a4) = 0;\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) ^ 0xfffffb29;\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8) - (in_EAX + -2);\n    *(unaff_EBX + 0x4f54a4) = 0;\n    *(unaff_EBX + 0x4f54a4) = 0;\n    *(unaff_EBX + 0x4f54a4) = 0;\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8) + 1;\n    uVar3 = fcn.0040d730(*(unaff_EBX + 0x4f5518));\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + 1;\n    *(unaff_EBX + 0x4f54a4) = 0;\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4);\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + -1;\n    iVar1 = *(unaff_EBX + 0x4f54a4);\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8) + 1;\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + -1;\n    *(unaff_EBX + 0x4f54d8) = (arg_8h ^ 0xffffffff | uVar3) - ((var_ch ^ unaff_EDI) + 1) ^ 0xffffffff;\n    iVar1 = -(iVar1 + -1);\n    *(unaff_EBX + 0x4f54d8) = iVar1;\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + iVar1;\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8);\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + 1;\n    uVar2 = (uVar3 >> 0x20) - (arg_ch | 1) ^ 1;\n    *(unaff_EBX + 0x4f54d8) = uVar2;\n    *(unaff_EBX + 0x4f54d8) = 0xffffffff;\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + -1;\n    *(unaff_EBX + 0x4f54a4) = *(unaff_EBX + 0x4f54a4) + -1;\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8) | uVar2;\n    *(unaff_EBX + 0x4f54d8) = *(unaff_EBX + 0x4f54d8) + -1;\n    return CONCAT44(in_stack_ffffffd8, uVar4);\n}\n",
        "token_count": 1114
    },
    "0040e470": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040e470(uint arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_EDI;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = var_4h | in_EDX;\n    if (arg_ch < 0xb9c6) {\n        iVar1 = *(unaff_EBX + 0x4f5408) + -1;\n        var_4h = var_4h - 1;\n    }\n    else {\n        iVar1 = 2;\n    }\n    *(unaff_EBX + 0x4f5064) = *(unaff_EBX + 0x4f5064) & 1;\n    *(unaff_EBX + 0x4f5354) = 0xffffffff;\n    *(unaff_EBX + 0x4f5064) = *(unaff_EBX + 0x4f5064) + iVar1;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408) | unaff_EDI & var_4h;\n    *(unaff_EBX + 0x4f5408) = 1;\n    *(unaff_EBX + 0x4f5064) = 0xffffffff;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408) & 1;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408) + (unaff_EDI & var_4h);\n    *(unaff_EBX + 0x4f5064) = *(unaff_EBX + 0x4f5064) & 0xfffffd72;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408);\n    *(unaff_EBX + 0x4f5354) = 0x50d;\n    *(unaff_EBX + 0x4f5354) = *(unaff_EBX + 0x4f5354) + 1;\n    *(unaff_EBX + 0x4f5408) = 0;\n    *(unaff_EBX + 0x4f5408) = 0xffffffff;\n    *(unaff_EBX + 0x4f5408) = 0xfffffce7;\n    *(unaff_EBX + 0x4f5408) = 0;\n    *(unaff_EBX + 0x4f5064) = 0;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408);\n    *(unaff_EBX + 0x4f5064) = *(unaff_EBX + 0x4f5064) + 1;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408);\n    *(unaff_EBX + 0x4f5354) = *(unaff_EBX + 0x4f5354) & 1;\n    *(unaff_EBX + 0x4f5354) = *(unaff_EBX + 0x4f5354) + 1;\n    *(unaff_EBX + 0x4f5354) = 0;\n    *(unaff_EBX + 0x4f5408) = *(unaff_EBX + 0x4f5408) | 2;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 859
    },
    "0040e789": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040e789(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = unaff_ESI;\n    if (arg_8h < 0x45f6) {\n        arg_8h = arg_8h + unaff_ESI;\n        unaff_EDI = 0xfffff870;\n        *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) - in_ECX;\n    }\n    else {\n        fcn.0040584c(*(unaff_EBX + 0x4f5504));\n        in_EDX = extraout_EDX;\n    }\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) ^ 0x94;\n    if (&stack0xffffffe0 + -arg_8h < 0) {\n        unaff_EDI = unaff_EDI - *(unaff_EBX + 0x4f5100);\n    }\n    else {\n        arg_8h = 0x6f0;\n    }\n    uVar2 = (arg_8h & in_EDX - 1 | unaff_EDI ^ in_EDX) + (*(unaff_EBX + 0x4f5100) & 0x797);\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + 1;\n    uVar1 = uVar2 - 1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) & uVar2;\n    *(unaff_EBX + 0x4f5100) = 0xffffffff;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + 1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + -0x2f4;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + 1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + -1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) & (uVar1 ^ 0xfffffcca) + 0x48d & uVar1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100);\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + 1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100);\n    *(unaff_EBX + 0x4f5100) = 0;\n    *(unaff_EBX + 0x4f5100) = 1;\n    uVar2 = 0xfffff94e - (uVar2 - 2);\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) & uVar2;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + uVar2;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + 1;\n    *(unaff_EBX + 0x4f5100) = 0xffffffff;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + 1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100);\n    *(unaff_EBX + 0x4f5100) = unaff_ESI - 0x498U & uVar1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) ^ 1;\n    *(unaff_EBX + 0x4f5100) = *(unaff_EBX + 0x4f5100) + -1;\n    return CONCAT44(iVar3, in_ECX);\n}\n",
        "token_count": 1159
    },
    "0040eaba": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040eaba(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_EAX;\n    uint32_t uVar3;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t in_EDX;\n    int32_t extraout_EDX;\n    uchar *unaff_EBX;\n    int32_t unaff_ESI;\n    uchar *puVar4;\n    uint arg_8h_00;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    puVar4 = &stack0xfffffffc;\n    if (unaff_EBX < &stack0xfffffffc) {\n        in_EAX = 0;\n    }\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) + -1;\n    if ((in_EAX + 1U ^ 0xfffff8d7) < 0xa225) {\n        var_4h = var_4h ^ in_EDX + 1U;\n    }\n    else {\n        var_4h = var_4h + 1;\n    }\n    fcn.004026fd(*(unaff_EBX + 0x4f54b4));\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) | extraout_ECX + (var_4h & 0x1ab);\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) ^ 0x1aa;\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034) ^ 1;\n    fcn.00410092(*(unaff_EBX + 0x4f543c), *(unaff_EBX + 0x4f508c), *(unaff_EBX + 0x4f52ac));\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) & extraout_ECX_00 + unaff_ESI + extraout_ECX;\n    uVar1 = *(unaff_EBX + 0x4f5034);\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) + 0x2a6;\n    arg_8h_00 = *(unaff_EBX + 0x4f5324);\n    fcn.004047c6(arg_8h_00);\n    *(unaff_EBX + 0x4f5034) = 0xffffffff;\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034);\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034) + -0xd7;\n    fcn.0040f328(*(unaff_EBX + 0x4f50dc));\n    uVar3 = fcn.00408c30(&stack0xfffffffc);\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034) & uVar3;\n    *(unaff_EBX + 0x4f5034) = unaff_ESI + extraout_ECX ^ (uVar1 | extraout_EDX - 1U) - 0x2bf;\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034) + 1;\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) ^ 1;\n    *(unaff_EBX + 0x4f5034) = 0xf2;\n    fcn.00406295(0xfffffec8, *(unaff_EBX + 0x4f50e4));\n    iVar2 = *(unaff_EBX + 0x4f5034);\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034) ^ 1;\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) | iVar2 + 1U;\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034);\n    *(unaff_EBX + 0x4f5034) = *(unaff_EBX + 0x4f5034);\n    *(unaff_EBX + 0x4f54cc) = *(unaff_EBX + 0x4f54cc) + -1;\n    return CONCAT44(puVar4, arg_8h_00);\n}\n",
        "token_count": 1140
    },
    "0040f02d": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: arg_8h\n\nulong __cdecl fcn.0040f02d(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_EAX;\n    uint32_t uVar1;\n    uint in_ECX;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint var_4h;\n    \n    if ((POPCOUNT(*(unaff_EBX + 0x4f5254) - 0x1bc8U & 0xff) & 1U) == 0) {\n        *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) + -1;\n        uVar1 = in_EAX - 1;\n    }\n    else {\n        uVar1 = 1;\n    }\n    uVar1 = uVar1 ^ 0xfffff970;\n    if (!SBORROW4(in_EDX, unaff_EBX)) {\n        *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + unaff_ESI;\n        uVar1 = uVar1 & 0x51f;\n    }\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + -1;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + 1;\n    *(unaff_EBX + 0x4f5254) = 0xffffffff;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + -1;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + -1;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) | 0xfffffccb;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + -1;\n    *(unaff_EBX + 0x4f52e4) = 1;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) | 1;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) + (uVar1 - 1 & 0x2e6 ^ 0x539) + 0x7b;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + -1;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) + 1;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) | unaff_EDI;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) & 1;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) & unaff_EDI + 1;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + 0x41;\n    *(unaff_EBX + 0x4f5254) = *(unaff_EBX + 0x4f5254) + -0x3c6;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4) + -0x73a;\n    *(unaff_EBX + 0x4f52e4) = *(unaff_EBX + 0x4f52e4);\n    fcn.0040dda8(*(unaff_EBX + 0x4f5180));\n    *(unaff_EBX + 0x4f5254) = 0xfffffbb9;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 1068
    },
    "0040f328": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040f328(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_EDI;\n    int32_t var_8h;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + 1;\n    *(unaff_EBX + 0x4f53a0) = 0xffffffff;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + -1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) ^ 1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) & unaff_EDI - 2U;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0);\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) & unaff_EDI - 2U;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) & 1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) & 1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + 1;\n    *(unaff_EBX + 0x4f53a0) = 0xffffffff;\n    *(unaff_EBX + 0x4f53a0) = 0;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + ((var_8h - 1U | 1) + 1 & 0x3d5);\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + -0x6fa;\n    *(unaff_EBX + 0x4f53a0) = 0xffffffff;\n    *(unaff_EBX + 0x4f53a0) = 599;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + -1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + 1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + -1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + -1;\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0);\n    *(unaff_EBX + 0x4f53a0) = *(unaff_EBX + 0x4f53a0) + -1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 821
    },
    "0040fa15": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: arg_8h\n\nulong __cdecl fcn.0040fa15(uint arg_8h)\n\n{\n    int32_t in_EAX;\n    uint in_EDX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_4h;\n    \n    if (in_EAX < unaff_EDI) {\n        *(unaff_EBX + 0x4f5298) = unaff_ESI;\n        *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + in_EAX;\n    }\n    *(unaff_EBX + 0x4f5298) = *(unaff_EBX + 0x4f5298) + -1;\n    *(unaff_EBX + 0x4f5298) = 0xffffffff;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + -1;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) | 1;\n    *(unaff_EBX + 0x4f5298) = *(unaff_EBX + 0x4f5298);\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + 1;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + 1;\n    *(unaff_EBX + 0x4f5298) = 0x530;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + -1;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) & 0x530;\n    *(unaff_EBX + 0x4f5220) = 0;\n    *(unaff_EBX + 0x4f5298) = *(unaff_EBX + 0x4f5298);\n    *(unaff_EBX + 0x4f5298) = *(unaff_EBX + 0x4f5298) + -1;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + -1;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) + -1;\n    *(unaff_EBX + 0x4f5220) = *(unaff_EBX + 0x4f5220) & 0x1ec;\n    *(unaff_EBX + 0x4f5298) = *(unaff_EBX + 0x4f5298) + 1;\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 698
    },
    "0040fd4a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040fd4a(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t in_ECX;\n    uint32_t uVar1;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    uint32_t unaff_EDI;\n    uchar *var_4h;\n    \n    uVar1 = in_ECX;\n    if (var_4h <= &stack0xffffffe4 && &stack0xffffffe4 != var_4h) {\n        uVar1 = in_ECX & unaff_EDI;\n    }\n    if (var_4h < 0x98e6) {\n        *(unaff_EBX + 0x4f5260) = 0xffffffff;\n    }\n    *(unaff_EBX + 0x4f5260) = *(unaff_EBX + 0x4f5260) - in_EDX;\n    *(unaff_EBX + 0x4f5260) = 0xffffffff;\n    *(unaff_EBX + 0x4f5260) = 0;\n    *(unaff_EBX + 0x4f52d4) = *(unaff_EBX + 0x4f52d4) | uVar1 & in_EDX ^ 1;\n    *(unaff_EBX + 0x4f5260) = *(unaff_EBX + 0x4f5260) + -1;\n    *(unaff_EBX + 0x4f551c) = *(unaff_EBX + 0x4f551c) + -1;\n    *(unaff_EBX + 0x4f551c) = 0xffffffff;\n    fcn.00411413(&stack0xfffffffc);\n    *(unaff_EBX + 0x4f52d4) = *(unaff_EBX + 0x4f52d4) + 1;\n    *(unaff_EBX + 0x4f551c) = *(unaff_EBX + 0x4f551c) + -1;\n    *(unaff_EBX + 0x4f52d4) = *(unaff_EBX + 0x4f52d4) | 0xfffff959;\n    *(unaff_EBX + 0x4f52d4) = *(unaff_EBX + 0x4f52d4) + 1;\n    *(unaff_EBX + 0x4f52d4) = *(unaff_EBX + 0x4f52d4) + 0xbe;\n    *(unaff_EBX + 0x4f551c) = *(unaff_EBX + 0x4f551c) + 1;\n    *(unaff_EBX + 0x4f5260) = 0xffffff4b;\n    *(unaff_EBX + 0x4f5260) = 0xfffffbe9;\n    *(unaff_EBX + 0x4f5260) = 0xfffffe3f;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 688
    },
    "00410092": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00410092(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_EAX;\n    int32_t in_ECX;\n    uint extraout_ECX;\n    uint32_t in_EDX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint unaff_EDI;\n    uint arg_10h_00;\n    int32_t var_4h;\n    \n    if ((POPCOUNT(var_4h - 0x2d8bU & 0xff) & 1U) == 0) {\n        in_ECX = 0;\n    }\n    else {\n        in_EAX = 0;\n    }\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + -1;\n    *(unaff_EBX + 0x4f511c) = 0;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) | in_ECX - 1U & 0x387;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + in_EAX + -0x6a5;\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364) - (in_EAX + -0x6a3);\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + 1;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) ^ in_EDX;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) ^ 0xfffffa9e;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + -1;\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364) + 1;\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364);\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364) & 1;\n    *(unaff_EBX + 0x4f5364) = 0;\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364);\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364) ^ (in_EDX + 0x31a | 1) - 0x719;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + 0x20c;\n    fcn.0040dda8(*(unaff_EBX + 0x4f5014));\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + -1;\n    *(unaff_EBX + 0x4f511c) = extraout_ECX;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + -1;\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364) + -1;\n    *(unaff_EBX + 0x4f5364) = *(unaff_EBX + 0x4f5364) + 0x722;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) + extraout_EDX;\n    *(unaff_EBX + 0x4f511c) = *(unaff_EBX + 0x4f511c) ^ 0xfffffaf7;\n    arg_10h_00 = *(unaff_EBX + 0x4f5194);\n    fcn.0040168b(*(unaff_EBX + 0x4f538c), *(unaff_EBX + 0x4f53c4), arg_10h_00);\n    *(unaff_EBX + 0x4f511c) = 0;\n    return CONCAT44(arg_10h_00, unaff_EDI);\n}\n",
        "token_count": 1073
    },
    "00410a3a": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00410a3a(uint arg_8h)\n\n{\n    uint32_t in_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint arg_10h;\n    uint uVar1;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5120) = *(unaff_EBX + 0x4f5120) + 1;\n    *(unaff_EBX + 0x4f5120) = 0xffffff07;\n    *(unaff_EBX + 0x4f523c) = *(unaff_EBX + 0x4f523c) | 1;\n    *(unaff_EBX + 0x4f50d4) = *(unaff_EBX + 0x4f50d4);\n    *(unaff_EBX + 0x4f523c) = *(unaff_EBX + 0x4f523c) - (in_ECX ^ (unaff_ESI - in_ECX | in_ECX) | 0xfffffd0a);\n    uVar1 = 0;\n    fcn.00407201(*(unaff_EBX + 0x4f5230), 0);\n    *(unaff_EBX + 0x4f50d4) = *(unaff_EBX + 0x4f50d4) & 0xfffff9dd;\n    arg_10h = *(unaff_EBX + 0x4f52a0);\n    fcn.0040e470(*(unaff_EBX + 0x4f5528), *(unaff_EBX + 0x4f53f8), arg_10h);\n    *(unaff_EBX + 0x4f50d4) = *(unaff_EBX + 0x4f50d4);\n    *(unaff_EBX + 0x4f523c) = 0;\n    *(unaff_EBX + 0x4f523c) = 0;\n    *(unaff_EBX + 0x4f50d4) = 0;\n    *(unaff_EBX + 0x4f50d4) = *(unaff_EBX + 0x4f50d4) + 1;\n    *(unaff_EBX + 0x4f50d4) = 0xffffffff;\n    *(unaff_EBX + 0x4f523c) = 0;\n    *(unaff_EBX + 0x4f523c) = 0;\n    *(unaff_EBX + 0x4f50d4) = *(unaff_EBX + 0x4f50d4) | 1;\n    *(unaff_EBX + 0x4f5120) = *(unaff_EBX + 0x4f5120) + -1;\n    *(unaff_EBX + 0x4f50d4) = *(unaff_EBX + 0x4f50d4) + -1;\n    return CONCAT44(arg_10h, uVar1);\n}\n",
        "token_count": 685
    },
    "00410d8d": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00410d8d(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t in_ECX;\n    uint32_t extraout_ECX;\n    uint32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5104) = 0;\n    *(unaff_EBX + 0x4f5104) = *(unaff_EBX + 0x4f5104) | 1;\n    *(unaff_EBX + 0x4f547c) = *(unaff_EBX + 0x4f547c) ^ unaff_ESI - 1U;\n    uVar1 = *(unaff_EBX + 0x4f506c);\n    uVar4 = *(unaff_EBX + 0x4f5104) ^ uVar1;\n    *(unaff_EBX + 0x4f506c) = *(unaff_EBX + 0x4f506c) | 1;\n    iVar2 = *(unaff_EBX + 0x4f5104);\n    iVar3 = *(unaff_EBX + 0x4f5104);\n    *(unaff_EBX + 0x4f5104) = *(unaff_EBX + 0x4f5104) + 2;\n    *(unaff_EBX + 0x4f5104) = *(unaff_EBX + 0x4f5104) + -1;\n    *(unaff_EBX + 0x4f547c) = *(unaff_EBX + 0x4f547c) + -1;\n    *(unaff_EBX + 0x4f5104) = *(unaff_EBX + 0x4f5104) | iVar3 - 1U;\n    *(unaff_EBX + 0x4f5104) = *(unaff_EBX + 0x4f5104) + -1;\n    *(unaff_EBX + 0x4f506c) = ((uVar1 - 1) - iVar2) + uVar4;\n    *(unaff_EBX + 0x4f547c) = 1;\n    *(unaff_EBX + 0x4f547c) = 0xa36 - ((in_ECX & arg_8h | uVar4) + 2 | 0xfffffffe);\n    fcn.00407b8c(*(unaff_EBX + 0x4f52fc));\n    *(unaff_EBX + 0x4f506c) = *(unaff_EBX + 0x4f506c);\n    *(unaff_EBX + 0x4f506c) = *(unaff_EBX + 0x4f506c) ^ extraout_ECX;\n    *(unaff_EBX + 0x4f547c) = 0;\n    *(unaff_EBX + 0x4f506c) = *(unaff_EBX + 0x4f506c) + -1;\n    *(unaff_EBX + 0x4f547c) = *(unaff_EBX + 0x4f547c);\n    *(unaff_EBX + 0x4f547c) =\n         *(unaff_EBX + 0x4f547c) + (extraout_EDX ^ 0xfffffa2d) + extraout_ECX + *(unaff_EBX + 0x4f5104) + 600;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 841
    },
    "004110ce": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004110ce(uint arg_8h, uint arg_ch)\n\n{\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint in_stack_ffffffd4;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(unaff_EBX + 0x4f5110) < 0xb242) {\n        unaff_ESI = 0;\n        in_stack_ffffffd4 = *(unaff_EBX + 0x4f5350);\n        fcn.0040131e(0, in_stack_ffffffd4, *(unaff_EBX + 0x4f507c));\n    }\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410);\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110) + 1;\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110);\n    *(unaff_EBX + 0x4f5110) = 0xffffffff;\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410) | 1;\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110) + -1;\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110);\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410) + 1;\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410) + (unaff_ESI - var_4h) + -2;\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110) | 1;\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410) + -1;\n    *(unaff_EBX + 0x4f5410) = 0xfffff8c6;\n    *(unaff_EBX + 0x4f5410) = 0;\n    *(unaff_EBX + 0x4f5410) = *(unaff_EBX + 0x4f5410) + -1;\n    *(unaff_EBX + 0x4f5110) = 0xffffff64;\n    fcn.00403e0f(&stack0xfffffffc);\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110) + 1;\n    *(unaff_EBX + 0x4f5110) = *(unaff_EBX + 0x4f5110);\n    *(unaff_EBX + 0x4f5410) = 0;\n    return CONCAT44(in_stack_ffffffd4, unaff_EDI);\n}\n",
        "token_count": 773
    },
    "00411727": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00411727(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_EAX;\n    int32_t extraout_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uchar *unaff_EDI;\n    uint arg_8h_00;\n    uint arg_8h_01;\n    uint var_8h;\n    uint var_4h;\n    \n    if (-1 < in_EAX + -0x9861) {\n        unaff_ESI = 1;\n    }\n    if (unaff_EDI <= &stack0xfffffffc) {\n        fcn.0040bcfc(in_EAX);\n    }\n    *(unaff_EBX + 0x4f524c) = 1;\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c);\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c) + (unaff_ESI ^ in_EDX);\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c) - (unaff_ESI ^ in_EDX);\n    *(unaff_EBX + 0x4f524c) = 1;\n    arg_8h_01 = *(unaff_EBX + 0x4f53a4);\n    fcn.004104ce(arg_8h_01);\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c);\n    arg_8h_00 = *(unaff_EBX + 0x4f5250);\n    fcn.00405b77(arg_8h_00, *(unaff_EBX + 0x4f5330));\n    *(unaff_EBX + 0x4f524c) = 0xffffffff;\n    *(unaff_EBX + 0x4f524c) = extraout_ECX - *(unaff_EBX + 0x4f524c);\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c);\n    *(unaff_EBX + 0x4f524c) = 1;\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c);\n    fcn.0040200a(*(unaff_EBX + 0x4f5380), *(unaff_EBX + 0x4f53b0));\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c) + -1;\n    *(unaff_EBX + 0x4f524c) = 0xffffffff;\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c) & 0xfffffc16;\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c) & 0xfffffffe;\n    *(unaff_EBX + 0x4f524c) = 0xffffffff;\n    *(unaff_EBX + 0x4f524c) = *(unaff_EBX + 0x4f524c) + -1;\n    return CONCAT44(arg_8h_00, arg_8h_01);\n}\n",
        "token_count": 806
    },
    "00401ce8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00401ce8(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    ulong uVar2;\n    uchar *puVar3;\n    uint arg_8h_00;\n    int32_t var_4h;\n    \n    if (var_4h < 0x19f9) {\n        var_4h = var_4h + 1;\n    }\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434) ^ 0xffffffc7;\n    *(unaff_EBX + 0x4f542c) = *(unaff_EBX + 0x4f542c) + 1;\n    *(unaff_EBX + 0x4f542c) = 0;\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434);\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434) & ((in_ECX | in_EDX) - var_4h) + 2;\n    *(unaff_EBX + 0x4f542c) = 0xffffffff;\n    *(unaff_EBX + 0x4f542c) = 0;\n    arg_8h_00 = *(unaff_EBX + 0x4f5514);\n    fcn.00405513(arg_8h_00, *(unaff_EBX + 0x4f53d0));\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434) + 1;\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434) + 1;\n    *(unaff_EBX + 0x4f542c) = *(unaff_EBX + 0x4f542c) ^ 0xfffffe89;\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434) ^ 0x3d2;\n    puVar3 = &stack0xffffffd8;\n    uVar2 = fcn.0040d3f7(&stack0xffffffd8, *(unaff_EBX + 0x4f5130));\n    *(unaff_EBX + 0x4f5040) = *(unaff_EBX + 0x4f5040) + -1;\n    *(unaff_EBX + 0x4f5434) = *(unaff_EBX + 0x4f5434) | (uVar2 >> 0x20 ^ uVar2) - 1;\n    *(unaff_EBX + 0x4f542c) = *(unaff_EBX + 0x4f542c) + -1;\n    *(unaff_EBX + 0x4f5434) = 0xffffffff;\n    *(unaff_EBX + 0x4f5040) = *(unaff_EBX + 0x4f5040) + -1;\n    iVar1 = fcn.00407519(*(unaff_EBX + 0x4f5000), *(unaff_EBX + 0x4f5458));\n    *(unaff_EBX + 0x4f542c) = *(unaff_EBX + 0x4f542c) - iVar1;\n    *(unaff_EBX + 0x4f542c) = *(unaff_EBX + 0x4f542c) + 1;\n    *(unaff_EBX + 0x4f5040) = *(unaff_EBX + 0x4f5040) + -1;\n    *(unaff_EBX + 0x4f5040) = *(unaff_EBX + 0x4f5040) + -0x747;\n    return CONCAT44(puVar3, arg_8h_00);\n}\n",
        "token_count": 938
    },
    "0040445b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nulong __cdecl fcn.0040445b(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint arg_8h_00;\n    uint var_4h;\n    \n    uVar1 = *(unaff_EBX + 0x4f529c);\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c);\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + -1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + unaff_ESI + (unaff_EDI & uVar1);\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + -1;\n    *(unaff_EBX + 0x4f529c) = 0xffffffff;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) ^ 0x241;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + -1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c);\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + 1;\n    *(unaff_EBX + 0x4f529c) = 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) | in_ECX + 0x265U;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + -1;\n    *(unaff_EBX + 0x4f529c) = 0;\n    arg_8h_00 = *(unaff_EBX + 0x4f520c);\n    fcn.00410d8d(arg_8h_00);\n    *(unaff_EBX + 0x4f529c) = 0;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) - extraout_ECX;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + -1;\n    *(unaff_EBX + 0x4f529c) = 1;\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c);\n    fcn.00401000(*(unaff_EBX + 0x4f5378), *(unaff_EBX + 0x4f54dc));\n    *(unaff_EBX + 0x4f529c) = *(unaff_EBX + 0x4f529c) + -1;\n    return CONCAT44(arg_8h_00, unaff_ESI);\n}\n",
        "token_count": 975
    },
    "00406295": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00406295(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t in_EAX;\n    int32_t arg_8h_00;\n    int32_t extraout_ECX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint arg_10h;\n    uint var_4h;\n    \n    uVar1 = unaff_ESI;\n    if (SBORROW4(arg_8h, 0x38f4)) {\n        *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) & in_EAX;\n        uVar1 = unaff_ESI ^ arg_8h;\n    }\n    uVar2 = uVar1 ^ 0xfffff99b;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) | uVar2;\n    *(unaff_EBX + 0x4f5024) = uVar2;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) + -1;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) & uVar1 - 1;\n    arg_8h_00 = (-1 - (arg_ch + -2)) + (uVar1 - 1);\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + arg_8h_00;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + 1;\n    *(unaff_EBX + 0x4f5024) = uVar2;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + 1;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + 1;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) + 1;\n    *(unaff_EBX + 0x4f5024) = 0xffffffff;\n    arg_10h = *(unaff_EBX + 0x4f526c);\n    fcn.0040857b(arg_8h_00, *(unaff_EBX + 0x4f5448), arg_10h);\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) - (extraout_EDX + -1);\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) + uVar1;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) - (uVar1 + 0xa4a);\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) ^ extraout_ECX - 1U;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + -1;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + 1;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) + 1;\n    *(unaff_EBX + 0x4f5024) = *(unaff_EBX + 0x4f5024) + 1;\n    *(unaff_EBX + 0x4f5328) = *(unaff_EBX + 0x4f5328) - ((extraout_ECX - 1U ^ 0xffffffff) + 1 | 1);\n    return CONCAT44(arg_10h, unaff_ESI);\n}\n",
        "token_count": 1026
    },
    "00407b8c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00407b8c(uint32_t arg_8h)\n\n{\n    int32_t in_EAX;\n    int32_t in_ECX;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    uint32_t extraout_EDX_00;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint unaff_EDI;\n    uint arg_10h;\n    uint var_4h;\n    \n    if (in_EAX <= *(unaff_EBX + 0x4f5004)) {\n        in_EDX = arg_8h;\n    }\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) & in_EDX;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) + -1;\n    *(unaff_EBX + 0x4f53dc) = 1;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) & unaff_ESI;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) | in_ECX + 1U;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) | in_EDX - 2;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) + 0x60c;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004);\n    *(unaff_EBX + 0x4f53dc) = 0xffffffff;\n    fcn.004088a5(*(unaff_EBX + 0x4f5280));\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) + -1;\n    *(unaff_EBX + 0x4f5004) = unaff_ESI + 1;\n    *(unaff_EBX + 0x4f5004) = 0xffffffff;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) + -1;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) + -1;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) ^ 0xfffff9c7;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) + 1;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) + -1;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) | extraout_EDX & extraout_ECX ^ 0xffffffff;\n    arg_10h = *(unaff_EBX + 0x4f54d4);\n    fcn.0040857b(*(unaff_EBX + 0x4f5158), *(unaff_EBX + 0x4f50c4), arg_10h);\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) + 1;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc);\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) + -1;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) + -1;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) & 2;\n    *(unaff_EBX + 0x4f53dc) = *(unaff_EBX + 0x4f53dc) | 2;\n    *(unaff_EBX + 0x4f5004) = 0xfffffc1a;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) | extraout_ECX_00 & extraout_EDX_00 ^ 0x355 | 1;\n    *(unaff_EBX + 0x4f5004) = 0xffffffff;\n    *(unaff_EBX + 0x4f5004) = *(unaff_EBX + 0x4f5004) + 1;\n    return CONCAT44(arg_10h, unaff_EDI);\n}\n",
        "token_count": 1175
    },
    "0040d3f7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040d3f7(uint arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint unaff_EDI;\n    uint arg_ch_00;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5248) = 0xffffffff;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) + -1;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) | unaff_ESI;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) + 1;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) + 1;\n    *(unaff_EBX + 0x4f5010) = *(unaff_EBX + 0x4f5010) + -0x12e;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248);\n    *(unaff_EBX + 0x4f53d4) = *(unaff_EBX + 0x4f53d4) + -1;\n    *(unaff_EBX + 0x4f53d4) = *(unaff_EBX + 0x4f53d4) + 1;\n    *(unaff_EBX + 0x4f53d4) = *(unaff_EBX + 0x4f53d4) + -1;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248);\n    *(unaff_EBX + 0x4f5010) = *(unaff_EBX + 0x4f5010);\n    *(unaff_EBX + 0x4f53d4) = *(unaff_EBX + 0x4f53d4) + 1;\n    *(unaff_EBX + 0x4f5010) = *(unaff_EBX + 0x4f5010);\n    arg_ch_00 = *(unaff_EBX + 0x4f5424);\n    uVar1 = fcn.00405f43(*(unaff_EBX + 0x4f5494), arg_ch_00, *(unaff_EBX + 0x4f54bc));\n    *(unaff_EBX + 0x4f5010) = *(unaff_EBX + 0x4f5010) | uVar1;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) + -1;\n    fcn.0040b019(*(unaff_EBX + 0x4f5114));\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) & 3;\n    *(unaff_EBX + 0x4f53d4) = *(unaff_EBX + 0x4f53d4) | 0x457;\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) - (extraout_ECX + arg_ch + -0x111);\n    *(unaff_EBX + 0x4f5248) = *(unaff_EBX + 0x4f5248) & 0xfffffffd;\n    *(unaff_EBX + 0x4f53d4) = 0;\n    *(unaff_EBX + 0x4f5248) = 0xfffff851;\n    *(unaff_EBX + 0x4f5010) = *(unaff_EBX + 0x4f5010) + -0xae;\n    return CONCAT44(arg_ch_00, unaff_EDI);\n}\n",
        "token_count": 990
    },
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00411413": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00411413(int32_t arg_8h)\n\n{\n    uint32_t in_EAX;\n    uint32_t in_EDX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint32_t uVar1;\n    uint unaff_EDI;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    if (&stack0xfffffffc + -in_EDX < 0) {\n        *(unaff_EBX + 0x4f51b8) = *(unaff_EBX + 0x4f51b8) & in_EAX;\n        *(unaff_EBX + 0x4f51b8) = 0x235;\n    }\n    else {\n        arg_8h = arg_8h + 1;\n    }\n    uVar1 = unaff_ESI + arg_8h;\n    if ((POPCOUNT(*(unaff_EBX + 0x4f52c4) - 0x9d9dU & 0xff) & 1U) != 0) {\n        uVar1 = uVar1 - 1;\n    }\n    *(unaff_EBX + 0x4f5238) = *(unaff_EBX + 0x4f5238);\n    *(unaff_EBX + 0x4f51b8) = 1;\n    *(unaff_EBX + 0x4f51b8) = *(unaff_EBX + 0x4f51b8);\n    *(unaff_EBX + 0x4f52c4) = *(unaff_EBX + 0x4f52c4);\n    *(unaff_EBX + 0x4f5238) = *(unaff_EBX + 0x4f5238) + -1;\n    uVar1 = ((((uVar1 ^ 1) & in_EDX) + 1) - var_8h ^ 2) + 2;\n    *(unaff_EBX + 0x4f5238) = *(unaff_EBX + 0x4f5238) - (((var_8h & 1) + 1 ^ uVar1) - *(unaff_EBX + 0x4f5238) | uVar1);\n    *(unaff_EBX + 0x4f51b8) = *(unaff_EBX + 0x4f51b8) + 1;\n    *(unaff_EBX + 0x4f51b8) = *(unaff_EBX + 0x4f51b8);\n    fcn.004065e0(*(unaff_EBX + 0x4f540c), *(unaff_EBX + 0x4f5124));\n    *(unaff_EBX + 0x4f5238) = 0;\n    *(unaff_EBX + 0x4f5238) = *(unaff_EBX + 0x4f5238) + extraout_EDX;\n    *(unaff_EBX + 0x4f51b8) = 1;\n    *(unaff_EBX + 0x4f51b8) = *(unaff_EBX + 0x4f51b8) + -1;\n    *(unaff_EBX + 0x4f51b8) = *(unaff_EBX + 0x4f51b8) + 1;\n    return CONCAT44(unaff_EDI, in_EDX);\n}\n",
        "token_count": 781
    },
    "00402a00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint64_t __cdecl fcn.00402a00(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t arg_8h_00;\n    uint32_t arg_ch_00;\n    uint32_t in_EDX;\n    uint32_t extraout_EDX;\n    uint32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = arg_8h - 1;\n    if (arg_8h_00 == 0) {\n        return in_EDX << 0x20;\n    }\n    if (arg_10h != 0) {\n        arg_ch_00 = (unaff_EBX ^ arg_8h_00 + arg_10h) & arg_ch;\n        if (arg_8h_00 != arg_ch) {\n            fcn.00402a00(arg_8h_00, arg_ch_00, unaff_ESI + arg_ch_00);\n            in_EDX = extraout_EDX;\n        }\n    }\n    return in_EDX << 0x20;\n}\n",
        "token_count": 291
    },
    "00406c80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.00406c80(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint in_EAX;\n    uint extraout_ECX;\n    uint uVar2;\n    uint extraout_ECX_00;\n    uint32_t *puVar3;\n    uint uVar4;\n    int32_t unaff_EBX;\n    uchar *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint32_t uVar9;\n    ulong uVar10;\n    code *in_stack_004f81e4;\n    int32_t iVar11;\n    int32_t iStack32;\n    \n    if (*(unaff_EBX + 0x4f51d4) == 0) {\n        in_EAX = (**(sym.imp.user32.dll_GetCaretBlinkTime + unaff_EBX))();\n        *(unaff_EBX + 0x4f51d4) = in_EAX;\n    }\n    iVar7 = param_1 + *(param_1 + 0x3c);\n    if (*(iVar7 + 0x80) == 0) {\n        return in_EAX;\n    }\n    piVar6 = *(iVar7 + 0x80) + param_1;\n    puVar5 = &stack0xfffffffc;\n    do {\n        if (*piVar6 == 0) {\n            iVar7 = piVar6[4];\n        }\n        else {\n            *(puVar5 + -0x10) = *piVar6;\n            iVar7 = *(puVar5 + -0x10);\n        }\n        *(puVar5 + -8) = piVar6[4];\n        *(puVar5 + -0x10) = *(puVar5 + 8);\n        iVar11 = *(puVar5 + -0x10);\n        *(puVar5 + -0x10) = iVar7;\n        iVar7 = *(puVar5 + -0x10);\n        *(puVar5 + -8) = iVar11 + *(puVar5 + -8);\n        iStack32 = piVar6[3] + *(puVar5 + 8);\n        *(puVar5 + -0x10) = piVar6;\n        puVar8 = *(puVar5 + 8) + iVar7;\n        puVar3 = *(puVar5 + -0x10);\n        (**(sym.imp.kernel32.dll_GetModuleHandleA + unaff_EBX))();\n        uVar9 = 0;\n        uVar10 = (*in_stack_004f81e4)(iVar11);\n        uVar4 = uVar10 >> 0x20;\n        *(puVar8 + -0x10) = &iStack32;\n        *(puVar8 + -0xc) = uVar10;\n        unaff_EBX = *(puVar8 + -0x10);\n        uVar2 = extraout_ECX;\n        do {\n            if ((*puVar3 & 0x80000000) == 0) {\n                uVar1 = *puVar3;\n                *(puVar8 + -0x10) = uVar4;\n                *(puVar8 + -0x10) = uVar9;\n                *(puVar8 + -4) = 0;\n                *(puVar8 + -4) = *(puVar8 + -4) ^ uVar9 ^ *(puVar8 + -0x10) ^ *(puVar8 + 8) + uVar1 + 2;\n                uVar9 = *(puVar8 + -0x10);\n                *(puVar8 + -0x10) = puVar3;\n                puVar3 = *(puVar8 + -0x10);\n            }\n            else {\n                *(puVar8 + -4) = *puVar3;\n                *(puVar8 + -4) = *(puVar8 + -4) & 0xffff;\n            }\n            iStack32 = *(puVar8 + -4);\n            *(puVar8 + -0x10) = uVar2;\n            uVar10 = (**(sym.imp.kernel32.dll_GetProcAddress + unaff_EBX))(*(puVar8 + -0xc));\n            uVar4 = uVar10 >> 0x20;\n            *(puVar8 + -0x10) = uVar10;\n            *(puVar8 + -0x10) = *(puVar8 + -0x10);\n            **(puVar8 + -8) = *(puVar8 + -0x10);\n            *(puVar8 + -0x10) = puVar3;\n            puVar3 = *(puVar8 + -0x10) + 4;\n            *(puVar8 + -0x10) = uVar9;\n            uVar9 = *(puVar8 + -0x10);\n            *(puVar8 + -8) = *(puVar8 + -8) + 4;\n            uVar2 = extraout_ECX_00;\n        } while (*puVar3 != 0);\n        piVar6 = uVar9 + 0x14;\n        puVar5 = puVar8;\n    } while ((*piVar6 != 0) || (*(uVar9 + 0x24) != 0));\n    return 0;\n}\n",
        "token_count": 1154
    },
    "004095dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004095dc(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = 3;\n    do {\n        iVar1 = iVar1 + -1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 75
    },
    "0040af03": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n\ncode * __cdecl fcn.0040af03(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    code *in_EAX;\n    uint unaff_EBX;\n    int32_t iVar2;\n    uint unaff_ESI;\n    uchar *puVar3;\n    code **ppcVar4;\n    uint unaff_EDI;\n    uchar *puVar5;\n    int32_t in_FS_OFFSET;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h = arg_8h + *(arg_8h + 0x3c);\n    iVar2 = *(arg_8h + 0xc0);\n    if (iVar2 != 0) {\n        piVar1 = iVar2 + *(arg_8h + 0x34);\n        puVar3 = *piVar1;\n        puVar5 = **(in_FS_OFFSET + 0x2c);\n        for (iVar2 = piVar1[1] - *piVar1; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = *puVar3;\n            puVar3 = puVar3 + 1;\n            puVar5 = puVar5 + 1;\n        }\n        if (piVar1[3] != 0) {\n            for (ppcVar4 = piVar1[3]; *ppcVar4 != NULL; ppcVar4 = ppcVar4 + 1) {\n                in_EAX = *ppcVar4;\n                if (in_EAX != NULL) {\n                    in_EAX = (**ppcVar4)(0x400000, 1, 0, unaff_EDI, unaff_ESI, unaff_EBX);\n                }\n            }\n        }\n    }\n    return in_EAX;\n}\n",
        "token_count": 414
    },
    "0040c2c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t fcn.0040c2c5(uint8_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint32_t in_EAX;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t unaff_EBX;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint32_t uStack24;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    int32_t iStack8;\n    \n    iVar1 = *(param_2 + 0xc);\n    uVar2 = *(param_2 + 4);\n    if (iVar1 == 1) {\n        uStack12 = 7;\n        uStack24 = 1;\n        uStack16 = 8;\n    }\n    if (iVar1 == 0) {\n        if (*(unaff_EBX + 0x4f52b8) == 0) {\n            in_EAX = (**(sym.imp.kernel32.dll_GetConsoleCP + unaff_EBX))();\n            *(unaff_EBX + 0x4f52b8) = 0;\n            *(unaff_EBX + 0x4f52b8) = *(unaff_EBX + 0x4f52b8) ^ in_EAX;\n        }\n        return in_EAX;\n    }\n    if (iVar1 == 2) {\n        uStack12 = 3;\n        uStack24 = 0x11;\n        uStack16 = 4;\n    }\n    else if (iVar1 == 4) {\n        uStack12 = 1;\n        uStack24 = 0x55;\n        uStack16 = 2;\n    }\n    uVar4 = uVar2 / uStack16;\n    uVar5 = uVar2 % uStack16;\n    iStack8 = uVar2 - uVar5;\n    puVar6 = param_1 + -1;\n    do {\n        puVar7 = puVar6;\n        if ((param_1 & uStack12) == 0) {\n            puVar7 = puVar6 + 1;\n            unaff_EBX = puVar7[uStack16];\n            uVar4 = uStack16;\n        }\n        uVar3 = param_1 & uStack12 & 0x1f;\n        puVar6 = puVar7 + 1;\n        uVar3 = *puVar7 | (uStack24 << uVar3 | uStack24 >> 0x20 - uVar3) & unaff_EBX;\n        uVar4 = uVar4 & 0xffffff00 | uVar3;\n        *param_1 = uVar3;\n        param_1 = param_1 + 1;\n        iStack8 = iStack8 + -1;\n    } while (iStack8 != 0);\n    puVar6 = puVar7 + 2;\n    for (; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *param_1 = *puVar6;\n        puVar6 = puVar6 + 1;\n        param_1 = param_1 + 1;\n    }\n    return uVar4;\n}\n",
        "token_count": 736
    },
    "0040ee32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: dwSize\n\nvoid __cdecl fcn.0040ee32(uchar *arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    int32_t unaff_EBX;\n    uchar *puVar5;\n    uchar *puVar6;\n    uchar *puVar7;\n    uint lpflOldProtect;\n    uint dwSize;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    if (*(unaff_EBX + 0x4f5348) == 0) {\n        uVar1 = (**(sym.imp.kernel32.dll_GetConsoleCP + unaff_EBX))();\n        *(unaff_EBX + 0x4f5348) = uVar1;\n    }\n    puVar3 = arg_8h + *(arg_8h + 0x3c);\n    var_4h = *(puVar3 + 6);\n    iVar4 = *(puVar3 + 0x54);\n    iVar2 = iVar4;\n    puVar5 = arg_8h;\n    puVar6 = *(unaff_EBX + 0x4f51fc);\n    puVar7 = puVar3;\n    if (*(unaff_EBX + 0x4f51fc) != arg_8h) {\n        do {\n            *puVar6 = *puVar5;\n            iVar2 = iVar2 + -1;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        } while (iVar2 != 0);\n        *(unaff_EBX + 0x4f50e8) = 0x40;\n        (**(sym.imp.kernel32.dll_VirtualProtect + unaff_EBX))(*(unaff_EBX + 0x4f51fc), iVar4, 2, unaff_EBX + 0x4f50e8);\n    }\n    puVar3 = puVar3 + 0xf8;\n    do {\n        puVar5 = arg_8h + *(puVar3 + 0x14);\n        puVar6 = *(puVar3 + 0xc) + *(unaff_EBX + 0x4f51fc);\n        for (iVar4 = *(puVar3 + 0x10); iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar6 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        }\n        puVar3 = puVar3 + 0x28;\n        var_4h = var_4h - 1;\n    } while (var_4h != 0);\n    *(unaff_EBX + 0x4f53c0) = *(puVar7 + 0x28) + *(unaff_EBX + 0x4f51fc);\n    iVar4 = *(unaff_EBX + 0x4f51fc);\n    if (iVar4 != 0) {\n        fcn.00406c80(iVar4);\n        fcn.0040aa03(iVar4);\n        fcn.0040af03(*(unaff_EBX + 0x4f51d0));\n    }\n    return;\n}\n",
        "token_count": 734
    },
    "004107dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.004107dc(int32_t *param_1, uint8_t *param_2)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint32_t uVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint16_t uVar9;\n    int32_t unaff_EBX;\n    int32_t iVar10;\n    uint unaff_ESI;\n    uint8_t *puVar11;\n    uint8_t *puVar12;\n    uint8_t *puVar13;\n    uint8_t *puVar14;\n    int32_t *piVar15;\n    uint8_t *puStackY32;\n    int32_t iStack8;\n    \n    if (*(unaff_EBX + 0x4f510c) == 0) {\n        uVar3 = (**(sym.imp.user32.dll_GetWindowThreadProcessId + unaff_EBX))\n                          (*(unaff_EBX + 0x4f521c), *(unaff_EBX + 0x4f5160));\n        *(unaff_EBX + 0x4f510c) = uVar3;\n    }\n    if (*(unaff_EBX + 0x4f5224) == 0) {\n        uVar3 = (**(sym.imp.kernel32.dll_GetACP + unaff_EBX))(unaff_ESI);\n        *(unaff_EBX + 0x4f5224) = uVar3;\n    }\n    puVar4 = *(unaff_EBX + 0x4f500c) + -0x10;\n    puVar6 = puVar4;\n    puVar11 = param_1 + *param_1;\n    puVar13 = param_2;\n    do {\n        *puVar13 = *puVar11;\n        puVar6 = puVar6 + -1;\n        puVar12 = param_2;\n        puVar11 = puVar11 + 1;\n        puVar14 = param_2;\n        puVar13 = puVar13 + 1;\n        puStackY32 = puVar4;\n    } while (puVar6 != NULL);\n    do {\n        uVar2 = *puVar12;\n        uVar5 = uVar2;\n        puVar12 = puVar12 + 1;\n        if (uVar5 != 0) {\n            uVar9 = 0;\n            iStack8 = 8;\n            do {\n                uVar1 = uVar5 << 1;\n                uVar5 = uVar1 & 0xffff0000 | CONCAT11(puVar12 >> 8, uVar1 | uVar5 < 0);\n                uVar9 = (uVar9 & 0xff | (uVar1 >> 8) << 8) >> 1;\n                iStack8 = iStack8 + -1;\n            } while (iStack8 != 0);\n            uVar2 = uVar9;\n            puStackY32 = puVar12;\n        }\n        *puVar14 = uVar2;\n        puVar4 = puVar4 + -1;\n        puVar14 = puVar14 + 1;\n    } while (puVar4 != NULL);\n    if ((param_1 != NULL) && (param_2 != NULL)) {\n        puStackY32 = param_2;\n        fcn.0040c2c5();\n    }\n    if (puStackY32 != NULL) {\n        iVar8 = param_1[1];\n        iVar10 = param_1[2];\n        puVar6 = param_2 + (iVar8 - iVar10);\n        piVar15 = param_1;\n        for (iVar7 = param_1[2]; iVar7 != 0; iVar7 = iVar7 + -1) {\n            *piVar15 = *puVar6;\n            puVar6 = puVar6 + 1;\n            piVar15 = piVar15 + 1;\n        }\n        puVar6 = param_2;\n        for (iVar10 = iVar8 - iVar10; iVar10 != 0; iVar10 = iVar10 + -1) {\n            *piVar15 = *puVar6;\n            puVar6 = puVar6 + 1;\n            piVar15 = piVar15 + 1;\n        }\n        for (; iVar8 != 0; iVar8 = iVar8 + -1) {\n            *param_2 = *param_1;\n            param_1 = param_1 + 1;\n            param_2 = param_2 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 1033
    },
    "0040aa03": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.0040aa03(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t unaff_EBX;\n    int32_t iVar8;\n    \n    if (param_1 != 0) {\n        param_1 = param_1 + *(param_1 + 0x3c);\n        iVar2 = *(param_1 + 0x34);\n        iVar8 = *(unaff_EBX + 0x4f51fc) - iVar2;\n        param_1 = *(param_1 + 0x14) + param_1;\n        iVar7 = *(param_1 + -0x40);\n        if (iVar7 != 0) {\n            piVar5 = iVar2 + iVar8 + iVar7;\n            for (iVar7 = *(param_1 + -0x3c); iVar7 != 0; iVar7 = iVar7 - iVar4) {\n                iVar3 = *piVar5;\n                iVar4 = piVar5[1];\n                piVar5 = piVar5 + 2;\n                for (uVar6 = iVar4 - 8U >> 1; uVar6 != 0; uVar6 = uVar6 - 1) {\n                    if ((*piVar5 & 0xf000) != 0) {\n                        piVar1 = (*piVar5 & 0xfff) + iVar3 + iVar8 + iVar2;\n                        *piVar1 = *piVar1 + iVar8;\n                    }\n                    piVar5 = piVar5 + 2;\n                }\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 409
    },
    "00402675": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402675(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_10h;\n    uint32_t arg_ch_00;\n    uint var_4h;\n    \n    arg_10h = arg_8h;\n    arg_ch_00 = arg_8h;\n    do {\n        arg_ch_00 = arg_8h ^ arg_ch_00 + arg_10h;\n        if (arg_10h < arg_ch_00) {\n            uVar1 = arg_ch;\n            fcn.00402a00(arg_ch, arg_ch_00, arg_10h);\n            arg_10h = uVar1;\n        }\n        arg_10h = arg_10h - 1;\n    } while (arg_10h != 0);\n    return 0;\n}\n",
        "token_count": 192
    },
    "0040857b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040857b(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t in_ECX;\n    uint32_t uVar1;\n    int32_t in_EDX;\n    int32_t unaff_EBX;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    uint32_t var_4h;\n    \n    if (*(unaff_EBX + 0x4f54a0) + -0x6d51 < 0) {\n        *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) & 0xfffffdda;\n        uVar1 = in_ECX;\n    }\n    else {\n        uVar1 = in_ECX - 1;\n    }\n    *(unaff_EBX + 0x4f54a0) = *(unaff_EBX + 0x4f54a0) ^ uVar1;\n    if (var_4h <= unaff_ESI - 1U) {\n        *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c);\n    }\n    *(unaff_EBX + 0x4f536c) = 1;\n    *(unaff_EBX + 0x4f536c) = 0xfffff82d;\n    *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) + -1;\n    *(unaff_EBX + 0x4f54a0) = 0;\n    *(unaff_EBX + 0x4f536c) = 0xffffffff;\n    *(unaff_EBX + 0x4f54a0) = *(unaff_EBX + 0x4f54a0) + 0x4fe;\n    *(unaff_EBX + 0x4f54a0) = *(unaff_EBX + 0x4f54a0) ^ in_EDX - 1U;\n    *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) + 1;\n    *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) - (unaff_ESI - (unaff_EDI + uVar1));\n    *(unaff_EBX + 0x4f54a0) = *(unaff_EBX + 0x4f54a0) + 1;\n    *(unaff_EBX + 0x4f54a0) = *(unaff_EBX + 0x4f54a0) + -1;\n    *(unaff_EBX + 0x4f536c) = 0;\n    *(unaff_EBX + 0x4f54a0) = *(unaff_EBX + 0x4f54a0) + 1;\n    *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) + -0x1e9;\n    *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) + 0x48d;\n    fcn.004047c6(*(unaff_EBX + 0x4f52e8));\n    *(unaff_EBX + 0x4f536c) = 1;\n    *(unaff_EBX + 0x4f54a0) = 0xfffffe2d;\n    *(unaff_EBX + 0x4f54a0) = 0xfffffffe;\n    *(unaff_EBX + 0x4f536c) = 0xffffffff;\n    *(unaff_EBX + 0x4f536c) = 0;\n    *(unaff_EBX + 0x4f536c) = *(unaff_EBX + 0x4f536c) + 1;\n    return CONCAT44(unaff_ESI, in_ECX);\n}\n",
        "token_count": 924
    },
    "004104ce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004104ce(uint arg_8h)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uint unaff_ESI;\n    int32_t unaff_EDI;\n    ulong uVar1;\n    uint arg_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) ^ 0xffffffff;\n    *(unaff_EBX + 0x4f5510) = *(unaff_EBX + 0x4f5510) + 1;\n    *(unaff_EBX + 0x4f5510) = *(unaff_EBX + 0x4f5510) & 0x431;\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) + 1;\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) & unaff_EDI + 0x7c8U;\n    *(unaff_EBX + 0x4f5510) = *(unaff_EBX + 0x4f5510) + 1;\n    arg_ch = *(unaff_EBX + 0x4f5258);\n    fcn.00407efd(&stack0xfffffffc, arg_ch);\n    *(unaff_EBX + 0x4f5294) = 0;\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) + -1;\n    *(unaff_EBX + 0x4f5294) = 0xffffffff;\n    uVar1 = fcn.00407b8c(*(unaff_EBX + 0x4f5390));\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) + -0x99;\n    *(unaff_EBX + 0x4f5510) = uVar1 + -0x307;\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) - (extraout_ECX - 1U);\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) | extraout_ECX - 1U;\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) ^ (uVar1 >> 0x20) * 2;\n    *(unaff_EBX + 0x4f5294) = 0;\n    *(unaff_EBX + 0x4f5510) = *(unaff_EBX + 0x4f5510) + -1;\n    *(unaff_EBX + 0x4f5294) = *(unaff_EBX + 0x4f5294) ^ 1U - *(unaff_EBX + 0x4f5294);\n    return CONCAT44(arg_ch, unaff_ESI);\n}\n",
        "token_count": 730
    }
}