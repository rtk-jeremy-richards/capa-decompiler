{
    "004091ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004091ae(uint *param_1)\n\n{\n    *param_1 = 0x401690;\n    if (param_1[2] != 0) {\n        fcn.004098aa(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint main(void)\n\n{\n    int32_t iVar1;\n    uint var_a0h;\n    uint var_98h;\n    uint var_18h;\n    \n    if (*0x69af70 == 3) {\n        fcn.00409f4c(0x5413a8, 0);\n        fcn.00409e93(0, 0);\n        fcn.0040775a();\n        fcn.004086b4(3, 1);\n        fcn.004085af(0x4013e8);\n        fcn.00409d7c();\n        fcn.00409ce7();\n    }\n    *0x69af70 = *0x4225a4;\n    iVar1 = 0;\n    do {\n        if (iVar1 == 0x1737) {\n            *0x69af74 = *0x421008;\n        }\n        iVar1 = iVar1 + 1;\n    } while (iVar1 < 0x79a863);\n    fcn.00404ae9();\n    return 0;\n}\n",
        "token_count": 235
    },
    "004051be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t * __cdecl fcn.004051be(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x401614;\n        fcn.0040507e();\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    cVar1 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = 0x401414;\n    if (cVar1 != '\\0') {\n        fcn.00408d23(*(*extraout_ECX + 4) + extraout_ECX);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 317
    },
    "004052b8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004052b8(uint32_t arg_8h)\n\n{\n    uint32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((arg_8h != 0) && (in_EAX = fcn.0040505c(),  in_EAX <= arg_8h)) {\n        iVar1 = fcn.0040505c();\n        in_EAX = iVar1 + *(in_ECX + 0x14);\n        if (arg_8h < in_EAX) {\n            return CONCAT31(in_EAX >> 8, 1);\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 155
    },
    "0040532c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040532c(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint var_ch;\n    \n    if (arg_8h == 0) {\n        arg_8h = 0;\n    }\n    else if (0xffffffff / arg_8h == 0) {\n        fcn.004042d0(0);\n        fcn.00409853(&var_ch, 0x41e594);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    fcn.004097ee(arg_8h);\n    return;\n}\n",
        "token_count": 138
    },
    "00405934": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405934(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.004050a9();\n    if ((iVar1 != 0) && (uVar2 = fcn.004050a9(),  *(in_ECX + 0x3c) < uVar2)) {\n        uVar3 = fcn.004050a9();\n        *(in_ECX + 0x3c) = uVar3;\n    }\n    if (((arg_14h & 1) == 0) || (iVar4 = fcn.004050a3(),  iVar1 = *0x401654,  iVar4 == 0)) {\n        iVar1 = *0x401654;\n        if (((arg_14h & 2) != 0) && (iVar4 = fcn.004050a9(),  iVar1 = *0x401654,  iVar4 != 0)) {\n            if (arg_10h == 2) {\n                iVar4 = fcn.0040509d();\n                arg_ch = arg_ch + (*(in_ECX + 0x3c) - iVar4);\n            }\n            else if (arg_10h == 1) {\n                iVar4 = fcn.004050a9();\n                iVar5 = fcn.0040509d();\n                arg_ch = arg_ch + (iVar4 - iVar5);\n            }\n            else if (arg_10h != 0) {\n                arg_ch = *0x401654;\n            }\n            if ((-1 < arg_ch) && (iVar4 = fcn.0040509d(),  arg_ch <= *(in_ECX + 0x3c) - iVar4)) {\n                iVar1 = fcn.004050a9();\n                iVar4 = fcn.0040509d();\n                fcn.004056c0((arg_ch - iVar1) + iVar4);\n                iVar1 = arg_ch;\n            }\n        }\n        goto code_r0x00405acc;\n    }\n    if (arg_10h == 2) {\n        iVar4 = fcn.0040509d();\n        arg_ch = arg_ch + (*(in_ECX + 0x3c) - iVar4);\n    }\n    else if (arg_10h == 1) {\n        if ((arg_14h & 2) == 0) {\n            iVar4 = fcn.004050a3();\n            iVar5 = fcn.0040509d();\n            arg_ch = arg_ch + (iVar4 - iVar5);\n        }\n        else {\ncode_r0x004059ba:\n            arg_ch = *0x401654;\n        }\n    }\n    else if (arg_10h != 0) goto code_r0x004059ba;\n    if ((-1 < arg_ch) && (iVar4 = fcn.0040509d(),  arg_ch <= *(in_ECX + 0x3c) - iVar4)) {\n        iVar1 = fcn.004050a3();\n        iVar4 = fcn.0040509d();\n        fcn.0040568d((arg_ch - iVar1) + iVar4);\n        iVar1 = arg_ch;\n        if (((arg_14h & 2) != 0) && (iVar4 = fcn.004050a9(),  iVar4 != 0)) {\n            uVar3 = fcn.004050db();\n            arg_ch_00 = fcn.004050a3();\n            arg_8h_00 = fcn.004057b8();\n            fcn.00405104(arg_8h_00, arg_ch_00, uVar3);\n        }\n    }\ncode_r0x00405acc:\n    fcn.004056e3(iVar1);\n    return arg_8h;\n}\n",
        "token_count": 908
    },
    "00405d4d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00405d4d(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = fcn.00405660();\n    if (uVar1 < 2) {\n        return 1;\n    }\n    return uVar1 - 1;\n}\n",
        "token_count": 64
    },
    "00405f69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405f69(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint *arg_ch_00;\n    uint arg_10h_00;\n    \n    if (arg_ch == 1) {\n        arg_ch_00 = &arg_10h;\n        iVar1 = fcn.0040505c();\n        fcn.0040431e(iVar1 + arg_8h, arg_ch_00);\n    }\n    else {\n        arg_10h_00 = arg_10h;\n        iVar1 = fcn.0040505c();\n        fcn.00405ddb(iVar1 + arg_8h, arg_ch, arg_10h_00);\n    }\n    return;\n}\n",
        "token_count": 175
    },
    "00406316": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00406316(uint32_t arg_8h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint arg_10h;\n    uint arg_8h_00;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uchar *puVar10;\n    int32_t in_ECX;\n    bool bVar11;\n    int32_t in_stack_ffffffc0;\n    int32_t arg_10h_00;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if (((*(in_ECX + 0x40) & 8) != 0) && (iVar3 = fcn.004050a9(),  iVar3 != 0)) {\n        uVar5 = *(in_ECX + 0x3c);\n        uVar4 = fcn.004050a9();\n        if (uVar4 < uVar5) {\n            arg_10h = fcn.004050db();\n            arg_8h_00 = fcn.004057b8();\n            fcn.00405104(arg_8h_00, uVar5, arg_10h);\n        }\n    }\n    uVar5 = fcn.00405660();\n    var_ch = uVar5;\n    cVar1 = fcn.0040564c(&fcn.00406316::var_ch, &fcn.00406316::arg_8h);\n    if (cVar1 != '\\0') {\n        uVar5 = fcn.0040579c(&fcn.00406316::arg_8h);\n        return uVar5;\n    }\n    iVar3 = fcn.004050a9();\n    if (iVar3 != 0) {\n        uVar4 = fcn.004050db();\n        uVar6 = fcn.004050a9();\n        if (uVar6 < uVar4) goto code_r0x004064c7;\n    }\n    if ((*(in_ECX + 0x40) & 2) != 0) {\n        return uVar5;\n    }\n    iVar3 = fcn.004050a9();\n    if (iVar3 == 0) {\n        var_4h = 0;\n    }\n    else {\n        iVar3 = fcn.004050db();\n        iVar9 = fcn.0040509d();\n        var_4h = iVar3 - iVar9;\n    }\n    uVar5 = var_4h;\n    var_ch = 0x20;\n    if (0x1f < var_4h >> 1) {\n        var_ch = var_4h >> 1;\n    }\n    iVar3 = 0;\n    var_8h = fcn.0040509d();\n    uVar4 = var_ch;\n    if (var_ch != 0) {\n        do {\n            if (var_4h <= 0x7fffffff - uVar4) break;\n            uVar4 = uVar4 >> 1;\n        } while (uVar4 != 0);\n        if (uVar4 != 0) {\n            uVar5 = uVar4 + var_4h;\n            iVar3 = fcn.00405c9c(uVar5);\n        }\n    }\n    bVar11 = var_4h == 0;\n    if (!bVar11) {\n        in_stack_ffffffc0 = 0x406435;\n        fcn.00405d6e(iVar3, uVar5, var_8h, var_4h);\n        bVar11 = var_4h == 0;\n    }\n    iVar9 = iVar3;\n    if (bVar11) {\n        *(in_ECX + 0x3c) = iVar3;\n        fcn.004050e6(iVar3, iVar3 + uVar5);\n        if ((*(in_ECX + 0x40) & 4) != 0) {\ncode_r0x00406452:\n            in_stack_ffffffc0 = 0;\n        }\n    }\n    else {\n        *(in_ECX + 0x3c) = *(in_ECX + 0x3c) + (iVar3 - var_8h);\n        var_ch = iVar3 - var_8h;\n        arg_10h_00 = iVar3 + uVar5;\n        iVar7 = fcn.004050a9();\n        iVar7 = iVar7 + var_ch;\n        iVar8 = fcn.004057b8();\n        fcn.00405104(iVar8 + var_ch, iVar7, arg_10h_00);\n        if ((*(in_ECX + 0x40) & 4) != 0) goto code_r0x00406452;\n        iVar9 = fcn.004050a9();\n        iVar9 = iVar9 + 1;\n        in_stack_ffffffc0 = fcn.004050a3();\n        in_stack_ffffffc0 = in_stack_ffffffc0 + var_ch;\n    }\n    fcn.004050ba(iVar3, in_stack_ffffffc0, iVar9);\n    if ((*(in_ECX + 0x40) & 1) != 0) {\n        fcn.0040506a(var_8h);\n    }\n    *(in_ECX + 0x40) = *(in_ECX + 0x40) | 1;\ncode_r0x004064c7:\n    puVar10 = fcn.004057be();\n    uVar2 = fcn.00405637(&fcn.00406316::arg_8h);\n    *puVar10 = uVar2;\n    return arg_8h;\n}\n",
        "token_count": 1287
    },
    "004064eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004064eb(uint arg_8h, int32_t arg_ch)\n\n{\n    uint arg_10h;\n    int32_t in_ECX;\n    \n    if ((arg_8h != '\\0') && (0xf < *(in_ECX + 0x18))) {\n        arg_10h = *(in_ECX + 4);\n        if (arg_ch != 0) {\n            fcn.00405d6e(in_ECX + 4, 0x10, arg_10h, arg_ch);\n        }\n        fcn.0040506a(arg_10h);\n    }\n    *(in_ECX + 0x18) = 0xf;\n    fcn.00405cba(arg_ch);\n    return;\n}\n",
        "token_count": 166
    },
    "0040664d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040664d(uint noname_0, uint *arg_ch, uint arg_10h, uint arg_14h, uint8_t *arg_18h, int32_t arg_1ch)\n\n{\n    if (arg_1ch != 0) {\n        fcn.00405125();\n        do {\n            fcn.00406020(*arg_18h);\n            arg_1ch = arg_1ch + -1;\n            arg_18h = arg_18h + 1;\n        } while (arg_1ch != 0);\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    return;\n}\n",
        "token_count": 156
    },
    "0040668c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040668c(uint noname_0, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    if (arg_1ch != 0) {\n        fcn.00405125();\n        do {\n            fcn.00406020(arg_18h);\n            arg_1ch = arg_1ch + -1;\n        } while (arg_1ch != 0);\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    return;\n}\n",
        "token_count": 138
    },
    "004066c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.004066c0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint arg_8h_00;\n    uint arg_10h;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar3;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint uVar4;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = &var_18h;\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    uVar3 = *(unaff_EBP + 8) | 0xf;\n    uVar2 = fcn.00405d4d();\n    *(unaff_EBP + -0x1c) = uVar2;\n    if (uVar2 < uVar3) {\n        uVar3 = *(unaff_EBP + 8);\n    }\n    else {\n        uVar2 = *(extraout_ECX + 0x18);\n        *(unaff_EBP + -0x14) = uVar2;\n        *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) >> 1;\n        uVar1 = *(unaff_EBP + -0x14);\n        if ((uVar3 / 3 < uVar1) && (uVar2 <= *(unaff_EBP + -0x1c) - uVar1)) {\n            uVar3 = uVar1 + uVar2;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = fcn.00405c9c(uVar3 + 1);\n    if (*(unaff_EBP + 0xc) != 0) {\n        uVar4 = *(unaff_EBP + 0xc);\n        arg_10h = fcn.0040505c();\n        fcn.00405d6e(arg_8h_00, uVar3 + 1, arg_10h, uVar4);\n    }\n    fcn.004064eb(1, 0);\n    uVar4 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 4) = arg_8h_00;\n    *(extraout_ECX + 0x18) = uVar3;\n    fcn.00405cba(uVar4);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 700
    },
    "004067ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004067ac(uint arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, uint8_t *arg_18h, int32_t arg_1ch)\n\n{\n    uint32_t uVar1;\n    \n    if (arg_1ch != 0) {\n        fcn.00405125();\n        do {\n            uVar1 = fcn.00405fa3(*arg_18h);\n            fcn.00406020(uVar1 & 0xff);\n            arg_1ch = arg_1ch + -1;\n            arg_18h = arg_18h + 1;\n        } while (arg_1ch != 0);\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    return;\n}\n",
        "token_count": 184
    },
    "00406802": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.00406802(uint arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, int32_t arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t arg_1ch_00;\n    uint var_10h;\n    uint var_8h;\n    \n    while( true ) {\n        iVar2 = fcn.00409b50(arg_18h, 0, arg_1ch);\n        arg_1ch_00 = arg_1ch;\n        if (iVar2 != 0) {\n            arg_1ch_00 = iVar2 - arg_18h;\n        }\n        puVar3 = fcn.004067ac(arg_8h, &var_8h, arg_10h, arg_14h, arg_18h, arg_1ch_00);\n        arg_10h = *puVar3;\n        arg_14h = puVar3[1];\n        if (arg_1ch - arg_1ch_00 == 0) break;\n        if (arg_20h != '\\0') {\n            puVar3 = fcn.0040668c(arg_8h, &var_10h, *puVar3, puVar3[1], arg_20h, 1);\n            arg_10h = *puVar3;\n            arg_14h = puVar3[1];\n        }\n        arg_18h = arg_18h + arg_1ch_00 + 1;\n        arg_1ch = (arg_1ch - arg_1ch_00) + -1;\n    }\n    uVar1 = *puVar3;\n    arg_ch[1] = puVar3[1];\n    *arg_ch = uVar1;\n    return arg_ch;\n}\n",
        "token_count": 424
    },
    "004069dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004069dc(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    \n    uVar1 = fcn.00405d4d();\n    if (uVar1 < arg_8h) {\n        fcn.00408f60();\n    }\n    if (*(in_ECX + 0x18) < arg_8h) {\n        fcn.004066c0(arg_8h, *(in_ECX + 0x14), unaff_EDI, unaff_ESI, unaff_EBP, unaff_retaddr, arg_8h, arg_ch);\n    }\n    else if ((arg_ch == '\\0') || (0xf < arg_8h)) {\n        if (arg_8h == 0) {\n            fcn.00405cba(0);\n        }\n    }\n    else {\n        uVar1 = *(in_ECX + 0x14);\n        if (arg_8h < *(in_ECX + 0x14)) {\n            uVar1 = arg_8h;\n        }\n        fcn.004064eb(1, uVar1);\n    }\n    return arg_8h != 0;\n}\n",
        "token_count": 301
    },
    "00406fc6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a0h\n\nuint __cdecl fcn.00406fc6(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a0h;\n    uint var_2ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = 0;\n    piVar2 = *(unaff_EBP + 8);\n    if ((piVar2 != NULL) && (*piVar2 == 0)) {\n        iVar3 = fcn.004097ee(0x18);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            iVar3 = 0;\n        }\n        else {\n            uVar4 = fcn.00406fa9(unaff_EBP + -0x2c);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x10) = 1;\n            uVar4 = fcn.00406c70(uVar4);\n            *(unaff_EBP + -0x10) = 3;\n            iVar3 = fcn.0040546f(uVar4, 0);\n        }\n        uVar1 = *(unaff_EBP + -0x10);\n        *(unaff_EBP + -4) = 2;\n        *piVar2 = iVar3;\n        if ((uVar1 & 2) != 0) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n            fcn.00406ccc();\n        }\n        if ((*(unaff_EBP + -0x10) & 1) != 0) {\n            fcn.00406945();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 2;\n}\n",
        "token_count": 497
    },
    "00407272": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a0h\n\nuint __cdecl fcn.00407272(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a0h;\n    uint var_2ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = 0;\n    piVar1 = *(unaff_EBP + 8);\n    if ((piVar1 != NULL) && (*piVar1 == 0)) {\n        iVar2 = fcn.004097ee(0x10);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            uVar3 = fcn.00406fa9(unaff_EBP + -0x2c);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x10) = 1;\n            uVar3 = fcn.00406c70(uVar3);\n            *(unaff_EBP + -0x10) = 3;\n            iVar2 = fcn.00405db6(uVar3, 0);\n        }\n        *(unaff_EBP + -4) = 2;\n        *piVar1 = iVar2;\n        if ((*(unaff_EBP + -0x10) & 2) != 0) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n            fcn.00406ccc();\n        }\n        if ((*(unaff_EBP + -0x10) & 1) != 0) {\n            fcn.00406945();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 4;\n}\n",
        "token_count": 480
    },
    "00407539": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407539(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x28) == 0) {\n        arg_8h = arg_8h | 4;\n    }\n    fcn.004073cc(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 84
    },
    "00407736": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407736(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    \n    if (arg_8h != 0) {\n        uVar1 = fcn.00404593();\n        fcn.00407539(uVar1 | arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 81
    },
    "00407903": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_60h\n\nuint __cdecl\nfcn.00407903(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    uint uVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint uVar9;\n    uint32_t uVar10;\n    int32_t unaff_EBP;\n    uint32_t uVar11;\n    uint *in_FS_OFFSET;\n    uint uVar12;\n    uint var_60h;\n    uint var_44h;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.004097b4();\n    uVar3 = fcn.004045b4(unaff_EBP + -0x20);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.0040768e(uVar3);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x18) = uVar3;\n    fcn.004044af();\n    fcn.00406b48(unaff_EBP + -0x60);\n    *(unaff_EBP + -4) = 1;\n    uVar2 = fcn.00405f44();\n    *(unaff_EBP + -0x1c) = uVar2;\n    fcn.00406924();\n    uVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    uVar2 = fcn.00405fa3(0x30);\n    pcVar8 = *(unaff_EBP + 0x20);\n    *(unaff_EBP + -0x14) = uVar2;\n    if ((*pcVar8 == '+') || (*pcVar8 == '-')) {\n        *(unaff_EBP + 0x20) = 1;\n    }\n    else {\n        *(unaff_EBP + 0x20) = 0;\n    }\n    puVar4 = fcn.00409b2a();\n    *(unaff_EBP + -0x10) = **puVar4;\n    *(unaff_EBP + -0xf) = 0x65;\n    *(unaff_EBP + -0xe) = 0;\n    iVar5 = fcn.00409b50(pcVar8, 0x65, *(unaff_EBP + 0x30));\n    iVar6 = fcn.00409b50(pcVar8, *(unaff_EBP + -0x10), *(unaff_EBP + 0x30));\n    *(unaff_EBP + 8) = iVar6;\n    if (iVar6 == 0) {\n        *(unaff_EBP + 0x2c) = 0;\n    }\n    pcVar7 = fcn.00405fde();\n    if ((*pcVar7 != '\\x7f') && ('\\0' < *pcVar7)) {\n        fcn.00406e1b(pcVar8, *(unaff_EBP + 0x30));\n        if (iVar5 == 0) {\n            fcn.00406a6e(*(unaff_EBP + 0x2c), 0x30);\n        }\n        else {\n            if (*(unaff_EBP + 8) == 0) {\n                fcn.00406a6e(*(unaff_EBP + 0x24), 0x30);\n                *(unaff_EBP + 0x24) = 0;\n            }\n            fcn.00406abe(iVar5 - pcVar8, *(unaff_EBP + 0x2c), 0x30);\n        }\n        if (*(unaff_EBP + 8) == 0) {\n            fcn.00406a6e(*(unaff_EBP + 0x24), 0x30);\n        }\n        else {\n            iVar5 = *(unaff_EBP + 8) - pcVar8;\n            fcn.00406abe(iVar5 + 1, *(unaff_EBP + 0x28), 0x30);\n            fcn.00406abe(iVar5, *(unaff_EBP + 0x24), 0x30);\n            *(unaff_EBP + 0x28) = 0;\n        }\n        *(unaff_EBP + 0x24) = 0;\n        pcVar8 = fcn.00405fde();\n        iVar5 = unaff_EBP + -0x10;\n        uVar12 = 0;\n        uVar9 = fcn.00405f1c(0);\n        iVar6 = fcn.00409c00(uVar9, uVar12);\n        while (((cVar1 = *pcVar8,  cVar1 != '\\x7f' && ('\\0' < cVar1)) && (cVar1 < iVar6 - *(unaff_EBP + 0x20)))) {\n            iVar6 = iVar6 - cVar1;\n            iVar5 = iVar6;\n            fcn.00406abe(iVar6, 1, 0);\n            if ('\\0' < pcVar8[1]) {\n                pcVar8 = pcVar8 + 1;\n            }\n        }\n        uVar9 = 0;\n        pcVar8 = fcn.00405f1c(0);\n        *(unaff_EBP + 0x2c) = 0;\n        uVar9 = fcn.00404f95(uVar9, iVar5);\n        *(unaff_EBP + 0x30) = uVar9;\n    }\n    uVar11 = *(unaff_EBP + 0x24) + *(unaff_EBP + 0x28) + *(unaff_EBP + 0x2c) + *(unaff_EBP + 0x30);\n    uVar10 = fcn.00405e04();\n    if ((uVar10 < 1) || (uVar10 <= uVar11)) {\n        *(unaff_EBP + 8) = 0;\n    }\n    else {\n        *(unaff_EBP + 8) = uVar10 - uVar11;\n    }\n    uVar10 = fcn.004045b0();\n    if ((uVar10 & 0x1c0) != 0x40) {\n        if (((uVar10 & 0x1c0) == 0x100) && (*(unaff_EBP + 0x20) != 0)) {\n            puVar4 = fcn.004067ac(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, 1);\n            *(unaff_EBP + 0x10) = *puVar4;\n            uVar9 = puVar4[1];\n            pcVar8 = pcVar8 + 1;\n            *(unaff_EBP + 0x30) = *(unaff_EBP + 0x30) + -1;\n            *(unaff_EBP + 0x14) = uVar9;\n        }\n        puVar4 = fcn.0040668c(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x1c), \n                              *(unaff_EBP + 8));\n        *(unaff_EBP + 0x10) = *puVar4;\n        uVar9 = puVar4[1];\n        *(unaff_EBP + 8) = 0;\n        *(unaff_EBP + 0x14) = uVar9;\n    }\n    iVar5 = fcn.00409b50(pcVar8, *(unaff_EBP + -0x10), *(unaff_EBP + 0x30));\n    if (iVar5 != 0) {\n        iVar6 = (iVar5 - pcVar8) + 1;\n        puVar4 = fcn.00406802(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, iVar5 - pcVar8\n                              , *(unaff_EBP + -0x1c));\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        puVar4 = fcn.0040668c(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x24));\n        *(unaff_EBP + 0x10) = *puVar4;\n        uVar9 = 1;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        uVar10 = fcn.00405f3f();\n        puVar4 = fcn.0040668c(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), uVar10 & 0xff, uVar9);\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        puVar4 = fcn.0040668c(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x28));\n        *(unaff_EBP + 0x10) = *puVar4;\n        uVar9 = puVar4[1];\n        pcVar8 = pcVar8 + iVar6;\n        *(unaff_EBP + 0x30) = *(unaff_EBP + 0x30) - iVar6;\n        *(unaff_EBP + 0x14) = uVar9;\n    }\n    iVar5 = fcn.00409b50(pcVar8, 0x65, *(unaff_EBP + 0x30));\n    if (iVar5 != 0) {\n        *(unaff_EBP + 0x24) = (iVar5 - pcVar8) + 1;\n        puVar4 = fcn.00406802(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, iVar5 - pcVar8\n                              , *(unaff_EBP + -0x1c));\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        puVar4 = fcn.0040668c(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x2c));\n        *(unaff_EBP + 0x2c) = 0;\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        uVar10 = fcn.004045b0();\n        uVar9 = 0x4015d0;\n        if ((uVar10 & 4) == 0) {\n            uVar9 = 0x4015cc;\n        }\n        puVar4 = fcn.004067ac(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], uVar9, 1);\n        *(unaff_EBP + 0x10) = *puVar4;\n        *(unaff_EBP + 0x14) = puVar4[1];\n        pcVar8 = pcVar8 + *(unaff_EBP + 0x24);\n        *(unaff_EBP + 0x30) = *(unaff_EBP + 0x30) - *(unaff_EBP + 0x24);\n    }\n    puVar4 = fcn.00406802(uVar3, unaff_EBP + -0x28, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), pcVar8, \n                          *(unaff_EBP + 0x30), *(unaff_EBP + -0x1c));\n    *(unaff_EBP + 0x10) = *puVar4;\n    *(unaff_EBP + 0x14) = puVar4[1];\n    puVar4 = fcn.0040668c(uVar3, unaff_EBP + -0x28, *puVar4, puVar4[1], *(unaff_EBP + -0x14), *(unaff_EBP + 0x2c));\n    uVar9 = *puVar4;\n    *(unaff_EBP + 0x10) = uVar9;\n    uVar12 = puVar4[1];\n    *(unaff_EBP + 0x14) = uVar12;\n    fcn.00405e08(0);\n    fcn.0040668c(uVar3, *(unaff_EBP + 0xc), uVar9, uVar12, *(unaff_EBP + 0x1c), *(unaff_EBP + 8));\n    fcn.00406945();\n    fcn.00406945();\n    uVar3 = *(unaff_EBP + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 3183
    },
    "00407d46": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n\nuint __cdecl\nfcn.00407d46(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint arg_14h_00;\n    uint uVar3;\n    char *pcVar4;\n    int32_t arg_ch_00;\n    uint32_t uVar5;\n    uint *puVar6;\n    char *arg_18h_00;\n    int32_t unaff_EBP;\n    int32_t iVar7;\n    uint *in_FS_OFFSET;\n    uint var_38h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    uVar3 = fcn.004045b4(unaff_EBP + -0x1c);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.0040768e(uVar3);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x18) = uVar3;\n    fcn.004044af();\n    fcn.00406b48(unaff_EBP + -0x38);\n    arg_18h_00 = *(unaff_EBP + 0x20);\n    cVar1 = *arg_18h_00;\n    *(unaff_EBP + -4) = 1;\n    if ((cVar1 == '+') || (cVar1 == '-')) {\n        *(unaff_EBP + -0x10) = 1;\n    }\n    else if ((cVar1 == '0') && ((arg_18h_00[1] == 'x' || (arg_18h_00[1] == 'X')))) {\n        *(unaff_EBP + -0x10) = 2;\n    }\n    else {\n        *(unaff_EBP + -0x10) = 0;\n    }\n    pcVar4 = fcn.00405fde();\n    if ((*pcVar4 != '\\x7f') && ('\\0' < *pcVar4)) {\n        iVar7 = *(unaff_EBP + 0x24);\n        *(unaff_EBP + 0x20) = pcVar4;\n        while (((cVar1 = *pcVar4,  cVar1 != '\\x7f' && ('\\0' < cVar1)) && (cVar1 < iVar7 - *(unaff_EBP + -0x10)))) {\n            iVar7 = iVar7 - cVar1;\n            arg_ch_00 = (*(unaff_EBP + 0x24) - iVar7) + 1;\n            fcn.00409338(arg_18h_00 + iVar7 + 1, arg_ch_00, arg_18h_00 + iVar7, arg_ch_00);\n            *(unaff_EBP + 0x24) = *(unaff_EBP + 0x24) + 1;\n            pcVar4 = *(unaff_EBP + 0x20) + 1;\n            arg_18h_00[iVar7] = '\\0';\n            if ('\\0' < *pcVar4) {\n                *(unaff_EBP + 0x20) = pcVar4;\n            }\n            pcVar4 = *(unaff_EBP + 0x20);\n        }\n    }\n    uVar5 = fcn.00405e04();\n    if ((uVar5 < 1) || (uVar5 < *(unaff_EBP + 0x24) || uVar5 == *(unaff_EBP + 0x24))) {\n        *(unaff_EBP + 0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + 0x20) = uVar5 - *(unaff_EBP + 0x24);\n    }\n    uVar5 = fcn.004045b0();\n    uVar3 = *(unaff_EBP + 8);\n    if ((uVar5 & 0x1c0) != 0x40) {\n        if ((uVar5 & 0x1c0) == 0x100) {\n            iVar7 = *(unaff_EBP + -0x10);\n            puVar6 = fcn.004067ac(uVar3, unaff_EBP + -0x14, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), arg_18h_00, iVar7)\n            ;\n            uVar2 = *puVar6;\n            *(unaff_EBP + 0x24) = *(unaff_EBP + 0x24) - iVar7;\n            *(unaff_EBP + 0x10) = uVar2;\n            *(unaff_EBP + 0x14) = puVar6[1];\n            arg_18h_00 = arg_18h_00 + iVar7;\n            puVar6 = fcn.0040668c(uVar3, unaff_EBP + -0x14, *puVar6, puVar6[1], *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20)\n                                 );\n        }\n        else {\n            puVar6 = fcn.0040668c(uVar3, unaff_EBP + -0x14, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), \n                                  *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20));\n        }\n        uVar2 = *puVar6;\n        *(unaff_EBP + 0x20) = 0;\n        *(unaff_EBP + 0x10) = uVar2;\n        *(unaff_EBP + 0x14) = puVar6[1];\n    }\n    uVar5 = fcn.00405f44();\n    puVar6 = fcn.00406802(uVar3, unaff_EBP + -0x14, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), arg_18h_00, \n                          *(unaff_EBP + 0x24), uVar5 & 0xff);\n    uVar2 = *puVar6;\n    *(unaff_EBP + 0x10) = uVar2;\n    arg_14h_00 = puVar6[1];\n    *(unaff_EBP + 0x14) = arg_14h_00;\n    fcn.00405e08(0);\n    fcn.0040668c(uVar3, *(unaff_EBP + 0xc), uVar2, arg_14h_00, *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20));\n    fcn.00406945();\n    uVar3 = *(unaff_EBP + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 1619
    },
    "00408182": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408182(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    double dVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t arg_28h;\n    unkbyte3 Stack0000001c;\n    uint32_t in_stack_0000001c;\n    int32_t arg_14h_00;\n    int32_t iStack140;\n    uint var_78h;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    iStack140 = fcn.00404f95();\n    arg_28h = 0;\n    if ((iStack140 < 1) && (uVar2 = fcn.004045b0(),  (uVar2 & 0x2000) == 0)) {\n        iStack140 = 6;\n    }\n    else {\n        var_8h = 0x24;\n        if (0x24 < iStack140) goto code_r0x004081c1;\n    }\n    var_8h = iStack140;\ncode_r0x004081c1:\n    iStack140 = iStack140 - var_8h;\n    var_4h = 0;\n    uVar2 = fcn.004045b0();\n    dVar1 = CONCAT44(in_stack_0000001c, arg_1ch);\n    if (((uVar2 & 0x3000) == 0x2000) && (*0x401600 * dVar1 != dVar1)) {\n        if (((0.0 < dVar1) << 8 | (dVar1 == 0.0) << 0xe) == 0) {\n            in_stack_0000001c = CONCAT13(1, Stack0000001c);\n            dVar1 = -dVar1;\n        }\n        else {\n            in_stack_0000001c = in_stack_0000001c & 0xffffff;\n        }\n        if (*0x4015f8 < dVar1 != (*0x4015f8 == dVar1)) {\n            do {\n                if (4999 < var_4h) break;\n                dVar1 = dVar1 / *0x4015f0;\n                var_4h = var_4h + 10;\n            } while (*0x4015f8 < dVar1 != (*0x4015f8 == dVar1));\n        }\n        if (0.0 < dVar1) {\n            for (; ((9 < iStack140 && (dVar1 <= *0x4015e8)) && (arg_28h < 5000)); arg_28h = arg_28h + 10) {\n                iStack140 = iStack140 + -10;\n                dVar1 = dVar1 * *0x4015f0;\n            }\n        }\n    }\n    arg_14h_00 = var_8h;\n    uVar3 = fcn.00405e42(var_ch, &arg_1ch, 0, uVar2);\n    uVar3 = fcn.00409c46(&var_78h, 0x6c, uVar3, arg_14h_00);\n    fcn.00407903(var_ch, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_78h, var_4h, arg_28h, iStack140, uVar3);\n    return arg_8h;\n}\n",
        "token_count": 799
    },
    "004082d2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004082d2(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    double dVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t arg_28h;\n    unkbyte3 Stack0000001c;\n    uint32_t in_stack_0000001c;\n    int32_t arg_14h_00;\n    int32_t iStack144;\n    uint var_7ch;\n    uint32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    iStack144 = fcn.00404f95();\n    arg_28h = 0;\n    if ((iStack144 < 1) && (uVar2 = fcn.004045b0(),  (uVar2 & 0x2000) == 0)) {\n        iStack144 = 6;\n    }\n    else {\n        var_8h = 0x24;\n        if (0x24 < iStack144) goto code_r0x00408311;\n    }\n    var_8h = iStack144;\ncode_r0x00408311:\n    iStack144 = iStack144 - var_8h;\n    var_4h = 0;\n    var_10h = fcn.004045b0();\n    if ((var_10h & 0x3000) == 0x2000) {\n        dVar1 = CONCAT44(in_stack_0000001c, arg_1ch);\n        if (0.0 <= dVar1) {\n            in_stack_0000001c = in_stack_0000001c & 0xffffff;\n        }\n        else {\n            in_stack_0000001c = CONCAT13(1, Stack0000001c);\n            dVar1 = -dVar1;\n        }\n        if (*0x4015f8 < dVar1 != (*0x4015f8 == dVar1)) {\n            do {\n                if (4999 < var_4h) break;\n                dVar1 = dVar1 / *0x4015f0;\n                var_4h = var_4h + 10;\n            } while (*0x4015f8 < dVar1 != (*0x4015f8 == dVar1));\n        }\n        if (0.0 < dVar1) {\n            for (; ((9 < iStack144 && (dVar1 <= *0x4015e8)) && (arg_28h < 5000)); arg_28h = arg_28h + 10) {\n                iStack144 = iStack144 + -10;\n                dVar1 = dVar1 * *0x4015f0;\n            }\n        }\n    }\n    arg_14h_00 = var_8h;\n    uVar3 = fcn.00405e42(var_ch, &arg_1ch, 0x4c, var_10h);\n    uVar3 = fcn.00409c46(&var_7ch, 0x6c, uVar3, arg_14h_00);\n    fcn.00407903(var_ch, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_7ch, var_4h, arg_28h, iStack144, uVar3);\n    return arg_8h;\n}\n",
        "token_count": 775
    },
    "00408495": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t * __cdecl fcn.00408495(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x40160c;\n        fcn.0040507e();\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    arg_ch_00 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = 0x401424;\n    extraout_ECX[1] = 0;\n    fcn.00407f20(*(unaff_EBP + 8), arg_ch_00);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 333
    },
    "004094c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.004094c1(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x40956c;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.00409598;\n        uStack36 = *0x540258 ^ &fcn.004094c1::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.004094c1::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.0040dabc();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.004094c1::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 721
    },
    "004098aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004098aa(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040eac8(0x41edb0, 0xc);\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 != 0) {\n        if (*0x69ced8 == 3) {\n            fcn.0040dfcf(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.0040e002(iVar1);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.0040e032(arg_8h_00, iVar1);\n            }\n            *(unaff_EBP + -4) = 0xfffffffe;\n            fcn.00409900();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x00409932;\n            iVar1 = *(unaff_EBP + 8);\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x69b200, 0, iVar1);\n        if (iVar1 == 0) {\n            puVar2 = fcn.0040b128();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = fcn.0040b0e6(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\ncode_r0x00409932:\n    fcn.0040eb0d();\n    return;\n}\n",
        "token_count": 430
    },
    "0040b33b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b33b(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x540258) {\n        return;\n    }\n    *0x69ba30 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x69ba34 = &arg_8h;\n    *0x69b970 = 0x10001;\n    *0x69b918 = 0xc0000409;\n    *0x69b91c = 1;\n    var_328h = *0x540258;\n    var_324h = *0x54025c;\n    *0x69b924 = unaff_retaddr;\n    *0x69b9fc = in_GS;\n    *0x69ba00 = in_FS;\n    *0x69ba04 = in_ES;\n    *0x69ba08 = in_DS;\n    *0x69ba0c = unaff_EDI;\n    *0x69ba10 = unaff_ESI;\n    *0x69ba14 = unaff_EBX;\n    *0x69ba18 = in_EDX;\n    *0x69ba1c = in_ECX;\n    *0x69ba20 = in_EAX;\n    *0x69ba24 = unaff_EBP;\n    *0x69ba28 = unaff_retaddr;\n    *0x69ba2c = in_CS;\n    *0x69ba38 = in_SS;\n    *0x69b968 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.0040ecbc(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x4027c4);\n    if (*0x69b968 == 0) {\n        fcn.0040ecbc(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 831
    },
    "0040c5f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0040c5f6(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040dabc();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.0040dabc();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "0040c8d1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c8d1(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.004096ff(*(unaff_EBP + -0x28));\n    iVar1 = fcn.0040dabc();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.0040dabc();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.004096d8(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0040c656(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 383
    },
    "0040fe23": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x0040ff16: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x0040ff1b)\n// WARNING: Removing unreachable block (ram,0x0040ff49)\n// WARNING: Removing unreachable block (ram,0x0040ff21)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040fe23(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040eac8(0x41f108, 0x18);\n    fcn.0040dfcf(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x69b3ac != 1) {\n        *0x69b3a8 = 1;\n        *0x69b3a4 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.0040d870(*0x69ceac);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.0040d870(*0x69cea8);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.0040d867();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.0040d870(*piVar2);\n                        iVar3 = fcn.0040d867();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.0040d870(*0x69ceac);\n                        piVar1 = fcn.0040d870(*0x69cea8);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.0040fd5d(0x40127c);\n        }\n        fcn.0040fd5d(0x401284);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0040def5(8);\n    }\n    return;\n}\n",
        "token_count": 806
    },
    "004101bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.004101bd(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.0040def5(0);\n    }\n    return;\n}\n",
        "token_count": 64
    },
    "00417dee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00417dee(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x540258 ^ &stack0xfffffffc;\n    fcn.0040a140(arg_10h);\n    var_14h = fcn.00419eae(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.00419426(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00417e47:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00417e87;\n        }\n        if (iVar1 != 2) {\ncode_r0x00417e79:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00417e87;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00417e79;\n        goto code_r0x00417e47;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x00417e87:\n    fcn.0040b33b(unaff_EBX);\n    return;\n}\n",
        "token_count": 501
    },
    "00417e96": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00417e96(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x540258 ^ &stack0xfffffffc;\n    fcn.0040a140(arg_10h);\n    var_14h = fcn.00419eae(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0041996a(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x00417eef:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00417f2f;\n        }\n        if (iVar1 != 2) {\ncode_r0x00417f21:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x00417f2f;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x00417f21;\n        goto code_r0x00417eef;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x00417f2f:\n    fcn.0040b33b(unaff_EBX);\n    return;\n}\n",
        "token_count": 506
    },
    "004182d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004182d3(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0040d867();\n    var_4h = 0;\n    if (*0x69bc8c == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4038c8);\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4038bc);\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x69bc8c = fcn.0040d7f5(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, 0x4038ac);\n        *0x69bc90 = fcn.0040d7f5(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x403898);\n        *0x69bc94 = fcn.0040d7f5(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x40387c);\n        *0x69bc9c = fcn.0040d7f5(uVar3);\n        if (*0x69bc9c != 0) {\n            uVar3 = (*pcVar4)(iVar2, 0x403864);\n            *0x69bc98 = fcn.0040d7f5(uVar3);\n        }\n    }\n    if ((*0x69bc98 != iVar1) && (*0x69bc9c != iVar1)) {\n        pcVar4 = fcn.0040d870(*0x69bc98);\n        pcVar5 = fcn.0040d870(*0x69bc9c);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x00418415;\n        }\n    }\n    if ((((*0x69bc90 != iVar1) && (pcVar4 = fcn.0040d870(*0x69bc90),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x69bc94 != iVar1 && (pcVar4 = fcn.0040d870(*0x69bc94),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x00418415:\n    pcVar4 = fcn.0040d870(*0x69bc8c);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 843
    },
    "00419426": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00419426(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x00419927;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = str.5_v_[0] + L'\\xffffffff';\n        iVar4 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        uVar9 = str.5_v_[0] & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x0041955b;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x00419562;\ncode_r0x0041955b:\n                        do {\n                            var_4h = 1;\ncode_r0x00419562:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x00419570;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x00419570:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x540f18 - str.5_v_[0]) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x540f18 < iVar12) {\n                if (iVar12 < *0x540f14) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + str.5_v_[3];\n                    iVar4 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = str.5_v_[3] + *0x540f14;\n                    uVar5 = 1;\n                }\n                goto code_r0x00419927;\n            }\n            var_10h = *0x540f18 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = str.5_v_[0] + L'\\xffffffff';\n            iVar12 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar10 = str.5_v_[0] & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x00419713;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x00419713:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = str.5_v_[1] + L'\\x01';\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x00419927:\n    var_20h = iVar12 << (0x1fU - str.5_v_[1] & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3654
    },
    "0041996a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041996a(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x00419e6b;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = *0x540f34 - 1;\n        iVar4 = *0x540f34 + (*0x540f34 >> 0x1f & 0x1fU) >> 5;\n        uVar9 = *0x540f34 & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x00419a9f;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x00419aa6;\ncode_r0x00419a9f:\n                        do {\n                            var_4h = 1;\ncode_r0x00419aa6:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x00419ab4;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x00419ab4:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x540f30 - *0x540f34) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x540f30 < iVar12) {\n                if (iVar12 < *0x540f2c) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + *0x540f40;\n                    iVar4 = *0x540f38 + (*0x540f38 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x540f38 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = *0x540f38 + (*0x540f38 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x540f38 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = *0x540f40 + *0x540f2c;\n                    uVar5 = 1;\n                }\n                goto code_r0x00419e6b;\n            }\n            var_10h = *0x540f30 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = *0x540f34 - 1;\n            iVar12 = *0x540f34 + (*0x540f34 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = *0x540f34 & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x00419c57;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x00419c57:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = *0x540f38 + 1;\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x00419e6b:\n    var_20h = iVar12 << (0x1fU - *0x540f38 & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (*0x540f3c == 0x40) {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (*0x540f3c == 0x20) {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3647
    },
    "004042f7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004042f7(uint32_t arg_8h)\n\n{\n    fcn.004042ec();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00404501": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404501(uint32_t arg_8h)\n\n{\n    fcn.00404460();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 58
    },
    "00404546": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404546(uint32_t arg_8h)\n\n{\n    fcn.0040453b();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "004045e5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004045e5(uint32_t arg_8h)\n\n{\n    fcn.004045ce();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00404fe5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404fe5(uint32_t arg_8h)\n\n{\n    fcn.00404fa8();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00405128": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405128(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    \n    if ((*(param_1 + 0x40) & 1) != 0) {\n        iVar1 = fcn.004050a9();\n        if (iVar1 == 0) {\n            iVar1 = fcn.004050af();\n        }\n        else {\n            iVar1 = fcn.004050db();\n        }\n        iVar2 = fcn.0040509d();\n        arg_8h = fcn.0040509d(iVar1 - iVar2);\n        fcn.0040506a(arg_8h);\n    }\n    fcn.004050ba(0, 0, 0);\n    fcn.004050e6(0, 0);\n    *(param_1 + 0x40) = *(param_1 + 0x40) & 0xfffffffe;\n    *(param_1 + 0x3c) = 0;\n    return;\n}\n",
        "token_count": 238
    },
    "00405230": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00405230(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if ((arg_8h & 1) == 0) {\n        uVar1 = 4;\n    }\n    if ((arg_8h & 2) == 0) {\n        uVar1 = uVar1 | 2;\n    }\n    if ((arg_8h & 8) != 0) {\n        uVar1 = uVar1 | 8;\n    }\n    if ((arg_8h & 4) != 0) {\n        uVar1 = uVar1 | 0x10;\n    }\n    return uVar1;\n}\n",
        "token_count": 161
    },
    "004055f8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004055f8(uint32_t arg_8h)\n\n{\n    fcn.004055e2();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00405adf": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00405adf(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint32_t arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint arg_ch_00;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.004057ce();\n    iVar2 = fcn.004050a9();\n    if ((iVar2 != 0) && (uVar3 = fcn.004050a9(),  *(in_ECX + 0x3c) < uVar3)) {\n        uVar4 = fcn.004050a9();\n        *(in_ECX + 0x3c) = uVar4;\n    }\n    iVar2 = iVar1;\n    if (iVar1 != *0x401654) {\n        iVar2 = *0x401654;\n        if (((arg_24h & 1) == 0) || (iVar5 = fcn.004050a3(),  iVar5 == 0)) {\n            if (((arg_24h & 2) != 0) &&\n               (((iVar5 = fcn.004050a9(),  iVar5 != 0 && (-1 < iVar1)) &&\n                (iVar5 = fcn.0040509d(),  iVar1 <= *(in_ECX + 0x3c) - iVar5)))) {\n                iVar2 = fcn.004050a9();\n                iVar5 = fcn.0040509d();\n                fcn.004056c0((iVar1 - iVar2) + iVar5);\n                iVar2 = iVar1;\n            }\n        }\n        else if ((-1 < iVar1) && (iVar5 = fcn.0040509d(),  iVar1 <= *(in_ECX + 0x3c) - iVar5)) {\n            iVar2 = fcn.004050a3();\n            iVar5 = fcn.0040509d();\n            fcn.0040568d((iVar1 - iVar2) + iVar5);\n            iVar2 = iVar1;\n            if (((arg_24h & 2) != 0) && (iVar5 = fcn.004050a9(),  iVar5 != 0)) {\n                uVar4 = fcn.004050db();\n                arg_ch_00 = fcn.004050a3();\n                arg_8h_00 = fcn.004057b8();\n                fcn.00405104(arg_8h_00, arg_ch_00, uVar4);\n            }\n        }\n    }\n    fcn.004056e3(iVar2);\n    return arg_8h;\n}\n",
        "token_count": 633
    },
    "00405bf3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00405bf3(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00405023();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0(in_ECX + -4);\n    }\n    return in_ECX + -4;\n}\n",
        "token_count": 82
    },
    "00405c15": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00405c15(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00405036();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0(in_ECX + -8);\n    }\n    return in_ECX + -8;\n}\n",
        "token_count": 82
    },
    "00405c37": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405c37(uint32_t arg_8h)\n\n{\n    fcn.00405617();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00405c56": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00405c56(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00405049();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0(in_ECX + -0xc);\n    }\n    return in_ECX + -0xc;\n}\n",
        "token_count": 84
    },
    "00405c78": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405c78(uint32_t arg_8h)\n\n{\n    fcn.00405770();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00405e23": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405e23(uint32_t arg_8h)\n\n{\n    fcn.00405e18();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "004068f2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004068f2(uint32_t arg_8h)\n\n{\n    fcn.004068dc();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "0040694f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040694f(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00406911();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0(in_ECX + -0x54);\n    }\n    return in_ECX + -0x54;\n}\n",
        "token_count": 86
    },
    "00406c19": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406c19(uint32_t arg_8h)\n\n{\n    fcn.00406bf8();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00406c51": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406c51(uint32_t arg_8h)\n\n{\n    fcn.00406c38();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "00406f4e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406f4e(uint32_t arg_8h)\n\n{\n    fcn.00406f43();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "00407095": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407095(uint32_t arg_8h)\n\n{\n    fcn.0040708a();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "00407319": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a4h\n\nuint __cdecl fcn.00407319(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t *piVar4;\n    uint *in_FS_OFFSET;\n    uint var_a4h;\n    uint var_30h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    piVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = 0;\n    if ((piVar4 != NULL) && (*piVar4 == 0)) {\n        iVar2 = fcn.004097ee(0x18);\n        *(unaff_EBP + -0x14) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            iVar2 = 0;\n        }\n        else {\n            uVar3 = fcn.00406fa9(unaff_EBP + -0x30);\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x10) = 1;\n            uVar3 = fcn.00406c70(uVar3);\n            *(unaff_EBP + -4) = 2;\n            *(unaff_EBP + -0x10) = 3;\n            iVar2 = fcn.00406893(uVar3, 0, 1);\n            piVar4 = *(unaff_EBP + 8);\n        }\n        uVar1 = *(unaff_EBP + -0x10);\n        *piVar4 = iVar2;\n        *(unaff_EBP + -4) = 3;\n        if ((uVar1 & 2) != 0) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n            fcn.00406ccc();\n        }\n        if ((*(unaff_EBP + -0x10) & 1) != 0) {\n            fcn.00406945();\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 4;\n}\n",
        "token_count": 534
    },
    "004097ee": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004097ee(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_ch;\n    \n    do {\n        iVar2 = fcn.0040d2c2(arg_8h);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.0040ddfb(arg_8h);\n    } while (iVar2 != 0);\n    if ((*0x69b1b0 & 1) == 0) {\n        *0x69b1b0 = *0x69b1b0 | 1;\n        fcn.004097d3();\n        fcn.0040b298(0x41c545);\n    }\n    fcn.004053f1(0x69b1a4);\n    fcn.00409853(&var_ch, 0x41e594);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 221
    },
    "00408f39": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408f39(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x40165c;\n    fcn.00406bf8();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 81
    },
    "00409217": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409217(uint32_t arg_8h)\n\n{\n    fcn.004091ae();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 58
    },
    "00409238": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409238(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x4016b0;\n    fcn.004091ae();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 80
    },
    "0040926f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040926f(uint32_t arg_8h)\n\n{\n    fcn.0040925f();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "0040c461": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c461(uint32_t arg_8h)\n\n{\n    uint *in_ECX;\n    \n    *in_ECX = 0x402020;\n    fcn.004091ae();\n    if ((arg_8h & 1) != 0) {\n        fcn.004092b0();\n    }\n    return;\n}\n",
        "token_count": 79
    },
    "00416c5e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416c5e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040eac8(0x41f268, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0040b13b();\n        *puVar2 = 0;\n        puVar2 = fcn.0040b128();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x69bd68)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x69bd80;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.00419040(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0040b128();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0040b13b();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0041652b(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00416d30(0x41f268);\n                goto code_r0x00416d2a;\n            }\n        }\n        puVar2 = fcn.0040b13b();\n        *puVar2 = 0;\n        puVar2 = fcn.0040b128();\n        *puVar2 = 9;\n        fcn.00409a6f(0, 0, 0, 0, 0);\n    }\ncode_r0x00416d2a:\n    fcn.0040eb0d();\n    return;\n}\n",
        "token_count": 640
    },
    "00404604": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nvoid fcn.00404604(void)\n\n{\n    *0x5413a8 = 0x6d;\n    *0x5413a9 = 0x73;\n    *0x5413ad = 0x33;\n    *0x5413b3 = 0;\n    *0x5413ac = 0x67;\n    *0x5413b0 = 100;\n    *0x5413ab = 0x6d;\n    *0x5413b1 = 0x6c;\n    *0x5413af = 0x2e;\n    *0x5413b2 = 0x6c;\n    *0x5413ae = 0x32;\n    *0x5413aa = 0x69;\n    (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x5413a8);\n    return;\n}\n",
        "token_count": 198
    },
    "004049ea": {
        "rules": [
            "64-bit execution via heavens gate/cf627f8086064c53962fc93043360d1e"
        ],
        "decompiled_code": "\nvoid fcn.004049ea(void)\n\n{\n    uint var_4h;\n    \n    *0x5413ae = 0x33;\n    *0x5413af = 0x32;\n    *0x5413b3 = 0x6c;\n    *0x5413ab = 0x6e;\n    *0x5413a8 = 0x6b;\n    *0x5413ac = 0x65;\n    *0x5413ad = 0x6c;\n    *0x5413a9 = 0x65;\n    *0x5413aa = 0x72;\n    *0x5413b0 = 0x2e;\n    *0x5413b1 = 100;\n    *0x5413b2 = 0x6c;\n    *0x5413b4 = 0;\n    *0x6993ec = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x5413a8);\n    *0x5413b3 = 0x65;\n    *0x5413a9 = 0x69;\n    *0x5413ac = 0x75;\n    *0x5413ae = 0x6c;\n    *0x5413ad = 0x61;\n    *0x5413b1 = 0x6f;\n    *0x5413b5 = 0x74;\n    *0x5413a8 = 0x56;\n    *0x5413b4 = 99;\n    *0x5413af = 0x50;\n    *0x5413b6 = 0;\n    *0x5413ab = 0x74;\n    *0x5413b2 = 0x74;\n    *0x5413aa = 0x72;\n    *0x5413b0 = 0x72;\n    *0x5413a4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x6993ec, 0x5413a8);\n    (**0x5413a4)(*0x6958ec, *0x69af70, 0x40, &var_4h);\n    return;\n}\n",
        "token_count": 497
    },
    "004046e7": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __cdecl fcn.004046e7(uint32_t *arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t unaff_ESI;\n    uint *unaff_EDI;\n    uint lpBuffer;\n    uint lpVolumeNameBuffer;\n    uint lpszVolumeName;\n    uint var_848h;\n    uint szLang;\n    uint uStackY100;\n    uint uStackY96;\n    uint *puStackY92;\n    uint uStackY88;\n    uint *puStackY84;\n    uint uStackY80;\n    uint var_48h;\n    uint *var_44h;\n    uint var_40h;\n    uint *nSize;\n    uint *lpNumberOfCharsRead;\n    uint *var_34h;\n    uint *var_30h;\n    int32_t var_2ch;\n    uint *var_28h;\n    uint *var_24h;\n    int32_t var_20h;\n    uint *var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint32_t var_10h;\n    uint *var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0x4046f4;\n    fcn.004093a0();\n    var_4h = *arg_8h;\n    var_24h = *arg_ch;\n    var_20h = arg_ch[1];\n    var_28h = arg_ch[2];\n    var_2ch = arg_ch[3];\n    var_18h = -0x3910c8e0;\n    var_30h = 0x9e3779b9;\n    var_1ch = 0x20;\n    var_ch = unaff_EDI;\n    var_8h = unaff_ESI;\n    do {\n        uVar3 = var_4h;\n        iVar2 = var_18h;\n        if (*0x69af70 == 5) {\n            var_10h = 0x40474e;\n            (*_sym.imp.KERNEL32.dll_GetConsoleAliasExesLengthW)();\n        }\n        puVar1 = var_28h + uVar3 * 4;\n        var_8h = iVar2 + var_4h;\n        uVar3 = var_4h >> 5;\n        if (*0x69af70 == 0x1b) {\n            var_10h = 0;\n            var_14h = &fcn.004046e7::lpszVolumeName;\n            var_18h = 0;\n            var_1ch = 0x40477a;\n            (*_sym.imp.KERNEL32.dll_FindNextVolumeW)();\n            var_1ch = 0x4012bc;\n            var_20h = 0;\n            var_24h = NULL;\n            var_28h = 0x404787;\n            (*_sym.imp.KERNEL32.dll_SetLocaleInfoA)();\n            var_28h = NULL;\n            var_2ch = 0;\n            var_30h = 0x40478f;\n            (*_sym.imp.KERNEL32.dll_SetSystemTimeAdjustment)();\n            var_30h = &fcn.004046e7::var_48h;\n            var_34h = 0x404799;\n            (*_sym.imp.KERNEL32.dll_InterlockedDecrement)();\n            var_34h = NULL;\n            lpNumberOfCharsRead = 0x4047a0;\n            (*_sym.imp.KERNEL32.dll_LocalFlags)();\n        }\n        *0x6958f0 = var_2ch + uVar3 ^ puVar1 ^ var_8h;\n        var_14h = &fcn.004046e7::var_10h;\n        var_18h = 0x4047cc;\n        var_10h = *0x6958f0;\n        fcn.00404673(var_14h, *0x6958f0);\n        if (*0x69af70 == 0x839) {\n            var_18h = 0;\n            var_1ch = &fcn.004046e7::szLang;\n            var_20h = 0;\n            var_24h = 0x4047e6;\n            sub.KERNEL32.dll_VerLanguageNameA();\n        }\n        uVar3 = var_10h;\n        if (*0x69af70 == 0x78c) {\n            var_24h = &fcn.004046e7::nSize;\n            var_28h = &fcn.004046e7::lpBuffer;\n            var_2ch = 0x40480e;\n            (*_sym.imp.KERNEL32.dll_GetComputerNameW)();\n            var_2ch = 0;\n            var_30h = &fcn.004046e7::szLang;\n            var_34h = &fcn.004046e7::var_34h;\n            lpNumberOfCharsRead = &fcn.004046e7::var_44h;\n            nSize = &fcn.004046e7::var_40h;\n            var_40h = 0;\n            var_44h = &fcn.004046e7::lpVolumeNameBuffer;\n            var_48h = 0;\n            uStackY80 = 0x404831;\n            (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)();\n            uStackY80 = 0;\n            puStackY84 = &fcn.004046e7::lpNumberOfCharsRead;\n            uStackY88 = 0;\n            puStackY92 = &fcn.004046e7::var_848h;\n            uStackY96 = 0;\n            uStackY100 = 0x404845;\n            (*_sym.imp.KERNEL32.dll_ReadConsoleA)();\n        }\n        var_8h = var_10h + var_18h;\n        *0x6958fc = 0xffffffff;\n        var_14h = (uVar3 >> 5) + var_20h;\n        *0x6958f8 = 0xff6b3619;\n        var_4h = var_4h - (var_24h + uVar3 * 4 ^ var_8h ^ var_14h);\n        var_ch = var_30h;\n        var_18h = iVar2 - var_30h;\n        var_1ch = var_1ch + -1;\n    } while (var_1ch != NULL);\n    arg_8h[1] = uVar3;\n    *arg_8h = var_4h;\n    return;\n}\n",
        "token_count": 1547
    },
    "004048af": {
        "rules": [
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0",
            "hash data using aphash/10489b186fc44711a1078750698db7a9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004048af(int32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint lpFindFileData;\n    \n    if (*0x69af70 == 0x516) {\n        (*_sym.imp.KERNEL32.dll_MoveFileWithProgressW)(0, 0, 0, 0, 0);\n    }\n    for (arg_ch = arg_ch >> 3; arg_ch != 0; arg_ch = arg_ch - 1) {\n        if (*0x69af70 == 0x29) {\n            (*_sym.imp.KERNEL32.dll_CopyFileExA)(0, 0, 0, 0, 0, 0);\n        }\n        if (*0x69af70 == 0x1c) {\n            (*_sym.imp.KERNEL32.dll_FindNextFileA)(0, &lpFindFileData);\n            (*_sym.imp.KERNEL32.dll_EnumSystemCodePagesA)(0, 0);\n        }\n        fcn.004046e7(arg_8h, arg_10h);\n        arg_8h = arg_8h + 8;\n    }\n    return;\n}\n",
        "token_count": 260
    },
    "004065c9": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004065c9(uint arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x3c) = 0;\n    *(in_ECX + 0x40) = arg_10h;\n    if ((arg_ch != 0) && ((arg_10h & 6) != 6)) {\n        arg_8h_00 = fcn.00405c9c(arg_ch);\n        fcn.00405d6e(arg_8h_00, arg_ch, arg_8h, arg_ch);\n        arg_ch = arg_ch + arg_8h_00;\n        *(in_ECX + 0x3c) = arg_ch;\n        if ((*(in_ECX + 0x40) & 4) == 0) {\n            fcn.004050ba(arg_8h_00, arg_8h_00, arg_ch);\n        }\n        if ((*(in_ECX + 0x40) & 2) == 0) {\n            iVar1 = arg_ch;\n            if ((*(in_ECX + 0x40) & 0x10) == 0) {\n                iVar1 = arg_8h_00;\n            }\n            fcn.00405104(arg_8h_00, iVar1, arg_ch);\n            iVar1 = fcn.004050a3();\n            if (iVar1 == 0) {\n                fcn.004050ba(arg_8h_00, 0, arg_8h_00);\n            }\n        }\n        *(in_ECX + 0x40) = *(in_ECX + 0x40) | 1;\n    }\n    return;\n}\n",
        "token_count": 406
    },
    "004071ca": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.004071ca(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    fcn.0040890d(0);\n    iVar1 = *0x69af78;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    arg_8h_00 = fcn.004043c0();\n    iVar2 = fcn.004044c7(arg_8h_00);\n    if ((iVar2 == 0) && (iVar2 = iVar1,  iVar1 == 0)) {\n        iVar2 = fcn.00406fc6(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.004091d1(0x401578);\n            fcn.00409853(unaff_EBP + -0x20, 0x41e878);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x69af78 = iVar2;\n        fcn.004043f5();\n        fcn.00404458();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00408935();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 414
    },
    "004075e6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.004075e6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    fcn.0040890d(0);\n    iVar1 = *0x69af7c;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    arg_8h_00 = fcn.004043c0();\n    iVar2 = fcn.004044c7(arg_8h_00);\n    if ((iVar2 == 0) && (iVar2 = iVar1,  iVar1 == 0)) {\n        iVar2 = fcn.00407272(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.004091d1(0x401578);\n            fcn.00409853(unaff_EBP + -0x20, 0x41e878);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x69af7c = iVar2;\n        fcn.004043f5();\n        fcn.00404458();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00408935();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 416
    },
    "0040768e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t __cdecl fcn.0040768e(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    fcn.0040890d(0);\n    iVar1 = *0x69af80;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar1;\n    arg_8h_00 = fcn.004043c0();\n    iVar2 = fcn.004044c7(arg_8h_00);\n    if ((iVar2 == 0) && (iVar2 = iVar1,  iVar1 == 0)) {\n        iVar2 = fcn.00407319(unaff_EBP + -0x10, *(unaff_EBP + 8));\n        if (iVar2 == -1) {\n            fcn.004091d1(0x401578);\n            fcn.00409853(unaff_EBP + -0x20, 0x41e878);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x69af80 = iVar2;\n        fcn.004043f5();\n        fcn.00404458();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00408935();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 414
    },
    "00407f69": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00407f69(uint param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    \n    arg_8h = 0;\n    cVar1 = fcn.004045a2();\n    if (cVar1 == '\\0') {\n        fcn.00404fb3();\n        iVar2 = fcn.00405090();\n        if (iVar2 == -1) {\n            arg_8h = 4;\n        }\n    }\n    fcn.00407736(arg_8h, 0);\n    return param_1;\n}\n",
        "token_count": 136
    },
    "00404694": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404694(uint32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint var_4h;\n    \n    *arg_8h = arg_ch ^ arg_10h;\n    return;\n}\n",
        "token_count": 61
    },
    "004046ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004046ba(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    *arg_8h = *arg_8h + arg_ch;\n    return;\n}\n",
        "token_count": 46
    },
    "004049dc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004049dc(void)\n\n{\n    return;\n}\n",
        "token_count": 15
    },
    "00404ae9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpState\n// WARNING: Variable defined which should be unmapped: lpLastWriteTime\n// WARNING: Variable defined which should be unmapped: lpCreationTime\n// WARNING: Variable defined which should be unmapped: lpMaxCollectionCount\n// WARNING: Variable defined which should be unmapped: lpCollectDataTimeout\n// WARNING: Variable defined which should be unmapped: lpLastAccessTime\n\nuint fcn.00404ae9(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t unaff_ESI;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint lpString1;\n    uint lpBuffer;\n    uint ContextRecord;\n    uint lpUserName;\n    uint lpReturnedString;\n    uint lpConsoleTitle;\n    uint lpCalData;\n    uint lpVersionInformation;\n    uint uStackY272;\n    uint uStackY268;\n    uint uStackY264;\n    uint uStackY260;\n    uint uStackY256;\n    uint uStackY252;\n    uint uStackY248;\n    uint *puStackY244;\n    uint uStackY240;\n    uint uStackY236;\n    uint *puStackY232;\n    uint uStackY228;\n    uint uStackY224;\n    uint *puStackY220;\n    uint uStackY216;\n    uint uStackY212;\n    uint uStackY208;\n    uint uStackY204;\n    uint *puStackY200;\n    uint *puStackY196;\n    uint uStackY192;\n    uint *puStackY188;\n    uint uStackY184;\n    uint uStackY180;\n    uint uStackY176;\n    uint *puStackY172;\n    uint *puStackY168;\n    uint *puStackY164;\n    uint *puStackY160;\n    uint *puStackY156;\n    uint uStackY152;\n    uint uStackY148;\n    uint *puStackY144;\n    uint uStackY140;\n    uint *puStackY136;\n    uint *puStackY132;\n    uint uStackY128;\n    uint *puStackY124;\n    uint uStackY120;\n    uint uStackY116;\n    uint uStackY112;\n    uint lpCriticalSection;\n    uint *puStackY104;\n    uint uStackY100;\n    uint uStackY96;\n    uint *puStackY92;\n    uint uStackY88;\n    uint uStackY84;\n    uint *puStackY80;\n    uint pActCtx;\n    uint *var_44h;\n    uint var_40h;\n    uint *puStackY64;\n    uint *puStackY60;\n    uint uStackY56;\n    uint *puStackY52;\n    uint *puStackY48;\n    uint *lpLastWriteTime;\n    uint *lpCreationTime;\n    uint lpCurInstances;\n    uint lpNumberOfCharsWritten;\n    uint lpLastAccessTime;\n    uint32_t lpState;\n    uint32_t lpValue;\n    int32_t lpCollectDataTimeout;\n    int32_t lpMaxCollectionCount;\n    \n    lpMaxCollectionCount = 0x404af6;\n    fcn.004093a0();\n    uVar3 = 0;\n    lpCollectDataTimeout = unaff_ESI;\n    do {\n        if (uVar3 < 0x214cd) {\n            lpValue = 0;\n            lpState = 0x404b0b;\n            (*_sym.imp.KERNEL32.dll_SetLastError)();\n            lpState = 0x404b11;\n            (*_sym.imp.KERNEL32.dll_GetTickCount)();\n        }\n    } while ((((uVar3 < 0x1e9d5e42) || (lpCollectDataTimeout == 0xad5cf7)) || (var_44h == 0xad4c41c)) &&\n            (uVar3 = uVar3 + 1,  uVar3 < 0x91be26a3));\n    iVar4 = 0;\n    do {\n        if (iVar4 == 0x420) {\n            *0x69af70 = *0x69af70 + 0x38d6;\n        }\n        if (*0x69af70 == 0x7a) {\n            lpValue = 0;\n            lpState = 0;\n            lpLastAccessTime = 0x404b5a;\n            (*_sym.imp.KERNEL32.dll_GetLogicalDriveStringsW)();\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x40dece);\n    lpValue = *0x69af70;\n    lpState = 0;\n    lpLastAccessTime = 0x404b70;\n    *0x6958ec = (*_sym.imp.KERNEL32.dll_LocalAlloc)();\n    uVar3 = 0;\n    if (*0x69af70 != 0) {\n        do {\n            lpNumberOfCharsWritten = 0x404b85;\n            lpState = uVar3;\n            fcn.0040492d(uVar3);\n            if (*0x69af70 == 0x1f) {\n                lpNumberOfCharsWritten = 0;\n                lpCurInstances = 0x404b95;\n                (*_sym.imp.KERNEL32.dll_UnregisterWait)();\n                lpCurInstances = 0;\n                lpCreationTime = &fcn.00404ae9::lpUserName;\n                lpLastWriteTime = &fcn.00404ae9::lpMaxCollectionCount;\n                puStackY48 = &fcn.00404ae9::lpCurInstances;\n                puStackY52 = &fcn.00404ae9::lpState;\n                uStackY56 = 0;\n                puStackY60 = 0x404bb4;\n                (*_sym.imp.KERNEL32.dll_GetNamedPipeHandleStateW)();\n                puStackY60 = &fcn.00404ae9::lpValue;\n                puStackY64 = 0x404bbe;\n                (*_sym.imp.KERNEL32.dll_InterlockedIncrement)();\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *0x69af70);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GetPrivateProfileStructA;\n    iVar4 = 0x5aedbe7;\n    do {\n        if (*0x69af70 == 0x37) {\n            lpNumberOfCharsWritten = 0x404be6;\n            (*_sym.imp.KERNEL32.dll_GetConsoleAliasExesLengthW)();\n            lpNumberOfCharsWritten = 0;\n            lpCurInstances = 0;\n            lpCreationTime = NULL;\n            lpLastWriteTime = 0x404bf0;\n            (*_sym.imp.KERNEL32.dll_EnumCalendarInfoA)();\n            lpLastWriteTime = NULL;\n            puStackY48 = NULL;\n            puStackY52 = NULL;\n            uStackY56 = 0x404bf9;\n            (*_sym.imp.KERNEL32.dll_EnumDateFormatsW)();\n            uStackY56 = 0;\n            puStackY60 = NULL;\n            puStackY64 = &fcn.00404ae9::lpValue;\n            var_40h = 0x404c05;\n            (*_sym.imp.KERNEL32.dll_InterlockedCompareExchange)();\n            var_40h = 0;\n            var_44h = 0x404c0c;\n            (*_sym.imp.KERNEL32.dll_DeleteFiber)();\n            var_44h = 0x401300;\n            pActCtx = 0;\n            puStackY80 = &fcn.00404ae9::lpCalData;\n            uStackY84 = 0x40130c;\n            uStackY88 = 0x401324;\n            puStackY92 = 0x404c25;\n            (*pcVar2)();\n            puStackY92 = &fcn.00404ae9::lpCriticalSection;\n            uStackY96 = 0x404c2f;\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n            uStackY96 = 0;\n            uStackY100 = 0;\n            puStackY104 = 0x404c37;\n            (*_sym.imp.KERNEL32.dll_InterlockedExchange)();\n            puStackY104 = &fcn.00404ae9::ContextRecord;\n            lpCriticalSection = 0x404c44;\n            (*_sym.imp.KERNEL32.dll_RtlCaptureContext)();\n            lpCriticalSection = 0;\n            uStackY112 = 0;\n            uStackY116 = 0;\n            uStackY120 = 0x404c4d;\n            (*_sym.imp.KERNEL32.dll_FindResourceA)();\n            uStackY120 = 0;\n            puStackY124 = 0x404c54;\n            (*_sym.imp.KERNEL32.dll_LocalFlags)();\n            puStackY124 = NULL;\n            uStackY128 = 0;\n            puStackY132 = NULL;\n            puStackY136 = 0x404c5d;\n            (*_sym.imp.KERNEL32.dll_OpenMutexA)();\n            puStackY136 = &fcn.00404ae9::lpMaxCollectionCount;\n            uStackY140 = 0;\n            puStackY144 = 0x401348;\n            uStackY148 = 0;\n            uStackY152 = 0;\n            puStackY156 = 0x404c6f;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExA)();\n            puStackY156 = &fcn.00404ae9::lpState;\n            puStackY160 = &fcn.00404ae9::lpConsoleTitle;\n            puStackY164 = 0x404c80;\n            (*_sym.imp.KERNEL32.dll_GetComputerNameA)();\n            puStackY164 = &fcn.00404ae9::var_40h;\n            puStackY168 = 0x404c8a;\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)();\n        }\n        iVar4 = iVar4 + -1;\n    } while (iVar4 != 0);\n    lpMaxCollectionCount = 0;\n    do {\n        if (*0x69af70 == 0x2e) {\n            lpNumberOfCharsWritten = 0;\n            lpCurInstances = 0x404ca9;\n            (*_sym.imp.KERNEL32.dll_LoadLibraryW)();\n        }\n        if (lpMaxCollectionCount == 0x76069) {\n            lpNumberOfCharsWritten = 0x5413a8;\n            lpCurInstances = 0x404cb9;\n            *0x6993ec = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)();\n        }\n        lpMaxCollectionCount = lpMaxCollectionCount + 1;\n    } while (lpMaxCollectionCount < 0x1756bb);\n    lpNumberOfCharsWritten = 0x5413a8;\n    lpCurInstances = *0x6993ec;\n    *0x5413a8 = 0;\n    lpCreationTime = 0x404cdd;\n    *0x5413a4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    iVar4 = 0;\n    do {\n        if (iVar4 == 0x1c) {\n            lpCreationTime = 0x404cee;\n            fcn.004049ea();\n        }\n        iVar4 = iVar4 + 1;\n    } while (iVar4 < 0x3debc7);\n    lpCreationTime = 0x421010;\n    lpLastWriteTime = *0x6958ec;\n    puStackY48 = 0x404d0d;\n    fcn.004048af(*0x6958ec, *0x69af70, 0x421010);\n    pcVar1 = _sym.imp.KERNEL32.dll_InterlockedDecrement;\n    lpMaxCollectionCount = 0;\n    do {\n        if (*0x69af70 == 0x10) {\n            puStackY48 = NULL;\n            puStackY52 = 0x404d22;\n            (*pcVar1)();\n        }\n        if (lpMaxCollectionCount == 0x1e674) {\n            puStackY48 = 0x404d30;\n            fcn.004049dc();\n        }\n        lpMaxCollectionCount = lpMaxCollectionCount + 1;\n    } while (lpMaxCollectionCount < 0x3e4e2);\n    puStackY48 = 0x404d41;\n    fcn.00404604();\n    if (*0x69af70 == 0x1144) {\n        puStackY48 = NULL;\n        puStackY52 = NULL;\n        uStackY56 = 0;\n        puStackY60 = 0x404d5a;\n        (*_sym.imp.KERNEL32.dll_GetCurrentConsoleFont)();\n        puStackY60 = NULL;\n        puStackY64 = 0x404d61;\n        (*_sym.imp.KERNEL32.dll_GlobalFlags)();\n        puStackY64 = NULL;\n        var_40h = 0;\n        var_44h = NULL;\n        pActCtx = 0x404d6a;\n        (*_sym.imp.KERNEL32.dll_FindNextVolumeA)();\n        pActCtx = 0;\n        puStackY80 = NULL;\n        uStackY84 = 0x404d72;\n        (*_sym.imp.KERNEL32.dll_GetConsoleFontSize)();\n        uStackY84 = 0x401350;\n        uStackY88 = 0;\n        puStackY92 = 0x404d7e;\n        (*_sym.imp.KERNEL32.dll_CreateJobObjectA)();\n        puStackY92 = 0x401358;\n        uStackY96 = 0x404d89;\n        (*_sym.imp.KERNEL32.dll_GetModuleHandleW)();\n        uStackY96 = 0;\n        uStackY100 = 0;\n        puStackY104 = &fcn.00404ae9::lpString1;\n        lpCriticalSection = 0;\n        uStackY112 = 0;\n        uStackY116 = 0;\n        uStackY120 = 0;\n        puStackY124 = 0x404d9c;\n        (*_sym.imp.KERNEL32.dll_FormatMessageW)();\n        puStackY124 = &fcn.00404ae9::pActCtx;\n        uStackY128 = 0x404da6;\n        (*_sym.imp.KERNEL32.dll_CreateActCtxA)();\n        uStackY128 = 0;\n        puStackY132 = &fcn.00404ae9::lpConsoleTitle;\n        puStackY136 = 0x404db4;\n        (*_sym.imp.KERNEL32.dll_GetConsoleTitleA)();\n        puStackY136 = &fcn.00404ae9::lpValue;\n        uStackY140 = 0;\n        puStackY144 = &fcn.00404ae9::lpCalData;\n        uStackY148 = 0;\n        uStackY152 = 0;\n        puStackY156 = NULL;\n        puStackY160 = 0x404dc9;\n        (*_sym.imp.KERNEL32.dll_GetCalendarInfoA)();\n        puStackY160 = NULL;\n        puStackY164 = NULL;\n        puStackY168 = NULL;\n        puStackY172 = &fcn.00404ae9::lpVersionInformation;\n        uStackY176 = 0x404dd9;\n        (*_sym.imp.KERNEL32.dll_VerifyVersionInfoW)();\n        uStackY176 = 0;\n        uStackY180 = 0;\n        uStackY184 = 0;\n        puStackY188 = 0x404de2;\n        (*_sym.imp.KERNEL32.dll_FindFirstChangeNotificationA)();\n        puStackY188 = &fcn.00404ae9::lpState;\n        uStackY192 = 0x404dec;\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)();\n        uStackY192 = 0;\n        puStackY196 = 0x404def;\n        (*pcVar1)();\n        puStackY196 = 0x404df5;\n        (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n        puStackY196 = &fcn.00404ae9::lpCurInstances;\n        puStackY200 = &fcn.00404ae9::lpBuffer;\n        uStackY204 = 0;\n        uStackY208 = 0x401364;\n        uStackY212 = 0x40139c;\n        uStackY216 = 0x4013b0;\n        puStackY220 = 0x404e16;\n        (*_sym.imp.KERNEL32.dll_SearchPathA)();\n        lpCollectDataTimeout = 0;\n        lpMaxCollectionCount = 0;\n        puStackY220 = &fcn.00404ae9::lpLastWriteTime;\n        uStackY224 = 0;\n        puStackY232 = &fcn.00404ae9::lpNumberOfCharsWritten;\n        uStackY228 = 0;\n        uStackY236 = 0;\n        uStackY240 = 0x404e3f;\n        (*_sym.imp.KERNEL32.dll_WriteConsoleOutputA)();\n        uStackY240 = 0;\n        puStackY244 = &fcn.00404ae9::lpReturnedString;\n        uStackY248 = 0x4013d8;\n        uStackY252 = 0x404e52;\n        (*_sym.imp.KERNEL32.dll_GetProfileSectionA)();\n        uStackY252 = 0;\n        uStackY256 = 0;\n        uStackY260 = 0;\n        uStackY264 = 0;\n        uStackY268 = 0;\n        uStackY272 = 0x404e5d;\n        (*_sym.imp.KERNEL32.dll_MoveFileWithProgressA)();\n        uStackY272 = 0x404e63;\n        (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    }\n    if (*0x69af70 == 0x1d) {\n        lpLastWriteTime = NULL;\n        puStackY48 = &fcn.00404ae9::lpNumberOfCharsWritten;\n        puStackY52 = NULL;\n        uStackY56 = 0;\n        puStackY60 = NULL;\n        puStackY64 = 0x404e7f;\n        (*_sym.imp.KERNEL32.dll_WriteConsoleA)();\n        puStackY64 = NULL;\n        var_40h = 0;\n        var_44h = &fcn.00404ae9::lpString1;\n        pActCtx = 0x404e8e;\n        (*_sym.imp.KERNEL32.dll_lstrcpynW)();\n        pActCtx = 0;\n        puStackY80 = NULL;\n        uStackY84 = 0;\n        uStackY88 = 0x404e97;\n        (*_sym.imp.KERNEL32.dll_CopyFileA)();\n        uStackY88 = 0;\n        puStackY92 = 0x404e9e;\n        (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n        puStackY92 = NULL;\n        uStackY96 = 0;\n        uStackY100 = 0;\n        puStackY104 = NULL;\n        lpCriticalSection = 0;\n        uStackY112 = 0x404ea9;\n        (*_sym.imp.KERNEL32.dll_MoveFileWithProgressW)();\n        uStackY112 = 0;\n        uStackY116 = 0;\n        uStackY120 = 0;\n        puStackY124 = NULL;\n        uStackY128 = 0x404eb3;\n        (*_sym.imp.KERNEL32.dll_CreateIoCompletionPort)();\n        uStackY128 = 0x404eb9;\n        (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n        uStackY128 = 0;\n        puStackY132 = &fcn.00404ae9::lpValue;\n        puStackY136 = 0x404ec4;\n        (*_sym.imp.KERNEL32.dll_InterlockedExchange)();\n        puStackY136 = NULL;\n        uStackY140 = 0;\n        puStackY144 = &fcn.00404ae9::lpReturnedString;\n        uStackY148 = 0;\n        uStackY152 = 0;\n        puStackY156 = 0x404ed1;\n        (*pcVar2)();\n        puStackY156 = NULL;\n        puStackY160 = 0x404ed8;\n        (*_sym.imp.KERNEL32.dll_DeleteVolumeMountPointA)();\n        puStackY160 = NULL;\n        puStackY164 = 0x404edf;\n        (*_sym.imp.KERNEL32.dll_GetConsoleAliasesLengthA)();\n        puStackY164 = &fcn.00404ae9::lpLastWriteTime;\n        puStackY168 = &fcn.00404ae9::lpLastAccessTime;\n        puStackY172 = &fcn.00404ae9::lpCreationTime;\n        uStackY176 = 0;\n        uStackY180 = 0x404ef2;\n        (*_sym.imp.KERNEL32.dll_GetFileTime)();\n        uStackY180 = 0;\n        uStackY184 = 0;\n        puStackY188 = NULL;\n        uStackY192 = 0;\n        puStackY196 = 0x404efc;\n        (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n    }\n    lpLastWriteTime = 0x404f01;\n    fcn.004049d6();\n    return 0;\n}\n",
        "token_count": 4685
    },
    "00405228": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405228(int32_t param_1)\n\n{\n    fcn.00409065(*(param_1 + 4));\n    return;\n}\n",
        "token_count": 37
    },
    "00405291": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405291(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404fb3();\n    if (iVar1 != 0) {\n        iVar1 = fcn.00404fb3();\n        fcn.00409075(*(iVar1 + 4));\n        return;\n    }\n    return;\n}\n",
        "token_count": 76
    },
    "00405439": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405439(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    fcn.00404341(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 62
    },
    "00405454": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405454(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    fcn.0040435d(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 63
    },
    "004054b1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004054b1(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00408730(arg_8h & 0xff, in_ECX + 8);\n    return;\n}\n",
        "token_count": 56
    },
    "004054f4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004054f4(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    fcn.00408df4(arg_8h & 0xff, in_ECX + 8);\n    return;\n}\n",
        "token_count": 57
    },
    "004056c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004056c0(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    **(in_ECX + 0x34) = **(in_ECX + 0x34) - arg_8h;\n    **(in_ECX + 0x24) = **(in_ECX + 0x24) + arg_8h;\n    return;\n}\n",
        "token_count": 93
    },
    "00405cba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.00405cba(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint *arg_ch;\n    uint var_1h;\n    \n    arg_ch = &var_1h;\n    *(in_ECX + 0x14) = arg_8h;\n    iVar1 = fcn.0040505c();\n    fcn.0040431e(iVar1 + arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 127
    },
    "00405d34": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00405d34(void)\n\n{\n    return 0x9249249;\n}\n",
        "token_count": 22
    },
    "00405f1c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00405f1c(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) <= arg_8h && arg_8h != *(in_ECX + 0x14)) {\n        fcn.00409a95();\n    }\n    iVar1 = fcn.0040505c();\n    return iVar1 + arg_8h;\n}\n",
        "token_count": 107
    },
    "0040605e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.0040605e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = &stack0xffffffe0;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    uVar2 = fcn.00405df3();\n    *(unaff_EBP + 8) = uVar2;\n    *(extraout_ECX + 8) = 0;\n    *(extraout_ECX + 0x10) = 0;\n    *(extraout_ECX + 0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.004043aa(unaff_EBP + -0x20);\n    uVar2 = fcn.00405fab(*(*(unaff_EBP + 8) + 8));\n    *(extraout_ECX + 8) = uVar2;\n    uVar2 = fcn.004043aa(unaff_EBP + -0x20);\n    uVar2 = fcn.00405df8(0, uVar2);\n    uVar2 = fcn.00405fab(uVar2);\n    *(extraout_ECX + 0x10) = uVar2;\n    uVar2 = fcn.004043aa(unaff_EBP + -0x20);\n    uVar2 = fcn.00405dfe(0, uVar2);\n    uVar2 = fcn.00405fab(uVar2);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(extraout_ECX + 0x14) = uVar2;\n    fcn.004043aa(unaff_EBP + -0x20);\n    uVar1 = fcn.00405fa3(***(unaff_EBP + 8));\n    *(extraout_ECX + 0xc) = uVar1;\n    fcn.004043aa(unaff_EBP + -0x20);\n    uVar1 = fcn.00405fa3(**(*(unaff_EBP + 8) + 4));\n    *(extraout_ECX + 0xd) = uVar1;\n    if (*(unaff_EBP + 0xc) != '\\0') {\n        fcn.004043aa(unaff_EBP + -0x20);\n        uVar2 = fcn.00405fab(0x40150d);\n        *(extraout_ECX + 8) = uVar2;\n        fcn.004043aa(unaff_EBP + -0x20);\n        uVar1 = fcn.00405fa3(0x2e);\n        *(extraout_ECX + 0xc) = uVar1;\n        fcn.004043aa(unaff_EBP + -0x18);\n        uVar1 = fcn.00405fa3(0x2c);\n        *(extraout_ECX + 0xd) = uVar1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 864
    },
    "004061af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004061af(uchar *arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    int32_t arg_8h_00;\n    uint arg_10h_00;\n    int32_t *in_ECX;\n    uchar *arg_8h_01;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    arg_8h_01 = arg_8h;\n    iVar3 = arg_10h;\n    if (0 < arg_10h) {\n        do {\n            arg_8h_00 = fcn.004056b1();\n            if (arg_8h_00 < 1) {\n                arg_10h = (**(*in_ECX + 0x14))();\n                arg_8h = fcn.00405660();\n                cVar1 = fcn.0040564c(&arg_8h, &arg_10h);\n                if (cVar1 != '\\0') {\n                    return var_4h;\n                }\n                uVar2 = fcn.00405637(&arg_10h);\n                *arg_8h_01 = uVar2;\n                arg_8h_01 = arg_8h_01 + 1;\n                var_4h = var_4h + 1;\n                iVar4 = -1;\n            }\n            else {\n                if (iVar3 < arg_8h_00) {\n                    arg_8h_00 = iVar3;\n                }\n                iVar4 = arg_8h_00;\n                arg_10h_00 = fcn.004050a3();\n                fcn.00405d6e(arg_8h_01, arg_ch, arg_10h_00, iVar4);\n                var_4h = var_4h + arg_8h_00;\n                arg_8h_01 = arg_8h_01 + arg_8h_00;\n                iVar4 = -arg_8h_00;\n                fcn.0040568d(arg_8h_00);\n            }\n            iVar3 = iVar3 + iVar4;\n        } while (0 < iVar3);\n    }\n    return var_4h;\n}\n",
        "token_count": 520
    },
    "00406247": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00406247(int32_t arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    int32_t iVar4;\n    int32_t arg_8h_00;\n    int32_t arg_10h;\n    int32_t arg_14h;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    iVar4 = arg_ch;\n    var_8h = in_ECX;\n    if (0 < arg_ch) {\n        do {\n            iVar2 = fcn.004056d4();\n            if (iVar2 < 1) {\n                iVar2 = *in_ECX;\n                uVar3 = fcn.00405641(arg_8h);\n                arg_ch = (**(iVar2 + 4))(uVar3);\n                var_8h = fcn.00405660();\n                cVar1 = fcn.0040564c(&var_8h, &arg_ch);\n                if (cVar1 != '\\0') {\n                    return var_4h;\n                }\n                arg_8h = arg_8h + 1;\n                var_4h = var_4h + 1;\n                iVar2 = -1;\n            }\n            else {\n                arg_8h_00 = iVar2;\n                if (iVar4 < iVar2) {\n                    arg_8h_00 = iVar4;\n                }\n                arg_10h = arg_8h;\n                arg_14h = arg_8h_00;\n                uVar3 = fcn.004050a9();\n                fcn.00405d6e(uVar3, iVar2, arg_10h, arg_14h);\n                arg_8h = arg_8h + arg_8h_00;\n                var_4h = var_4h + arg_8h_00;\n                iVar2 = -arg_8h_00;\n                fcn.004056c0(arg_8h_00);\n            }\n            iVar4 = iVar4 + iVar2;\n        } while (0 < iVar4);\n    }\n    return var_4h;\n}\n",
        "token_count": 498
    },
    "00406539": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406539(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t arg_14h;\n    int32_t iVar2;\n    int32_t arg_ch_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.00408f98();\n    }\n    uVar1 = *(in_ECX + 0x14) - arg_8h;\n    if (uVar1 < arg_ch) {\n        arg_ch = uVar1;\n    }\n    if (arg_ch != 0) {\n        arg_14h = uVar1 - arg_ch;\n        iVar2 = fcn.0040505c();\n        iVar2 = iVar2 + arg_8h + arg_ch;\n        arg_ch_00 = *(in_ECX + 0x18) - arg_8h;\n        iVar3 = fcn.0040505c();\n        fcn.00405d92(iVar3 + arg_8h, arg_ch_00, iVar2, arg_14h);\n        fcn.00405cba(*(in_ECX + 0x14) - arg_ch);\n    }\n    return;\n}\n",
        "token_count": 287
    },
    "00406a6e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406a6e(uint32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    \n    if (-*(in_ECX + 0x14) - 1U <= arg_8h) {\n        fcn.00408f60();\n    }\n    if (arg_8h != 0) {\n        arg_8h_00 = *(in_ECX + 0x14) + arg_8h;\n        cVar1 = fcn.004069dc(arg_8h_00, 0);\n        if (cVar1 != '\\0') {\n            fcn.00405f69(*(in_ECX + 0x14), arg_8h, arg_ch);\n            fcn.00405cba(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "00406abe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406abe(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t arg_14h;\n    int32_t iVar2;\n    int32_t arg_ch_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.00408f98();\n    }\n    if (-*(in_ECX + 0x14) - 1U <= arg_ch) {\n        fcn.00408f60();\n    }\n    if (arg_ch != 0) {\n        arg_8h_00 = *(in_ECX + 0x14) + arg_ch;\n        cVar1 = fcn.004069dc(arg_8h_00, 0);\n        if (cVar1 != '\\0') {\n            arg_14h = *(in_ECX + 0x14) - arg_8h;\n            iVar2 = fcn.0040505c();\n            iVar2 = iVar2 + arg_8h;\n            arg_ch_00 = (*(in_ECX + 0x18) - arg_8h) - arg_ch;\n            iVar3 = fcn.0040505c();\n            fcn.00405d92(iVar3 + arg_8h + arg_ch, arg_ch_00, iVar2, arg_14h);\n            fcn.00405f69(arg_8h, arg_ch, arg_10h);\n            fcn.00405cba(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 376
    },
    "00406b5f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406b5f(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t arg_ch_00;\n    int32_t iVar6;\n    int32_t in_ECX;\n    \n    uVar3 = fcn.00404f95();\n    if (uVar3 < arg_ch) {\n        fcn.00408f98();\n    }\n    iVar4 = fcn.00404f95();\n    if (iVar4 - arg_ch < arg_10h) {\n        arg_10h = iVar4 - arg_ch;\n    }\n    if ((-*(in_ECX + 0x14) - 1U <= arg_10h) || (*(in_ECX + 0x14) + arg_10h < *(in_ECX + 0x14))) {\n        fcn.00408f60();\n    }\n    if (arg_10h != 0) {\n        iVar4 = *(in_ECX + 0x14) + arg_10h;\n        cVar2 = fcn.004069dc(iVar4, 0);\n        if (cVar2 != '\\0') {\n            iVar1 = *(in_ECX + 0x14);\n            iVar5 = fcn.0040505c();\n            iVar5 = iVar5 + arg_ch;\n            arg_ch_00 = *(in_ECX + 0x18) - iVar1;\n            iVar6 = fcn.0040505c();\n            fcn.00405d6e(iVar6 + iVar1, arg_ch_00, iVar5, arg_10h);\n            fcn.00405cba(iVar4);\n        }\n    }\n    return;\n}\n",
        "token_count": 409
    },
    "00406d23": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406d23(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    uint arg_ch_00;\n    uint32_t arg_14h;\n    \n    uVar2 = fcn.00404f95();\n    if (uVar2 < arg_ch) {\n        fcn.00408f98();\n    }\n    iVar3 = fcn.00404f95();\n    uVar2 = iVar3 - arg_ch;\n    if (arg_10h < iVar3 - arg_ch) {\n        uVar2 = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.00406539(uVar2 + arg_ch, 0xffffffff);\n        fcn.00406539(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.004069dc(uVar2, 0);\n        if (cVar1 != '\\0') {\n            arg_14h = uVar2;\n            iVar3 = fcn.0040505c();\n            iVar3 = iVar3 + arg_ch;\n            arg_ch_00 = *(in_ECX + 0x18);\n            arg_8h_00 = fcn.0040505c();\n            fcn.00405d6e(arg_8h_00, arg_ch_00, iVar3, arg_14h);\n            fcn.00405cba(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 364
    },
    "00406e1b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406e1b(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    int32_t iVar3;\n    int32_t arg_ch_00;\n    int32_t iVar4;\n    int32_t in_ECX;\n    \n    cVar2 = fcn.004052b8(arg_8h);\n    if (cVar2 == '\\0') {\n        if ((-*(in_ECX + 0x14) - 1U <= arg_ch) || (*(in_ECX + 0x14) + arg_ch < *(in_ECX + 0x14))) {\n            fcn.00408f60();\n        }\n        if (arg_ch != 0) {\n            iVar3 = *(in_ECX + 0x14) + arg_ch;\n            cVar2 = fcn.004069dc(iVar3, 0);\n            if (cVar2 != '\\0') {\n                iVar1 = *(in_ECX + 0x14);\n                arg_ch_00 = *(in_ECX + 0x18) - iVar1;\n                iVar4 = fcn.0040505c();\n                fcn.00405d6e(iVar4 + iVar1, arg_ch_00, arg_8h, arg_ch);\n                fcn.00405cba(iVar3);\n            }\n        }\n    }\n    else {\n        iVar3 = fcn.0040505c();\n        fcn.00406b5f(in_ECX, arg_8h - iVar3, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 353
    },
    "00406fa9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406fa9(uint arg_8h)\n\n{\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    fcn.00406ea9(*in_ECX + 0x18);\n    return arg_8h;\n}\n",
        "token_count": 61
    },
    "0040711e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint * __cdecl fcn.0040711e(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00409151(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0x401538;\n    fcn.00406ea9(arg_8h_00 + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 248
    },
    "00407481": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint * __cdecl fcn.00407481(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00409151(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = 0x401544;\n    fcn.00406ea9(arg_8h_00 + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 247
    },
    "00407555": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407555(uint32_t arg_8h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 0x10) = 0;\n    *(in_ECX + 0x14) = 0;\n    if (arg_8h == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar2 = fcn.00405d34();\n        if (uVar2 < arg_8h) {\n            fcn.004070e5();\n        }\n        iVar3 = fcn.00405d3c(arg_8h);\n        *(in_ECX + 0xc) = iVar3;\n        *(in_ECX + 0x10) = iVar3;\n        *(in_ECX + 0x14) = arg_8h * 0x1c + iVar3;\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 244
    },
    "00407fae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.00407fae(uint arg_8h)\n\n{\n    uint uVar1;\n    char cVar2;\n    uchar uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0040525c(*(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    cVar2 = fcn.00404597();\n    if (cVar2 != '\\0') {\n        iVar4 = fcn.00405224();\n        if (iVar4 != 0) {\n            fcn.00405224();\n            fcn.00407f69();\n        }\n    }\n    uVar3 = fcn.00404597();\n    uVar1 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 4) = uVar3;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 319
    },
    "0040801c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040801c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    uint in_ECX;\n    uint var_48h;\n    uint var_8h;\n    \n    uVar1 = fcn.004045b0();\n    uVar1 = fcn.00405ea7(in_ECX, &var_8h, 0x4015d4, uVar1);\n    uVar1 = fcn.00409c46(&var_48h, 0x40, uVar1, arg_1ch);\n    fcn.00407d46(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_48h, uVar1);\n    return arg_8h;\n}\n",
        "token_count": 205
    },
    "00408074": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408074(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    uint in_ECX;\n    uint var_48h;\n    uint var_8h;\n    \n    uVar1 = fcn.004045b0();\n    uVar1 = fcn.00405ea7(in_ECX, &var_8h, 0x4015d8, uVar1);\n    uVar1 = fcn.00409c46(&var_48h, 0x40, uVar1, arg_1ch);\n    fcn.00407d46(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_48h, uVar1);\n    return arg_8h;\n}\n",
        "token_count": 204
    },
    "004080cc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.004080cc(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint in_ECX;\n    uint var_40h;\n    \n    uVar2 = arg_1ch;\n    uVar1 = fcn.004045b0(arg_1ch, arg_20h);\n    uVar1 = fcn.00405ea7(in_ECX, &arg_1ch, 0x4015dc, uVar1);\n    uVar2 = fcn.00409c46(&var_40h, 0x40, uVar1, uVar2);\n    fcn.00407d46(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_40h, uVar2);\n    return arg_8h;\n}\n",
        "token_count": 226
    },
    "00408127": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00408127(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    uint in_ECX;\n    uint var_40h;\n    \n    uVar2 = arg_1ch;\n    uVar1 = fcn.004045b0(arg_1ch, arg_20h);\n    uVar1 = fcn.00405ea7(in_ECX, &arg_1ch, 0x4015e0, uVar1);\n    uVar2 = fcn.00409c46(&var_40h, 0x40, uVar1, uVar2);\n    fcn.00407d46(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_40h, uVar2);\n    return arg_8h;\n}\n",
        "token_count": 227
    },
    "00408411": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00408411(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint arg_24h;\n    uint in_ECX;\n    uint var_40h;\n    \n    arg_24h = fcn.00409c46(&var_40h, 0x40, 0x401608, arg_1ch);\n    fcn.00407d46(in_ECX, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, &var_40h, arg_24h);\n    return arg_8h;\n}\n",
        "token_count": 155
    },
    "00408452": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.00408452(void)\n\n{\n    uint32_t uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_4h;\n    uint var_ch;\n    uint var_10h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = &var_ch;\n    uVar1 = fcn.004045b0();\n    if ((uVar1 & 2) != 0) {\n        fcn.00407f69();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 168
    },
    "004085af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_30h\n\nint32_t * fcn.004085af(void)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t *arg_8h;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_18h;\n    uint var_10h;\n    uint var_38h;\n    uint var_30h;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h_2;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x10) = &stack0xffffffc8;\n    *(unaff_EBP + -0x14) = arg_8h;\n    fcn.00407fae(arg_8h);\n    *(unaff_EBP + -4) = 0;\n    cVar2 = fcn.00405184();\n    if (cVar2 != '\\0') {\n        uVar3 = fcn.004045b4(unaff_EBP + -0x1c);\n        *(unaff_EBP + -4) = 1;\n        uVar3 = fcn.004075e6(uVar3);\n        *(unaff_EBP + -0x20) = uVar3;\n        fcn.004044af();\n        iVar1 = *(*arg_8h + 4);\n        *(unaff_EBP + -4) = 2;\n        uVar3 = fcn.00404fb3();\n        puVar4 = fcn.004051a9(uVar3);\n        uVar3 = *(unaff_EBP + 8);\n        uVar5 = fcn.0040507a();\n        fcn.00405188(unaff_EBP + -0x38, *puVar4, puVar4[1], iVar1 + arg_8h, uVar5 & 0xff, uVar3);\n        cVar2 = fcn.004051bb();\n        if (cVar2 != '\\0') {\n            *(unaff_EBP + -0x18) = 4;\n        }\n        *(unaff_EBP + -4) = 0;\n    }\n    fcn.00407736(*(unaff_EBP + -0x18), 0);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00408572();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return arg_8h;\n}\n",
        "token_count": 638
    },
    "00409ec6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409ec6(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040eac8(0x41ee10, 0xc);\n    if (*(unaff_EBP + 0xc) == 0) {\n        puVar1 = fcn.0040b128();\n        *puVar1 = 0x16;\n        fcn.00409a6f(0, 0, 0, 0, 0);\n    }\n    else {\n        uVar2 = fcn.004103dd();\n        fcn.004104f5(0, uVar2);\n        *(unaff_EBP + -4) = 0;\n        uVar2 = fcn.004103dd(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        uVar2 = (**(unaff_EBP + 8))(uVar2);\n        *(unaff_EBP + -0x1c) = uVar2;\n        *(unaff_EBP + -4) = 0xfffffffe;\n        fcn.00409f3d();\n    }\n    fcn.0040eb0d();\n    return;\n}\n",
        "token_count": 340
    },
    "00409f4c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409f4c(uint arg_8h, uint arg_ch)\n\n{\n    fcn.00409ec6(fcn.0041065c, arg_8h, 0, &arg_ch);\n    return;\n}\n",
        "token_count": 55
    },
    "0040ff4f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040ff4f(uint arg_8h)\n\n{\n    fcn.0040fe23(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 42
    },
    "00411d9e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00411db2)\n// WARNING: Removing unreachable block (ram,0x00411db8)\n// WARNING: Removing unreachable block (ram,0x00411dba)\n\nvoid fcn.00411d9e(void)\n\n{\n    return;\n}\n",
        "token_count": 64
    },
    "0040492d": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get hostname",
            "get OS version",
            "get common file path",
            "delete file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040492d(int32_t arg_8h)\n\n{\n    uint var_89ch;\n    uint lpBuffer;\n    uint lpVersionInformation;\n    \n    if (*0x69af70 == 0x37) {\n        (*_sym.imp.KERNEL32.dll_GetComputerNameExW)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_FindResourceA)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_IsBadReadPtr)(0, 0);\n        (*_sym.imp.KERNEL32.dll_lstrlenW)(0x4012c4);\n        (*_sym.imp.KERNEL32.dll_DeleteFileA)(0x4012d0);\n        (*_sym.imp.KERNEL32.dll_GetWindowsDirectoryA)(&lpBuffer, 0);\n        (*_sym.imp.KERNEL32.dll_MapViewOfFileEx)(0, 0, 0, 0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(0, &var_89ch, 0);\n        (*_sym.imp.KERNEL32.dll_DebugBreak)();\n        (*_sym.imp.KERNEL32.dll_LocalSize)(0);\n        (*_sym.imp.KERNEL32.dll_VerifyVersionInfoA)(&lpVersionInformation, 0, 0, 0);\n    }\n    *(*0x6958ec + arg_8h) = *(*0x69af74 + 0x38d6 + arg_8h);\n    return;\n}\n",
        "token_count": 330
    },
    "004052e8": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004052e8(int32_t param_1)\n\n{\n    *(param_1 + 0x10) = param_1 + 8;\n    *(param_1 + 0x14) = param_1 + 0xc;\n    *(param_1 + 0x20) = param_1 + 0x18;\n    *(param_1 + 0x24) = param_1 + 0x1c;\n    *(param_1 + 0x30) = param_1 + 0x28;\n    *(param_1 + 0x34) = param_1 + 0x2c;\n    fcn.004050e6(0, 0);\n    fcn.004050ba(0, 0, 0);\n    return;\n}\n",
        "token_count": 178
    },
    "004074f0": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004074f0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    *(param_1 + 0x24) = 0;\n    *(param_1 + 4) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0x201;\n    *(param_1 + 0x14) = 6;\n    *(param_1 + 0x18) = 0;\n    *(param_1 + 0x1c) = 0;\n    *(param_1 + 0x20) = 0;\n    fcn.004074df(0);\n    iVar1 = fcn.004097ee(4);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.0040447c();\n    }\n    *(param_1 + 0x24) = uVar2;\n    return;\n}\n",
        "token_count": 234
    },
    "0041bc01": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0041bc01(void)\n\n{\n    *0x5410b4 = (*_sym.imp.KERNEL32.dll_CreateFileA)(0x403934, 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 64
    },
    "00405fab": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405fab(char *arg_8h)\n\n{\n    char cVar1;\n    char *pcVar2;\n    char *pcVar3;\n    \n    pcVar2 = arg_8h;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    pcVar2 = pcVar2 + (1 - (arg_8h + 1));\n    pcVar3 = fcn.00408f06(pcVar2);\n    for (; pcVar2 != NULL; pcVar2 = pcVar2 + -1) {\n        *pcVar3 = *arg_8h;\n        pcVar3 = pcVar3 + 1;\n        arg_8h = arg_8h + 1;\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "004073cc": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_94h\n\nvoid __cdecl fcn.004073cc(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_94h;\n    int32_t arg_8h_00;\n    uint in_stack_ffffff74;\n    uint var_6ch;\n    uint var_50h;\n    uint var_28h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.004097b4();\n    uVar1 = *(unaff_EBP + 8) & 0x17;\n    *(extraout_ECX + 8) = uVar1;\n    uVar1 = *(extraout_ECX + 0xc) & uVar1;\n    if (uVar1 == 0) {\n        *in_FS_OFFSET = *(unaff_EBP + -0xc);\n        return;\n    }\n    uVar2 = 0;\n    if (*(unaff_EBP + 0xc) == '\\0') goto code_r0x004073fe;\n    in_stack_ffffff74 = 0;\n    arg_8h_00 = 0;\n    do {\n        while( true ) {\n            fcn.00409853(arg_8h_00, in_stack_ffffff74);\n            uVar1 = extraout_ECX_00;\ncode_r0x004073fe:\n            if ((uVar1 & 4) == 0) break;\n            fcn.004070b4(0x4015b4);\n            *(unaff_EBP + -4) = uVar2;\ncode_r0x00407413:\n            fcn.0040706f(unaff_EBP + -0x28);\n            arg_8h_00 = unaff_EBP + -0x50;\n        }\n        uVar2 = 2;\n        if ((uVar1 & 2) != 0) {\n            fcn.004070b4(0x40159c);\n            *(unaff_EBP + -4) = 1;\n            goto code_r0x00407413;\n        }\n        fcn.004070b4(0x401584);\n        *(unaff_EBP + -4) = 2;\n        fcn.0040706f(unaff_EBP + -0x6c);\n        arg_8h_00 = unaff_EBP + -0x94;\n    } while( true );\n}\n",
        "token_count": 575
    },
    "00408f06": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00408f06(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar auStack16 [12];\n    \n    do {\n        iVar2 = fcn.0040d2c2(param_1);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.0040ddfb(param_1);\n    } while (iVar2 != 0);\n    if ((*0x69b1b0 & 1) == 0) {\n        *0x69b1b0 = *0x69b1b0 | 1;\n        fcn.004097d3();\n        fcn.0040b298(0x41c545);\n    }\n    fcn.004053f1(0x69b1a4);\n    fcn.00409853(auStack16, 0x41e594);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 221
    },
    "0040d38c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d38c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0040eac8(0x41f058, 0xc);\n    fcn.0040dfcf(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x69b1e8;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x69b1e4;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x0040d3d0;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.004098aa(arg_8h_00);\ncode_r0x0040d3d0:\n        fcn.004098aa(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0040d3f3();\n    fcn.0040eb0d();\n    return;\n}\n",
        "token_count": 408
    },
    "00409e93": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00409e93(uint lpExistingFileName, uint lpNewFileName)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileA)(lpExistingFileName, lpNewFileName);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    else {\n        iVar1 = 0;\n    }\n    if (iVar1 != 0) {\n        fcn.0040b14e(iVar1);\n        return 0xffffffff;\n    }\n    return 0;\n}\n",
        "token_count": 130
    }
}