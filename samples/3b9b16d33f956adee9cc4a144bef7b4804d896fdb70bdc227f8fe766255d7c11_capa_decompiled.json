{
    "00401000": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401080)\n// WARNING: Removing unreachable block (ram,0x004010bc)\n// WARNING: Removing unreachable block (ram,0x00401077)\n// WARNING: Removing unreachable block (ram,0x00401087)\n// WARNING: Removing unreachable block (ram,0x004010b3)\n// WARNING: Removing unreachable block (ram,0x00401090)\n// WARNING: Removing unreachable block (ram,0x00401054)\n\nuint fcn.00401000(void)\n\n{\n    uint uVar1;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    // [00] -r-x section size 45056 named .text\n    uVar1 = fcn.00402325(0, 0xffffef2d, 0xb3);\n    return uVar1;\n}\n",
        "token_count": 207
    },
    "00401105": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint8_t __cdecl fcn.00401105(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t arg_10h_00;\n    uint32_t uVar1;\n    uint var_ch;\n    uint var_8h;\n    uint flNewProtect;\n    \n    arg_10h_00 = (arg_8h & 0xff) - 1 & 0xff;\n    uVar1 = (arg_ch ^ arg_8h & 0xff) & 0xffff;\n    var_ch._0_1_ = arg_8h;\n    if (arg_8h == 0x165) {\n        if (uVar1 == 0x100) {\n            if (((arg_8h == 0x165) && (arg_10h_00 != 0x9c)) && (arg_10h_00 == 100)) {\n                fcn.0040260d(0x65, 0x165);\n            }\n        }\n        else if (uVar1 == 0x4bfa) {\n            fcn.00403d50(arg_8h & 0xffff, arg_8h & 0xff & arg_10h_00, arg_10h_00, arg_8h);\n        }\n        else if ((uVar1 != 0x198e) && (0x57bd < uVar1)) {\n            var_ch._0_1_ = -(arg_ch | var_ch);\n        }\n    }\n    else if (arg_8h == -0x5518) {\n        (*_sym.imp.KERNEL32.dll_OutputDebugStringA)(uVar1 & arg_8h & 0xffff | arg_8h);\n        var_ch._0_1_ = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                                 (arg_8h * (arg_8h | 200), arg_10h_00 + 0x6c0000 + (arg_8h & 0xff), arg_8h & 0xffff, \n                                  arg_10h_00);\n    }\n    return var_ch;\n}\n",
        "token_count": 479
    },
    "0040163e": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Removing unreachable block (ram,0x00401701)\n// WARNING: Removing unreachable block (ram,0x00401709)\n\nuint32_t __cdecl fcn.0040163e(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint var_4h;\n    \n    arg_ch = arg_ch & 0xced1 & arg_ch;\n    if (arg_10h < 0x1cbf) {\n        if (arg_10h < 0x998a) {\n            if (arg_10h < 0xa4da) {\n                if (0x2986 < arg_10h) {\n                    return arg_ch;\n                }\n                if (arg_10h == 0) {\n                    if (arg_ch == 0) {\n                        fcn.004034cd(arg_ch, arg_ch, arg_ch % 0x28);\n                    }\n                    else if (0x16bd < arg_ch) {\n                        fcn.00403d50(arg_ch + 0xc2b1, arg_ch % 0x28, arg_ch * 0xde, 0);\n                    }\n                }\n            }\n            else {\n                fcn.00403d50(unaff_EBX, unaff_EDI, unaff_ESI, var_4h);\n            }\n        }\n        arg_10h = 0;\n    }\n    return arg_10h;\n}\n",
        "token_count": 346
    },
    "00401865": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401b32)\n// WARNING: Removing unreachable block (ram,0x00401b50)\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00401865(uint32_t arg_8h)\n\n{\n    uint16_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint32_t var_3ch;\n    uint32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint32_t var_20h;\n    uint var_1ch;\n    uint32_t *var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar7 = arg_8h & 0xffff;\n    uVar3 = uVar7 * 0x1000000 >> 1;\n    uVar6 = *((uVar7 & arg_8h) + 0x431297);\n    uVar8 = (arg_8h ^ 0x1a80) & 0xffff;\n    var_18h = *((uVar8 + arg_8h + -0x1a80) * 4 + 0x43128f);\n    var_20h = arg_8h + uVar3;\n    do {\n        if (uVar6 <= var_20h) {\n            uVar6 = arg_8h * -0x35ffffff + 0xca000000;\n            (**(((arg_8h & uVar8) + 0xf04b0000 & uVar8) * 4 + 0x43128f))\n                      ((uVar8 - uVar6) + -0x35bf5a40, (uVar6 - uVar8) + 0x3640dac4);\n            return (arg_8h & uVar6) + arg_8h;\n        }\n        uVar1 = arg_8h;\n        var_28h._0_2_ = uVar1 + 0x3748;\n        var_2ch._0_2_ = uVar1 + var_28h;\n        uVar4 = arg_8h & 0xaaacf5fa | var_28h;\n        var_38h = *var_18h;\n        uVar5 = arg_8h + 0x45;\n        if (uVar5 < 0xd6) {\n            if (uVar5 == 0x45) {\n                var_3ch = var_18h[1];\n            }\n            else if (uVar5 == 0xe6) {\n                var_2ch._0_2_ = 0xe6 / uVar4;\n            }\n            else if (uVar5 < 6) {\n                var_28h._0_2_ = var_2ch | var_28h;\n            }\n            else if (uVar5 == 0xee) {\n                fcn.00403e94();\n            }\n        }\n        else {\n            var_28h._0_2_ = 0;\n        }\n        uVar2 = var_2ch >> 3;\n        var_48h = (uVar5 - uVar2) + -0x3910c83c;\n        for (var_44h = var_28h * arg_8h + 0x20; var_44h != 0; var_44h = var_44h + -1) {\n            var_3ch = var_3ch - (var_38h * 0x10 + 0x850fccc2 ^ var_38h + var_48h ^\n                                (var_38h >> 5) + uVar7 * 0x1000000 * arg_8h + 0x49547713);\n            var_38h = var_38h - (var_3ch * 0x10 + (uVar7 - uVar3) + -0x7d8f26e1 ^ var_3ch + var_48h ^\n                                (var_3ch >> 5) + 0x5bec786b);\n            var_48h = var_48h - (((arg_8h & 0xff) << 8 ^ uVar1 / 0x34) + 0x9e3779b9);\n        }\n        *var_18h = var_38h;\n        var_18h[1] = var_3ch;\n        if ((uVar4 < 0x5130) && (uVar4 == 0x3748)) {\n            if (uVar2 == 0xe9) {\n                if (var_28h == 0x3748) {\n                    var_20h = var_20h + 8;\n                }\n            }\n            else if (uVar2 == 0x8b) {\n                return var_28h;\n            }\n        }\n        var_18h = var_18h + 2;\n    } while( true );\n}\n",
        "token_count": 1223
    },
    "00401c6a": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401d38)\n// WARNING: Removing unreachable block (ram,0x00401d41)\n\nuint32_t __cdecl fcn.00401c6a(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t noname_0;\n    uint32_t arg_ch_00;\n    uint32_t arg_14h;\n    uint hWnd;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_ch_00 = (arg_ch & 0xffff) >> 3 & 0xff;\n    arg_14h = arg_ch_00 - (arg_8h ^ 0x4da5) & 0xff;\n    noname_0 = arg_ch_00 - 0xd86900;\n    uVar1 = arg_ch * 0xf98a * arg_14h;\n    if (0x5ab8 < uVar1) {\n        if (uVar1 == 0xa3a551d4) {\n            fcn.00401e83(noname_0, arg_ch_00, noname_0, arg_14h);\n        }\n        (*_sym.imp.USER32.dll_SetFocus)((arg_ch & 0xffff) - 0xf7);\n        fcn.0040339f();\n        noname_0 = arg_ch | noname_0;\n    }\n    return noname_0;\n}\n",
        "token_count": 320
    },
    "00402117": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402295)\n// WARNING: Removing unreachable block (ram,0x004022a7)\n// WARNING: Removing unreachable block (ram,0x004022af)\n// WARNING: Removing unreachable block (ram,0x0040221a)\n// WARNING: Removing unreachable block (ram,0x00402212)\n// WARNING: Removing unreachable block (ram,0x00402184)\n// WARNING: Removing unreachable block (ram,0x004021c3)\n// WARNING: Removing unreachable block (ram,0x00402170)\n// WARNING: Removing unreachable block (ram,0x0040229d)\n// WARNING: Removing unreachable block (ram,0x0040225b)\n// WARNING: Removing unreachable block (ram,0x00402261)\n// WARNING: Could not reconcile some variable overlaps\n\nuchar fcn.00402117(void)\n\n{\n    uchar uVar1;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_8h._0_2_ = fcn.004028f7(0xba00, 0, 0, 0);\n    if (var_8h == 0x5f) {\n        fcn.00401786();\n    }\n    else if ((var_8h < 0x3bb0) && (0xfed0 < var_8h)) {\n        var_8h._0_2_ = var_8h - 1;\n    }\n    uVar1 = (*_sym.imp.USER32.dll_SetFocus)(var_8h - 0x5f);\n    return uVar1;\n}\n",
        "token_count": 364
    },
    "0040260d": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004026e1)\n// WARNING: Removing unreachable block (ram,0x00402707)\n// WARNING: Removing unreachable block (ram,0x004026d9)\n// WARNING: Removing unreachable block (ram,0x004026e9)\n// WARNING: Removing unreachable block (ram,0x004026ff)\n// WARNING: Removing unreachable block (ram,0x004026f1)\n// WARNING: Removing unreachable block (ram,0x004026ba)\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0040260d(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    uint var_30h;\n    uint hMailslot;\n    uint var_28h;\n    uint lpSystemInfo;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint32_t lpflOldProtect;\n    int32_t var_10h;\n    uint var_ch;\n    uchar *var_8h;\n    uint lpAddress;\n    \n    uVar3 = arg_8h & 0xffff;\n    uVar1 = uVar3 / 0x19;\n    var_8h = (uVar1 | uVar3) + 0x40cfcc;\n    uVar2 = uVar1 + 0xce84;\n    var_10h = *(uVar3 + uVar1 + 0x43122a);\n    lpflOldProtect = uVar3 * 0x100;\n    if (uVar1 == 0x8210) {\n        lpflOldProtect = (lpflOldProtect | 0x8210) & 0xcfa3caa6;\n    }\n    else if (uVar1 == 4) {\n        var_18h = uVar3 * 0x400 + -0x15ff3;\n    }\n    else if (0xd644 < uVar1) {\n        (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                  ((uVar2 | uVar1) - uVar2, lpflOldProtect * (lpflOldProtect | 0x8e00), uVar1 ^ 0x418a0000, \n                   lpflOldProtect);\n        (*_sym.imp.KERNEL32.dll__lcreat)(uVar1, uVar3 ^ 0xd8);\n    }\n    do {\n        if (var_18h == (lpflOldProtect ^ uVar3) - 0x6565) {\n            *((uVar1 & lpflOldProtect) + 0x431293) = var_10h;\n            return uVar1;\n        }\n        var_20h._0_1_ = arg_8h;\n        var_28h._0_1_ = var_20h + arg_ch * -0x56;\n        *(var_10h + ((arg_8h & 0xff) - 0x65)) = *var_8h;\n        uVar2 = arg_8h;\n        var_10h = var_10h + ((arg_8h & 0xffff) - (arg_8h & 0xff)) + 1;\n        if (uVar2 < 0x9a54) {\n            if (uVar2 == 0x65) {\n                var_8h = var_8h + ((arg_8h & 0xff) - 100);\n            }\n            else {\n                if (0x59a8 < uVar2) {\n                    return var_28h;\n                }\n                if (uVar2 == 0x5996) {\n                    var_28h._0_1_ = 0;\n                }\n                else if (uVar2 == 0x5932) {\n                    var_28h._0_1_ = var_20h % 0x10;\n                }\n            }\n        }\n        else {\n            var_28h._0_1_ = (*_sym.imp.KERNEL32.dll_SetMailslotInfo)(arg_8h & 0xffff, 0);\n            var_20h._0_1_ = (*_sym.imp.KERNEL32.dll_GetSystemInfo)(arg_8h & 0xff ^ 0x35ce0000);\n        }\n        if (var_20h < 0x38) {\n            (*_sym.imp.USER32.dll_DispatchMessageA)(arg_8h & 0xffff);\n        }\n        else if (var_20h == 0x65) {\n            var_18h = var_18h - ((var_28h ^ arg_8h & 0xffff) - 0x11);\n        }\n    } while( true );\n}\n",
        "token_count": 1047
    },
    "00402ab1": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00402ab1(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint LCType;\n    uint Locale;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint32_t var_48h;\n    uint var_44h;\n    uint8_t *var_40h;\n    uint var_3ch;\n    uint var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar8 = arg_14h & 0xffff;\n    uVar1 = uVar8 >> 2;\n    uVar7 = (arg_10h & 0xff) * 3 & 0xff;\n    iVar5 = *(sym.imp.KERNEL32.dll_GetModuleHandleA + ((uVar8 ^ uVar1) - 0xe100) * 4 + (uVar1 & uVar7)) +\n            ((uVar8 | uVar1) - 0xf500);\n    uVar2 = arg_8h - (uVar8 & 0xe900);\n    *0x431285 = iVar5 + (uVar1 | uVar8) + 0xb00;\n    var_ch = (iVar5 - ((uVar2 - uVar1) + 0x2100)) - *0x431285;\n    uVar6 = uVar2 >> 1;\n    for (var_18h = var_ch + ((uVar2 | uVar6) - 0x1400);\n        *(var_18h + uVar8 * uVar7 * 2) != (uVar1 & uVar2 >> 1 & 0xff) + 0x5a4d;\n        var_18h = var_18h - ((uVar3 ^ (arg_ch | arg_ch * (uVar3 | 0x4100))) + 0x10000)) {\n        uVar3 = arg_ch >> 3;\n    }\n    iVar5 = var_18h + ((uVar7 | uVar1) - 0x3500);\n    uVar9 = arg_10h & 0xffff;\n    if (uVar7 == 0x86) {\n        (*_sym.imp.USER32.dll_ImpersonateDdeClientWindow)(uVar2, uVar2 | 0x6700);\n    }\n    else if (uVar7 == '\\0') {\n        var_30h = var_18h + *(iVar5 + *(iVar5 + (uVar1 * uVar8 + -0x2be3fff1) * 4) + (uVar6 & uVar1) +\n                             (uVar9 + uVar2 + -0x13e2) * 4) + uVar1 + uVar6 + -0x3500;\n    }\n    if (uVar1 < 0xab88) {\n        if (uVar1 == 0x3500) {\n            var_ch = *(var_30h + (uVar7 * uVar6 + 6) * 4) - (uVar6 ^ uVar7);\n        }\n        var_34h = (var_18h + *(var_30h + ((uVar2 | uVar9) - 0x13f8) * 4)) - ((uVar9 - uVar1) + 0x3500);\n        for (; var_ch != uVar6; var_ch = var_ch - ((uVar7 | arg_8h % 0x48) - 0x37)) {\n            uVar7 = arg_ch & 0xff;\n            var_48h = (arg_ch & 0xff) - uVar7;\n            for (var_40h = *(var_34h + (arg_ch & 0xff) * uVar7 * 4) + var_18h;\n                var_40h[uVar7 - (arg_ch & 0xff)] != uVar7 * (arg_ch & 0xff);\n                var_40h = var_40h + ((arg_14h - (arg_14h & 0xffff) ^ arg_14h & 0xffff) - 0xd3ff)) {\n                var_48h = (var_48h << 7 | var_48h >> 0x19) + (*var_40h ^ 0xae);\n            }\n            if (var_48h == 0xe449559a - ((uVar8 | uVar1) - 0xf500)) {\n                uVar2 = arg_10h;\n                iVar5 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)\n                                  ((arg_10h & 0xff) * (arg_10h & 0xffff), arg_10h & 0xffff, 0, \n                                   (arg_10h & 0xffff) + (arg_10h & 0xff));\n                var_30h = var_30h + iVar5;\n                uVar3 = uVar2 + 0x430e;\n                var_ch = *(*(var_30h + (((arg_10h & 0xff) - (arg_10h & 0xffff)) + 9) * 4) + var_18h +\n                          ((*(var_30h + ((arg_10h & 0xffff ^ arg_10h & 0xff) + 6) * 4) - var_ch) +\n                           (arg_10h & 0xff) + (arg_10h & 0xffff) + uVar3 * (arg_10h & 0xffff)) * 2);\n                var_34h = (var_18h + *(var_30h + ((uVar3 - ((arg_14h ^ uVar2) & 0x8d92)) + 0x40f9) * 4)) -\n                          (arg_10h & 0xffff);\n                uVar4 = uVar2 + 1;\n                *0x431287 = var_18h + *(var_34h + (var_ch - ((uVar3 | arg_10h & 0xff) - 0x430e)) * 4);\n                uVar2 = uVar3 * 2 + 0x89e7 ^ uVar2 & 0xff ^ uVar2 & 0xff;\n                *0x43128b = (**0x431287)(uVar3 + uVar4 + -0x430f, (uVar4 - uVar3) + 0x28562, (uVar3 - uVar2) + -0x230b, \n                                         (arg_10h & 0xff | uVar3) - 0x42ce);\n                *((uVar4 ^ arg_10h & 0xff) + 0x43128e) = *0x43128b - (((uVar2 - 1) - (arg_10h & 0xff)) + -0x1002);\n            }\n            var_34h = var_34h + (arg_ch & 0xff) + uVar7 + 4;\n        }\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 1812
    },
    "004035f5": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040367c)\n// WARNING: Removing unreachable block (ram,0x0040369c)\n// WARNING: Removing unreachable block (ram,0x00403668)\n// WARNING: Removing unreachable block (ram,0x00403674)\n// WARNING: Removing unreachable block (ram,0x00403681)\n// WARNING: Removing unreachable block (ram,0x00403694)\n// WARNING: Removing unreachable block (ram,0x00403689)\n// WARNING: Removing unreachable block (ram,0x00403670)\n\nuint32_t __cdecl fcn.004035f5(uint arg_8h, uint32_t arg_ch, uint noname_2, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_14h_00;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_14h_00 = arg_14h + (arg_ch & 0x590a00);\n    uVar1 = (arg_14h & arg_ch) * 32000;\n    if (uVar1 == 0) {\n        if (arg_14h < 0xb817) {\n            return 0;\n        }\n        if (arg_14h == 0xd400) {\n            arg_14h_00 = fcn.00402ab1(0xd400, 0, arg_8h, arg_14h_00);\n        }\n        else if (arg_14h < 0x79f0) {\n            arg_14h_00 = arg_14h | 0xa7;\n        }\n    }\n    else if (0xeceb < uVar1) {\n        return uVar1;\n    }\n    if (arg_8h == 0) {\n        fcn.00402117();\n    }\n    return arg_14h_00;\n}\n",
        "token_count": 414
    },
    "0040387e": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004038fe)\n// WARNING: Removing unreachable block (ram,0x004038b9)\n// WARNING: Removing unreachable block (ram,0x004038da)\n// WARNING: Removing unreachable block (ram,0x00403906)\n\nuint __cdecl fcn.0040387e(uint arg_8h)\n\n{\n    uint var_4h;\n    \n    fcn.00403a7d(0, 0, 0);\n    return 0;\n}\n",
        "token_count": 111
    },
    "00403937": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00403937(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uchar *var_8h;\n    uint var_4h;\n    \n    uVar3 = arg_ch | 0x5400;\n    uVar2 = (arg_8h & 0xff & arg_8h) * arg_8h & 0xff;\n    iVar1 = 0x41043e;\n    var_8h = *((uVar3 ^ uVar2) + 0x42be93 + ((uVar2 - uVar3) + 0x5400) * 4);\n    for (var_10h = uVar2 + uVar3 + -0x4e3a; var_10h != uVar3 - 0x5401; var_10h = var_10h + -1) {\n        *var_8h = *(iVar1 + ((arg_ch | arg_ch * -0x6e5a) - 0x91a7));\n        var_8h = var_8h + 1;\n        iVar1 = iVar1 + arg_ch + arg_ch + -1;\n    }\n    *(uVar3 * 2 + 0x426a91) = var_8h;\n    return uVar3;\n}\n",
        "token_count": 373
    },
    "00403a7d": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403b2a)\n// WARNING: Removing unreachable block (ram,0x00403b57)\n// WARNING: Removing unreachable block (ram,0x00403b5f)\n// WARNING: Removing unreachable block (ram,0x00403b32)\n// WARNING: Removing unreachable block (ram,0x00403b6f)\n// WARNING: Removing unreachable block (ram,0x00403b74)\n\nuint32_t fcn.00403a7d(uint32_t param_1, uint param_2, uint32_t param_3)\n\n{\n    param_1 = param_1 & 0xff;\n    param_3 = param_3 & 0xffff;\n    if (param_3 == 0) {\n        if ((((param_1 != 0x26) && (param_1 != 0x33)) && (param_1 == '\\0')) &&\n           (((param_1 != 0x10 && (param_1 < 0xda)) && (param_1 != 0x66)))) {\n            param_3 = fcn.0040163e(param_1, param_1, param_3);\n            param_3 = param_3 & 0xffff;\n        }\n    }\n    else if ((param_3 != 0x5143) && (0x90e6 < param_3)) {\n        return param_3;\n    }\n    return param_3 & 0xff;\n}\n",
        "token_count": 320
    },
    "004013a4": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040153d)\n// WARNING: Removing unreachable block (ram,0x00401579)\n// WARNING: Removing unreachable block (ram,0x00401565)\n// WARNING: Removing unreachable block (ram,0x00401574)\n// WARNING: Removing unreachable block (ram,0x0040156a)\n// WARNING: Removing unreachable block (ram,0x0040152b)\n\nint32_t __cdecl fcn.004013a4(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint lpSecurityAttributes;\n    uchar *var_ch;\n    uint *var_8h;\n    int32_t var_4h;\n    \n    uVar1 = (*_sym.imp.USER32.dll_SetFocus)((arg_8h & 0xffff) - 0xffff);\n    uVar1 = uVar1 & 0xffff;\n    uVar4 = uVar1 >> 1;\n    var_4h = (uVar1 & uVar4) + 0x410a06;\n    var_8h = (uVar1 | 0x94) + 0x4311fb;\n    uVar1 = uVar1 / 0x33;\n    var_ch = var_8h[uVar1];\n    iVar2 = (uVar4 ^ uVar1) * arg_8h;\n    for (var_14h = iVar2 * 0x94 + 0x2087f; var_14h != (uVar1 | uVar4); var_14h = var_14h - ((uVar5 & arg_8h & 0xff) + 1)\n        ) {\n        uVar3 = arg_8h % 0x12;\n        uVar5 = uVar3 >> 2;\n        *var_ch = *(var_4h + (arg_8h & 0xff) + uVar5 + -0xff);\n        var_ch = var_ch + uVar5 + uVar3 + -2;\n        var_4h = var_4h + uVar5 + (arg_8h & 0xff) + -0xfe;\n    }\n    if (uVar4 == 0) {\n        if (uVar1 == 0) {\n            var_8h = (uVar1 & 0x94) + 0x431293;\n        }\n        else {\n            if (uVar1 == 0x73f) {\n                return iVar2;\n            }\n            if (0xcf66 < uVar1) {\n                return 0x94;\n            }\n            if ((uVar1 < 0xeb95) && (uVar1 == 0x5160)) {\n                (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(0x70320094, (uVar4 | 0x94) ^ 0xbcc0, iVar2 * 0x5590);\n                (*_sym.imp.KERNEL32.dll_SetConsoleOutputCP)((uVar4 & 0x11) + uVar4);\n            }\n        }\n    }\n    *var_8h = var_ch;\n    return iVar2;\n}\n",
        "token_count": 784
    },
    "00401d75": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuint8_t __cdecl fcn.00401d75(uint arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_ch ^ 0xe2;\n    uVar2 = arg_ch - 1;\n    uVar3 = ((arg_ch & 0xffff) + 1 & 0xffff) + 1 & 0xffff;\n    if (uVar3 < 0xab59) {\n        if ((uVar3 == 0xc0) && (uVar1 == 0x5c)) {\n            uVar1 = fcn.004024b2();\n        }\n    }\n    else {\n        fcn.00403daa(uVar2 & 0x44de, (uVar1 | 0x45) + uVar2, ((arg_ch & 0xffff) - (arg_ch & 0x36)) * 2 + -0xa9ec);\n    }\n    return uVar1;\n}\n",
        "token_count": 251
    },
    "00401e83": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00401e83(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    char *pcVar1;\n    uchar *puVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint16_t *puVar5;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint32_t uVar6;\n    uint unaff_EDI;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uchar *var_8h;\n    uchar *var_4h;\n    \n    uVar6 = arg_14h * (arg_14h ^ 0x320b00);\n    uVar4 = uVar6 * uVar6;\n    var_4h = *(uVar6 + 0xde3f224b + ((uVar6 | uVar4) + 0x4ce80dac) * 4);\n    uVar6 = uVar6 & 0x97e4cb37;\n    puVar2 = var_8h;\n    if (0x183 < uVar6) {\n        if (uVar6 == 0x200c004) {\n            if (uVar4 == 0x931c) {\n                uVar4 = (arg_10h | 0x200c004) & 0x6272;\n            }\n            else {\n                puVar2 = var_4h;\n                if (uVar4 != 0x93179210) {\n                    puVar2 = var_8h;\n                }\n            }\n        }\n        else if (uVar6 < 0x754f) {\n            fcn.00403e5e(unaff_EBX, unaff_EDI, unaff_ESI);\n        }\n        else if (uVar6 < 0x11bc) {\n            uVar4 = uVar4 & uVar6;\n        }\n    }\n    var_8h = puVar2;\n    var_ch = uVar4 + 0x6ceab045;\n    while (var_ch != 0) {\n        uVar6 = arg_14h - 1;\n        pcVar1 = var_4h + (arg_14h - 0xae);\n        uVar3 = uVar6 - (uVar6 & 0x24f4);\n        puVar5 = var_4h + 1;\n        var_4h = puVar5 + uVar3 * uVar6 + -0x613;\n        var_20h._0_2_ = *puVar5;\n        var_ch = var_ch - ((uVar6 ^ uVar3) - 0xa1);\n        if (*pcVar1 == -0x4d) {\n            var_ch = var_ch - var_20h;\n            for (; var_20h != 0; var_20h._0_2_ = var_20h - 1) {\n                if (arg_10h == 0xff27971e) {\n                    *var_8h = *var_4h;\n                }\n                var_4h = var_4h + 1;\n                var_8h = var_8h + 1;\n            }\n        }\n        else if (*pcVar1 == -3) {\n            var_ch = var_ch - var_20h;\n            var_4h = var_4h + var_20h;\n        }\n    }\n    *((arg_ch * arg_ch ^ uVar4) + 0x6d2b8103) = var_8h - *((uVar4 + uVar4 * uVar4 + 0x7ab22cf0) * 4 + 0x43128f);\n    return arg_ch * arg_ch;\n}\n",
        "token_count": 895
    },
    "004028f7": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004028f7(uint noname_0, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint var_10h;\n    uint lpSecurityAttributes;\n    uint lReadTimeout;\n    uint nMaxMessageSize;\n    \n    uVar4 = arg_10h & 0xff;\n    uVar5 = arg_14h & 0xffff;\n    uVar2 = (arg_10h | arg_14h) * arg_ch;\n    uVar3 = (arg_ch & 0xff) % 0x14;\n    uVar6 = uVar5 - arg_14h & 0xffff;\n    uVar1 = uVar4 / 0x1b;\n    if (uVar1 == '\\0') {\n        if (uVar6 < 0xd24b) {\n            if (uVar6 < 0xa858) {\n                if (uVar6 == 0) {\n                    if (uVar4 == '\\0') {\n                        if (uVar3 < 0x2e42) {\n                            if (uVar3 == 37999) {\n                                uVar1 = (*_sym.imp.KERNEL32.dll_SetMailslotInfo)(uVar1, 0x72be0000);\n                                (*_sym.imp.KERNEL32.dll_CreateMailslotW)\n                                          (uVar2, uVar2 & 37999, uVar2 * (uVar1 & 0xff), uVar5 | 0x20f03ec3);\n                            }\n                            else if (uVar3 == 0) {\n                                uVar6 = fcn.004037eb(0, uVar4, 0);\n                                uVar6 = uVar6 & 0xffff;\n                            }\n                            else if (0x5956 < uVar3) {\n                                uVar6 = uVar3;\n                            }\n                        }\n                        else {\n                            fcn.00403da5(uVar5 + uVar6 * -2, uVar1 * uVar1);\n                        }\n                    }\n                }\n                else if (0x5c8a < uVar6) {\n                    uVar6 = uVar2;\n                }\n            }\n            else {\n                uVar6 = uVar3;\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_GetSystemTime)(uVar4 * 0x19a200);\n        }\n    }\n    return uVar6;\n}\n",
        "token_count": 584
    },
    "0040339f": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040347e)\n// WARNING: Removing unreachable block (ram,0x00403476)\n// WARNING: Removing unreachable block (ram,0x00403488)\n// WARNING: Removing unreachable block (ram,0x00403490)\n// WARNING: Removing unreachable block (ram,0x00403406)\n// WARNING: Removing unreachable block (ram,0x00403449)\n// WARNING: Removing unreachable block (ram,0x0040346e)\n// WARNING: Removing unreachable block (ram,0x00403441)\n// WARNING: Removing unreachable block (ram,0x00403451)\n// WARNING: Removing unreachable block (ram,0x00403466)\n// WARNING: Removing unreachable block (ram,0x00403459)\n// WARNING: Removing unreachable block (ram,0x004033ee)\n\nuint fcn.0040339f(void)\n\n{\n    uint var_8h;\n    uint lParam;\n    \n    fcn.0040387e(0);\n    return 0xb3000000;\n}\n",
        "token_count": 227
    },
    "00403bbd": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403d0b)\n// WARNING: Removing unreachable block (ram,0x00403cdc)\n// WARNING: Removing unreachable block (ram,0x00403cf4)\n// WARNING: Removing unreachable block (ram,0x00403d03)\n// WARNING: Removing unreachable block (ram,0x00403cfc)\n// WARNING: Removing unreachable block (ram,0x00403ce4)\n// WARNING: Could not reconcile some variable overlaps\n\nuint8_t fcn.00403bbd(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_4h;\n    \n    uVar1 = fcn.00401105(0x165, 0x165, 0x165);\n    uVar2 = uVar1 >> 1;\n    var_4h._0_1_ = uVar2;\n    uVar3 = 0x165 - (uVar2 & 0xff ^ 0x4600) & 0xffff;\n    if (uVar3 == 0xbb33) {\n        if (uVar1 < 0x50e9) {\n            if (uVar1 == 0x65) {\n                fcn.004032a5(0x65, 0xbb33, uVar2 & 0xff);\n            }\n            else if (0x6628 < uVar1) {\n                var_4h._0_1_ = (uVar1 ^ 0x62) * '3';\n            }\n        }\n        else {\n            var_4h._0_1_ = 0x33;\n        }\n    }\n    else if (uVar3 == 0xa8f7) {\n        fcn.00403e3f(0, uVar1, 0xa8f7, uVar1 & 0x9f000000 ^ uVar2 & 0xff, uVar2 & 0xff);\n    }\n    return var_4h >> 3;\n}\n",
        "token_count": 450
    },
    "00401264": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401368)\n// WARNING: Removing unreachable block (ram,0x0040133c)\n// WARNING: Removing unreachable block (ram,0x00401349)\n// WARNING: Removing unreachable block (ram,0x00401360)\n// WARNING: Removing unreachable block (ram,0x00401351)\n// WARNING: Removing unreachable block (ram,0x00401344)\n\nuint32_t __cdecl fcn.00401264(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_ch & 0xffff;\n    uVar2 = (arg_ch + 1 + arg_8h + 0x25c900 & 0xff) - 1 & 0xff;\n    if (uVar2 < 0x82) {\n        if (uVar2 == '\\0') {\n            if (uVar1 < 0xd25f) {\n                if (uVar1 == 0) {\n                    fcn.00401000();\n                }\n                else if (uVar1 == 0x7c68) {\n                    (*_sym.imp.USER32.dll_GetMenuItemID)(uVar1 / (arg_ch + 1) - uVar2, 0x16a68);\n                }\n            }\n            else {\n                uVar2 = 0;\n            }\n        }\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 348
    },
    "null": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004025ba)\n// WARNING: Removing unreachable block (ram,0x004025af)\n// WARNING: Removing unreachable block (ram,0x004025a3)\n\nushort main(void)\n\n{\n    ushort uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00403563(0xbdff);\n    return uVar1;\n}\n",
        "token_count": 96
    },
    "004032a5": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004032a5(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_4h;\n    \n    uVar1 = (arg_8h & 0xffff) * 0x10000;\n    uVar2 = 0x53a300 - (arg_8h & 0xffff) & 0xffff;\n    uVar1 = (uVar1 | 0x6545c7a1) + uVar1;\n    uVar3 = uVar2 + (uVar2 ^ uVar1) & 0xffff;\n    if (uVar3 != 0x5253) {\n        if (uVar3 == 0x2c5e) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetAtomNameA)(uVar1, uVar2, uVar1 * 0x2c5e);\n            (*_sym.imp.KERNEL32.dll_RaiseException)\n                      ((uVar2 & 0xffff) * 0xf1 - uVar1, uVar1 + 0x72000000, (uVar2 & 0xffff) - (uVar1 & 0x30d0000), \n                       uVar1);\n        }\n        else if (uVar3 < 0xe9f7) {\n            if (uVar3 == 0x7d5) {\n                fcn.0040308d(0x7d5, uVar2);\n            }\n            else if (uVar3 == 0x8e36) {\n                fcn.00403da5();\n            }\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 394
    },
    "004024b2": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040253d)\n// WARNING: Removing unreachable block (ram,0x00402535)\n// WARNING: Removing unreachable block (ram,0x0040250d)\n// WARNING: Removing unreachable block (ram,0x0040251d)\n// WARNING: Removing unreachable block (ram,0x004024f3)\n\nuint fcn.004024b2(void)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004013a4(0x9fffffff);\n    return 0x9fffffff;\n}\n",
        "token_count": 129
    },
    "0040308d": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004030ec)\n// WARNING: Removing unreachable block (ram,0x0040310c)\n// WARNING: Removing unreachable block (ram,0x004030e4)\n// WARNING: Removing unreachable block (ram,0x004030f2)\n// WARNING: Removing unreachable block (ram,0x00403104)\n// WARNING: Removing unreachable block (ram,0x004030fa)\n// WARNING: Removing unreachable block (ram,0x004030ca)\n\nuint32_t __cdecl fcn.0040308d(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t arg_ch_00;\n    uint var_4h;\n    \n    arg_ch_00 = arg_8h * arg_ch & 0xff;\n    if (arg_8h == 0x7d5) {\n        fcn.00401c6a(0x7d5, arg_ch_00);\n    }\n    else if (0xafce < arg_8h) {\n        return arg_ch_00;\n    }\n    return arg_ch_00 * 0xec + arg_8h;\n}\n",
        "token_count": 250
    },
    "00403159": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004031ee)\n// WARNING: Removing unreachable block (ram,0x004031d1)\n// WARNING: Removing unreachable block (ram,0x004031e6)\n// WARNING: Removing unreachable block (ram,0x004031d9)\n\nuint16_t __cdecl fcn.00403159(uint arg_8h, uint noname_1, uint noname_2, uint arg_14h)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_14h & 0x709b & arg_14h;\n    if (uVar1 != 0x54c) {\n        if (uVar1 == 1) {\n            fcn.00403764();\n        }\n        else if (0x1e55 < uVar1) {\n            uVar1 = arg_14h;\n        }\n    }\n    uVar2 = uVar1 + 0x42;\n    if (uVar1 < 0x3ce8) {\n        if (uVar1 == 0x47d4) {\n            return uVar2;\n        }\n        if (uVar1 == 1) {\n            fcn.00403bbd();\n        }\n        else if ((uVar1 < 0xc637) && (0x221 < uVar1)) {\n            uVar2 = arg_8h | 0x6a04 | uVar1;\n        }\n    }\n    return uVar2 + 0x8e0a;\n}\n",
        "token_count": 359
    },
    "004037eb": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nulong fcn.004037eb(uint32_t param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = (param_2 & 0xffff) - 1 & 0xffff;\n    uVar2 = uVar1 - (param_1 | 0x41) & 0xff;\n    if ((uVar1 == 0xffff) && (uVar2 == 0xbe)) {\n        fcn.00401d75(0xbe, 0xbe);\n    }\n    return CONCAT44((uVar2 >> 1) + 0x51 + uVar2, uVar2 >> 1);\n}\n",
        "token_count": 156
    },
    "00401786": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t fcn.00401786(void)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = fcn.00403937(1, 1);\n    uVar2 = uVar2 & 0xff;\n    uVar1 = uVar2;\n    if (uVar1 == 1) {\n        fcn.00403159(uVar2, uVar2, uVar2, uVar2);\n    }\n    else if ((((uVar1 != 0xca) && (uVar1 < 0x38)) && (uVar1 < 0xe3)) && (uVar1 == 0x15)) {\n        fcn.00403e12(uVar2 * 2);\n    }\n    return uVar2;\n}\n",
        "token_count": 194
    },
    "00402325": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00402325(int32_t arg_8h, uint noname_1, uint32_t arg_10h)\n\n{\n    uint16_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    uint32_t uVar5;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uchar *var_8h;\n    uint var_4h;\n    \n    uVar3 = arg_8h * arg_8h >> 2;\n    uVar5 = uVar3 & 0xff;\n    uVar3 = uVar5 + uVar3 * 0x18ed00;\n    puVar4 = (uVar5 ^ uVar3) + 0x40d030;\n    uVar5 = uVar3 & 0xff;\n    var_8h = *(uVar3 * 5 + uVar5 * -5 + 0x431293);\n    var_ch = 1;\n    do {\n        if (var_ch == (uVar5 ^ uVar3)) {\n            *(((arg_10h ^ 0x36) + uVar5) * uVar5 + 0x431293) = var_8h;\n            (*_sym.imp.USER32.dll_SetFocus)(uVar3 + uVar5);\n            return uVar5;\n        }\n        uVar2 = arg_10h;\n        var_14h._0_2_ = uVar2 * -0x4400 + uVar2;\n        if (var_14h == 0x74b3) {\n            if (uVar2 == 0xb3) {\n                *var_8h = *puVar4;\n            }\n            else if (uVar2 < 0x9d) {\n                var_14h._0_2_ = 0;\n            }\n        }\n        else if (var_14h == 0xeea5) {\n            return 0xeea5;\n        }\n        uVar1 = uVar2 * -0x676c;\n        var_8h = var_8h + uVar1 + (arg_10h & 0xff) + -0xb02e;\n        puVar4 = puVar4 + ((var_14h & uVar1) - 0x242f);\n        var_ch = var_ch - ((arg_10h & 0xff) + uVar1 + -0xb02e);\n    } while( true );\n}\n",
        "token_count": 595
    },
    "00403764": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004037b4)\n// WARNING: Removing unreachable block (ram,0x004037ac)\n// WARNING: Removing unreachable block (ram,0x0040378b)\n\nuint fcn.00403764(void)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00401264(0, 0xcb000000);\n    return 0;\n}\n",
        "token_count": 95
    },
    "004040ee": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.004040ee(void)\n\n{\n    uint unaff_EBX;\n    uint in_stack_fffffd5c;\n    uint in_stack_fffffd60;\n    \n    fcn.00404300();\n    *0x448f28 = 1;\n    fcn.00404165(unaff_EBX, in_stack_fffffd5c, in_stack_fffffd60);\n    return;\n}\n",
        "token_count": 88
    },
    "00404165": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404165(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    char cVar1;\n    int32_t unaff_EBP;\n    uint16_t in_FPUStatusWord;\n    float10 in_ST0;\n    uint var_a4h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ah;\n    uint var_86h;\n    uint var_7eh;\n    \n    if (*0x448f18 != 0) {\n        return;\n    }\n    *0x448f20 = in_ST0;\n    cVar1 = *(unaff_EBP + -0x90);\n    if (cVar1 != '\\0') {\n        if ((cVar1 != -1) && (cVar1 != -2)) {\n            if (cVar1 == '\\0') {\n                return;\n            }\n            *(unaff_EBP + -0x8e) = cVar1;\n            goto code_r0x00404233;\n        }\n        if ((*0x448f20 & 0x7ff0000000000000) == 0) {\n            *(unaff_EBP + -0x8e) = 4;\n            in_ST0 = fscale(in_ST0, *0x40c138);\n            if (ABS(in_ST0) < *0x40c128) {\n                in_ST0 = in_ST0 * *0x40c148;\n            }\n            goto code_r0x00404233;\n        }\n        if ((*0x448f26 & 0x7ff0) == 0x7ff0) {\n            *(unaff_EBP + -0x8e) = 3;\n            in_ST0 = fscale(in_ST0, *0x40c130);\n            if (*0x40c120 < ABS(in_ST0)) {\n                in_ST0 = in_ST0 * *0x40c140;\n            }\n            goto code_r0x00404233;\n        }\n    }\n    if ((*(unaff_EBP + -0xa4) & 0x20) != 0) {\n        return;\n    }\n    if ((in_FPUStatusWord & 0x20) == 0) {\n        return;\n    }\n    *(unaff_EBP + -0x8e) = 8;\ncode_r0x00404233:\n    *(unaff_EBP + -0x8a) = *(unaff_EBP + -0x94) + 1;\n    if (*0x448f28 == '\\0') {\n        *(unaff_EBP + -0x86) = *(unaff_EBP + 8);\n        *(unaff_EBP + -0x82) = *(unaff_EBP + 0xc);\n        if (*(*(unaff_EBP + -0x94) + 0xd) != '\\x01') {\n            *(unaff_EBP + -0x7e) = *(unaff_EBP + 0x10);\n            *(unaff_EBP + -0x7a) = *(unaff_EBP + 0x14);\n        }\n    }\n    *(unaff_EBP + -0x76) = in_ST0;\n    fcn.00407304(*(*(unaff_EBP + -0x94) + 0xe), unaff_EBP + -0x8e, unaff_EBP + -0xa4);\n    return;\n}\n",
        "token_count": 752
    },
    "00404cd6": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00404cd6(uint param_1, uint32_t param_2, uint16_t param_3)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    float10 fVar2;\n    float10 fVar3;\n    uint in_stack_0000001c;\n    ushort uStack00000020;\n    uint32_t in_stack_00000020;\n    ushort uStack00000022;\n    uint16_t in_stack_00000024;\n    \n    if ((((((CONCAT22(param_3, param_2._2_2_) ^ 0x700) & 0x700) == 0) &&\n         (*(((param_2._2_2_ & 0x7800) >> 0xb) + 0x43139c) != '\\0')) && ((param_3 & 0x7fff) != 0x7fff)) &&\n       ((((in_stack_00000024 & 0x7fff) != 0 && ((in_stack_00000024 & 0x7fff) != 0x7fff)) &&\n        (((in_stack_00000020 & 0x7fffffff) == 0 && ((param_2 & 0x7fffffff) == 0)))))) {\n        if ((param_3 & 0x7fff) + 0x3f < (in_stack_00000024 & 0x7fff)) {\n            iVar1 = ((in_stack_00000024 & 0x7fff) - (param_3 & 0x7fff) & 0x3f | 0x20) + 1;\n            fVar3 = ABS(CONCAT28(in_stack_00000024 & 0x7fff | param_3 & 0x8000, \n                                 CONCAT26(param_2._2_2_, CONCAT24(param_2, param_1))));\n            fVar2 = ABS(CONCAT28(in_stack_00000024, \n                                 CONCAT26(uStack00000022, CONCAT24(uStack00000020, in_stack_0000001c))));\n            do {\n                if (fVar3 <= fVar2) {\n                    fVar2 = fVar2 - fVar3;\n                }\n                fVar3 = fVar3 * *0x4313cc;\n                iVar1 = iVar1 + -1;\n            } while (iVar1 != 0);\n        }\n        else {\n            while (-1 < (in_stack_00000024 & 0x7fff) - ((param_3 & 0x7fff) + 10)) {\n                fVar2 = CONCAT28(in_stack_00000024, \n                                 CONCAT26(uStack00000022, CONCAT24(uStack00000020, in_stack_0000001c)));\n                fVar3 = CONCAT28((in_stack_00000024 & 0x7fff) - ((in_stack_00000024 & 0x7fff) - param_3 & 7 | 4) |\n                                 param_3 & 0x8000, CONCAT26(param_2._2_2_, CONCAT24(param_2, param_1)));\n                fVar2 = fVar2 - (fVar2 / fVar3) * fVar3;\n                in_stack_0000001c = SUB104(fVar2, 0);\n                uStack00000020 = fVar2 >> 0x20;\n                uStack00000022 = fVar2 >> 0x30;\n                in_stack_00000024 = fVar2 >> 0x40;\n            }\n        }\n    }\n    return in_EAX;\n}\n",
        "token_count": 779
    },
    "00406b36": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00406b36(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    int32_t iStack16;\n    \n    iStack16 = param_1;\n    uStack24 = 0x406b14;\n    uStack28 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack28;\n    while( true ) {\n        iVar1 = *(param_1 + 8);\n        iVar2 = *(param_1 + 0xc);\n        if ((iVar2 == -1) || (iVar2 == param_2)) break;\n        uStack20 = *(iVar1 + iVar2 * 0xc);\n        *(param_1 + 0xc) = uStack20;\n        if (*(iVar1 + 4 + iVar2 * 0xc) == 0) {\n            fcn.00406bca(0x101);\n            (**(iVar1 + 8 + iVar2 * 0xc))();\n        }\n    }\n    *in_FS_OFFSET = uStack28;\n    return;\n}\n",
        "token_count": 265
    },
    "00406cfd": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406cfd(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint var_1a4h;\n    uint var_a0h;\n    \n    iVar2 = 0;\n    piVar1 = 0x431a38;\n    do {\n        if (arg_8h == *piVar1) break;\n        piVar1 = piVar1 + 2;\n        iVar2 = iVar2 + 1;\n    } while (piVar1 < 0x431ac8);\n    if (arg_8h == *(iVar2 * 8 + 0x431a38)) {\n        if ((*0x448f14 == 1) || ((*0x448f14 == 0 && (*0x431330 == 1)))) {\n            fcn.004087d0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (arg_8h != 0xfc) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.004086e0();\n            }\n            iVar2 = fcn.004087d0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.004087d0();\n                fcn.00409460();\n            }\n            fcn.004086e0();\n            fcn.004086f0();\n            fcn.004086f0();\n            fcn.004086f0();\n            fcn.004093ce(&var_a0h, \"Microsoft Visual C++ Runtime Library\");\n        }\n    }\n    return;\n}\n",
        "token_count": 383
    },
    "00408bee": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408bee(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    int32_t *piVar3;\n    char cVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    int32_t *piVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar5 = arg_8h[4];\n    iVar6 = *(arg_ch - 4);\n    piVar10 = arg_ch - 4;\n    uVar11 = arg_ch - arg_8h[3] >> 0xf;\n    uVar7 = *(arg_ch - 8);\n    var_ch = iVar6 + -1;\n    piVar3 = uVar11 * 0x204 + 0x144 + uVar5;\n    uVar13 = *(var_ch + piVar10);\n    if ((uVar13 & 1) == 0) {\n        arg_ch = (uVar13 >> 4) - 1;\n        if (0x3f < arg_ch) {\n            arg_ch = 0x3f;\n        }\n        if (*(iVar6 + 3 + piVar10) == *(iVar6 + 7 + piVar10)) {\n            if (arg_ch < 0x20) {\n                pcVar1 = arg_ch + 4 + uVar5;\n                uVar12 = ~(0x80000000U >> (arg_ch & 0x1f));\n                puVar2 = uVar5 + 0x44 + uVar11 * 4;\n                *puVar2 = *puVar2 & uVar12;\n                *pcVar1 = *pcVar1 + -1;\n                if (*pcVar1 == '\\0') {\n                    *arg_8h = *arg_8h & uVar12;\n                }\n            }\n            else {\n                pcVar1 = arg_ch + 4 + uVar5;\n                uVar12 = ~(0x80000000U >> (arg_ch - 0x20 & 0x1f));\n                puVar2 = uVar5 + 0xc4 + uVar11 * 4;\n                *puVar2 = *puVar2 & uVar12;\n                *pcVar1 = *pcVar1 + -1;\n                if (*pcVar1 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar12;\n                }\n            }\n        }\n        *(*(iVar6 + 7 + piVar10) + 4) = *(iVar6 + 3 + piVar10);\n        var_ch = var_ch + uVar13;\n        *(*(iVar6 + 3 + piVar10) + 8) = *(iVar6 + 7 + piVar10);\n    }\n    uVar13 = (var_ch >> 4) - 1;\n    if (0x3f < uVar13) {\n        uVar13 = 0x3f;\n    }\n    if ((uVar7 & 1) == 0) {\n        piVar10 = piVar10 - uVar7;\n        arg_ch = (uVar7 >> 4) - 1;\n        if (0x3f < arg_ch) {\n            arg_ch = 0x3f;\n        }\n        var_ch = var_ch + uVar7;\n        uVar13 = (var_ch >> 4) - 1;\n        if (0x3f < uVar13) {\n            uVar13 = 0x3f;\n        }\n        if (arg_ch != uVar13) {\n            if (piVar10[1] == piVar10[2]) {\n                if (arg_ch < 0x20) {\n                    pcVar1 = arg_ch + 4 + uVar5;\n                    uVar12 = ~(0x80000000U >> (arg_ch & 0x1f));\n                    puVar2 = uVar5 + 0x44 + uVar11 * 4;\n                    *puVar2 = *puVar2 & uVar12;\n                    *pcVar1 = *pcVar1 + -1;\n                    if (*pcVar1 == '\\0') {\n                        *arg_8h = *arg_8h & uVar12;\n                    }\n                }\n                else {\n                    pcVar1 = arg_ch + 4 + uVar5;\n                    uVar12 = ~(0x80000000U >> (arg_ch - 0x20 & 0x1f));\n                    puVar2 = uVar5 + 0xc4 + uVar11 * 4;\n                    *puVar2 = *puVar2 & uVar12;\n                    *pcVar1 = *pcVar1 + -1;\n                    if (*pcVar1 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar12;\n                    }\n                }\n            }\n            *(piVar10[2] + 4) = piVar10[1];\n            *(piVar10[1] + 8) = piVar10[2];\n        }\n    }\n    if (((uVar7 & 1) != 0) || (arg_ch != uVar13)) {\n        piVar10[1] = piVar3[uVar13 * 2 + 1];\n        piVar10[2] = piVar3 + uVar13 * 2;\n        (piVar3 + uVar13 * 2)[1] = piVar10;\n        *(piVar10[1] + 8) = piVar10;\n        if (piVar10[1] == piVar10[2]) {\n            cVar4 = *(uVar13 + 4 + uVar5);\n            *(uVar13 + 4 + uVar5) = cVar4 + '\\x01';\n            uVar9 = uVar13;\n            if (uVar13 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                puVar2 = uVar5 + 0x44 + uVar11 * 4;\n                *puVar2 = *puVar2 | 0x80000000U >> (uVar9 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n                puVar2 = uVar5 + 0xc4 + uVar11 * 4;\n                *puVar2 = *puVar2 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n            }\n        }\n    }\n    *piVar10 = var_ch;\n    *(var_ch + -4 + piVar10) = var_ch;\n    *piVar3 = *piVar3 + -1;\n    pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n    uVar5 = *0x449118;\n    puVar2 = *0x449120;\n    if ((*piVar3 == 0) && (uVar5 = uVar11,  puVar2 = arg_8h,  *0x449120 != NULL)) {\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x449118 * 0x8000 + (*0x449120)[3], 0x8000, 0x4000);\n        (*0x449120)[2] = (*0x449120)[2] | 0x80000000U >> (*0x449118 & 0x1f);\n        *((*0x449120)[4] + 0xc4 + *0x449118 * 4) = 0;\n        *((*0x449120)[4] + 0x43) = *((*0x449120)[4] + 0x43) + -1;\n        if (*((*0x449120)[4] + 0x43) == '\\0') {\n            (*0x449120)[1] = (*0x449120)[1] & 0xfffffffe;\n        }\n        puVar2 = arg_8h;\n        if ((*0x449120)[2] == 0xffffffff) {\n            (*pcVar8)((*0x449120)[3], 0, 0x8000);\n            (*_sym.imp.KERNEL32.dll_HeapFree)(*0x449348, 0, (*0x449120)[4]);\n            fcn.004077f0(*0x449120, *0x449120 + 5, (*0x449124 * 0x14 - *0x449120) + -0x14 + *0x449128);\n            *0x449124 = *0x449124 + -1;\n            if (*0x449120 < arg_8h) {\n                arg_8h = arg_8h + -5;\n            }\n            *0x44911c = *0x449128;\n            puVar2 = arg_8h;\n        }\n    }\n    *0x449120 = puVar2;\n    *0x449118 = uVar5;\n    return;\n}\n",
        "token_count": 2132
    },
    "00404edc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nfloat10 fcn.00404edc(void)\n\n{\n    float10 in_ST0;\n    float10 fVar1;\n    float10 in_ST1;\n    \n    if ((in_ST1 & 0) != 0) {\n        fVar1 = fcn.00404cd6();\n        return fVar1;\n    }\n    if ((SUB104(in_ST1, 0) | in_ST1 >> 0x20) != 0) {\n        fVar1 = fcn.00404cd6(in_ST1 * *0x4313b4);\n        return fVar1;\n    }\n    return in_ST0 - (in_ST0 / in_ST1) * in_ST1;\n}\n",
        "token_count": 151
    },
    "004034cd": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.004034cd(uint32_t arg_8h, uint noname_1, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h = arg_8h & 0xffff;\n    uVar1 = 0;\n    if (arg_8h < 0x99c6) {\n        if (arg_8h == 0) {\n            uVar1 = fcn.00401865(arg_8h);\n            uVar1 = uVar1 & 0xffff;\n        }\n        else if (0x770e < arg_8h) {\n            arg_8h = 0;\n        }\n    }\n    else {\n        arg_8h = arg_8h % 100;\n    }\n    return CONCAT44(arg_8h << 0x18, uVar1) & 0xffffffff000000ff;\n}\n",
        "token_count": 212
    },
    "00403563": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00403563(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_ch;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.USER32.dll_SetFocus)((arg_8h & 0xffff) - 0xbdff);\n    uVar2 = uVar1 & 0xffff | 0xd400;\n    arg_ch = (uVar1 & 0xff ^ uVar2) + 0x600900 & 0xff;\n    if (uVar2 == 0xd400) {\n        fcn.004035f5(uVar1 & 0xffff, arg_ch, arg_ch, 0xd400);\n    }\n    return arg_ch + 1 & 0xff;\n}\n",
        "token_count": 190
    },
    "00404295": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404295(uint arg_8h, uint arg_ch)\n\n{\n    fcn.004042c1(arg_8h, arg_ch);\n    fcn.00404300();\n    fcn.0040415e();\n    return;\n}\n",
        "token_count": 58
    },
    "00407fba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407fba(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if ((param_1 <= *0x431be0) && (iVar1 = fcn.00408f19(param_1),  iVar1 != 0)) {\n        return;\n    }\n    if (param_1 == 0) {\n        param_1 = 1;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x449348, 0, param_1 + 0xf & 0xfffffff0);\n    return;\n}\n",
        "token_count": 128
    },
    "004086f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.004086f0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x0040873f;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00408751;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00408751;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00408751;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x0040873f:\n    puVar5 = puVar3 + -1;\ncode_r0x00408751:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x004087c8;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x004087c8:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 748
    },
    "004086e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.004086e0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x004087c8;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x004087c8:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 439
    },
    "00409af5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00409af5(uint param_1, uint param_2)\n\n{\n    fcn.00409989(param_1, param_2, 0x431bf0);\n    return;\n}\n",
        "token_count": 46
    },
    "00409b0b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00409b0b(uint param_1, uint param_2)\n\n{\n    fcn.00409989(param_1, param_2, 0x431c08);\n    return;\n}\n",
        "token_count": 47
    },
    "00409b21": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409b21(uint arg_8h, uint arg_ch)\n\n{\n    uint var_ch;\n    \n    fcn.0040ab56(&var_ch, &arg_ch, arg_ch, 0, 0, 0, 0);\n    fcn.00409af5(&var_ch, arg_8h);\n    return;\n}\n",
        "token_count": 80
    },
    "00409b4e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409b4e(uint arg_8h, uint arg_ch)\n\n{\n    uint var_ch;\n    \n    fcn.0040ab56(&var_ch, &arg_ch, arg_ch, 0, 0, 0, 0);\n    fcn.00409b0b(&var_ch, arg_8h);\n    return;\n}\n",
        "token_count": 82
    },
    "0040a338": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040a338(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    puVar1 = 0x431d18;\n    do {\n        if (param_1 == *puVar1) {\n            *0x448f34 = *(iVar2 * 8 + 0x431d1c);\n            *0x448f38 = param_1;\n            return;\n        }\n        puVar1 = puVar1 + 2;\n        iVar2 = iVar2 + 1;\n    } while (puVar1 < 0x431e80);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        *0x448f34 = 0xd;\n        *0x448f38 = param_1;\n        return;\n    }\n    if ((param_1 < 0xbc) || (*0x448f34 = 8,  0xca < param_1)) {\n        *0x448f34 = 0x16;\n    }\n    *0x448f38 = param_1;\n    return;\n}\n",
        "token_count": 261
    }
}