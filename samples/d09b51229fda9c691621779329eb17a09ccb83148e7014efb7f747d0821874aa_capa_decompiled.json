{
    "00401090": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401195) overlaps instruction at (ram,0x00401193)\n// \n// WARNING: Removing unreachable block (ram,0x004010cd)\n// WARNING: Removing unreachable block (ram,0x004010da)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl\nfcn.00401090(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint32_t uVar1;\n    int32_t extraout_ECX;\n    int32_t iVar2;\n    int32_t extraout_ECX_00;\n    uint8_t uVar3;\n    uint *puVar4;\n    uint8_t *unaff_EBX;\n    uint *puVar5;\n    uint *puVar6;\n    bool bVar7;\n    uint var_27h;\n    uint var_8h;\n    uint var_4h;\n    uchar uStack44;\n    uint uStack43;\n    uint *puStack12;\n    uint32_t uStack8;\n    \n    puStack12 = fcn.00402930(noname_4, noname_5, 0x406054, 7);\n    if (puStack12 != NULL) {\n        if ((puStack12 < 0) || (iVar2 = extraout_ECX,  puStack12 >= 0)) {\n            iVar2 = 7;\n        }\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        puVar4 = &uStack44 + 1;\n        for (; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *puVar4 = 0;\n        *(puVar4 + 2) = 0;\n        uStack8 = 0;\n        do {\n            uVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            puVar4 = uVar1 & 0x800000ff;\n            if (puVar4 < 0) {\n                puVar4 = (puVar4 - 1U | 0xffffff00) + 1;\n            }\n            uVar3 = puVar4;\n            (&uStack44)[uStack8] = uVar3;\n            uVar1 = uStack8 + 1;\n            bVar7 = SBORROW4(uVar1, 0x20);\n            iVar2 = uStack8 - 0x1f;\n            uStack8 = uVar1;\n        } while (uVar1 < 0x20);\n        if ((uVar1 < 0x20) || (bVar7 == iVar2 < 0)) {\n            iVar2 = 8;\n            puVar4 = puStack12;\n        }\n        else {\n            *puVar4 = *puVar4 | uVar3;\n            bVar7 = SCARRY1(*puVar4, uVar3);\n            *puVar4 = *puVar4 + uVar3;\n            iVar2 = extraout_ECX_00;\n        }\n        puVar5 = &uStack44;\n        puVar6 = puVar4;\n        for (; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar6 = *puVar5;\n            puVar5 = puVar5 + 1;\n            puVar6 = puVar6 + 1;\n        }\n        if (!bVar7) {\n            if (bVar7) {\n                LOCK();\n                puVar4 = puVar4 + 0x658f517f;\n            }\n        }\n        fcn.00402160(noname_0, noname_1, noname_2, noname_3, &uStack44, 0x20, puVar4);\n        fcn.00404940(noname_4, noname_5);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 985
    },
    "00401210": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint fcn.00401210(void)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint *puVar4;\n    bool bVar5;\n    uint *puStack168;\n    uint *puStack160;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    uint uStack8;\n    \n    puVar3 = &stack0xfffffffc;\n    bVar5 = (POPCOUNT(&lpVersionInformation & 0xff) & 1U) == 0;\n    puStack160 = &lpVersionInformation;\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if ((!bVar5) && (bVar5)) {\n        puVar4 = &stack0xffffff5c;\n        cVar1 = '\\x1e';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *puVar3;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 330
    },
    "00401290": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040179d) overlaps instruction at (ram,0x0040179b)\n// \n// WARNING: Removing unreachable block (ram,0x00401620)\n\nvoid fcn.00401290(uint32_t param_1, uint param_2, uint32_t param_3, uint32_t param_4, uint32_t param_5, uint param_6, \n                 uint param_7, uchar param_8, uint param_9, uint16_t param_10)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    char cVar3;\n    uint8_t uVar4;\n    int16_t iVar5;\n    uint32_t uVar6;\n    char *pcVar7;\n    int16_t extraout_CX;\n    uint16_t extraout_CX_00;\n    uint16_t extraout_CX_01;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint8_t extraout_DL;\n    uint8_t uVar8;\n    uint16_t extraout_DX;\n    ushort extraout_DX_00;\n    int32_t extraout_EDX;\n    uint16_t uVar9;\n    uint32_t unaff_EBX;\n    uint32_t uVar10;\n    uint unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    uchar uVar11;\n    bool bVar12;\n    uint8_t in_AF;\n    uchar uVar13;\n    bool bVar14;\n    char cVar15;\n    float10 fVar16;\n    uchar uVar17;\n    unkbyte3 Var18;\n    uchar uVar19;\n    unkbyte3 Var20;\n    uchar uVar21;\n    uchar uVar22;\n    uchar uVar23;\n    uchar uVar24;\n    ushort uVar25;\n    uint *puVar26;\n    unkuint3 Var27;\n    int32_t iVar28;\n    uint uVar29;\n    uchar uVar30;\n    uchar uVar31;\n    uchar uVar32;\n    uchar uVar33;\n    uchar uVar34;\n    \n    uVar24 = param_9 >> 0x18;\n    uVar22 = param_9;\n    fcn.004044a0(0x4104d4, 0x17, 0x406024, 10);\n    fcn.004044a0(0x4104d4, 0x17, 0x406030, 0x12);\n    fcn.004044a0(0x4104d4, 0x17, 0x406044, 4);\n    puVar26 = unaff_ESI;\n    uVar29 = unaff_EBP;\n    fcn.004044a0(0x4104d4, 0x17, 0x406048, 0xc);\n    cVar3 = fcn.004044a0(0x4104d4, 0x17, 0x406054, 7);\n    uVar11 = false;\n    uVar13 = ((extraout_CX + 1U & 0xff | (extraout_CX + 1U >> 8 & cVar3 + 2U) << 8) & 0x7bc9) == 0;\n    uVar4 = fcn.004044a0(0x4104d4, 0x17, 0x40605c, 0xb);\n    if ((uVar11 || uVar13) || (!uVar11 && !uVar13)) {\n        uVar9 = 0xc;\n        uVar23 = 0;\n        uVar29 = 0x406068;\n        puVar26 = 0x17;\n    }\n    else {\n        *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffe4;\n        uVar11 = 0;\n        uVar13 = (uVar4 | 0x68) == 0;\n        uVar9 = 0x4060;\n        uVar23 = 0x6a;\n    }\n    fcn.004044a0(0x4104d4, puVar26, uVar29, CONCAT13(uVar23, uVar9));\n    if ((!uVar11 && !uVar13) && (uVar11 || uVar13)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.004044a0(0x4104d4, 0x17, 0x406074, 8);\n    fcn.004044a0(0x4104d4, 0x17, 0x40607c, 0xd);\n    bVar12 = false;\n    bVar14 = (unaff_ESI & extraout_CX_00) == 0;\n    fcn.004044a0(0x4104d4, 0x17, 0x40608c, 0x18);\n    if ((!bVar12 && !bVar14) && (bVar12 || bVar14)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.004044a0(0x4104d4, 0x17, 0x4060a4, 0x25);\n    Var27 = unaff_EBX & 0xffff;\n    uVar10 = unaff_EBX & 0xff000000 | Var27 | (unaff_EBX >> 0x10) << 0x10;\n    iVar5 = fcn.004044a0(0x4104d4, 0x17, 0x4060cc, 10);\n    bVar12 = false;\n    bVar14 = iVar5 == Var27;\n    iVar28 = 0;\n    Var27 = 0x4104d4;\n    fcn.004044a0(0x4104d4, 0x17, 0x4060d8, 0xc);\n    if ((!bVar12 && !bVar14) && (bVar12 || bVar14)) {\n        unaff_ESI = Var27 | iVar28 << 0x18;\n    }\n    fcn.004044a0(0x4104d4, 0x17, 0x4060e4, 0xd);\n    fcn.004044a0(0x4104d4, 0x17, 0x4060f4, 6);\n    fcn.004044a0(0x4104d4, 0x17, 0x4060fc, 5);\n    uVar31 = 4;\n    uVar32 = 0x61;\n    uVar33 = 0x40;\n    uVar34 = 0;\n    uVar11 = 0x17;\n    uVar13 = 0;\n    uVar23 = 0;\n    uVar30 = 0;\n    uVar29 = 0x4104d4;\n    fcn.004044a0(0x4104d4, 0x17, 0x406104, 0xd);\n    puVar1 = extraout_EDX + 0x17;\n    bVar12 = CARRY1(*puVar1, extraout_CH);\n    *puVar1 = *puVar1 + extraout_CH;\n    bVar14 = *puVar1 == 0;\n    uVar6 = fcn.004044a0(0x4104d4, uVar29, CONCAT13(uVar30, CONCAT12(uVar23, CONCAT11(uVar13, uVar11))), \n                         CONCAT13(uVar34, CONCAT12(uVar33, CONCAT11(uVar32, uVar31))));\n    if ((bVar14) || (!bVar14)) {\ncode_r0x00401571:\n        fcn.004044a0(0x4104d4, 0x17, 0x406130, 0xf);\n        fcn.004044a0(0x4104d4, 0x17, 0x406140, 0xe);\n        fcn.004044a0(0x4104d4, 0x17, 0x406150, 0xb);\n        cVar15 = false;\n        uVar8 = extraout_DL & uVar10;\n    }\n    else {\n        uVar10 = uVar10 + 1;\n        uVar4 = uVar6;\n        if (!bVar12 && uVar10 != 0) {\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            piVar2 = (uVar6 & 0xffff0000 | CONCAT11((uVar6 >> 8) + in_AF, uVar4 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n            *piVar2 = *piVar2 - uVar10;\n            unaff_ESI = unaff_ESI + 1;\n            goto code_r0x00401571;\n        }\n        cVar3 = extraout_ECX + 1 >> 8;\n        cVar15 = SCARRY1(uVar4 % 4, cVar3);\n        uVar8 = uVar4 % 4 + cVar3;\n        pcVar7 = uVar6 & 0xffff0000 | CONCAT11(uVar4 / 4, uVar4) & 0xffffff00 | uVar8;\n        if (extraout_ECX + 1 == 1 || uVar8 != 0) {\n            *pcVar7 = *pcVar7 + uVar8;\n            goto code_r0x00401571;\n        }\n    }\n    cVar3 = uVar8 < '\\0';\n    uVar29 = fcn.004044a0(0x4104d4, 0x17, 0x40615c, 0xb);\n    puVar26 = unaff_EDI;\n    if ((cVar15 == cVar3) && (cVar15 != cVar3)) {\n        out(0xc4, uVar29);\n        puVar26 = unaff_EDI + 1;\n        *unaff_EDI = uVar29;\n    }\n    param_5 = param_5 & 0xff000000;\n    uVar19 = 0xb;\n    Var18 = 0x4061;\n    param_3 = 0x68000000;\n    param_2 = 0x17004104;\n    param_1 = 0xd4004016;\n    fcn.004044a0(0x4104d4, 0x17, 0x406168, 0xb);\n    uVar9 = uVar10 & 0xff00 | uVar10 - 0x12;\n    bVar12 = uVar9 < extraout_DX;\n    bVar14 = uVar9 == extraout_DX;\n    uVar22 = 0;\n    param_8 = 0x61;\n    param_7 = 0x74000000;\n    param_6 = 0x17004104;\n    uVar19 = 0x60;\n    uVar21 = 0xd4;\n    Var20 = 0x4016;\n    fcn.004044a0(0x4104d4, 0x17, 0x406174, 10);\n    if ((bVar12 || bVar14) || (!bVar12 && !bVar14)) {\n        Var20 = 0;\n        param_3 = 0x80000000;\n        uVar19 = 0xc;\n        Var18 = 0x4061;\n    }\n    else {\n        *puVar26 = *unaff_ESI;\n        uVar10 = uVar10 & 0xffff0000 | CONCAT11(0xdf, uVar10);\n        unaff_EBP = 0x6ae181d0;\n        *(extraout_ECX_00 + 0x40) = 0;\n        unaff_ESI = unaff_ESI + 1;\n        puVar26 = puVar26 + 1;\n    }\n    param_3 = param_3 & 0xff000000;\n    param_2 = 0x17004104;\n    param_1 = 0xd4004016;\n    uVar17 = param_3 >> 0x18;\n    fcn.004044a0(0x4104d4, 0x17, CONCAT31(Var18, uVar17), CONCAT31(Var20, uVar19));\n    uVar17 = unaff_EBP;\n    param_1 = param_1 & 0xffffff | puVar26 << 0x18;\n    uVar22 = 0;\n    param_8 = 0x61;\n    param_7 = 0x8c000000;\n    param_6 = 0x17004104;\n    param_4 = CONCAT13(0xbf, unaff_EBP >> 8);\n    param_5 = 0xd4004016;\n    fcn.004044a0(0x4104d4, 0x17, 0x40618c, 0xe);\n    uVar22 = 0;\n    param_8 = 0x61;\n    param_7 = 0x9c000000;\n    param_6 = 0x17004104;\n    param_4 = param_4 & 0xffffff | 0xef000000;\n    param_5 = 0xd4004016;\n    fcn.004044a0(0x4104d4, 0x17, 0x40619c, 0x11);\n    uVar11 = false;\n    uVar9 = uVar10;\n    uVar22 = 0;\n    uVar13 = 0;\n    uVar23 = 0;\n    param_8 = 0x61;\n    param_7 = 0xb0000000;\n    param_6 = 0x17004104;\n    param_4 = param_4 & 0xffffff | 0x24000000;\n    param_5 = 0xd4004017;\n    fcn.004044a0(0x4104d4, 0x17, 0x4061b0, 0x13);\n    if ((!uVar11) && (uVar11)) {\n        uVar11 = *0x10 == 0xffffffe8;\n    }\n    param_5 = 0x14;\n    param_4 = 0x4061c4;\n    param_3 = 0x17;\n    param_2 = 0x4104d4;\n    param_1 = 0x401740;\n    fcn.004044a0(0x4104d4, 0x17, 0x4061c4, 0x14);\n    if ((!uVar11) && (uVar11)) {\n        out(*unaff_ESI, extraout_DX_00);\n    }\n    param_1 = 0x33;\n    fcn.004044a0(0x4104d4, 0x17, 0x4061d8, 0x33);\n    fcn.004044a0(0x4104d4, 0x17, 0x40620c, 10);\n    if (SCARRY4(&stack0xffffffec, 0x40) == &stack0x0000002c < 0) {\n        uVar25 = uVar10 >> 0x10;\n        uVar10 = uVar10 & 0xffff;\n        param_10 = uVar9;\n        if (SCARRY4(&stack0xffffffec, 0x40) != &stack0x0000002c < 0) goto code_r0x004017a4;\n    }\n    uVar9 = uVar10;\n    param_10 = 4;\n    uVar25 = 0;\n    uVar22 = 0x18;\n    uVar13 = 0x62;\n    uVar23 = 0x40;\n    uVar24 = 0;\ncode_r0x004017a4:\n    param_8 = 0x17;\n    param_7 = 0x4104d4;\n    param_6 = 0x4017b0;\n    fcn.004044a0(0x4104d4, 0x17, CONCAT13(uVar24, CONCAT12(uVar23, CONCAT11(uVar13, uVar22))), \n                 CONCAT22(uVar25, param_10));\n    param_10 = 5;\n    uVar22 = 0x1c;\n    uVar24 = 0;\n    param_8 = 0x17;\n    param_7 = 0x4104d4;\n    param_6 = 0x4017e0;\n    fcn.004044a0(0x4104d4, 0x17, 0x40621c, 5);\n    param_10 = 6;\n    uVar22 = 0x24;\n    uVar24 = 0;\n    param_8 = 0x17;\n    param_7 = 0x4104d4;\n    param_6 = 0x401803;\n    fcn.004044a0(0x4104d4, 0x17, 0x406224, 6);\n    bVar12 = (uVar9 & extraout_CX_01) < 0;\n    param_10 = 0x2a;\n    uVar22 = 0x58;\n    uVar24 = 0;\n    param_8 = 0x17;\n    param_7 = 0x4104d4;\n    param_6 = 0x40181e;\n    fVar16 = fcn.004044a0(0x4104d4, 0x17, 0x406258, 0x2a);\n    if ((!bVar12) && (bVar12)) {\n        *(puVar26 + 7) = fVar16;\n    }\n    param_7 = 0xb;\n    param_6 = 0x406284;\n    param_5 = 0x17;\n    param_4 = 0x4104d4;\n    param_3 = 0x401842;\n    fcn.004044a0(0x4104d4, 0x17, 0x406284, 0xb);\n    return;\n}\n",
        "token_count": 4112
    },
    "00401850": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401bd0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401df6) overlaps instruction at (ram,0x00401df5)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nfloat10 fcn.00401bd0(uint param_1, char param_2)\n\n{\n    uint32_t *puVar1;\n    char *pcVar2;\n    uchar *puVar3;\n    float fVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint16_t *puVar8;\n    int32_t **ppiVar9;\n    int32_t iVar10;\n    char extraout_CH;\n    char extraout_CH_00;\n    ushort extraout_CX;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t extraout_EDX;\n    uint32_t extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint16_t uVar11;\n    ushort uVar12;\n    uint16_t uVar13;\n    uint32_t unaff_EBX;\n    uint32_t uVar14;\n    int32_t **ppiVar15;\n    uint32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t *piVar16;\n    int16_t iVar17;\n    int32_t *unaff_EDI;\n    int32_t *piVar18;\n    uchar in_CF;\n    uchar uVar19;\n    bool bVar20;\n    char cVar21;\n    bool bVar22;\n    bool in_SF;\n    uchar uVar23;\n    float10 in_ST0;\n    float10 fVar24;\n    float10 extraout_ST0;\n    ulong uVar25;\n    unkbyte6 Var26;\n    uint *puVar27;\n    uint uVar28;\n    uint uVar29;\n    \n    if ((!in_SF) && (in_SF)) {\n        piVar18 = unaff_EDI + 1;\n        piVar16 = unaff_ESI + 1;\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        unaff_ESI = unaff_ESI + 5;\n        in_CF = *piVar16 < *piVar18;\n    }\n    fcn.004044a0(0x4104d4, 0x17, 0x40638c, 0x20);\n    if ((!in_CF) && (in_CF)) {\n        unaff_EBX = unaff_EBX + *(unaff_EBX + 0x69 + extraout_EDX * 4) + in_CF;\n    }\n    fcn.004044a0(0x4104d4, 0x17, 0x4063ac, 0x26);\n    uVar19 = 0;\n    uVar23 = 0;\n    cVar21 = (extraout_EDX_00 & 0x1200) == 0;\n    uVar14 = unaff_EBP;\n    while( true ) {\n        uVar29 = 0x4104d4;\n        uVar28 = 0x401c3f;\n        fcn.004044a0(0x4104d4, 0x17, 0x4063d4, 0x4104d4);\n        if ((uVar19) || (!uVar19)) break;\n        if (extraout_ECX == 1 || cVar21 == '\\0') {\n            *unaff_EDI = unaff_ESI + 1;\n            puVar8 = *0x9750e2b5;\n            unaff_ESI = 0x6ab8ec44;\n            puVar1 = *0x9750e2b5 + -0x12;\n            uVar6 = uVar19;\n            uVar5 = *puVar1;\n            uVar7 = *puVar1 - unaff_EBP;\n            uVar23 = SBORROW4(*puVar1, unaff_EBP) != SBORROW4(uVar7, uVar6);\n            *puVar1 = uVar7 - uVar6;\n            *puVar8 = *puVar8 + (uVar5 < unaff_EBP || uVar7 < uVar6) * ((puVar8 & 3) - (*puVar8 & 3));\ncode_r0x00401c5f:\n            puVar27 = 0x4104d4;\n            fVar24 = fcn.004044a0(0x4104d4, 0x17, uVar14, uVar28);\n            if ((!uVar23) && (uVar23)) {\n                *puVar27 = uVar29;\n                return fVar24;\n            }\n            fcn.004044a0(0x4104d4, 0x17, 0x4063f8, 0xb);\n            fcn.004044a0(0x4104d4, 0x17, 0x406404, 0x12);\n            bVar20 = extraout_CH - 1U < 5;\n            bVar22 = extraout_CH - 1U == 5;\n            uVar25 = fcn.004044a0(0x4104d4, 0x17, 0x406418, 0x12);\n            ppiVar9 = uVar25;\n            if (!bVar20 && !bVar22) {\n                unaff_EBX = unaff_EBX & 0xffff00ff;\n            }\n            *unaff_EDI = *unaff_ESI;\n            pcVar2 = (uVar25 >> 0x20) + 0x17;\n            *pcVar2 = *pcVar2 + extraout_CH_00 + param_2;\n            ppiVar9[-1] = 0x4104d4;\n            ppiVar9[-2] = 0x401d28;\n            fcn.004044a0(ppiVar9[-1], *ppiVar9, ppiVar9[1], ppiVar9[2]);\n            ppiVar9[6] = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n            *(ppiVar9 + 0x16) = extraout_CX;\n            uVar28 = ppiVar9[6];\n            ppiVar9[6] = 0x8;\n            ppiVar9[5] = 0x406430;\n            ppiVar9[4] = 0x17;\n            ppiVar9[3] = 0x4104d4;\n            ppiVar9[2] = 0x401d53;\n            uVar25 = fcn.004044a0(ppiVar9[3], ppiVar9[4], ppiVar9[5], ppiVar9[6]);\n            ppiVar9[6] = uVar25;\n            ppiVar9[5] = extraout_ECX_00;\n            ppiVar9[4] = uVar25 >> 0x20;\n            ppiVar9[3] = uVar28;\n            ppiVar9[2] = ppiVar9 + 7;\n            ppiVar9[1] = 0x6ae181d0;\n            *ppiVar9 = unaff_ESI + 1;\n            ppiVar9[-1] = unaff_EDI + 1;\n            piVar18 = ppiVar9[-1];\n            piVar16 = *ppiVar9;\n            uVar14 = ppiVar9[3];\n            ppiVar9[6] = 0x8;\n            ppiVar9[5] = 0x406438;\n            ppiVar9[4] = 0x17;\n            ppiVar9[3] = 0x4104d4;\n            ppiVar9[2] = 0x401d71;\n            uVar28 = fcn.004044a0(ppiVar9[3], ppiVar9[4], ppiVar9[5], ppiVar9[6]);\n            ppiVar9[6] = uVar28;\n            ppiVar9[6] = 0x6;\n            ppiVar9[5] = 0x406440;\n            ppiVar9[4] = 0x17;\n            ppiVar9[3] = 0x4104d4;\n            ppiVar9[2] = 0x401d92;\n            Var26 = fcn.004044a0(ppiVar9[3], ppiVar9[4], ppiVar9[5], ppiVar9[6]);\n            uVar13 = Var26 >> 0x20;\n            ppiVar9[6] = Var26;\n            *(ppiVar9 + 0x16) = uVar14;\n            uVar11 = uVar14 & 0xff00 | uVar14 - 0x12;\n            bVar20 = uVar11 < uVar13;\n            bVar22 = uVar11 == uVar13;\n            uVar12 = *(ppiVar9 + 0x16);\n            ppiVar9[6] = 0x7;\n            ppiVar9[5] = 0x406448;\n            ppiVar9[4] = 0x17;\n            ppiVar9[3] = 0x4104d4;\n            ppiVar9[2] = 0x401dc0;\n            iVar10 = fcn.004044a0(ppiVar9[3], ppiVar9[4], ppiVar9[5], ppiVar9[6]);\n            iVar17 = piVar18;\n            if ((bVar20 || bVar22) || (!bVar20 && !bVar22)) {\n                ppiVar15 = ppiVar9 + 2;\n                ppiVar9[2] = 0x7;\n            }\n            else {\n                iVar17 = iVar17 + 4;\n                *piVar18 = *piVar16;\n                uVar12 = CONCAT11(0xdf, uVar12);\n                ppiVar15 = iVar10 + 4;\n                piVar16 = piVar16 + 1;\n            }\n            ppiVar15[-1] = 0x406450;\n            ppiVar15[-2] = 0x17;\n            ppiVar15[-3] = 0x4104d4;\n            ppiVar15[-4] = 0x401ded;\n            fcn.004044a0(ppiVar15[-3], ppiVar15[-2], ppiVar15[-1], *ppiVar15);\n            ppiVar15[4] = extraout_EDX_01;\n            *(ppiVar15 + 0xe) = uVar12;\n            bVar20 = false;\n            uVar13 = *(ppiVar15 + 0xe);\n            ppiVar15[4] = 0x6;\n            ppiVar15[3] = 0x406458;\n            ppiVar15[2] = 0x17;\n            ppiVar15[1] = 0x4104d4;\n            *ppiVar15 = 0x401e24;\n            puVar27 = fcn.004044a0(ppiVar15[1], ppiVar15[2], ppiVar15[3], ppiVar15[4]);\n            if ((!bVar20) && (*(ppiVar15 + 2) = iVar17,  bVar20)) {\n                fVar4 = *(piVar16 + 0x6f);\n                puVar3 = *puVar27;\n                *ppiVar15 = 0xb7f8c08b;\n                if (puVar3 <= ppiVar15 + 1 && puVar27 != 0xffffffff) {\n                    return extraout_ST0 / fVar4;\n                }\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *ppiVar15 = 0x25;\n            ppiVar15[-1] = 0x406460;\n            ppiVar15[-2] = 0x17;\n            ppiVar15[-3] = 0x4104d4;\n            ppiVar15[-4] = 0x401e5c;\n            fcn.004044a0(ppiVar15[-3], ppiVar15[-2], ppiVar15[-1], *ppiVar15);\n            ppiVar15[4] = uVar14 & 0xffff0000 | uVar13;\n            ppiVar15[4] = 0x8;\n            ppiVar15[3] = 0x406488;\n            ppiVar15[2] = 0x17;\n            ppiVar15[1] = 0x4104d4;\n            *ppiVar15 = 0x401e7d;\n            fVar24 = fcn.004044a0(ppiVar15[1], ppiVar15[2], ppiVar15[3], ppiVar15[4]);\n            return fVar24;\n        }\n    }\n    uVar28 = 0x19;\n    uVar14 = 0x4063dc;\n    goto code_r0x00401c5f;\n}\n",
        "token_count": 2949
    },
    "00402110": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00402110(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00402e30(0x80000002, 0x4061d8, 0x406224, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 133
    },
    "00403240": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00403240(char *arg_8h, uint32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint *puVar7;\n    char *pcVar8;\n    bool bVar9;\n    uint uStack632;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    puVar6 = &stack0xfffffffc;\n    var_264h = 0;\n    puVar7 = &var_263h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_160h = '\\0';\n    puVar7 = &var_15fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    bVar9 = (POPCOUNT(arg_ch & 0xff) & 1U) != 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    if ((bVar9) && (!bVar9)) {\n        puVar7 = &uStack632;\n        cVar1 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return uVar3;\n    }\n    uStack632 = arg_8h;\n    (*_sym.imp.MSVCRT.dll_sprintf)(*0x10 + -0x164, 0x608c);\n    uStack632 = arg_8h;\n    (*pcVar2)(*0x10 + -0x268, 0x60a4);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar5 = 0xffffffff;\n    pcVar8 = &var_160h;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar8 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar5 - 1;\n    uVar5 = 0xffffffff;\n    pcVar8 = arg_8h;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar8 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x4060cc;\n    var_30h = 0x4060d8;\n    var_2ch = 0x4060e4;\n    var_28h = 0x4060f4;\n    var_24h = 0x4060fc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar5 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar5 = (arg_ch != 0) * 4;\n        do {\n            uStack632._0_2_ = *(&var_48h + uVar5);\n            uStack632._2_2_ = *(&var_48h + uVar5) >> 0x10;\n            iVar4 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar5), *(&var_5ch + uVar5), *(&var_20h + uVar5));\n            if (iVar4 != 0) {\n                return 0;\n            }\n            uVar5 = uVar5 + 4;\n        } while (uVar5 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1329
    },
    "00403780": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2",
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004037f1) overlaps instruction at (ram,0x004037ed)\n// \n\nbool fcn.00403780(uint32_t param_1)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t *unaff_ESI;\n    int32_t *unaff_EDI;\n    bool bVar4;\n    unkbyte6 Var5;\n    uchar auStack256 [208];\n    uint uStack48;\n    uint32_t uStack44;\n    uint32_t uStack40;\n    \n    uStack40 = param_1;\n    uStack44 = 0x403793;\n    Var5 = (*_sym.imp.MSVCRT.dll__strlwr)();\n    iVar2 = Var5;\n    bVar4 = 0xfffffffb < &stack0xffffffd8;\n    puVar3 = &stack0xfffffffc;\n    if (!bVar4 && *0x10 != 0x24) {\n        puVar3 = &stack0xfffffffc;\n        if (bVar4 || *0x10 == 0x24) {\n            *unaff_EDI = *unaff_ESI;\n            uVar1 = in(Var5 >> 0x20);\n            iVar2 = (&stack0xffffff00 | uVar1) + 2;\n            param_1 = param_1 & 0xffff0000 | CONCAT11(iVar2 + -0x21, param_1);\n            LOCK();\n            bVar4 = *(iVar2 * 3) < iVar2 >> 8;\n            puVar3 = 0xc7e181d2;\n            unaff_ESI = unaff_ESI + 1;\n            unaff_EDI = unaff_EDI + 1;\n        }\n    }\n    *(puVar3 + -0xc) = 0x406448;\n    *(puVar3 + -8) = 0x406450;\n    *(puVar3 + -4) = 0x406458;\n    if ((!bVar4) && (bVar4)) goto code_r0x004037dd;\n    bVar4 = false;\n    unaff_EDI = NULL;\n    unaff_ESI = puVar3 + -0x14;\n    while( true ) {\n        iVar2 = *unaff_ESI;\ncode_r0x004037dd:\n        uStack40 = iVar2 + 0x7c8ecb0d + !bVar4;\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x3327e95e;\n        *(puVar3 + 0x68bec75) = *(puVar3 + 0x68bec75) + -1;\n        uStack48 = 0x4037fb;\n        uStack44 = param_1;\n        iVar2 = (*_sym.imp.MSVCRT.dll_strstr)();\n        if (iVar2 != 0) break;\n        unaff_EDI = unaff_EDI + 1;\n        unaff_ESI = unaff_ESI + 1;\n        bVar4 = unaff_EDI < 0x5;\n        if (!bVar4) {\n            uStack40 = 0x406430;\n            uStack48 = 0x403821;\n            uStack44 = param_1;\n            iVar2 = (*_sym.imp.MSVCRT.dll_strstr)();\n            return iVar2 == 0;\n        }\n    }\n    return true;\n}\n",
        "token_count": 779
    },
    "00403690": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nbool fcn.00403690(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    pcbData = 0x104;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x406460, 0x406488, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(0xf0, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(0xf0);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 316
    },
    "004029b0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402af1) overlaps instruction at (ram,0x00402aed)\n// \n// WARNING: Removing unreachable block (ram,0x00402a33)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nfloat10 __cdecl fcn.004029b0(uint32_t arg_8h, int32_t arg_ch, int32_t *arg_10h, int32_t *arg_14h)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int16_t unaff_BX;\n    char cVar8;\n    char cVar9;\n    bool bVar10;\n    float10 extraout_ST0;\n    float10 fVar11;\n    double in_stack_458b92c5;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = fcn.00402d80(0, arg_8h, arg_ch + 1U >> 1);\n    uVar3 = uVar3 & 0xffff;\n    cVar9 = '\\0';\n    cVar8 = (uVar3 + unaff_BX | 0x11a9) < 0;\n    piVar4 = (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    piVar5 = piVar4;\n    if ((cVar9 == cVar8) && (cVar9 != cVar8)) {\n        *(arg_8h | &stack0xfffffffc) = piVar4;\n        piVar5 = piVar4 & 0xffff0000 | piVar4 + (piVar4 >> 8) * 'y';\n    }\n    uVar1 = piVar5[0x16];\n    if (uVar3 < uVar1) {\n        iVar6 = (uVar3 - uVar1 & 0xffff) - 1;\n    }\n    else {\n        iVar6 = uVar3 - (uVar1 & 0xffff);\n    }\n    uVar3 = uVar1 >> 0x10;\n    uVar2 = uVar1 >> 0x10;\n    bVar10 = SBORROW2(iVar6, uVar2);\n    if (iVar6 < uVar2) {\n        if ((!bVar10) && (bVar10)) {\n            LOCK();\n            uVar3 = uVar3 + 0x658f517f;\n        }\n        iVar6 = (iVar6 - uVar3 & 0xffff) - 1;\n    }\n    else {\n        iVar6 = iVar6 - uVar3;\n    }\n    iVar7 = iVar6 + arg_ch;\n    *arg_14h = iVar7;\n    fVar11 = extraout_ST0;\n    if ((iVar7 != 0 && SCARRY4(iVar6, arg_ch) == iVar7 < 0) && (iVar7 == 0 || SCARRY4(iVar6, arg_ch) != iVar7 < 0)) {\n        fVar11 = extraout_ST0 - in_stack_458b92c5;\n        piVar4 = arg_14h;\n    }\n    *arg_10h = piVar4[0x16];\n    return fVar11;\n}\n",
        "token_count": 741
    },
    "00401ef0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool fcn.00401ef0(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    iVar1 = fcn.00401210();\n    if (iVar1 == 0) {\n        return false;\n    }\n    fcn.004035b0();\n    iVar1 = fcn.00402ee0(0x406074);\n    if (iVar1 != -1) {\n        return false;\n    }\n    fcn.00401850();\n    *0x42452c = 1;\n    iVar1 = fcn.00404550();\n    if (iVar1 != 0) {\n        return false;\n    }\n    var_20h = 0;\n    var_80h._0_1_ = 0;\n    puVar2 = &var_1fh;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    var_60h._0_1_ = 0;\n    puVar2 = &var_80h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    var_40h._0_1_ = 0;\n    puVar2 = &var_60h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_40h + 1;\n    for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.00404100(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar1 != 0) {\n        iVar1 = fcn.00402380(&var_20h);\n        if (iVar1 != 0) {\n            iVar1 = fcn.00404580(&var_80h, *0x10 + -100, *0x10 + -0x24, 0xbc);\n            return iVar1 != 0;\n        }\n        return false;\n    }\n    return false;\n}\n",
        "token_count": 700
    },
    "00402160": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004022c9) overlaps instruction at (ram,0x004022c7)\n// \n\nvoid __cdecl\nfcn.00402160(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint *arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint *puVar3;\n    char cVar4;\n    uint8_t uVar5;\n    int32_t in_EAX;\n    int32_t iVar6;\n    int32_t in_ECX;\n    int32_t *in_EDX;\n    uint *unaff_EBX;\n    uint *puVar7;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar8;\n    uint8_t in_AF;\n    bool bVar9;\n    unkbyte10 in_ST0;\n    uint *apuStack312 [2];\n    uint in_stack_fffffed4;\n    int32_t in_stack_fffffed8;\n    uint in_stack_fffffedc;\n    int32_t in_stack_fffffee0;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((&stack0xfffffffc < 0x10c) || (SBORROW4(&stack0xfffffffc, 0x10c) == &stack0xfffffef0 < 0)) {\n        in_EAX = arg_20h + 0x20;\n        in_stack_fffffedc = 0x20;\n        in_ECX = arg_8h;\n        unaff_EBX = arg_18h;\n        unaff_ESI = arg_20h;\n        unaff_EDI = arg_1ch;\n        in_stack_fffffed4 = arg_1ch;\n        in_stack_fffffed8 = arg_8h;\n        in_stack_fffffee0 = in_EAX;\n    }\n    *(in_EAX + -0x7ce92414) = in_ST0;\n    uVar5 = in_EAX - 1;\n    uVar2 = 9 < (uVar5 & 0xf) | in_AF;\n    uVar5 = uVar5 + uVar2 * '\\x06';\n    *in_EDX = *in_EDX + 0x758bdf84;\n    *(unaff_EBX + 0x7d8b084d) = *(unaff_EBX + 0x7d8b084d) & in_ECX;\n    *(unaff_EBX + 0x6a502046) =\n         (*(unaff_EBX + 0x6a502046) - in_ECX) -\n         (uVar5 + (0x90 < (uVar5 & 0xf0) | &stack0xfffffffc < 0x10c | uVar2 * (0xf9 < uVar5)) * '`' < 0x8b);\n    puVar1 = in_ECX + 0x57;\n    *puVar1 = *puVar1 & in_EDX;\n    bVar9 = *puVar1 == 0;\n    apuStack312[1] = 0x40219b;\n    fcn.00402720(unaff_EBX, in_stack_fffffed4, in_stack_fffffed8, in_stack_fffffedc, in_stack_fffffee0);\n    puVar7 = unaff_EBX;\n    if ((!bVar9) && (bVar9)) {\n        puVar8 = &stack0xfffffecc;\n        puVar7 = &stack0xfffffecc;\n        cVar4 = '\\x10';\n        puVar3 = unaff_EBX;\n        do {\n            puVar3 = puVar3 + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *puVar3;\n            cVar4 = cVar4 + -1;\n            apuStack312[1] = unaff_EBX;\n        } while ('\\0' < cVar4);\n    }\n    fcn.00402720(unaff_EBX, unaff_EDI, puVar7[3], 0x20, unaff_ESI + 0x60);\n    fcn.00402720(unaff_EBX, unaff_EDI, puVar7[4], 0x20, unaff_ESI + 0xa0);\n    fcn.00402720(unaff_EBX, unaff_EDI, puVar7[5], 0x20, unaff_ESI + 0xe0);\n    iVar6 = fcn.00402110();\n    if (iVar6 == -1) {\n        iVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(unaff_ESI + 0x120) = iVar6 % 5;\n    }\n    else {\n        *(unaff_ESI + 0x120) = iVar6;\n    }\n    *(puVar7 + -0x43) = 0;\n    puVar8 = puVar7 + -0x10b;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    puVar7[-1] = 0x104;\n    *(puVar8 + 2) = 0;\n    iVar6 = fcn.00402e30(0x80000001, 0x406258, 0x406284, puVar7 + -2, puVar7 + -0x43, puVar7 + -1);\n    if (iVar6 != 0) {\n        if ((-1 < iVar6) && (-1 >= iVar6)) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        iVar6 = (*_sym.imp.MSVCRT.dll__stricmp)(puVar7 + -0x10c, 0xd4);\n        if (iVar6 == 0) {\n            *(unaff_ESI + 0x120) = *(unaff_ESI + 0x120) | 0x80;\n        }\n    }\n    return;\n}\n",
        "token_count": 1411
    },
    "00402c10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402c10(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_14h;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x406048;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.00404460(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, &lpCreationTime, &var_1ch, &var_14h);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1154
    },
    "00402ee0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402ee0(uint arg_8h)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint hObject;\n    \n    hObject = 0xffffffff;\n    iVar3 = (**0x42451c)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = (**0x424520)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    uVar1 = hObject;\n    while( true ) {\n        hObject = uVar1;\n        if (iVar4 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return uVar1;\n        }\n        iVar4 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar4 == 0) break;\n        iVar4 = (**0x424524)(iVar3, &var_12ch);\n        uVar1 = hObject;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n    return var_124h;\n}\n",
        "token_count": 369
    },
    "004033d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004033d0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00402ee0(0x40607c);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 211
    },
    "00403490": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403541)\n\nuint __cdecl fcn.00403490(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_8h_00;\n    char cVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar **ppuVar4;\n    uchar **ppuVar5;\n    bool in_ZF;\n    uchar *apuStack28 [2];\n    uint var_4h;\n    \n    puVar3 = &stack0xfffffffc;\n    ppuVar5 = &stack0xfffffffc;\n    if ((!in_ZF) && (ppuVar5 = &stack0xfffffffc,  in_ZF)) {\n        ppuVar4 = apuStack28 + 1;\n        ppuVar5 = apuStack28 + 1;\n        cVar1 = '\\x10';\n        do {\n            puVar3 = puVar3 + -1;\n            ppuVar4 = ppuVar4 + -1;\n            *ppuVar4 = *puVar3;\n            cVar1 = cVar1 + -1;\n            apuStack28[1] = &stack0xfffffffc;\n        } while ('\\0' < cVar1);\n    }\n    *0x424528 = fcn.00401000();\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    *(ppuVar5 + 8) = iVar2;\n    if (iVar2 == -1) {\n        return 0;\n    }\n    arg_8h_00 = *(ppuVar5 + 8);\n    iVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)(arg_8h_00, *(ppuVar5 + 0xc), *(ppuVar5 + 0x10), ppuVar5 + -4, 0);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if (*0x424528 != 0) {\n        iVar2 = fcn.004033d0(arg_8h_00);\n        *0x424528 = iVar2 == 0;\n    }\n    fcn.00402c10(0, arg_8h_00);\n    if (*0x424528 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 529
    },
    "00404550": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00404550(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00404460(0x406010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 73
    },
    "00404580": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404780) overlaps instruction at (ram,0x0040477d)\n// \n// WARNING: Removing unreachable block (ram,0x00404646)\n\nuchar * fcn.00404580(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    uchar *arg_ch;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    code *pcVar6;\n    char *pcVar7;\n    uint8_t extraout_CL;\n    int32_t iVar8;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t extraout_EDX;\n    uint32_t uVar9;\n    uint unaff_EBX;\n    uchar *puVar10;\n    uint unaff_ESI;\n    uchar *puVar11;\n    uint unaff_EDI;\n    uint *puVar12;\n    uint16_t in_SS;\n    uint16_t in_DS;\n    uint8_t uVar13;\n    uchar uVar14;\n    uint8_t in_AF;\n    bool bVar15;\n    bool bVar16;\n    char cVar17;\n    char cVar18;\n    ulong uVar19;\n    uint32_t in_stack_fffffdb0;\n    uint32_t in_stack_fffffdb4;\n    uint32_t noname_8;\n    uchar *arg_8h;\n    uchar *noname_11;\n    uint noname_12;\n    uint32_t noname_14;\n    uint arg_ch_00;\n    uint32_t in_stack_fffffde8;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack16;\n    uchar auStack12 [8];\n    \n    puVar10 = &stack0xfffffffc;\n    uVar3 = in_stack_fffffde8 & 0xffffff00;\n    puVar12 = &stack0xfffffde9;\n    for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    *puVar12 = 0;\n    *(puVar12 + 2) = 0;\n    uStack276 = 0;\n    puVar12 = &stack0xfffffeed;\n    for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar12 = 0;\n        puVar12 = puVar12 + 1;\n    }\n    *puVar12 = 0;\n    uStack16 = 1;\n    *(puVar12 + 2) = 0;\n    cVar18 = '\\0';\n    cVar17 = unaff_EBX < '\\0';\n    uVar14 = (POPCOUNT(unaff_EBX) & 1U) == 0;\n    puVar11 = &stack0xfffffde8;\n    arg_ch_00 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    puVar5 = &stack0xfffffde8;\n    noname_11 = &stack0xfffffeec;\n    noname_12 = 0x406030;\n    noname_14 = param_1;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((uVar14) || (!uVar14)) {\n        arg_ch = &stack0xfffffff4;\n    }\n    else {\n        param_1 = 0x34a96cf4;\n        arg_ch = extraout_EDX + 1;\n        in_DS = *0x8d17b43a >> 0x20;\n        cVar18 = SCARRY4(*0x8d17b43a, 1);\n        puVar10 = *0x8d17b43a + 1;\n        cVar17 = puVar10 < 0;\n    }\n    arg_8h = puVar10 + -4;\n    noname_8 = 0x404624;\n    uVar19 = fcn.004031c0(arg_8h, arg_ch);\n    uVar9 = uVar19 >> 0x20;\n    if (cVar18 == cVar17) {\n        uVar2 = uVar9 << 0x10;\n        noname_8 = noname_8 & 0xffff | uVar2;\n        if (cVar18 != cVar17) {\n            out(0xc4, uVar19);\n            noname_8 = uVar2 | in_DS;\n            in_stack_fffffdb0 = uVar9 & 0xffffff00 | uVar19 >> 0x20 ^ extraout_CL;\n            in_stack_fffffdb4 = in_stack_fffffdb4 & 0xffff0000 | in_SS;\n            *(puVar12 + 3) = uVar19;\n        }\n    }\n    iVar8 = fcn.00401090(param_1, *(puVar10 + 0xc), *(puVar10 + 0x10), *(puVar10 + 0x14), *(puVar10 + -4), \n                         *(puVar10 + -8), in_stack_fffffdb0, in_stack_fffffdb4, noname_8, arg_8h, arg_ch, noname_11, \n                         noname_12, puVar5, noname_14, puVar11, arg_ch_00, unaff_EDI, unaff_ESI, unaff_EBX, uVar3);\n    if (iVar8 == 0) {\n        return NULL;\n    }\n    uVar3 = fcn.00403490(puVar10 + -0x110, *(puVar10 + -4), *(puVar10 + -8));\n    if (uVar3 == 0) {\n        return NULL;\n    }\n    bVar15 = (param_1 & (uVar3 & 0xffff0000 | CONCAT11((uVar3 >> 8) + '\\x01', uVar3))) == 0;\n    fcn.00404a60();\n    if ((!bVar15) && (bVar15)) {\n        in_AF = ((in_AF & 1) * '\\x10' & 0x10) != 0;\n    }\n    iVar8 = fcn.00402ee0(0x406068);\n    if ((iVar8 == -1) && (iVar8 = fcn.00402ee0(0x40605c),  iVar8 == -1)) {\n        iVar8 = *(puVar10 + 8);\n    }\n    else {\n        iVar8 = *(puVar10 + 8);\n        iVar4 = fcn.004028f0(iVar8);\n        if (iVar4 != 0) {\n            fcn.00404af0();\n            fcn.00402e20();\n            return 0x1;\n        }\n        if (*0x424528 == 0) {\n            return NULL;\n        }\n    }\n    iVar4 = fcn.00402300(iVar8, puVar10 + -0x110);\n    if (iVar4 == 0) {\n        puVar11 = NULL;\n    }\n    else {\n        puVar11 = *(puVar10 + -0xc);\n    }\n    if (puVar11 == NULL) goto code_r0x0040478e;\n    while( true ) {\n        puVar5 = fcn.00404870(iVar8);\n        if (puVar5 == NULL) {\n            *(puVar10 + -0xc) = 0;\n            puVar11 = puVar5;\n        }\ncode_r0x0040478e:\n        if (puVar11 == NULL) {\n            puVar11 = fcn.00403240(iVar8, 0);\n            *(puVar10 + -0xc) = puVar11;\n        }\n        bVar15 = false;\n        cVar17 = false;\n        bVar16 = puVar11 == NULL;\n        puVar5 = puVar11;\n        if (!bVar16) {\n            fcn.00402e20();\n            bVar15 = 0xfffffffb < &stack0xfffffdc4;\n            cVar17 = SCARRY4(&stack0xfffffdc4, 4);\n            puVar5 = &stack0xfffffdc8;\n        }\n        uVar14 = bVar16 || *0x10 == 0x238;\n        cVar18 = puVar5 < 0;\n        if ((bVar15 || uVar14) || (!bVar15 && (!bVar16 && *0x10 != 0x238))) {\n            pcVar6 = (*_sym.imp.KERNEL32.dll_Sleep)();\n            iVar4 = extraout_ECX_00;\n        }\n        else {\n            puVar1 = iVar8 + 0x68;\n            uVar13 = *puVar1 < &stack0xfffffdc8;\n            *puVar1 = *puVar1 - &stack0xfffffdc8;\n            iVar4 = func_0xff4047f0();\n            cVar17 = SCARRY4(iVar4, 0x40507c) != SCARRY4(sym.imp.KERNEL32.dll_Sleep + iVar4, uVar13);\n            pcVar6 = sym.imp.KERNEL32.dll_Sleep + iVar4 + uVar13;\n            cVar18 = pcVar6 < 0;\n            uVar14 = pcVar6 == NULL;\n            iVar4 = extraout_ECX;\n        }\n        if ((uVar14 || cVar17 != cVar18) || (!uVar14 && cVar17 == cVar18)) break;\n        in_AF = 9 < (pcVar6 & 0xf) | in_AF;\n        uVar13 = pcVar6 + in_AF * '\\x06';\n        pcVar7 = pcVar6 & 0xffff0000 | CONCAT11((pcVar6 >> 8) + in_AF, uVar13) & 0xff0f;\n        if (iVar4 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *pcVar7 = *pcVar7 + (uVar13 & 0xf);\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)();\n    return puVar11;\n}\n",
        "token_count": 2262
    },
    "00404820": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040485e) overlaps instruction at (ram,0x0040485a)\n// \n\nuint __cdecl fcn.00404820(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_ESI;\n    int32_t iVar3;\n    int32_t *unaff_EDI;\n    int32_t *piVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    \n    iVar2 = *((&stack0xfffffffc & 0xffff0000 | *0x10 - 4) + 8);\n    piVar5 = unaff_EDI;\n    iVar6 = unaff_ESI;\n    do {\n        iVar2 = (*_sym.imp.MSVCRT.dll__access)(iVar2, 0);\n        if (iVar2 == -1) {\n            return 1;\n        }\n        iVar3 = iVar6;\n        piVar4 = piVar5;\n    } while (((iVar2 == -1) && (iVar2 != -1)) &&\n            (iVar3 = unaff_ESI,  piVar4 = unaff_EDI,  extraout_ECX != 1 && iVar2 == -1));\n    *piVar4 = iVar3 + 4;\n    uVar1 = *0x9750e2b5;\n    *(piVar4 + 0x5e) = *(piVar4 + 0x5e);\n    return uVar1;\n}\n",
        "token_count": 339
    },
    "004049b0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.004049b0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00401290();\n        fcn.00401ef0();\n        fcn.00403e80();\n        if (*0x424528 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00404b20();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 161
    },
    "00402300": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040233f) overlaps instruction at (ram,0x0040233c)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402300(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint32_t extraout_ECX;\n    uint32_t uVar2;\n    uint8_t extraout_DL;\n    uint in_EDX;\n    uint16_t unaff_BX;\n    bool bVar3;\n    uint uVar4;\n    uint var_4h;\n    \n    bVar3 = ((CONCAT11(in_EAX >> 8 & in_EDX >> 8, in_EAX) * 2 | in_EDX) ^ 0x6c00) == unaff_BX;\n    uVar4 = 0;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    if (!bVar3) {\n        uVar2 = (extraout_ECX >> 8 & 0xffff00) << 8 | extraout_ECX & 0xffff;\n        if (bVar3) goto code_r0x00402338;\n    }\n    uVar2 = arg_8h;\ncode_r0x00402338:\n    *(uVar2 + 0x50) = *(uVar2 + 0x50) | extraout_DL;\n    fcn.00402080(0x47, uVar4);\n    uVar4 = fcn.004048d0(uVar1, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n    return uVar4;\n}\n",
        "token_count": 384
    },
    "00402e30": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00402e30(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 208
    },
    "00404940": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404940(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar1;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    iVar1 = fcn.004029b0(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.004029b0(arg_8h_00, arg_ch_00, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 163
    },
    "00402490": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004025ff) overlaps instruction at (ram,0x004025fd)\n// \n// WARNING: Removing unreachable block (ram,0x0040252a)\n// WARNING: Removing unreachable block (ram,0x00402532)\n// WARNING: Removing unreachable block (ram,0x00402535)\n\nuint64_t __cdecl fcn.00402490(int16_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char cVar5;\n    uint in_EAX;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint32_t uVar6;\n    char *in_EDX;\n    uint extraout_EDX;\n    uint32_t uVar7;\n    uchar *puVar8;\n    uint *unaff_ESI;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint *puVar11;\n    int16_t *unaff_EDI;\n    uint *puVar12;\n    bool in_PF;\n    uint8_t in_AF;\n    bool bVar13;\n    uint64_t uVar14;\n    uint uStack28;\n    uchar *puStack24;\n    uint var_4h;\n    int32_t iVar3;\n    \n    puVar11 = &stack0xfffffffc;\n    if ((!in_PF) && (in_PF)) {\n        out(*unaff_ESI, in_EDX);\n        do {\n            cVar5 = in_EAX >> 8;\n            in_AF = 9 < (in_EAX & 0xf) | in_AF;\n            in_EAX = CONCAT31(CONCAT21(in_EAX >> 0x10, cVar5 - in_AF), -in_AF);\n        } while (in_AF || cVar5 == *in_EDX);\n        piVar1 = unaff_EDI + in_EDX;\n        iVar4 = *piVar1;\n        iVar2 = *piVar1;\n        *piVar1 = (iVar2 + 0x7b) - in_AF;\n        iVar3 = *piVar1;\n        *(in_ECX + -0x75) = in_EAX;\n        unaff_ESI = unaff_ESI + 1;\n        arg_8h = unaff_EDI;\n        if ((SBORROW4(iVar4, -0x7b) != SBORROW4(iVar2 + 0x7b, in_AF)) == iVar3 < 0) {\n            *(unaff_EDI + 0x2f) = *(unaff_EDI + 0x2f);\n            goto code_r0x004024bd;\n        }\n    }\n    bVar13 = *arg_8h == 0x5a4d;\n    if (bVar13) {\n        if ((!bVar13) && (bVar13)) {\n            out(*unaff_ESI, in_EDX);\n        }\n        if (*(*(arg_8h + 0x1e) + arg_8h) != 0x4550) {\n            return ZEXT48(in_EDX) << 0x20;\n        }\n        uVar6 = (in_EDX >> 8 & 0xffff00) << 8 | in_EDX & 0xffff;\n        if ((*(arg_8h + 0x1e) + arg_8h)[0x16] != 0) {\n            return uVar6 << 0x20;\n        }\n        uVar7 = 0x40;\n        if (0x80 < *(arg_8h + 0x1e)) {\n            uVar6 = *(arg_8h + 0x1e);\n            if (uVar6 < 0xc0) {\n                uVar7 = uVar6 - 0x80;\n            }\n            puVar8 = &stack0xfffffffc;\n            if ((uVar6 != 0xc0) && (puVar8 = &stack0xfffffffc,  uVar6 == 0xc0)) {\n                puVar12 = &stack0xffffffe8;\n                puVar8 = &stack0xffffffe8;\n                puStack24 = &stack0xfffffffc;\n                cVar5 = '\\x10';\n                do {\n                    puVar11 = puVar11 + -1;\n                    puVar12 = puVar12 + -1;\n                    *puVar12 = *puVar11;\n                    cVar5 = cVar5 + -1;\n                } while ('\\0' < cVar5);\n            }\n            puStack24 = uVar7;\n            uVar14 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n            *(puVar8 + -4) = uVar14;\n            if (uVar14 != 0) {\n                uVar9 = 0;\n                bVar13 = false;\n                uVar10 = uVar9;\n                uVar6 = uVar7;\n                if (uVar7 != 0) {\n                    do {\n                        puStack24 = 0x4025d3;\n                        iVar4 = (*_sym.imp.MSVCRT.dll_rand)();\n                        uVar14 = CONCAT44(iVar4 % 0xff, *(puVar8 + -4));\n                        uVar9 = uVar10 + 1;\n                        bVar13 = SBORROW4(uVar9, uVar7);\n                        uVar6 = uVar9 - uVar7;\n                        *(uVar10 + *(puVar8 + -4)) = iVar4 % 0xff;\n                        uVar10 = uVar9;\n                    } while (uVar9 < uVar7);\n                    arg_8h = *(puVar8 + 8);\n                }\n                if ((bVar13 == uVar6 < 0) && (bVar13 != uVar6 < 0)) {\n                    return uVar14 & 0xffffffff00000000 | uVar9;\n                }\n                puVar11 = uVar14;\n                puVar12 = arg_8h + 0x40;\n                for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n                    *puVar12 = *puVar11;\n                    puVar11 = puVar11 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n                    *puVar12 = *puVar11;\n                    puVar11 = puVar11 + 1;\n                    puVar12 = puVar12 + 1;\n                }\n                puStack24 = *(puVar8 + -4);\n                sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n                return CONCAT44(extraout_EDX, 1);\n            }\n            return uVar14 & 0xffffffff00000000;\n        }\n        return uVar6 << 0x20;\n    }\n    in_EAX = 0;\ncode_r0x004024bd:\n    return CONCAT44(in_EDX, in_EAX);\n}\n",
        "token_count": 1544
    },
    "00402d80": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402dbe) overlaps instruction at (ram,0x00402dbd)\n// \n// WARNING: Removing unreachable block (ram,0x00402d9f)\n// WARNING: Type propagation algorithm not settling\n\nuint8_t * __cdecl fcn.00402d80(uint8_t *arg_8h, uint16_t *arg_ch, uint16_t *arg_10h)\n\n{\n    uint8_t *in_EAX;\n    uint16_t *puVar1;\n    uint16_t *puVar2;\n    char in_SF;\n    bool in_OF;\n    \n    if (((in_OF == in_SF) && (in_OF != in_SF)) || (!in_OF)) {\n        arg_8h = in_EAX;\n    }\n    puVar1 = arg_10h;\n    if (arg_10h != NULL) {\n        do {\n            if ((puVar1 < 0) || (puVar1 >= 0)) {\n                arg_10h = *arg_ch;\n            }\n            *puVar1 = *puVar1 & 0xc3;\n            *(arg_10h + -0x1bf31e4b) = *(arg_10h + -0x1bf31e4b) << 6;\n            arg_8h = arg_8h + arg_ch;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            puVar2 = arg_10h + -0xdf98eea;\n            puVar1 = puVar1 + -1;\n            arg_10h = arg_ch;\n            arg_ch = puVar2;\n        } while (puVar1 != NULL);\n    }\n    return arg_8h + (arg_8h >> 0x10);\n}\n",
        "token_count": 415
    },
    "00404b20": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404b20(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42452c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00401e90(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4062e4, acStack1304, &uStack2112);\n    uStack2088 = 0x40636c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x406384;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00404d30(auStack1564, 0x4062e0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1870
    },
    "00403020": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403020(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004049b0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x406490;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00404100": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040413c)\n\nulong __cdecl fcn.00404100(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint extraout_EDX;\n    uint *puVar6;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar6 = &var_10bh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    var_8h = 0;\n    *(puVar6 + 2) = 0;\n    fcn.00402640();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        uVar2 = fcn.00404530();\n        uVar3 = fcn.00404530();\n        uVar4 = fcn.00404530();\n        fcn.00401e90(arg_10h, uVar2);\n        fcn.00401e90(arg_8h, uVar3);\n        fcn.00401e90(arg_ch, uVar4);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x406024, &lpBuffer, arg_10h);\n        iVar5 = fcn.00404820(&var_314h);\n        if (iVar5 != 0) {\n            (*pcVar1)(&var_210h, 0x406030, &lpBuffer, arg_8h);\n            iVar5 = fcn.00404820(&var_210h);\n            if (iVar5 != 0) {\n                (*pcVar1)(&var_210h, 0x406030, &lpBuffer, arg_ch);\n                iVar5 = fcn.00404820(&var_210h);\n                if (iVar5 != 0) {\n                    iVar5 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar5 = var_8h;\n    } while (var_4h < 3);\n    fcn.00401e90(arg_14h, 4);\n    return CONCAT44(extraout_EDX, iVar5 != 0);\n}\n",
        "token_count": 630
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401062) overlaps instruction at (ram,0x0040105f)\n// \n// WARNING: Removing unreachable block (ram,0x00401056)\n// WARNING: Removing unreachable block (ram,0x00401064)\n\nbool fcn.00401000(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    // [00] -r-x section size 16384 named .text\n    var_4h = 0x104;\n    iVar1 = fcn.00402e30(0x80000002, 0x4062f0, 0x406330, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 227
    },
    "00401e90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ea5) overlaps instruction at (ram,0x00401ea3)\n// \n\nvoid fcn.00401e90(uint param_1, char *param_2)\n\n{\n    int32_t iVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    bool in_SF;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((!in_SF) && (puVar4 = &stack0xfffffffc,  in_SF)) {\n        param_2 = in_EAX + -0x38f3ba75;\n        *param_2 = *param_2 + param_2;\n        *param_2 = *param_2 + param_2;\n        puVar4 = &stack0xfffffffd;\n    }\n    if (param_2 != NULL) {\n        do {\n            iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n            iVar1 = *(puVar4 + -4);\n            *(iVar1 + *(puVar4 + 8)) = iVar2 % 0x1a + 'a';\n            uVar3 = iVar1 + 1;\n            *(puVar4 + -4) = uVar3;\n        } while (uVar3 < *(puVar4 + 0xc));\n    }\n    return;\n}\n",
        "token_count": 303
    },
    "00402080": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402080(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 127
    },
    "00402640": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040266b)\n\nvoid fcn.00402640(void)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint *unaff_EBP;\n    bool in_ZF;\n    \n    if ((!in_ZF) && (in_ZF)) {\n        puVar3 = &stack0xfffffffc;\n        cVar1 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar3 = puVar3 + -1;\n            *puVar3 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    if (*0x4244f8 == 0) {\n        uVar2 = (*_sym.imp.MSVCRT.dll_time)();\n        (*_sym.imp.MSVCRT.dll_srand)(uVar2);\n        *0x4244f8 = 1;\n    }\n    return;\n}\n",
        "token_count": 226
    },
    "00402720": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2h\n\nvoid __cdecl fcn.00402720(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t in_EDX;\n    uint8_t uVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    bool bVar6;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_2h;\n    \n    uVar2 = arg_14h * '\\x02';\n    var_8h = 0;\n    bVar6 = arg_14h == 0;\n    if (0 < arg_14h) {\n        puVar4 = 0x1;\n        do {\n            puVar5 = puVar4;\n            if ((!bVar6) && (bVar6)) {\n                puVar5 = puVar4 + 1;\n                out(*puVar4, in_EDX);\n            }\n            uVar1 = *(puVar5 % arg_ch + arg_8h);\n            uVar3 = *(var_8h + arg_10h) ^ *((puVar5 + -1) % arg_ch + arg_8h);\n            in_EDX = (puVar5 + -1) % arg_ch & 0xffffff00U | uVar3;\n            puVar5[arg_18h + -1] = uVar2 ^ uVar3;\n            puVar5[arg_18h] = uVar2 ^ uVar1;\n            var_8h = var_8h + 1;\n            puVar4 = puVar5 + 2;\n            bVar6 = var_8h == arg_14h;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 426
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.00403020(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.00402fc0(argv),  pcVar2 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar3 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar3)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar2)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 241
    },
    "004028f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004028f0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403240(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 53
    },
    "00402930": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00402930(char *arg_8h, char *arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar1 = arg_ch + (arg_8h - arg_14h);\n    if (arg_14h == 0) {\n        return CONCAT44(arg_ch, arg_8h);\n    }\n    if (arg_8h <= pcVar1) {\n        do {\n            if (*arg_8h == *arg_10h) {\n                bVar5 = true;\n                iVar2 = arg_14h;\n                pcVar3 = arg_8h;\n                pcVar4 = arg_10h;\n                do {\n                    pcVar4 = pcVar4 + 1;\n                    pcVar3 = pcVar3 + 1;\n                    iVar2 = iVar2 + -1;\n                    if (iVar2 == 0) break;\n                    bVar5 = *pcVar3 == *pcVar4;\n                } while (bVar5);\n                if (bVar5) goto code_r0x004029a6;\n            }\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_10h;\n        } while (arg_8h <= pcVar1);\n    }\n    arg_8h = NULL;\n    arg_10h = arg_ch;\ncode_r0x004029a6:\n    return CONCAT44(arg_10h, arg_8h);\n}\n",
        "token_count": 354
    },
    "00402b10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402bcb) overlaps instruction at (ram,0x00402bca)\n// \n// WARNING: Removing unreachable block (ram,0x00402bcb)\n\nuint fcn.00402b10(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uchar *unaff_EBP;\n    uint unaff_ESI;\n    int32_t *unaff_EDI;\n    ushort in_SS;\n    bool bVar3;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    uint var_31ch_2;\n    uint var_218h_2;\n    uint var_114h_2;\n    uint var_10h_2;\n    uint var_ch_2;\n    uint *var_8h_2;\n    uint *var_4h_2;\n    uchar *puStack4;\n    \n    puStack4 = unaff_EBP;\n    do {\n        var_ch_2 = 0x104;\n        uVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&fcn.00402b10::var_218h_2, &fcn.00402b10::var_ch_2, unaff_ESI);\n        bVar3 = (POPCOUNT(uVar1 & 0xff) & 1U) != 0;\n        if (uVar1 == 0) {\n            return 0;\n        }\n        var_4h_2 = 0x104;\n        var_8h_2 = 0x104;\n    } while (((bVar3) && (!bVar3)) &&\n            (segment(in_SS, *0x10 + 0x18),  puStack4 = &stack0xfffffffc,  unaff_ESI = 0x104,  !bVar3));\n    puStack4 = NULL;\n    var_4h_2 = 0x402ba0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    if (iVar2 != 0) {\n        if ((-1 < iVar2) && (-1 >= iVar2)) {\n            out(0xc4, iVar2);\n            *unaff_EDI = iVar2;\n        }\n        var_8h_2 = &fcn.00402b10::var_114h_2;\n        var_ch_2 = 0x402bdb;\n        var_4h_2 = &fcn.00402b10::var_114h_2;\n        iVar2 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n        if (iVar2 == 0) {\n            return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 628
    },
    "00403080": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040312b) overlaps instruction at (ram,0x00403126)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403080(uchar *arg_8h, uint arg_ch)\n\n{\n    char *pcVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint in_EAX;\n    uchar *puVar4;\n    int32_t in_ECX;\n    uchar *in_EDX;\n    uint16_t unaff_BX;\n    uchar *puVar5;\n    uchar *puVar6;\n    char *unaff_EDI;\n    char *pcVar7;\n    uint8_t in_AF;\n    bool bVar8;\n    bool bVar9;\n    float10 in_ST0;\n    float10 in_ST1;\n    uint16_t uStack20;\n    \n    puVar5 = &stack0xfffffffc;\n    uStack20 = in_EAX;\n    *arg_8h = 0xe5;\n    bVar9 = false;\n    bVar8 = (uStack20 ^ unaff_BX) < 0;\n    arg_8h[1] = 0x25;\n    if ((!bVar8) && (bVar8)) {\n        pcVar1 = unaff_EDI + 4;\n        pcVar7 = arg_8h + 4;\n        *(unaff_EDI + 0x1c) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        arg_8h = arg_8h + 5;\n        bVar9 = SBORROW1(*pcVar7, *pcVar1);\n        bVar8 = *pcVar7 - *pcVar1 < '\\0';\n        in_ST0 = in_ST1;\n    }\n    puVar4 = CONCAT31(in_EAX >> 8, 0x98);\n    arg_8h[2] = 0x98;\n    if ((bVar9 == bVar8) && (bVar9 != bVar8)) {\n        puVar6 = puVar4 + 1;\n        bVar9 = SCARRY4(in_EDX, puVar6);\n        in_EDX = in_EDX + puVar6;\n        bVar8 = in_EDX < 0;\n        puVar4 = arg_8h;\n        arg_8h = puVar6;\n    }\n    else {\n        arg_8h[3] = 0xd6;\n    }\n    puVar6 = puVar4;\n    if (bVar9 != bVar8) goto code_r0x004030ef;\n    while( true ) {\n        puVar6 = puVar4;\n        if (bVar9 != bVar8) {\n            arg_8h = arg_8h + -1;\n            pcVar7 = unaff_EDI | puVar5;\n            unaff_EDI = pcVar7 + 1;\n            *pcVar7 = puVar4;\n            in_EDX = in_EDX & 0xffffff00;\n            puVar6 = puVar4 + (puVar4 >> 8) * 'y';\n        }\ncode_r0x004030ef:\n        arg_8h[4] = 0xc9;\n        bVar8 = (POPCOUNT(puVar6 & 0xcb) & 1U) == 0;\n        cVar2 = puVar6;\n        arg_8h[5] = cVar2;\n        if ((bVar8) || (!bVar8)) {\n            arg_8h[6] = 0x26;\n        }\n        puVar5 = *0xc617b43a;\n        arg_8h = 0x34a96cf5;\n        bVar9 = SBORROW1(cVar2, 'Q');\n        bVar8 = cVar2 + -0x51 < '\\0';\n        *0x34a96cfc = 0xbb;\n        if ((cVar2 < 'R') || ('Q' < cVar2)) break;\n        uVar3 = in_EDX + 1;\n        in_AF = 9 < (uVar3 & 0xf) | in_AF;\n        puVar4 = CONCAT11((in_EDX + 1 >> 8) + in_AF, uVar3 + in_AF * '\\x06') & 0xff0f;\n        in_EDX = puVar6;\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    *0x34a96cfd = 0xaf;\n    if ((!bVar8) && (bVar8)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        arg_8h = 0x34a96cfa;\n    }\n    arg_8h[9] = 0x69;\n    arg_8h[10] = 0x6b;\n    arg_8h[0xb] = 8;\n    **(puVar5 + 0xc) = 0xc;\n    return;\n}\n",
        "token_count": 1133
    },
    "004031c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403207) overlaps instruction at (ram,0x00403204)\n// \n\nvoid __cdecl fcn.004031c0(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint extraout_EDX;\n    uint arg_ch_00;\n    uint32_t uVar2;\n    uint *puVar3;\n    bool bVar4;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    puVar3 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    bVar4 = false;\n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    fcn.00403080(uVar2 - 0x68, uVar2 - 4);\n    if ((bVar4) || (arg_ch_00 = extraout_EDX,  !bVar4)) {\n        arg_ch_00 = *(uVar2 - 4);\n    }\n    fcn.004040a0(uVar2 - 0x68, arg_ch_00, 0x406494, 0xa040);\n    puVar3 = *(uVar2 + 0xc);\n    **(uVar2 + 8) = 0x406494;\n    *puVar3 = 0xa040;\n    return;\n}\n",
        "token_count": 375
    },
    "004035b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403605) overlaps instruction at (ram,0x00403604)\n// \n\nuint fcn.004035b0(void)\n\n{\n    char *pcVar1;\n    code cVar2;\n    uchar uVar3;\n    char cVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uchar *extraout_ECX;\n    uint32_t unaff_EBX;\n    uint *puVar8;\n    uint *unaff_EBP;\n    uint unaff_ESI;\n    code *pcVar9;\n    bool bVar10;\n    uchar uVar11;\n    bool bVar12;\n    unkbyte6 Var13;\n    \n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    pcVar9 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar5 == 0) {\n        return 0;\n    }\n    bVar10 = false;\n    bVar12 = false;\n    uVar11 = iVar5 == unaff_EBX;\n    Var13 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    iVar6 = Var13;\n    *0x42451c = iVar6;\n    if ((bVar12) || (!bVar12)) {\n        *0x424520 = (*pcVar9)();\n    }\n    else {\n        cVar2 = in(Var13 >> 0x20);\n        *pcVar9 = cVar2;\n        if (!bVar10 && !uVar11) {\n            uVar7 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, iVar5, iVar6 + 1, unaff_ESI);\n            return uVar7;\n        }\n        uVar3 = *extraout_ECX;\n        pcVar1 = iVar5 + -1;\n        *pcVar1 = *pcVar1 + (Var13 >> 0x20);\n        uVar11 = *pcVar1 == '\\0';\n        *0x424520 = CONCAT31(0x406130, *((unaff_EBX & 0xffff0000 | CONCAT11(uVar3, 0xbc)) + 0x68));\n        pcVar9 = pcVar9 + 1;\n    }\n    if ((!uVar11) && (uVar11)) {\n        puVar8 = &stack0xffffffe4;\n        cVar4 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar8 = puVar8 + -1;\n            *puVar8 = *unaff_EBP;\n            cVar4 = cVar4 + -1;\n        } while ('\\0' < cVar4);\n    }\n    *0x424524 = (*pcVar9)(iVar5);\n    if (((*0x42451c != 0) && (*0x424520 != 0)) && (*0x424524 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 656
    },
    "00403840": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004038b0) overlaps instruction at (ram,0x004038ad)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00403840(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    ulong uVar6;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x404fb0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4063f8);\n    if (iVar1 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    hLibModule = iVar1;\n    (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x406404);\n    uVar6 = func_0x6a4038c0(0x47);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(uVar6 >> 0x20 & 0xffffff00 | (uVar6 >> 0x20) + *0x53, uVar6);\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x406418);\n    if (pcVar2 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar1 = (*pcVar2)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar1 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar1 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((-1 < iVar1) && (var_24h != NULL)) {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    arg_8h = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar1 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &arg_8h);\n                    if ((iVar1 < 0) || (arg_8h == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x00403c70:\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\ncode_r0x00403c7c:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar1 = (***arg_8h)(arg_8h, 0x4051b0, &var_10h);\n                    if (((iVar1 < 0) || (var_10h == NULL)) ||\n                       (iVar1 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar1 < 0)) {\njoined_r0x00403c37:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                        goto code_r0x00403c7c;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00403a73:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    else {\n                        fcn.00403660(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x40642c);\n                        if (iVar3 != 0) goto joined_r0x00403a73;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar1 = (***arg_8h)(arg_8h, 0x4051a0, &var_14h);\n                        if ((iVar1 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x00403c1c:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x00403c70;\n                        }\n                        iVar1 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar3 = var_3ch;\n                        if (iVar1 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x00403c1c;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar5 = &var_147h;\n                            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                                *puVar5 = 0;\n                                puVar5 = puVar5 + 1;\n                            }\n                            *puVar5 = 0;\n                            *(puVar5 + 2) = 0;\n                            fcn.00403660(iVar3, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar3 = fcn.00403780(&var_148h);\n                            if (iVar3 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x00403c37;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n        }\n        if (var_24h != NULL) {\n            var_4h = var_4h._1_3_ << 8;\n            (**(*var_24h + 8))(var_24h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar1;\n}\n",
        "token_count": 2441
    },
    "00403d80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403dac) overlaps instruction at (ram,0x00403da9)\n// \n// WARNING: Removing unreachable block (ram,0x00403e20)\n// WARNING: Removing unreachable block (ram,0x00403e28)\n// WARNING: Removing unreachable block (ram,0x00403e2b)\n// WARNING: Removing unreachable block (ram,0x00403dac)\n\nuint __cdecl fcn.00403d80(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x4063d4);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x403d00, 0);\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 470
    },
    "00403e80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403f33) overlaps instruction at (ram,0x00403f32)\n// \n// WARNING: Removing unreachable block (ram,0x00403f52)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t fcn.00403e80(void)\n\n{\n    int32_t iVar1;\n    uint extraout_EDX;\n    uint uVar2;\n    code *unaff_ESI;\n    uint *puVar3;\n    ushort in_SS;\n    uchar uVar4;\n    bool bVar5;\n    unkbyte6 Var6;\n    uint uStack640;\n    uchar auStack611 [259];\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    uint32_t uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    if ((!SBORROW4(&stack0xfffffffc, 0x260)) && (SBORROW4(&stack0xfffffffc, 0x260))) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.00401bd0();\n    uStack24 = fcn.00403690();\n    bVar5 = (POPCOUNT(uStack24 & 0xff) & 1U) == 0;\n    if (uStack24 != 0) {\n        if (((!bVar5) && (bVar5)) && (segment(in_SS, *0x10 + -0x270),  bVar5)) {\n            (*_sym.imp.USER32.dll_PostMessageA)();\n            return 0;\n        }\n        puVar3 = auStack611;\n        for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        uStack640 = 0;\n        Var6 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)();\n        uStack24 = Var6;\n        bVar5 = uStack24 != 0;\n        if (bVar5) {\n            if ((bVar5) && (!bVar5)) {\n                uVar2 = in(Var6 >> 0x20);\n                *(puVar3 + 3) = uVar2;\n                if (&uStack640 < 1) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            fcn.00402640();\n            uStack352 = 0;\n            puVar3 = &uStack351;\n            for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            uStack24 = 0;\n            do {\n                puVar3 = auStack92;\n                for (iVar1 = 0x11; iVar1 != 0; iVar1 = iVar1 + -1) {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 1;\n                }\n                uStack20 = 0;\n                auStack92[0] = 0x44;\n                uStack16 = 0;\n                uStack48 = 1;\n                uStack12 = 0;\n                uStack44 = 0;\n                uStack8 = 0;\n                iVar1 = (*_sym.imp.KERNEL32.dll_CreateProcessA)();\n                if (iVar1 == 0) {\n                    return 0;\n                }\n                uVar4 = 0;\n                (*_sym.imp.KERNEL32.dll_Sleep)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.00403d80, uStack12);\n                uVar2 = uStack20;\n                if ((!uVar4) && (uVar4)) {\n                    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8b27e95e;\n                    LOCK();\n                    uVar2 = extraout_EDX;\n                }\n                iVar1 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uVar2, 1000);\n                if (iVar1 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                }\n                unaff_ESI = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*unaff_ESI)(uStack20);\n                uStack24 = uStack24 + 1;\n            } while (uStack24 < 1);\n        }\n    }\n    return uStack24;\n}\n",
        "token_count": 1165
    },
    "00404270": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004043ad) overlaps instruction at (ram,0x004043ab)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x004042cd)\n// WARNING: Removing unreachable block (ram,0x004042d7)\n// WARNING: Removing unreachable block (ram,0x004042db)\n\nvoid __fastcall fcn.00404270(uint param_1, uint32_t param_2, uint32_t *param_3)\n\n{\n    uint32_t **ppuVar1;\n    char cVar2;\n    uint32_t *in_EAX;\n    uint32_t *puVar3;\n    int32_t iVar4;\n    uint32_t unaff_EBX;\n    uint32_t *unaff_EBP;\n    uchar *puVar5;\n    uint32_t unaff_ESI;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    ushort in_SS;\n    bool bVar9;\n    bool bVar10;\n    int32_t in_stack_5f9dff5f;\n    \n    bVar9 = (POPCOUNT(param_2 & 0x66) & 1U) != 0;\n    *param_3 = 0xe9;\n    cVar2 = in_EAX;\n    puVar5 = &stack0xfffffffc;\n    uVar7 = unaff_ESI;\n    if ((bVar9) && (puVar5 = &stack0xfffffffc,  !bVar9)) {\n        uVar7 = *param_3;\n        *param_3 = unaff_ESI;\n        puVar5 = &stack0xfffffffc + -in_stack_5f9dff5f;\n        if (puVar5 < 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        if (-1 < uVar7) {\n            bVar9 = SCARRY1(*in_EAX, cVar2);\n            *in_EAX = *in_EAX + cVar2;\n            puVar3 = in_EAX;\n            goto code_r0x004042ff;\n        }\n    }\n    *(param_3 + 1) = 0x5d;\n    *(param_3 + 2) = 0x99;\n    *(param_3 + 3) = 0x8c;\n    puVar3 = (CONCAT11((in_EAX >> 8) + -0x2b, cVar2) ^ 0x3d) + 0x7c28;\n    unaff_EBX = param_2;\ncode_r0x004042ea:\n    bVar9 = SBORROW2(puVar3 ^ CONCAT11(param_2 >> 8 | param_2, param_2), 0x4001);\n    *(param_3 + 1) = 0x72;\n    puVar3 = in_EAX;\n    param_2 = unaff_EBX;\n    uVar6 = uVar7;\n    unaff_EBP = in_EAX;\n    if (!bVar9) {\ncode_r0x004042ff:\n        uVar6 = uVar7;\n        in_EAX = unaff_EBP;\n        if (bVar9) {\n            LOCK();\n            puVar3 = puVar3 + 0x658f517f;\n            uVar6 = 0x138b2633;\n        }\n    }\n    do {\n        *(param_3 + 5) = 0x70;\n        bVar9 = (uVar6 | 0x561b) < param_2;\n        bVar10 = (POPCOUNT((uVar6 | 0x561b) - param_2 & 0xff) & 1U) == 0;\n        *(param_3 + 6) = 0x95;\n        uVar7 = uVar6;\n        if ((!bVar10) && (bVar10)) {\n            uVar7 = *param_3;\n            *param_3 = uVar6;\n            puVar5 = puVar5 + -*(puVar5 + 0x5f9dff63);\n            if (puVar5 < 0) break;\n            bVar9 = false;\n            bVar10 = (POPCOUNT(uVar7 & 0xff) & 1U) == 0;\n            if (-1 < uVar7) {\n                *(puVar5 + -4) = 0;\n                puVar5[-0x68] = 0;\n                puVar8 = puVar5 + -0x67;\n                for (iVar4 = 0x18; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n                *puVar8 = 0;\n                *(puVar8 + 2) = 0;\n                fcn.00404270(puVar5 + -0x68, puVar5 + -4);\n                fcn.004040a0(puVar5 + -0x68, *(puVar5 + -4), 0x4104ec, 0x14000);\n                puVar8 = *(puVar5 + 0xc);\n                **(puVar5 + 8) = 0x4104ec;\n                *puVar8 = 0x14000;\n                return;\n            }\n        }\n        *(param_3 + 7) = 0x3b;\n        if ((bVar10) || (!bVar10)) goto code_r0x00404394;\n        ppuVar1 = segment(in_SS, *0x10 + -0xc);\n        puVar3 = *ppuVar1;\n        param_2 = 0xb7bc9ea5;\n        if (bVar9) {\n            *puVar3 = *puVar3 | puVar3;\n            *puVar3 = *puVar3 + puVar3;\n            goto code_r0x004043aa;\n        }\n        uVar6 = uVar7;\n        if (!bVar10) {\ncode_r0x00404394:\n            *(param_3 + 2) = 0xb3;\ncode_r0x004043aa:\n            *(uVar7 | 0x5f) = 9;\n            return;\n        }\n    } while( true );\n    *puVar3 = *puVar3 + puVar3;\n    goto code_r0x004042ea;\n}\n",
        "token_count": 1431
    },
    "004043c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004043c0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00404270(&var_68h, &var_4h);\n    fcn.004040a0(&var_68h, var_4h, 0x4104ec, 0x14000);\n    *arg_8h = 0x4104ec;\n    *arg_ch = 0x14000;\n    return;\n}\n",
        "token_count": 241
    },
    "00404530": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00404530(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00404870": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404870(uint arg_8h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint hSCObject;\n    \n    uVar2 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    *(uVar2 - 4) = uVar1;\n    uVar1 = fcn.00402690(uVar1, *(uVar2 + 8));\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(*(uVar2 - 4));\n    return uVar1;\n}\n",
        "token_count": 159
    },
    "00404a60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool fcn.00404a60(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pvData;\n    \n    pvData = NULL;\n    iVar2 = fcn.00402b10(&pvData);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (pvData == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = pvData;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4061d8, 0x406218, 1, pvData, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 251
    },
    "00404d30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "contain loop",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404d5e) overlaps instruction at (ram,0x00404d5a)\n// \n\nuint __cdecl fcn.00404d30(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    uint8_t extraout_DL;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    while( true ) {\n        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n        bVar2 = false;\n        bVar4 = false;\n        bVar3 = (extraout_DL & 0x66) == 0;\n        (*_sym.imp.MSVCRT.dll_fflush)();\n        if ((bVar2 || bVar3) || (!bVar2 && !bVar3)) break;\n        if (!bVar4) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 291
    },
    "00404460": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404460(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "00402fc0": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402fc0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x406490, 0x424518, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 138
    },
    "004040a0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004040a0(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "004044a0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.004044a0(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint *puVar6;\n    int32_t *piVar7;\n    int32_t unaff_ESI;\n    bool bVar8;\n    uint uStack32;\n    int32_t iStack28;\n    uint var_8h;\n    uint var_1h;\n    \n    bVar8 = false;\n    puVar6 = &var_1h + 1;\n    if (0 < arg_14h) {\n        do {\n            if ((!bVar8) && (iStack28 = unaff_ESI,  bVar8)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *(puVar6 + -1) = *(puVar6[-2] + puVar6[4]);\n            iVar4 = puVar6[-2];\n            unaff_ESI = puVar6[2];\n            iVar1 = puVar6[3];\n            uVar3 = *(puVar6 + -1) ^ *(iVar4 % iVar1 + unaff_ESI);\n            piVar7 = puVar6;\n            if ((uVar3 != 0) && (uVar3 == 0)) {\n                piVar5 = &iStack28;\n                piVar7 = &iStack28;\n                cVar2 = '\\x10';\n                do {\n                    puVar6 = puVar6 + -1;\n                    piVar5 = piVar5 + -1;\n                    *piVar5 = *puVar6;\n                    cVar2 = cVar2 + -1;\n                } while ('\\0' < cVar2);\n            }\n            iStack28 = iVar4 % iVar1;\n            iVar1 = piVar7[5];\n            *(iVar4 + piVar7[4]) = iVar1 ^ uVar3;\n            iVar4 = iVar4 + 1;\n            bVar8 = SBORROW4(iVar4, iVar1);\n            piVar7[-2] = iVar4;\n            puVar6 = piVar7;\n        } while (iVar4 < iVar1);\n    }\n    return;\n}\n",
        "token_count": 544
    },
    "004048d0": {
        "rules": [
            "contain loop",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004048ea) overlaps instruction at (ram,0x004048e8)\n// \n// WARNING: Removing unreachable block (ram,0x00404923)\n\nuint __fastcall fcn.004048d0(int32_t param_1, char *param_2, uint param_3, ulong param_4)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    char cVar5;\n    uint in_EAX;\n    int32_t iVar4;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    uint8_t in_CF;\n    bool in_PF;\n    uint8_t in_AF;\n    uint32_t uVar3;\n    \n    if ((in_PF) || (!in_PF)) {\n        in_EAX = param_4 >> 0x20;\n    }\n    else {\n        out(*unaff_ESI, param_2);\n        in_CF = in_AF;\n        do {\n            cVar5 = in_EAX >> 8;\n            in_CF = 9 < (in_EAX & 0xf) | in_CF;\n            in_EAX = CONCAT31(CONCAT21(in_EAX >> 0x10, cVar5 - in_CF), -in_CF);\n        } while (in_CF || cVar5 == *param_2);\n    }\n    puVar1 = unaff_EDI + param_2 * 2;\n    uVar2 = *puVar1;\n    uVar3 = *puVar1;\n    *puVar1 = (uVar3 + 0x7b) - in_CF;\n    *(param_1 + -0x75) = in_EAX;\n    *param_2 = *param_2 + (param_1 >> 8) + (uVar2 < 0xffffff85 || uVar3 + 0x7b < in_CF);\n    iVar4 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    if (iVar4 != 0) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar4);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 477
    },
    "00402690": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402690(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 236
    },
    "00404af0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404af0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4061d8, 0x40621c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 81
    }
}