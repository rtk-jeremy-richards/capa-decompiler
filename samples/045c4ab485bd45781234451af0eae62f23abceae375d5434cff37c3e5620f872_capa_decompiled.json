{
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "0040cee7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040cee7(uint32_t arg_8h)\n\n{\n    bool bVar1;\n    bool bVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t arg_8h_00;\n    int32_t iVar6;\n    int32_t *in_ECX;\n    uint hWnd;\n    uint lpMsg;\n    uint var_ch;\n    int32_t lParam;\n    uint var_4h;\n    \n    bVar2 = true;\n    lParam = 0;\n    if ((arg_8h & 4) != 0) {\n        uVar4 = fcn.004109b6();\n        bVar1 = true;\n        if ((uVar4 & 0x10000000) == 0) goto code_r0x0040cf17;\n    }\n    bVar1 = false;\ncode_r0x0040cf17:\n    iVar5 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n    in_ECX[0xf] = in_ECX[0xf] | 0x18;\n    arg_8h_00 = fcn.0041a743();\n    pcVar3 = _sym.imp.USER32.dll_UpdateWindow;\ncode_r0x0040cfa2:\n    while ((!bVar2 || (iVar6 = (*_sym.imp.USER32.dll_PeekMessageW)(arg_8h_00, 0, 0, 0, 0),  iVar6 != 0))) {\n        do {\n            iVar6 = fcn.0041ab8f();\n            if (iVar6 == 0) {\n                fcn.00417276(0);\n                return -1;\n            }\n            if ((bVar1) && ((*(arg_8h_00 + 4) == 0x118 || (*(arg_8h_00 + 4) == 0x104)))) {\n                fcn.00410ab2(1);\n                (*pcVar3)(in_ECX[8]);\n                bVar1 = false;\n            }\n            iVar6 = (**(*in_ECX + 0x88))();\n            if (iVar6 == 0) {\n                in_ECX[0xf] = in_ECX[0xf] & 0xffffffe7;\n                return in_ECX[0x11];\n            }\n            iVar6 = fcn.0041aa92(arg_8h_00);\n            if (iVar6 != 0) {\n                bVar2 = true;\n                lParam = 0;\n            }\n            iVar6 = (*_sym.imp.USER32.dll_PeekMessageW)(arg_8h_00, 0, 0, 0, 0);\n        } while (iVar6 != 0);\n    }\n    if (bVar1) {\n        fcn.00410ab2(1);\n        (*pcVar3)(in_ECX[8]);\n        bVar1 = false;\n    }\n    if ((((arg_8h & 1) == 0) && (iVar5 != 0)) && (lParam == 0)) {\n        (*_sym.imp.USER32.dll_SendMessageW)(iVar5, 0x121, 0, in_ECX[8]);\n    }\n    if ((arg_8h & 2) == 0) goto code_r0x0040cf86;\n    goto code_r0x0040cf9f;\ncode_r0x0040cf86:\n    iVar6 = (*_sym.imp.USER32.dll_SendMessageW)(in_ECX[8], 0x36a, 0, lParam);\n    lParam = lParam + 1;\n    if (iVar6 == 0) {\ncode_r0x0040cf9f:\n        bVar2 = false;\n    }\n    goto code_r0x0040cfa2;\n}\n",
        "token_count": 841
    },
    "0041053c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041053c(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    uint32_t var_34h;\n    uint var_30h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    char16_t *var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.004213cc();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.00430820(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcW;\n        iVar1 = fcn.004213cc();\n        var_24h = *(iVar1 + 8);\n        var_1ch = *0x45f7b0;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            var_34h = 0xb;\n            var_10h = L\"AfxWnd90su\";\n            iVar1 = fcn.00410239(&var_34h);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            var_10h = L\"AfxOleControl90su\";\n            iVar1 = fcn.00410239(&var_34h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            var_10h = L\"AfxControlBar90su\";\n            var_18h = 0x10;\n            iVar1 = fcn.00410239(&var_34h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            var_18h = 0;\n            iVar1 = fcn.004104f8(&var_34h, L\"AfxMDIFrame90su\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            var_18h = 6;\n            iVar1 = fcn.004104f8(&var_34h, L\"AfxFrameOrView90su\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.0040db4f(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.0040db4f(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.0040db4f(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.0040db4f(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.0040db4f(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.0040db4f(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.0040db4f(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.0040db4f(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.0040db4f(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.0040db4f(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.0040db4f(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.0040db4f(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.0040db4f(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x40000) != 0) {\n            var_8h = 0x8000;\n            uVar2 = fcn.0040db4f(&var_ch, 0x40000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80000) != 0) {\n            var_8h = 0x1000;\n            uVar2 = fcn.0040db4f(&var_ch, 0x80000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n            uVar3 = uVar3 | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 1875
    },
    "004132d9": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004132d9(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        iVar1 = fcn.00413206(&var_10h);\n        if (iVar1 != 0) {\n            uVar2 = fcn.004109b6();\n            if ((uVar2 & 0x1000000) != 0) {\n                uVar3 = fcn.004109d0();\n                uVar3 = fcn.004109b6(0, uVar3);\n                (*_sym.imp.USER32.dll_AdjustWindowRectEx)(&var_10h, uVar3);\n                *(arg_8h + 8) = var_10h;\n                *(arg_8h + 0xc) = var_ch;\n                *(arg_8h + 0x10) = var_8h - var_10h;\n                *(arg_8h + 0x14) = var_4h - var_ch;\n            }\n        }\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 308
    },
    "00413968": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00413968(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n    }\n    if ((arg_8h[1] == 0x201) || (arg_8h[1] == 0xa1)) {\n        fcn.004217b7(*arg_8h);\n    }\n    if ((((*(in_ECX + 0x34) & 4) != 0) && (arg_8h[1] == 0x105)) && (arg_8h[2] == 0x79)) {\n        (**(*in_ECX + 0x160))(1);\n    }\n    if ((*(in_ECX + 0x34) & 2) != 0) {\n        if ((arg_8h[1] == 0x105) && (arg_8h[2] == 0x12)) {\n            (**(*in_ECX + 0x160))((in_ECX[0x35] == 1) + '\\x01');\n        }\n        else if ((arg_8h[1] == 0x106) && (in_ECX[0x35] == 2)) {\n            (**(*in_ECX + 0x160))(1);\n            in_ECX[0x37] = 1;\n        }\n    }\n    if (((*(in_ECX + 0x34) & 1) == 0) &&\n       ((((iVar1 = arg_8h[1],  iVar1 == 0x100 && (arg_8h[2] == 0x1b)) || ((iVar1 == 0x201 || (iVar1 == 0x204)))) ||\n        (((iVar1 == 0xa1 || (iVar1 == 0xa4)) && (arg_8h[2] != 5)))))) {\n        (**(*in_ECX + 0x160))(2);\n    }\n    iVar1 = arg_8h[1];\n    if ((iVar1 == 0xa1) || (iVar1 == 0xa4)) {\n        in_ECX[0x38] = arg_8h[2] == 5;\n    }\n    else if (((iVar1 == 0xa2) || (iVar1 == 0xa5)) || ((iVar1 == 0x202 || (iVar1 == 0x205)))) {\n        in_ECX[0x38] = 0;\n    }\n    iVar1 = fcn.0040b139(arg_8h);\n    if (iVar1 == 0) {\n        if (in_ECX[0x20] != NULL) {\n            iVar1 = (**(*in_ECX[0x20] + 0x54))(arg_8h);\n            if (iVar1 != 0) goto code_r0x00413aa7;\n        }\n        if ((0xff < arg_8h[1]) && (arg_8h[1] < 0x10a)) {\n            iVar1 = (**(*in_ECX + 0x180))();\n            if (iVar1 != 0) {\n                iVar1 = (*_sym.imp.USER32.dll_TranslateAcceleratorW)(in_ECX[8], iVar1, arg_8h);\n                if (iVar1 != 0) goto code_r0x00413aa7;\n            }\n        }\n        uVar2 = 0;\n    }\n    else {\ncode_r0x00413aa7:\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 805
    },
    "00414365": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414365(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    \n    uVar2 = fcn.004109b6();\n    iVar3 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        iVar3 = fcn.0040dfaa();\n    }\n    if (iVar3 == 0) {\n        fcn.00407ad1();\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n    if ((arg_8h & 0xc) != 0) {\n        iVar4 = fcn.00410ad9();\n        if ((((~(arg_8h >> 3) & 1) == 0) || (iVar4 == 0)) || (iVar3 == in_ECX)) {\n            (*pcVar1)(*(iVar3 + 0x20), 0x86, 0, 0);\n        }\n        else {\n            *(in_ECX + 0x3c) = *(in_ECX + 0x3c) | 0x200;\n            (*pcVar1)(*(iVar3 + 0x20), 0x86, 1, 0);\n            *(in_ECX + 0x3c) = *(in_ECX + 0x3c) & 0xfffffdff;\n        }\n    }\n    uVar6 = 5;\n    iVar4 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    while (iVar4 = (*_sym.imp.USER32.dll_GetWindow)(iVar4, uVar6),  iVar4 != 0) {\n        iVar5 = fcn.00413b18(*(iVar3 + 0x20), iVar4);\n        if (iVar5 != 0) {\n            (*pcVar1)(iVar4, 0x36d, arg_8h, 0);\n        }\n        uVar6 = 2;\n    }\n    return;\n}\n",
        "token_count": 478
    },
    "004148e7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004148e7(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    \n    fcn.0040d3b7();\n    if ((arg_8h == 0) && ((*(in_ECX + 0x34) & 1) == 0)) {\n        (**(*in_ECX + 0x160))(2);\n    }\n    uVar2 = fcn.004109b6();\n    piVar3 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        piVar3 = fcn.0040dfaa();\n    }\n    if (piVar3 == NULL) {\n        fcn.00407ad1();\n    }\n    if (arg_8h != 0) {\n        arg_ch = in_ECX;\n    }\n    if ((arg_ch == NULL) ||\n       ((piVar3 != arg_ch &&\n        ((piVar4 = fcn.0040dfaa(),  piVar3 != piVar4 ||\n         (iVar5 = (*_sym.imp.USER32.dll_SendMessageW)(arg_ch[8], 0x36d, 0x40, 0),  iVar5 == 0)))))) {\n        bVar1 = false;\n    }\n    else {\n        bVar1 = true;\n    }\n    piVar3[0xf] = piVar3[0xf] & 0xffffffdf;\n    if (bVar1) {\n        piVar3[0xf] = piVar3[0xf] | 0x20;\n    }\n    fcn.00414365(!bVar1 * 4 + 4);\n    piVar3 = in_ECX[0x2c];\n    if (piVar3 == NULL) {\n        iVar5 = (**(*in_ECX + 0x148))();\n        piVar3 = *(iVar5 + 0xb0);\n        if (piVar3 == NULL) {\n            return;\n        }\n    }\n    if ((arg_8h != 0) && (arg_10h == 0)) {\n        (**(*piVar3 + 0x168))(1, piVar3, piVar3);\n    }\n    (**(*piVar3 + 0x16c))(arg_8h);\n    return;\n}\n",
        "token_count": 559
    },
    "00414f37": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414f37(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    int32_t extraout_EDX;\n    uint var_4h;\n    \n    iVar3 = fcn.0040dfaa();\n    iVar5 = iVar3;\n    if (iVar3 == 0) {\n        fcn.00407ad1();\n        iVar5 = extraout_EDX;\n    }\n    if ((in_ECX[0x20] != NULL) &&\n       (iVar4 = (**(*in_ECX[0x20] + 0x7c))(arg_8h, arg_ch, arg_10h),  iVar5 = iVar3,  iVar4 != 0)) {\n        return;\n    }\n    if (arg_ch == 0xffff) {\n        in_ECX[0xf] = in_ECX[0xf] & 0xffffffbf;\n        if (*(iVar5 + 0x68) == 0) {\n            in_ECX[0x2a] = 0xe001;\n        }\n        else {\n            in_ECX[0x2a] = 0xe002;\n        }\n        (*_sym.imp.USER32.dll_SendMessageW)(in_ECX[8], 0x362, in_ECX[0x2a], 0);\n        iVar5 = (**(*in_ECX + 0x16c))();\n        if (iVar5 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar5 + 0x20));\n        }\n        pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n        if (((arg_10h == 0) && ((*(in_ECX + 0x34) & 1) == 0)) &&\n           ((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x79),  -1 < iVar2 &&\n            ((iVar2 = (*pcVar1)(0x12),  -1 < iVar2 && (in_ECX[0x38] == 0)))))) {\n            (**(*in_ECX + 0x160))(2);\n        }\n        goto code_r0x004150a2;\n    }\n    if (((in_ECX[0x37] != 0) && (in_ECX[0x37] = 0,  (arg_ch & 0x2000) != 0)) && ((*(in_ECX + 0x34) & 1) == 0)) {\n        (**(*in_ECX + 0x160))(2);\n        iVar5 = iVar3;\n    }\n    if ((arg_8h == 0) || ((arg_ch & 0x810) != 0)) {\n        in_ECX[0x2a] = 0;\n    }\n    else {\n        if (arg_8h - 0xf000 < 0x1f0) {\n            arg_8h = (arg_8h - 0xf000 >> 4) + 0xef00;\n        }\n        else if (0xfeff < arg_8h) {\n            in_ECX[0x2a] = 0xef1f;\n            goto code_r0x0041509e;\n        }\n        in_ECX[0x2a] = arg_8h;\n    }\ncode_r0x0041509e:\n    *(iVar5 + 0x3c) = *(iVar5 + 0x3c) | 0x40;\ncode_r0x004150a2:\n    if (in_ECX[0x2a] != in_ECX[0x2b]) {\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n        iVar5 = fcn.0040d45d(arg_8h_00);\n        if (iVar5 != 0) {\n            (*_sym.imp.USER32.dll_PostMessageW)(in_ECX[8], 0x36a, 0, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 938
    },
    "00415181": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415181(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n    }\n    iVar1 = fcn.0041512f(arg_8h[1]);\n    if (iVar1 == 0) {\n        arg_8h[7] = 1;\n    }\n    else {\n        iVar1 = *arg_8h;\n        uVar2 = fcn.004109b6();\n        (**(iVar1 + 4))(uVar2 >> 0x1c & 1);\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "004151c4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004151c4(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint32_t uVar1;\n    uint arg_10h;\n    \n    arg_8h_00 = fcn.0041512f(arg_8h);\n    if (arg_8h_00 != 0) {\n        arg_10h = 0;\n        uVar1 = fcn.004109b6();\n        fcn.00414c91(arg_8h_00, ~(uVar1 >> 0x1c) & 1, arg_10h);\n    }\n    return arg_8h_00 != 0;\n}\n",
        "token_count": 151
    },
    "00415202": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415202(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n    }\n    iVar1 = arg_8h[1];\n    if (iVar1 == 0xe701) {\n        uVar4 = 0x14;\n    }\n    else if (iVar1 == 0xe702) {\n        uVar4 = 0x90;\n    }\n    else if (iVar1 == 0xe703) {\n        uVar4 = 0x91;\n    }\n    else {\n        if (iVar1 != 0xe706) {\n            arg_8h[7] = 1;\n            return;\n        }\n        uVar4 = 0x15;\n    }\n    ppcVar2 = *arg_8h;\n    uVar3 = (*_sym.imp.USER32.dll_GetKeyState)(uVar4);\n    (**ppcVar2)(uVar3 & 1);\n    return;\n}\n",
        "token_count": 249
    },
    "004158f7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004158f7(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    int32_t extraout_ECX;\n    uint32_t uVar1;\n    \n    if ((arg_10h != 0) && (arg_ch == 0)) {\n        arg_10h = fcn.00407ad1();\n        arg_ch = extraout_ECX;\n    }\n    if ((~*(arg_8h + 0x18) & 1) == 0) {\n        for (; arg_10h != 0; arg_10h = arg_10h - uVar1) {\n            uVar1 = 0x1fffffff;\n            if (arg_10h < 0x1fffffff) {\n                uVar1 = arg_10h;\n            }\n            fcn.0041582c(arg_ch, uVar1 * 4);\n            arg_ch = arg_ch + uVar1 * 4;\n        }\n    }\n    else {\n        for (; arg_10h != 0; arg_10h = arg_10h - uVar1) {\n            uVar1 = 0x1fffffff;\n            if (arg_10h < 0x1fffffff) {\n                uVar1 = arg_10h;\n            }\n            fcn.00421eff(arg_ch, uVar1 * 4);\n            arg_ch = arg_ch + uVar1 * 4;\n        }\n    }\n    return;\n}\n",
        "token_count": 327
    },
    "00416155": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416155(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    int32_t unaff_EBP;\n    uint var_218h;\n    uint lpWideCharStr;\n    uint var_210h;\n    uint var_4h;\n    \n    fcn.00430f04(0x20c);\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar2 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x218) = iVar2;\n    if (puVar1 != NULL) goto code_r0x00416182;\n    do {\n        iVar2 = fcn.00407ad1();\ncode_r0x00416182:\n    } while (iVar2 == 0);\n    fcn.00401890();\n    iVar2 = puVar1[2];\n    arg_8h = puVar1[1];\n    *(unaff_EBP + -4) = 0;\n    if (((iVar2 == -0x208) && ((*(puVar1 + 0x19) & 1) != 0)) || ((iVar2 == -0x212 && ((*(puVar1 + 0x2d) & 1) != 0)))) {\n        arg_8h = (*_sym.imp.USER32.dll_GetDlgCtrlID)(arg_8h);\n    }\n    if (arg_8h != 0) {\n        iVar2 = fcn.00410bdc(arg_8h, unaff_EBP + -0x210, 0x100);\n        if (iVar2 == 0) {\n            fcn.00401020();\n            goto code_r0x0041626b;\n        }\n        fcn.00410c4f(unaff_EBP + -0x214, unaff_EBP + -0x210, 1, 10);\n    }\n    if (puVar1[2] == -0x208) {\n        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(3, 0, *(unaff_EBP + -0x214), 0xffffffff, puVar1 + 4, 0x50, 0, 0);\n    }\n    else {\n        fcn.00407b1c(puVar1 + 4, 0x50, *(unaff_EBP + -0x214), 0xffffffff);\n    }\n    **(unaff_EBP + -0x218) = 0;\n    (*_sym.imp.USER32.dll_SetWindowPos)(*puVar1, 0, 0, 0, 0, 0, 0x213);\n    fcn.00401020();\ncode_r0x0041626b:\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 654
    },
    "00418223": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.00418223(uint arg_8h)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint16_t *puVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_194h;\n    uint var_120h;\n    uint var_d8h;\n    uint var_64h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x188);\n    *(unaff_EBP + -0x10) = 0;\n    if ((*(unaff_EBP + 8) == 0) && (*(extraout_ECX + 0x74) != 0)) {\n        puVar4 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(extraout_ECX + 0x74));\n        if (puVar4 == NULL) {\n            fcn.00407ad1();\n        }\n        if ((*(puVar4 + 3) & 1) == 0) goto code_r0x0041845a;\n        fcn.004250c3(1, 0x14000c, 0);\n        *(unaff_EBP + -4) = 0;\n        iVar5 = fcn.0042534b();\n        if (iVar5 != 0) {\n            if (*(*(unaff_EBP + -100) + 0xc) == 0) {\n                if (*(extraout_ECX + 0x70) != 0) {\n                    fcn.00421610(*(extraout_ECX + 0x70));\n                }\n                fcn.00421610(*(extraout_ECX + 0x74));\n                *(extraout_ECX + 0x70) = 0;\n                *(extraout_ECX + 0x74) = 0;\n            }\n            else {\n                puVar6 = fcn.0042535e(unaff_EBP + -0x18);\n                pcVar3 = _sym.imp.KERNEL32.dll_lstrcmpW;\n                uVar2 = *puVar6;\n                uVar1 = *puVar4;\n                *(unaff_EBP + -4) = 1;\n                *(unaff_EBP + -0x10) = 1;\n                iVar5 = (*pcVar3)(puVar4 + uVar1, uVar2);\n                if (iVar5 == 0) {\n                    puVar6 = fcn.00425392(unaff_EBP + -0x14);\n                    uVar2 = *puVar6;\n                    uVar1 = puVar4[1];\n                    *(unaff_EBP + -4) = 2;\n                    *(unaff_EBP + -0x10) = 3;\n                    iVar5 = (*pcVar3)(puVar4 + uVar1, uVar2);\n                    if (iVar5 != 0) goto code_r0x00418355;\n                    puVar6 = fcn.004253c7(unaff_EBP + -0x1c);\n                    uVar2 = *puVar6;\n                    uVar1 = puVar4[2];\n                    *(unaff_EBP + -0x10) = 7;\n                    iVar5 = (*pcVar3)(puVar4 + uVar1, uVar2);\n                    *(unaff_EBP + 0xb) = 0;\n                    if (iVar5 != 0) goto code_r0x00418355;\n                }\n                else {\ncode_r0x00418355:\n                    *(unaff_EBP + 0xb) = 1;\n                }\n                if ((*(unaff_EBP + -0x10) & 4) != 0) {\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffb;\n                    fcn.00401020();\n                }\n                if ((*(unaff_EBP + -0x10) & 2) != 0) {\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n                    fcn.00401020();\n                }\n                *(unaff_EBP + -4) = 0;\n                if ((*(unaff_EBP + -0x10) & 1) != 0) {\n                    fcn.00401020();\n                }\n                if (*(unaff_EBP + 0xb) == '\\0') {\n                    iVar5 = *(*(unaff_EBP + -100) + 8);\n                    if (iVar5 != 0) {\n                        fcn.00421610(iVar5);\n                    }\n                    iVar5 = *(*(unaff_EBP + -100) + 0xc);\n                    if (iVar5 != 0) {\n                        fcn.00421610(iVar5);\n                    }\n                }\n                else {\n                    if (*(extraout_ECX + 0x70) != 0) {\n                        fcn.00421610(*(extraout_ECX + 0x70));\n                    }\n                    fcn.00421610(*(extraout_ECX + 0x74));\n                    iVar5 = *(unaff_EBP + -100);\n                    *(extraout_ECX + 0x70) = *(iVar5 + 8);\n                    *(extraout_ECX + 0x74) = *(iVar5 + 0xc);\n                }\n            }\n        }\n        *(unaff_EBP + -0xd8) = vtable.CCommonDialog.0;\n    }\n    else {\n        fcn.004250c3(1, 0x14000c, 0);\n        *(unaff_EBP + -4) = 3;\n        fcn.0042534b();\n        if (*(extraout_ECX + 0x70) != 0) {\n            fcn.00421610(*(extraout_ECX + 0x70));\n        }\n        if (*(extraout_ECX + 0x74) != 0) {\n            fcn.00421610(*(extraout_ECX + 0x74));\n        }\n        iVar5 = *(unaff_EBP + -0x120);\n        *(extraout_ECX + 0x70) = *(iVar5 + 8);\n        *(extraout_ECX + 0x74) = *(iVar5 + 0xc);\n        *(unaff_EBP + -0x194) = vtable.CCommonDialog.0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041aecf();\ncode_r0x0041845a:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1574
    },
    "0041c58c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c58c(uint32_t arg_8h)\n\n{\n    fcn.00401020();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040644a();\n    }\n    return;\n}\n",
        "token_count": 60
    },
    "0041c66c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041c66c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar2;\n    uint uVar3;\n    uint var_4h;\n    \n    fcn.00430ece(8);\n    iVar2 = *(unaff_EBP + 8) * 0x14 + extraout_ECX[0x1e];\n    if ((*(iVar2 + 0xc) & 1) == 0) {\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar1 = *(*(iVar2 + 0x10) + -0xc);\n        }\n        else {\n            iVar1 = fcn.00403500(*(unaff_EBP + 0xc));\n        }\n        if (iVar1 == 0) goto code_r0x0041c70f;\n    }\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.00401a10();\n    }\n    else {\n        fcn.004027e0();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) == 0) {\n        *(iVar2 + 0xc) = *(iVar2 + 0xc) | 1;\n    }\n    else {\n        *(iVar2 + 0xc) = *(iVar2 + 0xc) & 0xfffffffe;\n        if ((*(iVar2 + 8) & 0x4000000) == 0) {\n            uVar3 = *(iVar2 + 0x10);\n        }\n        else {\n            uVar3 = 0;\n        }\n        (**(*extraout_ECX + 0x118))(0x40b, *(iVar2 + 8) | *(unaff_EBP + 8), uVar3);\n    }\ncode_r0x0041c70f:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 492
    },
    "0041c761": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: lpRect\n// WARNING: Variable defined which should be unmapped: dy\n\nvoid __cdecl fcn.0041c761(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint *puVar7;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint lpRect;\n    uint dy;\n    uint var_28h;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x38);\n    if (*(unaff_EBP + 8) != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(extraout_ECX[8], unaff_EBP + -0x30);\n        (*_sym.imp.USER32.dll_OffsetRect)(unaff_EBP + -0x30, -*(unaff_EBP + -0x30), -*(unaff_EBP + -0x2c));\n        (**(*extraout_ECX + 0x148))(unaff_EBP + -0x30, 1);\n        (**(*extraout_ECX + 0x118))(0x407, 0, unaff_EBP + -0x20);\n        iVar5 = extraout_ECX[0x1d];\n        iVar6 = (*(unaff_EBP + -0x28) - *(unaff_EBP + -0x30)) + *(unaff_EBP + -0x18);\n        iVar3 = extraout_ECX[0x1e];\n        *(unaff_EBP + 8) = 0;\n        if (0 < iVar5) {\n            piVar4 = iVar3 + 4;\n            *(unaff_EBP + -0x14) = iVar5;\n            do {\n                if ((piVar4[1] & 0x8000000U) != 0) {\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + 1;\n                }\n                iVar3 = *piVar4;\n                piVar4 = piVar4 + 5;\n                iVar6 = iVar6 + ((-6 - iVar3) - *(unaff_EBP + -0x18));\n                piVar1 = unaff_EBP + -0x14;\n                *piVar1 = *piVar1 + -1;\n            } while (*piVar1 != 0);\n        }\n        *(unaff_EBP + -0x44) = vtable.CArray_int__int_const__.0;\n        *(unaff_EBP + -0x40) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x3c) = 0;\n        *(unaff_EBP + -4) = 0;\n        fcn.0041c329(iVar5, 0xffffffff);\n        *(unaff_EBP + -0x10) = 0;\n        iVar5 = *(unaff_EBP + -0x20);\n        if (0 < extraout_ECX[0x1d]) {\n            puVar2 = extraout_ECX[0x1e] + 8;\n            *(unaff_EBP + -0x14) = puVar2;\n            while( true ) {\n                iVar5 = iVar5 + 6 + puVar2[-1];\n                if (((*puVar2 & 0x8000000) != 0) && (0 < iVar6)) {\n                    iVar3 = iVar6 / *(unaff_EBP + 8);\n                    iVar5 = iVar5 + iVar3;\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + -1;\n                    iVar6 = iVar6 - iVar3;\n                }\n                piVar4 = fcn.0041c0f4(*(unaff_EBP + -0x10));\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 0x14;\n                *piVar4 = iVar5;\n                iVar5 = iVar5 + *(unaff_EBP + -0x18);\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n                if (extraout_ECX[0x1d] <= *(unaff_EBP + -0x10)) break;\n                puVar2 = *(unaff_EBP + -0x14);\n            }\n        }\n        (**(*extraout_ECX + 0x118))(0x404, extraout_ECX[0x1d], *(unaff_EBP + -0x40));\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0041c464();\n    }\n    iVar5 = 0;\n    if ((*(unaff_EBP + 0xc) != 0) && (0 < extraout_ECX[0x1d])) {\n        puVar7 = extraout_ECX[0x1e] + 0x10;\n        do {\n            if ((*(puVar7 + -1) & 1) != 0) {\n                fcn.0041c66c(iVar5, *puVar7, 1);\n            }\n            puVar7 = puVar7 + 5;\n            iVar5 = iVar5 + 1;\n        } while (iVar5 < extraout_ECX[0x1d]);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1467
    },
    "0041cdf5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041cdf5(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    uVar1 = param_1[0x21];\n    param_1[0x29] = 0;\n    if (((uVar1 & 1) == 0) || ((uVar1 & 4) == 0)) {\n        if ((uVar1 & 0xa000) == 0) {\n            uVar2 = 0x50;\n        }\n        else {\n            uVar2 = 0x4a;\n        }\n    }\n    else {\n        uVar2 = 0x46;\n    }\n    var_8h = param_1;\n    piStack8 = param_1;\n    (**(*param_1 + 0x140))(&var_8h, 0, uVar2);\n    return;\n}\n",
        "token_count": 218
    },
    "0041ce77": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041ce77(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint8_t *puVar5;\n    int32_t iVar6;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar3 = 0;\n    iVar6 = 0;\n    var_4h = 0;\n    if (arg_ch < 1) {\ncode_r0x0041cf3c:\n        return var_4h + 1;\n    }\ncode_r0x0041ce97:\n    piVar1 = iVar3 * 0x14 + arg_8h;\n    piVar4 = piVar1 + 2;\n    *piVar4 = *piVar4 & 0xdf;\n    if ((*piVar4 & 8) == 0) {\n        if ((*(piVar1 + 9) & 1) == 0) {\n            iVar2 = *(in_ECX + 0xb0);\n        }\n        else {\n            iVar2 = *piVar1;\n        }\n        iVar6 = iVar6 + iVar2;\n        iVar2 = iVar3;\n        if (arg_10h < iVar6) {\n            for (; (-1 < iVar2 && ((*piVar4 & 0x20) == 0)); piVar4 = piVar4 + -5) {\n                if (((*(piVar4 + 1) & 1) != 0) && ((piVar4[-1] == 0 && ((*piVar4 & 8) == 0)))) goto code_r0x0041cf1f;\n                iVar2 = iVar2 + -1;\n            }\n            iVar2 = iVar3 + -1;\n            if (-1 < iVar2) {\n                puVar5 = iVar2 * 0x14 + 8 + arg_8h;\n                do {\n                    if ((*puVar5 & 0x20) != 0) break;\n                    if (((*puVar5 & 8) == 0) && (((puVar5[1] & 1) == 0 || (*(puVar5 + -4) == 0))))\n                    goto code_r0x0041cf1f;\n                    iVar2 = iVar2 + -1;\n                    puVar5 = puVar5 + -0x14;\n                } while (-1 < iVar2);\n            }\n        }\n    }\n    goto code_r0x0041cf30;\ncode_r0x0041cf1f:\n    puVar5 = iVar2 * 0x14 + 8 + arg_8h;\n    *puVar5 = *puVar5 | 0x20;\n    iVar6 = 0;\n    var_4h = var_4h + 1;\n    iVar3 = iVar2;\ncode_r0x0041cf30:\n    iVar3 = iVar3 + 1;\n    if (arg_ch <= iVar3) goto code_r0x0041cf3c;\n    goto code_r0x0041ce97;\n}\n",
        "token_count": 705
    },
    "0041d3fb": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041d3fb(uint arg_8h, int32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *in_ECX;\n    uint *puVar4;\n    uint *arg_8h_00;\n    uint var_30h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint8_t var_fh;\n    uint var_eh;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    arg_8h_00 = &var_18h;\n    (**(*in_ECX + 0x118))(0x417, arg_8h);\n    *(arg_ch + 2) = *(arg_ch + 2) ^ 4;\n    var_eh._0_1_ = 0;\n    var_eh._1_1_ = 0;\n    *(arg_ch + 10) = 0;\n    *(arg_ch + 0xb) = 0;\n    iVar2 = fcn.0042f196(arg_ch, &var_18h, 0x14);\n    if (iVar2 != 0) {\n        uVar3 = fcn.004109b6();\n        var_20h = uVar3;\n        fcn.004109ea(0x10000000, 0, 0);\n        (**(*in_ECX + 0x118))(0x416, arg_8h, 0);\n        pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n        if (arg_ch[4] < -1) {\n            var_1ch = (*_sym.imp.USER32.dll_SendMessageW)(in_ECX[8], 0x43d, 0, 0);\n            (*pcVar1)(in_ECX[8], 0xb, 0, 0);\n            (*pcVar1)(in_ECX[8], 0x43c, var_1ch + 1, 0);\n            (*pcVar1)(in_ECX[8], 0x43c, var_1ch, 0);\n            (*pcVar1)(in_ECX[8], 0xb, 1, 0);\n            arg_ch[4] = arg_ch[4] + 1000000;\n            uVar3 = var_20h;\n        }\n        (**(*in_ECX + 0x118))(0x415, arg_8h, arg_ch);\n        fcn.004109ea(0, uVar3 & 0x10000000, 0);\n        if ((((*(arg_ch + 9) ^ var_fh) & 1) == 0) && (((*(arg_ch + 9) & 1) == 0 || (*arg_ch == var_18h)))) {\n            iVar2 = (**(*in_ECX + 0x118))(0x41d, arg_8h, &var_30h);\n            if (iVar2 == 0) goto code_r0x0041d550;\n            puVar4 = &var_30h;\n        }\n        else {\n            puVar4 = NULL;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(in_ECX[8], puVar4, 1);\n    }\ncode_r0x0041d550:\n    fcn.0042e09f(arg_8h_00);\n    return;\n}\n",
        "token_count": 788
    },
    "0041d600": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041d600(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint8_t *puVar8;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar7 = *in_ECX;\n    var_ch = 0;\n    var_8h = 0;\n    *arg_8h = 0;\n    arg_8h[1] = 0;\n    uVar2 = (**(iVar7 + 0x118))(0x455, 0, 0);\n    if (0 < arg_10h) {\n        puVar8 = arg_ch + 9;\n        arg_ch = arg_10h;\n        do {\n            arg_10h = *(puVar8 + -9);\n            uVar3 = fcn.004109b6();\n            if (((uVar3 & 0x800) == 0) && (*0x45bc5c != 0x40047)) {\n                arg_10h = (arg_10h * 2) / 3;\n            }\n            if ((puVar8[-1] & 8) == 0) {\n                uVar1 = *puVar8;\n                iVar7 = in_ECX[0x2c];\n                if ((uVar1 & 1) == 0) {\n                    if (((uVar1 & 8) != 0) && ((uVar2 & 1) != 0)) {\n                        iVar7 = iVar7 + *0x45bc60;\n                    }\n                    iVar4 = var_ch + iVar7;\n                    if (var_ch + iVar7 <= *arg_8h) {\n                        iVar4 = *arg_8h;\n                    }\n                    *arg_8h = iVar4;\n                    iVar4 = in_ECX[0x2d];\n                    iVar6 = var_8h;\ncode_r0x0041d6dc:\n                    iVar5 = iVar4 + iVar6;\n                    if (iVar4 + iVar6 <= arg_8h[1]) {\n                        iVar5 = arg_8h[1];\n                    }\n                    arg_8h[1] = iVar5;\n                }\n                else {\n                    if ((puVar8[-1] & 0x20) != 0) {\n                        iVar4 = in_ECX[0x2d] + var_8h;\n                        iVar6 = arg_10h;\n                        goto code_r0x0041d6dc;\n                    }\n                    iVar4 = *(puVar8 + -9) + var_ch;\n                    if (*(puVar8 + -9) + var_ch <= *arg_8h) {\n                        iVar4 = *arg_8h;\n                    }\n                    *arg_8h = iVar4;\n                }\n                if ((uVar1 & 1) != 0) {\n                    iVar7 = *(puVar8 + -9);\n                }\n                var_ch = var_ch + iVar7;\n                if ((puVar8[-1] & 0x20) != 0) {\n                    var_8h = var_8h + in_ECX[0x2d];\n                    var_ch = 0;\n                    if ((uVar1 & 1) != 0) {\n                        var_8h = var_8h + arg_10h;\n                    }\n                }\n            }\n            puVar8 = puVar8 + 0x14;\n            arg_ch = arg_ch + -1;\n        } while (arg_ch != 0);\n    }\n    return arg_8h;\n}\n",
        "token_count": 845
    },
    "0041da09": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041da09(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    \n    puVar1 = in_ECX + 0x84;\n    uVar2 = *puVar1;\n    *puVar1 = uVar2 & 0xfffff0ff;\n    fcn.00427fb8(arg_8h);\n    *puVar1 = uVar2;\n    if (((uVar2 & 4) != 0) && ((*(arg_8h + 0x18) & 1) == 0)) {\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 180
    },
    "0041db0b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041db0b(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar4 = 0;\n    var_8h = 0;\n    var_4h = 0;\n    if (0x40046 < *0x45bc5c) {\n        var_8h = fcn.004109b6();\n        iVar4 = fcn.004109ea(0, 0x8800, 0);\n        if (0x5ffff < *0x45bc5c) {\n            if (param_1 == 0) {\n                uVar1 = 0;\n            }\n            else {\n                uVar1 = *(param_1 + 0x20);\n            }\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar2 != 0) {\n                uVar3 = fcn.0041d01b();\n                var_4h = fcn.0041d02e(uVar3 & 0xfffffffe);\n            }\n        }\n    }\n    uVar1 = fcn.0040d3b7();\n    if (iVar4 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongW)(*(param_1 + 0x20), 0xfffffff0, var_8h);\n    }\n    if ((var_4h & 1) != 0) {\n        fcn.0041d02e(var_4h);\n    }\n    return uVar1;\n}\n",
        "token_count": 372
    },
    "0041dedf": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n\nint32_t * __cdecl fcn.0041dedf(int32_t *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    int32_t *piVar3;\n    int32_t *in_ECX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint32_t arg_ch_00;\n    uint32_t *puVar6;\n    int32_t iVar7;\n    uint32_t lpRect;\n    uint32_t var_38h;\n    uint32_t var_34h;\n    uint32_t var_30h;\n    int32_t lprc;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    uint32_t *var_18h;\n    int32_t var_14h;\n    uint32_t *var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint32_t *var_4h;\n    \n    iVar5 = *in_ECX;\n    var_4h = NULL;\n    *arg_8h = 0;\n    arg_8h[1] = 0;\n    var_ch = (**(iVar5 + 0x118))(0x418, 0, 0);\n    if (var_ch == 0) goto code_r0x0041e1d3;\n    puVar2 = fcn.0040641b(-(var_ch * 0x14 >> 0x20 != 0) | var_ch * 0x14);\n    iVar5 = 0;\n    var_4h = puVar2;\n    if (var_ch < 1) goto code_r0x0041e1d3;\n    do {\n        fcn.0041cda3(iVar5, puVar2);\n        arg_ch_00 = var_ch;\n        iVar5 = iVar5 + 1;\n        puVar2 = puVar2 + 5;\n    } while (iVar5 < var_ch);\n    uVar4 = 0;\n    if (var_ch < 1) goto code_r0x0041e1d3;\n    uVar1 = in_ECX[0x21];\n    if ((uVar1 & 2) == 0) {\n        if ((uVar1 & 4) == 0) {\ncode_r0x0041dfdc:\n            uVar4 = -((arg_ch & 2) != 0) & 0x7fff;\n        }\n        else if ((arg_ch & 4) == 0) {\n            if ((arg_ch & 8) == 0) {\n                if ((arg_ch & 0x10) == 0) {\n                    if (arg_10h == -1) {\n                        if ((uVar1 & 1) == 0) goto code_r0x0041dfdc;\n                        goto code_r0x0041df77;\n                    }\n                    (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n                    (**(*in_ECX + 0x148))(&lprc, arg_ch & 2);\n                    lpRect = arg_ch & 0x20;\n                    if (lpRect == 0) {\n                        var_28h = var_24h - lprc;\n                    }\n                    else {\n                        var_28h = var_20h - var_28h;\n                    }\n                    uVar4 = var_28h + arg_10h;\n                }\n                else {\n                    lpRect = 0;\n                }\n            }\n            else {\n                uVar4 = 0x7fff;\n            }\n        }\n        else {\ncode_r0x0041df77:\n            uVar4 = in_ECX[0x1c];\n        }\n        fcn.0041d732(var_4h, arg_ch_00, uVar4, lpRect);\n    }\n    piVar3 = fcn.0041d600(&var_24h, var_4h, arg_ch_00);\n    iVar5 = piVar3[1];\n    *arg_8h = *piVar3;\n    arg_8h[1] = iVar5;\n    if ((arg_ch & 0x40) != 0) {\n        var_20h = in_ECX[0x29];\n        var_14h = 0;\n        arg_10h = 0;\n        in_ECX[0x29] = 0;\n        if (0 < arg_ch_00) {\n            var_18h = var_4h + 1;\n            puVar2 = var_18h;\n            uVar4 = arg_ch_00;\n            do {\n                if (((*(puVar2 + 5) & 1) != 0) && (*puVar2 != 0)) {\n                    arg_10h = arg_10h + 1;\n                }\n                puVar2 = puVar2 + 5;\n                uVar4 = uVar4 - 1;\n            } while (uVar4 != 0);\n            if (0 < arg_10h) {\n                var_14h = fcn.0040641b(-(arg_10h * 0x18 >> 0x20 != 0) | arg_10h * 0x18);\n                var_10h = var_14h + 8;\n                var_1ch = arg_10h;\n                arg_10h = 0;\n                var_8h = 0;\n                puVar2 = var_10h;\n                do {\n                    arg_ch_00 = var_ch;\n                    if (var_1ch <= arg_10h) break;\n                    puVar6 = puVar2;\n                    if (((*(var_18h + 5) & 1) != 0) && (*var_18h != 0)) {\n                        puVar2[-2] = var_8h;\n                        puVar2[-1] = *var_18h;\n                        (**(*in_ECX + 0x184))(var_8h, &lpRect);\n                        fcn.00409b04(&lpRect);\n                        arg_10h = arg_10h + 1;\n                        puVar6 = var_10h + 6;\n                        *puVar2 = lpRect;\n                        puVar2[1] = var_38h;\n                        puVar2[2] = var_34h;\n                        puVar2[3] = var_30h;\n                        var_10h = puVar6;\n                    }\n                    var_8h = var_8h + 1;\n                    var_18h = var_18h + 5;\n                    arg_ch_00 = var_ch;\n                    puVar2 = puVar6;\n                } while (var_8h < var_ch);\n            }\n        }\n        if (((in_ECX[0x21] & 1U) != 0) && ((in_ECX[0x21] & 4U) != 0)) {\n            in_ECX[0x1c] = *arg_8h;\n        }\n        var_8h = 0;\n        if (0 < arg_ch_00) {\n            var_10h = var_4h;\n            do {\n                fcn.0041d3fb(var_8h, var_10h);\n                var_8h = var_8h + 1;\n                var_10h = var_10h + 5;\n            } while (var_8h < arg_ch_00);\n        }\n        if (0 < arg_10h) {\n            puVar2 = var_14h + 8;\n            do {\n                var_10h = puVar2;\n                var_1ch = fcn.00410902(puVar2[-1]);\n                if (var_1ch != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(*(var_1ch + 0x20), &lpRect);\n                    iVar7 = var_38h - puVar2[1];\n                    iVar5 = lpRect - *puVar2;\n                    (**(*in_ECX + 0x184))(var_10h[-2], &lpRect);\n                    fcn.00410b5a(0, iVar5 + lpRect, iVar7 + var_38h, 0, 0, 0x15);\n                    puVar2 = var_10h;\n                }\n                puVar2 = puVar2 + 6;\n                arg_10h = arg_10h - 1;\n            } while (arg_10h != 0);\n            var_10h = puVar2;\n            fcn.0040644a(var_14h);\n        }\n        in_ECX[0x29] = var_20h;\n    }\n    fcn.0040644a(var_4h);\ncode_r0x0041e1d3:\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&lpRect);\n    (**(*in_ECX + 0x148))(&lpRect, arg_ch & 2);\n    arg_8h[1] = arg_8h[1] + (var_38h - var_30h);\n    *arg_8h = *arg_8h + (lpRect - var_34h);\n    fcn.00427d8e(&var_24h, arg_ch & 1, arg_ch & 2);\n    iVar5 = *arg_8h;\n    if (*arg_8h <= var_24h) {\n        iVar5 = var_24h;\n    }\n    *arg_8h = iVar5;\n    iVar5 = arg_8h[1];\n    if (arg_8h[1] <= var_20h) {\n        iVar5 = var_20h;\n    }\n    arg_8h[1] = iVar5;\n    return arg_8h;\n}\n",
        "token_count": 2194
    },
    "0041e3ce": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e3ce(uint32_t arg_8h)\n\n{\n    fcn.0041fef8();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040644a();\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "00420024": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420024(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = *(*arg_8h + 0x74);\n    if (*(iVar1 + 0x1e) <= *(iVar1 + 0x1c) && *(iVar1 + 0x1c) != *(iVar1 + 0x1e)) {\n        *(iVar1 + 0x1e) = *(iVar1 + 0x1c);\n    }\n    iVar1 = fcn.004213cc();\n    iVar1 = *(iVar1 + 4);\n    if (((arg_8h[2] == 0) && (arg_8h[3] == 0)) && ((arg_8h[1] == 0 || ((*(arg_8h + 0xf) & 2) != 0)))) {\n        *(*(*arg_8h + 0x74) + 0x18) = *(*(*arg_8h + 0x74) + 0x1c);\n        *(*(*arg_8h + 0x74) + 0x1a) = *(*(*arg_8h + 0x74) + 0x1e);\n        iVar2 = fcn.00418462(*arg_8h);\n        if (iVar2 != 1) {\n            return 0;\n        }\n    }\n    else {\n        if (*(*(*arg_8h + 0x74) + 0x10) == 0) {\n            iVar2 = fcn.0041856f(*(*arg_8h + 0x74));\n            if ((iVar2 == 0) &&\n               (((arg_8h[1] == 0 || ((*(arg_8h + 0xf) & 1) != 0)) && (iVar2 = fcn.00418462(*arg_8h),  iVar2 != 1)))) {\n                return 0;\n            }\n            if ((*(*(*arg_8h + 0x74) + 0x10) == 0) && (iVar2 = fcn.004251d7(),  iVar2 == 0)) {\n                return 0;\n            }\n        }\n        *(*(*arg_8h + 0x74) + 0x18) = *(*(*arg_8h + 0x74) + 0x1c);\n        *(*(*arg_8h + 0x74) + 0x1a) = *(*(*arg_8h + 0x74) + 0x1e);\n    }\n    if (*(*(*arg_8h + 0x74) + 0x10) == 0) {\n        return 0;\n    }\n    arg_8h[6] = *(iVar1 + 0x94);\n    iVar1 = fcn.00402820(0xf044);\n    if (iVar1 == 0) {\n        fcn.00407ad1();\n    }\n    return 1;\n}\n",
        "token_count": 671
    },
    "00421a82": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00421a82(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        iVar1 = 0;\n    }\n    else {\n        if ((*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0041beec(4, *(in_ECX + 0x14));\n        }\n        uVar3 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.00408f79(arg_8h, arg_ch, *(in_ECX + 0x28), uVar3);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x20);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x24) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if ((uVar3 != 0) && (var_8h == iVar1)) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    if ((*(in_ECX + 0xc) != 0) || (var_4h = *(in_ECX + 0x20),  *(in_ECX + 0x20) < uVar3)) {\n                        var_4h = uVar3;\n                    }\n                    var_8h = *(in_ECX + 0x30);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x24) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x2c) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                    iVar1 = *(in_ECX + 0x30);\n                }\n                uVar4 = *(in_ECX + 0x2c) - iVar1;\n                *(in_ECX + 0x28) = iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.00408f79(arg_8h, uVar3, iVar1, uVar4);\n                *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 939
    },
    "00421bb3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00421bb3(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *(param_1 + 0x28);\n    if ((*(param_1 + 0x18) & 1) == 0) {\n        piVar1 = param_1 + 0x30;\n        iVar2 = *piVar1;\n        if (*(param_1 + 8) == 0) {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x38))(iVar2, iVar3 - iVar2);\n            }\n        }\n        else {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x50))(2, iVar3 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x24) + 0x50))(1, *(param_1 + 0x20), piVar1, param_1 + 0x2c);\n        }\n        iVar3 = *piVar1;\n    }\n    else {\n        if (*(param_1 + 0x2c) != iVar3) {\n            iVar3 = iVar3 - *(param_1 + 0x2c);\n            (**(**(param_1 + 0x24) + 0x28))(iVar3, iVar3 >> 0x1f, 1);\n        }\n        iVar3 = *(param_1 + 0x2c);\n    }\n    *(param_1 + 0x28) = iVar3;\n    return;\n}\n",
        "token_count": 376
    },
    "00421c2b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421c2b(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_10h;\n    uint32_t uVar2;\n    uint32_t arg_8h_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_8h_01;\n    int32_t in_stack_ffffffe4;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar4 = in_ECX;\n    if ((*(in_ECX + 0x18) & 1) != 0) goto code_r0x00421c47;\n    arg_8h_01 = 4;\n    in_stack_ffffffe4 = *(in_ECX + 0x14);\n    do {\n        fcn.0041beec(arg_8h_01, in_stack_ffffffe4);\n        iVar4 = in_ECX;\ncode_r0x00421c47:\n        in_ECX = in_stack_ffffffe4;\n        arg_10h = *(iVar4 + 0x28);\n        piVar1 = iVar4 + 0x2c;\n        var_4h = *piVar1 - arg_10h;\n        uVar2 = arg_8h + var_4h;\n        if (*(iVar4 + 8) == 0) {\n            arg_8h_00 = *(iVar4 + 0x30);\n            if (arg_8h_00 < arg_10h) {\n                if (0 < var_4h) {\n                    fcn.00421a61(arg_8h_00, *piVar1 - arg_8h_00, arg_10h, var_4h);\n                    arg_8h_00 = *(iVar4 + 0x30);\n                    *(iVar4 + 0x28) = arg_8h_00;\n                    *piVar1 = arg_8h_00 + var_4h;\n                }\n                if (*(iVar4 + 0xc) == 0) {\n                    arg_8h = *(iVar4 + 0x20);\n                }\n                arg_8h = arg_8h - var_4h;\n                iVar5 = var_4h + arg_8h_00;\n                do {\n                    iVar3 = (**(**(iVar4 + 0x24) + 0x34))(iVar5, arg_8h);\n                    var_4h = var_4h + iVar3;\n                    arg_8h = arg_8h - iVar3;\n                    iVar5 = iVar5 + iVar3;\n                    if ((iVar3 == 0) || (arg_8h == 0)) break;\n                } while (var_4h < uVar2);\n                *(iVar4 + 0x28) = *(iVar4 + 0x30);\n                *piVar1 = *(iVar4 + 0x30) + var_4h;\n            }\n        }\n        else {\n            if (var_4h != 0) {\n                (**(**(iVar4 + 0x24) + 0x28))(-var_4h, -var_4h >> 0x1f, 1);\n            }\n            (**(**(iVar4 + 0x24) + 0x50))(0, *(iVar4 + 0x20), iVar4 + 0x30, piVar1);\n            *(iVar4 + 0x28) = *(iVar4 + 0x30);\n        }\n        if (uVar2 <= *piVar1 - *(iVar4 + 0x28)) {\n            return;\n        }\n        arg_8h_01 = 3;\n        in_stack_ffffffe4 = in_ECX;\n    } while( true );\n}\n",
        "token_count": 845
    },
    "00421d1a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421d1a(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0041beec(2, *(in_ECX + 0x14));\n    }\n    uVar1 = *(in_ECX + 0x28) + 2;\n    if (*(in_ECX + 0x2c) <= uVar1 && uVar1 != *(in_ECX + 0x2c)) {\n        fcn.00421bb3();\n    }\n    **(in_ECX + 0x28) = arg_8h;\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 2;\n    return;\n}\n",
        "token_count": 194
    },
    "00421d59": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421d59(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0041beec(2, *(in_ECX + 0x14));\n    }\n    uVar1 = *(in_ECX + 0x28) + 4;\n    if (*(in_ECX + 0x2c) <= uVar1 && uVar1 != *(in_ECX + 0x2c)) {\n        fcn.00421bb3();\n    }\n    **(in_ECX + 0x28) = arg_8h;\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 4;\n    return;\n}\n",
        "token_count": 193
    },
    "00421d97": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421d97(ushort *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0041beec(4, *(in_ECX + 0x14));\n    }\n    if (*(in_ECX + 0x2c) < *(in_ECX + 0x28) + 2U) {\n        fcn.00421c2b((*(in_ECX + 0x28) - *(in_ECX + 0x2c)) + 2);\n    }\n    *arg_8h = **(in_ECX + 0x28);\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 2;\n    return;\n}\n",
        "token_count": 190
    },
    "00421ddf": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421ddf(uint *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0041beec(4, *(in_ECX + 0x14));\n    }\n    if (*(in_ECX + 0x2c) < *(in_ECX + 0x28) + 4U) {\n        fcn.00421c2b((*(in_ECX + 0x28) - *(in_ECX + 0x2c)) + 4);\n    }\n    *arg_8h = **(in_ECX + 0x28);\n    *(in_ECX + 0x28) = *(in_ECX + 0x28) + 4;\n    return;\n}\n",
        "token_count": 188
    },
    "00421eff": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421eff(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t arg_ch_00;\n    int32_t in_ECX;\n    uint32_t arg_14h;\n    int32_t iVar1;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        if ((~*(in_ECX + 0x18) & 1) == 0) {\n            fcn.0041beec(2, *(in_ECX + 0x14));\n        }\n        arg_ch_00 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        arg_14h = arg_ch;\n        if (arg_ch_00 <= arg_ch) {\n            arg_14h = arg_ch_00;\n        }\n        fcn.00408f79(*(in_ECX + 0x28), arg_ch_00, arg_8h, arg_14h);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_14h;\n        arg_ch = arg_ch - arg_14h;\n        if (arg_ch != 0) {\n            fcn.00421bb3();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x20);\n            (**(**(in_ECX + 0x24) + 0x38))(arg_8h + arg_14h, iVar1);\n            arg_ch = arg_ch - iVar1;\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x24) + 0x50))(1, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n            }\n            if (arg_ch < *(in_ECX + 0x20)) goto code_r0x00421fa6;\n            do {\n                fcn.00407ad1();\ncode_r0x00421fa6:\n            } while (*(in_ECX + 0x28) != *(in_ECX + 0x30));\n            fcn.00408f79(*(in_ECX + 0x28), arg_ch, arg_8h + arg_14h + iVar1, arg_ch);\n            *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_ch;\n        }\n    }\n    return;\n}\n",
        "token_count": 572
    },
    "00422371": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00422371(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    uint8_t *puVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint hMem;\n    uint lpCriticalSection;\n    \n    iVar1 = param_1 + 0x1c;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(iVar1);\n    iVar7 = *(param_1 + 4);\n    iVar8 = *(param_1 + 8);\n    if ((iVar7 <= iVar8) || ((*(*(param_1 + 0x10) + iVar8 * 8) & 1) != 0)) {\n        iVar8 = 1;\n        if (1 < iVar7) {\n            puVar3 = *(param_1 + 0x10);\n            do {\n                puVar3 = puVar3 + 8;\n                if ((*puVar3 & 1) == 0) break;\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < iVar7);\n            if (iVar8 < iVar7) goto code_r0x0042245f;\n        }\n        iVar7 = iVar7 + 0x20;\n        if (*(param_1 + 0x10) == 0) {\n            uVar4 = fcn.00406cb3(iVar7, 8);\n            iVar5 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(2, uVar4);\n        }\n        else {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar4);\n            uVar9 = 0x2002;\n            uVar6 = fcn.00406cb3(iVar7, 8);\n            iVar5 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)(uVar4, uVar6, uVar9);\n        }\n        if (iVar5 == 0) {\n            param_1 = *(param_1 + 0x10);\n            if (param_1 != 0) {\n                uVar4 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1);\n                (*_sym.imp.KERNEL32.dll_GlobalLock)(uVar4);\n            }\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(iVar1);\n            iVar5 = fcn.00407a99();\n        }\n        iVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar5);\n        fcn.00430820(iVar5 + *(param_1 + 4) * 8, 0, (iVar7 - *(param_1 + 4)) * 8);\n        *(param_1 + 4) = iVar7;\n        *(param_1 + 0x10) = iVar5;\n    }\ncode_r0x0042245f:\n    if (*(param_1 + 0xc) <= iVar8) {\n        *(param_1 + 0xc) = iVar8 + 1;\n    }\n    puVar2 = *(param_1 + 0x10) + iVar8 * 8;\n    *puVar2 = *puVar2 | 1;\n    *(param_1 + 8) = iVar8 + 1;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(iVar1);\n    return iVar8;\n}\n",
        "token_count": 776
    },
    "0042288f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042288f(uint32_t arg_8h)\n\n{\n    fcn.00422836();\n    if ((arg_8h & 1) != 0) {\n        fcn.0040644a();\n    }\n    return;\n}\n",
        "token_count": 59
    },
    "004247e1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004247e1(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if ((arg_8h & 2) == 0) {\n        fcn.00401020();\n        if ((arg_8h & 1) != 0) {\n            fcn.0040644a();\n        }\n    }\n    else {\n        fcn.0043101d(in_ECX, 4, *(in_ECX + -4), fcn.00401910);\n        if ((arg_8h & 1) != 0) {\n            fcn.0040644a(in_ECX + -4);\n        }\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "00427fb8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427fb8(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_DefWindowProcW)(*(in_ECX + 0x20), 0x46, 0, arg_8h);\n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x20), &lpRect);\n        var_4h = *(arg_8h + 0x10);\n        var_ch = var_ch - lpRect;\n        var_8h = var_8h - var_10h;\n        iVar1 = *(arg_8h + 0x14);\n        if ((var_4h != var_ch) && ((*(in_ECX + 0x84) & 0x400) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_4h - *0x45f780, 0, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_ch - *0x45f780, 0, var_ch, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n        }\n        pcVar2 = _sym.imp.USER32.dll_SetRect;\n        if ((iVar1 != var_8h) && ((*(in_ECX + 0x84) & 0x800) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, 0, iVar1 - *0x45f784, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n            (*pcVar2)(&lpRect, 0, var_8h - *0x45f784, var_4h, var_8h);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), &lpRect, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 578
    },
    "00428332": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00428332(uint noname_0, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    bool bVar5;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar1 = (**(*in_ECX + 0x16c))(arg_ch);\n    if (((uVar1 & 0x10000000) != 0) && ((uVar1 & 0xf000) != 0)) {\n        (*_sym.imp.USER32.dll_CopyRect)(&var_1ch, arg_ch + 1);\n        iVar4 = var_14h - var_1ch;\n        iVar3 = var_10h - var_18h;\n        bVar5 = arg_ch[7] != 0;\n        if (((var_4h[0x21] & 4U) == 0) || ((var_4h[0x21] & 1U) == 0)) {\n            if ((uVar1 & 0xa000) == 0) {\n                uVar2 = bVar5 | 0x10;\n            }\n            else {\n                uVar2 = bVar5 | 10;\n            }\n        }\n        else {\n            uVar2 = bVar5 | 6;\n        }\n        (**(*var_4h + 0x140))(&var_ch, 0xffffffff, uVar2);\n        if (iVar4 <= var_ch) {\n            var_ch = iVar4;\n        }\n        if (iVar3 <= var_8h) {\n            var_8h = iVar3;\n        }\n        if ((uVar1 & 0xa000) == 0) {\n            if ((uVar1 & 0x5000) != 0) {\n                arg_ch[5] = arg_ch[5] + var_ch;\n                iVar3 = arg_ch[6];\n                if (arg_ch[6] <= var_8h) {\n                    iVar3 = var_8h;\n                }\n                arg_ch[6] = iVar3;\n                if ((uVar1 & 0x1000) == 0) {\n                    if ((uVar1 & 0x4000) != 0) {\n                        var_1ch = var_14h - var_ch;\n                        arg_ch[3] = arg_ch[3] - var_ch;\n                    }\n                }\n                else {\n                    arg_ch[1] = arg_ch[1] + var_ch;\n                }\n            }\n        }\n        else {\n            arg_ch[6] = arg_ch[6] + var_8h;\n            iVar3 = arg_ch[5];\n            if (arg_ch[5] <= var_ch) {\n                iVar3 = var_ch;\n            }\n            arg_ch[5] = iVar3;\n            if ((uVar1 & 0x2000) == 0) {\n                if ((uVar1 & 0x8000) != 0) {\n                    var_18h = var_10h - var_8h;\n                    arg_ch[4] = arg_ch[4] - var_8h;\n                }\n            }\n            else {\n                arg_ch[2] = arg_ch[2] + var_8h;\n            }\n        }\n        var_14h = var_1ch + var_ch;\n        var_10h = var_18h + var_8h;\n        if (*arg_ch != 0) {\n            fcn.0040b33d(arg_ch, var_4h[8], &var_1ch);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 866
    },
    "00428c8c": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00428c8c(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint32_t uVar5;\n    \n    uVar1 = fcn.004109b6();\n    uVar2 = in_ECX[0x20];\n    uVar5 = 0;\n    if (((uVar2 & 1) == 0) || ((uVar1 & 0x10000000) == 0)) {\n        if (((uVar2 & 2) != 0) && ((uVar1 & 0x10000000) == 0)) {\n            uVar5 = 0x40;\n        }\n    }\n    else {\n        uVar5 = 0x80;\n    }\n    in_ECX[0x20] = uVar2 & 0xfffffffc;\n    if (uVar5 != 0) {\n        fcn.00410b5a(0, 0, 0, 0, 0, uVar5 | 0x17);\n    }\n    uVar2 = fcn.004109b6();\n    if ((uVar2 & 0x10000000) != 0) {\n        if ((in_ECX[0x24] != 0) && (uVar2 = fcn.004109b6(),  (uVar2 & 0x10000000) == 0)) {\n            return 0;\n        }\n        piVar3 = fcn.0040877c();\n        if ((piVar3 == NULL) || (iVar4 = (**(*piVar3 + 0x128))(),  iVar4 == 0)) {\n            piVar3 = fcn.0040df6b();\n        }\n        if (piVar3 != NULL) {\n            (**(*in_ECX + 0x144))(piVar3, arg_8h);\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 456
    },
    "0042a08e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __cdecl\nfcn.0042a08e(int32_t *lpSize, int32_t *arg_ch, int16_t *arg_10h, uint32_t *arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            uint32_t *arg_20h, uint arg_24h, int16_t *arg_28h, int32_t *arg_2ch, int32_t *arg_30h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint32_t uVar5;\n    int16_t *piVar6;\n    int32_t *piVar7;\n    uint var_ach;\n    int32_t var_8ch;\n    uint var_70h;\n    int32_t var_5ch;\n    int32_t var_50h;\n    uint var_3eh;\n    int32_t var_34h;\n    int32_t lpPoint;\n    uint Y;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    int32_t lpBuffer;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t cbString;\n    int16_t *lpString;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.GDI32.dll_GetTextMetricsW;\n    (*_sym.imp.GDI32.dll_GetTextMetricsW)(*(in_ECX + 8), &var_70h);\n    (*pcVar2)(*(in_ECX + 4), &var_ach);\n    (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)(*(in_ECX + 8), 0x44cc40, 1, lpSize);\n    var_20h = (*_sym.imp.GDI32.dll_GetTextAlign)(*(in_ECX + 8));\n    var_24h = var_20h & 1;\n    if (var_24h != 0) {\n        (*_sym.imp.GDI32.dll_GetCurrentPositionEx)(*(in_ECX + 4), &lpPoint);\n        *arg_ch = lpPoint;\n    }\n    iVar3 = *arg_ch;\n    var_4h = 0;\n    var_8h = 0;\n    lpString = arg_10h;\n    var_18h = iVar3;\n    if (arg_18h != 0) {\n        if (arg_1ch == 1) {\n            var_8h = *arg_20h;\n        }\n        else {\n            var_8h = (*_sym.imp.USER32.dll_GetTabbedTextExtentA)(*(in_ECX + 8), 0x44cc3c, 1, 0, 0);\n            var_8h = var_8h & 0xffff;\n        }\n    }\n    var_14h = 0;\n    piVar6 = arg_10h;\n    piVar7 = arg_2ch;\n    arg_10h = iVar3;\n    if (*arg_14h != 0) {\n        do {\n            iVar1 = *piVar6;\n            cbString = iVar1 == var_3eh;\n            if ((cbString == 0) && ((arg_18h == 0 || (iVar1 != 9)))) {\n                (*_sym.imp.GDI32.dll_GetCharWidthW)(*(in_ECX + 4), iVar1, iVar1, &lpBuffer);\n                iVar3 = (*_sym.imp.GDI32.dll_GetCharWidthW)(*(in_ECX + 8), *piVar6, *piVar6, piVar7);\n                if (iVar3 == 0) {\n                    *piVar7 = var_5ch;\n                }\n                *piVar7 = *piVar7 - var_50h;\n                iVar3 = *piVar7;\n                lpBuffer = lpBuffer - var_8ch;\n                if (piVar7 != arg_2ch) {\n                    iVar4 = (iVar3 - lpBuffer) / 2;\n                    piVar7[-1] = piVar7[-1] + iVar4;\n                    *piVar7 = iVar3 - iVar4;\n                }\n                *arg_28h = *piVar6;\n                piVar7 = piVar7 + 1;\n                arg_10h = arg_10h + iVar3;\n                arg_28h = arg_28h + 1;\n            }\n            else {\n                (*_sym.imp.GDI32.dll_GetTextExtentPoint32W)\n                          (*(in_ECX + 8), lpString, (piVar6 - lpString >> 1) + cbString, &var_34h);\n                iVar3 = (var_34h - var_50h) + var_18h;\n                if (cbString == 0) {\n                    iVar3 = fcn.00429ba8(iVar3, arg_1ch, arg_20h, arg_24h, var_8h);\n                }\n                if (piVar7 == arg_2ch) {\n                    var_4h = var_4h + (iVar3 - arg_10h);\n                }\n                else {\n                    piVar7[-1] = piVar7[-1] + (iVar3 - arg_10h);\n                }\n                lpString = piVar6 + 1;\n                arg_10h = iVar3;\n                var_18h = iVar3;\n            }\n            piVar6 = piVar6 + 1;\n            var_14h = var_14h + 1;\n            iVar3 = arg_10h;\n        } while (var_14h < *arg_14h);\n    }\n    *lpSize = iVar3 - *arg_ch;\n    *arg_30h = 0;\n    uVar5 = var_20h & 6;\n    iVar3 = var_4h;\n    if (uVar5 != 0) {\n        if (uVar5 != 6) {\n            if (uVar5 == 2) {\n                *arg_30h = var_4h;\n            }\n            goto code_r0x0042a288;\n        }\n        iVar3 = var_4h / 2;\n    }\n    *arg_ch = *arg_ch + iVar3;\ncode_r0x0042a288:\n    if (var_24h != 0) {\n        (*_sym.imp.GDI32.dll_MoveToEx)(*(in_ECX + 4), *arg_ch, Y, 0);\n    }\n    *arg_14h = piVar7 - arg_2ch >> 2;\n    return lpSize;\n}\n",
        "token_count": 1483
    },
    "0042b640": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.0042b640(void)\n\n{\n    int32_t *piVar1;\n    int64_t iVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t *extraout_ECX;\n    uint uVar8;\n    int32_t *arg_8h;\n    int32_t unaff_EBP;\n    int16_t *arg_8h_00;\n    uint32_t uVar9;\n    code *pcVar10;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    int32_t *piVar11;\n    \n    piVar11 = 0x18;\n    fcn.00430e9b(0x18);\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    if (extraout_ECX[0x1e] != 1) {\ncode_r0x0042bb7f:\n        fcn.00430f73();\n        return;\n    }\n    pcVar10 = NULL;\n    arg_8h = extraout_ECX;\n    if (*(extraout_ECX[0x1d] + 0x30) == 0) goto code_r0x0042b686;\n    iVar4 = (**(*extraout_ECX[0x20] + 0x44))(extraout_ECX[0x20], *(extraout_ECX[0x1d] + 0x30));\n    if (-1 < iVar4) goto code_r0x0042b686;\ncode_r0x0042b681:\n    fcn.00407ad1();\ncode_r0x0042b686:\n    if (*(arg_8h[0x1d] + 0x3c) != pcVar10) {\n        fcn.00402680(*(arg_8h[0x1d] + 0x3c));\n        piVar1 = arg_8h[0x20];\n        iVar4 = *piVar1;\n        *(unaff_EBP + -4) = pcVar10;\n        iVar4 = (**(iVar4 + 0x58))(piVar1, *(unaff_EBP + -0x20));\n        if (pcVar10 <= iVar4 == pcVar10) goto code_r0x0042b681;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00401020();\n    }\n    if (*(arg_8h[0x1d] + 0xc) != pcVar10) {\n        arg_8h_00 = *(arg_8h[0x1d] + 0xc);\n        *(unaff_EBP + -0x14) = pcVar10;\n        if (*arg_8h_00 != pcVar10) {\n            do {\n                iVar4 = fcn.00430fa5(arg_8h_00);\n                iVar5 = fcn.00430fa5(arg_8h_00 + iVar4 + 1);\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 1;\n                arg_8h_00 = arg_8h_00 + iVar4 + 1 + iVar5 + 1;\n            } while (*arg_8h_00 != pcVar10);\n            if (pcVar10 < *(unaff_EBP + -0x14)) {\n                iVar2 = ZEXT48(*(unaff_EBP + -0x14)) * 8;\n                pcVar10 = fcn.0040641b(-(iVar2 >> 0x20 != 0) | iVar2);\n                if (pcVar10 != NULL) goto code_r0x0042b72b;\n                do {\n                    fcn.00407a99();\ncode_r0x0042b72b:\n                    iVar4 = arg_8h[0x1d];\n                    *(unaff_EBP + -0x20) = 0;\n                    iVar4 = *(iVar4 + 0xc);\n                    if (*(unaff_EBP + -0x14) == 0) goto code_r0x0042b824;\n                    while( true ) {\n                        fcn.00401890();\n                        *(unaff_EBP + -4) = 1;\n                        iVar5 = fcn.00430fa5(iVar4);\n                        arg_8h = iVar5 + 1;\n                        iVar5 = fcn.0040641b(-(ZEXT48(arg_8h) * 2 >> 0x20 != 0) | ZEXT48(arg_8h) * 2);\n                        *(unaff_EBP + -0x18) = iVar5;\n                        if (iVar5 == 0) break;\n                        fcn.004029f0(iVar4);\n                        iVar6 = *(*(unaff_EBP + -0x1c) + -0xc);\n                        iVar5 = iVar6 * 2 + 2;\n                        fcn.0042e44a(*(unaff_EBP + -0x18), iVar6 * 2 + 2, *(unaff_EBP + -0x1c), iVar5);\n                        arg_8h = iVar4 + arg_8h * 2;\n                        *(pcVar10 + *(unaff_EBP + -0x20) * 8) = *(unaff_EBP + -0x18);\n                        iVar6 = fcn.00430fa5(arg_8h);\n                        iVar2 = (iVar6 + 1U) * 2;\n                        iVar7 = fcn.0040641b(-(iVar2 >> 0x20 != 0) | iVar2);\n                        *(unaff_EBP + -0x18) = iVar7;\n                        if (iVar7 == 0) break;\n                        piVar11 = arg_8h;\n                        fcn.004029f0(iVar5, iVar4, arg_8h);\n                        iVar4 = *(*(unaff_EBP + -0x1c) + -0xc);\n                        fcn.0042e44a(*(unaff_EBP + -0x18), iVar4 * 2 + 2, *(unaff_EBP + -0x1c), iVar4 * 2 + 2);\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        *(pcVar10 + *(unaff_EBP + -0x20) * 8 + 4) = *(unaff_EBP + -0x18);\n                        *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 1;\n                        iVar4 = arg_8h + (iVar6 + 1U) * 2;\n                        fcn.00401020();\n                        if (*(unaff_EBP + -0x14) <= *(unaff_EBP + -0x20)) {\n                            arg_8h = *(unaff_EBP + -0x24);\n                            goto code_r0x0042b824;\n                        }\n                    }\n                } while( true );\n            }\n        }\n    }\n    goto code_r0x0042b89a;\ncode_r0x0042b824:\n    iVar4 = (**(*arg_8h[0x20] + 0x10))(arg_8h[0x20], *(unaff_EBP + -0x14), pcVar10);\n    uVar9 = 0;\n    if (iVar4 < 0) goto code_r0x0042b681;\n    if (*(unaff_EBP + -0x14) != 0) {\n        do {\n            fcn.0040644a(*(pcVar10 + uVar9 * 8));\n            fcn.0040644a(*(pcVar10 + uVar9 * 8 + 4));\n            uVar9 = uVar9 + 1;\n        } while (uVar9 < *(unaff_EBP + -0x14));\n    }\n    fcn.0040644a(pcVar10);\n    uVar8 = 1;\n    if (1 < *(arg_8h[0x1d] + 0x18)) {\n        uVar8 = *(arg_8h[0x1d] + 0x18);\n    }\n    iVar4 = (**(*arg_8h[0x20] + 0x14))(arg_8h[0x20], uVar8);\n    if (iVar4 < 0) goto code_r0x0042b681;\n    pcVar10 = NULL;\ncode_r0x0042b89a:\n    if ((*(arg_8h[0x1d] + 0x1c) == pcVar10) && (*(arg_8h[0x1d] + 0x2c) == pcVar10)) goto code_r0x0042ba22;\n    fcn.00401890();\n    iVar4 = arg_8h[0x1d];\n    *(unaff_EBP + -4) = 2;\n    if (*(iVar4 + 0x1c) != pcVar10) {\n        fcn.00402680(*(iVar4 + 0x1c));\n        *(unaff_EBP + -4) = 3;\n        fcn.00401930(unaff_EBP + -0x20);\n        uVar8 = fcn.004157fc();\n        (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(uVar8);\n        fcn.0040d34f(0xffffffff);\n        iVar4 = *(*(unaff_EBP + -0x14) + -0xc);\n        iVar3 = fcn.00418e83(iVar4);\n        if (iVar3 == 0x5c) {\n            iVar4 = iVar4 + 1;\n        }\n        iVar4 = (**(*arg_8h[0x20] + 0x3c))(arg_8h[0x20], *(unaff_EBP + -0x20) + iVar4 * 2);\n        if (pcVar10 <= iVar4 == pcVar10) goto code_r0x0042b681;\n        *(unaff_EBP + -4) = 2;\n        fcn.00401020();\n    }\n    iVar4 = *(unaff_EBP + -0x14);\n    if (*(arg_8h[0x1d] + 0x2c) == pcVar10) {\ncode_r0x0042b95d:\n        if (*(iVar4 + -0xc) != pcVar10) goto code_r0x0042b966;\n    }\n    else {\n        if (*(iVar4 + -0xc) == pcVar10) {\n            piVar11 = *(arg_8h[0x1d] + 0x2c);\n            fcn.004029f0();\n            iVar4 = *(unaff_EBP + -0x14);\n            goto code_r0x0042b95d;\n        }\ncode_r0x0042b966:\n        uVar9 = *0x45f824 & 1;\n        *(unaff_EBP + -0x1c) = pcVar10;\n        if (uVar9 == 0) {\n            *0x45f824 = *0x45f824 | 1;\n            *(unaff_EBP + -4) = 4;\n            *0x45f820 = fcn.004191b8(L\"Shell32.dll\");\n            *(unaff_EBP + -4) = 2;\n        }\n        if ((*0x45f820 != pcVar10) == pcVar10) goto code_r0x0042b681;\n        if ((*0x45f824 & 2) == 0) {\n            *0x45f824 = *0x45f824 | 2;\n            *0x45f81c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x45f820, \"SHCreateItemFromParsingName\", piVar11);\n        }\n        if ((*0x45f81c != pcVar10) == pcVar10) goto code_r0x0042b681;\n        iVar4 = (**0x45f81c)(iVar4, pcVar10, 0x44d0a4, unaff_EBP + -0x1c);\n        if (pcVar10 <= iVar4) {\n            iVar4 = (**(*arg_8h[0x20] + 0x30))(arg_8h[0x20], *(unaff_EBP + -0x1c));\n            if (pcVar10 <= iVar4 == pcVar10) goto code_r0x0042b681;\n            (**(**(unaff_EBP + -0x1c) + 8))(*(unaff_EBP + -0x1c));\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00401020();\ncode_r0x0042ba22:\n    piVar1 = arg_8h[0x20];\n    *(unaff_EBP + -0x10) = pcVar10;\n    iVar4 = (**(*piVar1 + 0x28))(piVar1, unaff_EBP + -0x10);\n    if (iVar4 < 0) goto code_r0x0042b681;\n    iVar4 = arg_8h[0x1d];\n    if ((*(iVar4 + 0x34) & 0x200) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffdff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x200;\n    }\n    if ((*(iVar4 + 0x34) & 0x2000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffffdfff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x2000;\n    }\n    if ((*(iVar4 + 0x34) & 0x2000000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfdffffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x2000000;\n    }\n    if ((*(iVar4 + 0x34) & 0x1000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffffefff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x1000;\n    }\n    if ((*(iVar4 + 0x34) & 0x10000000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xefffffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x10000000;\n    }\n    if ((*(iVar4 + 0x34) & 8) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffff7;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 8;\n    }\n    if ((*(iVar4 + 0x34) & 0x100000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffefffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x100000;\n    }\n    if ((*(iVar4 + 0x34) & 0x8000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffff7fff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x8000;\n    }\n    if ((*(iVar4 + 0x34) & 0x10000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffeffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x10000;\n    }\n    if ((*(iVar4 + 0x34) & 0x100) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffeff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x100;\n    }\n    if ((*(iVar4 + 0x34) & 2) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffffffd;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 2;\n    }\n    if ((*(iVar4 + 0x34) & 0x800) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffff7ff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x800;\n    }\n    if ((*(iVar4 + 0x34) & 0x4000) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xffffbfff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x4000;\n    }\n    if ((*(iVar4 + 0x54) & 1) == 0) {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & 0xfffbffff;\n    }\n    else {\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) | 0x40000;\n    }\n    arg_8h = arg_8h[0x20];\n    iVar4 = (**(*arg_8h + 0x24))(arg_8h, *(unaff_EBP + -0x10));\n    if (-1 < iVar4) goto code_r0x0042bb7f;\n    goto code_r0x0042b681;\n}\n",
        "token_count": 4410
    },
    "0042cbd7": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042cbd7(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t *puVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    uint arg_8h_00;\n    uint in_stack_ffffffec;\n    \n    if (arg_8h != 0) goto code_r0x0042cbf2;\n    in_stack_ffffffec = *(in_ECX + 0x14);\n    arg_8h_00 = 6;\n    while( true ) {\n        fcn.0041beec(arg_8h_00, in_stack_ffffffec);\ncode_r0x0042cbf2:\n        if ((~*(in_ECX + 0x18) & 1) != 0) break;\n        arg_8h_00 = 1;\n    }\n    if (*(arg_8h + 8) == 0xffff) {\n        fcn.00407ab5();\n    }\n    fcn.0042ca98(0);\n    puVar2 = fcn.00422f50(arg_8h);\n    uVar1 = *puVar2;\n    if (uVar1 == 0) {\n        fcn.00421d1a(0xffff);\n        fcn.0042202b(in_ECX);\n        fcn.0042c8c3();\n        puVar3 = fcn.00422f50(arg_8h);\n        *puVar3 = *(in_ECX + 0x34);\n        *(in_ECX + 0x34) = *(in_ECX + 0x34) + 1;\n    }\n    else if (uVar1 < 0x7fff) {\n        fcn.00421d1a(uVar1 | 0x8000);\n    }\n    else {\n        fcn.00421d1a(0x7fff);\n        fcn.00421d59(uVar1 | 0x80000000);\n    }\n    return;\n}\n",
        "token_count": 447
    },
    "0042cc86": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0042cc86(int32_t arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    uint32_t uVar4;\n    uint arg_8h_01;\n    uint in_stack_ffffffdc;\n    int32_t var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*(in_ECX + 0x18) & 1) != 0) goto code_r0x0042cca3;\n    in_stack_ffffffdc = *(in_ECX + 0x14);\n    arg_8h_01 = 1;\ncode_r0x0042cc9e:\n    do {\n        while( true ) {\n            fcn.0041beec(arg_8h_01, in_stack_ffffffdc);\ncode_r0x0042cca3:\n            arg_8h_00 = 0xffff;\n            if ((arg_8h != 0) && (*(arg_8h + 8) == 0xffff)) {\n                fcn.00407ab5();\n            }\n            fcn.0042ca98(0);\n            fcn.00421d97(&var_4h);\n            if (var_4h == 0x7fff) {\n                fcn.00421ddf(&var_ch);\n            }\n            else {\n                var_ch = (var_4h & 0x8000) << 0x10 | var_4h & 0x7fff;\n            }\n            if ((var_ch & 0x80000000) != 0) break;\n            if (arg_10h != NULL) {\n                *arg_10h = var_ch;\n                return 0;\n            }\ncode_r0x0042cd0e:\n            arg_8h_01 = 5;\n        }\n        if (var_4h != -1) {\n            uVar4 = var_ch & 0x7fffffff;\n            if ((uVar4 == 0) || (*(*(in_ECX + 0x38) + 8) - 1U < uVar4)) goto code_r0x0042cd0e;\n            var_4h = 0;\n            fcn.00422dce(1, &var_4h);\n            if (var_4h == 0) {\ncode_r0x0042cda6:\n                fcn.00407ad1();\n                goto code_r0x0042cdab;\n            }\n            piVar2 = fcn.0041c0f4(uVar4);\n            if (*piVar2 == 2) goto code_r0x0042cd0e;\n            arg_8h_00 = fcn.004246ab(uVar4);\n            var_8h = 0;\n            if ((*(in_ECX + 0x3c) == 0) || (iVar3 = fcn.00422dce(arg_8h_00, &var_4h),  var_8h = var_4h,  iVar3 == 0)) {\n                var_8h = *(arg_8h_00 + 8) & 0x7fffffff;\n            }\ncode_r0x0042ce3c:\n            if ((arg_8h == 0) || (iVar3 = fcn.004075a2(arg_8h),  iVar3 != 0)) {\n                if (arg_ch == NULL) {\n                    *(in_ECX + 0x10) = var_8h;\n                }\n                else {\n                    *arg_ch = var_8h;\n                }\n                if (arg_10h != NULL) {\n                    *arg_10h = var_ch;\n                }\n                return arg_8h_00;\n            }\ncode_r0x0042cd38:\n            arg_8h_01 = 6;\n            goto code_r0x0042cc9e;\n        }\n        arg_8h_00 = fcn.00421e78(in_ECX, &var_8h);\n        if (arg_8h_00 == 0) goto code_r0x0042cd38;\n        if ((*(arg_8h_00 + 8) & 0x7fffffff) == var_8h) {\ncode_r0x0042cd77:\n            fcn.0042c8c3();\n            uVar4 = 1;\n            fcn.0042d1c3(*(in_ECX + 0x34), arg_8h_00, 1);\n            var_10h = 0;\n            fcn.00422dce(1, &var_10h);\n            if (var_10h == 0) goto code_r0x0042cda6;\ncode_r0x0042cdab:\n            var_4h = uVar4;\n            fcn.0042c8ee(*(in_ECX + 0x34), &var_4h, uVar4);\n            *(in_ECX + 0x34) = *(in_ECX + 0x34) + 1;\n            goto code_r0x0042ce3c;\n        }\n        if ((*(arg_8h_00 + 8) & 0x80000000) != 0) {\n            fcn.0042c9c4(0);\n            uVar4 = var_8h;\n            puVar1 = fcn.00422f50(arg_8h_00);\n            *puVar1 = uVar4;\n            goto code_r0x0042cd77;\n        }\n        arg_8h_01 = 7;\n    } while( true );\n}\n",
        "token_count": 1304
    },
    "0042ce7a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ce7a(int32_t *arg_8h)\n\n{\n    uint32_t arg_8h_00;\n    uint32_t *puVar1;\n    uint arg_8h_01;\n    uint *puVar2;\n    int32_t in_ECX;\n    \n    if ((~*(in_ECX + 0x18) & 1) == 0) {\n        fcn.0041beec(2, *(in_ECX + 0x14));\n    }\n    fcn.0042ca98(0);\n    if (arg_8h == NULL) {\n        fcn.00421d1a(0);\n    }\n    else {\n        puVar1 = fcn.00422f50(arg_8h);\n        arg_8h_00 = *puVar1;\n        if (arg_8h_00 == 0) {\n            arg_8h_01 = (***arg_8h)();\n            fcn.0042cbd7(arg_8h_01);\n            fcn.0042c8c3();\n            puVar2 = fcn.00422f50(arg_8h);\n            *puVar2 = *(in_ECX + 0x34);\n            *(in_ECX + 0x34) = *(in_ECX + 0x34) + 1;\n            (**(*arg_8h + 8))();\n        }\n        else if (arg_8h_00 < 0x7fff) {\n            fcn.00421d1a(arg_8h_00);\n        }\n        else {\n            fcn.00421d1a(0x7fff);\n            fcn.00421d59(arg_8h_00);\n        }\n    }\n    return;\n}\n",
        "token_count": 387
    },
    "0042cf16": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.0042cf16(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *arg_ch;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint uVar4;\n    uint var_4h;\n    \n    var_4h = 0x42cf22;\n    fcn.00430ece(0x14);\n    if ((*(extraout_ECX + 0x18) & 1) != 0) goto code_r0x0042cf34;\n    var_4h = *(extraout_ECX + 0x14);\n    uVar4 = 4;\ncode_r0x0042cf2f:\n    do {\n        fcn.0041beec(uVar4, var_4h);\ncode_r0x0042cf34:\n        iVar2 = fcn.0042cc86(*(unaff_EBP + 8), unaff_EBP + -0x1c, unaff_EBP + -0x18);\n        *(unaff_EBP + -0x14) = 0;\n        if (iVar2 == 0) {\n            arg_ch = *(unaff_EBP + -0x18);\n            if (*(*(extraout_ECX + 0x38) + 8) + -1 < arg_ch) {\ncode_r0x0042cf5f:\n                uVar4 = 5;\n                goto code_r0x0042cf2f;\n            }\n            *(unaff_EBP + -0x14) = 0;\n            iVar2 = fcn.00422dce(1, unaff_EBP + -0x14);\n            if (iVar2 != 0) {\n                iVar2 = *(unaff_EBP + -0x14);\n                if (iVar2 == 0) goto code_r0x0042cf82;\n                goto code_r0x0042cf87;\n            }\n        }\n        else {\n            *(unaff_EBP + -4) = 0;\n            arg_ch = fcn.00407558();\n            *(unaff_EBP + -0x14) = arg_ch;\n            if (arg_ch == NULL) {\n                fcn.00407a99();\n            }\n            fcn.0042c8c3();\n            fcn.0042d1c3(*(extraout_ECX + 0x34), arg_ch, 1);\n            *(unaff_EBP + 8) = 0;\n            fcn.00422dce(1, unaff_EBP + 8);\n            if (*(unaff_EBP + 8) != 0) {\n                uVar4 = *(extraout_ECX + 0x34);\n                *(unaff_EBP + -0x18) = 2;\n                fcn.0042c8ee(uVar4, unaff_EBP + -0x18, 1);\n                uVar4 = *(unaff_EBP + -0x1c);\n                uVar1 = *(extraout_ECX + 0x10);\n                *(extraout_ECX + 0x34) = *(extraout_ECX + 0x34) + 1;\n                *(extraout_ECX + 0x10) = uVar4;\n                (**(*arg_ch + 8))(extraout_ECX);\n                *(extraout_ECX + 0x10) = uVar1;\ncode_r0x0042d04e:\n                fcn.00430f73();\n                return;\n            }\ncode_r0x0042cf82:\n            fcn.00407ad1();\n            iVar2 = extraout_ECX_00;\ncode_r0x0042cf87:\n            if (arg_ch <= *(iVar2 + 8) + -1) {\n                piVar3 = fcn.0041c0f4(arg_ch);\n                if (*piVar3 == 1) goto code_r0x0042cf5f;\n            }\n        }\n        iVar2 = fcn.004246ab(arg_ch);\n        if ((iVar2 == 0) || (*(unaff_EBP + 8) == 0)) goto code_r0x0042d04e;\n        iVar2 = fcn.004075cd(*(unaff_EBP + 8));\n        if (iVar2 != 0) goto code_r0x0042d04e;\n        uVar4 = 6;\n    } while( true );\n}\n",
        "token_count": 1077
    },
    "0042d290": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042d290(uint lpProcName, uint arg_ch)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f830 & 1) == 0) {\n        *0x45f830 = *0x45f830 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f82c = fcn.004191b8(0x44d6d0);\n    }\n    if (*0x45f82c != 0) {\n        (*_sym.imp.KERNEL32.dll_GetProcAddress)(*0x45f82c, *(unaff_EBP + 8));\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 199
    },
    "0042d2e4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042d2e4(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f838 & 1) == 0) {\n        *0x45f838 = *0x45f838 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f834 = fcn.0042d290(\"IsAppThemed\", method._AFX_MOUSEANCHORWND.virtual_28);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x45f834)();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 178
    },
    "0042d32a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042d32a(uint arg_8h, uint arg_ch)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f840 & 1) == 0) {\n        *0x45f840 = *0x45f840 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f83c = fcn.0042d290(\"OpenThemeData\", method._AFX_MOUSEANCHORWND.virtual_28);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x45f83c)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 207
    },
    "0042d3bf": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042d3bf(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f850 & 1) == 0) {\n        *0x45f850 = *0x45f850 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f84c = fcn.0042d290(\"DrawThemeBackground\", 0x42d28a);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x45f84c)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18), \n                 *(unaff_EBP + 0x1c));\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 275
    },
    "0042d417": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0042d417(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f858 & 1) == 0) {\n        *0x45f858 = *0x45f858 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f854 = fcn.0042d290(\"GetThemePartSize\", 0x42d28a);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x45f854)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18), \n                 *(unaff_EBP + 0x1c), *(unaff_EBP + 0x20));\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 290
    },
    "0042d472": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042d472(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f860 & 1) == 0) {\n        *0x45f860 = *0x45f860 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f85c = fcn.0042d290(\"IsThemeBackgroundPartiallyTransparent\", method._AFX_MOUSEANCHORWND.virtual_28);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x45f85c)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 226
    },
    "0042d4c1": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042d4c1(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    if ((*0x45f868 & 1) == 0) {\n        *0x45f868 = *0x45f868 | 1;\n        *(unaff_EBP + -4) = 0;\n        *0x45f864 = fcn.0042d290(\"DrawThemeParentBackground\", 0x42d28a);\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    (**0x45f864)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 221
    },
    "0043c584": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0043c584(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    uint var_14h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.00432e02();\n    var_4h = 0;\n    if (*0x4603e8 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"USER32.DLL\");\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (iVar2 == 0) {\n            return 0;\n        }\n        arg_8h_00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"MessageBoxA\");\n        if (arg_8h_00 == 0) {\n            return 0;\n        }\n        *0x4603e8 = fcn.00432d90(arg_8h_00);\n        uVar3 = (*pcVar4)(iVar2, 0x44e5f0);\n        *0x4603ec = fcn.00432d90(uVar3);\n        uVar3 = (*pcVar4)(iVar2, 0x44e5dc);\n        *0x4603f0 = fcn.00432d90(uVar3);\n        uVar3 = (*pcVar4)(iVar2, \"GetUserObjectInformationA\");\n        *0x4603f8 = fcn.00432d90(uVar3);\n        if (*0x4603f8 != 0) {\n            uVar3 = (*pcVar4)(iVar2, \"GetProcessWindowStation\");\n            *0x4603f4 = fcn.00432d90(uVar3);\n        }\n    }\n    if ((*0x4603f4 != iVar1) && (*0x4603f8 != iVar1)) {\n        pcVar4 = fcn.00432e0b(*0x4603f4);\n        pcVar5 = fcn.00432e0b(*0x4603f8);\n        if (((pcVar4 != NULL) && (pcVar5 != NULL)) &&\n           (((iVar2 = (*pcVar4)(),  iVar2 == 0 || (iVar2 = (*pcVar5)(iVar2, 1, &var_14h, 0xc, &var_8h),  iVar2 == 0)) ||\n            ((var_ch & 1) == 0)))) {\n            arg_10h = arg_10h | 0x200000;\n            goto code_r0x0043c6c6;\n        }\n    }\n    if ((((*0x4603ec != iVar1) && (pcVar4 = fcn.00432e0b(*0x4603ec),  pcVar4 != NULL)) &&\n        (var_4h = (*pcVar4)(),  var_4h != 0)) &&\n       ((*0x4603f0 != iVar1 && (pcVar4 = fcn.00432e0b(*0x4603f0),  pcVar4 != NULL)))) {\n        var_4h = (*pcVar4)(var_4h);\n    }\ncode_r0x0043c6c6:\n    pcVar4 = fcn.00432e0b(*0x4603e8);\n    if (pcVar4 == NULL) {\n        return 0;\n    }\n    uVar3 = (*pcVar4)(var_4h, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 849
    },
    "0043d2a4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043d2a4(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00431080(0x457550, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0043148e();\n        *puVar2 = 0;\n        puVar2 = fcn.0043147b();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x461588)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x4615a0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x40;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.0043f538(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0043147b();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0043148e();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0043cb71(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.0043d376(0x457550);\n                goto code_r0x0043d370;\n            }\n        }\n        puVar2 = fcn.0043148e();\n        *puVar2 = 0;\n        puVar2 = fcn.0043147b();\n        *puVar2 = 9;\n        fcn.0043399c(0, 0, 0, 0, 0);\n    }\ncode_r0x0043d370:\n    fcn.004310c5();\n    return;\n}\n",
        "token_count": 631
    },
    "0043ef6e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043ef6e(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.0042e8c8(arg_10h);\n    var_14h = fcn.00441097(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0044060f(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x0043efc7:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0043f007;\n        }\n        if (iVar1 != 2) {\ncode_r0x0043eff9:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0043f007;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x0043eff9;\n        goto code_r0x0043efc7;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x0043f007:\n    fcn.0042e09f(unaff_EBX);\n    return;\n}\n",
        "token_count": 508
    },
    "0043f016": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043f016(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.0042e8c8(arg_10h);\n    var_14h = fcn.00441097(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.00440b53(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x0043f06f:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0043f0af;\n        }\n        if (iVar1 != 2) {\ncode_r0x0043f0a1:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x0043f0af;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x0043f0a1;\n        goto code_r0x0043f06f;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x0043f0af:\n    fcn.0042e09f(unaff_EBX);\n    return;\n}\n",
        "token_count": 514
    },
    "00401930": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.00401930(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t **ppiVar5;\n    \n    iVar3 = *param_2;\n    iVar4 = *param_1;\n    ppiVar1 = iVar3 + -0x10;\n    ppiVar5 = iVar4 + -0x10;\n    if (ppiVar1 == ppiVar5) {\n        return param_1;\n    }\n    piVar2 = iVar4 + -4;\n    if ((-1 < *(iVar4 + -4)) && (*ppiVar1 == *ppiVar5)) {\n        iVar4 = fcn.00401b80(ppiVar1);\n        LOCK();\n        iVar3 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**ppiVar5 + 4))(ppiVar5);\n        }\n        *param_1 = iVar4 + 0x10;\n        return param_1;\n    }\n    fcn.00401a80(iVar3, *(iVar3 + -0xc));\n    return param_1;\n}\n",
        "token_count": 301
    },
    "00401a10": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401a10(int32_t *param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    \n    iVar4 = *param_1;\n    ppiVar1 = iVar4 + -0x10;\n    piVar3 = *ppiVar1;\n    if (*(iVar4 + -0xc) != 0) {\n        piVar2 = iVar4 + -4;\n        if (*(iVar4 + -4) < 0) {\n            if (*(iVar4 + -8) < 0) {\n                fcn.00401000(0x80070057);\n                iVar4 = extraout_ECX;\n            }\n            *(iVar4 + -0xc) = 0;\n            **param_1 = 0;\n            return;\n        }\n        LOCK();\n        iVar4 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar4 == 1 || iVar4 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1);\n        }\n        iVar4 = (**(*piVar3 + 0xc))();\n        *param_1 = iVar4 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 299
    },
    "00401b30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401b30(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t arg_ch;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBP;\n    int32_t **ppiVar6;\n    \n    iVar3 = *param_1;\n    if (param_2 < *(iVar3 + -0xc)) {\n        param_2 = *(iVar3 + -0xc);\n    }\n    if (1 < *(iVar3 + -4)) {\n        iVar3 = *param_1;\n        iVar2 = *(iVar3 + -0xc);\n        ppiVar6 = iVar3 + -0x10;\n        puVar4 = (**(**ppiVar6 + 0x10))();\n        iVar5 = (***puVar4)(param_2, 2);\n        if (iVar5 == 0) {\n            fcn.00401c10();\n        }\n        if (iVar2 < param_2) {\n            param_2 = iVar2;\n        }\n        arg_ch = param_2 * 2 + 2;\n        fcn.0042e44a(iVar5 + 0x10, arg_ch, iVar3, arg_ch);\n        *(iVar5 + 4) = iVar2;\n        piVar1 = iVar3 + -4;\n        LOCK();\n        iVar3 = *piVar1;\n        *piVar1 = *piVar1 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**ppiVar6 + 4))(ppiVar6);\n        }\n        *unaff_EBP = iVar5 + 0x10;\n        return;\n    }\n    iVar3 = *(iVar3 + -8);\n    if (param_2 <= iVar3) {\n        return;\n    }\n    if (iVar3 < 0x401) {\n        iVar3 = iVar3 * 2;\n    }\n    else {\n        iVar3 = iVar3 + 0x400;\n    }\n    if (iVar3 < param_2) {\n        iVar3 = param_2;\n    }\n    iVar2 = *param_1;\n    if ((*(iVar2 + -8) < iVar3) && (0 < iVar3)) {\n        iVar3 = (**(**(iVar2 + -0x10) + 8))(iVar2 + -0x10, iVar3, 2);\n        if (iVar3 != 0) goto code_r0x00401cce;\n    }\n    iVar3 = fcn.00401c10();\ncode_r0x00401cce:\n    *param_1 = iVar3 + 0x10;\n    return;\n}\n",
        "token_count": 612
    },
    "00401b80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** fcn.00401b80(int32_t **param_1)\n\n{\n    int32_t arg_ch;\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    \n    piVar1 = (**(**param_1 + 0x10))();\n    if ((-1 < param_1[3]) && (piVar1 == *param_1)) {\n        LOCK();\n        param_1[3] = param_1[3] + 1;\n        return param_1;\n    }\n    ppiVar2 = (***piVar1)(param_1[1], 2);\n    if (ppiVar2 == NULL) {\n        fcn.00401c10();\n    }\n    ppiVar2[1] = param_1[1];\n    arg_ch = param_1[1] * 2 + 2;\n    fcn.0042e44a(ppiVar2 + 4, arg_ch, param_1 + 4, arg_ch);\n    return ppiVar2;\n}\n",
        "token_count": 228
    },
    "00402660": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402660(int32_t **param_1)\n\n{\n    int32_t **arg_8h;\n    int32_t *piVar1;\n    \n    piVar1 = *param_1;\n    while (piVar1 != NULL) {\n        arg_8h = *param_1;\n        *param_1 = *arg_8h;\n        fcn.0042e518(arg_8h);\n        piVar1 = *param_1;\n    }\n    return;\n}\n",
        "token_count": 111
    },
    "00404180": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00404180(int32_t param_1, char param_2, int32_t param_3)\n\n{\n    uint arg_10h;\n    \n    if ((param_2 != '\\0') && (0xf < *(param_1 + 0x18))) {\n        arg_10h = *(param_1 + 4);\n        if (param_3 != 0) {\n            fcn.0042e44a(param_1 + 4, 0x10, arg_10h, param_3);\n        }\n        fcn.0040644a(arg_10h);\n    }\n    *(param_1 + 0x14) = param_3;\n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 4 + param_3) = 0;\n    return;\n}\n",
        "token_count": 190
    },
    "00404360": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch_3\n// WARNING: Could not reconcile some variable overlaps\n\nuint * __thiscall fcn.00404360(int32_t param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint *arg_8h;\n    int32_t arg_10h;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t *in_FS_OFFSET;\n    uint32_t var_4h;\n    uint var_8h;\n    uint var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint32_t uStack60;\n    code *apcStack44 [3];\n    uint var_28h;\n    uint uStack28;\n    int32_t iStack24;\n    uint32_t *puStack20;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h_2;\n    uint var_ch_3;\n    \n    var_14h = 0x4461d0;\n    var_18h = *in_FS_OFFSET;\n    uStack60 = *0x45c240 ^ &var_ch_3;\n    puStack20 = &uStack60;\n    *in_FS_OFFSET = &var_18h;\n    uVar4 = var_4h | 0xf;\n    uVar5 = var_4h;\n    if (uVar4 != 0xffffffff) {\n        uVar1 = *(param_1 + 0x18);\n        uVar3 = uVar1 >> 1;\n        uVar5 = uVar4;\n        if ((uVar4 / 3 < uVar3) && (uVar1 <= -uVar3 - 2)) {\n            uVar5 = uVar3 + uVar1;\n        }\n    }\n    uVar4 = uVar5 + 1;\n    var_10h_2 = 0;\n    iStack24 = param_1;\n    if (uVar4 == 0) {\n        uVar4 = 0;\n    }\n    else if (0xffffffff / uVar4 == 0) {\n        uStack28 = 0;\n        fcn.0042ed82(&uStack28);\n        apcStack44[0] = vtable.std::bad_alloc.0;\n        fcn.0043126c(apcStack44, 0x4577e0);\n        var_10h_2 = CONCAT31(var_10h_2._1_3_, 2);\n        puStack20 = &stack0xffffffb8;\n        fcn.004044e0(var_4h + 1);\n        return 0x40443c;\n    }\n    puStack20 = &uStack60;\n    arg_8h = fcn.0040641b(uVar4);\n    var_10h_2 = 0xffffffff;\n    if (param_3 != 0) {\n        if (*(param_1 + 0x18) < 0x10) {\n            arg_10h = param_1 + 4;\n        }\n        else {\n            arg_10h = *(param_1 + 4);\n        }\n        fcn.0042e44a(arg_8h, uVar5 + 1, arg_10h, param_3);\n    }\n    if (0xf < *(param_1 + 0x18)) {\n        fcn.0040644a();\n    }\n    puVar2 = param_1 + 4;\n    *puVar2 = 0;\n    *puVar2 = arg_8h;\n    *(param_1 + 0x18) = uVar5;\n    *(param_1 + 0x14) = param_3;\n    if (0xf < uVar5) {\n        puVar2 = arg_8h;\n    }\n    *(puVar2 + param_3) = 0;\n    *in_FS_OFFSET = var_18h;\n    return puVar2;\n}\n",
        "token_count": 897
    },
    "004044e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004044e0(uint32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t arg_8h;\n    \n    if (param_1 == 0) {\n        arg_8h = 0;\n    }\n    else {\n        arg_8h = param_1;\n        if (0xffffffff / param_1 == 0) {\n            param_1 = 0;\n            fcn.0042ed82(&param_1);\n            fcn.0043126c(&stack0xfffffff0, 0x4577e0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n    }\n    fcn.0040641b(arg_8h);\n    return;\n}\n",
        "token_count": 167
    },
    "004065a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004065a9(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    code **ppcVar5;\n    int32_t *in_ECX;\n    int32_t *piVar6;\n    uint32_t arg_ch_00;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.004213cc();\n        if (*(iVar1 + 0x3c) != 0) goto code_r0x004065c9;\n    }\n    else {\n        if (arg_ch != 0xfffffffd) {\n            if (arg_ch != 0xffffffff) {\n                uVar4 = arg_ch & 0xffff;\n                arg_ch_00 = arg_ch >> 0x10;\n                arg_ch = uVar4;\n                if (arg_ch_00 != 0) goto code_r0x00406681;\n            }\n            arg_ch_00 = 0x111;\ncode_r0x00406681:\n            ppcVar5 = (**(*in_ECX + 0x28))();\n            while( true ) {\n                if (*ppcVar5 == NULL) {\n                    return 0;\n                }\n                iVar1 = fcn.0040b1e3(ppcVar5[1], arg_ch_00, arg_ch, arg_8h);\n                if (iVar1 != 0) break;\n                ppcVar5 = (**ppcVar5)();\n            }\n            iVar1 = fcn.00406471(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n            return iVar1;\n        }\n        arg_ch = 0;\n        if (arg_10h != 0) {\n            iVar1 = *(arg_10h + 0x30);\n            puVar2 = (**(*in_ECX + 0x2c))();\n            do {\n                if (puVar2 == NULL) {\n                    return arg_ch;\n                }\n                if (arg_ch != 0) {\n                    return arg_ch;\n                }\n                piVar6 = puVar2[1];\n                while (((piVar6[1] != 0 && (piVar6[2] != 0)) && (arg_ch == 0))) {\n                    if (arg_8h == piVar6[1]) {\n                        if (iVar1 == 0) {\n                            if (*piVar6 == 0) {\ncode_r0x00406646:\n                                *(arg_10h + 4) = piVar6[2];\n                                arg_ch = 1;\n                            }\n                        }\n                        else if ((*piVar6 != 0) && (iVar3 = fcn.00406455(iVar1, *piVar6),  iVar3 != 0))\n                        goto code_r0x00406646;\n                    }\n                    piVar6 = piVar6 + 3;\n                }\n                puVar2 = *puVar2;\n            } while( true );\n        }\n    }\n    fcn.00407ad1();\ncode_r0x004065c9:\n    iVar1 = fcn.004213cc();\n    iVar1 = (**(**(iVar1 + 0x3c) + 4))();\n    return iVar1;\n}\n",
        "token_count": 761
    },
    "00406d5e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406d5e(int32_t arg_8h, int32_t arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint *extraout_ECX;\n    uint uVar2;\n    \n    if (arg_10h != NULL) goto code_r0x00406d78;\n    uVar2 = 0x80004005;\n    while( true ) {\n        fcn.00401000(uVar2);\n        arg_10h = extraout_ECX;\ncode_r0x00406d78:\n        if ((arg_8h != 0) || (arg_ch == 0)) break;\n        uVar2 = 0x80070057;\n    }\n    iVar1 = (***arg_10h)(arg_ch, 2);\n    if (iVar1 == 0) {\n        iVar1 = fcn.00401c10();\n    }\n    *in_ECX = iVar1 + 0x10;\n    fcn.004019e0(arg_ch);\n    fcn.00401bf0(*in_ECX, arg_ch, arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 263
    },
    "00406e54": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406e54(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = *in_ECX;\n    if (arg_8h < *(iVar1 + -0xc)) {\n        arg_8h = *(iVar1 + -0xc);\n    }\n    if (*(iVar1 + -4) < 2) {\n        iVar1 = *(iVar1 + -8);\n        if (iVar1 < arg_8h) {\n            if (iVar1 < 0x401) {\n                iVar1 = iVar1 * 2;\n            }\n            else {\n                iVar1 = iVar1 + 0x400;\n            }\n            if (iVar1 < arg_8h) {\n                iVar1 = arg_8h;\n            }\n            fcn.00406c7a(iVar1);\n        }\n    }\n    else {\n        fcn.00406dea(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 218
    },
    "00406fcc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406fcc(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (arg_8h != 0) {\n        iVar1 = fcn.0040fd7c();\n        if (iVar1 != 0) {\n            fcn.00410b1b();\n        }\n    }\n    return;\n}\n",
        "token_count": 80
    },
    "00407121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00407121(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.0040d3b7();\n    if (((iVar1 != 3) && (iVar1 != 4)) && (iVar2 = fcn.0040df6b(),  iVar2 != 0)) {\n        piVar3 = fcn.00413d6e();\n        iVar2 = (*_sym.imp.USER32.dll_GetFocus)();\n        if (((piVar3 == param_1) && (param_1[8] != iVar2)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_IsChild)(param_1[8], iVar2),  iVar2 == 0)) {\n            (**(*param_1 + 0x168))(1, param_1, param_1);\n        }\n        else {\n            fcn.00413d75(param_1, 1);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 241
    },
    "00407195": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407195(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint arg_8h_00;\n    \n    if (arg_8h == 0) {\n        fcn.00407ad1();\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x20));\n    uVar2 = fcn.0040d45d(uVar2);\n    iVar3 = fcn.004075cd(0x44788c);\n    if (iVar3 != 0) {\n        if (arg_ch != 0) {\n            return uVar2;\n        }\n        do {\n            arg_8h_00 = (*pcVar1)(*(arg_8h + 0x20));\n            arg_8h = fcn.0040d45d(arg_8h_00);\n            if (arg_8h == 0) {\n                return uVar2;\n            }\n            iVar3 = (*_sym.imp.USER32.dll_IsIconic)(*(arg_8h + 0x20));\n        } while (iVar3 == 0);\n    }\n    return 0;\n}\n",
        "token_count": 292
    },
    "00407279": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407279(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint in_ECX;\n    uint extraout_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n        in_ECX = extraout_ECX;\n    }\n    iVar1 = fcn.00407195(in_ECX, 0);\n    if ((iVar1 == 0) || (*(iVar1 + 0x98) != 0)) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = 1;\n    }\n    (***arg_8h)(uVar2);\n    return;\n}\n",
        "token_count": 157
    },
    "004075a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004075a2(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if (in_ECX != 0) goto code_r0x004075b2;\n    do {\n        in_ECX = fcn.00407ad1();\ncode_r0x004075b2:\n    } while (arg_8h == 0);\n    do {\n        if (in_ECX == arg_8h) {\n            return 1;\n        }\n        in_ECX = *(in_ECX + 0x10);\n    } while (in_ECX != 0);\n    return 0;\n}\n",
        "token_count": 141
    },
    "004075eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004075eb(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    \n    if (arg_ch != 0) {\n        iVar1 = fcn.004075cd(arg_8h);\n        if (iVar1 != 0) {\n            return arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 83
    },
    "004076a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004076a7(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "004076dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004076dc(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.0040700d();\n    if (piVar1 != NULL) {\n        iVar2 = (**(*piVar1 + 0x128))();\n        if ((iVar2 != 0) && (piVar1[0x20] != NULL)) {\n            (**(*piVar1[0x20] + 100))(arg_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 124
    },
    "00407715": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00407715(int32_t arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = arg_8h;\n    if (arg_8h != 0) goto code_r0x00407745;\n    iVar3 = fcn.00407639();\n    if ((iVar3 == 0) && (iVar3 = fcn.0040700d(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar5 = iVar3;\n        iVar6 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x20); iVar5 = iVar3,  iVar6 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x00407745:\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongW)(iVar3, 0xfffffff0);\n            iVar5 = iVar3;\n            iVar6 = iVar3;\n            if ((uVar4 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar5,  iVar1 != 0) {\n        iVar5 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((arg_8h == 0) && (iVar6 != 0)) {\n        iVar6 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar6);\n    }\n    if (arg_ch != NULL) {\n        if (((iVar3 == 0) || (iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar5 == 0)) || (iVar3 == iVar6))\n        {\n            *arg_ch = 0;\n        }\n        else {\n            *arg_ch = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 482
    },
    "004077c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004077c7(int32_t arg_8h, uint arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t hWnd_00;\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint *lpCaption;\n    uint *arg_ch_00;\n    uint var_220h;\n    uint var_21ch;\n    int32_t lpdwProcessId;\n    int32_t var_214h;\n    int32_t hWnd;\n    uint var_20ch;\n    ushort var_6h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.004076dc(0);\n    arg_ch_00 = &hWnd;\n    hWnd_00 = fcn.00407715(0, arg_ch_00);\n    if (hWnd_00 != hWnd) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd_00, 1);\n    }\n    lpdwProcessId = 0;\n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(hWnd_00, &lpdwProcessId);\n    if ((((hWnd_00 == 0) || (iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(),  lpdwProcessId != iVar1)) ||\n        (piVar2 = (*_sym.imp.USER32.dll_SendMessageW)(hWnd_00, 0x376, 0, 0),  piVar2 == NULL)) &&\n       (piVar2 = NULL,  arg_8h != 0)) {\n        piVar2 = arg_8h + 0x78;\n    }\n    var_214h = 0;\n    if ((piVar2 != NULL) && (var_214h = *piVar2,  arg_14h != 0)) {\n        *piVar2 = arg_14h + 0x30000;\n    }\n    if ((arg_10h & 0xf0) == 0) {\n        if ((arg_10h & 0xf) < 2) {\n            arg_10h = arg_10h | 0x30;\n        }\n        else if ((arg_10h & 0xf) - 3 < 2) {\n            arg_10h = arg_10h | 0x20;\n        }\n    }\n    var_20ch._0_2_ = 0;\n    if (arg_8h == 0) {\n        lpCaption = &var_20ch;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, lpCaption, 0x104);\n        if (iVar1 == 0x104) {\n            var_6h = 0;\n        }\n    }\n    else {\n        lpCaption = *(arg_8h + 0x50);\n    }\n    fcn.00407645(hWnd_00, arg_ch, lpCaption, arg_10h);\n    if (piVar2 != NULL) {\n        *piVar2 = var_214h;\n    }\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    fcn.004076dc(1);\n    fcn.0042e09f(arg_ch_00);\n    return;\n}\n",
        "token_count": 756
    },
    "004079c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004079c9(int32_t *param_1)\n\n{\n    if (0 < param_1[1]) {\n        (**(*param_1 + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "00407cfe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407cfe(uint32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.0040d9b4(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x78))(0);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0x140))(arg_8h & 0xff | 0xff00, arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 157
    },
    "00407d47": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407d47(uint32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.0040d9b4(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x78))(1);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0x140))((arg_8h & 0xff) << 8 | 0xff, arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 161
    },
    "004083e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004083e5(int32_t param_1)\n\n{\n    uint arg_8h;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    int32_t lParam;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    uint lpRect;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (*(param_1 + 0x84) == 0) {\n        *(param_1 + 0x84) = 1;\n        var_4h = 1;\n        arg_8h = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x20));\n        iVar1 = fcn.0040d45d(arg_8h);\n        if ((iVar1 == 0) ||\n           (iVar1 = (*_sym.imp.USER32.dll_SendMessageW)(*(iVar1 + 0x20), 0x368, 0, &fcn.004083e5::lParam),  iVar1 == 0))\n        {\n            iVar2 = fcn.004082aa(&fcn.004083e5::var_18h, &fcn.004083e5::var_10h);\n            iVar1 = var_14h;\n            iVar3 = var_18h;\n            if (iVar2 == 0) {\n                (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x20), &fcn.004083e5::lpRect);\n                if ((0 < var_20h) && (0 < var_1ch)) {\n                    fcn.0040c02d(3, 0);\n                }\n                *(param_1 + 0x84) = 0;\n                return;\n            }\n        }\n        else {\n            var_4h = 0;\n            fcn.00407c9e(0x408444);\n            iVar1 = var_2ch - var_34h;\n            iVar3 = var_30h - lParam;\n        }\n        fcn.00408327(iVar3, iVar1, &fcn.004083e5::var_8h, &fcn.004083e5::var_20h, &fcn.004083e5::var_18h, var_4h);\n        if (var_8h != 0) {\n            iVar1 = iVar1 - var_ch;\n        }\n        if (var_4h != 0) {\n            iVar3 = iVar3 - var_10h;\n        }\n        fcn.00407c4a(var_18h, var_14h);\n        var_4ch = 0;\n        var_50h = 3;\n        fcn.0040c02d(0, var_8h);\n        if (var_8h != 0) {\n            var_48h = *(param_1 + 0x68) + -1;\n            var_44h = iVar3;\n            iVar3 = fcn.0040b29f(0, &fcn.004083e5::var_54h, 1);\n            if (iVar3 == 0) {\n                fcn.0040bfc2(0, 0, var_20h, 1);\n            }\n        }\n        fcn.0040c02d(1, var_4h);\n        if (var_4h != 0) {\n            var_48h = *(param_1 + 0x6c) + -1;\n            var_44h = iVar1;\n            iVar1 = fcn.0040b29f(1, &fcn.004083e5::var_54h, 1);\n            if (iVar1 == 0) {\n                fcn.0040bfc2(1, 0, var_1ch, 1);\n            }\n        }\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 970
    },
    "00408793": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408793(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    uint32_t uVar6;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_GetWindowRect)(param_1[8], &var_28h);\n    iVar1 = param_1[0x1c];\n    uVar6 = 0;\n    if ((iVar1 == 0x7923) || (iVar1 == 0x7922)) {\n        if (var_ch < var_24h) {\n            uVar6 = 30999;\n        }\n        else if (var_1ch < var_ch) {\n            uVar6 = 0x791d;\n        }\n    }\n    if ((iVar1 == 0x7923) || (iVar1 == 0x7921)) {\n        if (var_10h < var_28h) {\n            if (uVar6 == 0) {\n                uVar6 = 0x7919;\n            }\n            else if (iVar1 == 0x7923) {\n                uVar6 = uVar6 - 1;\n            }\n        }\n        else if (var_20h < var_10h) {\n            if (uVar6 == 0) {\n                uVar6 = 0x791b;\n            }\n            else if (iVar1 == 0x7923) {\n                uVar6 = uVar6 + 1;\n            }\n        }\n    }\n    if (param_1[0x1b] == 0) {\n        if (uVar6 == 0) {\n            (*_sym.imp.USER32.dll_SetCursor)(param_1[0x1d]);\n        }\n        else {\n            iVar1 = fcn.004213cc();\n            uVar2 = (*_sym.imp.USER32.dll_LoadCursorW)(*(iVar1 + 0xc), uVar6 & 0xffff);\n            (*_sym.imp.USER32.dll_SetCursor)(uVar2);\n            if ((var_20h < var_10h) || (var_20h = var_28h,  var_10h < var_28h)) {\n                var_8h = var_10h - var_20h;\n            }\n            else {\n                var_8h = 0;\n            }\n            if ((var_1ch < var_ch) || (var_1ch = var_24h,  var_ch < var_24h)) {\n                var_4h = var_ch - var_1ch;\n            }\n            else {\n                var_4h = 0;\n            }\n            piVar3 = fcn.0040877c();\n            iVar1 = param_1[0x1c];\n            if ((iVar1 == 0x7923) || (iVar1 == 0x7922)) {\n                uVar2 = 1;\n            }\n            else {\n                uVar2 = 0;\n            }\n            if ((iVar1 == 0x7923) || (iVar1 == 0x7921)) {\n                uVar4 = 1;\n            }\n            else {\n                uVar4 = 0;\n            }\n            (**(*piVar3 + 0x18c))(&var_18h, var_8h, var_4h, uVar4, uVar2);\n            fcn.00410ab2(0);\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(piVar3[8]);\n            uVar2 = fcn.0040d45d(uVar2);\n            piVar5 = fcn.004075eb(0x44788c, uVar2);\n            if (piVar5 == NULL) {\n                (**(*piVar3 + 0x144))();\n            }\n            else {\n                (**(*piVar5 + 0x184))(piVar3, var_18h, var_14h, 1);\n            }\n            (*_sym.imp.USER32.dll_UpdateWindow)(param_1[8]);\n            fcn.00410b5a(0x45f3d0, param_1[0x19] + -0x10, param_1[0x1a] + -0x10, 0, 0, 0x51);\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_KillTimer)(param_1[8], 0xe000);\n        (*_sym.imp.USER32.dll_ReleaseCapture)();\n        (*_sym.imp.USER32.dll_SetCursor)(0);\n        iVar1 = fcn.0040877c();\n        (**(*param_1 + 0x60))();\n        if (*(iVar1 + 0x58) != NULL) {\n            (**(**(iVar1 + 0x58) + 4))(1);\n        }\n        *(iVar1 + 0x58) = 0;\n    }\n    return;\n}\n",
        "token_count": 1189
    },
    "0040898d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl fcn.0040898d(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    int32_t arg_ch_00;\n    int32_t arg_10h;\n    int32_t lpRect;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    \n    if (*(in_ECX + 0x5c) == -1) {\n        (**(*arg_8h + 0x34))(8);\n        var_14h = *(in_ECX + 100);\n        lpRect = *(in_ECX + 0x60);\n        fcn.00407f3e(&var_8h, lpRect, var_14h);\n        fcn.00407f24(&var_10h, *(in_ECX + 0x68), *(in_ECX + 0x6c));\n    }\n    else {\n        (**(*arg_8h + 0x34))(*(in_ECX + 0x5c));\n    }\n    arg_10h = 0;\n    arg_ch_00 = 0;\n    if (arg_8h[3] == 0) {\n        piVar1 = fcn.0040819f(&var_10h);\n        arg_ch_00 = -*piVar1;\n        arg_10h = -piVar1[1];\n        if (*(in_ECX + 0x80) != 0) {\n            (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n            if (*(in_ECX + 0x68) < var_10h - lpRect) {\n                arg_ch_00 = ((var_10h - *(in_ECX + 0x68)) - lpRect) / 2;\n            }\n            if (*(in_ECX + 0x6c) < var_ch - var_14h) {\n                arg_10h = ((var_ch - *(in_ECX + 0x6c)) - var_14h) / 2;\n            }\n        }\n    }\n    fcn.00407f0a(&var_10h, arg_ch_00, arg_10h);\n    fcn.00407341(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 555
    },
    "00408afc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00408afc(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x18);\n    *(unaff_EBP + -0x10) = *(extraout_ECX + 0x5c);\n    *(extraout_ECX + 0x5c) = *(unaff_EBP + 8);\n    *(extraout_ECX + 0x60) = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 100) = *(unaff_EBP + 0x10);\n    fcn.00409d54(0);\n    uVar2 = *(extraout_ECX + 0x5c);\n    *(unaff_EBP + -4) = 0;\n    fcn.00409531(uVar2);\n    pcVar5 = _sym.imp.GDI32.dll_LPtoDP;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x68) = *(extraout_ECX + 0x60);\n    *(extraout_ECX + 0x6c) = *(extraout_ECX + 100);\n    (*pcVar5)(uVar2, extraout_ECX + 0x68, 1);\n    iVar3 = (*(unaff_EBP + 0x14))[1];\n    piVar1 = extraout_ECX + 0x70;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *piVar1 = **(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x74) = iVar3;\n    (*pcVar5)(uVar2, piVar1, 1);\n    uVar2 = (*(unaff_EBP + 0x18))[1];\n    uVar4 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x78) = **(unaff_EBP + 0x18);\n    *(extraout_ECX + 0x7c) = uVar2;\n    (*pcVar5)(uVar4, extraout_ECX + 0x78, 1);\n    if (*(extraout_ECX + 0x6c) < 0) {\n        *(extraout_ECX + 0x6c) = -*(extraout_ECX + 0x6c);\n    }\n    if (*(extraout_ECX + 0x74) < 0) {\n        *(extraout_ECX + 0x74) = -*(extraout_ECX + 0x74);\n    }\n    if (*(extraout_ECX + 0x7c) < 0) {\n        *(extraout_ECX + 0x7c) = -*(extraout_ECX + 0x7c);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00409da8();\n    if (*piVar1 == 0) {\n        *piVar1 = *(extraout_ECX + 0x68) / 10;\n    }\n    if (*(extraout_ECX + 0x74) == 0) {\n        *(extraout_ECX + 0x74) = *(extraout_ECX + 0x6c) / 10;\n    }\n    if (*(extraout_ECX + 0x78) == 0) {\n        *(extraout_ECX + 0x78) = *piVar1 / 10;\n    }\n    if (*(extraout_ECX + 0x7c) == 0) {\n        *(extraout_ECX + 0x7c) = *(extraout_ECX + 0x74) / 10;\n    }\n    if (*(extraout_ECX + 0x20) != 0) {\n        fcn.004083e5();\n        if (*(unaff_EBP + -0x10) != *(extraout_ECX + 0x5c)) {\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(extraout_ECX + 0x20), 0, 1);\n        }\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1088
    },
    "004090f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004090f9(uint arg_8h, uint hMenu, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t unaff_EBP;\n    uint var_23ch;\n    uint var_238h;\n    uint var_234h;\n    uint var_230h;\n    uint var_22ch;\n    uint var_228h;\n    uint lpNewItem;\n    uint uIDNewItem;\n    uint uIDItem;\n    uint var_218h;\n    uint uPosition;\n    uint lpString;\n    uint var_4h;\n    \n    fcn.00430f04(0x230);\n    puVar2 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x230) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x228) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x238) = 0;\n    *(unaff_EBP + -0x234) = 0;\n    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x23c) = iVar3;\n    *(unaff_EBP + -0x218) = 0;\n    *(unaff_EBP + -0x214) = 0;\n    if (*(unaff_EBP + 0x14) == 1) {\n        *(unaff_EBP + -0x214) = *puVar2;\n    }\n    *(unaff_EBP + -0x21c) = 0;\n    if (0 < iVar3) {\n        do {\n            uVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(*(unaff_EBP + -0x228), *(unaff_EBP + -0x21c));\n            *(unaff_EBP + -0x220) = uVar4;\n            uVar5 = (*_sym.imp.USER32.dll_GetMenuState)(*(unaff_EBP + -0x228), *(unaff_EBP + -0x21c), 0x400);\n            if ((*(unaff_EBP + -0x220) == 0) && ((uVar5 & 0x800) != 0)) {\n                iVar3 = *(unaff_EBP + 0x14);\n                puVar2[iVar3] = *(unaff_EBP + -0x218);\n                *(unaff_EBP + -0x218) = 0;\n                if (iVar3 < 5) {\n                    *(unaff_EBP + -0x214) = *(unaff_EBP + -0x214) + (puVar2 + iVar3)[1];\n                }\n                *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + 2;\n            }\n            else {\n                *(unaff_EBP + -0x22c) = 0;\n                if ((*(unaff_EBP + 0x18) != 0) && ((*(unaff_EBP + 0x14) == 5 && (puVar2[5] == 1)))) {\n                    uVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(*(unaff_EBP + -0x230), *(unaff_EBP + -0x214));\n                    *(unaff_EBP + -0x22c) = uVar4;\n                }\n                iVar3 = (*_sym.imp.USER32.dll_GetMenuStringW)\n                                  (*(unaff_EBP + -0x228), *(unaff_EBP + -0x21c), unaff_EBP + -0x210, 0x100, 0x400);\n                if (*(unaff_EBP + -0x220) == 0) {\n                    if (0 < iVar3) {\n                        iVar3 = unaff_EBP + -0x210;\n                        uVar4 = (*_sym.imp.USER32.dll_GetMenuItemID)\n                                          (*(unaff_EBP + -0x228), *(unaff_EBP + -0x21c), iVar3);\n                        uVar5 = uVar5 | 0x400;\ncode_r0x0040930d:\n                        (*_sym.imp.USER32.dll_InsertMenuW)\n                                  (*(unaff_EBP + -0x230), *(unaff_EBP + -0x214), uVar5, uVar4, iVar3);\n                        *(unaff_EBP + -0x214) = *(unaff_EBP + -0x214) + 1;\n                        *(unaff_EBP + -0x218) = *(unaff_EBP + -0x218) + 1;\n                    }\n                }\n                else if (*(unaff_EBP + -0x22c) == 0) {\n                    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(unaff_EBP + -0x220));\n                    if (iVar3 != 0) {\n                        iVar3 = unaff_EBP + -0x210;\n                        uVar4 = *(unaff_EBP + -0x220);\n                        uVar5 = uVar5 & 0xff | 0x410;\n                        goto code_r0x0040930d;\n                    }\n                }\n                else {\n                    iVar3 = fcn.004213cc();\n                    fcn.00402680(*(iVar3 + 0x10));\n                    *(unaff_EBP + -4) = 0;\n                    if (*(*(unaff_EBP + -0x224) + -0xc) != 0) {\n                        fcn.00405240(0x20);\n                    }\n                    fcn.004090aa(unaff_EBP + -0x210);\n                    uVar4 = *(unaff_EBP + -0x220);\n                    (*_sym.imp.USER32.dll_AppendMenuW)(*(unaff_EBP + -0x22c), 0x10, uVar4, *(unaff_EBP + -0x224));\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    puVar1 = puVar2 + *(unaff_EBP + 0x14);\n                    *puVar1 = 0;\n                    puVar1[-1] = puVar1[-1] + 1;\n                    *(unaff_EBP + -0x238) = 1;\n                    *(unaff_EBP + -0x234) = uVar4;\n                    fcn.00401020();\n                }\n            }\n            *(unaff_EBP + -0x21c) = *(unaff_EBP + -0x21c) + 1;\n        } while (*(unaff_EBP + -0x21c) < *(unaff_EBP + -0x23c));\n        if (*(unaff_EBP + -0x238) != 0) goto code_r0x00409358;\n    }\n    puVar2[*(unaff_EBP + 0x14)] = *(unaff_EBP + -0x218);\ncode_r0x00409358:\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 1609
    },
    "00409bbb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409bbb(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    iVar1 = fcn.004213ff();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00406404(fcn.00421648);\n        iVar2 = fcn.0040641b(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.00422fd7(0x448158, fcn.00409b80, fcn.004096f6, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar3;\n        fcn.00406404(arg_8h_00);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 324
    },
    "00423060": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00423060(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430ece(8);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((arg_8h_00 != 0) && (iVar1 = fcn.00422d89(arg_8h_00),  iVar1 == 0)) {\n        iVar1 = fcn.00422d89(arg_8h_00);\n        if (iVar1 == 0) {\n            uVar2 = fcn.00406404(fcn.00421648);\n            *(unaff_EBP + -4) = 0;\n            *(unaff_EBP + 8) = uVar2;\n            iVar1 = fcn.0042c881();\n            if (iVar1 == 0) {\n                fcn.00407a99();\n            }\n            (**(extraout_ECX + 0x14))(iVar1);\n            piVar3 = fcn.00422f50(arg_8h_00);\n            uVar2 = *(unaff_EBP + 8);\n            *(unaff_EBP + -4) = 0xffffffff;\n            *piVar3 = iVar1;\n            fcn.00406404(uVar2);\n            piVar3 = *(extraout_ECX + 0x58) + iVar1;\n            *piVar3 = arg_8h_00;\n            if (*(extraout_ECX + 0x5c) == 2) {\n                piVar3[1] = arg_8h_00;\n            }\n        }\n        else {\n            piVar3 = *(extraout_ECX + 0x58) + iVar1;\n            *piVar3 = arg_8h_00;\n            if (*(extraout_ECX + 0x5c) == 2) {\n                piVar3[1] = arg_8h_00;\n            }\n        }\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 511
    },
    "00409cac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00409cac(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CDC.0;\n    if (param_1[1] != NULL) {\n        uVar1 = fcn.00409c79();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 85
    },
    "00409e77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409e77(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    iVar1 = fcn.004213ff();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00406404(fcn.00421648);\n        iVar2 = fcn.0040641b(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.00422fd7(0x4481c8, fcn.00409ba1, fcn.004096f6, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar3;\n        fcn.00406404(arg_8h_00);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 325
    },
    "00409f57": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00409f57(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.00409f2b();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "0040a6e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040a6e0(void)\n\n{\n    uint *arg_8h;\n    uint lpVersionInformation;\n    uint var_94h;\n    uint var_88h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.00430820(&var_94h, 0, 0x90);\n    arg_8h = &lpVersionInformation;\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    fcn.0042e09f(arg_8h);\n    return;\n}\n",
        "token_count": 145
    },
    "0040a9c8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.0040a9c8(int32_t *arg_8h, int32_t arg_ch, uint noname_2, uint noname_3, uint32_t arg_18h, uint32_t *arg_1ch, \n            uint *arg_20h, uint noname_7, uint *arg_28h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    code *pcVar4;\n    int32_t *piVar5;\n    uint32_t *puVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t *piVar10;\n    ushort uVar11;\n    uint var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_34h;\n    uint var_30h;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint var_20h;\n    int32_t pvargDest;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar6 = arg_1ch;\n    piVar5 = arg_8h;\n    iVar9 = 0;\n    var_20h._0_2_ = 0;\n    if (arg_8h == NULL) {\n        return -0x7ff8ffa9;\n    }\n    if (arg_1ch == NULL) {\n        return -0x7ffdfff8;\n    }\n    uVar2 = arg_1ch[2];\n    if (5 < uVar2) {\n        return -0x7ffdfff2;\n    }\n    arg_8h = NULL;\n    if (arg_1ch[3] != 0) {\n        arg_1ch = arg_1ch[1];\n        do {\n            uVar3 = *arg_1ch;\n            if (uVar2 <= uVar3) {\n                return -0x7ffdfff2;\n            }\n            arg_1ch = arg_1ch + 1;\n            arg_8h = arg_8h + 1;\n            (&var_44h)[uVar3] = *puVar6 + iVar9;\n            iVar9 = iVar9 + 0x10;\n        } while (arg_8h < puVar6[3]);\n    }\n    if (arg_8h < uVar2) {\n        iVar9 = arg_8h * 0x10 + *puVar6;\n        iVar8 = uVar2 - arg_8h;\n        piVar10 = &var_48h + (uVar2 - arg_8h);\n        do {\n            *piVar10 = iVar9;\n            iVar9 = iVar9 + 0x10;\n            piVar10 = piVar10 + -1;\n            iVar8 = iVar8 + -1;\n        } while (iVar8 != 0);\n    }\n    iVar9 = -0x7ffdfffd;\n    if (arg_28h == NULL) {\n        arg_28h = &arg_18h;\n    }\n    if (arg_20h == NULL) {\n        arg_20h = &var_20h;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantClear)(&pvargDest);\n    pcVar4 = _sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime;\n    if (0x12 < arg_ch + 0x139aU) goto code_r0x0040af33;\n    // switch table (19 cases) at 0x40af48\n    switch(*((arg_ch + 0x139aU) * 4 + 0x40af48)) {\n    case 0x40aaa9:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 100))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3]);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40aaca:\n        if (puVar6[2] == 2) {\n            if (*var_44h != 3) {\n                iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_44h, 0, 3);\n                if (iVar9 < 0) goto code_r0x0040acce;\n                var_44h = &pvargDest;\n            }\n            arg_18h = var_44h[2];\n            if (*var_40h != 3) {\n                iVar9 = (*pcVar4)(&pvargDest, var_40h, 0, 3);\n                if (iVar9 < 0) {\ncode_r0x0040aeb5:\n                    *arg_28h = 1;\n                    goto code_r0x0040af33;\n                }\n                var_40h = &pvargDest;\n            }\n            iVar9 = (**(*piVar5 + 0x60))(piVar5, arg_18h, var_40h[2], arg_20h);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40ab37:\n        if (puVar6[2] == 2) {\n            if (*var_44h != 3) {\n                iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_44h, 0, 3);\n                if (iVar9 < 0) goto code_r0x0040acce;\n                var_44h = &pvargDest;\n            }\n            iVar9 = (**(*piVar5 + 0x5c))(piVar5, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40ab84:\n        if (puVar6[2] == 5) {\n            while ((uVar1 = *var_44h,  (uVar1 & 0x4000) != 0 && ((uVar1 & 0xf) != 0))) {\n                if ((uVar1 & 0xc) == 0) {\n                    pvargDest = var_44h[2];\n                }\n                else {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                    *var_44h[2] = 3;\n                    pvargDest = var_44h[2] + 8;\n                }\n            }\n            *arg_28h = 0;\n            iVar9 = (**(*piVar5 + 0x58))\n                              (piVar5, pvargDest, var_ch, var_8h, var_4h, *var_34h, var_34h[1], var_34h[2], var_34h[3]);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40abef:\n        if (puVar6[2] == 2) {\n            if (*var_44h != 3) {\n                iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_44h, 0, 3);\n                if (iVar9 < 0) goto code_r0x0040acce;\n                var_44h = &pvargDest;\n            }\n            iVar9 = (**(*piVar5 + 0x54))(piVar5, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3]);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40ac39:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x50))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\ncode_r0x0040ac5c:\n            if (iVar9 < 0) goto code_r0x0040af33;\n            uVar11 = 8;\n            goto code_r0x0040af2c;\n        }\n        break;\n    case 0x40ac6d:\n        iVar9 = (**(*piVar5 + 0x4c))(piVar5, arg_20h);\n        goto code_r0x0040af33;\n    case 0x40ac7b:\n        iVar9 = (**(*piVar5 + 0x48))(piVar5, arg_20h);\n        goto code_r0x0040af33;\n    case 0x40ac89:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x44))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040ac5c;\n        }\n        break;\n    case 0x40acae:\n        if (puVar6[2] == 2) {\n            uVar1 = *var_44h;\n            if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {\n                iVar9 = -0x7ffdfffb;\ncode_r0x0040acce:\n                *arg_28h = 0;\n                goto code_r0x0040af33;\n            }\n            if (uVar1 == 0x400c) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                *var_44h[2] = 8;\n                puVar7 = var_44h[2] + 8;\n            }\n            else if (uVar1 == 0x4008) {\n                puVar7 = var_44h[2];\n            }\n            else {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h);\n                puVar7 = var_44h + 2;\n                *var_44h = 8;\n            }\n            iVar9 = (**(*piVar5 + 0x40))(piVar5, puVar7, *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h + 2);\n            goto code_r0x0040ad35;\n        }\n        break;\n    case 0x40ad46:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x3c))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040ac5c;\n        }\n        break;\n    case 0x40ad6e:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x38))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40ad92:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x34))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x0040af33;\n        }\n        break;\n    case 0x40adb6:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x30))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040ac5c;\n        }\n        break;\n    case 0x40adde:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x0040ae5b;\n            if (puVar6[2] == 2) {\n                var_30h = *var_44h;\n                uStack48 = var_44h[1];\n                uStack44 = var_44h[2];\n                uStack40 = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_40h, 0, 3);\n                    if (iVar9 < 0) goto code_r0x0040aeb5;\n                    var_40h = &pvargDest;\n                }\n                iVar9 = (**(*piVar5 + 0x6c))(piVar5, var_30h, uStack48, uStack44, uStack40, var_40h[2]);\n                goto code_r0x0040af33;\n            }\n        }\n        else if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x2c))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040ac5c;\n        }\n        break;\n    case 0x40ae5b:\ncode_r0x0040ae5b:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x0040aedd;\n            if (puVar6[2] == 2) {\n                var_30h = *var_44h;\n                uStack48 = var_44h[1];\n                uStack44 = var_44h[2];\n                uStack40 = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&pvargDest, var_40h, 0, 3);\n                    if (iVar9 < 0) goto code_r0x0040aeb5;\n                    var_40h = &pvargDest;\n                }\n                iVar9 = (**(*piVar5 + 0x68))(piVar5, var_30h, uStack48, uStack44, uStack40, var_40h[2]);\n                goto code_r0x0040af33;\n            }\n        }\n        else if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x28))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040ac5c;\n        }\n        break;\n    case 0x40aedd:\ncode_r0x0040aedd:\n        if (puVar6[2] == 1) {\n            iVar9 = (**(*piVar5 + 0x24))(piVar5, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0040af24;\n        }\n        break;\n    case 0x40af05:\n        iVar9 = (**(*piVar5 + 0x20))(piVar5, arg_20h + 2);\ncode_r0x0040ad35:\n        if (iVar9 < 0) goto code_r0x0040af33;\n        uVar11 = 3;\n        goto code_r0x0040af2c;\n    case 0x40af17:\n        iVar9 = (**(*piVar5 + 0x1c))(piVar5, arg_20h + 2);\ncode_r0x0040af24:\n        if (iVar9 < 0) goto code_r0x0040af33;\n        uVar11 = 9;\ncode_r0x0040af2c:\n        *arg_20h = uVar11;\n        goto code_r0x0040af33;\n    }\n    iVar9 = -0x7ffdfff2;\ncode_r0x0040af33:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&pvargDest);\n    return iVar9;\n}\n",
        "token_count": 3828
    },
    "0040af94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.0040af94(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint noname_3, int32_t arg_18h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_1h;\n    \n    uVar3 = 0;\n    if (arg_10h != 0) {\n        do {\n            bVar1 = false;\n            uVar4 = 0;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(*(arg_ch + uVar3 * 4), *(uVar4 + 0x45b6d8));\n                if (iVar2 == 0) {\n                    bVar1 = true;\n                    *(arg_18h + uVar3 * 4) = *(uVar4 + 0x45b688);\n                }\n                uVar4 = uVar4 + 4;\n            } while (uVar4 < 0x4c);\n            if (!bVar1) {\n                return 0x80020006;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < arg_10h);\n    }\n    return 0;\n}\n",
        "token_count": 305
    },
    "0040b1e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040b1e3(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 170
    },
    "0040b29f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b29f(int32_t arg_8h, uint *lpsi, uint redraw)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = in_ECX[8];\n    if (arg_8h != 2) {\n        iVar1 = (**(*in_ECX + 0x78))(arg_8h);\n        if (iVar1 != 0) {\n            iVar2 = *(iVar1 + 0x20);\n            arg_8h = 2;\n        }\n    }\n    *lpsi = 0x1c;\n    (*_sym.imp.USER32.dll_SetScrollInfo)(iVar2, arg_8h, lpsi, redraw);\n    return 1;\n}\n",
        "token_count": 173
    },
    "0040b2df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b2df(int32_t arg_8h, uint *lpsi, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = in_ECX[8];\n    if (arg_8h != 2) {\n        iVar1 = (**(*in_ECX + 0x78))(arg_8h);\n        if (iVar1 != 0) {\n            iVar2 = *(iVar1 + 0x20);\n            arg_8h = 2;\n        }\n    }\n    *lpsi = 0x1c;\n    lpsi[1] = arg_10h;\n    (*_sym.imp.USER32.dll_GetScrollInfo)(iVar2, arg_8h, lpsi);\n    return;\n}\n",
        "token_count": 184
    },
    "0040b33d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040b33d(int32_t *arg_8h, uint hWnd, int32_t *lprc2)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint lpRect;\n    uint var_8h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(hWnd);\n    if ((arg_8h == NULL) || (*arg_8h != 0)) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n        pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar2, &lpRect);\n        (*pcVar1)(uVar2, &var_8h);\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprc2);\n        if (iVar3 == 0) {\n            if (arg_8h == NULL) {\n                (*_sym.imp.USER32.dll_SetWindowPos)\n                          (hWnd, 0, *lprc2, lprc2[1], lprc2[2] - *lprc2, lprc2[3] - lprc2[1], 0x14);\n            }\n            else {\n                iVar3 = (*_sym.imp.USER32.dll_DeferWindowPos)(*arg_8h);\n                *arg_8h = iVar3;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 336
    },
    "0040b73b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040b73b(int32_t hdc, uint arg_ch, int32_t arg_10h, int32_t hgdiobj, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint lpvObject;\n    uint crColor;\n    \n    if ((((hdc == 0) || (hgdiobj == 0)) || (arg_10h == 1)) || ((arg_10h == 0 || (arg_10h == 5)))) {\ncode_r0x0040b7ac:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.0042169b(arg_ch, 2);\n            if (iVar1 == 0) goto code_r0x0040b7ac;\n        }\n        (*_sym.imp.GDI32.dll_GetObjectW)(hgdiobj, 0xc, &lpvObject);\n        (*_sym.imp.GDI32.dll_SetBkColor)(hdc, crColor);\n        if (arg_18h == -1) {\n            arg_18h = (*_sym.imp.USER32.dll_GetSysColor)(8);\n        }\n        (*_sym.imp.GDI32.dll_SetTextColor)(hdc, arg_18h);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 308
    },
    "0040b8c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040b8c1(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "0040b957": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040b957(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "0040b9eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040b9eb(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "0040ba9a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040ba9a(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 198
    },
    "0040bb28": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040bb28(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "0040bdbf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040bdbf(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    \n    iVar4 = fcn.004213ff();\n    if ((*(iVar4 + 0x3c) != 0) && (iVar1 = *(*(iVar4 + 0x3c) + 0x20),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_SendMessageW)(iVar1, 0x401, 0, 0);\n    }\n    piVar2 = *(iVar4 + 0x50);\n    if ((arg_8h != 0) && (piVar2 != NULL)) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar3) {\n            (**(*piVar2 + 0x178))(0xffffffff);\n        }\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "0040c02d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c02d(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (arg_8h == 3) {\n        fcn.0040c02d(0, arg_ch);\n        arg_8h = 1;\n    }\n    iVar1 = (**(*in_ECX + 0x78))(arg_8h);\n    if (iVar1 == 0) {\n        fcn.0040bb9d(arg_8h, arg_ch);\n    }\n    else {\n        fcn.00410af4(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 149
    },
    "0040c0ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040c0ba(uint XAmount, int32_t YAmount, int32_t arg_10h, int32_t lpClipRect)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint uVar4;\n    uint lpRect;\n    int32_t Y;\n    uint uStack12;\n    \n    iVar3 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x20));\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (((iVar3 == 0) && (arg_10h == 0)) && (lpClipRect == 0)) {\n        uVar4 = 5;\n        iVar3 = *(in_ECX + 0x20);\n        while (iVar3 = (*pcVar1)(iVar3, uVar4),  iVar3 != 0) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar3, &fcn.0040c0ba::lpRect);\n            uStack12 = 0x40c101;\n            fcn.00409ac3(&fcn.0040c0ba::lpRect);\n            iVar2 = Y;\n            uStack12 = 0x15;\n            Y = 0;\n            lpRect = 0;\n            (*_sym.imp.USER32.dll_SetWindowPos)(iVar3, 0, XAmount, iVar2 + YAmount);\n            uVar4 = 2;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_ScrollWindow)(*(in_ECX + 0x20), XAmount, YAmount, arg_10h, lpClipRect);\n    }\n    if ((*(in_ECX + 0x4c) != 0) && (arg_10h == 0)) {\n        (**(**(in_ECX + 0x4c) + 0x5c))(XAmount, YAmount);\n    }\n    return;\n}\n",
        "token_count": 438
    },
    "0040c166": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040c166(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (arg_8h == 0) {\n        iVar1 = fcn.004213ff();\n        if ((*(iVar1 + 0x48) != 0) && ((*(*(iVar1 + 0x48) + 4) & 0x40000000) == 0)) {\n            fcn.0040bdbf(1);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 114
    },
    "0040cb81": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040cb81(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t var_4h;\n    \n    iVar2 = 0;\n    if (*(param_1 + 0x4c) != 0) {\n        var_4h = *(*(param_1 + 0x4c) + 0x44);\n        while (var_4h != 0) {\n            piVar1 = fcn.0040b31f(&var_4h);\n            if ((*(*piVar1 + 4) != 0) && (*(*(*piVar1 + 4) + 0x74) != 0)) {\n                iVar2 = iVar2 + 1;\n            }\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 186
    },
    "0040cbc9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0040cbc9(uint arg_8h, uint noname_1, int32_t arg_10h, uint noname_3, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t *arg_20h, int32_t *arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0040b672(arg_18h, arg_1ch, arg_20h, arg_24h, arg_8h);\n    if (iVar1 < 0) {\n        fcn.0040b499(&var_4h);\n        iVar2 = fcn.0040cb81();\n        if (arg_10h <= iVar2 + var_4h) {\n            var_8h = *(*(in_ECX + 0x4c) + 0x44);\n            while (var_8h != 0) {\n                piVar3 = fcn.0040b31f(&var_8h);\n                iVar2 = *(*piVar3 + 4);\n                if (iVar2 != 0) {\n                    if (*(iVar2 + 0x74) != 0) {\n                        var_4h = var_4h + 1;\n                    }\n                    if (var_4h == arg_10h) {\n                        iVar1 = *(*piVar3 + 4);\n                        var_18h = *(iVar1 + 0x30);\n                        var_14h = *(iVar1 + 0x34);\n                        var_10h = *(iVar1 + 0x38);\n                        var_ch = *(iVar1 + 0x3c);\n                        fcn.00409b04(&var_18h);\n                        *arg_18h = var_18h;\n                        *arg_1ch = var_14h;\n                        *arg_20h = var_10h - var_18h;\n                        *arg_24h = var_ch - var_14h;\n                        iVar1 = 0;\n                    }\n                }\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 538
    },
    "0040d0a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040d0a9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(*(param_1 + 0xc));\n        *(param_1 + 4) = iVar1;\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryW)(*(param_1 + 0xc));\n            *(param_1 + 4) = iVar1;\n            *(param_1 + 8) = iVar1 != 0;\n        }\n    }\n    return *(param_1 + 4);\n}\n",
        "token_count": 162
    },
    "0040d0dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d0dd(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        uVar1 = fcn.0040d0a9(\"InitCommonControls\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x10) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x10);\n    return;\n}\n",
        "token_count": 130
    },
    "0040d16f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040d16f(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) != 2) {\n        fcn.00420b29(0, *(unaff_EBP + -0x1c));\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "0040d180": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d180(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) == 0) {\n        uVar1 = fcn.0040d0a9(\"InitCommonControlsEx\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x14) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x14);\n    return;\n}\n",
        "token_count": 130
    },
    "0040d224": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040d224(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "0040d25a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d25a(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        uVar1 = fcn.0040d0a9(\"InitNetworkAddressControl\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x10) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x10);\n    return;\n}\n",
        "token_count": 131
    },
    "0040d2f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0040d2f9(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "0040d3e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040d3e9(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    iVar1 = fcn.004213ff();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00406404(fcn.00421648);\n        iVar2 = fcn.0040641b(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.00422fd7(0x4485c8, 0x40d082, fcn.004096f6, 0x20, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar3;\n        fcn.00406404(arg_8h_00);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 328
    },
    "0040d516": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040d516(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.00422773(0x407aed);\n    if (iVar1 == 0) {\n        fcn.00407ad1();\n    }\n    iVar2 = fcn.004213cc();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x28) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x28));\n        *(iVar1 + 0x28) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 188
    },
    "0040d5a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040d5a0(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    \n    iVar2 = fcn.0041a73a();\n    if (iVar2 == 0) goto code_r0x0040d5ed;\n    if (*(iVar2 + 0x20) == param_1) {\n        iVar3 = fcn.004213cc();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.004213cc();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.00423c1c();\n                if (iVar3 == 0) goto code_r0x0040d5e2;\n            }\n            fcn.00417276(0);\n        }\ncode_r0x0040d5e2:\n        *(iVar2 + 0x20) = 0;\n    }\n    if (*(iVar2 + 0x24) == param_1) {\n        *(iVar2 + 0x24) = 0;\n    }\ncode_r0x0040d5ed:\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 0x50))();\n        param_1[0x12] = 0;\n    }\n    if (param_1[0x13] != NULL) {\n        (**(*param_1[0x13] + 4))(1);\n    }\n    param_1[0x13] = 0;\n    if ((*(param_1 + 0xf) & 1) != 0) {\n        iVar2 = fcn.004213ff();\n        iVar2 = *(iVar2 + 0x3c);\n        if ((iVar2 != 0) && (*(iVar2 + 0x20) != 0)) {\n            fcn.00430820(&var_30h, 0, 0x30);\n            var_28h = param_1[8];\n            var_30h = 0x2c;\n            var_2ch = 1;\n            var_24h = var_28h;\n            (*_sym.imp.USER32.dll_SendMessageW)(*(iVar2 + 0x20), 0x433, 0, &var_30h);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongW;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongW)(param_1[8], 0xfffffffc);\n    fcn.0040d3b7();\n    iVar3 = (*pcVar1)(param_1[8], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0xf8))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongW)(param_1[8], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.0040d4e6();\n    (**(*param_1 + 0x11c))();\n    return;\n}\n",
        "token_count": 748
    },
    "0040d822": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040d822(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h, int32_t *lprcDst, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t in_ECX;\n    int32_t hWinPosInfo;\n    int32_t lprcSrc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = arg_20h;\n    var_ch = 0;\n    var_10h = 0;\n    if (arg_1ch == NULL) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lprcSrc);\n    }\n    else {\n        lprcSrc = *arg_1ch;\n        var_1ch = arg_1ch[1];\n        var_18h = arg_1ch[2];\n        var_14h = arg_1ch[3];\n    }\n    uVar2 = arg_14h & 0xffff7fff;\n    if (uVar2 == 1) {\n        hWinPosInfo = 0;\n    }\n    else {\n        hWinPosInfo = (*_sym.imp.USER32.dll_BeginDeferWindowPos)(8);\n    }\n    for (iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(*(in_ECX + 0x20)); iVar3 != 0;\n        iVar3 = (*_sym.imp.USER32.dll_GetWindow)(iVar3, 2)) {\n        uVar4 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar3);\n        iVar5 = fcn.0040d489(iVar3);\n        iVar1 = iVar3;\n        if ((((uVar4 != arg_10h) && (iVar1 = var_4h,  arg_8h <= uVar4)) && (uVar4 <= arg_ch)) && (iVar5 != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageW)(iVar3, 0x361, 0, &hWinPosInfo);\n            iVar1 = var_4h;\n        }\n        var_4h = iVar1;\n    }\n    if (uVar2 == 1) {\n        if (arg_20h == 0) {\n            lprcDst[2] = var_10h;\n            lprcDst[1] = 0;\n            *lprcDst = 0;\n            lprcDst[3] = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_CopyRect)(lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        if ((arg_10h != 0) && (var_4h != 0)) {\n            piVar6 = fcn.0040d45d(var_4h);\n            if (uVar2 == 2) {\n                lprcSrc = lprcSrc + *lprcDst;\n                var_1ch = var_1ch + lprcDst[1];\n                var_18h = var_18h - lprcDst[2];\n                var_14h = var_14h - lprcDst[3];\n            }\n            if ((arg_14h & 0x8000) == 0) {\n                (**(*piVar6 + 0x68))(&lprcSrc, 0);\n                fcn.0040b33d(&hWinPosInfo, var_4h, &lprcSrc);\n            }\n        }\n        if (hWinPosInfo != 0) {\n            (*_sym.imp.USER32.dll_EndDeferWindowPos)(hWinPosInfo);\n        }\n    }\n    return;\n}\n",
        "token_count": 935
    },
    "00413dd3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00413dd3(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(param_1 + 0xb0) != 0) {\n        fcn.00410b1b();\n        return;\n    }\n    if ((*(param_1 + 0x4c) != 0) && (iVar1 = (**(**(param_1 + 0x4c) + 0x90))(),  iVar1 != 0)) {\n        return;\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 130
    },
    "0040da80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040da80(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 9) != '\\0') {\n        var_4h = NULL;\n        iVar2 = (**(*in_ECX + 0xec))(arg_8h, arg_ch, &var_4h);\n        if (-1 < iVar2) {\n            return var_4h;\n        }\n    }\n    piVar1 = fcn.0040d3b7();\n    return piVar1;\n}\n",
        "token_count": 164
    },
    "0040dba8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpVersionInformation\n\nvoid fcn.0040dba8(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint lpVersionInformation;\n    uint32_t var_114h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    iVar1 = fcn.004213cc();\n    if (iVar1 != 0) goto code_r0x0040dbce;\n    do {\n        fcn.00407ad1();\ncode_r0x0040dbce:\n        if (*(iVar1 + 0x88) != 0) goto code_r0x0040dc31;\n        fcn.00430820(&lpVersionInformation, 0, 0x114);\n        lpVersionInformation = 0x114;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetVersionExW)(&lpVersionInformation);\n    } while (iVar2 == 0);\n    if (5 < var_114h) {\n        fcn.004213cc();\n        uVar3 = fcn.0040d289();\n        *(iVar1 + 0x84) = uVar3;\n    }\n    *(iVar1 + 0x88) = 1;\ncode_r0x0040dc31:\n    fcn.0042e09f(lpVersionInformation);\n    return;\n}\n",
        "token_count": 318
    },
    "0040dd00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.0040dd00(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t extraout_EDX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_44h;\n    uint var_28h;\n    uint var_18h;\n    uint var_4h;\n    \n    fcn.00430ece(0x38);\n    iVar1 = fcn.00422773(0x407aed);\n    iVar4 = 0;\n    *(unaff_EBP + -0x18) = iVar1;\n    if (iVar1 == 0) {\n        fcn.00407ad1();\n        iVar4 = extraout_EDX;\n    }\n    puVar5 = iVar1 + 0x58;\n    puVar6 = unaff_EBP + -0x44;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(iVar1 + 0x58) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x60) = *(unaff_EBP + 0x14);\n    uVar2 = *(unaff_EBP + 0x18);\n    *(iVar1 + 0x5c) = iVar3;\n    *(iVar1 + 100) = uVar2;\n    *(unaff_EBP + -4) = iVar4;\n    if ((iVar3 == 2) && (arg_8h_00[0x13] != iVar4)) {\n        (**(*arg_8h_00[0x13] + 0x60))(iVar4);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.0040bce6(arg_8h_00, unaff_EBP + -0x28, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h_00 + 0x110))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.0040dc8a(arg_8h_00, unaff_EBP + -0x28, *(unaff_EBP + 8));\n    }\n    puVar5 = unaff_EBP + -0x44;\n    puVar6 = iVar1 + 0x58;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 803
    },
    "0040de40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0040de40(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[8] != NULL) && (extraout_ECX != 0x45f3d0)) && (extraout_ECX != 0x45f428)) &&\n       ((extraout_ECX != 0x45f480 && (extraout_ECX != 0x45f4d8)))) {\n        fcn.0040d6b3();\n    }\n    if (extraout_ECX[0x13] != NULL) {\n        (**(*extraout_ECX[0x13] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0x14];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x28) == extraout_ECX)) {\n        *(pcVar1 + 0x28) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00406838();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 342
    },
    "0040dee2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040dee2(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    \n    if (*arg_ch == 1) {\n        iVar1 = fcn.00422773(0x407aed);\n        if (iVar1 != 0) goto code_r0x0040df0b;\n        do {\n            iVar1 = fcn.00407ad1();\ncode_r0x0040df0b:\n            if (*(iVar1 + 0x74) == in_ECX[8]) {\n                iVar1 = fcn.004234aa();\n            }\n            else {\n                iVar1 = (**(*in_ECX + 0x6c))();\n            }\n        } while (iVar1 == 0);\n        piVar2 = fcn.0040be6b(iVar1, arg_ch[2]);\n        if (piVar2 != NULL) {\n            (**(*piVar2 + 0x10))(arg_ch);\n        }\n    }\n    else {\n        iVar1 = fcn.0040d7a9(in_ECX[8], arg_ch[1], 1);\n        if ((iVar1 != 0) && (iVar1 = fcn.0040d9b4(0),  iVar1 != 0)) {\n            return;\n        }\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 323
    },
    "0040dfaa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0040dfaa(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[8] != 0)) {\n        iVar2 = (**(*param_1 + 0x128))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.0040df6b();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.0040df6b();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 188
    },
    "0040dfeb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040dfeb(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageW)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.0040d489(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0040dd00(iVar2, *(iVar2 + 0x20), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0040dfeb(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 329
    },
    "0040e10a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040e10a(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    \n    if (((arg_8h == 1) || (arg_8h == 2)) && (iVar1 = fcn.0040e06a(arg_ch, 0),  iVar1 != 0)) {\n        return;\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 99
    },
    "0040e200": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040e200(int32_t arg_8h, int32_t arg_ch, ushort *arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t arg_ch_00;\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    if (*(in_ECX + 0x4c) != 0) {\n        var_8h = arg_8h;\n        var_4h = arg_ch;\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x20), &var_8h);\n        arg_ch = fcn.0040e166();\n        if (*(in_ECX + 0x4c) != 0) {\n            arg_8h = *(*(in_ECX + 0x4c) + 0x44);\n            while (arg_8h != 0) {\n                piVar1 = fcn.0040b31f(&arg_8h);\n                if ((*(*piVar1 + 4) != 0) && (*(*(*piVar1 + 4) + 0x74) != 0)) {\n                    arg_ch = arg_ch + 1;\n                    iVar2 = fcn.0040b1cd(var_8h, var_4h);\n                    if (iVar2 != 0) {\n                        *arg_10h = 3;\n                        *(arg_10h + 4) = arg_ch;\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    uVar3 = fcn.0040b6c8(arg_8h_00, arg_ch_00, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 452
    },
    "0040e2a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0040e2a5(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_8ch;\n    uint hWnd;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x80);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0040672c();\n    fcn.0040bca1();\n    uVar2 = *(extraout_ECX + 0x20);\n    *(unaff_EBP + -4) = 0;\n    iVar1 = (*_sym.imp.USER32.dll_GetTopWindow)(uVar2);\n    do {\n        if (iVar1 == 0) {\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(unaff_EBP + -0x6c) = 0;\n            fcn.0040de40();\n            fcn.00430f73();\n            return;\n        }\n        *(unaff_EBP + -0x6c) = iVar1;\n        uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar1);\n        *(unaff_EBP + -0x34) = uVar2;\n        *(unaff_EBP + -0x24) = unaff_EBP + -0x8c;\n        iVar3 = fcn.0040d489(iVar1);\n        if (iVar3 == 0) {\ncode_r0x0040e315:\n            iVar3 = fcn.004065a9(*(unaff_EBP + -0x34), 0xffffffff, unaff_EBP + -0x38, 0);\n            if (iVar3 == 0) {\n                iVar3 = *(unaff_EBP + 0xc);\n                if (iVar3 != 0) {\n                    uVar4 = (*_sym.imp.USER32.dll_SendMessageW)(*(unaff_EBP + -0x6c), 0x87, 0, 0);\n                    if ((uVar4 & 0x2000) != 0) {\n                        uVar4 = fcn.004109b6();\n                        uVar4 = uVar4 & 0xf;\n                        if ((((uVar4 != 3) && (uVar4 != 6)) && (uVar4 != 7)) && (uVar4 != 9)) goto code_r0x0040e36d;\n                    }\n                    iVar3 = 0;\n                }\ncode_r0x0040e36d:\n                fcn.00406752(*(unaff_EBP + 8), iVar3);\n            }\n        }\n        else {\n            iVar3 = fcn.004065a9(0, 0xbd11ffff, unaff_EBP + -0x38, 0);\n            if (iVar3 == 0) goto code_r0x0040e315;\n        }\n        iVar1 = (*_sym.imp.USER32.dll_GetWindow)(iVar1, 2);\n    } while( true );\n}\n",
        "token_count": 809
    },
    "0040e3a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040e3a6(uint hWnd)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.0040d4aa(hWnd);\n    if (iVar1 != 0) {\n        (**(*in_ECX + 0x50))();\n        piVar2 = (**(*in_ECX + 0xf8))();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongW)(hWnd, 0xfffffffc, fcn.0040ddf3);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 168
    },
    "0040e987": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040e987(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthW)(*(in_ECX + 0x20));\n        uVar2 = fcn.004052a0(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextW)(*(in_ECX + 0x20), uVar2);\n        fcn.0040d34f(0xffffffff);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0040e9cb. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x8c))();\n    return;\n}\n",
        "token_count": 209
    },
    "0040e9d1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040e9d1(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    if ((*arg_ch == 1) && (piVar1 = fcn.004234be(arg_ch[5]),  piVar1 != NULL)) {\n        (**(*piVar1 + 0xc))(arg_ch);\n        return;\n    }\n    iVar2 = fcn.0040e06a(arg_ch[5], 0);\n    if (iVar2 == 0) {\n        fcn.0040d3b7();\n    }\n    return;\n}\n",
        "token_count": 144
    },
    "0040ea64": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ea64(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    fcn.004214b9(0xc);\n    iVar1 = fcn.0042224f(0x40dc5a);\n    if (iVar1 == 0) {\n        fcn.00407ad1();\n    }\n    if (*(iVar1 + 8) == 0) {\n        iVar2 = fcn.0040bacf(\"hhctrl.ocx\");\n        *(iVar1 + 4) = iVar2;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"HtmlHelpW\");\n            *(iVar1 + 8) = iVar2;\n            if (iVar2 != 0) goto code_r0x0040eac9;\n            (*_sym.imp.KERNEL32.dll_FreeLibrary)(*(iVar1 + 4));\n            *(iVar1 + 4) = 0;\n        }\n        uVar3 = 0;\n    }\n    else {\ncode_r0x0040eac9:\n        fcn.0042152b(0xc);\n        uVar3 = (**(iVar1 + 8))(arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    return uVar3;\n}\n",
        "token_count": 323
    },
    "0040ee84": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040ee84(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    uVar1 = (**(**(param_1 + 0xc) + 0xc))(*(param_1 + 0xc), 0);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "0040ee99": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ee99(int32_t *arg_8h)\n\n{\n    uint uVar1;\n    \n    if ((((*arg_8h == 0) && (arg_8h[1] == 0)) && (arg_8h[2] == 0xc0)) && (arg_8h[3] == 0x46000000)) {\n        uVar1 = 1;\n    }\n    else {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 116
    },
    "0040eec9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040eec9(int32_t arg_8h, int32_t *arg_ch, uint arg_10h, int32_t **arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if ((arg_8h == 0) || (arg_ch == NULL)) {\n        iVar2 = -0x7ff8ffa9;\n    }\n    else if (arg_14h == NULL) {\n        iVar2 = -0x7fffbffd;\n    }\n    else {\n        *arg_14h = NULL;\n        iVar2 = fcn.0040ee99(arg_10h);\n        if (iVar2 == 0) {\n            for (; pcVar1 = arg_ch[2],  pcVar1 != NULL; arg_ch = arg_ch + 3) {\n                iVar2 = *arg_ch;\n                if ((iVar2 == 0) || (iVar3 = fcn.0040ee45(iVar2, arg_10h),  iVar3 != 0)) {\n                    if (pcVar1 == 0x1) goto code_r0x0040eeff;\n                    iVar3 = (*pcVar1)(arg_8h, arg_10h, arg_14h, arg_ch[1]);\n                    if (iVar3 == 0) {\n                        return 0;\n                    }\n                    if ((iVar2 != 0) && (iVar3 < 0)) {\n                        return iVar3;\n                    }\n                }\n            }\n            iVar2 = -0x7fffbffe;\n        }\n        else {\ncode_r0x0040eeff:\n            piVar4 = arg_ch[1] + arg_8h;\n            (**(*piVar4 + 4))(piVar4);\n            *arg_14h = piVar4;\n            iVar2 = 0;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 429
    },
    "0040ef86": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ef86(code **param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    param_1[5] = 0xc0000001;\n    fcn.0040ee84();\n    iVar2 = fcn.004213cc();\n    iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(iVar2 + 0x2c);\n    if (iVar2 != 0) {\n        return;\n    }\n    iVar2 = fcn.004213cc();\n    if (*(iVar2 + 0x30) == 0) {\n        fcn.00423c3c(1);\n        iVar2 = fcn.004213cc();\n        iVar2 = *(iVar2 + 4);\n        if ((iVar2 == 0) || (*(iVar2 + 0x20) == 0)) {\n            iVar2 = fcn.004213cc();\n            if (*(iVar2 + 0x14) == '\\0') {\n                fcn.00417276(0);\n            }\n        }\n        else {\n            iVar1 = fcn.00410ad9();\n            if (iVar1 != 0) {\n    // WARNING: Could not recover jumptable at 0x00423c8e. Too many branches\n    // WARNING: Treating indirect jump as call\n                (**(**(iVar2 + 0x20) + 0x60))();\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 407
    },
    "0040f4b1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f4b1(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.00422773(0x407aed);\n    if (iVar1 == 0) {\n        fcn.00407ad1();\n    }\n    if (*(iVar1 + 0x14) != arg_8h) {\n        if (*(iVar1 + 0x28) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExW)(5, 0x40f291, 0, uVar2);\n            *(iVar1 + 0x28) = iVar3;\n            if (iVar3 == 0) {\n                fcn.00407a99();\n            }\n        }\n        *(iVar1 + 0x14) = arg_8h;\n    }\n    return;\n}\n",
        "token_count": 223
    },
    "0040f668": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0040f668(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    code **ppcVar6;\n    uint32_t uVar7;\n    int32_t *arg_8h_00;\n    code *pcVar8;\n    int32_t unaff_EBP;\n    int16_t iVar9;\n    int16_t iVar10;\n    uint var_7ch;\n    uint var_5ch;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint *var_24h;\n    uint *var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x70);\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = 0x7fffffff;\n    uVar7 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    if (uVar7 == 0x111) {\n        iVar3 = (**(*arg_8h_00 + 0xf0))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar3 == 0) goto code_r0x0040f878;\n        goto code_r0x0040f6a6;\n    }\n    if (uVar7 == 0x4e) {\n        if (**(unaff_EBP + 0x10) != 0) {\n            iVar3 = (**(*arg_8h_00 + 0xf4))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\n            goto joined_r0x0040fb51;\n        }\n        goto code_r0x0040f878;\n    }\n    var_24h = *(unaff_EBP + 0x10);\n    if (uVar7 == 6) {\n        uVar4 = fcn.0040d45d(var_24h);\n        fcn.0040f054(arg_8h_00, *(unaff_EBP + 0xc), uVar4);\n    }\n    iVar9 = var_24h;\n    if ((uVar7 == 0x20) && (iVar3 = fcn.0040f0cc(arg_8h_00, iVar9, var_24h >> 0x10),  iVar3 != 0))\n    goto code_r0x0040f6a6;\n    if ((((arg_8h_00[0x13] != 0) && (0 < *(arg_8h_00[0x13] + 0x74))) &&\n        ((((0x1ff < uVar7 && (uVar7 < 0x20a)) || ((0xff < uVar7 && (uVar7 < 0x110)))) || (uVar7 - 0x281 < 0x11)))) &&\n       (iVar3 = (**(*arg_8h_00[0x13] + 0x94))(uVar7, *(unaff_EBP + 0xc), var_24h, unaff_EBP + -0x10),  iVar3 != 0))\n    goto code_r0x0040fc0a;\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    uVar7 = *(unaff_EBP + 8);\n    *(unaff_EBP + 0x10) = uVar5;\n    fcn.0040bc3c(7);\n    iVar3 = ((uVar5 ^ uVar7) & 0x1ff) * 0xc;\n    *(unaff_EBP + -0x18) = iVar3 + 0x45dba0;\n    if ((*(unaff_EBP + 8) != *(iVar3 + 0x45dba0)) || (*(unaff_EBP + 0x10) != *(iVar3 + 0x45dba8))) {\n        puVar1 = *(unaff_EBP + -0x18);\n        ppcVar6 = *(unaff_EBP + 0x10);\n        *puVar1 = *(unaff_EBP + 8);\n        puVar1[2] = ppcVar6;\n        while (*ppcVar6 != NULL) {\n            if (*(unaff_EBP + 8) < 0xc000) {\n                iVar3 = fcn.0040b1e3(ppcVar6[1], *(unaff_EBP + 8), 0, 0);\n                *(unaff_EBP + 0x10) = iVar3;\n                if (iVar3 != 0) {\n                    *(*(unaff_EBP + -0x18) + 4) = iVar3;\n                    fcn.0040bc70();\n                    goto code_r0x0040f806;\n                }\n            }\n            else {\n                iVar3 = *(*(unaff_EBP + 0x10) + 4);\n                uVar4 = 0xc000;\n                while (iVar3 = fcn.0040b1e3(iVar3, uVar4, 0, 0),  iVar3 != 0) {\n                    if (**(iVar3 + 0x10) == *(unaff_EBP + 8)) {\n                        *(*(unaff_EBP + -0x18) + 4) = iVar3;\n                        fcn.0040bc70();\n                        goto code_r0x0040fbfc;\n                    }\n                    iVar3 = iVar3 + 0x18;\n                }\n                ppcVar6 = *(unaff_EBP + 0x10);\n            }\n            ppcVar6 = (**ppcVar6)();\n            *(unaff_EBP + 0x10) = ppcVar6;\n        }\n        *(*(unaff_EBP + -0x18) + 4) = 0;\n        fcn.0040bc70();\n        goto code_r0x0040f878;\n    }\n    iVar3 = *(iVar3 + 0x45dba4);\n    *(unaff_EBP + 0x10) = iVar3;\n    fcn.0040bc70();\n    if (iVar3 == 0) goto code_r0x0040f878;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x0040fbfc:\n        pcVar8 = *(iVar3 + 0x14);\n        goto code_r0x0040fc00;\n    }\ncode_r0x0040f806:\n    pcVar8 = *(*(unaff_EBP + 0x10) + 0x14);\n    iVar3 = *(*(unaff_EBP + 0x10) + 0x10);\n    iVar10 = var_24h >> 0x10;\n    var_14h = var_24h;\n    // switch table (84 cases) at 0x40fc2c\n    switch(iVar3) {\n    case 1:\n        var_14h = *(unaff_EBP + 0xc);\n        fcn.00409c2f(var_14h);\n        goto code_r0x0040f8a7;\n    case 2:\n    case 3:\n    case 4:\n    case 0x1b:\n    case 0x1c:\n        var_14h = *(unaff_EBP + 0xc);\n        goto code_r0x0040f8a7;\n    case 5:\n    case 0xc:\n        var_14h = var_24h >> 0x10;\n        var_18h = var_24h & 0xffff;\n        uVar7 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.0040d45d(uVar7);\n        goto code_r0x0040f8dc;\n    case 6:\n    case 0x47:\n        var_24h = *(unaff_EBP + 0xc);\n        var_28h = fcn.0040d45d(var_24h);\n        goto code_r0x0040fc03;\n    case 7:\n    case 0xd:\n    case 0x4a:\ncode_r0x0040f8a7:\n        uVar4 = (*pcVar8)(var_14h);\n        goto code_r0x0040fc07;\n    case 8:\n        fcn.00409766();\n        uVar4 = var_24h[1];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x24) = uVar4;\n        fcn.0040bca1();\n        uVar4 = *var_24h;\n        uVar2 = var_24h[2];\n        *(unaff_EBP + -4) = 2;\n        *(unaff_EBP + -0x5c) = uVar4;\n        iVar3 = fcn.0040d489(uVar4);\n        if (iVar3 == 0) {\n            if ((arg_8h_00[0x13] != 0) && (iVar3 = fcn.00422d89(*(unaff_EBP + -0x5c)),  iVar3 != 0)) {\n                *(unaff_EBP + -0x2c) = iVar3;\n            }\n            iVar3 = unaff_EBP + -0x7c;\n        }\n        uVar4 = (*pcVar8)(unaff_EBP + -0x28, iVar3, uVar2);\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x5c) = 0;\n        *(unaff_EBP + -0x10) = uVar4;\n        *(unaff_EBP + -4) = 1;\n        fcn.0040de40();\n        goto code_r0x0040f961;\n    case 9:\n        fcn.00409766();\n        uVar4 = var_24h[2];\n        *(unaff_EBP + -0x24) = var_24h[1];\n        *(unaff_EBP + -4) = 3;\n        uVar4 = (*pcVar8)(unaff_EBP + -0x28, uVar4);\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x10) = uVar4;\ncode_r0x0040f961:\n        *(unaff_EBP + -4) = 0;\n        fcn.00409cac();\n        break;\n    case 10:\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = fcn.0040d45d(var_24h);\n        var_18h = var_24h;\n        goto code_r0x0040f9a5;\n    case 0xb:\n        var_24h = *(unaff_EBP + 0xc) >> 0x10;\n        var_28h = *(unaff_EBP + 0xc);\n        goto code_r0x0040fc03;\n    case 0xe:\n    case 0x2f:\n    case 0x4f:\n        goto code_r0x0040fc00;\n    case 0xf:\n        var_18h = fcn.004234aa(var_24h);\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0040f9a5:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x0040f8dc:\n        uVar4 = (*pcVar8)(uVar5, uVar7, var_18h, var_14h);\n        goto code_r0x0040fc07;\n    case 0x10:\n    case 0x12:\n    case 0x15:\n    case 0x1e:\n    case 0x2d:\n    case 0x32:\n    case 0x4c:\n    case 0x53:\n        goto code_r0x0040fbe5;\n    case 0x11:\n    case 0x14:\n    case 0x54:\n        var_14h = *(unaff_EBP + 0xc);\n        goto code_r0x0040f9d1;\n    case 0x13:\n        (*pcVar8)();\n        break;\n    case 0x16:\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        var_18h = *(unaff_EBP + 0xc);\n        goto code_r0x0040fbe8;\n    case 0x17:\n        var_14h = iVar10;\n        var_18h = iVar9;\n        goto code_r0x0040fbe8;\n    case 0x18:\n    case 0x19:\n        var_14h = var_24h >> 0x10;\n        var_18h = var_24h & 0xffff;\n        goto code_r0x0040fa09;\n    case 0x1a:\n        fcn.0040d45d(var_24h);\n        goto code_r0x0040fbe5;\n    case 0x1d:\n    case 0x28:\n    case 0x31:\n        uVar4 = (*pcVar8)();\n        goto code_r0x0040fc07;\n    case 0x1f:\n        var_14h = *(unaff_EBP + 0xc);\n        var_18h = fcn.0040d45d(var_14h);\n        fcn.0040d45d(var_24h);\n        uVar7 = arg_8h_00[8] == var_24h;\n        goto code_r0x0040fa0d;\n    case 0x20:\n        var_14h = *(unaff_EBP + 0xc);\n        fcn.00409c2f(var_14h);\n        goto code_r0x0040f9d1;\n    case 0x21:\n        var_14h = *(unaff_EBP + 0xc);\n        fcn.004234aa(var_14h);\n        goto code_r0x0040f9d1;\n    case 0x22:\n        var_14h = iVar10;\n        var_18h = iVar9;\n        uVar7 = fcn.004234aa(*(unaff_EBP + 0xc), var_18h, var_14h);\n        goto code_r0x0040fa0d;\n    case 0x23:\n        var_14h = *(unaff_EBP + 0xc);\n        goto code_r0x0040fa5e;\n    case 0x24:\ncode_r0x0040fa5e:\n        fcn.0040d45d(var_14h);\n        goto code_r0x0040f9d1;\n    case 0x25:\n        var_14h = var_24h >> 0x10;\n        var_18h = var_24h & 0xffff;\n        goto code_r0x0040fa71;\n    case 0x26:\n        var_18h = iVar9;\n        var_14h = iVar10;\ncode_r0x0040fa71:\n        uVar7 = fcn.0040d45d(*(unaff_EBP + 0xc));\n        goto code_r0x0040fa0d;\n    case 0x27:\n        var_18h = fcn.0040d45d(*(unaff_EBP + 0xc));\n        goto code_r0x0040fbe8;\n    case 0x29:\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        var_18h = fcn.0040d45d(var_24h);\n        goto code_r0x0040faa3;\n    case 0x2a:\n    case 0x2b:\n        var_18h = *(unaff_EBP + 0xc);\n        var_14h = *(unaff_EBP + 0xc) >> 0x10;\n        *(unaff_EBP + 8) = var_18h;\n        *(unaff_EBP + 0xc) = var_14h;\n        if (iVar3 == 0x2a) {\n            var_18h = fcn.0040d45d(var_24h);\n            uVar7 = *(unaff_EBP + 0xc);\n            var_14h = var_24h;\n            goto code_r0x0040fa0d;\n        }\n        goto code_r0x0040fbe8;\n    case 0x2c:\n    case 0x33:\ncode_r0x0040f9d1:\n        (*pcVar8)(var_14h);\n        break;\n    case 0x2e:\n    case 0x36:\n    case 0x52:\n        (*pcVar8)(*(unaff_EBP + 0xc), var_24h);\n        goto code_r0x0040f6a6;\n    case 0x30:\n    case 0x46:\n        var_28h = iVar9;\n        var_24h = iVar10;\n        goto code_r0x0040fc03;\n    case 0x34:\n        var_18h = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x0040faa3:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0040fa0d;\n    case 0x35:\n        var_18h = iVar9;\n        var_14h = iVar10;\ncode_r0x0040fa09:\n        uVar7 = *(unaff_EBP + 0xc);\ncode_r0x0040fa0d:\n        (*pcVar8)(uVar7, var_18h, var_14h);\n        break;\n    case 0x37:\n        iVar3 = (*pcVar8)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, iVar9, iVar10);\n        *(unaff_EBP + -0x10) = iVar3;\n        goto joined_r0x0040fb51;\n    case 0x38:\n        (*pcVar8)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, iVar9, iVar10);\n        break;\n    case 0x45:\n        iVar3 = (*pcVar8)();\n        *(unaff_EBP + -0x10) = iVar3;\njoined_r0x0040fb51:\n        if (iVar3 != 0) {\ncode_r0x0040f878:\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0040bc70();\n            goto code_r0x0040f886;\n        }\n        break;\n    case 0x48:\n        fcn.004234aa(var_24h);\ncode_r0x0040fbe5:\n        var_18h = *(unaff_EBP + 0xc);\n        goto code_r0x0040fbe8;\n    case 0x49:\n        var_24h = fcn.004234aa(var_24h);\n        goto code_r0x0040fc00;\n    case 0x4b:\n        var_18h = fcn.004234aa(*(unaff_EBP + 0xc), var_24h);\n        goto code_r0x0040fbe8;\n    case 0x4d:\n        var_14h = var_24h & 0xffff;\n        var_18h = var_24h >> 0x10 & 0xf000;\n        uVar5 = var_24h >> 0x10 & 0xfff;\n        uVar7 = fcn.0040d45d(*(unaff_EBP + 0xc));\n        goto code_r0x0040fba2;\n    case 0x4e:\n        var_18h = *(unaff_EBP + 0xc);\ncode_r0x0040fbe8:\n        (*pcVar8)(var_18h, var_14h);\n        break;\n    case 0x50:\n        var_18h = iVar9;\n        var_14h = iVar10;\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0040fba2;\n    case 0x51:\n        var_18h = iVar9;\n        var_14h = iVar10;\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\ncode_r0x0040fba2:\n        (*pcVar8)(uVar7, uVar5, var_18h, var_14h);\ncode_r0x0040f6a6:\n        *(unaff_EBP + -0x10) = 1;\n    }\ncode_r0x0040fc0a:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040bc70();\ncode_r0x0040f886:\n    fcn.00430f73();\n    return;\ncode_r0x0040fc00:\n    var_28h = *(unaff_EBP + 0xc);\ncode_r0x0040fc03:\n    uVar4 = (*pcVar8)(var_28h, var_24h);\ncode_r0x0040fc07:\n    *(unaff_EBP + -0x10) = uVar4;\n    goto code_r0x0040fc0a;\n}\n",
        "token_count": 5045
    },
    "00410239": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00410239(uint arg_8h)\n\n{\n    int32_t lpWndClass;\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_38h;\n    uint var_4h;\n    \n    fcn.00430ece(0x30);\n    lpWndClass = *(unaff_EBP + 8);\n    iVar2 = fcn.0040b8f8(*(lpWndClass + 0x10), *(lpWndClass + 0x24), unaff_EBP + -0x38);\n    if (((iVar2 == 0) && (iVar1 = fcn.0040b866(lpWndClass),  iVar1 != 0)) &&\n       (iVar2 = fcn.004213cc(),  *(iVar2 + 0x14) != '\\0')) {\n        fcn.004214b9(1);\n        *(unaff_EBP + -4) = 0;\n        fcn.004213cc();\n        fcn.004090e2(*(lpWndClass + 0x24));\n        fcn.00405240(10);\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042152b(1);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 310
    },
    "0041082e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041082e(int32_t arg_8h)\n\n{\n    if (*(arg_8h + 0x28) == 0) {\n        fcn.0041053c(1);\n        *(arg_8h + 0x28) = L\"AfxWnd90su\";\n    }\n    return 1;\n}\n",
        "token_count": 77
    },
    "004108cb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004108cb(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) != 0) {\n    // WARNING: Could not recover jumptable at 0x004108dc. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x4c) + 0x98))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "004108e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004108e8(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) != 0) {\n    // WARNING: Could not recover jumptable at 0x004108f9. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x4c) + 0x54))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 117
    },
    "00410902": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410902(uint nIDDlgItem)\n\n{\n    uint arg_8h;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        arg_8h = (*_sym.imp.USER32.dll_GetDlgItem)(*(in_ECX + 0x20), nIDDlgItem);\n        fcn.0040d45d(arg_8h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410929. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x74))();\n    return;\n}\n",
        "token_count": 159
    },
    "0041092c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041092c(uint nIDDlgItem, uint *arg_ch)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(in_ECX + 0x20), nIDDlgItem);\n        *arg_ch = uVar1;\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410952. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x70))();\n    return;\n}\n",
        "token_count": 158
    },
    "00410955": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410955(uint nIDDlgItem, uint lpString)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_SetDlgItemTextW)(*(in_ECX + 0x20), nIDDlgItem, lpString);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410979. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x88))();\n    return;\n}\n",
        "token_count": 142
    },
    "004109b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004109b6(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongW)(*(param_1 + 0x20), 0xfffffff0);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004109cd. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0x78))();\n    return;\n}\n",
        "token_count": 127
    },
    "004109d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004109d0(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongW)(*(param_1 + 0x20), 0xffffffec);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004109e7. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0x7c))();\n    return;\n}\n",
        "token_count": 128
    },
    "004109ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004109ea(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        fcn.0040b093(*(in_ECX + 0x20), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410a10. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x80))();\n    return;\n}\n",
        "token_count": 147
    },
    "00410a16": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410a16(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        fcn.0040b0af(*(in_ECX + 0x20), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410a3c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x84))();\n    return;\n}\n",
        "token_count": 150
    },
    "00410a42": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410a42(uint lpString)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (in_ECX != 0) goto code_r0x00410a53;\n    while( true ) {\n        fcn.00407ad1();\ncode_r0x00410a53:\n        iVar1 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x20));\n        if (iVar1 != 0) break;\n        if (*(in_ECX + 0x50) != 0) {\ncode_r0x00410a65:\n    // WARNING: Could not recover jumptable at 0x00410a6c. Too many branches\n    // WARNING: Treating indirect jump as call\n            (**(**(in_ECX + 0x50) + 0x88))();\n            return;\n        }\n    }\n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowTextW)(*(in_ECX + 0x20), lpString);\n        return;\n    }\n    goto code_r0x00410a65;\n}\n",
        "token_count": 258
    },
    "00410a89": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410a89(uint dwNewLong)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongW)(*(in_ECX + 0x20), 0xfffffff4, dwNewLong);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410aac. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x94))();\n    return;\n}\n",
        "token_count": 138
    },
    "00410ab2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410ab2(uint nCmdShow)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(*(in_ECX + 0x20), nCmdShow);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410ad3. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0xa0))();\n    return;\n}\n",
        "token_count": 131
    },
    "00410ad9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410ad9(int32_t param_1)\n\n{\n    if (*(param_1 + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x20));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410aee. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0xa4))();\n    return;\n}\n",
        "token_count": 121
    },
    "00410af4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410af4(uint bEnable)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(*(in_ECX + 0x20), bEnable);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410b15. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0xa8))();\n    return;\n}\n",
        "token_count": 129
    },
    "00410b1b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410b1b(int32_t param_1)\n\n{\n    uint arg_8h;\n    \n    if (*(param_1 + 0x50) == 0) {\n        arg_8h = (*_sym.imp.USER32.dll_SetFocus)(*(param_1 + 0x20));\n        fcn.0040d45d(arg_8h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410b36. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x50) + 0xb0))();\n    return;\n}\n",
        "token_count": 148
    },
    "00410b5a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410b5a(int32_t arg_8h, uint X, uint Y, uint cx, uint cy, uint uFlags)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        if (arg_8h != 0) {\n            arg_8h = *(arg_8h + 0x20);\n        }\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(in_ECX + 0x20), arg_8h, X, Y, cx, cy, uFlags);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00410b92. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x50) + 0x9c))();\n    return;\n}\n",
        "token_count": 196
    },
    "00410b98": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410b98(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((in_ECX != 0) && (*(in_ECX + 0x50) == 0)) {\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        iVar1 = fcn.00422d89(arg_8h_00);\n        if ((iVar1 != 0) && (*(iVar1 + 0x4c) != 0)) {\n            (**(**(iVar1 + 0x4c) + 0x9c))();\n        }\n    }\n    return;\n}\n",
        "token_count": 169
    },
    "00410c4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00410c4f(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t arg_10h_00;\n    \n    if (arg_ch == 0) {\ncode_r0x00410c5c:\n        uVar1 = 0;\n    }\n    else {\n        while (arg_10h != 0) {\n            arg_10h = arg_10h + -1;\n            arg_ch = fcn.0043151a(arg_ch, arg_14h);\n            if (arg_ch == 0) {\n                fcn.00401a10();\n                goto code_r0x00410c5c;\n            }\n            arg_ch = arg_ch + 2;\n        }\n        iVar2 = fcn.0043151a(arg_ch, arg_14h);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_ch);\n        }\n        else {\n            iVar2 = iVar2 - arg_ch >> 1;\n        }\n        arg_10h_00 = iVar2 * 2;\n        uVar1 = fcn.004052a0();\n        fcn.00408f79(uVar1, iVar2, arg_10h_00, arg_ch);\n        fcn.0040d34f(0xffffffff);\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 337
    },
    "00410dce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410dce(int32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    int32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0x60))();\n    while (var_4h != 0) {\n        piVar1 = (**(*in_ECX + 100))(&var_4h);\n        if (piVar1 != arg_8h) {\n            (**(*piVar1 + 0x170))(arg_8h, arg_ch, arg_10h);\n        }\n    }\n    return;\n}\n",
        "token_count": 155
    },
    "00410e80": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00410e80(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x38);\n    while (iVar1 != 0) {\n        iVar1 = fcn.00423ce5();\n        *(iVar1 + 0x54) = 0;\n        iVar1 = *(param_1 + 0x38);\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "0041118d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041118d(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 3;\n    fcn.00410e80();\n    if (*(extraout_ECX + 0x28) != 0) {\n        (**(**(extraout_ECX + 0x28) + 0x60))(extraout_ECX);\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.00423dac();\n    fcn.00401020();\n    fcn.00401020();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00406838();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 233
    },
    "004112b3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004112b3(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint arg_10h_00;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    if (arg_10h < 0) {\n        arg_10h = 0;\n    }\n    iVar1 = *(*in_ECX + -0xc);\n    iVar2 = fcn.00411096(arg_ch, arg_10h);\n    if (iVar1 < iVar2) {\n        arg_10h = *(*in_ECX + -0xc) - arg_ch;\n    }\n    iVar1 = *in_ECX;\n    iVar2 = *(iVar1 + -0xc);\n    if (iVar2 < arg_ch) {\n        arg_10h = 0;\n    }\n    if ((arg_ch == 0) && (arg_10h == iVar2)) {\n        fcn.004052f0();\n    }\n    else {\n        arg_10h_00 = fcn.004110fa();\n        fcn.0041111d(iVar1 + arg_ch * 2, arg_10h, arg_10h_00);\n    }\n    return arg_8h;\n}\n",
        "token_count": 307
    },
    "00411d9c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00411d9c(uint arg_8h, int16_t *arg_ch, int32_t *arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t arg_10h_00;\n    uint uVar5;\n    int32_t *in_ECX;\n    int32_t extraout_ECX;\n    uint var_4h;\n    \n    iVar4 = *arg_10h;\n    if (iVar4 < 0) {\n        fcn.00401000(0x80070057);\n        iVar4 = extraout_ECX;\n    }\n    if ((arg_ch == NULL) || (*arg_ch == 0)) {\n        iVar3 = *in_ECX;\n        if (iVar4 < *(iVar3 + -0xc)) {\n            uVar5 = fcn.004110fa();\n            fcn.004119d6(iVar3 + *arg_10h * 2, uVar5);\n            return arg_8h;\n        }\n    }\n    else {\n        iVar3 = *in_ECX;\n        uVar1 = iVar3 + iVar4 * 2;\n        uVar2 = iVar3 + *(iVar3 + -0xc) * 2;\n        if (uVar1 < uVar2) {\n            iVar4 = fcn.00431583(uVar1, arg_ch);\n            uVar1 = uVar1 + iVar4 * 2;\n            if (uVar1 < uVar2) {\n                arg_10h_00 = fcn.004315cc(uVar1, arg_ch);\n                iVar3 = *arg_10h;\n                *arg_10h = iVar3 + iVar4 + 1 + arg_10h_00;\n                fcn.004112b3(arg_8h, iVar3 + iVar4, arg_10h_00);\n                return arg_8h;\n            }\n        }\n    }\n    *arg_10h = -1;\n    uVar5 = fcn.004110fa();\n    fcn.004110e3(uVar5);\n    return arg_8h;\n}\n",
        "token_count": 479
    },
    "004124fa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004124fa(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    fcn.0041092c(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        iVar2 = fcn.004108e8(iVar1);\n        if (iVar2 == 0) {\n            fcn.00407ab5();\n        }\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = iVar1;\n    return arg_8h;\n}\n",
        "token_count": 157
    },
    "0041253b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041253b(int32_t *param_1)\n\n{\n    int32_t *hWnd;\n    \n    hWnd = param_1;\n    if ((*param_1 != 0) && (param_1[2] != 0)) {\n        fcn.0041092c(param_1[2], &hWnd);\n        if (hWnd != NULL) {\n            (*_sym.imp.USER32.dll_SetFocus)(hWnd);\n            if (param_1[3] != 0) {\n                (*_sym.imp.USER32.dll_SendMessageW)(hWnd, 0xb1, 0, 0xffffffff);\n            }\n        }\n    }\n    fcn.004096da();\n    return;\n}\n",
        "token_count": 159
    },
    "004125a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004125a8(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint uVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t *piVar4;\n    uint unaff_EDI;\n    uint var_88h;\n    uint lpString;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    arg_8h_00 = fcn.0041258c(arg_ch);\n    uVar1 = arg_18h;\n    if (*arg_8h == 0) {\n        puVar3 = fcn.0043147b();\n        uVar1 = *puVar3;\n        puVar3 = fcn.0043147b();\n        *puVar3 = 0;\n        fcn.0042e42a(&lpString, 0x40, 0x3f, arg_10h, &arg_18h);\n        piVar4 = fcn.0043147b();\n        if (*piVar4 == 0) {\n            puVar3 = fcn.0043147b();\n            *puVar3 = uVar1;\n        }\n        else {\n            puVar3 = fcn.0043147b();\n            fcn.0040904e(*puVar3);\n        }\n        fcn.00421550(arg_8h_00, &lpString);\n    }\n    else {\n        (*_sym.imp.USER32.dll_GetWindowTextW)(arg_8h_00, &lpString, 0x40);\n        iVar2 = fcn.004316bf(&lpString, 0x40, arg_10h, uVar1);\n        if (iVar2 != 1) {\n            fcn.0040797a(arg_14h, 0, 0xffffffff);\n            fcn.0041253b();\n        }\n    }\n    fcn.0042e09f(unaff_EDI);\n    return;\n}\n",
        "token_count": 469
    },
    "00412682": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412682(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.004125a8(arg_8h, arg_ch, 0x44f86c, 0xf117, arg_10h);\n    return;\n}\n",
        "token_count": 95
    },
    "004126b3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004126b3(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    \n    arg_8h_00 = fcn.0041258c(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.00421550(arg_8h_00, *arg_10h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthW)(arg_8h_00);\n        uVar2 = fcn.004052a0(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextW)(arg_8h_00, uVar2);\n        fcn.0040d34f(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "004127f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004127f0(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    if (arg_8h != 1) {\n        (**(*in_ECX + 0x150))(1);\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "00412809": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00412809(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0xb4) == 0) || (arg_8h != 0x2d)) {\n        uVar1 = fcn.0040d3b7();\n    }\n    else {\n        uVar1 = 0;\n    }\n    return uVar1;\n}\n",
        "token_count": 102
    },
    "0041282a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041282a(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0xe8) == 0) {\n        if (arg_8h != NULL) {\n            *arg_8h = 0;\n        }\n        iVar1 = 0;\n    }\n    else {\n        uVar2 = (*_sym.imp.USER32.dll_SendMessageW)(*(in_ECX + 0xe8), 0x229, 0, arg_8h);\n        iVar1 = fcn.0040d489(uVar2);\n        if ((((iVar1 != 0) && (*(iVar1 + 0xec) != 0)) && (uVar3 = fcn.004109b6(),  (uVar3 & 0x10000000) == 0)) &&\n           (iVar1 = 0,  arg_8h != NULL)) {\n            *arg_8h = 0;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 248
    },
    "00412cfd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00412cfd(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((arg_ch == 0) && (iVar1 = fcn.0040b7f2(),  iVar1 != 0)) {\n        arg_ch = *(in_ECX + 0xa8) + 0x10000;\n    }\n    iVar1 = fcn.0041282a(0);\n    if (((iVar1 == 0) || (iVar1 = fcn.0040dd00(iVar1, *(iVar1 + 0x20), 0x365, arg_8h, arg_ch),  iVar1 == 0)) &&\n       (iVar1 = fcn.00414286(arg_8h, arg_ch),  iVar1 == 0)) {\n        if ((arg_ch == 0) || (iVar1 = fcn.004213cc(),  *(iVar1 + 4) == 0)) {\n            return 0;\n        }\n        iVar1 = fcn.004213cc();\n        (**(**(iVar1 + 4) + 0xac))(arg_ch, 1);\n    }\n    return 1;\n}\n",
        "token_count": 272
    },
    "004134a7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004134a7(int32_t arg_8h, int32_t arg_ch)\n\n{\n    bool bVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    in_ECX[0x3b] = 0;\n    fcn.00413206(0);\n    piVar2 = fcn.00413d6e();\n    if ((arg_8h == 0) && (piVar2 != NULL)) {\n        (**(*piVar2 + 0x168))(0, piVar2, piVar2);\n    }\n    bVar1 = false;\n    if (in_ECX[0x20] != NULL) {\n        iVar3 = (**(*in_ECX[0x20] + 0x5c))(arg_8h);\n        if (iVar3 != 0) {\n            bVar1 = true;\n            goto code_r0x0041351b;\n        }\n    }\n    uVar4 = 0;\n    if ((arg_8h != 0) || (arg_ch != 0)) {\n        uVar4 = 1;\n    }\n    (**(*in_ECX + 0x178))(uVar4);\ncode_r0x0041351b:\n    if ((arg_8h != 0) && (piVar2 != NULL)) {\n        uVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        iVar3 = fcn.0040d45d(uVar4);\n        iVar5 = fcn.004129ba();\n        if (iVar5 == iVar3) {\n            (**(*piVar2 + 0x168))(1, piVar2, piVar2);\n        }\n    }\n    if (!bVar1) {\n        (**(*in_ECX + 0x198))(arg_8h, arg_ch, 0);\n        iVar3 = fcn.004129ba();\n        (*_sym.imp.USER32.dll_DrawMenuBar)(*(iVar3 + 0x20));\n    }\n    return;\n}\n",
        "token_count": 470
    },
    "00413bb1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413bb1(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_ch;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    arg_ch = (*_sym.imp.USER32.dll_GetWindow)(uVar2);\n    pcVar1 = _sym.imp.USER32.dll_ShowWindow;\n    for (; arg_ch != 0; arg_ch = (*_sym.imp.USER32.dll_GetWindow)(arg_ch, 2)) {\n        iVar3 = fcn.0040d489(arg_ch);\n        if (((iVar3 != 0) && (*(in_ECX + 0x20) != arg_ch)) &&\n           (iVar4 = fcn.00413b18(*(in_ECX + 0x20), arg_ch),  iVar4 != 0)) {\n            uVar5 = (*_sym.imp.USER32.dll_GetWindowLongW)(arg_ch, 0xfffffff0);\n            if (arg_8h == 0) {\n                if ((uVar5 & 0x18000000) == 0x10000000) {\n                    (*pcVar1)(arg_ch, 0);\n                    *(iVar3 + 0x3c) = *(iVar3 + 0x3c) | 2;\n                }\n            }\n            else if ((((uVar5 & 0x18000000) == 0) && ((*(iVar3 + 0x3c) & 2) != 0)) && (*(in_ECX + 0xb4) == 0)) {\n                (*pcVar1)(arg_ch, 4);\n                *(iVar3 + 0x3c) = *(iVar3 + 0x3c) & 0xfffffffd;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 437
    },
    "00413d75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413d75(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    \n    piVar1 = *(in_ECX + 0xb0);\n    if (arg_8h != piVar1) {\n        *(in_ECX + 0xb0) = 0;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0x168))(0, arg_8h, piVar1);\n        }\n        if (((*(in_ECX + 0xb0) == 0) && (*(in_ECX + 0xb0) = arg_8h,  arg_8h != NULL)) && (arg_ch != 0)) {\n            (**(*arg_8h + 0x168))(1, arg_8h, piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 206
    },
    "00413df3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413df3(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x80) != NULL) {\n        (**(**(in_ECX + 0x80) + 0x78))(arg_8h);\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 84
    },
    "00413e8c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00413e8c(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_1 + 0x170))();\n    if (iVar1 != 0) {\n        return param_1[0x26];\n    }\n    if ((param_1[0x24] != 0) && (*(param_1[0x24] + 0x98) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 118
    },
    "00414189": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414189(int32_t param_1)\n\n{\n    fcn.0040d3b7();\n    if (*(param_1 + 0x80) != NULL) {\n    // WARNING: Could not recover jumptable at 0x004141a9. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x80) + 0x6c))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 109
    },
    "00414519": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414519(uint arg_8h, uint lpIconName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_58h;\n    uint var_38h;\n    int32_t var_30h;\n    uint var_28h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar1 = fcn.004213cc();\n    iVar1 = (*_sym.imp.USER32.dll_LoadIconW)(*(iVar1 + 0xc), lpIconName);\n    if (iVar1 != 0) {\n        fcn.00430820(&var_58h, 0, 0x30);\n        var_38h = arg_8h;\n        (**(*in_ECX + 100))(&var_58h);\n        if (var_30h != 0) {\n            iVar2 = fcn.004213cc();\n            iVar2 = fcn.0040b8f8(*(iVar2 + 8), var_30h, &var_28h);\n            if ((iVar2 != 0) && (var_14h != iVar1)) {\n                uVar3 = fcn.004102c6(var_28h, var_10h, var_ch, iVar1);\n                return uVar3;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 319
    },
    "00414669": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414669(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if (param_1[0x2d] != NULL) {\n        (*param_1[0x2d])(param_1);\n    }\n    piVar1 = (**(*param_1 + 0x144))();\n    if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x8c))(param_1),  iVar2 == 0)) {\n        return;\n    }\n    iVar2 = fcn.004213cc();\n    piVar3 = *(iVar2 + 4);\n    if ((piVar3 != NULL) && (piVar3[8] == param_1)) {\n        if ((piVar1 == NULL) && (iVar2 = (**(*piVar3 + 0x94))(),  iVar2 == 0)) {\n            return;\n        }\n        fcn.0041872c();\n        fcn.00418694();\n        iVar2 = fcn.00423c1c();\n        if (iVar2 == 0) {\n            fcn.00423c3c(0);\n            return;\n        }\n        iVar2 = fcn.004213cc();\n        if ((*(iVar2 + 0x14) == '\\0') && (piVar3[8] == 0)) {\n            fcn.00417276(0);\n            return;\n        }\n    }\n    if ((piVar1 != NULL) && (piVar1[0x13] != 0)) {\n        var_4h = (**(*piVar1 + 0x60))();\n        do {\n            if (var_4h == NULL) {\n                (**(*piVar1 + 0x7c))();\n                return;\n            }\n            iVar2 = (**(*piVar1 + 100))(&var_4h);\n            if (iVar2 == 0) {\n                fcn.00407ad1();\n                break;\n            }\n            piVar3 = fcn.0040df6b();\n        } while (piVar3 == param_1);\n        (**(*piVar1 + 0x94))(param_1);\n    }\n    (**(*param_1 + 0x60))();\n    return;\n}\n",
        "token_count": 536
    },
    "00414851": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414851(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *piVar3;\n    \n    uVar1 = arg_8h;\n    fcn.0040c166(arg_8h);\n    (**(*in_ECX + 0x188))(uVar1, arg_ch);\n    if (in_ECX[0x20] != 0) {\n        if ((arg_8h == 0) || (arg_8h >> 0x10 != 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        (**(*in_ECX[0x20] + 0x58))(uVar1);\n    }\n    iVar2 = fcn.0041a73a();\n    if (*(iVar2 + 0x20) == in_ECX) {\n        piVar3 = in_ECX[0x2c];\n        if (piVar3 == NULL) {\n            iVar2 = (**(*in_ECX + 0x148))();\n            piVar3 = *(iVar2 + 0xb0);\n            if (piVar3 == NULL) goto code_r0x004148cd;\n        }\n        (**(*piVar3 + 0x168))(0, piVar3, piVar3);\n    }\ncode_r0x004148cd:\n    (*_sym.imp.USER32.dll_PostMessageW)(in_ECX[8], 0x36a, 0, 0);\n    return 0;\n}\n",
        "token_count": 356
    },
    "004149e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004149e4(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar2 = fcn.0040dfaa();\n    if (iVar2 == 0) {\n        iVar2 = fcn.00407ad1();\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n    arg_8h = arg_8h & 0xfff0;\n    if (*(iVar2 + 0x68) == 0) {\ncode_r0x00414a2d:\n        fcn.0040d3b7();\n    }\n    else {\n        if (arg_8h < 0xf041) {\n            if (((arg_8h != 0xf040) && (arg_8h != 0xf000)) && (arg_8h != 0xf010)) {\n                iVar2 = arg_8h - 0xf020;\ncode_r0x00414a26:\n                if ((iVar2 != 0) && (iVar2 != 0x10)) goto code_r0x00414a2d;\n            }\n        }\n        else if ((arg_8h != 0xf050) && (arg_8h != 0xf060)) {\n            iVar2 = arg_8h - 0xf120;\n            goto code_r0x00414a26;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageW)(*(in_ECX + 0x20), 0x365, 0, (arg_8h - 0xf000 >> 4) + 0x1ef00);\n        if (iVar2 == 0) {\n            (*pcVar1)(*(in_ECX + 0x20), 0x111, 0xe147, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 417
    },
    "00414a87": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414a87(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t in_ECX;\n    uint var_214h;\n    uint32_t var_210h;\n    uint var_20ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    uVar3 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(in_ECX + 0x20));\n    fcn.0040d45d(uVar3);\n    pcVar2 = _sym.imp.SHELL32.dll_DragQueryFileW;\n    uVar3 = 0;\n    uVar4 = (*_sym.imp.SHELL32.dll_DragQueryFileW)(arg_8h, 0xffffffff, 0, 0);\n    iVar5 = fcn.004213cc();\n    var_210h = 0;\n    piVar1 = *(iVar5 + 4);\n    if (uVar4 != 0) {\n        do {\n            (*pcVar2)(arg_8h, var_210h, &var_20ch, 0x104);\n            (**(*piVar1 + 0x88))(&var_20ch);\n            var_210h = var_210h + 1;\n        } while (var_210h < uVar4);\n    }\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    fcn.0042e09f(uVar3);\n    return;\n}\n",
        "token_count": 369
    },
    "00414b58": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414b58(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_8h != 0) {\n        iVar2 = fcn.004213cc();\n        piVar1 = *(iVar2 + 4);\n        if ((piVar1 != NULL) && (piVar1[8] == in_ECX)) {\n            fcn.00423c3c(1);\n            fcn.00418694(1);\n            (**(*piVar1 + 0x68))();\n        }\n    }\n    return;\n}\n",
        "token_count": 146
    },
    "00414b95": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_214h\n\nvoid __cdecl fcn.00414b95(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int16_t iVar4;\n    int32_t in_ECX;\n    uint var_214h;\n    uint var_210h;\n    uint var_20ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    iVar3 = fcn.004213cc();\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalGetAtomNameW;\n    iVar3 = *(iVar3 + 4);\n    if ((((iVar3 != 0) && (arg_ch != 0)) && (iVar4 = arg_ch >> 0x10,  iVar4 != 0)) &&\n       ((arg_ch == *(iVar3 + 0x90) && (iVar4 == *(iVar3 + 0x92))))) {\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameW)(*(iVar3 + 0x90), &var_20ch, 0x103);\n        pcVar2 = _sym.imp.KERNEL32.dll_GlobalAddAtomW;\n        (*_sym.imp.KERNEL32.dll_GlobalAddAtomW)(&var_20ch);\n        (*pcVar1)(*(iVar3 + 0x92), &var_20ch, 0x103);\n        (*pcVar2)(&var_20ch);\n        (*_sym.imp.USER32.dll_SendMessageW)(arg_8h, 0x3e4, *(in_ECX + 0x20), *(iVar3 + 0x90));\n    }\n    fcn.0042e09f(in_ECX);\n    return;\n}\n",
        "token_count": 404
    },
    "00414c91": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414c91(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint nCmdShow;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n    }\n    piVar1 = fcn.00413e76();\n    if (arg_10h == 0) {\n        fcn.00410b5a(0, 0, 0, 0, 0, (-(arg_ch != 0) & 0xffffffc0) + 0x80 | 0x17);\n        (**(*arg_8h + 0x164))(arg_ch);\n        if ((arg_ch != 0) || (iVar2 = fcn.00413e8c(),  iVar2 == 0)) {\n            (**(*piVar1 + 0x150))(0);\n        }\n    }\n    else {\n        (**(*arg_8h + 0x164))(arg_ch);\n        piVar1[0x39] = piVar1[0x39] | 0xc;\n    }\n    iVar2 = fcn.00413e8c();\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_8h[0x24] == NULL) {\n        uVar3 = arg_ch != 0;\n    }\n    else {\n        uVar3 = (**(*arg_8h[0x24] + 0x180))();\n    }\n    if (uVar3 == 1) {\n        if (arg_ch != 0) {\n            piVar1[0x28] = -1;\n            if (arg_10h == 0) {\n                nCmdShow = 8;\n                goto code_r0x00414d78;\n            }\n            piVar1[0x28] = 8;\n            goto code_r0x00414d86;\n        }\n    }\n    else if (uVar3 == 0) {\n        piVar1[0x28] = -1;\n        if (arg_10h != 0) {\n            piVar1[0x28] = 0;\n            return;\n        }\n        nCmdShow = 0;\ncode_r0x00414d78:\n        fcn.00410ab2(nCmdShow);\n        return;\n    }\n    if (arg_10h != 0) {\n        return;\n    }\ncode_r0x00414d86:\n    (**(*piVar1 + 0x150))(0);\n    return;\n}\n",
        "token_count": 585
    },
    "00414d96": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00414d96(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t in_ECX;\n    int32_t iVar8;\n    uint arg_ch_00;\n    int32_t iVar9;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004217b7(*(in_ECX + 0x20));\n    if ((arg_10h == 0) &&\n       ((*(in_ECX + 0x80) == NULL || (iVar2 = (**(**(in_ECX + 0x80) + 0x74))(arg_8h, arg_ch, 0),  iVar2 == 0)))) {\n        if (arg_8h == 0) {\n            fcn.00407ad1();\n        }\n        fcn.0040672c();\n        iVar2 = fcn.00420e14();\n        if (*(iVar2 + 0x78) != *(arg_8h + 4)) {\n            if (*(in_ECX + 0xd4) == 1) {\n                iVar2 = (*_sym.imp.USER32.dll_GetMenu)(*(in_ECX + 0x20));\n            }\n            else {\n                iVar2 = *(in_ECX + 0xd8);\n            }\n            if ((((iVar2 != 0) && (piVar3 = fcn.0040ec49(),  piVar3 != NULL)) &&\n                (iVar2 = (**(*piVar3 + 0x6c))(),  iVar2 != 0)) && (iVar2 = *(iVar2 + 4),  iVar2 != 0)) {\n                iVar4 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar2);\n                iVar8 = 0;\n                if (0 < iVar4) {\n                    do {\n                        iVar9 = iVar8;\n                        iVar5 = (*_sym.imp.USER32.dll_GetSubMenu)(iVar2, iVar8);\n                        if (iVar5 == *(arg_8h + 4)) {\n                            fcn.004234aa(iVar9, iVar2);\n                            break;\n                        }\n                        iVar8 = iVar8 + 1;\n                    } while (iVar8 < iVar4);\n                }\n            }\n        }\n        pcVar1 = _sym.imp.USER32.dll_GetMenuItemCount;\n        var_ch = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n        var_24h = 0;\n        if (var_ch != 0) {\n            do {\n                var_28h = fcn.0040bb6d(var_24h);\n                uVar6 = var_ch;\n                if (var_28h != 0) {\n                    if (var_28h == 0xffffffff) {\n                        iVar2 = fcn.0040bb82(var_24h);\n                        if (((iVar2 == 0) ||\n                            (var_28h = (*_sym.imp.USER32.dll_GetMenuItemID)(*(iVar2 + 4), 0),  var_28h == 0)) ||\n                           (var_28h == 0xffffffff)) goto code_r0x00414f21;\n                        arg_ch_00 = 0;\n                    }\n                    else if ((*(in_ECX + 0x54) == 0) || (0xefff < var_28h)) {\n                        arg_ch_00 = 0;\n                    }\n                    else {\n                        arg_ch_00 = 1;\n                    }\n                    fcn.00406752(in_ECX, arg_ch_00);\n                    uVar6 = (*pcVar1)(*(arg_8h + 4));\n                    if (uVar6 < var_ch) {\n                        var_24h = var_24h + (uVar6 - var_ch);\n                        while ((var_24h < uVar6 && (uVar7 = fcn.0040bb6d(var_24h),  uVar7 == var_28h))) {\n                            var_24h = var_24h + 1;\n                        }\n                    }\n                }\ncode_r0x00414f21:\n                var_ch = uVar6;\n                var_24h = var_24h + 1;\n            } while (var_24h < var_ch);\n        }\n    }\n    return;\n}\n",
        "token_count": 1032
    },
    "0041512f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041512f(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    if (arg_8h == 0) {\n        iVar1 = 0;\n    }\n    else {\n        var_4h = *(in_ECX + 0x88);\n        do {\n            if (var_4h == 0) {\n                return 0;\n            }\n            piVar2 = fcn.0040b31f(&var_4h);\n            iVar1 = *piVar2;\n            iVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar1 + 0x20));\n        } while (iVar3 != arg_8h);\n    }\n    return iVar1;\n}\n",
        "token_count": 198
    },
    "004156d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004156d3(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    fcn.0040d3b7();\n    if (arg_8h != 1) {\n        (**(*in_ECX + 0x150))(1);\n    }\n    return;\n}\n",
        "token_count": 73
    },
    "004157fc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004157fc(int32_t *param_1)\n\n{\n    if (1 < *(*param_1 + -4)) {\n        fcn.00401c20(*(*param_1 + -0xc));\n    }\n    return *param_1;\n}\n",
        "token_count": 63
    },
    "0041597f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041597f(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        iVar2 = fcn.00424332(in_ECX + 0x14, *(in_ECX + 0x18), 0xc);\n        iVar1 = *(in_ECX + 0x18);\n        puVar3 = iVar2 + -8 + iVar1 * 0xc;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar3 = *(in_ECX + 0x10);\n            *(in_ECX + 0x10) = puVar3;\n            puVar3 = puVar3 + -3;\n        }\n    }\n    puVar3 = *(in_ECX + 0x10);\n    if (puVar3 == NULL) {\n        puVar3 = fcn.00407ad1();\n    }\n    *(in_ECX + 0x10) = *puVar3;\n    puVar3[1] = arg_8h;\n    *puVar3 = arg_ch;\n    *(in_ECX + 0xc) = *(in_ECX + 0xc) + 1;\n    return;\n}\n",
        "token_count": 309
    },
    "004159e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004159e1(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x3c) == 0) {\n        uVar1 = fcn.0040d0a9(\"ImageList_Draw\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x3c) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x3c);\n    return;\n}\n",
        "token_count": 132
    },
    "00415a94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00415a94(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "00415aca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415aca(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    piVar1 = in_ECX + 0x9c;\n    if (*piVar1 == 0) {\n        uVar2 = fcn.0040d0a9(\"ImageList_GetImageInfo\");\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2);\n        *piVar1 = iVar3;\n    }\n    *arg_8h = *piVar1;\n    return;\n}\n",
        "token_count": 144
    },
    "00415b78": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00415b78(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "00415e73": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415e73(int32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    fcn.0040dae4(arg_8h, arg_ch);\n    if ((arg_8h == 2) && (*(in_ECX + 0xa8) != *(in_ECX + 0xac))) {\n        fcn.00415113(*(in_ECX + 0xa8));\n    }\n    return;\n}\n",
        "token_count": 105
    },
    "00416046": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.00416046(void)\n\n{\n    int32_t iVar1;\n    int32_t **ppiVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    uint var_48h;\n    uint var_44h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_10h;\n    int32_t arg_8h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x3c);\n    fcn.0041587c(10);\n    *(unaff_EBP + -4) = 0;\n    arg_8h = 10;\n    fcn.0041587c(10);\n    iVar1 = *(extraout_ECX + 0x88);\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = iVar1;\n    while (iVar1 != 0) {\n        ppiVar2 = fcn.0040b31f(unaff_EBP + -0x10);\n        piVar4 = *ppiVar2;\n        (**(*piVar4 + 0x170))();\n        arg_8h = piVar4[8];\n        fcn.00415ebe(arg_8h);\n        iVar1 = *(unaff_EBP + -0x10);\n    }\n    puVar5 = *(unaff_EBP + -0x44);\n    while( true ) {\n        while( true ) {\n            do {\n                if (puVar5 == NULL) {\n                    puVar5 = *(unaff_EBP + -0x28);\n                    goto code_r0x00416128;\n                }\n                arg_8h = puVar5[2];\n                puVar5 = *puVar5;\n                uVar3 = fcn.0040d489();\n                piVar4 = fcn.004075eb(0x44bdcc, uVar3);\n            } while (piVar4 == NULL);\n            if (piVar4[0x26] != 0) break;\n            (**(*piVar4 + 0x60))();\n        }\n        piVar4 = fcn.0040df6b();\n        if (piVar4 == NULL) break;\n        (**(*piVar4 + 0x60))();\n    }\n    fcn.00407ad1();\n    do {\n        arg_8h = puVar5[2];\n        puVar5 = *puVar5;\n        uVar3 = fcn.0040d489();\n        piVar4 = fcn.004075eb(0x449a10, uVar3);\n        if (piVar4 != NULL) {\n            (**(*piVar4 + 0x60))();\n        }\ncode_r0x00416128:\n    } while (puVar5 != NULL);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x2c) = vtable.CList_struct_HWND_____struct_HWND____.0;\n    fcn.00414027(arg_8h);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x48) = vtable.CList_struct_HWND_____struct_HWND____.0;\n    fcn.00414027();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 794
    },
    "0041634f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041634f(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uVar4;\n    \n    fcn.00416046();\n    if (param_1[0x17] != 0) {\n        iVar3 = param_1[0x17];\n        iVar2 = (*_sym.imp.USER32.dll_GetMenu)(param_1[8]);\n        if (iVar2 != iVar3) {\n            (*_sym.imp.USER32.dll_SetMenu)(param_1[8], iVar3);\n        }\n    }\n    iVar3 = fcn.004213cc();\n    iVar3 = *(iVar3 + 4);\n    if (((iVar3 != 0) && (*(iVar3 + 0x20) == param_1)) && (*(iVar3 + 0x6c) == 0)) {\n        (*_sym.imp.USER32.dll_WinHelpW)(param_1[8], 0, 2, 0);\n    }\n    if (param_1[0x13] != NULL) {\n        (**(*param_1[0x13] + 4))(1, unaff_ESI);\n    }\n    piVar1 = param_1[0xb];\n    param_1[0x13] = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0xc))(piVar1, 0, 0);\n    }\n    piVar1 = param_1[10];\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 8))(piVar1);\n    }\n    uVar4 = 0x407aed;\n    iVar3 = fcn.00422773(0x407aed);\n    if (iVar3 == 0) {\n        iVar3 = fcn.00407ad1(uVar4, unaff_ESI);\n    }\n    (**(*param_1 + 0x118))(*(iVar3 + 0x5c), *(iVar3 + 0x60), *(iVar3 + 100));\n    return;\n}\n",
        "token_count": 474
    },
    "00416fa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00416fa0(int32_t arg_8h)\n\n{\n    unkuint3 Var2;\n    uint32_t uVar1;\n    uint32_t *in_ECX;\n    \n    Var2 = *0x45f53c >> 8;\n    if (*0x45f53c == NULL) {\n        uVar1 = CONCAT31(Var2, 1);\n    }\n    else if ((arg_8h == 0) || (*in_ECX != 0xffffffff)) {\n        uVar1 = Var2 << 8;\n    }\n    else {\n        uVar1 = (**0x45f53c)(arg_8h);\n        *in_ECX = uVar1;\n        uVar1 = uVar1 & 0xffffff00 | uVar1 != 0xffffffff;\n    }\n    return uVar1;\n}\n",
        "token_count": 189
    },
    "00416fda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00416fda(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*0x45f544 == NULL) {\n        return true;\n    }\n    if ((*param_1 != -1) && (param_1[1] == 0)) {\n        iVar1 = (**0x45f544)(*param_1, param_1 + 1);\n        return iVar1 == 1;\n    }\n    return false;\n}\n",
        "token_count": 106
    },
    "004171dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004171dc(int32_t param_1)\n\n{\n    if (*(param_1 + 0x88) != NULL) {\n        (**(**(param_1 + 0x88) + 0x14))();\n    }\n    if (*(param_1 + 0x94) != 0) {\n        fcn.00418d5f(L\"Settings\", L\"PreviewPages\", *(param_1 + 0x94));\n    }\n    return;\n}\n",
        "token_count": 107
    },
    "00417381": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417381(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x74) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x74));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(iVar2 + *(iVar2 + 2) * 2, lpString2);\n        if ((iVar2 == 0) && (iVar2 = sub.WINSPOOL.DRV_OpenPrinterW(lpString2, &var_4h, 0),  iVar2 != 0)) {\n            if (*(in_ECX + 0x70) != 0) {\n                fcn.00421610(*(in_ECX + 0x70));\n            }\n            uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesW(0, var_4h, lpString2, 0, 0, 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n            *(in_ECX + 0x70) = uVar3;\n            uVar3 = (*pcVar1)(uVar3);\n            iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesW(0, var_4h, lpString2, uVar3, 0, 2);\n            if (iVar2 != 1) {\n                fcn.00421610(*(in_ECX + 0x70));\n                *(in_ECX + 0x70) = 0;\n            }\n            sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 427
    },
    "00417496": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpLibFileName\n\nvoid __cdecl fcn.00417496(int32_t Locale)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    uint in_ECX;\n    uint in_EDX;\n    uint lpLibFileName;\n    uint var_ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    if (Locale == 0x800) {\n        uVar1 = fcn.0043138b(&var_ch, 4, 0x44a528);\n        fcn.00401d80(uVar1);\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)(Locale, 3, &var_ch, 4);\n        if (iVar2 == 0) goto code_r0x00417554;\n    }\n    puVar3 = fcn.0043147b();\n    uVar1 = *puVar3;\n    puVar3 = fcn.0043147b();\n    *puVar3 = 0;\n    uVar4 = fcn.00431418(&lpLibFileName, 0x112, 0x111, in_ECX, in_EDX);\n    piVar5 = fcn.0043147b();\n    if (*piVar5 == 0) {\n        puVar3 = fcn.0043147b();\n        *puVar3 = uVar1;\n    }\n    else {\n        puVar3 = fcn.0043147b();\n        fcn.0040904e(*puVar3);\n    }\n    if ((uVar4 != 0xffffffff) && (uVar4 < 0x112)) {\n        (*_sym.imp.KERNEL32.dll_LoadLibraryW)(&lpLibFileName);\n    }\ncode_r0x00417554:\n    fcn.0042e09f(lpLibFileName);\n    return;\n}\n",
        "token_count": 450
    },
    "00417562": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00417562(int32_t *param_1)\n\n{\n    if ((*0x45f540 != NULL) && (*param_1 != -1)) {\n        fcn.00417007();\n        (**0x45f540)(*param_1);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00417d09": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417d09(int32_t arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint arg_8h_01;\n    \n    if (arg_8h == 0) {\n        arg_8h_00 = 0;\n    }\n    else {\n        arg_8h_00 = fcn.0041747a(arg_8h);\n    }\n    if (arg_8h_00 < 1) {\n        fcn.00406d27();\n    }\n    else {\n        arg_8h_01 = fcn.00406eac(arg_8h_00);\n        fcn.00406c4f(arg_8h_01, arg_8h_00, arg_8h, 0xffffffff);\n        fcn.00406c24(arg_8h_00);\n    }\n    return;\n}\n",
        "token_count": 194
    },
    "00417d59": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** __thiscall fcn.00417d59(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    uint unaff_EDI;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_MultiByteToWideChar;\n    ppiVar3 = param_1 + 6;\n    if ((*ppiVar3)[-3] != 0) {\n        if (param_1[5] != 3) {\n            return param_1;\n        }\n        ppiVar3 = param_1 + 7;\n        if (((*ppiVar3)[-3] != 0) && (ppiVar3 = param_1 + 8,  (*ppiVar3)[-3] != 0)) {\n            ppiVar3 = param_1 + 9;\n            if ((*ppiVar3)[-3] != 0) {\n                return *ppiVar3;\n            }\n        }\n    }\n    if (param_2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(3, 0, param_2, 0xffffffff, 0, 0, unaff_EDI);\n        iVar2 = iVar2 + -1;\n        if (0 < iVar2) {\n            if ((1U - (*ppiVar3)[-1] | (*ppiVar3)[-2] - iVar2) < 0) {\n                fcn.00401b30(iVar2);\n            }\n            (*pcVar1)(3, 0, param_2, 0xffffffff, *ppiVar3, iVar2);\n            if (iVar2 <= (*ppiVar3)[-2]) {\n                (*ppiVar3)[-3] = iVar2;\n                *(*ppiVar3 + iVar2 * 2) = 0;\n                return ppiVar3;\n            }\n            fcn.00401000(0x80070057);\n        }\n    }\n    fcn.00401a10();\n    return ppiVar3;\n}\n",
        "token_count": 453
    },
    "00418019": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t ** __thiscall fcn.00418019(int32_t *param_1, int16_t *param_2)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    int32_t **ppiVar3;\n    uint unaff_EDI;\n    \n    ppiVar3 = param_1 + 6;\n    if ((*ppiVar3)[-3] != 0) {\n        if (param_1[5] != 3) {\n            return param_1;\n        }\n        ppiVar3 = param_1 + 7;\n        if (((*ppiVar3)[-3] != 0) && (ppiVar3 = param_1 + 8,  (*ppiVar3)[-3] != 0)) {\n            ppiVar3 = param_1 + 9;\n            if ((*ppiVar3)[-3] != 0) {\n                return *ppiVar3;\n            }\n        }\n    }\n    if (param_2 == NULL) {\n        fcn.00401a80(0, 0, unaff_EDI);\n        return ppiVar3;\n    }\n    piVar2 = param_2;\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    fcn.00401a80(param_2, piVar2 - (param_2 + 1) >> 1, unaff_EDI);\n    return ppiVar3;\n}\n",
        "token_count": 328
    },
    "00418114": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418114(int32_t param_1)\n\n{\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 0x58) == 0) {\n        fcn.00407ad1();\n        param_1 = extraout_ECX;\n    }\n    // WARNING: Could not recover jumptable at 0x0041812a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x58) + 0x2c))();\n    return;\n}\n",
        "token_count": 125
    },
    "0041814e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041814e(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x50) == 0) {\n        uVar1 = fcn.0040d0a9(\"CommDlgExtendedError\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x50) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x50);\n    return;\n}\n",
        "token_count": 130
    },
    "004181ed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004181ed(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 186
    },
    "00418462": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00418462(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n    }\n    fcn.00418223(0);\n    *(arg_8h[0x1d] + 8) = *(in_ECX + 0x70);\n    *(arg_8h[0x1d] + 0xc) = *(in_ECX + 0x74);\n    while( true ) {\n        iVar2 = (**(*arg_8h + 0x14c))();\n        if ((iVar2 == 1) || (iVar2 == 2)) {\n            *(in_ECX + 0x70) = *(arg_8h[0x1d] + 8);\n            *(in_ECX + 0x74) = *(arg_8h[0x1d] + 0xc);\n            return iVar2;\n        }\n        fcn.004213cc();\n        iVar1 = fcn.0041817d();\n        if ((iVar1 != 0x1009) && (1 < iVar1 - 0x100bU)) break;\n        if (*(arg_8h[0x1d] + 0xc) != 0) {\n            fcn.00421610(*(arg_8h[0x1d] + 0xc));\n            *(arg_8h[0x1d] + 0xc) = 0;\n            *(in_ECX + 0x74) = 0;\n        }\n        if (*(arg_8h[0x1d] + 8) != 0) {\n            fcn.00421610(*(arg_8h[0x1d] + 8));\n            *(arg_8h[0x1d] + 8) = 0;\n            *(in_ECX + 0x70) = 0;\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 457
    },
    "0041856f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041856f(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    fcn.00418223(*(in_ECX + 0x74) == 0);\n    if (*(in_ECX + 0x74) == 0) {\n        uVar2 = 0;\n    }\n    else {\n        if (arg_8h == 0) {\n            arg_8h = fcn.00407ad1();\n        }\n        *(arg_8h + 0xc) = *(in_ECX + 0x74);\n        pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n        *(arg_8h + 8) = *(in_ECX + 0x70);\n        (*pcVar1)(*(in_ECX + 0x74));\n        (*pcVar1)(*(in_ECX + 0x70));\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 228
    },
    "0041867b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041867b(int32_t param_1)\n\n{\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 0x58) == 0) {\n        fcn.00407ad1();\n        param_1 = extraout_ECX;\n    }\n    // WARNING: Could not recover jumptable at 0x00418691. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x58) + 0x1c))();\n    return;\n}\n",
        "token_count": 125
    },
    "00418694": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00418694(int32_t param_1)\n\n{\n    if (*(param_1 + 0x58) != 0) {\n    // WARNING: Could not recover jumptable at 0x004186a5. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(param_1 + 0x58) + 0x24))();\n        return;\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "004186ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004186ac(uint *arg_8h)\n\n{\n    int32_t in_ECX;\n    uint *extraout_ECX;\n    \n    if (arg_8h == NULL) {\n        in_ECX = fcn.00407ad1();\n        arg_8h = extraout_ECX;\n    }\n    if (*(in_ECX + 0x88) == NULL) {\n        (***arg_8h)(0);\n    }\n    else {\n        (**(**(in_ECX + 0x88) + 0xc))(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "004187cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004187cf(int32_t param_1)\n\n{\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 0x58) == 0) {\n        fcn.00407ad1();\n        param_1 = extraout_ECX;\n    }\n    // WARNING: Could not recover jumptable at 0x004187e5. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x58) + 0x14))();\n    return;\n}\n",
        "token_count": 124
    },
    "00418928": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00418928(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint hKey;\n    uint phkResult;\n    uint lpSubKey;\n    uint var_224h;\n    uint lpName;\n    uint var_4h;\n    \n    fcn.00430f3a(0x228);\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x230) = iVar1;\n    fcn.004052f0(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (iVar1 == -0x80000000) {\n        iVar1 = fcn.00420ca6();\n        if (iVar1 == 1) {\n            uVar2 = fcn.004188d3(unaff_EBP + -0x224, L\"Software\\\\Classes\\\\\", unaff_EBP + -0x228);\n            *(unaff_EBP + -4) = 1;\n            fcn.00401930(uVar2);\n            *(unaff_EBP + -4) = 0;\n            fcn.00401020();\n            *(unaff_EBP + -0x230) = 0x80000001;\n        }\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)(*(unaff_EBP + -0x230), *(unaff_EBP + -0x228), unaff_EBP + -0x22c);\n    if (iVar1 == 0) {\n        while( true ) {\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyW)(*(unaff_EBP + -0x22c), 0, unaff_EBP + -0x220, 0x104);\n            if (iVar1 != 0) break;\n            *(unaff_EBP + -4) = 2;\n            fcn.00402680(unaff_EBP + -0x220);\n            *(unaff_EBP + -4) = 3;\n            iVar1 = fcn.00418928(*(unaff_EBP + -0x22c), unaff_EBP + -0x224);\n            *(unaff_EBP + -4) = 2;\n            fcn.00401020();\n            if (iVar1 != 0) break;\n            *(unaff_EBP + -4) = 0;\n        }\n        if ((iVar1 == 0x103) || (iVar1 == 0x3f2)) {\n            (*_sym.imp.ADVAPI32.dll_RegDeleteKeyW)(*(unaff_EBP + -0x230), *(unaff_EBP + -0x228));\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x22c));\n    }\n    fcn.00401020();\n    fcn.00430f96();\n    return;\n}\n",
        "token_count": 681
    },
    "00418cf4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00418cf4(uint lpAppName, uint lpValueName, int32_t nDefault)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x54) == 0) {\n        nDefault = (*_sym.imp.KERNEL32.dll_GetPrivateProfileIntW)(lpAppName, lpValueName, nDefault, *(in_ECX + 0x68));\n    }\n    else {\n        var_4h = in_ECX;\n        iVar1 = fcn.00418cac(lpAppName);\n        if (iVar1 != 0) {\n            lpAppName = 4;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(iVar1, lpValueName, 0, &var_8h, &var_4h, &lpAppName);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            if (iVar2 == 0) {\n                return var_4h;\n            }\n        }\n    }\n    return nDefault;\n}\n",
        "token_count": 259
    },
    "00418d5f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418d5f(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    uint lpString;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    if (*(in_ECX + 0x54) == 0) {\n        fcn.004313fa(&lpString, 0x10, 0x449360, arg_10h);\n        (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringW)(arg_8h, arg_ch, &lpString, *(in_ECX + 0x68));\n    }\n    else {\n        iVar1 = fcn.00418cac(arg_8h);\n        if (iVar1 != 0) {\n            (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(iVar1, arg_ch, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n        }\n    }\n    fcn.0042e09f(unaff_EBX);\n    return;\n}\n",
        "token_count": 271
    },
    "00418de8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00418de8(uint lpAppName, int32_t lpValueName, int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x54) == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringW)(lpAppName, lpValueName, lpString, *(in_ECX + 0x68));\n        return uVar3;\n    }\n    if (lpValueName == 0) {\n        iVar1 = fcn.00418c19();\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyW)(iVar1, lpAppName);\n            goto code_r0x00418e59;\n        }\n    }\n    else {\n        iVar1 = fcn.00418cac(lpAppName);\n        if (lpString == 0) {\n            if (iVar1 != 0) {\n                iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueW)(iVar1, lpValueName);\ncode_r0x00418e59:\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n                return iVar2 == 0;\n            }\n        }\n        else if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(iVar1, lpValueName, 0, 1, lpString, iVar2 * 2 + 2);\n            goto code_r0x00418e59;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 391
    },
    "004190c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004190c3(int16_t *lpString1, uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint unaff_EDI;\n    uint var_624h;\n    uint var_620h;\n    uint var_61ch;\n    uint var_414h;\n    uint var_20ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiW)(lpString1, lpString2);\n    if ((iVar2 == 0) &&\n       (iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a),  pcVar1 = _sym.imp.KERNEL32.dll_lstrlenW,  iVar2 != 0)) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString1);\n        iVar3 = (*pcVar1)(lpString2);\n        if (iVar2 == iVar3) {\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n            pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeExW;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExW)(uVar4, 1, lpString1, 0xffffffff, &var_61ch);\n            (*pcVar1)(uVar4, 4, lpString1, 0xffffffff, &var_20ch);\n            (*pcVar1)(uVar4, 1, lpString2, 0xffffffff, &var_414h);\n            if (*lpString1 != 0) {\n                iVar2 = 0;\n                do {\n                    if (((*(&var_20ch + iVar2) & 0x80) != 0) && (*(&var_61ch + iVar2) != *(&var_414h + iVar2))) break;\n                    iVar2 = iVar2 + 2;\n                    lpString1 = lpString1 + 1;\n                } while (*lpString1 != 0);\n            }\n        }\n    }\n    fcn.0042e09f(unaff_EDI);\n    return;\n}\n",
        "token_count": 496
    },
    "00419211": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00419211(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t unaff_EBX;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        uVar1 = *(unaff_EBP + -0x1c) == unaff_EBX;\n        if (uVar1 == unaff_EBX) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29();\n        if (uVar1 != unaff_EBX) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar2);\n        }\n    }\n    return;\n}\n",
        "token_count": 196
    },
    "00419864": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00419864(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t arg_8h_00;\n    int32_t arg_8h_01;\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint var_274h;\n    uint var_270h;\n    uint lpFilePart;\n    uint lpFileName;\n    uint lpRootPathName;\n    uint lpFindFileData;\n    uint lpString;\n    uint var_4h;\n    \n    fcn.00430f04(0x268);\n    arg_8h_00 = *(unaff_EBP + 8);\n    iVar2 = *(unaff_EBP + 0xc);\n    arg_8h_01 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x268) = iVar2;\n    if (arg_8h_00 != 0) goto code_r0x00419892;\n    do {\n        iVar2 = fcn.00407ad1();\ncode_r0x00419892:\n    } while (iVar2 == 0);\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetFullPathNameW)(iVar2, 0x104, arg_8h_00, unaff_EBP + -0x26c);\n    if (uVar3 == 0) {\n        fcn.00407b1c(arg_8h_00, 0x104, *(unaff_EBP + -0x268), 0xffffffff);\n        fcn.00419835(arg_8h_01, *(unaff_EBP + -0x268));\n        goto code_r0x004199fb;\n    }\n    if (0x103 < uVar3) {\n        if (arg_8h_01 != 0) {\n            uVar1 = *(unaff_EBP + -0x268);\n            *(arg_8h_01 + 8) = 3;\n            fcn.004027e0(uVar1);\n        }\n        goto code_r0x004199fb;\n    }\n    fcn.00401890();\n    *(unaff_EBP + -4) = 0;\n    fcn.004196d3(arg_8h_00, unaff_EBP + -0x264);\n    iVar2 = (*_sym.imp.SHLWAPI.dll_PathIsUNCW)(*(unaff_EBP + -0x264));\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationW)\n                          (*(unaff_EBP + -0x264), 0, 0, 0, unaff_EBP + -0x274, unaff_EBP + -0x270, 0, 0);\n        if (iVar2 == 0) {\ncode_r0x0041994d:\n            fcn.00419835(arg_8h_01, *(unaff_EBP + -0x268));\n        }\n        else {\n            if ((*(unaff_EBP + -0x270) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperW)(arg_8h_00);\n            }\n            if (((*(unaff_EBP + -0x270) & 4) != 0) ||\n               (iVar2 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(*(unaff_EBP + -0x268), unaff_EBP + -0x260),  iVar2 == -1\n               )) goto code_r0x004199ea;\n            (*_sym.imp.KERNEL32.dll_FindClose)(iVar2);\n            if ((*(unaff_EBP + -0x26c) == 0) ||\n               (*(unaff_EBP + -0x26c) < arg_8h_00 || *(unaff_EBP + -0x26c) == arg_8h_00)) goto code_r0x0041994d;\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(unaff_EBP + -0x234);\n            iVar4 = *(unaff_EBP + -0x26c) - arg_8h_00 >> 1;\n            if (iVar2 + iVar4 < 0x104) {\n                fcn.00417428(*(unaff_EBP + -0x26c), 0x104 - iVar4, unaff_EBP + -0x234);\n                goto code_r0x004199ea;\n            }\n            if (arg_8h_01 != 0) {\n                uVar1 = *(unaff_EBP + -0x268);\n                *(arg_8h_01 + 8) = 3;\n                fcn.004027e0(uVar1);\n            }\n        }\n        fcn.00401020();\n    }\n    else {\ncode_r0x004199ea:\n        fcn.00401020();\n    }\ncode_r0x004199fb:\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 1140
    },
    "00419aae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419aae(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    uint uVar4;\n    int32_t in_stack_fffffdc0;\n    uint lpSecurityAttributes;\n    uint var_220h;\n    uint32_t var_21ch;\n    int32_t var_218h;\n    uint dwDesiredAccess;\n    int32_t lpFileName;\n    uint var_20ch;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    *(in_ECX + 8) = 0;\n    *(in_ECX + 4) = 0xffffffff;\n    lpFileName = arg_8h;\n    var_218h = arg_10h;\n    fcn.00401a10();\n    if ((lpFileName == 0) || (in_stack_fffffdc0 = lpFileName,  iVar2 = fcn.00419246(lpFileName, 0x104, 0),  iVar2 < 0))\n    {\n        if (var_218h != 0) {\n            *(var_218h + 8) = 3;\n            fcn.004027e0();\n        }\n        goto code_r0x00419c87;\n    }\n    iVar2 = fcn.00419864(&var_20ch, lpFileName, var_218h);\n    if (iVar2 == 0) goto code_r0x00419c87;\n    fcn.004029f0(&var_20ch);\n    uVar3 = arg_ch & 3;\n    dwDesiredAccess = 0;\n    if (uVar3 == 0) {\n        dwDesiredAccess = 0x80000000;\n    }\n    else if (uVar3 == 1) {\n        dwDesiredAccess = 0x40000000;\n    }\n    else if (uVar3 == 2) {\n        dwDesiredAccess = 0xc0000000;\n    }\n    uVar3 = arg_ch & 0x70;\n    uVar4 = 1;\n    if ((uVar3 == 0) || (uVar3 == 0x10)) {\ncode_r0x00419ba3:\n        uVar4 = 0;\n    }\n    else if (uVar3 != 0x20) {\n        if (uVar3 == 0x30) {\n            uVar4 = 2;\n        }\n        else {\n            uVar4 = 3;\n            if (uVar3 != 0x40) goto code_r0x00419ba3;\n        }\n    }\n    var_21ch = ~((arg_ch & 0xffff7fff) >> 7) & 1;\n    lpSecurityAttributes = 0xc;\n    var_220h = 0;\n    if ((arg_ch & 0x1000) == 0) {\n        cVar1 = '\\x03';\n    }\n    else {\n        cVar1 = (-((arg_ch & 0x2000) != 0) & 2U) + 2;\n    }\n    uVar3 = 0x80;\n    if ((arg_ch & 0x10000) != 0) {\n        uVar3 = 0x20000080;\n    }\n    if ((arg_ch & 0x20000) != 0) {\n        uVar3 = uVar3 | 0x80000000;\n    }\n    if ((arg_ch & 0x40000) != 0) {\n        uVar3 = uVar3 | 0x10000000;\n    }\n    if ((arg_ch & 0x80000) != 0) {\n        uVar3 = uVar3 | 0x8000000;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileW)\n                      (lpFileName, dwDesiredAccess, uVar4, &lpSecurityAttributes, cVar1, uVar3, 0);\n    if (iVar2 == -1) {\n        fcn.00419835(var_218h, lpFileName);\n    }\n    else {\n        *(in_ECX + 4) = iVar2;\n        *(in_ECX + 8) = 1;\n    }\ncode_r0x00419c87:\n    fcn.0042e09f(in_stack_fffffdc0);\n    return;\n}\n",
        "token_count": 995
    },
    "0041a127": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0041a127(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    uint extraout_ECX;\n    uint *puVar2;\n    uint *puVar3;\n    uint var_24h;\n    \n    if (arg_8h == NULL) {\n        fcn.00401000(0x80004005);\n        in_ECX = extraout_ECX;\n    }\n    iVar1 = fcn.0042e5a6(&var_24h, in_ECX);\n    if (iVar1 == 0) {\n        puVar2 = &var_24h;\n        puVar3 = arg_8h;\n        for (iVar1 = 9; iVar1 != 0; iVar1 = iVar1 + -1) {\n            *puVar3 = *puVar2;\n            puVar2 = puVar2 + 1;\n            puVar3 = puVar3 + 1;\n        }\n    }\n    else {\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 238
    },
    "0041a3a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041a3a2(uint arg_8h, int32_t lpFileTime)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uchar *arg_ch;\n    uint lpSystemTime;\n    uint var_12h;\n    ushort var_eh;\n    ushort var_ch;\n    ushort var_ah;\n    uchar lpLocalFileTime [8];\n    \n    if (lpFileTime == 0) {\n        fcn.00407ad1();\n    }\n    lpSystemTime._0_2_ = fcn.0041a169();\n    lpSystemTime._2_2_ = fcn.0041a18c();\n    var_12h._0_2_ = fcn.0041a1ab();\n    var_12h._2_2_ = fcn.0041a1c9();\n    var_eh = fcn.0041a1e8();\n    var_ch = fcn.0041a207();\n    var_ah = 0;\n    arg_ch = lpLocalFileTime;\n    iVar2 = (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.004241fb(uVar3, arg_ch);\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalFileTimeToFileTime)(lpLocalFileTime, lpFileTime);\n    if (iVar2 == 0) {\n        uVar3 = (*pcVar1)();\n        fcn.004241fb(uVar3, iVar2);\n    }\n    return;\n}\n",
        "token_count": 395
    },
    "0041a440": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041a440(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t *puVar3;\n    int32_t in_ECX;\n    uint var_28h;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    uint32_t lpFileSize;\n    uint32_t var_4h;\n    \n    fcn.00430820(arg_8h, 0, 0x22c);\n    fcn.00407b1c(arg_8h + 0x22, 0x104, *(in_ECX + 0xc), 0xffffffff);\n    if (*(in_ECX + 4) == *0x44a970) {\ncode_r0x0041a597:\n        uVar2 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetFileSizeEx)(*(in_ECX + 4), &lpFileSize);\n            if (iVar1 != 0) {\n                arg_8h[6] = lpFileSize;\n                arg_8h[7] = var_4h;\n                if (*(*(in_ECX + 0xc) + -0xc) == 0) {\n                    *(arg_8h + 8) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesW)(*(in_ECX + 0xc));\n                    *(arg_8h + 8) = (iVar1 == -1) - 1U & iVar1;\n                }\n                iVar1 = fcn.00419fa4(&lpCreationTime);\n                if (iVar1 == 0) {\n                    *arg_8h = 0;\n                    arg_8h[1] = 0;\n                }\n                else {\n                    puVar3 = fcn.0041a0c7(&lpCreationTime, 0xffffffff);\n                    *arg_8h = *puVar3;\n                    arg_8h[1] = puVar3[1];\n                }\n                iVar1 = fcn.00419fa4(&lpLastAccessTime);\n                if (iVar1 == 0) {\n                    arg_8h[4] = 0;\n                    arg_8h[5] = 0;\n                }\n                else {\n                    puVar3 = fcn.0041a0c7(&lpLastAccessTime, 0xffffffff);\n                    arg_8h[4] = *puVar3;\n                    arg_8h[5] = puVar3[1];\n                }\n                iVar1 = fcn.00419fa4(&lpLastWriteTime);\n                if (iVar1 == 0) {\n                    arg_8h[2] = 0;\n                    arg_8h[3] = 0;\n                }\n                else {\n                    puVar3 = fcn.0041a0c7(&lpLastWriteTime, 0xffffffff);\n                    arg_8h[2] = *puVar3;\n                    arg_8h[3] = puVar3[1];\n                }\n                if ((*arg_8h | arg_8h[1]) == 0) {\n                    *arg_8h = arg_8h[2];\n                    arg_8h[1] = arg_8h[3];\n                }\n                if ((arg_8h[4] | arg_8h[5]) == 0) {\n                    arg_8h[4] = arg_8h[2];\n                    arg_8h[5] = arg_8h[3];\n                }\n                goto code_r0x0041a597;\n            }\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 873
    },
    "0041a776": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041a776(uint noname_0, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_EBP;\n    \n    iVar1 = fcn.004213ff();\n    if (*(iVar1 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x0041a78a. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar2 = (**(**(iVar1 + 4) + 0x6c))();\n        return uVar2;\n    }\n    if (arg_ch[1] == 1) {\n        uVar2 = 0xffffffff;\n    }\n    else {\n        if (arg_ch[1] == 0xf) {\n            (*_sym.imp.USER32.dll_ValidateRect)(*arg_ch, 0, unaff_EBP);\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 216
    },
    "0041a98d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041a98d(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    \n    iVar1 = fcn.004213ff();\n    if (((*(iVar1 + 4) == 0) || (*arg_8h != 0)) || (iVar1 = fcn.0041a8bf(arg_8h),  iVar1 == 0)) {\n        piVar3 = fcn.0040700d();\n        piVar4 = piVar3;\n        if (piVar3 != NULL) {\n            piVar4 = piVar3[8];\n        }\n        iVar1 = fcn.0040d96e(piVar4, arg_8h);\n        if (iVar1 == 0) {\n            if (piVar3 != NULL) {\n                fcn.0040d45d(*arg_8h);\n                piVar4 = fcn.0040ec49();\n                if (piVar4 != piVar3) {\n                    uVar2 = (**(*piVar3 + 0x108))(arg_8h);\n                    return uVar2;\n                }\n            }\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = 1;\n        }\n    }\n    else {\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 317
    },
    "0041aba5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041aba5(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004213cc();\n    if ((*(iVar1 + 0x14) == '\\0') && ((-1 < arg_8h || (arg_8h == 0x8001)))) {\n        iVar1 = fcn.004213ff();\n        if (*(iVar1 + 4) != NULL) {\n            (**(**(iVar1 + 4) + 0x70))(arg_8h, arg_10h);\n            return;\n        }\n    }\n    iVar1 = fcn.00422773(0x407aed);\n    if (iVar1 == 0) {\n        iVar1 = fcn.00407ad1();\n    }\n    (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar1 + 0x2c), arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 225
    },
    "0041ad3d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0041ad3d(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.004213cc();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.00420e14();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExW)(0xffffffff, fcn.0041aba5, 0, uVar2);\n        *(iVar1 + 0x2c) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "0041ad6b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041ad6b(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    \n    if (arg_8h < 1) {\n        iVar3 = *(in_ECX + 0x20);\n        if (((iVar3 != 0) && (*(iVar3 + 0x20) != 0)) &&\n           (iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x20)),  iVar1 != 0)) {\n            fcn.0040dd00(iVar3, *(iVar3 + 0x20), 0x363, 1, 0);\n            fcn.0040dfeb(*(iVar3 + 0x20), 0x363, 1, 0, 1, 1);\n        }\n        fcn.004213cc();\n        iVar1 = fcn.00415818();\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x6c)) {\n            if ((*(iVar1 + 0x20) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0xa0) == 0) {\n                    fcn.00410ab2(0);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x20));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0xa0))) {\n                    fcn.0040dd00(iVar1, *(iVar1 + 0x20), 0x363, 1, 0);\n                    fcn.0040dfeb(*(iVar1 + 0x20), 0x363, 1, 0, 1, 1);\n                }\n                if (0 < *(iVar1 + 0xa0)) {\n                    fcn.00410ab2(*(iVar1 + 0xa0));\n                }\n                *(iVar1 + 0xa0) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.004213cc();\n        iVar3 = fcn.00415818();\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.00422fce();\n            fcn.004231e6(1);\n        }\n    }\n    return arg_8h < 1;\n}\n",
        "token_count": 550
    },
    "0041aecf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0041aecf(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[8] != NULL) {\n        fcn.0040d6b3();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040de40();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 166
    },
    "0041b89e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b89e(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x58) = arg_8h;\n    if (((arg_8h & 0xffff0000) == 0) && (*(in_ECX + 0x54) == 0)) {\n        *(in_ECX + 0x54) = arg_8h & 0xffff;\n    }\n    iVar1 = fcn.004213cc();\n    uVar3 = *(iVar1 + 0xc);\n    uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceW)(uVar3, arg_8h, 5);\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar3, uVar2);\n    uVar3 = fcn.0041b85f(uVar2, arg_ch, uVar3);\n    (*_sym.imp.KERNEL32.dll_FreeResource)(uVar2);\n    return uVar3;\n}\n",
        "token_count": 251
    },
    "0041b912": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b912(int32_t *arg_8h, int16_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t *piVar1;\n    int16_t iVar2;\n    uint16_t uVar3;\n    int32_t iVar4;\n    int16_t *piVar5;\n    int16_t *piVar6;\n    uint var_4h;\n    \n    piVar6 = arg_ch;\n    if (arg_ch != NULL) goto code_r0x0041b927;\n    do {\n        fcn.00407ad1();\ncode_r0x0041b927:\n    } while (arg_10h == 0);\n    arg_ch = NULL;\n    iVar2 = *piVar6;\n    piVar5 = piVar6;\n    while (iVar2 != 0) {\n        if (*piVar5 == 0x25) {\n            uVar3 = piVar5[1];\n            if ((uVar3 < 0x31) || (0x39 < uVar3)) {\n                if ((uVar3 < 0x41) || (0x5a < uVar3)) goto code_r0x0041b98b;\n                if (uVar3 < 0x3a) goto code_r0x0041b96a;\n                iVar4 = uVar3 - 0x38;\n            }\n            else {\ncode_r0x0041b96a:\n                iVar4 = uVar3 - 0x31;\n            }\n            piVar5 = piVar5 + 2;\n            if (arg_14h <= iVar4) goto code_r0x0041b98d;\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4);\n                arg_ch = arg_ch + iVar4;\n            }\n        }\n        else {\ncode_r0x0041b98b:\n            piVar5 = piVar5 + 1;\ncode_r0x0041b98d:\n            arg_ch = arg_ch + 1;\n        }\n        iVar2 = *piVar5;\n    }\n    piVar5 = fcn.004019b0(arg_ch);\n    iVar2 = *piVar6;\n    do {\n        if (iVar2 == 0) {\n            fcn.0040d34f(piVar5 - *arg_8h >> 1);\n            return;\n        }\n        if (*piVar6 == 0x25) {\n            uVar3 = piVar6[1];\n            if ((uVar3 < 0x31) || (0x39 < uVar3)) {\n                if ((uVar3 < 0x41) || (0x5a < uVar3)) goto code_r0x0041ba2d;\n                if (uVar3 < 0x3a) goto code_r0x0041b9e2;\n                iVar4 = uVar3 - 0x38;\n            }\n            else {\ncode_r0x0041b9e2:\n                iVar4 = uVar3 - 0x31;\n            }\n            piVar6 = piVar6 + 2;\n            if (arg_14h <= iVar4) {\n                *piVar5 = 0x3f;\n                goto code_r0x0041ba34;\n            }\n            piVar1 = arg_10h + iVar4 * 4;\n            iVar4 = *piVar1;\n            if (iVar4 != 0) {\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(iVar4);\n                fcn.00417428(piVar5, arg_ch + 1, *piVar1);\n                arg_ch = arg_ch - iVar4;\n                piVar5 = piVar5 + iVar4;\n            }\n        }\n        else {\ncode_r0x0041ba2d:\n            *piVar5 = *piVar6;\n            piVar6 = piVar6 + 1;\ncode_r0x0041ba34:\n            piVar5 = piVar5 + 1;\n            arg_ch = arg_ch + -1;\n        }\n        iVar2 = *piVar6;\n    } while( true );\n}\n",
        "token_count": 943
    },
    "0041bb83": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041bb83(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    fcn.00427653();\n    if ((*(param_1 + 0x40) != 0) && (*(param_1 + 0x68) == 0)) {\n        iVar1 = fcn.004213cc();\n        uVar3 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.USER32.dll_LoadMenuW)(uVar3, *(param_1 + 0x40));\n        *(param_1 + 0x68) = uVar2;\n        uVar3 = (*_sym.imp.USER32.dll_LoadAcceleratorsW)(uVar3, *(param_1 + 0x40));\n        *(param_1 + 0x6c) = uVar3;\n    }\n    return;\n}\n",
        "token_count": 204
    },
    "0041c94a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c94a(int32_t arg_8h)\n\n{\n    uint32_t arg_ch;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x18) = 1;\n    arg_ch = *(*(in_ECX + 8) * 0x14 + 8 + *(*(in_ECX + 0x14) + 0x78)) & 0xfbffffff;\n    if (arg_8h == 0) {\n        arg_ch = arg_ch | 0x4000000;\n    }\n    fcn.0041c8cc(*(in_ECX + 8), arg_ch);\n    return;\n}\n",
        "token_count": 149
    },
    "0041c987": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c987(int32_t arg_8h)\n\n{\n    uint32_t arg_ch;\n    int32_t in_ECX;\n    \n    arg_ch = *(*(in_ECX + 8) * 0x14 + 8 + *(*(in_ECX + 0x14) + 0x78)) & 0xfffffdff;\n    if (arg_8h != 0) {\n        arg_ch = arg_ch | 0x200;\n    }\n    fcn.0041c8cc(*(in_ECX + 8), arg_ch);\n    return;\n}\n",
        "token_count": 132
    },
    "0041da50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041da50(int32_t *arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint dwNewLong;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    dwNewLong = 0;\n    var_4h = 0;\n    if (0x40046 < *0x45bc5c) {\n        dwNewLong = fcn.004109b6();\n        iVar4 = fcn.004109ea(0, 0x8800, 0);\n        if (0x5ffff < *0x45bc5c) {\n            if (in_ECX == 0) {\n                uVar1 = 0;\n            }\n            else {\n                uVar1 = *(in_ECX + 0x20);\n            }\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar2 != 0) {\n                uVar3 = fcn.0041d01b();\n                var_4h = fcn.0041d02e(uVar3 & 0xfffffffe);\n            }\n        }\n    }\n    iVar2 = fcn.0040d3b7();\n    if (iVar2 != 0) {\n        *arg_8h = arg_ch;\n        arg_8h[1] = arg_ch >> 0x10;\n    }\n    if (iVar4 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongW)(*(in_ECX + 0x20), 0xfffffff0, dwNewLong);\n    }\n    if (var_4h != 0) {\n        fcn.0041d02e(var_4h);\n    }\n    return iVar2;\n}\n",
        "token_count": 416
    },
    "0041dc7a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041dc7a(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_ch;\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x18) = 1;\n    uVar1 = fcn.0041ce3e(*(in_ECX + 8));\n    arg_ch = uVar1 & 0xfffbffff;\n    if (arg_8h == 0) {\n        arg_ch = uVar1 & 0xfff9ffff | 0x40000;\n    }\n    fcn.0041d59d(*(in_ECX + 8), arg_ch);\n    return;\n}\n",
        "token_count": 153
    },
    "0041dcbd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041dcbd(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    uVar1 = fcn.0041ce3e(*(in_ECX + 8));\n    uVar1 = uVar1 & 0xffeeffff;\n    if (arg_8h == 1) {\n        uVar1 = uVar1 | 0x10000;\n    }\n    else if (arg_8h == 2) {\n        uVar1 = uVar1 | 0x100000;\n    }\n    fcn.0041d59d(*(in_ECX + 8), uVar1 | 2);\n    return;\n}\n",
        "token_count": 160
    },
    "0041e445": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041e445(int32_t *param_1, uint8_t param_2, uint param_3, int32_t param_4)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[0x43] == 0) {\n        return;\n    }\n    if ((param_4 != 0) && (iVar1 = fcn.0040d9b4(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*param_1 + 0x78))(0);\n    if (param_4 == iVar1) {\n        (**(*param_1 + 0x140))(param_2 | 0xff00, param_3, 1);\n    }\n    return;\n}\n",
        "token_count": 171
    },
    "0041e45d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e45d(uint *arg_8h)\n\n{\n    int32_t in_ECX;\n    \n    (***arg_8h)(*(in_ECX + 0x10c) != 2);\n    return;\n}\n",
        "token_count": 56
    },
    "0041e54c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041e54c(uint arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    uVar2 = 0x8000ffff;\n    if ((*(in_ECX + 0x108) != 0) && (*(in_ECX + 0x100) != 0)) {\n        puVar1 = *(in_ECX + 0x100);\n        uVar2 = (***puVar1)(puVar1, 0x44f680, arg_8h);\n    }\n    return uVar2;\n}\n",
        "token_count": 137
    },
    "0041e57d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041e57d(uint arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    uVar2 = 0x8000ffff;\n    if ((*(in_ECX + 0x10c) != 0) && (*(in_ECX + 0x104) != 0)) {\n        puVar1 = *(in_ECX + 0x104);\n        uVar2 = (***puVar1)(puVar1, 0x44f680, arg_8h);\n    }\n    return uVar2;\n}\n",
        "token_count": 138
    },
    "0041e5ae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041e5ae(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CPreviewView.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.00409c79();\n    if (extraout_ECX[0x4d] != NULL) {\n        fcn.0041e3ce(1);\n    }\n    fcn.0040644a(extraout_ECX[0x2a]);\n    if (extraout_ECX[0x24] != NULL) {\n        (**(*extraout_ECX[0x24] + 4))(1);\n    }\n    if (extraout_ECX[0x48] != NULL) {\n        uVar1 = (*_sym.imp.USER32.dll_LoadCursorW)(0, 0x7f00);\n        (*_sym.imp.USER32.dll_SetCursor)(uVar1);\n        (*_sym.imp.USER32.dll_DestroyCursor)(extraout_ECX[0x48]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00409cac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00407c04();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 373
    },
    "0041e825": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0041e825(int32_t *arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t var_8h;\n    \n    var_8h = in_ECX;\n    fcn.004082aa(arg_8h, &var_8h);\n    if (*(in_ECX + 0x10c) == 0) {\n        iVar2 = *(**(in_ECX + 0x134) + 0x74);\n        iVar1 = *(iVar2 + 0x1e);\n        if ((iVar1 != -1) && (iVar1 != *(iVar2 + 0x1c))) {\n            *arg_8h = *arg_8h - var_8h;\n        }\n    }\n    *(in_ECX + 0x11c) = (*arg_8h + -8) / 2;\n    if (*(in_ECX + 0x118) == 2) {\n        iVar2 = (*arg_8h + -0x18) / 2;\n    }\n    else {\n        iVar2 = *arg_8h + -0x10;\n    }\n    arg_8h[1] = arg_8h[1] + -0x10;\n    *arg_8h = iVar2;\n    return arg_8h;\n}\n",
        "token_count": 308
    },
    "0041e8a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e8a5(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    int32_t *piVar7;\n    uint xRight;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar6 = arg_8h * 0x28 + *(in_ECX + 0xb0);\n    fcn.0041e825(&var_8h);\n    iVar5 = *(iVar6 + 0x24);\n    iVar1 = *(in_ECX + 0x10c);\n    bVar2 = iVar5 <= *(iVar6 + 0x20);\n    if (iVar1 == 0) {\n        *(iVar6 + 0x18) = *(iVar6 + 0x20);\n        iVar4 = *(iVar6 + 0x24);\ncode_r0x0041e925:\n        *(iVar6 + 0x1c) = iVar4;\n    }\n    else {\n        iVar4 = iVar1 + -1;\n        if (iVar4 == 0) {\n            *(iVar6 + 0x1c) = iVar5;\n            if (bVar2) {\n                iVar5 = *(iVar6 + 0x20) * 3 - iVar5;\n            }\n            else {\n                iVar5 = *(iVar6 + 0x20) + iVar5;\n            }\n            iVar5 = iVar5 / 2;\n        }\n        else {\n            if (iVar1 != 2) goto code_r0x0041e928;\n            if (!bVar2) {\n                *(iVar6 + 0x18) = iVar4;\n                goto code_r0x0041e925;\n            }\n            *(iVar6 + 0x1c) = iVar5;\n            iVar5 = *(iVar6 + 0x20) * 2 - *(iVar6 + 0x24);\n        }\n        *(iVar6 + 0x18) = iVar5;\n    }\ncode_r0x0041e928:\n    iVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x10), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    iVar6 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x14), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    piVar7 = *(in_ECX + 0xb0) + arg_8h * 0x28;\n    (*_sym.imp.USER32.dll_SetRect)(piVar7, 8, 8, iVar5 + 0xb, iVar6 + 0xb);\n    pcVar3 = _sym.imp.USER32.dll_OffsetRect;\n    if (*(in_ECX + 0x10c) == 0) {\n        (*_sym.imp.USER32.dll_OffsetRect)\n                  (piVar7, ((*piVar7 - piVar7[2]) + var_8h) / 2 + -1, ((piVar7[1] - piVar7[3]) + var_4h) / 2 + -1);\n        if (arg_8h == 1) {\n            (*pcVar3)(piVar7, *(in_ECX + 0x11c), 0);\n        }\n    }\n    else {\n        fcn.00408afc(1, (piVar7[2] - *piVar7) + 0x10, (piVar7[3] - piVar7[1]) + 0x10, &var_8h, 0x447c50);\n    }\n    return;\n}\n",
        "token_count": 843
    },
    "0041ea2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041ea2d(int32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t lpRect;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t lprc;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 0x10c) != 0) {\n        piVar1 = fcn.0040819f(&var_ch);\n        iVar3 = piVar1[1];\n        *arg_8h = *arg_8h + *piVar1;\n        arg_8h[1] = arg_8h[1] + iVar3;\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n    *arg_ch = 0;\n    if (*(in_ECX + 0x118) != 0) {\n        do {\n            iVar3 = var_4h;\n            piVar1 = *arg_ch * 0x28 + *(in_ECX + 0xb0);\n            lprc = *piVar1;\n            var_10h = piVar1[1];\n            var_ch = piVar1[2];\n            var_8h = piVar1[3];\n            if (*(var_4h + 0x10c) != 0) {\n                iVar4 = (((var_1ch - var_ch) - lpRect) + -0x10 + lprc) / 2 + -1;\n                iVar2 = (((var_18h - var_8h) - var_20h) + -0x10 + var_10h) / 2 + -1;\n                if (iVar4 < 0) {\n                    iVar4 = 0;\n                }\n                if (iVar2 < 0) {\n                    iVar2 = 0;\n                }\n                (*_sym.imp.USER32.dll_OffsetRect)(&lprc, iVar4, iVar2);\n            }\n            iVar2 = (*_sym.imp.USER32.dll_PtInRect)(&lprc, *arg_8h, arg_8h[1]);\n            if (iVar2 != 0) {\n                iVar2 = *(*arg_ch * 0x28 + *(iVar3 + 0xb0));\n                arg_8h[1] = arg_8h[1] - *(*arg_ch * 0x28 + 4 + *(iVar3 + 0xb0));\n                *arg_8h = *arg_8h - iVar2;\n                iVar2 = *arg_ch * 0x28 + *(iVar3 + 0xb0);\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, *(iVar2 + 0x1c), *(iVar2 + 0x18));\n                *arg_8h = iVar2;\n                iVar3 = *arg_ch * 0x28 + *(iVar3 + 0xb0);\n                iVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_8h[1], *(iVar3 + 0x1c), *(iVar3 + 0x18));\n                arg_8h[1] = iVar3;\n                return 1;\n            }\n            *arg_ch = *arg_ch + 1;\n            in_ECX = iVar3;\n        } while (*arg_ch < *(iVar3 + 0x118));\n    }\n    return 0;\n}\n",
        "token_count": 841
    },
    "0041ec73": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041ec73(uint noname_0, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    uint var_8h;\n    \n    if (arg_ch == 1) {\n        (*_sym.imp.USER32.dll_GetCursorPos)(&var_8h);\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x20), &var_8h);\n        if ((*(in_ECX + 0x10c) == 2) || (iVar2 = fcn.0041ea2d(&var_8h, &arg_ch),  iVar2 == 0)) {\n            iVar2 = (*_sym.imp.USER32.dll_LoadCursorW)(0, 0x7f00);\n        }\n        else {\n            piVar3 = in_ECX + 0x120;\n            if (*piVar3 == 0) {\n                iVar2 = fcn.004213cc();\n                iVar2 = (*_sym.imp.USER32.dll_LoadCursorW)(*(iVar2 + 0xc), 0x7902);\n                *piVar3 = iVar2;\n            }\n            iVar2 = *piVar3;\n        }\n        (*_sym.imp.USER32.dll_SetCursor)(iVar2);\n        return 0;\n    }\n    uVar1 = fcn.0040d3b7();\n    return uVar1;\n}\n",
        "token_count": 327
    },
    "0041f0d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f0d0(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t in_stack_0000000c;\n    \n    if (in_ECX[0x43] != 0) {\n        if (((in_stack_0000000c == 0) || (iVar1 = fcn.0040d9b4(0),  iVar1 == 0)) &&\n           (iVar1 = (**(*in_ECX + 0x78))(1),  in_stack_0000000c == iVar1)) {\n            (**(*in_ECX + 0x140))((arg_8h & 0xff) << 8 | 0xff, arg_ch, 1);\n        }\n        return;\n    }\n    if (arg_8h == 0) {\n        arg_ch = in_ECX[0x45] - 1;\n    }\n    else if (arg_8h == 1) {\n        arg_ch = in_ECX[0x45] + 1;\n    }\n    else if (arg_8h == 2) {\n        arg_ch = in_ECX[0x45] - ((*(*(*in_ECX[0x4d] + 0x74) + 0x1e) - *(*(*in_ECX[0x4d] + 0x74) + 0x1c)) + 9) / 10;\n    }\n    else if (arg_8h == 3) {\n        arg_ch = ((*(*(*in_ECX[0x4d] + 0x74) + 0x1e) - *(*(*in_ECX[0x4d] + 0x74) + 0x1c)) + 9) / 10 + in_ECX[0x45];\n    }\n    else if (arg_8h != 4) {\n        if (arg_8h == 6) {\n            arg_ch = *(*(*in_ECX[0x4d] + 0x74) + 0x1c);\n        }\n        else {\n            if (arg_8h != 7) {\n                return;\n            }\n            arg_ch = *(*(*in_ECX[0x4d] + 0x74) + 0x1e);\n        }\n    }\n    fcn.0041eb73(arg_ch, 1);\n    return;\n}\n",
        "token_count": 543
    },
    "0041f85a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f85a(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = fcn.0041ea2d(&arg_ch, &var_4h);\n    if (iVar1 != 0) {\n        if (*(in_ECX + 0x10c) == 2) {\n            iVar1 = 0;\n        }\n        else {\n            iVar1 = *(in_ECX + 0x10c) + 1;\n        }\n        fcn.0041f6b5(iVar1, var_4h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 180
    },
    "00420a77": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nvoid fcn.00420a77(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (*0x45f568 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0x449028);\n        *0x45f568 = iVar2;\n        if (iVar2 == 0) {\n            iVar2 = fcn.00407ad1();\n        }\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        *0x45f554 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"CreateActCtxW\");\n        *0x45f558 = (*pcVar1)(*0x45f568, \"ReleaseActCtx\");\n        *0x45f55c = (*pcVar1)(*0x45f568, \"ActivateActCtx\");\n        *0x45f560 = (*pcVar1)(*0x45f568, \"DeactivateActCtx\");\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "00420b40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar __cdecl fcn.00420b40(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uchar uVar2;\n    \n    if (arg_ch == 0) {\n        fcn.00407ad1();\n    }\n    if (*0x45f55c == 0) {\n        uVar2 = 2;\n    }\n    else {\n        iVar1 = fcn.00420b12(arg_8h, arg_ch);\n        uVar2 = iVar1 != 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 125
    },
    "00420b73": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420b73(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint arg_8h;\n    uint var_230h;\n    uint var_22ch;\n    uint *var_228h;\n    uint var_21ch;\n    uint var_214h;\n    uint lpFilename;\n    int16_t var_8h;\n    ushort var_6h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.00420a77();\n    uVar2 = *(param_1 + 8);\n    var_6h = 0;\n    var_8h = 0;\n    arg_8h = 0x105;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(uVar2, &lpFilename);\n    if (iVar1 != 0) {\n        if (var_8h == 0) {\n            var_228h = &lpFilename;\n            puVar3 = &var_230h;\n            var_230h = 0x20;\n            var_22ch = 0x88;\n            var_21ch = 2;\n            var_214h = uVar2;\n            iVar1 = fcn.00420ae5(puVar3);\n            *(param_1 + 0x80) = iVar1;\n            if (iVar1 == -1) {\n                var_21ch = 3;\n                uVar2 = fcn.00420ae5(&var_230h);\n                *(param_1 + 0x80) = uVar2;\n            }\n            if (*(param_1 + 0x80) == -1) {\n                var_21ch = 1;\n                iVar1 = fcn.00420ae5(puVar3, &var_230h);\n                *(param_1 + 0x80) = iVar1;\n                if (iVar1 == -1) {\n                    *(param_1 + 0x80) = 0;\n                }\n            }\n        }\n        else {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x6f);\n        }\n    }\n    fcn.0042e09f(arg_8h);\n    return;\n}\n",
        "token_count": 514
    },
    "00420cfc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420cfc(code **param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.AFX_MODULE_THREAD_STATE.0;\n    if (param_1[0xf] != NULL) {\n        (**(*param_1[0xf] + 0x144))();\n    }\n    fcn.0040644a(param_1[0x12]);\n    if (param_1[5] != NULL) {\n        (***param_1[5])(1);\n    }\n    if (param_1[6] != NULL) {\n        (***param_1[6])(1);\n    }\n    if (param_1[7] != NULL) {\n        (***param_1[7])(1);\n    }\n    if (param_1[8] != NULL) {\n        (***param_1[8])(1);\n    }\n    if (param_1[9] != NULL) {\n        (***param_1[9])(1);\n    }\n    pcVar2 = param_1[0xe];\n    if (pcVar2 != NULL) {\n        while (*(pcVar2 + 0xc) != 0) {\n            uVar1 = fcn.00423ce5();\n            fcn.0040644a(uVar1);\n            pcVar2 = param_1[0xe];\n        }\n    }\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 4))(1);\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    if (param_1[0xe] != NULL) {\n        (**(*param_1[0xe] + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 406
    },
    "00420ef8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420ef8(code **param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    \n    *param_1 = vtable.CDllIsolationWrapperBase.0;\n    if (*(param_1 + 2) != '\\0') {\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(param_1[1]);\n    }\n    ppiVar3 = param_1[3] + -0x10;\n    piVar1 = param_1[3] + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar3 + 4))(ppiVar3);\n    }\n    return;\n}\n",
        "token_count": 194
    },
    "00421418": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421418(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.004213cc();\n    if ((*(iVar1 + 0x7c) == 0) || (*(arg_8h + 0x80) == -1)) {\n        *(in_ECX + 4) = 0;\n    }\n    else {\n        uVar2 = fcn.00420b12(*(arg_8h + 0x80));\n        *(in_ECX + 4) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 147
    },
    "00421450": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00421450(void)\n\n{\n    if (*0x45f574 == 0) {\n        *0x45f574 = 1;\n        (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x45f710);\n    }\n    return *0x45f574;\n}\n",
        "token_count": 68
    },
    "004214b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004214b9(uint32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (0x10 < arg_8h) {\n        fcn.00407ad1();\n    }\n    if (*0x45f574 == 0) {\n        fcn.00421450();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    piVar1 = arg_8h * 4 + 0x45f728;\n    if (*piVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x45f710);\n        if (*piVar1 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(arg_8h * 0x18 + 0x45f578);\n            *piVar1 = *piVar1 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x45f710);\n    }\n    (*pcVar2)(arg_8h * 0x18 + 0x45f578);\n    return;\n}\n",
        "token_count": 253
    },
    "00421e26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00421e26(int32_t lpString1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    \n    if (lpString1 == 0) {\n        fcn.00407ad1();\n    }\n    iVar1 = fcn.004213cc();\n    fcn.004214b9(0);\n    puVar2 = *(iVar1 + 0x1c);\n    while( true ) {\n        if (puVar2 == NULL) {\n            fcn.0042152b(0);\n            return NULL;\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(lpString1, *puVar2);\n        if (iVar1 == 0) break;\n        puVar2 = puVar2[5];\n    }\n    fcn.0042152b(0);\n    return puVar2;\n}\n",
        "token_count": 194
    },
    "004222c8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004222c8(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    \n    if (arg_8h == 0) {\n        fcn.00407ad1();\n        in_ECX = extraout_ECX;\n    }\n    return *(in_ECX + 4) + arg_8h;\n}\n",
        "token_count": 90
    },
    "00422680": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422680(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.00422300(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    (***arg_8h)(1);\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 359
    },
    "0042281d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042281d(uint arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = *0x45f7c4;\n    if (*0x45f7c4 != NULL) {\n        puVar1 = *0x45f7c4 + 7;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n        if (arg_ch == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*puVar3);\n            if (iVar4 != 0) {\n                fcn.00422680(iVar4, arg_8h);\n            }\n        }\n        else {\n            iVar4 = puVar3[5];\n            while (iVar4 != 0) {\n                iVar2 = *(iVar4 + 4);\n                fcn.00422680(iVar4, arg_8h);\n                iVar4 = iVar2;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n        return;\n    }\n    return;\n}\n",
        "token_count": 261
    },
    "00422773": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00422773(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_ch;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    if (*(unaff_EBP + 8) != 0) goto code_r0x00422792;\ncode_r0x0042278d:\n    do {\n        fcn.00407ad1();\ncode_r0x00422792:\n        if (*extraout_ECX != 0) goto code_r0x004227cd;\n        if (*0x45f7c4 == 0) {\n            *(unaff_EBP + -0x10) = 0x45f7c8;\n            *(unaff_EBP + -4) = 0;\n            *0x45f7c4 = fcn.00422489();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x45f7c4 == 0) goto code_r0x0042278d;\n        }\n        iVar1 = fcn.00422371();\n        *extraout_ECX = iVar1;\n        if (iVar1 != 0) {\ncode_r0x004227cd:\n            iVar1 = fcn.004221e3(*extraout_ECX);\n            if (iVar1 == 0) {\n                arg_ch = (**(unaff_EBP + 8))();\n                fcn.00422530(*extraout_ECX, arg_ch);\n            }\n            fcn.00430f73();\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 393
    },
    "00422921": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00422921(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t *in_ECX;\n    int32_t **ppiVar3;\n    \n    piVar1 = (**(*in_ECX + 0x44))(arg_8h);\n    if (piVar1 == NULL) {\n        ppiVar2 = (**(*in_ECX + 0x38))();\n        if ((((*0x44f650 == *arg_8h) && (arg_8h[1] == *0x44f654)) && (arg_8h[2] == *0x44f658)) &&\n           (arg_8h[3] == *0x44f65c)) {\n            do {\n                for (piVar1 = ppiVar2[1]; *piVar1 != 0; piVar1 = piVar1 + 2) {\n                    if (*(piVar1[1] + in_ECX) != 0) {\n                        return piVar1[1] + in_ECX;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        else {\n            do {\n                for (ppiVar3 = ppiVar2[1]; piVar1 = *ppiVar3,  piVar1 != NULL; ppiVar3 = ppiVar3 + 2) {\n                    if (((*piVar1 == *arg_8h) && (piVar1[1] == arg_8h[1])) &&\n                       ((piVar1[2] == arg_8h[2] && ((piVar1[3] == arg_8h[3] && (*(ppiVar3[1] + in_ECX) != 0)))))) {\n                        return ppiVar3[1] + in_ECX;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        piVar1 = NULL;\n    }\n    return piVar1;\n}\n",
        "token_count": 464
    },
    "004229d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004229d4(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(in_ECX + *piVar3);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 293
    },
    "00422a36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422a36(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != 0) {\n        (**(**(param_1 + 8) + 4))(*(param_1 + 8));\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(param_1 + 4);\n    return;\n}\n",
        "token_count": 86
    },
    "00422aa7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.00422aa7(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    int32_t iVar3;\n    \n    if (*(param_1 + 8) == 0) {\n        iVar3 = 8;\n        fcn.00430e9b(8);\n        if ((extraout_ECX[1] != 0) &&\n           (iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(extraout_ECX + 1),  iVar2 == 0)) {\n            fcn.00421418(extraout_ECX[7]);\n            iVar1 = *extraout_ECX;\n            *(unaff_EBP + -4) = 0;\n            (**(iVar1 + 0x10))();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*(unaff_EBP + -0x10) != 0) {\n                fcn.00420b29();\n                iVar3 = iVar2;\n            }\n        }\n        fcn.00430f73(iVar3);\n        return;\n    }\n    (**(**(param_1 + 8) + 8))(*(param_1 + 8));\n    return;\n}\n",
        "token_count": 327
    },
    "00422aff": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00422aff(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 8) != 0) {\n        iVar1 = (****(in_ECX + 8))(*(in_ECX + 8), arg_8h, arg_ch);\n        return iVar1;\n    }\n    iVar1 = fcn.00422921(arg_8h);\n    *arg_ch = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.004229d4(arg_8h);\n        *arg_ch = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.00422a36();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 209
    },
    "00422b62": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00422b62(uint hKey, uint lpSubKey, uint phkResult)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    fcn.00402680(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.00420ca6();\n        if (iVar1 == 1) {\n            uVar2 = fcn.004188d3(unaff_EBP + 8, L\"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.00401930(uVar2);\n            fcn.00401020();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCreateKeyW)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 314
    },
    "00422bea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00422bea(uint hKey, uint lpSubKey, uint lpData, uint lpcbData)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    fcn.00402680(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.00420ca6();\n        if (iVar1 == 1) {\n            uVar2 = fcn.004188d3(unaff_EBP + 8, L\"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.00401930(uVar2);\n            fcn.00401020();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegQueryValueW)\n              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 330
    },
    "00422c75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00422c75(uint hKey, uint lpSubKey, uint dwType, uint lpData, uint cbData)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    fcn.00402680(*(unaff_EBP + 0xc));\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 8) == -0x80000000) {\n        iVar1 = fcn.00420ca6();\n        if (iVar1 == 1) {\n            uVar2 = fcn.004188d3(unaff_EBP + 8, L\"Software\\\\Classes\\\\\", unaff_EBP + 0xc);\n            *(unaff_EBP + -4) = 1;\n            fcn.00401930(uVar2);\n            fcn.00401020();\n            *(unaff_EBP + 8) = 0x80000001;\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegSetValueW)\n              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 343
    },
    "00422f00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422f00(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar3 = fcn.00424332(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar1 = *(param_1 + 0x18);\n        puVar4 = iVar3 + -8 + iVar1 * 0xc;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar4 = *(param_1 + 0x10);\n            *(param_1 + 0x10) = puVar4;\n            puVar4 = puVar4 + -3;\n        }\n    }\n    puVar4 = *(param_1 + 0x10);\n    uVar2 = *puVar4;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar2;\n    puVar4[1] = 0;\n    puVar4[2] = 0;\n    return;\n}\n",
        "token_count": 288
    },
    "00423113": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00423113(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x44) != 0);\n        while (var_8h != 0) {\n            fcn.00422e3f(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x58) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x5c) == 2) {\n                puVar1[1] = 0;\n            }\n            (**(param_1 + 0x18))(var_4h);\n        }\n        fcn.00422d03();\n        fcn.0042c865();\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "004231e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004231e6(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.004213ff();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (((arg_8h != -1) && (iVar2 = fcn.0041a73a(),  iVar2 != 0)) && (*(iVar2 + 0x3c) != NULL)) {\n                (**(iVar2 + 0x3c))(0, 0);\n            }\n            fcn.00423113();\n            fcn.00423113();\n            fcn.00423113();\n            fcn.00423113();\n            fcn.00423113();\n        }\n        iVar2 = fcn.004213cc();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.00422235();\n        if ((((iVar3 != 0) && (iVar2 != 0)) &&\n            ((*(iVar3 + 0xc) == 0 || (uVar4 = fcn.00431fce(*(iVar3 + 0xc)),  uVar4 < *(iVar2 + 0x98))))) &&\n           (*(iVar2 + 0x98) != 0)) {\n            arg_8h = 0;\n            if (*(iVar3 + 0xc) != 0) {\n                arg_8h = fcn.00431fce(*(iVar3 + 0xc));\n                fcn.0042e518(*(iVar3 + 0xc));\n            }\n            iVar2 = fcn.0042eec5(*(iVar2 + 0x98));\n            *(iVar3 + 0xc) = iVar2;\n            if ((iVar2 == 0) && (arg_8h != 0)) {\n                uVar5 = fcn.0042eec5(arg_8h);\n                *(iVar3 + 0xc) = uVar5;\n            }\n        }\n    }\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 526
    },
    "00423436": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00423436(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    iVar1 = fcn.004213ff();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00406404(fcn.00421648);\n        iVar2 = fcn.0040641b(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.00422fd7(0x44bc48, fcn.0042341c, fcn.004096f6, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar3;\n        fcn.00406404(arg_8h_00);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 323
    },
    "00423537": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00423537(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0042350b();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 86
    },
    "00423db7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423db7(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x10) == 0) {\n        iVar2 = fcn.00424332(in_ECX + 0x14, *(in_ECX + 0x18), 0xc);\n        iVar1 = *(in_ECX + 0x18);\n        puVar3 = iVar2 + -8 + iVar1 * 0xc;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar3 = *(in_ECX + 0x10);\n            *(in_ECX + 0x10) = puVar3;\n            puVar3 = puVar3 + -3;\n        }\n    }\n    puVar3 = *(in_ECX + 0x10);\n    *(in_ECX + 0x10) = *puVar3;\n    puVar3[1] = arg_8h;\n    *puVar3 = arg_ch;\n    *(in_ECX + 0xc) = *(in_ECX + 0xc) + 1;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 295
    },
    "004241fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004241fb(int32_t arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    int32_t arg_10h;\n    \n    if (arg_8h != 0) {\n        arg_10h = arg_8h;\n        arg_8h_00 = fcn.00423e69(arg_8h);\n        fcn.004241b5(arg_8h_00, arg_8h, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 116
    },
    "00424332": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424332(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    if ((arg_ch != 0) && (arg_10h != 0)) {\n        puVar2 = fcn.0040641b(arg_ch * arg_10h + 4);\n        *puVar2 = *arg_8h;\n        *arg_8h = puVar2;\n        return;\n    }\n    fcn.00407ad1();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 147
    },
    "00424401": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424401(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x1c) == 0) {\n        uVar1 = fcn.0040d0a9(\"ImageList_Destroy\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x1c) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 131
    },
    "004244a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.004244a5(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "004244f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004244f6(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00430e9b(0);\n    iVar1 = fcn.004213ff();\n    if ((*(iVar1 + 0x24) == 0) && (*(unaff_EBP + 8) != 0)) {\n        arg_8h_00 = fcn.00406404(fcn.00421648);\n        iVar2 = fcn.0040641b(0x60);\n        *(unaff_EBP + 8) = iVar2;\n        *(unaff_EBP + -4) = 0;\n        if (iVar2 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = fcn.00422fd7(0x44bd10, fcn.004243e7, fcn.004096f6, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x24) = uVar3;\n        fcn.00406404(arg_8h_00);\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 324
    },
    "00424596": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00424596(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0042456a();\n    uVar1 = fcn.004244db(uVar1);\n    return uVar1;\n}\n",
        "token_count": 82
    },
    "004246ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004246ea(int16_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int16_t *piVar4;\n    uint uVar5;\n    \n    uVar5 = 0xffffffff;\n    piVar4 = arg_8h;\n    iVar1 = fcn.004219e3(arg_8h);\n    if (iVar1 == 0) {\n        fcn.00407ad1(piVar4, uVar5);\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_8h);\n    iVar2 = fcn.00426d05(arg_8h, 0, 0);\n    iVar2 = iVar2 + -1;\n    if (arg_ch < iVar1) {\n        if (arg_ch < iVar2) {\n            if (arg_10h == 0) {\n                *arg_8h = 0;\n                return;\n            }\n        }\n        else {\n            piVar4 = arg_8h + 2;\n            if ((*arg_8h == 0x5c) && (arg_8h[1] == 0x5c)) {\n                for (; *piVar4 != 0x5c; piVar4 = piVar4 + 1) {\n                }\n            }\n            if (3 < iVar1 - iVar2) {\n                do {\n                    piVar4 = piVar4 + 1;\n                } while (*piVar4 != 0x5c);\n            }\n            iVar3 = piVar4 - arg_8h >> 1;\n            if (iVar3 + 5 + iVar2 <= arg_ch) {\n                while (iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenW)(piVar4),  arg_ch < iVar2 + 4 + iVar3) {\n                    do {\n                        piVar4 = piVar4 + 1;\n                    } while (*piVar4 != 0x5c);\n                }\n                if ((iVar3 < 0) || (arg_ch <= iVar3)) {\n                    iVar3 = arg_ch;\n                }\n                fcn.00408f79(arg_8h + iVar3, (iVar1 - iVar3) + 1, L\"\\\\...\", 10);\n                fcn.00412b2d(arg_8h, iVar1 + 1, piVar4);\n                return;\n            }\n        }\n        fcn.00417428(arg_8h, iVar1 + 1, arg_8h + (iVar1 - iVar2));\n    }\n    return;\n}\n",
        "token_count": 583
    },
    "0042502e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042502e(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint16_t *puVar3;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (arg_8h == 0) {\n        uVar2 = 0;\n    }\n    else {\n        puVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(arg_8h);\n        if (arg_ch == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*pcVar1)(arg_ch);\n        }\n        if (puVar3 == NULL) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = (*_sym.imp.GDI32.dll_CreateDCW)(puVar3 + *puVar3, puVar3 + puVar3[1], puVar3 + puVar3[2], uVar2);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(arg_8h);\n            if (arg_ch != 0) {\n                (*pcVar1)(arg_ch);\n            }\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 285
    },
    "004250c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004250c3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.004250a4(*(unaff_EBP + 0x10));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CPrintDialog.0;\n    extraout_ECX[0x1d] = extraout_ECX + 0x1e;\n    fcn.00430820(extraout_ECX + 0x1e, 0, 0x42);\n    *extraout_ECX[0x1d] = 0x42;\n    *(extraout_ECX[0x1d] + 0x14) = *(unaff_EBP + 0xc) | 0x3000;\n    iVar2 = fcn.0041b2b2();\n    if (iVar2 != 0) {\n        *(extraout_ECX[0x1d] + 0x14) = *(extraout_ECX[0x1d] + 0x14) | 0x800;\n    }\n    iVar2 = *(unaff_EBP + 8);\n    *(extraout_ECX[0x1d] + 0x2a) = fcn.00425430;\n    *(extraout_ECX[0x1d] + 0x2e) = fcn.00425430;\n    if (iVar2 == 0) {\n        extraout_ECX[0x15] = 0x7008;\n        puVar1 = extraout_ECX[0x1d] + 0x14;\n        *puVar1 = *puVar1 | 0x100;\n    }\n    else {\n        extraout_ECX[0x15] = 0x7009;\n        puVar1 = extraout_ECX[0x1d] + 0x14;\n        *puVar1 = *puVar1 | 0x40;\n    }\n    *(extraout_ECX[0x1d] + 0x14) = *(extraout_ECX[0x1d] + 0x14) & 0xfffffdff;\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 605
    },
    "004251f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004251f8(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        uVar1 = fcn.0040d0a9(\"PrintDlgW\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x4c) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x4c);\n    return;\n}\n",
        "token_count": 132
    },
    "0042529c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0042529c(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 187
    },
    "004255d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004255d8(uint hKey, uint lpString, int32_t lpValueName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    bool bVar3;\n    \n    if (lpValueName == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString);\n        iVar1 = fcn.00422c75(0x80000000, hKey, 1, lpString, iVar1 * 2);\n        bVar3 = iVar1 == 0;\n    }\n    else {\n        iVar1 = fcn.00422b62(0x80000000, hKey, &hKey);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString);\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegSetValueExW)(hKey, lpValueName, 0, 1, lpString, iVar1 * 2 + 2);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            if ((iVar2 == 0) && (iVar1 == 0)) {\n                return true;\n            }\n        }\n        bVar3 = false;\n    }\n    return bVar3;\n}\n",
        "token_count": 286
    },
    "00425868": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00425868(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t iVar3;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = *(param_1 + 8);\n    iVar3 = 0;\n    var_4h = param_1;\n    while (var_8h != 0) {\n        ppiVar2 = fcn.0040b31f(&var_8h);\n        piVar1 = *ppiVar2;\n        var_4h = (**(*piVar1 + 0x54))();\n        while (var_4h != 0) {\n            (**(*piVar1 + 0x58))(&var_4h);\n            iVar3 = iVar3 + 1;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 205
    },
    "00425b76": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00425b76(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0xc);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.CDocManager.0;\n    pcVar1 = extraout_ECX[2];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        *(unaff_EBP + -0x14) = pcVar1;\n        ppiVar3 = fcn.0040b31f(unaff_EBP + -0x10);\n        piVar2 = *ppiVar3;\n        if (piVar2[8] != 0) {\n            fcn.00423d16(*(unaff_EBP + -0x14));\n            (**(*piVar2 + 4))(1);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00423dac();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 334
    },
    "00426d05": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00426d05(int32_t pszPath, int32_t arg_ch, uint arg_10h)\n\n{\n    uint arg_10h_00;\n    int32_t iVar1;\n    \n    if (pszPath == 0) {\n        fcn.00407ad1();\n    }\n    arg_10h_00 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameW)(pszPath);\n    if (arg_ch == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_10h_00);\n        iVar1 = iVar1 + 1;\n    }\n    else {\n        fcn.00407b1c(arg_ch, arg_10h, arg_10h_00, 0xffffffff);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 186
    },
    "00426d45": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00426d45(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    ushort *arg_8h;\n    uint uVar3;\n    uint *arg_8h_00;\n    char16_t *arg_10h;\n    uint *arg_8h_01;\n    uint var_618h;\n    uint var_614h;\n    uint var_414h;\n    uint lpFilename;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    iVar1 = fcn.004213cc();\n    *(iVar1 + 8) = *(param_1 + 0x44);\n    *(iVar1 + 0xc) = *(param_1 + 0x44);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(*(param_1 + 0x44), &lpFilename, 0x104);\n    if ((iVar2 == 0) || (iVar2 == 0x104)) {\n        fcn.004096da();\n    }\n    arg_8h_01 = &lpFilename;\n    arg_8h = (*_sym.imp.SHLWAPI.dll_PathFindExtensionW)();\n    if (arg_8h == NULL) {\n        fcn.004096da();\n    }\n    *arg_8h = 0;\n    iVar2 = fcn.00426d05(&lpFilename, &var_414h, 0x104);\n    if (iVar2 != 0) {\n        fcn.004096da();\n    }\n    if (*(param_1 + 0x60) != 0) goto code_r0x00426df8;\n    iVar2 = fcn.00431a97(&var_414h);\n    *(param_1 + 0x60) = iVar2;\n    if (iVar2 != 0) goto code_r0x00426df8;\ncode_r0x00426df3:\n    do {\n        fcn.00407a99();\ncode_r0x00426df8:\n        iVar2 = *(param_1 + 0x50);\n        if (iVar2 == 0) {\n            iVar2 = fcn.00410bdc(0xe000, &var_614h, 0x100);\n            if (iVar2 == 0) {\n                arg_8h_00 = *(param_1 + 0x60);\n            }\n            else {\n                arg_8h_00 = &var_614h;\n            }\n            iVar2 = fcn.00431a97(arg_8h_00);\n            *(param_1 + 0x50) = iVar2;\n            if (iVar2 == 0) goto code_r0x00426df3;\n        }\n        *(iVar1 + 0x10) = iVar2;\n        if (*(param_1 + 100) == 0) {\n            if (*(param_1 + 0x6c) == 1) {\n                arg_10h = L\".CHM\";\n            }\n            else {\n                arg_10h = L\".HLP\";\n            }\n            fcn.00417428(arg_8h, 0x104 - (arg_8h - &lpFilename >> 1), arg_10h);\n            iVar2 = fcn.00431a97(&lpFilename);\n            *(param_1 + 100) = iVar2;\n            if (iVar2 == 0) goto code_r0x00426df3;\n            *arg_8h = 0;\n        }\n        if (*(param_1 + 0x68) != 0) goto code_r0x00426ecb;\n        uVar3 = fcn.004316e2(&var_414h, 0x104, L\".INI\");\n        fcn.00401d80(uVar3);\n        iVar2 = fcn.00431a97(&var_414h);\n        *(param_1 + 0x68) = iVar2;\n        if (iVar2 != 0) {\ncode_r0x00426ecb:\n            fcn.0042e09f(arg_8h_01);\n            return;\n        }\n    } while( true );\n}\n",
        "token_count": 932
    },
    "00426eda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00426eda(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.004213cc();\n    *(iVar3 + 8) = arg_8h;\n    *(iVar3 + 0xc) = arg_8h;\n    fcn.00420b73();\n    iVar3 = fcn.004213cc();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x48) = arg_10h;\n        *(iVar3 + 0x4c) = arg_14h;\n        *(iVar3 + 0x44) = arg_8h;\n        fcn.00426d45();\n    }\n    iVar3 = fcn.004213cc();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.0041ad3d();\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(L\"user32.dll\");\n    if (iVar3 != 0) {\n        *0x45f3c4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"NotifyWinEvent\");\n    }\n    return 1;\n}\n",
        "token_count": 358
    },
    "00426ff9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00426ff9(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int16_t *piVar4;\n    uint16_t *puVar5;\n    uint16_t uVar6;\n    bool bVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar7 = *(arg_8h + 2) == -1;\n    iVar2 = fcn.00426fa8(arg_8h);\n    iVar3 = fcn.00426f61(arg_8h);\n    if (iVar3 != 0) {\n        iVar2 = iVar2 + (bVar7 * 2 + 1) * 2;\n        iVar3 = fcn.00430fa5(iVar2);\n        iVar2 = iVar2 + 2 + iVar3 * 2;\n    }\n    if (bVar7) {\n        iVar1 = *(arg_8h + 0x10);\n    }\n    else {\n        iVar1 = *(arg_8h + 8);\n    }\n    if (iVar1 != 0) {\n        do {\n            piVar4 = (iVar2 + 3U & 0xfffffffc) + (-bVar7 & 6) + 0x12;\n            if (*piVar4 == -1) {\n                piVar4 = piVar4 + 2;\n            }\n            else {\n                piVar4 = fcn.00426f94(piVar4);\n            }\n            if (*piVar4 == -1) {\n                puVar5 = piVar4 + 2;\n            }\n            else {\n                puVar5 = fcn.00426f94(piVar4);\n            }\n            uVar6 = *puVar5;\n            if ((uVar6 != 0) && (!bVar7)) {\n                uVar6 = uVar6 - 2;\n            }\n            iVar1 = iVar1 + -1;\n            iVar2 = puVar5 + uVar6 + 2;\n        } while (iVar1 != 0);\n    }\n    return iVar2 - arg_8h;\n}\n",
        "token_count": 475
    },
    "0042712d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042712d(uint lpString, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t *arg_8h;\n    int32_t iVar3;\n    int32_t iVar4;\n    ushort *puVar5;\n    uint32_t arg_10h;\n    uint uVar6;\n    uint *in_ECX;\n    int32_t iVar7;\n    uint32_t arg_ch_00;\n    int16_t iVar8;\n    uint32_t arg_8h_00;\n    bool bVar9;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (in_ECX[1] == 0) {\n        return 0;\n    }\n    arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n    bVar9 = *(arg_8h + 2) == -1;\n    iVar3 = fcn.00426f61(arg_8h);\n    iVar1 = bVar9 * 2 + 1;\n    iVar2 = iVar1 * 2;\n    if (bVar9) {\n        arg_8h[3] = arg_8h[3] | 0x40;\n    }\n    else {\n        *arg_8h = *arg_8h | 0x40;\n    }\n    iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenW)(lpString);\n    if ((iVar4 < 0x20) && (iVar4 = iVar2 + 2 + iVar4 * 2,  iVar2 <= iVar4)) {\n        puVar5 = fcn.00426fa8(arg_8h);\n        iVar7 = 0;\n        if (iVar3 != 0) {\n            iVar3 = fcn.00430fa5(puVar5 + iVar1);\n            iVar7 = iVar2 + 2 + iVar3 * 2;\n        }\n        arg_10h = iVar7 + 3 + puVar5 & 0xfffffffc;\n        arg_8h_00 = puVar5 + iVar4 + 3 & 0xfffffffc;\n        if (bVar9) {\n            iVar8 = *(arg_8h + 4);\n        }\n        else {\n            iVar8 = *(arg_8h + 2);\n        }\n        if ((iVar4 != iVar7) && (iVar8 != 0)) {\n            arg_ch_00 = (in_ECX[1] - arg_10h) + arg_8h;\n            if (in_ECX[1] < arg_ch_00) goto code_r0x00427207;\n            fcn.00421a61(arg_8h_00, arg_ch_00, arg_10h, arg_ch_00);\n        }\n        *puVar5 = arg_ch;\n        iVar4 = iVar4 + iVar1 * -2;\n        fcn.00421a61(puVar5 + iVar1, iVar4, lpString, iVar4);\n        in_ECX[1] = in_ECX[1] + (arg_8h_00 - arg_10h);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n        in_ECX[2] = 0;\n        uVar6 = 1;\n    }\n    else {\ncode_r0x00427207:\n        uVar6 = 0;\n    }\n    return uVar6;\n}\n",
        "token_count": 766
    },
    "00427252": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427252(uint32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char16_t *lpString;\n    uint unaff_EDI;\n    uint32_t uVar5;\n    uint var_64h;\n    int32_t lpvObject;\n    uint var_44h;\n    uint32_t var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    uVar5 = 10;\n    lpString = L\"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x004272d0;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectW)(iVar2, 0x5c, &lpvObject);\n    if (iVar2 != 0) {\n        lpString = &var_44h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        uVar5 = uVar5 & 0xffff;\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x004272d0:\n    if (arg_8h == 0) {\n        arg_8h = uVar5;\n    }\n    fcn.0042712d(lpString, arg_8h);\n    fcn.0042e09f(unaff_EDI);\n    return;\n}\n",
        "token_count": 460
    },
    "00427653": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00427653(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    uint var_4h;\n    \n    if (*(*(param_1 + 100) + -0xc) == 0) {\n        fcn.00402820(*(param_1 + 0x40));\n    }\n    pcVar2 = _sym.imp.USER32.dll_LoadAcceleratorsW;\n    pcVar1 = _sym.imp.USER32.dll_LoadMenuW;\n    if ((*(param_1 + 0x48) != 0) && (*(param_1 + 0x30) == 0)) {\n        iVar3 = fcn.004213cc();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x30) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x34) = uVar5;\n    }\n    if ((*(param_1 + 0x44) != 0) && (*(param_1 + 0x38) == 0)) {\n        iVar3 = fcn.004213cc();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x38) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x3c) = uVar5;\n    }\n    if ((*(param_1 + 0x4c) != 0) && (*(param_1 + 0x28) == 0)) {\n        iVar3 = fcn.004213cc();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x4c));\n        *(param_1 + 0x28) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x4c));\n        *(param_1 + 0x2c) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 556
    },
    "00427a56": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00427a56(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    \n    if ((*(param_1 + 0x20) != 0) && (iVar1 = fcn.00413e8c(),  iVar1 != 0)) {\n        piVar2 = fcn.00413e76();\n    // WARNING: Could not recover jumptable at 0x00427a76. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar3 = (**(*piVar2 + 0x60))();\n        return uVar3;\n    }\n    uVar3 = 0;\n    if (*(param_1 + 0x20) == 0) {\n        if (*(param_1 + 0x50) == 0) {\n            return 0;\n        }\n    }\n    else {\n        iVar1 = fcn.0040d3e9(0);\n        if (iVar1 == 0) {\n            fcn.00407ad1();\n        }\n        fcn.00422d89(*(param_1 + 0x20));\n    }\n    if ((*(param_1 + 0x20) != 0) || (*(param_1 + 0x50) != 0)) {\n        if (*(param_1 + 0x50) == 0) {\n            uVar3 = (*_sym.imp.USER32.dll_DestroyWindow)(*(param_1 + 0x20));\n        }\n        else {\n            uVar3 = (**(**(param_1 + 0x50) + 0x58))();\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 379
    },
    "00427c50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427c50(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    \n    uVar1 = *(in_ECX + 0x84);\n    if ((uVar1 & 0x100) != 0) {\n        *arg_8h = *arg_8h + *0x45f780;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        arg_8h[1] = arg_8h[1] + *0x45f784;\n    }\n    if ((uVar1 & 0x400) != 0) {\n        arg_8h[2] = arg_8h[2] - *0x45f780;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        arg_8h[3] = arg_8h[3] - *0x45f784;\n    }\n    if (arg_ch == 0) {\n        *arg_8h = *arg_8h + *(in_ECX + 100);\n        arg_8h[1] = arg_8h[1] + *(in_ECX + 0x5c);\n        arg_8h[2] = arg_8h[2] - *(in_ECX + 0x68);\n        arg_8h[3] = arg_8h[3] - *(in_ECX + 0x60);\n        if ((*(in_ECX + 0x84) & 0x400001) == 0x400000) {\n            arg_8h[1] = arg_8h[1] + 7;\n        }\n    }\n    else {\n        *arg_8h = *arg_8h + *(in_ECX + 0x5c);\n        arg_8h[1] = arg_8h[1] + *(in_ECX + 100);\n        arg_8h[2] = arg_8h[2] - *(in_ECX + 0x60);\n        arg_8h[3] = arg_8h[3] - *(in_ECX + 0x68);\n        if ((*(in_ECX + 0x84) & 0x400001) == 0x400000) {\n            *arg_8h = *arg_8h + 7;\n        }\n    }\n    return;\n}\n",
        "token_count": 550
    },
    "00427d8e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427d8e(uint *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    if ((arg_ch == 0) || (arg_10h == 0)) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 0x7fff;\n    }\n    *arg_8h = uVar1;\n    if ((arg_ch == 0) || (arg_10h != 0)) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 0x7fff;\n    }\n    arg_8h[1] = uVar1;\n    return;\n}\n",
        "token_count": 161
    },
    "00427e02": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427e02(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint arg_8h_00;\n    int32_t *piVar6;\n    int32_t *in_ECX;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar2 < 0) {\n        return;\n    }\n    iVar3 = fcn.004213ff();\n    var_8h = iVar3;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[8], &var_10h);\n    var_4h = (**(*in_ECX + 0x74))(var_10h, var_ch, 0);\n    if (var_4h < 0) {\n        *(iVar3 + 0x4c) = 0xffffffff;\n    }\n    else {\n        iVar4 = fcn.0040ec49();\n        iVar5 = fcn.0040fd7c();\n        if (iVar5 == 0) {\ncode_r0x00427e7f:\n            var_4h = -1;\n        }\n        else {\n            if (iVar4 == 0) {\n                fcn.00407ad1();\n            }\n            iVar5 = fcn.00410ad9();\n            if (iVar5 == 0) goto code_r0x00427e7f;\n        }\n        if (*(iVar3 + 0x3c) == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *(*(iVar3 + 0x3c) + 0x20);\n        }\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetCapture)();\n        piVar6 = fcn.0040d45d(arg_8h_00);\n        if (piVar6 != in_ECX) {\n            if (piVar6 == NULL) {\n                iVar5 = 0;\n            }\n            else {\n                iVar5 = piVar6[8];\n            }\n            if ((iVar5 != iVar3) && (iVar3 = fcn.0040ec49(),  iVar3 == iVar4)) {\n                var_4h = -1;\n            }\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_KillTimer;\n    if (-1 < var_4h) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[8], &var_10h);\n        iVar3 = (*_sym.imp.USER32.dll_WindowFromPoint)(var_10h, var_ch);\n        if (iVar3 == 0) {\ncode_r0x00427f14:\n            var_4h = -1;\n            *(var_8h + 0x4c) = 0xffffffff;\n        }\n        else if ((iVar3 != in_ECX[8]) && (iVar4 = (*_sym.imp.USER32.dll_IsChild)(in_ECX[8], iVar3),  iVar4 == 0)) {\n            iVar4 = *(var_8h + 0x3c);\n            if (iVar4 != 0) {\n                iVar4 = *(iVar4 + 0x20);\n            }\n            if (iVar4 != iVar3) goto code_r0x00427f14;\n        }\n        if (-1 < var_4h) goto code_r0x00427f44;\n    }\n    if (*(var_8h + 0x4c) == -1) {\n        (*pcVar1)(in_ECX[8], 0xe001);\n    }\n    (**(*in_ECX + 0x178))(0xffffffff);\ncode_r0x00427f44:\n    if ((arg_8h == 0xe000) && ((*pcVar1)(in_ECX[8], 0xe000),  -1 < var_4h)) {\n        (**(*in_ECX + 0x178))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 939
    },
    "004282a8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004282a8(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x24] != 0) && (iVar1 = (**(*in_ECX + 0x74))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[8], &arg_ch);\n        (***in_ECX[0x25])(arg_ch, arg_10h);\n        return;\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 156
    },
    "004282f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004282f6(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x24] != 0) && (iVar1 = (**(*in_ECX + 0x74))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (**(*in_ECX[0x25] + 8))();\n        return;\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 131
    },
    "00428d7b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428d7b(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == 0) {\n        arg_8h = 0x11;\n    }\n    if (*(in_ECX + 4) != 0) {\n        fcn.0040644a(*(in_ECX + 4));\n        *(in_ECX + 4) = 0;\n    }\n    if (arg_ch != 0) {\n        uVar1 = fcn.0040641b(-(arg_8h * 4 >> 0x20 != 0) | arg_8h * 4);\n        *(in_ECX + 4) = uVar1;\n        fcn.00430820(uVar1, 0, arg_8h << 2);\n    }\n    *(in_ECX + 8) = arg_8h;\n    return;\n}\n",
        "token_count": 218
    },
    "00428e12": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00428e12(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar3 = fcn.00424332(param_1 + 0x14, *(param_1 + 0x18), 0x10);\n        iVar1 = *(param_1 + 0x18);\n        puVar4 = iVar3 + -0xc + iVar1 * 0x10;\n        while (iVar1 = iVar1 + -1,  -1 < iVar1) {\n            *puVar4 = *(param_1 + 0x10);\n            *(param_1 + 0x10) = puVar4;\n            puVar4 = puVar4 + -4;\n        }\n    }\n    puVar4 = *(param_1 + 0x10);\n    uVar2 = *puVar4;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar2;\n    if (puVar4 != 0xfffffff8) {\n        fcn.00401890();\n    }\n    puVar4[3] = 0;\n    return puVar4;\n}\n",
        "token_count": 308
    },
    "004293a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.004293a9(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *var_4h;\n    \n    if ((param_1[0x39] & 8U) != 0) {\n        var_4h = param_1;\n        (**(*param_1 + 0x150))(param_1[0x39] & 4);\n    }\n    var_4h = param_1[0x22];\n    while (var_4h != NULL) {\n        piVar1 = fcn.0040b31f(&var_4h);\n        fcn.0040dd00(*piVar1, *(*piVar1 + 0x20), 0x363, 1, 0);\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "00429dc5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00429dc5(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.GDI32.dll_GetStockObject;\n    if (param_1[1] != 0) {\n        uVar4 = (*_sym.imp.GDI32.dll_GetStockObject)(7);\n        pcVar3 = _sym.imp.GDI32.dll_SelectObject;\n        uVar4 = (*_sym.imp.GDI32.dll_SelectObject)(param_1[2], uVar4);\n        (*pcVar3)(param_1[2], uVar4);\n        (*pcVar3)(param_1[1], uVar4);\n        uVar4 = (*pcVar2)(4);\n        uVar4 = (*pcVar3)(param_1[2], uVar4);\n        (*pcVar3)(param_1[2], uVar4);\n        (*pcVar3)(param_1[1], uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetROP2)(param_1[2]);\n        fcn.0040949a(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetBkMode)(param_1[2]);\n        fcn.00409436(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetTextAlign)(param_1[2]);\n        fcn.0040963d(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetPolyFillMode)(param_1[2]);\n        fcn.00409468(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetStretchBltMode)(param_1[2]);\n        fcn.004094cc(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetTextColor)(param_1[2]);\n        iVar1 = *param_1;\n        uVar4 = fcn.00429d61(uVar4);\n        (**(iVar1 + 0x30))(uVar4);\n        uVar4 = (*_sym.imp.GDI32.dll_GetBkColor)(param_1[2]);\n        iVar1 = *param_1;\n        uVar4 = fcn.00429d61(uVar4);\n        (**(iVar1 + 0x2c))(uVar4);\n    }\n    return;\n}\n",
        "token_count": 550
    },
    "00429ea5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_b8h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00429ea5(int32_t *param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t var_b8h;\n    int32_t var_ach;\n    uint var_a4h;\n    uint var_9ch;\n    uint var_84h;\n    uchar var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    int32_t var_74h;\n    uint var_70h;\n    int32_t var_6ch;\n    uint lpSize;\n    int32_t var_64h;\n    int32_t lpvObject;\n    uint var_5ch;\n    uint var_50h;\n    uint var_4ch;\n    uint8_t var_45h;\n    uint lpFaceName;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    if (param_1[2] != 0) {\n        if (param_1[0xb] == 0) {\n            (**(*param_1 + 0x24))(0xe);\n        }\n        else if (param_1[1] != 0) {\n            (*_sym.imp.GDI32.dll_GetObjectW)(param_1[0xb], 0x5c, &lpvObject);\n            (*_sym.imp.GDI32.dll_GetTextFaceW)(param_1[2], 0x20, &lpFaceName);\n            pcVar2 = _sym.imp.GDI32.dll_GetTextMetricsW;\n            (*_sym.imp.GDI32.dll_GetTextMetricsW)(param_1[2], &var_b8h);\n            pcVar1 = _sym.imp.GDI32.dll_CreateFontIndirectW;\n            if (var_b8h < 0) {\n                lpvObject = var_b8h;\n            }\n            else {\n                lpvObject = var_ach - var_b8h;\n            }\n            var_5ch = var_a4h;\n            var_50h = var_9ch;\n            var_4ch._0_1_ = var_84h;\n            var_4ch._1_1_ = var_84h._1_1_;\n            var_4ch._2_1_ = var_84h._2_1_;\n            var_4ch._3_1_ = var_80h;\n            var_45h = var_84h._3_1_;\n            var_74h = (*_sym.imp.GDI32.dll_CreateFontIndirectW)(&lpvObject);\n            (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], var_74h);\n            (*pcVar2)(param_1[1], &var_b8h);\n            iVar4 = -lpvObject;\n            if (var_b8h < 0) {\n                var_78h = -var_b8h;\n            }\n            else {\n                var_78h = var_b8h - var_ach;\n            }\n            (*_sym.imp.GDI32.dll_GetWindowExtEx)(param_1[1], &lpSize);\n            (*_sym.imp.GDI32.dll_GetViewportExtEx)(param_1[1], &var_70h);\n            pcVar2 = _sym.imp.KERNEL32.dll_MulDiv;\n            if (var_64h < 0) {\n                var_64h = -var_64h;\n            }\n            if (var_6ch < 0) {\n                var_6ch = -var_6ch;\n            }\n            var_7ch = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar4, var_6ch, var_64h);\n            iVar3 = (*pcVar2)(var_78h, var_6ch, var_64h);\n            iVar4 = var_74h;\n            if (var_7ch < iVar3) {\n                lpFaceName._0_2_ = 0;\n                var_45h = ((var_45h & 0xf0) != 0x50) - 1U & 0x50;\n                iVar4 = (*pcVar1)(&lpvObject);\n                (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], iVar4);\n                (*_sym.imp.GDI32.dll_DeleteObject)(var_74h);\n            }\n            fcn.004215e9(param_1 + 10);\n            param_1[10] = iVar4;\n        }\n    }\n    fcn.0042e09f(var_b8h);\n    return;\n}\n",
        "token_count": 1047
    },
    "0042a690": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a690(int32_t param_1)\n\n{\n    uint X;\n    uint var_ch;\n    int32_t lpPoint;\n    int32_t Y;\n    \n    if ((*(param_1 + 8) != 0) && (*(param_1 + 4) != 0)) {\n        (*_sym.imp.GDI32.dll_GetViewportOrgEx)(*(param_1 + 8), &lpPoint);\n        fcn.0042a345(&lpPoint);\n        Y = Y + *(param_1 + 0x24);\n        lpPoint = lpPoint + *(param_1 + 0x20);\n        (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), lpPoint, Y, 0);\n        (*_sym.imp.GDI32.dll_GetWindowOrgEx)(*(param_1 + 8), &X);\n        (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), X, var_ch, 0);\n    }\n    return;\n}\n",
        "token_count": 232
    },
    "0042a768": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a768(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    \n    if (arg_8h != 0) {\n        piVar1 = in_ECX + 0x38;\n        (*_sym.imp.GDI32.dll_GetViewportExtEx)(*(in_ECX + 8), piVar1);\n        piVar2 = in_ECX + 0x30;\n        (*_sym.imp.GDI32.dll_GetWindowExtEx)(*(in_ECX + 8), piVar2);\n        iVar6 = *piVar2;\n        while ((((-0x4000 < iVar6 && (*piVar2 < 0x4000)) && (iVar3 = *piVar1,  -0x4000 < iVar3)) && (iVar3 < 0x4000))) {\n            iVar6 = *piVar2 * 2;\n            *piVar2 = iVar6;\n            *piVar1 = iVar3 * 2;\n        }\n        iVar6 = *(in_ECX + 0x34);\n        pcVar4 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        while (((_sym.imp.GDI32.dll_GetDeviceCaps = pcVar4,  -0x4000 < iVar6 && (*(in_ECX + 0x34) < 0x4000)) &&\n               ((iVar3 = *(in_ECX + 0x3c),  -0x4000 < iVar3 && (iVar3 < 0x4000))))) {\n            iVar6 = *(in_ECX + 0x34) * 2;\n            *(in_ECX + 0x34) = iVar6;\n            *(in_ECX + 0x3c) = iVar3 * 2;\n            pcVar4 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        }\n        uVar5 = (*pcVar4)(*(in_ECX + 8), 0x58);\n        iVar6 = fcn.00429939(*piVar1, *(in_ECX + 0x10), *0x45f788, *(in_ECX + 0x14), uVar5);\n        *piVar1 = iVar6;\n        uVar5 = (*pcVar4)(*(in_ECX + 8), 0x5a);\n        uVar5 = fcn.00429939(*(in_ECX + 0x3c), *(in_ECX + 0x10), *0x45f78c, *(in_ECX + 0x14), uVar5);\n        *(in_ECX + 0x3c) = uVar5;\n    }\n    if (*(in_ECX + 4) != 0) {\n        (*_sym.imp.GDI32.dll_SetMapMode)(*(in_ECX + 4), 8);\n        (*_sym.imp.GDI32.dll_SetWindowExtEx)(*(in_ECX + 4), *(in_ECX + 0x30), *(in_ECX + 0x34), 0);\n        (*_sym.imp.GDI32.dll_SetViewportExtEx)(*(in_ECX + 4), *(in_ECX + 0x38), *(in_ECX + 0x3c), 0);\n        fcn.0042a690();\n    }\n    return;\n}\n",
        "token_count": 769
    },
    "0042a96a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a96a(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    *(in_ECX + 0x10) = arg_8h;\n    *(in_ECX + 0x14) = arg_ch;\n    if (*(in_ECX + 8) != 0) {\n        fcn.0042a768(1);\n        fcn.00429ea5();\n    }\n    return;\n}\n",
        "token_count": 105
    },
    "0042b121": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b121(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x14) == 0) {\n        uVar1 = fcn.0040d0a9(0x44ce98);\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x14) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x14);\n    return;\n}\n",
        "token_count": 131
    },
    "0042b1c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0042b1c5(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 189
    },
    "0042b1fb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b1fb(uint *arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x1c) == 0) {\n        uVar1 = fcn.0040d0a9(\"GetSaveFileNameW\");\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        *(in_ECX + 0x1c) = uVar1;\n    }\n    *arg_8h = *(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 134
    },
    "0042b29f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.0042b29f(void)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    bool bVar2;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x24) != 2) {\n        bVar2 = *(unaff_EBP + -0x1c) != 0;\n        if (bVar2) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        fcn.00420b29(0, *(unaff_EBP + -0x20));\n        if (!bVar2) {\n            (*_sym.imp.KERNEL32.dll_SetLastError)(uVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 188
    },
    "0042b30d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid fcn.0042b30d(void)\n\n{\n    code *arg_8h;\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFileDialog.0;\n    arg_8h = extraout_ECX[0x1d];\n    *(unaff_EBP + -4) = 1;\n    fcn.0042e518(arg_8h);\n    if (extraout_ECX[0x1e] == 0x1) {\n        iVar1 = (**(*extraout_ECX[0x20] + 0x20))(extraout_ECX[0x20], extraout_ECX[0x1f]);\n        if (-1 < iVar1) goto code_r0x0042b35b;\n        do {\n            fcn.00407ad1();\ncode_r0x0042b35b:\n            (**(*extraout_ECX[0x21] + 8))(extraout_ECX[0x21]);\n            iVar1 = (**(*extraout_ECX[0x20] + 8))(extraout_ECX[0x20]);\n        } while (iVar1 != 0);\n        (*_sym.imp.ole32.dll_CoUninitialize)();\n    }\n    fcn.00401020();\n    *(unaff_EBP + -4) = 0xffffffff;\n    *extraout_ECX = vtable.CCommonDialog.0;\n    fcn.0041aecf();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 419
    },
    "0042b3cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0042b3cc(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code **arg_8h_00;\n    uint32_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    ushort *puVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_138h;\n    uint var_134h;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint lpVersionInformation;\n    uint var_120h;\n    uint uVar5;\n    uint var_4h;\n    \n    fcn.00430f04(300);\n    *(unaff_EBP + -0x130) = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -300) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x138) = extraout_ECX;\n    fcn.004250a4(*(unaff_EBP + 0x1c));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CFileDialog.0;\n    fcn.00401890();\n    extraout_ECX[199] = NULL;\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[200] = NULL;\n    if (*(unaff_EBP + 0x20) == 0) {\n        fcn.00430820(unaff_EBP + -0x124, 0, 0x114);\n        *(unaff_EBP + -0x124) = 0x114;\n        (*_sym.imp.KERNEL32.dll_GetVersionExW)(unaff_EBP + -0x124);\n        *(unaff_EBP + 0x20) = 0x58;\n        extraout_ECX[0x1e] = ~-(*(unaff_EBP + -0x120) < 6) & *(unaff_EBP + 0x24);\n    }\n    pcVar2 = fcn.0042eec5(*(unaff_EBP + 0x20));\n    extraout_ECX[0x1d] = pcVar2;\n    if (pcVar2 == NULL) {\n        pcVar2 = fcn.00407a99();\n    }\n    fcn.00430820(pcVar2, 0, *(unaff_EBP + 0x20));\n    uVar5 = *(unaff_EBP + 0x20);\n    *(extraout_ECX + 0x24) = 0;\n    arg_8h_00 = extraout_ECX + 0x44;\n    *arg_8h_00 = 0;\n    pcVar2 = *(unaff_EBP + 8);\n    extraout_ECX[0x22] = pcVar2;\n    extraout_ECX[0x15] = 0x7005 - (pcVar2 != NULL);\n    extraout_ECX[0xc6] = NULL;\n    *extraout_ECX[0x1d] = uVar5;\n    uVar5 = *(unaff_EBP + 0xc);\n    *(extraout_ECX[0x1d] + 0x1c) = arg_8h_00;\n    *(extraout_ECX[0x1d] + 0x20) = 0x104;\n    *(extraout_ECX[0x1d] + 0x3c) = uVar5;\n    uVar1 = *(unaff_EBP + 0x14);\n    *(extraout_ECX[0x1d] + 0x24) = extraout_ECX + 0x24;\n    *(extraout_ECX[0x1d] + 0x28) = 0x40;\n    *(extraout_ECX[0x1d] + 0x34) = *(extraout_ECX[0x1d] + 0x34) | uVar1 | 0x80020;\n    if ((*(unaff_EBP + 0x14) & 0x40) != 0) {\n        *(extraout_ECX[0x1d] + 0x34) = *(extraout_ECX[0x1d] + 0x34) & 0xff7fffff;\n    }\n    iVar3 = fcn.004213cc();\n    *(extraout_ECX[0x1d] + 8) = *(iVar3 + 0xc);\n    *(extraout_ECX[0x1d] + 0x44) = fcn.00425430;\n    if (*(unaff_EBP + -0x130) != 0) {\n        fcn.00407b1c(arg_8h_00, 0x104, *(unaff_EBP + -0x130), 0xffffffff);\n    }\n    if (*(unaff_EBP + -300) != 0) {\n        fcn.004027e0(*(unaff_EBP + -300));\n        puVar4 = fcn.004019b0(0);\n        while( true ) {\n            puVar4 = fcn.0043151a(puVar4, 0x7c);\n            if (puVar4 == NULL) break;\n            *puVar4 = 0;\n            puVar4 = puVar4 + 1;\n        }\n        *(extraout_ECX[0x1d] + 0xc) = extraout_ECX[0x23];\n    }\n    if (extraout_ECX[0x1e] == 0x1) {\n        iVar3 = (*_sym.imp.ole32.dll_CoInitializeEx)(0, 2);\n        if (-1 < iVar3) {\n            extraout_ECX[199] = vtable.CFileDialog::XFileDialogEvents.0;\n            extraout_ECX[200] = vtable.CFileDialog::XFileDialogControlEvents.0;\n            if (extraout_ECX[0x22] == NULL) {\n                uVar5 = 0x45bfec;\n            }\n            else {\n                uVar5 = 0x45bfdc;\n            }\n            iVar3 = (*_sym.imp.ole32.dll_CoCreateInstance)(uVar5, 0, 1, 0x44d094, unaff_EBP + -0x128);\n            if (-1 < iVar3) {\n                iVar3 = (****(unaff_EBP + -0x128))(*(unaff_EBP + -0x128), 0x44ce88, unaff_EBP + -0x134);\n                if (-1 < iVar3) goto code_r0x0042b604;\n                do {\n                    fcn.00407ad1();\ncode_r0x0042b604:\n                    iVar3 = (**(**(unaff_EBP + -0x128) + 0x1c))\n                                      (*(unaff_EBP + -0x128), extraout_ECX + 199, extraout_ECX + 0x1f);\n                } while (iVar3 < 0);\n                extraout_ECX[0x20] = *(unaff_EBP + -0x128);\n                extraout_ECX[0x21] = *(unaff_EBP + -0x134);\n                goto code_r0x0042b636;\n            }\n        }\n        extraout_ECX[0x1e] = NULL;\n    }\ncode_r0x0042b636:\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 1714
    },
    "0042bc2a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0042bc2a(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint var_ch;\n    uint hWnd;\n    uint var_4h;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenW)(*(*(param_1 + 0x74) + 0x1c));\n    fcn.00430820(*(*(param_1 + 0x74) + 0x1c) + (iVar3 + 1) * 2, 0, (*(*(param_1 + 0x74) + 0x20) - (iVar3 + 1)) * 2);\n    uVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n    iVar3 = *(param_1 + 0x74);\n    bVar1 = false;\n    uVar5 = fcn.0041b183();\n    *(iVar3 + 4) = uVar5;\n    fcn.0040d516();\n    pcVar2 = _sym.imp.USER32.dll_EnableWindow;\n    if ((*(*(param_1 + 0x74) + 4) != 0) &&\n       (iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(*(param_1 + 0x74) + 4)),  iVar3 != 0)) {\n        bVar1 = true;\n        (*pcVar2)(*(*(param_1 + 0x74) + 4), 0);\n    }\n    iVar3 = fcn.00420e14();\n    if ((*(param_1 + 0x78) == 1) || ((*(*(param_1 + 0x74) + 0x34) & 0x80000) == 0)) {\n        fcn.0040f4b1(param_1);\n    }\n    else {\n        *(iVar3 + 0x18) = param_1;\n    }\n    if (*(param_1 + 0x78) == 1) {\n        fcn.0042b640();\n        iVar6 = (**(**(param_1 + 0x80) + 0xc))(*(param_1 + 0x80), *(*(param_1 + 0x74) + 4));\n        iVar6 = (iVar6 != 0) + 1;\n    }\n    else if (*(param_1 + 0x88) == 0) {\n        iVar6 = fcn.0042b2f1(*(param_1 + 0x74));\n    }\n    else {\n        iVar6 = fcn.0042b2d5(*(param_1 + 0x74));\n    }\n    *(iVar3 + 0x18) = 0;\n    if (bVar1) {\n        (*pcVar2)(*(*(param_1 + 0x74) + 4), 1);\n    }\n    iVar3 = (*_sym.imp.USER32.dll_IsWindow)(uVar4);\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetFocus)(uVar4);\n    }\n    fcn.0041b1bf();\n    if (iVar6 == 0) {\n        iVar6 = 2;\n    }\n    return iVar6;\n}\n",
        "token_count": 739
    },
    "0042bd59": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: pv\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0042bd59(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint lParam;\n    uint pv;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x10);\n    *(unaff_EBP + -0x1c) = 0;\n    if (*(extraout_ECX + 0x78) == 1) {\n        if (*(extraout_ECX + 0x20) != 0) {\n            fcn.00401890();\n            piVar1 = *(extraout_ECX + 0x80);\n            iVar3 = *piVar1;\n            *(unaff_EBP + -4) = 0;\n            iVar3 = (**(iVar3 + 0x38))(piVar1, unaff_EBP + -0x10);\n            if (-1 < iVar3) {\n                iVar3 = (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), 0x400000, unaff_EBP + -0x1c);\n                if (iVar3 == 1) {\n                    iVar3 = (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), 0x20000000, unaff_EBP + -0x1c);\n                    if (iVar3 != 0) goto code_r0x0042bdcc;\n                }\n                else {\ncode_r0x0042bdcc:\n                    *(unaff_EBP + -0x18) = 0;\n                    iVar3 = (**(**(unaff_EBP + -0x10) + 0x14))(*(unaff_EBP + -0x10), 0x80058000, unaff_EBP + -0x18);\n                    if (-1 < iVar3) {\n                        fcn.004029f0(*(unaff_EBP + -0x18));\n                        fcn.0040d34f(0xffffffff);\n                        (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x18));\n                    }\n                }\n                (**(**(unaff_EBP + -0x10) + 8))(*(unaff_EBP + -0x10));\n            }\n            fcn.004052f0(unaff_EBP + -0x14);\ncode_r0x0042be1b:\n            fcn.00401020();\n            goto code_r0x0042bef0;\n        }\n    }\n    else {\n        if (((*(*(extraout_ECX + 0x74) + 0x34) & 0x80000) == 0) || (*(extraout_ECX + 0x20) == 0)) goto code_r0x0042bee2;\n        fcn.00401890();\n        *(unaff_EBP + -4) = 1;\n        uVar4 = fcn.004019b0(0x104);\n        pcVar2 = _sym.imp.USER32.dll_GetParent;\n        uVar5 = *(extraout_ECX + 0x20);\n        *(unaff_EBP + -0x1c) = uVar4;\n        uVar5 = (*pcVar2)(uVar5);\n        iVar3 = fcn.0040d45d(uVar5);\n        iVar3 = (*_sym.imp.USER32.dll_SendMessageW)(*(iVar3 + 0x20), 0x464, 0x104, *(unaff_EBP + -0x1c));\n        if (iVar3 < 0) {\n            fcn.00401a10();\n        }\n        else {\n            fcn.0040d34f(0xffffffff);\n        }\n        if (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n            uVar4 = fcn.004019b0(0x104);\n            uVar5 = *(extraout_ECX + 0x20);\n            *(unaff_EBP + -0x1c) = uVar4;\n            uVar5 = (*pcVar2)(uVar5);\n            iVar3 = fcn.0040d45d(uVar5);\n            iVar3 = (*_sym.imp.USER32.dll_SendMessageW)(*(iVar3 + 0x20), 0x465, 0x104, *(unaff_EBP + -0x1c));\n            if (-1 < iVar3) {\n                fcn.0040d34f(0xffffffff);\n                fcn.004052f0(unaff_EBP + -0x10);\n                goto code_r0x0042be1b;\n            }\n            fcn.00401a10();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00401020();\n    }\ncode_r0x0042bee2:\n    fcn.00402680(*(*(extraout_ECX + 0x74) + 0x1c));\ncode_r0x0042bef0:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1253
    },
    "0042c009": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: lParam\n// WARNING: Variable defined which should be unmapped: pszPath\n\nvoid __cdecl fcn.0042c009(uint arg_8h)\n\n{\n    uint uVar1;\n    int16_t *piVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint lParam;\n    uint pszPath;\n    int32_t var_4h;\n    \n    fcn.00430e9b(8);\n    *(unaff_EBP + -0x14) = 0;\n    if (*(extraout_ECX + 0x78) == 1) {\n        fcn.00401890();\n        *(unaff_EBP + -4) = 0;\n        if (*(extraout_ECX + 0x20) == 0) {\n            uVar1 = fcn.0042bd59(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 2;\n        }\n        else {\n            uVar1 = fcn.0042bf16(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 1;\n        }\n        fcn.00401930(uVar1);\n        *(unaff_EBP + -4) = 0;\n        fcn.00401020();\n        fcn.0040d34f(0xffffffff);\ncode_r0x0042c071:\n        piVar2 = (*_sym.imp.SHLWAPI.dll_PathFindExtensionW)(*(unaff_EBP + -0x10));\n        if ((piVar2 == NULL) || (*piVar2 != 0x2e)) {\ncode_r0x0042c09e:\n            fcn.00401a10();\n            fcn.004052f0(unaff_EBP + -0x10);\n        }\n        else {\n            fcn.00402680(piVar2 + 1);\n        }\n        fcn.00401020();\n        goto code_r0x0042c157;\n    }\n    iVar4 = *(extraout_ECX + 0x74);\n    if (((*(iVar4 + 0x34) & 0x80000) != 0) && (*(extraout_ECX + 0x20) != 0)) {\n        fcn.00401890();\n        *(unaff_EBP + -4) = 3;\n        uVar3 = fcn.004019b0(0x104);\n        uVar1 = *(extraout_ECX + 0x20);\n        *(unaff_EBP + -0x14) = uVar3;\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(uVar1);\n        iVar4 = fcn.0040d45d(uVar1);\n        iVar4 = (*_sym.imp.USER32.dll_SendMessageW)(*(iVar4 + 0x20), 0x464, 0x104, *(unaff_EBP + -0x14));\n        fcn.0040d34f(0xffffffff);\n        if (-1 < iVar4) goto code_r0x0042c071;\n        goto code_r0x0042c09e;\n    }\n    iVar5 = *(extraout_ECX + 0x318);\n    if (iVar5 == 0) {\n        iVar5 = iVar4;\n        if (*(iVar4 + 0x3a) == 0) goto code_r0x0042c131;\ncode_r0x0042c144:\n        var_4h = *(iVar5 + 0x1c) + *(iVar5 + 0x3a) * 2;\n    }\n    else {\n        if (*(iVar5 + 0x3a) != 0) goto code_r0x0042c144;\ncode_r0x0042c131:\n        var_4h = 0x44fa4c;\n    }\n    fcn.00402680(var_4h);\ncode_r0x0042c157:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 924
    },
    "0042c837": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c837(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t *in_ECX;\n    \n    if (arg_8h < 4) {\n        arg_8h = 4;\n    }\n    if (arg_ch < 2) {\n        arg_ch = 0x40;\n    }\n    in_ECX[3] = 0;\n    in_ECX[2] = 0;\n    *in_ECX = arg_8h;\n    in_ECX[1] = arg_ch;\n    return;\n}\n",
        "token_count": 128
    },
    "0042c881": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042c881(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1[3] == 0) {\n        iVar1 = fcn.00424332(param_1 + 2, param_1[1], *param_1);\n        iVar3 = param_1[1] + -1;\n        piVar2 = iVar1 + 4 + *param_1 * iVar3;\n        for (; -1 < iVar3; iVar3 = iVar3 + -1) {\n            *piVar2 = param_1[3];\n            param_1[3] = piVar2;\n            piVar2 = piVar2 - *param_1;\n        }\n    }\n    param_1[3] = *param_1[3];\n    return;\n}\n",
        "token_count": 199
    },
    "0042d7f9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.0042d7f9(uint arg_8h)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t *extraout_ECX;\n    uint32_t uVar7;\n    int32_t unaff_EBP;\n    int32_t *piVar8;\n    uint *puVar9;\n    uint *puVar10;\n    uint lParam;\n    uint var_84h;\n    uint var_58h;\n    uint var_54h;\n    uint var_38h;\n    uint var_34h;\n    uint lpPoint;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uint uVar11;\n    \n    uVar11 = 0x7c;\n    fcn.00430e9b();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    puVar9 = *(unaff_EBP + 8);\n    uVar7 = puVar9[1];\n    *(unaff_EBP + -0x1c) = uVar7;\n    pcVar2 = _sym.imp.USER32.dll_GetKeyState;\n    if ((((uVar7 == 0x200) || (uVar7 == 0xa0)) || (uVar7 == 0x202)) || ((uVar7 == 0x205 || (uVar7 == 0x208)))) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if ((-1 < iVar3) && ((iVar3 = (*pcVar2)(2),  -1 < iVar3 && (iVar3 = (*pcVar2)(4),  -1 < iVar3)))) {\n            iVar4 = fcn.004213ff();\n            uVar11 = *puVar9;\n            *(unaff_EBP + -0x18) = iVar4;\n            while ((piVar5 = fcn.0040d45d(uVar11),  piVar5 != NULL && ((piVar5[0xf] & 0x401U) == 0))) {\n                uVar11 = (*_sym.imp.USER32.dll_GetParent)(piVar5[8]);\n            }\n            if (piVar5 != extraout_ECX) {\n                if (piVar5 == NULL) {\n                    *(iVar4 + 0x40) = 0;\n                    *(iVar4 + 0x44) = 0xffffffff;\n                }\n                goto code_r0x0042dc0c;\n            }\n            piVar5 = *(iVar4 + 0x3c);\n            uVar11 = fcn.0040d763();\n            *(unaff_EBP + -0x14) = uVar11;\n            if (piVar5 == NULL) {\ncode_r0x0042d8e4:\n                iVar6 = fcn.0040641b(0x70);\n                *(unaff_EBP + -0x1c) = iVar6;\n                piVar5 = NULL;\n                *(unaff_EBP + -4) = 0;\n                if (iVar6 != 0) {\n                    piVar5 = fcn.0042d510();\n                }\n                iVar6 = *piVar5;\n                *(unaff_EBP + -4) = 0xffffffff;\n                iVar6 = (**(iVar6 + 0x13c))(*(unaff_EBP + -0x14), 1);\n                if (iVar6 == 0) {\n                    (**(*piVar5 + 4))(1);\n                    goto code_r0x0042dc0c;\n                }\n                (*_sym.imp.USER32.dll_SendMessageW)(piVar5[8], 0x401, 0, 0);\n                piVar8 = *(unaff_EBP + -0x10);\n                *(iVar4 + 0x3c) = piVar5;\n            }\n            else {\n                iVar6 = fcn.0040877c();\n                if (iVar6 != *(unaff_EBP + -0x14)) {\n                    (**(*piVar5 + 0x60))();\n                    (**(*piVar5 + 4))(1);\n                    piVar5 = NULL;\n                    *(iVar4 + 0x3c) = 0;\n                }\n                piVar8 = extraout_ECX;\n                if (piVar5 == NULL) goto code_r0x0042d8e4;\n            }\n            fcn.00430820(unaff_EBP + -0x88, 0, 0x30);\n            uVar11 = *(*(unaff_EBP + 8) + 0x14);\n            *(unaff_EBP + -0x24) = *(*(unaff_EBP + 8) + 0x18);\n            iVar6 = piVar8[8];\n            *(unaff_EBP + -0x28) = uVar11;\n            (*_sym.imp.USER32.dll_ScreenToClient)(iVar6, unaff_EBP + -0x28);\n            fcn.00430820(unaff_EBP + -0x58, 0, 0x30);\n            iVar6 = *piVar8;\n            *(unaff_EBP + -0x58) = 0x2c;\n            iVar6 = (**(iVar6 + 0x74))(*(unaff_EBP + -0x28), *(unaff_EBP + -0x24), unaff_EBP + -0x58);\n            uVar7 = -(iVar6 != -1) & piVar8;\n            *(unaff_EBP + -0x1c) = iVar6;\n            *(unaff_EBP + -0x14) = uVar7;\n            if ((*(iVar4 + 0x44) == iVar6) && (*(iVar4 + 0x40) == uVar7)) {\n                if ((piVar8[0xf] & 0x400U) == 0) {\n                    if (iVar6 != -1) {\n                        fcn.0042d779(piVar5, *(unaff_EBP + 8));\n                    }\n                }\n                else {\n                    (*_sym.imp.USER32.dll_GetCursorPos)(unaff_EBP + -0x20);\n                    (*_sym.imp.USER32.dll_SendMessageW)\n                              (piVar5[8], 0x412, 0, CONCAT22(*(unaff_EBP + -0x1c), *(unaff_EBP + -0x20)));\n                }\n            }\n            else {\n                if (iVar6 == -1) {\n                    (*_sym.imp.USER32.dll_SendMessageW)(piVar5[8], 0x401, 0, 0);\n                }\n                else {\n                    uVar7 = *(unaff_EBP + -0x54);\n                    puVar9 = unaff_EBP + -0x58;\n                    puVar10 = unaff_EBP + -0x88;\n                    for (iVar4 = 0xc; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar10 = *puVar9;\n                        puVar9 = puVar9 + 1;\n                        puVar10 = puVar10 + 1;\n                    }\n                    uVar7 = uVar7 & 0x3fffffff;\n                    *(unaff_EBP + -0x84) = uVar7;\n                    if ((*(*(unaff_EBP + -0x10) + 0x3c) & 0x400) != 0) {\n                        *(unaff_EBP + -0x84) = uVar7 | 0x20;\n                    }\n                    (*_sym.imp.USER32.dll_SendMessageW)(piVar5[8], 0x432, 0, unaff_EBP + -0x88);\n                    if (((*(unaff_EBP + -0x54) & 0x40000000) != 0) || (iVar4 = fcn.0040fd7c(),  iVar4 != 0)) {\n                        (*_sym.imp.USER32.dll_SendMessageW)(piVar5[8], 0x401, 1);\n                        if ((*(*(unaff_EBP + -0x10) + 0x3c) & 0x400) != 0) {\n                            (*_sym.imp.USER32.dll_SendMessageW)(piVar5[8], 0x411, 1, unaff_EBP + -0x88);\n                        }\n                        (*_sym.imp.USER32.dll_SetWindowPos)(piVar5[8], 0, 0, 0, 0, 0, 0x213);\n                    }\n                    iVar4 = *(unaff_EBP + -0x18);\n                }\n                fcn.0042d779(piVar5, *(unaff_EBP + 8));\n                puVar1 = *(iVar4 + 0x48);\n                if ((puVar1 != NULL) && (0x2b < *puVar1)) {\n                    (*_sym.imp.USER32.dll_SendMessageW)(piVar5[8], 0x433, 0, puVar1);\n                }\n                *(iVar4 + 0x40) = *(unaff_EBP + -0x14);\n                *(iVar4 + 0x44) = *(unaff_EBP + -0x1c);\n                if (*(iVar4 + 0x48) == 0) {\n                    uVar11 = fcn.0040641b(0x30);\n                    *(iVar4 + 0x48) = uVar11;\n                    fcn.00430820(uVar11, 0, 0x30);\n                }\n                puVar9 = unaff_EBP + -0x58;\n                puVar10 = *(iVar4 + 0x48);\n                for (iVar6 = 0xc; iVar6 != 0; iVar6 = iVar6 + -1) {\n                    *puVar10 = *puVar9;\n                    puVar9 = puVar9 + 1;\n                    puVar10 = puVar10 + 1;\n                }\n            }\n            if ((*(unaff_EBP + -0x34) != -1) && (*(unaff_EBP + -0x38) == 0)) {\n                fcn.0042e518(*(unaff_EBP + -0x34));\n            }\n            goto code_r0x0042dc0c;\n        }\n        uVar7 = *(unaff_EBP + -0x1c);\n    }\n    if ((extraout_ECX[0xf] & 0x401U) != 0) {\n        while (piVar5 = fcn.0040d45d(uVar11),  piVar5 != NULL) {\n            if (piVar5 == extraout_ECX) goto code_r0x0042db77;\n            if ((piVar5[0xf] & 0x401U) != 0) break;\n            uVar11 = (*_sym.imp.USER32.dll_GetParent)(piVar5[8]);\n        }\n        if (piVar5 == extraout_ECX) {\ncode_r0x0042db77:\n            if (((uVar7 < 0x100) || (0x109 < uVar7)) && (3 < uVar7 - 0x104)) {\n                iVar4 = 0;\n            }\n            else {\n                iVar4 = 1;\n            }\n            if (((extraout_ECX[0xf] & 0x400U) == 0) &&\n               (((((iVar4 != 0 || (uVar7 == 0x201)) || ((uVar7 == 0x203 || ((uVar7 == 0x204 || (uVar7 == 0x206)))))) ||\n                 (uVar7 == 0x207)) ||\n                (((((uVar7 == 0x209 || (uVar7 == 0xa1)) || (uVar7 == 0xa3)) || ((uVar7 == 0xa4 || (uVar7 == 0xa6)))) ||\n                 ((uVar7 == 0xa7 || (uVar7 == 0xa9)))))))) {\n                fcn.0040bdbf(iVar4);\n            }\n        }\n    }\ncode_r0x0042dc0c:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 2850
    },
    "0042dc2e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042dc2e(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    \n    iVar1 = fcn.004213ff();\n    iVar2 = *(iVar1 + 0x3c);\n    if (arg_8h == 0) {\n        if ((*(in_ECX + 0x3c) & arg_ch) != 0) {\n            if (*(iVar1 + 0x40) == in_ECX) {\n                fcn.0040bdbf(1);\n            }\n            if ((iVar2 != 0) && (*(iVar2 + 0x20) != 0)) {\n                fcn.00430820(&var_30h, 0, 0x30);\n                var_28h = *(in_ECX + 0x20);\n                var_30h = 0x2c;\n                var_2ch = 1;\n                var_24h = var_28h;\n                (*_sym.imp.USER32.dll_SendMessageW)(*(iVar2 + 0x20), 0x433, 0, &var_30h);\n            }\n            *(in_ECX + 0x3c) = *(in_ECX + 0x3c) & ~arg_ch;\n        }\n    }\n    else if ((*(in_ECX + 0x3c) & arg_ch) == 0) {\n        iVar2 = fcn.004213cc();\n        *(iVar2 + 0x38) = fcn.0042dc1a;\n        *(in_ECX + 0x3c) = *(in_ECX + 0x3c) | arg_ch;\n    }\n    return 1;\n}\n",
        "token_count": 422
    },
    "0042e09f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e09f(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x45c240) {\n        return;\n    }\n    *0x45ff48 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x45ff4c = &arg_8h;\n    *0x45fe88 = 0x10001;\n    *0x45fe30 = 0xc0000409;\n    *0x45fe34 = 1;\n    var_328h = *0x45c240;\n    var_324h = *0x45c244;\n    *0x45fe3c = unaff_retaddr;\n    *0x45ff14 = in_GS;\n    *0x45ff18 = in_FS;\n    *0x45ff1c = in_ES;\n    *0x45ff20 = in_DS;\n    *0x45ff24 = unaff_EDI;\n    *0x45ff28 = unaff_ESI;\n    *0x45ff2c = unaff_EBX;\n    *0x45ff30 = in_EDX;\n    *0x45ff34 = in_ECX;\n    *0x45ff38 = in_EAX;\n    *0x45ff3c = unaff_EBP;\n    *0x45ff40 = unaff_retaddr;\n    *0x45ff44 = in_CS;\n    *0x45ff50 = in_SS;\n    *0x45fe80 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.0043c861(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x44e338);\n    if (*0x45fe80 == 0) {\n        fcn.0043c861(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 832
    },
    "0042ee32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ee32(code **param_1)\n\n{\n    *param_1 = vtable.std::exception.0;\n    if (param_1[2] != NULL) {\n        fcn.0042e518(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "00430bab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00430bab(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x430c56;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.00430c82;\n        uStack36 = *0x45c240 ^ &fcn.00430bab::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.00430bab::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.00433057();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.00430bab::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 718
    },
    "00431068": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431068(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.00430fbf(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    return;\n}\n",
        "token_count": 124
    },
    "004318d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x004319c6: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x004319cb)\n// WARNING: Removing unreachable block (ram,0x004319f9)\n// WARNING: Removing unreachable block (ram,0x004319d1)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004318d3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t unaff_EBP;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00431080(0x457120, 0x18);\n    fcn.004358f4(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x45f8e4 != 1) {\n        *0x45f8e0 = 1;\n        *0x45f8dc = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar1 = fcn.00432e0b(*0x4616a8);\n            *(unaff_EBP + -0x28) = piVar1;\n            if (piVar1 != NULL) {\n                piVar2 = fcn.00432e0b(*0x4616a4);\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x1c) = piVar1;\n                *(unaff_EBP + -0x20) = piVar2;\n                while( true ) {\n                    piVar2 = piVar2 + -1;\n                    *(unaff_EBP + -0x24) = piVar2;\n                    if (piVar2 < piVar1) break;\n                    iVar3 = fcn.00432e02();\n                    if (*piVar2 != iVar3) {\n                        if (piVar2 < piVar1) break;\n                        pcVar4 = fcn.00432e0b(*piVar2);\n                        iVar3 = fcn.00432e02();\n                        *piVar2 = iVar3;\n                        (*pcVar4)();\n                        iVar3 = fcn.00432e0b(*0x4616a8);\n                        piVar1 = fcn.00432e0b(*0x4616a4);\n                        if ((*(unaff_EBP + -0x1c) != iVar3) || (*(unaff_EBP + -0x20) != piVar1)) {\n                            *(unaff_EBP + -0x1c) = iVar3;\n                            *(unaff_EBP + -0x28) = iVar3;\n                            *(unaff_EBP + -0x20) = piVar1;\n                            *(unaff_EBP + -0x24) = piVar1;\n                            piVar2 = piVar1;\n                        }\n                        piVar1 = *(unaff_EBP + -0x28);\n                    }\n                }\n            }\n            fcn.0043180d(0x44774c);\n        }\n        fcn.0043180d(0x447754);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0043581a(8);\n    }\n    return;\n}\n",
        "token_count": 808
    },
    "004322d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004322d3(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint arg_18h)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) == 0) {\n        fcn.00430fbf(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + 0x18));\n    }\n    return;\n}\n",
        "token_count": 138
    },
    "004394cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004394cf(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00433057();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.00433057();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 86
    },
    "00439797": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439797(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.00430de9(*(unaff_EBP + -0x28));\n    iVar1 = fcn.00433057();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.00433057();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.00430dc2(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0043952f(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 379
    },
    "0043b83f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043b83f(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.0043581a(0);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "0044060f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0044060f(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x00440b10;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = str.5_v_[0] + L'\\xffffffff';\n        iVar4 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        uVar9 = str.5_v_[0] & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x00440744;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x0044074b;\ncode_r0x00440744:\n                        do {\n                            var_4h = 1;\ncode_r0x0044074b:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x00440759;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x00440759:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x45d178 - str.5_v_[0]) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x45d178 < iVar12) {\n                if (iVar12 < *0x45d174) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + str.5_v_[3];\n                    iVar4 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = str.5_v_[3] + *0x45d174;\n                    uVar5 = 1;\n                }\n                goto code_r0x00440b10;\n            }\n            var_10h = *0x45d178 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = str.5_v_[0] + L'\\xffffffff';\n            iVar12 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar10 = str.5_v_[0] & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x004408fc;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x004408fc:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = str.5_v_[1] + L'\\x01';\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x00440b10:\n    var_20h = iVar12 << (0x1fU - str.5_v_[1] & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3658
    },
    "00440b53": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00440b53(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x00441054;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = *0x45d194 - 1;\n        iVar4 = *0x45d194 + (*0x45d194 >> 0x1f & 0x1fU) >> 5;\n        uVar9 = *0x45d194 & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x00440c88;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x00440c8f;\ncode_r0x00440c88:\n                        do {\n                            var_4h = 1;\ncode_r0x00440c8f:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x00440c9d;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x00440c9d:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x45d190 - *0x45d194) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x45d190 < iVar12) {\n                if (iVar12 < *0x45d18c) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + *0x45d1a0;\n                    iVar4 = *0x45d198 + (*0x45d198 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x45d198 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = *0x45d198 + (*0x45d198 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x45d198 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = *0x45d1a0 + *0x45d18c;\n                    uVar5 = 1;\n                }\n                goto code_r0x00441054;\n            }\n            var_10h = *0x45d190 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = *0x45d194 - 1;\n            iVar12 = *0x45d194 + (*0x45d194 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = *0x45d194 & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x00440e40;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x00440e40:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = *0x45d198 + 1;\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x00441054:\n    var_20h = iVar12 << (0x1fU - *0x45d198 & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (*0x45d19c == 0x40) {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (*0x45d19c == 0x20) {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3647
    },
    "004028e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004028e0(int32_t *param_1, uint param_2, uint32_t param_3)\n\n{\n    uint16_t uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint16_t *puVar4;\n    uint32_t uVar5;\n    uint16_t *puVar6;\n    uint uVar7;\n    uint32_t uVar8;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_FindResourceW)(param_2, (param_3 >> 4) + 1 & 0xffff, 6);\n    if ((iVar3 == 0) || (puVar4 = fcn.00401e10(param_2, iVar3, param_3),  puVar4 == NULL)) {\n        return 0;\n    }\n    uVar8 = *puVar4;\n    if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - uVar8) < 0) {\n        fcn.00401b30(uVar8);\n    }\n    uVar5 = *puVar4;\n    if (uVar5 == 0xffffffff) {\n        puVar6 = puVar4 + 1;\n        do {\n            uVar1 = *puVar6;\n            puVar6 = puVar6 + 1;\n        } while (uVar1 != 0);\n        uVar5 = (puVar6 - (puVar4 + 2) >> 1) + 1;\n    }\n    uVar7 = fcn.0042e44a(*param_1, uVar8 * 2, puVar4 + 1, uVar5 * 2);\n    fcn.00401d80(uVar7);\n    if (*(*param_1 + -8) < uVar8) {\n        fcn.00401000(0x80070057);\n        pcVar2 = swi(3);\n        uVar7 = (*pcVar2)();\n        return uVar7;\n    }\n    *(*param_1 + -0xc) = uVar8;\n    *(uVar8 * 2 + *param_1) = 0;\n    return 1;\n}\n",
        "token_count": 487
    },
    "00404810": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00404810(uint32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *unaff_EBX;\n    int32_t **ppiVar5;\n    uint32_t *in_FS_OFFSET;\n    uint32_t uStack32;\n    uint32_t uStack28;\n    uint32_t uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4463c0;\n    uStack12 = *in_FS_OFFSET;\n    uStack28 = *0x45c240 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &stack0xfffffff4;\n    if (param_1 == 0xffffffff) {\n        uStack32 = 0x404849;\n        piVar2 = fcn.00406b74();\n        if (piVar2 == NULL) {\n            uStack32 = 0x80004005;\n            piVar2 = fcn.00401000();\n        }\n        (**(*piVar2 + 0xc))();\n        uStack8 = 0;\n        iVar3 = fcn.00410c44(0x8a2);\n        if (iVar3 != 0) {\n            fcn.004028e0(iVar3, 0x8a2);\n        }\n        uVar1 = uStack32;\n        ppiVar5 = uStack32 - 0x10;\n        iVar3 = fcn.00401b80(ppiVar5);\n        *unaff_EBX = iVar3 + 0x10;\n        piVar2 = uVar1 - 4;\n        LOCK();\n        iVar3 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**ppiVar5 + 4))(ppiVar5);\n            *in_FS_OFFSET = uStack32;\n            return;\n        }\n    }\n    else {\n        uStack32 = 0x4048fc;\n        piVar2 = fcn.00406b74();\n        if (piVar2 == NULL) {\n            uStack32 = 0x80004005;\n            piVar2 = fcn.00401000();\n        }\n        iVar3 = (**(*piVar2 + 0xc))();\n        uStack32 = iVar3 + 0x10;\n        fcn.00401ce0(&stack0xffffffe0, 0x451654, param_1 / 100, param_1 % 100);\n        iVar3 = uStack32;\n        ppiVar5 = uStack32 + -0x10;\n        iVar4 = fcn.00401b80(ppiVar5);\n        *unaff_EBX = iVar4 + 0x10;\n        piVar2 = iVar3 + -4;\n        LOCK();\n        iVar3 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**ppiVar5 + 4))(ppiVar5);\n        }\n    }\n    *in_FS_OFFSET = uStack28;\n    return;\n}\n",
        "token_count": 729
    },
    "00406c00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406c00(uint *arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    if (arg_ch * arg_10h >> 0x20 != 0) {\n        return 0x80070057;\n    }\n    *arg_8h = arg_ch * arg_10h;\n    return 0;\n}\n",
        "token_count": 85
    },
    "00407075": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00407075(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    \n    iVar1 = fcn.0040d3b7();\n    if (iVar1 != -1) {\n        if ((*arg_8h != 0) && (*(*arg_8h + 4) != 0)) {\n            fcn.00410d75(in_ECX);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 116
    },
    "0040797a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0040797a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    fcn.00401890();\n    *(unaff_EBP + -4) = 0;\n    fcn.00402820(*(unaff_EBP + 8));\n    arg_10h_00 = *(unaff_EBP + 0x10);\n    if (arg_10h_00 == -1) {\n        arg_10h_00 = *(unaff_EBP + 8);\n    }\n    fcn.0040792c(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), arg_10h_00);\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 254
    },
    "004085e7": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004085e7(uint noname_0, uint nNumber)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.00407d98(&var_8h, &var_4h);\n    if ((var_4h == NULL) && (var_8h == NULL)) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00407bd1();\n        iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar1, 0x78);\n        if (var_4h == NULL) {\n            if (var_8h == NULL) {\n                return 0;\n            }\n            if (iVar1 == -1) {\n                iVar1 = in_ECX[0x1c];\n                if (0 < nNumber) {\n                    iVar1 = -in_ECX[0x1c];\n                }\n            }\n            else {\n                iVar1 = in_ECX[0x1e] * iVar2;\n                if (in_ECX[0x1c] <= in_ECX[0x1e] * iVar2) {\n                    iVar1 = in_ECX[0x1c];\n                }\n            }\n            iVar3 = 0;\n        }\n        else {\n            if (iVar1 == -1) {\n                iVar3 = in_ECX[0x1d];\n                if (0 < nNumber) {\n                    iVar3 = -in_ECX[0x1d];\n                }\n            }\n            else {\n                iVar3 = in_ECX[0x1f] * iVar2;\n                if (in_ECX[0x1d] <= in_ECX[0x1f] * iVar2) {\n                    iVar3 = in_ECX[0x1d];\n                }\n            }\n            iVar1 = 0;\n        }\n        iVar1 = (**(*in_ECX + 0x144))(iVar1, iVar3, 1);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(in_ECX[8]);\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 526
    },
    "00408c21": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00408c21(int32_t param_1)\n\n{\n    fcn.0040d3b7();\n    if (*(param_1 + 0x5c) == -1) {\n        fcn.00408a6f(*(param_1 + 0x60), *(param_1 + 100));\n    }\n    else {\n        fcn.004083e5();\n    }\n    return;\n}\n",
        "token_count": 95
    },
    "0040d34f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d34f(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    if (arg_8h == -1) {\n        arg_8h = fcn.0040bc8c(*in_ECX, *(*in_ECX + -8));\n    }\n    fcn.004019e0(arg_8h);\n    return;\n}\n",
        "token_count": 89
    },
    "004103cb": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004103cb(int16_t *arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int16_t *piVar4;\n    uint *puVar5;\n    uint var_30h;\n    uint var_2ch;\n    int16_t *var_28h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 1;\n    piVar4 = arg_8h;\n    var_8h = in_ECX;\n    if (arg_8h != NULL) {\n        do {\n            iVar1 = *piVar4;\n            if (iVar1 == 0) break;\n            iVar2 = piVar4[1];\n            var_ch = *(piVar4 + 2);\n            piVar4 = piVar4 + 4;\n            if (iVar2 == 0x1234) {\ncode_r0x00410442:\n                puVar5 = &var_2ch;\n                for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                var_2ch = 0xffffffff;\n                var_30h = 1;\n                fcn.00402680(piVar4);\n                var_28h = arg_8h;\n                iVar3 = (*_sym.imp.USER32.dll_SendDlgItemMessageW)(*(var_8h + 0x20), iVar1, 0x40b, 0, &var_30h);\n                if (iVar3 == -1) {\n                    var_4h = 0;\n                }\n                fcn.00401020();\n            }\n            else if (iVar2 == 0x401) {\n                iVar2 = 0x180;\ncode_r0x004104ab:\n                iVar3 = (*_sym.imp.USER32.dll_SendDlgItemMessageA)(*(var_8h + 0x20), iVar1, iVar2, 0, piVar4);\n                if (iVar3 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                if (iVar2 == 0x403) {\n                    iVar2 = 0x143;\n                }\n                if (iVar2 == 0x40b) goto code_r0x00410442;\n                if ((iVar2 == 0x180) || (iVar2 == 0x143)) goto code_r0x004104ab;\n            }\n            piVar4 = piVar4 + var_ch;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.0040dfeb(*(var_8h + 0x20), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 672
    },
    "00419719": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.00419719(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_41ch;\n    uint var_4h;\n    \n    fcn.00430f3a(0x414);\n    *(unaff_EBP + -0x41c) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    pcVar1 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    if ((pcVar1 != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.00419523();\n    }\n    fcn.00401020();\n    fcn.00430f96();\n    return;\n}\n",
        "token_count": 192
    },
    "004144c6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004144c6(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.0040d3b7();\n    if ((iVar1 != -1) && (iVar1 = (**(*in_ECX + 0x174))(arg_8h, arg_ch),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_PostMessageW)(in_ECX[8], 0x362, 0xe001, 0);\n        (**(*in_ECX + 0x150))(1);\n        return 0;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 153
    },
    "0041572e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041572e(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == -1) {\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x20));\n        if (iVar1 == 0) {\n            arg_8h = 1;\n        }\n        else {\n            iVar1 = (*_sym.imp.USER32.dll_IsIconic)(*(in_ECX + 0x20));\n            if (iVar1 != 0) {\n                arg_8h = 9;\n            }\n        }\n    }\n    fcn.00413e42(arg_8h);\n    if (arg_8h != -1) {\n        fcn.00410ab2(arg_8h);\n        fcn.00413e42(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 204
    },
    "00419523": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00419523(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    bool bVar2;\n    uint arg_ch;\n    \n    bVar2 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar2 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.00401a10();\n    if (bVar2) {\n        arg_ch = *(param_1 + 0xc);\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.004241fb(arg_8h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 197
    },
    "00419568": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00419568(int32_t param_1)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    \n    if (*(param_1 + 4) != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        *(param_1 + 4) = 0xffffffff;\n    }\n    piVar3 = param_1 + 0xc;\n    iVar5 = *piVar3;\n    ppiVar1 = iVar5 + -0x10;\n    piVar4 = *ppiVar1;\n    if (*(iVar5 + -0xc) != 0) {\n        piVar2 = iVar5 + -4;\n        if (*(iVar5 + -4) < 0) {\n            if (*(iVar5 + -8) < 0) {\n                fcn.00401000(0x80070057);\n                iVar5 = extraout_ECX;\n            }\n            *(iVar5 + -0xc) = 0;\n            **piVar3 = 0;\n            return;\n        }\n        LOCK();\n        iVar5 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar5 == 1 || iVar5 + -1 < 0) {\n            (**(**ppiVar1 + 4))(ppiVar1);\n        }\n        iVar5 = (**(*piVar4 + 0xc))();\n        *piVar3 = iVar5 + 0x10;\n    }\n    return;\n}\n",
        "token_count": 370
    },
    "00419fd5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00419fd5(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, uint32_t arg_18h, uint32_t arg_1ch, \n            uint arg_20h)\n\n{\n    uint *in_ECX;\n    int64_t iVar1;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    if (0x76b < arg_8h) goto code_r0x00419ff3;\n    do {\n        do {\n            fcn.00401000();\ncode_r0x00419ff3:\n        } while ((((0xb < arg_ch - 1U) || (0x1e < arg_10h - 1U)) || (0x17 < arg_14h)) ||\n                ((0x3b < arg_18h || (0x3b < arg_1ch))));\n        var_24h = arg_1ch;\n        var_10h = arg_8h + -0x76c;\n        var_4h = arg_20h;\n        var_14h = arg_ch + -1;\n        var_20h = arg_18h;\n        var_1ch = arg_14h;\n        var_18h = arg_10h;\n        iVar1 = fcn.00431dd0(&var_24h);\n        *in_ECX = iVar1;\n        in_ECX[1] = iVar1 >> 0x20;\n    } while (iVar1 == -1);\n    return;\n}\n",
        "token_count": 393
    },
    "0041cadf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.0041cadf(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_8h;\n    uint hDC;\n    \n    if (*0x45bc60 == -1) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n        var_8h = 0;\n        uVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x48, 0, 0, 0, 400, 0, 0, 0, 2, 0, 0, 0, 0, L\"Marlett\");\n        iVar4 = (*_sym.imp.GDI32.dll_CreateFontW)(uVar3);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        if (iVar4 != 0) {\n            var_8h = (*_sym.imp.GDI32.dll_SelectObject)(uVar2, iVar4);\n        }\n        (*_sym.imp.GDI32.dll_GetCharWidthW)(uVar2, 0x36, 0x36, 0x45bc60);\n        if (iVar4 != 0) {\n            (*pcVar1)(uVar2, var_8h);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar4);\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    return *0x45bc60;\n}\n",
        "token_count": 330
    },
    "0041ddc5": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0041ddc5(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar4 = *0x45bc5c;\n    if (*0x45bc5c == -1) {\n        fcn.004213cc();\n        uVar1 = fcn.0040d0a9();\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"DllGetVersion\");\n        iVar4 = 0x40000;\n        if (pcVar2 != NULL) {\n            fcn.00430820(&var_14h, 0, 0x14);\n            var_14h = 0x14;\n            iVar3 = (*pcVar2)(&var_14h);\n            if (-1 < iVar3) {\n                iVar4 = CONCAT22(var_10h, var_ch);\n            }\n        }\n    }\n    *0x45bc5c = iVar4;\n    return iVar4;\n}\n",
        "token_count": 260
    },
    "0041e3ef": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041e3ef(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.00407075(arg_8h);\n    if (iVar1 != -1) {\n        *(in_ECX + 0x88) = *(*arg_8h + 0xc);\n    }\n    return iVar1;\n}\n",
        "token_count": 95
    },
    "00420e2d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00420e2d(void)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_STATE.0;\n    puVar1 = extraout_ECX[0x12];\n    *(unaff_EBP + -4) = 1;\n    if (puVar1 != NULL) {\n        (***puVar1)(1);\n    }\n    if (extraout_ECX[0x1c] != NULL) {\n        (**(*extraout_ECX[0x1c] + 0xc))(extraout_ECX + 0x13);\n        if (extraout_ECX[0x1c] != NULL) {\n            (**(*extraout_ECX[0x1c] + 4))(1);\n        }\n    }\n    if (*extraout_ECX[0x1e] != NULL) {\n        (****extraout_ECX[0x1e])(1);\n    }\n    if (*(extraout_ECX[0x1e] + 4) != NULL) {\n        (****(extraout_ECX[0x1e] + 4))(1);\n    }\n    fcn.0040644a(extraout_ECX[0x1e]);\n    pcVar2 = extraout_ECX[0x20];\n    if ((pcVar2 != NULL) && (pcVar2 != 0xffffffff)) {\n        fcn.00420afd(pcVar2);\n        extraout_ECX[0x20] = 0xffffffff;\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.004227fd();\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 455
    },
    "00422489": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00422489(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    param_1[5] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar1;\n    if (iVar1 == -1) {\n        fcn.00407a99();\n    }\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 + 7);\n    return param_1;\n}\n",
        "token_count": 169
    },
    "00422836": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422836(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.00422680(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 228
    },
    "00422e3f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422e3f(int32_t **arg_8h, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    int32_t **ppiVar1;\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *arg_8h;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(in_ECX + 8) != 0) {\n                ppiVar1 = *(in_ECX + 4);\n                do {\n                    piVar3 = *ppiVar1;\n                    if (piVar3 != NULL) goto code_r0x00422e73;\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar4 < *(in_ECX + 8));\n                fcn.00407ad1();\n                in_ECX = extraout_ECX;\n            }\n        }\ncode_r0x00422e73:\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(in_ECX + 8);\n            uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(in_ECX + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *arg_8h = piVar5;\n        *arg_ch = piVar3[1];\n        *arg_10h = piVar3[2];\n    }\n    return;\n}\n",
        "token_count": 473
    },
    "00427f6e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00427f6e(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x74))(arg_ch, arg_ch >> 0x10, 0);\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(in_ECX[8]);\n        uVar2 = -(iVar1 != 0) & iVar1 + 0x50000U;\n    }\n    else {\n        uVar2 = iVar1 + 0x10000;\n    }\n    return uVar2;\n}\n",
        "token_count": 162
    },
    "0042c66e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c66e(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    \n    arg_8h_00 = arg_8h;\n    iVar3 = 0;\n    if (-1 < arg_8h) goto code_r0x0042c686;\n    do {\n        fcn.00407ad1();\ncode_r0x0042c686:\n        if (iVar3 <= arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (arg_8h_00 == iVar3) {\n            fcn.0040644a(*(in_ECX + 4));\n            *(in_ECX + 0xc) = iVar3;\n            *(in_ECX + 8) = iVar3;\n            goto code_r0x0042c776;\n        }\n        if (*(in_ECX + 4) == iVar3) {\n            uVar1 = fcn.0040641b(arg_8h_00);\n            *(in_ECX + 4) = uVar1;\n            fcn.00430820(uVar1, iVar3, arg_8h_00);\n            *(in_ECX + 0xc) = arg_8h_00;\ncode_r0x0042c6ed:\n            *(in_ECX + 8) = arg_8h_00;\n            return;\n        }\n        iVar3 = *(in_ECX + 0xc);\n        if (arg_8h_00 <= iVar3) {\n            iVar3 = *(in_ECX + 8);\n            if (iVar3 < arg_8h_00) {\n                fcn.00430820(iVar3 + *(in_ECX + 4), 0, arg_8h_00 - iVar3);\n            }\n            goto code_r0x0042c6ed;\n        }\n        iVar2 = *(in_ECX + 0x10);\n        if (iVar2 == 0) {\n            iVar2 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar2 < 4) {\ncode_r0x0042c71f:\n                iVar2 = 4;\n            }\n            else if (iVar2 < 0x401) {\n                if (iVar2 < 4) goto code_r0x0042c71f;\n            }\n            else {\n                iVar2 = 0x400;\n            }\n        }\n        arg_8h = iVar2 + iVar3;\n        if (iVar2 + iVar3 <= arg_8h_00) {\n            arg_8h = arg_8h_00;\n        }\n    } while (arg_8h < iVar3);\n    iVar3 = fcn.0040641b(arg_8h);\n    fcn.00408f79(iVar3, arg_8h, *(in_ECX + 4), *(in_ECX + 8));\n    fcn.00430820(*(in_ECX + 8) + iVar3, 0, arg_8h_00 - *(in_ECX + 8));\n    fcn.0040644a(*(in_ECX + 4));\n    *(in_ECX + 8) = arg_8h_00;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x0042c776:\n    *(in_ECX + 4) = iVar3;\n    return;\n}\n",
        "token_count": 802
    },
    "0042d652": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d652(uint arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_34h;\n    int32_t var_14h;\n    uint *var_10h;\n    uint var_4h;\n    \n    puVar1 = arg_ch;\n    puVar3 = &var_34h;\n    for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    if (((var_14h == 0) && (var_10h != 0xffffffff)) && (var_10h != NULL)) {\n        iVar2 = fcn.00428ec5(var_10h, &var_4h);\n        if (iVar2 == 0) {\n            puVar1 = fcn.00428fa7(var_10h);\n            *puVar1 = 0;\n        }\n        arg_ch = NULL;\n        fcn.00428eee(var_10h, &arg_ch);\n        var_10h = arg_ch;\n    }\n    (**(*in_ECX + 0x118))(0x432, arg_8h, &var_34h);\n    return;\n}\n",
        "token_count": 323
    },
    "00402ef0": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __thiscall fcn.00402ef0(int32_t param_1, int32_t param_2, int32_t *param_3)\n\n{\n    int32_t **ppiVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    int32_t **ppiVar5;\n    int32_t **ppiVar6;\n    int32_t **ppiVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t **in_FS_OFFSET;\n    int32_t unaff_retaddr;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t *piStack20;\n    uint uStack12;\n    uint uStack8;\n    int32_t *piStack4;\n    \n    piStack4 = 0xffffffff;\n    uStack8 = 0x446488;\n    uStack12 = *in_FS_OFFSET;\n    uVar3 = *0x45c240 ^ &stack0xffffffd4;\n    *in_FS_OFFSET = &uStack12;\n    piVar4 = fcn.00406b74(uVar3);\n    if (piVar4 == NULL) {\n        piVar4 = fcn.00401000(0x80004005);\n    }\n    ppiVar5 = (**(*piVar4 + 0xc))();\n    uStack8 = 0;\n    piVar4 = fcn.00406b74();\n    if (piVar4 == NULL) {\n        piVar4 = fcn.00401000(0x80004005);\n    }\n    ppiVar6 = (**(*piVar4 + 0xc))();\n    uStack8 = CONCAT31(uStack8._1_3_, 1);\n    piVar4 = fcn.00406b74();\n    if (piVar4 == NULL) {\n        piVar4 = fcn.00401000(0x80004005);\n    }\n    ppiVar7 = (**(*piVar4 + 0xc))();\n    uStack8 = CONCAT31(uStack8._1_3_, 2);\n    iVar8 = fcn.0040cc9c(1);\n    if (iVar8 == 0) {\n        uStack12._0_1_ = 1;\n        ppiVar1 = ppiVar7 + 3;\n        LOCK();\n        piVar4 = *ppiVar1;\n        *ppiVar1 = *ppiVar1 + -1;\n        if (piVar4 + -1 < 1) {\n            (**(**ppiVar7 + 4))(ppiVar7);\n        }\n        uStack12 = uStack12 & 0xffffff00;\n        ppiVar7 = ppiVar6 + 3;\n        LOCK();\n        piVar4 = *ppiVar7;\n        *ppiVar7 = *ppiVar7 + -1;\n        if (piVar4 + -1 < 1) {\n            (**(**ppiVar6 + 4))(ppiVar6);\n        }\n        ppiVar6 = ppiVar5 + 3;\n        LOCK();\n        piVar4 = *ppiVar6;\n        *ppiVar6 = *ppiVar6 + -1;\n        goto code_r0x004032dd;\n    }\n    piVar4 = *(param_1 + 0x54);\n    (**(*piVar4 + 200))(*(param_1 + 0x9c) - piVar4[0x1f], piVar4 + 0x20);\n    piStack20 = &param_2;\n    fcn.004024f0();\n    if (param_2 == *(param_1 + 0xac)) {\n        cVar2 = fcn.004034a0();\n        if (cVar2 != '\\0') {\n            cVar2 = fcn.004034a0();\n            if (cVar2 != '\\0') {\n                cVar2 = fcn.004034a0();\n                if (cVar2 != '\\0') {\n                    fcn.00401910();\n                    fcn.00401910();\n                    fcn.00401910();\n                    *in_FS_OFFSET = param_3;\n                    return 1;\n                }\n            }\n        }\n    }\n    iVar11 = -1;\n    iVar10 = 3;\n    iVar8 = fcn.0040797a(6, 3, 0xffffffff);\n    if (iVar8 == 2) {\n        iVar8 = fcn.0040df6b();\n        iVar9 = fcn.004129ba();\n        (*_sym.imp.USER32.dll_SendMessageW)(*(iVar9 + 0xe8), 0x222, *(iVar8 + 0x20));\ncode_r0x00403280:\n        piVar4 = iVar10 + -4;\n        LOCK();\n        iVar8 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n    }\n    else {\n        if (iVar8 != 6) {\n            if (iVar8 == 7) {\n                param_2 = CONCAT31(param_2._1_3_, 1);\n                LOCK();\n                if (unaff_retaddr == 1 || unaff_retaddr + -1 < 0) {\n                    (**(*uStack12 + 4))();\n                }\n                uStack12 = uStack12 & 0xffffff00;\n                piVar4 = iVar11 + -4;\n                LOCK();\n                iVar8 = *piVar4;\n                *piVar4 = *piVar4 + -1;\n                if (iVar8 == 1 || iVar8 + -1 < 0) {\n                    (**(**(iVar11 + -0x10) + 4))(iVar11 + -0x10);\n                }\n                uStack12 = 0xffffffff;\n                LOCK();\n                if (param_3 == 0x1 || param_3 + -1 < 0) {\n                    param_3 = param_3 + -1;\n                    (**(*piStack4 + 4))(&piStack4);\n                    *in_FS_OFFSET = &param_3;\n                    return 1;\n                }\ncode_r0x0040323f:\n                *in_FS_OFFSET = piStack20;\n                return 1;\n            }\n            goto code_r0x00403280;\n        }\n        iVar8 = fcn.004023c0(param_1, *(param_1 + 0xac), *(param_1 + 0xa8));\n        if (iVar8 != 0) {\n            uStack12._0_1_ = 1;\n            piVar4 = iVar10 + -4;\n            LOCK();\n            iVar8 = *piVar4;\n            *piVar4 = *piVar4 + -1;\n            if (iVar8 == 1 || iVar8 + -1 < 0) {\n                (**(**(iVar10 + -0x10) + 4))(iVar10 + -0x10);\n            }\n            uStack12 = uStack12 & 0xffffff00;\n            piVar4 = iVar11 + -4;\n            LOCK();\n            iVar8 = *piVar4;\n            *piVar4 = *piVar4 + -1;\n            if (iVar8 == 1 || iVar8 + -1 < 0) {\n                (**(**(iVar11 + -0x10) + 4))(iVar11 + -0x10);\n            }\n            uStack12 = 0xffffffff;\n            LOCK();\n            if (param_3 == 0x1 || param_3 + -1 < 0) {\n                param_3 = param_3 + -1;\n                (**(*piStack4 + 4))(&piStack4);\n            }\n            goto code_r0x0040323f;\n        }\n        fcn.00403300();\n        piVar4 = iVar10 + -4;\n        LOCK();\n        iVar8 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n    }\n    if (iVar8 == 1 || iVar8 + -1 < 0) {\n        (**(**(iVar10 + -0x10) + 4))(iVar10 + -0x10);\n        uStack12._0_1_ = 1;\n    }\n    uStack12 = uStack12._1_3_ << 8;\n    piVar4 = iVar11 + -4;\n    LOCK();\n    iVar8 = *piVar4;\n    *piVar4 = *piVar4 + -1;\n    if (iVar8 == 1 || iVar8 + -1 < 0) {\n        (**(**(iVar11 + -0x10) + 4))(iVar11 + -0x10);\n    }\n    ppiVar5 = &piStack4;\n    LOCK();\n    piVar4 = param_3;\n    param_3 = param_3 + -1;\ncode_r0x004032dd:\n    uStack12 = 0xffffffff;\n    if (piVar4 == 0x1 || piVar4 + -1 < 0) {\n        (**(**ppiVar5 + 4))(ppiVar5);\n    }\n    *in_FS_OFFSET = piStack20;\n    return 0;\n}\n",
        "token_count": 2008
    },
    "00421648": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00421648(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.00420e14();\n    if ((iVar2 != 0) && (*(iVar2 + 0xc) != 0)) {\n        uVar3 = fcn.00431fce(*(iVar2 + 0xc));\n        if (arg_8h + 4U < uVar3) {\n            fcn.00431e8e(*(iVar2 + 0xc), (uVar3 - arg_8h) + -4);\n        }\n        else {\n            fcn.0042e518(*(iVar2 + 0xc));\n            *(iVar2 + 0xc) = 0;\n        }\n        return 1;\n    }\n    fcn.00407a99();\n    pcVar1 = swi(3);\n    uVar4 = (*pcVar1)();\n    return uVar4;\n}\n",
        "token_count": 229
    },
    "00418ea9": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00418ea9(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t extraout_ECX;\n    uint unaff_ESI;\n    int32_t *in_FS_OFFSET;\n    uint uStackY8240;\n    int32_t iStackY8236;\n    int32_t iStackY8232;\n    uint32_t uStackY8228;\n    int32_t iStackY8224;\n    uint uStackY8220;\n    uint uStackY92;\n    int32_t iStackY88;\n    uint uStackY84;\n    uint uStackY80;\n    uchar *puStackY76;\n    uint uStackY72;\n    uchar *puStackY68;\n    uint32_t uStackY64;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x444e5c;\n    var_ch = *in_FS_OFFSET;\n    fcn.00431af0();\n    *in_FS_OFFSET = &fcn.00418ea9::var_ch;\n    uStackY8220 = arg_8h;\n    iStackY8224 = arg_14h;\n    iStackY8232 = 0;\n    if (*(extraout_ECX + 0x54) == 0) {\n        if (arg_14h == 0) {\n            iStackY8224 = 0x44fa4c;\n        }\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringW)();\n    }\n    else {\n        iStackY8236 = fcn.00418cac(arg_ch);\n        if (iStackY8236 != 0) {\n            fcn.00401890();\n            pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExW;\n            var_4h = 0;\n            uStackY8240 = 0;\n            uStackY8228 = 0;\n            uStackY64 = 0x418f5a;\n            iStackY8232 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)();\n            if (iStackY8232 == 0) {\n                uStackY64 = uStackY8228 >> 1;\n                puStackY68 = 0x418f78;\n                uStackY72 = fcn.004019b0();\n                puStackY68 = &stack0xffffdfdc;\n                puStackY76 = &stack0xffffdfd0;\n                uStackY80 = 0;\n                uStackY84 = arg_10h;\n                iStackY88 = iStackY8236;\n                uStackY92 = 0x418f91;\n                iStackY8232 = (*pcVar1)();\n                uStackY64 = 0x418fa4;\n                fcn.0040d34f(0xffffffff);\n            }\n            uStackY64 = iStackY8236;\n            puStackY68 = 0x418fb0;\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)();\n            if (iStackY8232 == 0) {\n                fcn.004052f0();\n            }\n            else {\n                fcn.00402680();\n            }\n            fcn.00401020();\n            goto code_r0x00419028;\n        }\n    }\n    fcn.00402680();\ncode_r0x00419028:\n    *in_FS_OFFSET = var_ch;\n    fcn.0042e09f(unaff_ESI);\n    return;\n}\n",
        "token_count": 817
    },
    "004270cb": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004270cb(uint arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    \n    in_ECX[1] = arg_ch;\n    if (arg_ch <= arg_ch + 0x40) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, arg_ch + 0x40);\n        *in_ECX = iVar1;\n        if (iVar1 != 0) {\n            arg_8h_00 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n            fcn.00408f79(arg_8h_00, in_ECX[1], arg_8h, in_ECX[1]);\n            iVar1 = fcn.00426f61(arg_8h_00);\n            in_ECX[2] = iVar1 == 0;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 238
    },
    "00413e42": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00413e42(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t in_ECX;\n    \n    if ((((arg_8h != 0) && (arg_8h != 6)) && (arg_8h != 7)) && ((arg_8h != 8 && (arg_8h != 4)))) {\n        uVar1 = (*_sym.imp.USER32.dll_GetLastActivePopup)(*(in_ECX + 0x20));\n        (*_sym.imp.USER32.dll_BringWindowToTop)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "00406320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406320(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *in_FS_OFFSET;\n    uchar *puVar2;\n    uint uStack92;\n    uchar *puStack88;\n    uint uStack84;\n    int32_t iStack60;\n    uint uStack48;\n    int32_t iStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0xffffffff;\n    uStack16 = 0x4460d8;\n    iStack20 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &stack0xffffffec;\n    uStack84 = 0x406356;\n    fcn.00409cc5(in_ECX);\n    uStack16 = 0;\n    uStack84 = 0;\n    puStack88 = &stack0xffffffd0;\n    uStack92 = 0x406371;\n    (**(*in_ECX + 0x160))();\n    uStack92 = 1;\n    (*_sym.imp.GDI32.dll_DPtoLP)(uStack48, &fcn.00406320::arg_ch);\n    uStack84 = arg_ch;\n    puVar2 = &stack0xffffffa8;\n    (**(*in_ECX + 0x1bc))(&stack0xffffffac, &stack0xffffffa4, puVar2, 1);\n    iVar1 = (**(*in_ECX + 0x19c))();\n    if (puVar2 <= iVar1 + -1) {\n        (**(*in_ECX + 0x1a8))(puVar2);\n    }\n    fcn.00409d19();\n    *in_FS_OFFSET = iStack60;\n    return;\n}\n",
        "token_count": 394
    },
    "0040f50b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.0040f50b(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    bool bVar3;\n    uint uVar4;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_10h != 0) {\n        uVar4 = 0xffffffff;\n        iVar2 = arg_10h;\n        iVar1 = fcn.004219e3(arg_10h);\n        if (iVar1 == 0) {\n            fcn.00407ad1(iVar2, uVar4);\n        }\n    }\n    var_4h = arg_8h;\n    var_8h = arg_ch;\n    var_10h = arg_14h;\n    var_14h = arg_18h;\n    var_18h = arg_1ch;\n    var_1ch = arg_20h;\n    var_20h = arg_24h;\n    var_24h = arg_28h;\n    var_ch = arg_10h;\n    var_28h = arg_2ch;\n    iVar2 = fcn.004213cc();\n    var_2ch = *(iVar2 + 8);\n    var_30h = arg_30h;\n    iVar2 = (**(*in_ECX + 100))(&var_30h);\n    if (iVar2 == 0) {\n        (**(*in_ECX + 0x11c))();\n        bVar3 = false;\n    }\n    else {\n        fcn.0040f4b1(in_ECX);\n        iVar2 = fcn.0040ba20(var_4h, var_8h, var_ch, var_10h, var_14h, var_18h, var_1ch, var_20h, var_24h, var_28h, \n                             var_2ch, var_30h);\n        iVar1 = fcn.0040d516();\n        if (iVar1 == 0) {\n            (**(*in_ECX + 0x11c))();\n        }\n        bVar3 = iVar2 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 616
    },
    "004069ea": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.004069ea(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uchar *puVar3;\n    int32_t extraout_ECX;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    uint16_t uVar6;\n    int32_t iVar7;\n    int32_t var_90h;\n    int32_t nWidth;\n    int32_t nHeight;\n    uint lpvBits;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    nWidth = uVar2;\n    nHeight = uVar2 >> 0x10;\n    if ((nWidth < 5) || (iVar4 = nWidth,  nHeight < 6)) {\n        fcn.00407ad1();\n        iVar4 = extraout_ECX;\n    }\n    if (0x20 < iVar4) {\n        iVar4 = 0x20;\n        nWidth = 0x20;\n    }\n    iVar7 = iVar4 + 0xf >> 4;\n    iVar4 = ((iVar4 + -4) / 2 + iVar7 * 0x10) - iVar4;\n    if (0xc < iVar4) {\n        iVar4 = 0xc;\n    }\n    if (0x20 < nHeight) {\n        nHeight = 0x20;\n    }\n    fcn.00430820(&lpvBits, 0xff, 0x80);\n    puVar3 = &lpvBits + (nHeight + -6 >> 1) * iVar7 * 2;\n    puVar5 = 0x44780c;\n    var_90h = 5;\n    do {\n        uVar1 = *puVar5;\n        puVar5 = puVar5 + 1;\n        uVar6 = ~(uVar1 << (iVar4 & 0x1f));\n        *puVar3 = uVar6 >> 8;\n        puVar3[1] = uVar6;\n        puVar3 = puVar3 + iVar7 * 2;\n        var_90h = var_90h + -1;\n    } while (var_90h != 0);\n    uVar2 = 1;\n    *0x45f7c0 = (*_sym.imp.GDI32.dll_CreateBitmap)(nWidth, nHeight, 1, 1, &lpvBits);\n    if (*0x45f7c0 == 0) {\n        *0x45f7c0 = (*_sym.imp.USER32.dll_LoadBitmapW)(0, 0x7fe3);\n    }\n    fcn.0042e09f(uVar2);\n    return;\n}\n",
        "token_count": 618
    },
    "0040d379": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.0040d379(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.00422773(0x407aed);\n    if (iVar1 == 0) {\n        fcn.00407ad1();\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x68) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x70) = uVar2 >> 0x10;\n    *(iVar1 + 0x6c) = uVar2;\n    return iVar1 + 0x58;\n}\n",
        "token_count": 159
    },
    "0040eae4": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040eae4(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == 0) {\n        if (uVar3 == 0) {\n            return 0;\n        }\n        fcn.0040b26b();\n        var_28h = uVar3;\n        (**(*in_ECX + 0xc))(uVar3, 0xffffffff, &var_2ch, 0);\n        if (var_4h != 0) {\n            arg_8h = 0;\ncode_r0x0040eb69:\n            uVar2 = (**(*in_ECX + 0xc))(uVar3, arg_8h, 0, 0);\n            return uVar2;\n        }\n    }\n    else {\n        iVar1 = fcn.00422773(0x407aed);\n        if (iVar1 == 0) {\n            iVar1 = fcn.00407ad1();\n        }\n        if ((*(iVar1 + 0x13c) != in_ECX[8]) && (iVar1 = fcn.0040e06a(arg_ch, 0),  iVar1 == 0)) {\n            if (uVar3 == 0) {\n                return 0;\n            }\n            goto code_r0x0040eb69;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 388
    },
    "0040fdff": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040fdff(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0x112) {\n        if (arg_8h == 0x111) {\n            iVar2 = fcn.004065a9(0, arg_ch >> 0x10 | 0xbd110000, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 1;\n                return 1;\n            }\n            return 1;\n        }\n        if (0x2a < arg_8h) {\n            if ((arg_8h < 0x30) || (arg_8h == 0x39)) goto code_r0x0040fe95;\n            if (arg_8h == 0x4e) {\n                var_8h = arg_14h;\n                var_4h = arg_10h;\n                uVar1 = fcn.004065a9(0, *(arg_10h + 8) & 0xffff | 0xbc4e0000, &var_8h, 0);\n                return uVar1;\n            }\n        }\n    }\n    else if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) {\ncode_r0x0040fe95:\n        uVar1 = fcn.0040f668(arg_8h + 0xbc00, arg_ch, arg_10h, arg_14h);\n        return uVar1;\n    }\n    if (arg_8h - 0x132 < 7) {\n        var_4h = arg_8h - 0x132;\n        var_8h = arg_ch;\n        uVar1 = fcn.0040f668(0xbc19, 0, &var_ch, arg_14h);\n        if (*arg_14h != 0) {\n            return uVar1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 527
    },
    "0041d04a": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041d04a(uint hModule, int32_t hResInfo, int32_t arg_10h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *arg_10h_00;\n    int32_t *arg_8h;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint uVar11;\n    uint32_t uVar12;\n    int32_t iVar13;\n    uint hResData;\n    uint var_10h;\n    uint var_ch;\n    uint hDC;\n    uint var_4h;\n    \n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if ((iVar5 == 0) || (arg_10h_00 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar5),  arg_10h_00 == NULL)) {\n        iVar6 = 0;\n    }\n    else {\n        iVar13 = *arg_10h_00 + 0x40;\n        arg_8h = fcn.0042eec5(iVar13);\n        if (arg_8h == NULL) {\n            iVar6 = 0;\n        }\n        else {\n            fcn.00408f79(arg_8h, iVar13, arg_10h_00, iVar13);\n            iVar13 = *arg_8h;\n            hResInfo = 0;\n            do {\n                pcVar4 = _sym.imp.USER32.dll_GetSysColor;\n                puVar1 = arg_8h + hResInfo * 4 + iVar13;\n                uVar12 = 0;\n                do {\n                    if (*puVar1 == *(uVar12 * 8 + 0x44b234)) {\n                        if (arg_10h == 0) {\n                            puVar2 = uVar12 * 8 + 0x44b238;\n                            uVar12 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar2);\n                            uVar7 = (*pcVar4)(*puVar2);\n                            uVar8 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar2);\n                            *puVar1 = uVar8 >> 0x10 & 0xff | ((uVar7 & 0xff) << 8 | uVar12 >> 8 & 0xff) << 8;\n                        }\n                        else if (*(uVar12 * 8 + 0x44b238) != 0x12) {\n                            *puVar1 = 0xffffff;\n                        }\n                        break;\n                    }\n                    uVar12 = uVar12 + 1;\n                } while (uVar12 < 4);\n                hResInfo = hResInfo + 1;\n            } while (hResInfo < 0x10);\n            iVar13 = arg_8h[1];\n            iVar3 = arg_8h[2];\n            uVar9 = (*_sym.imp.USER32.dll_GetDC)(0);\n            iVar6 = (*_sym.imp.GDI32.dll_CreateCompatibleBitmap)(uVar9, iVar13, iVar3);\n            if (iVar6 != 0) {\n                uVar10 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(uVar9);\n                pcVar4 = _sym.imp.GDI32.dll_SelectObject;\n                uVar11 = (*_sym.imp.GDI32.dll_SelectObject)(uVar10, iVar6);\n                (*_sym.imp.GDI32.dll_StretchDIBits)\n                          (uVar10, 0, 0, iVar13, iVar3, 0, 0, iVar13, iVar3, \n                           arg_10h_00 + (1 << (*(arg_8h + 0xe) & 0x1f)) + 10, arg_8h, 0, 0xcc0020);\n                (*pcVar4)(uVar10, uVar11);\n                (*_sym.imp.GDI32.dll_DeleteDC)(uVar10);\n            }\n            (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar9);\n            fcn.0042e518(arg_8h);\n            (*_sym.imp.KERNEL32.dll_FreeResource)(iVar5);\n        }\n    }\n    return iVar6;\n}\n",
        "token_count": 968
    },
    "0041d2f4": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d2f4(uint32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x20));\n    pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n    if (iVar2 == 0) {\n        *(in_ECX + 0xb0) = arg_8h;\n        *(in_ECX + 0xb4) = arg_ch;\n        *(in_ECX + 0xa8) = arg_10h;\n        *(in_ECX + 0xac) = arg_14h;\n    }\n    else {\n        (*_sym.imp.USER32.dll_SendMessageW)(*(in_ECX + 0x20), 0x420, 0, arg_10h & 0xffff | arg_14h << 0x10);\n        (*pcVar1)(*(in_ECX + 0x20), 0x41f, 0, arg_8h & 0xffff | arg_ch << 0x10);\n        if (0x5ffff < *0x45bc5c) {\n            uVar3 = (*pcVar1)(*(in_ECX + 0x20), 0x43a, 0, 0);\n            *(in_ECX + 0xb0) = uVar3 & 0xffff;\n            *(in_ECX + 0xb4) = uVar3 >> 0x10;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 411
    },
    "0041d59d": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041d59d(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint *arg_ch_00;\n    uint var_18h;\n    char var_10h;\n    uint var_fh;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    arg_ch_00 = 0x41d5be;\n    fcn.0041cda3(arg_8h, &fcn.0041d59d::var_18h);\n    cVar1 = arg_ch >> 0x10;\n    if ((var_fh != arg_ch) || (var_10h != cVar1)) {\n        arg_ch_00 = &fcn.0041d59d::var_18h;\n        var_10h = cVar1;\n        var_fh._0_1_ = arg_ch;\n        fcn.0041d3fb(arg_8h, arg_ch_00);\n        *(in_ECX + 0xa4) = 1;\n    }\n    fcn.0042e09f(arg_ch_00);\n    return;\n}\n",
        "token_count": 275
    },
    "00425430": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00425430(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    \n    if (arg_8h == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar3 = fcn.00422773(0x407aed);\n        if (iVar3 == 0) {\n            fcn.00407ad1();\n        }\n        if ((*(iVar3 + 0x18) != 0) && (iVar4 = fcn.0040d489(arg_8h),  iVar4 == 0)) {\n            fcn.0040e3a6(arg_8h);\n            *(iVar3 + 0x18) = 0;\n        }\n        pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageW;\n        if (arg_ch == 0x110) {\n            *0x45f804 = (*_sym.imp.USER32.dll_RegisterWindowMessageW)(L\"commdlg_LBSelChangedNotify\");\n            *0x45f808 = (*pcVar1)(L\"commdlg_ShareViolation\");\n            *0x45f80c = (*pcVar1)(L\"commdlg_FileNameOK\");\n            *0x45f810 = (*pcVar1)(L\"commdlg_ColorOK\");\n            *0x45f814 = (*pcVar1)(L\"commdlg_help\");\n            *0x45f818 = (*pcVar1)(L\"commdlg_SetRGBColor\");\n            uVar2 = fcn.0041ae6d(arg_8h, 0x110);\n        }\n        else if ((arg_ch == *0x45f814) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageW)(arg_8h, 0x111, 0xe146, 0);\n            uVar2 = 1;\n        }\n        else {\n            if (((0xbfff < arg_ch) && (piVar5 = fcn.0040d489(arg_8h),  piVar5 != NULL)) &&\n               ((iVar3 = fcn.004075cd(0x44ce5c),  iVar3 == 0 ||\n                (iVar3 = fcn.0041bbc3(),  (*(iVar3 + 0x34) & 0x80000) == 0)))) {\n                if (arg_ch == *0x45f808) {\n                    uVar2 = (**(*piVar5 + 0x164))(arg_14h);\n                    return uVar2;\n                }\n                if (arg_ch == *0x45f80c) {\n                    piVar5[0xc6] = arg_14h;\n                    uVar2 = (**(*piVar5 + 0x168))();\n                    piVar5[0xc6] = 0;\n                    return uVar2;\n                }\n                if (arg_ch == *0x45f804) {\n                    (**(*piVar5 + 0x16c))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                }\n                else if (arg_ch == *0x45f810) {\n                    uVar2 = (**(*piVar5 + 0x164))();\n                    return uVar2;\n                }\n            }\n            uVar2 = 0;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 804
    },
    "00443b20": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t * fcn.00443b20(uint32_t *param_1, char param_2)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar1 = param_1 & 3;\n    while (uVar1 != 0) {\n        if (*param_1 == param_2) {\n            return param_1;\n        }\n        if (*param_1 == '\\0') {\n            return NULL;\n        }\n        uVar1 = param_1 + 1 & 3;\n        param_1 = param_1 + 1;\n    }\n    while( true ) {\n        while( true ) {\n            uVar1 = *param_1;\n            uVar4 = uVar1 ^ CONCAT22(CONCAT11(param_2, param_2), CONCAT11(param_2, param_2));\n            uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;\n            puVar5 = param_1 + 1;\n            if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;\n            param_1 = puVar5;\n            if ((uVar3 & 0x81010100) != 0) {\n                if ((uVar3 & 0x1010100) != 0) {\n                    return NULL;\n                }\n                if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {\n                    return NULL;\n                }\n            }\n        }\n        uVar1 = *param_1;\n        if (uVar1 == param_2) {\n            return param_1;\n        }\n        if (uVar1 == '\\0') {\n            return NULL;\n        }\n        cVar2 = uVar1 >> 8;\n        if (cVar2 == param_2) {\n            return param_1 + 1;\n        }\n        if (cVar2 == '\\0') break;\n        cVar2 = uVar1 >> 0x10;\n        if (cVar2 == param_2) {\n            return param_1 + 2;\n        }\n        if (cVar2 == '\\0') {\n            return NULL;\n        }\n        cVar2 = uVar1 >> 0x18;\n        if (cVar2 == param_2) {\n            return param_1 + 3;\n        }\n        param_1 = puVar5;\n        if (cVar2 == '\\0') {\n            return NULL;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 591
    },
    "00408c90": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: hRgn\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00408c90(uint arg_8h)\n\n{\n    int32_t *lpPoint;\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint hRgn;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0xc);\n    if (*(unaff_EBP + 8) == 0) {\n        fcn.00407ad1();\n    }\n    lpPoint = extraout_ECX + 0x19;\n    fcn.00407fa7(lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x25);\n    extraout_ECX[0x16] = extraout_ECX[0x1a] - iVar2;\n    iVar2 = (*pcVar1)(0x25);\n    extraout_ECX[0x18] = iVar2 + extraout_ECX[0x1a];\n    iVar3 = (*pcVar1)(0x24);\n    iVar2 = *lpPoint;\n    extraout_ECX[0x15] = *lpPoint - iVar3;\n    iVar3 = (*pcVar1)(0x24);\n    extraout_ECX[0x17] = iVar3 + iVar2;\n    *(unaff_EBP + -0x10) = *extraout_ECX;\n    uVar4 = fcn.004102c6(0x800, 0, 0, 0);\n    uVar4 = (**(*(unaff_EBP + -0x10) + 0x5c))(0x88, uVar4);\n    *(unaff_EBP + -0x10) = uVar4;\n    fcn.00407f78(*(unaff_EBP + 8));\n    if (*(unaff_EBP + -0x10) != 0) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -0x18) = vtable.CRgn.0;\n        *(unaff_EBP + -4) = 0;\n        uVar4 = (*_sym.imp.GDI32.dll_CreateEllipticRgn)(0, 0, 0x20, 0x20);\n        fcn.00409eff(uVar4);\n        (*_sym.imp.USER32.dll_SetWindowRgn)(extraout_ECX[8], *(unaff_EBP + -0x14), 1);\n        uVar4 = (*_sym.imp.USER32.dll_SetCapture)(extraout_ECX[8]);\n        fcn.0040d45d(uVar4);\n        (*_sym.imp.USER32.dll_SetTimer)(extraout_ECX[8], 0xe000, 0x32, 0);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x18) = vtable.CRgn.0;\n        fcn.00401080();\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 758
    },
    "0041a743": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nint32_t fcn.0041a743(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00420e14();\n    return iVar1 + 0x30;\n}\n",
        "token_count": 45
    },
    "0042d779": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/bde1572c33fb4ad4a176b04786e84c23",
            "validate payment card number using luhn algorithm with no lookup table/73780005e39049dabd818a965d665a12"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d779(int32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint var_24h;\n    int32_t var_20h;\n    uint32_t var_18h;\n    uint var_10h;\n    uint32_t lpPoint;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n    puVar3 = arg_ch;\n    puVar4 = &var_24h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    var_24h = (*_sym.imp.USER32.dll_SendMessageW)(*(arg_8h + 0x20), 0x410, 0, &var_10h);\n    lpPoint = arg_ch[5];\n    var_4h = arg_ch[6];\n    if (var_20h - 0x200U < 10) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(var_24h, &lpPoint);\n    }\n    var_18h = lpPoint & 0xffff | var_4h << 0x10;\n    (*pcVar1)(*(arg_8h + 0x20), 0x407, 0, &var_24h);\n    return;\n}\n",
        "token_count": 360
    },
    "0041ce3e": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041ce3e(uint arg_8h)\n\n{\n    uint var_18h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.0041cda3(arg_8h, &var_18h);\n    fcn.0042e09f(arg_8h);\n    return;\n}\n",
        "token_count": 100
    },
    "0041cf45": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041cf45(uint arg_8h, uint *arg_ch, uint32_t *arg_10h, uint *arg_14h)\n\n{\n    uint unaff_ESI;\n    uint var_18h;\n    uint var_14h;\n    uint8_t var_10h;\n    uint var_fh;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.0041cda3(arg_8h, &var_18h);\n    *arg_ch = var_14h;\n    *arg_10h = var_10h << 0x10 | var_fh;\n    *arg_14h = var_18h;\n    fcn.0042e09f(unaff_ESI);\n    return;\n}\n",
        "token_count": 193
    },
    "0041781c": {
        "rules": [
            "encrypt data using HC-128/11bb23636d2a4650a9dbaa6512d69580"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_12h\n\nvoid __cdecl fcn.0041781c(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    char cVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    code *pcVar5;\n    uint32_t uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t unaff_EBP;\n    uint var_26ch;\n    uint var_268h;\n    uint var_264h;\n    uint var_258h;\n    uint var_250h;\n    uint var_24ch;\n    uint var_248h;\n    uint var_244h;\n    uint var_240h;\n    uint var_238h;\n    uint var_234h;\n    uint var_230h;\n    uint var_228h;\n    uint lParam;\n    uint var_220h;\n    uint lpFilename;\n    uint var_12h;\n    uint var_4h;\n    \n    fcn.00430f04(0x260);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleW;\n    *(unaff_EBP + -0x228) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x234) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x224) = 0;\n    *(unaff_EBP + -0x220) = 0;\n    uVar4 = (*pcVar1)(L\"kernel32.dll\");\n    pcVar7 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    *(unaff_EBP + -0x238) = uVar4;\n    pcVar5 = (*pcVar7)(uVar4, \"GetUserDefaultUILanguage\");\n    if (pcVar5 == NULL) {\n        iVar8 = (*pcVar1)(L\"ntdll.dll\");\n        if (iVar8 != 0) {\n            *(unaff_EBP + -0x224) = 0;\n            (*_sym.imp.KERNEL32.dll_EnumResourceLanguagesW)(iVar8, 0x10, 1, fcn.00416ecf, unaff_EBP + -0x224);\n            pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n            if (*(unaff_EBP + -0x224) != 0) {\n                uVar6 = *(unaff_EBP + -0x224) & 0x3ff;\n                uVar4 = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)((*(unaff_EBP + -0x224) >> 10) << 10 | uVar6);\n                *(unaff_EBP + -0x24c) = uVar4;\n                uVar4 = (*pcVar1)(uVar6);\n                *(unaff_EBP + -0x248) = uVar4;\n                *(unaff_EBP + -0x220) = 2;\n            }\n        }\n    }\n    else {\n        uVar6 = (*pcVar5)();\n        pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n        *(unaff_EBP + -0x224) = uVar6 & 0xffff;\n        *(unaff_EBP + -0x220) = uVar6 & 0x3ff;\n        uVar4 = (*pcVar1)(uVar6 & 0xffff);\n        *(unaff_EBP + -0x24c) = uVar4;\n        uVar4 = (*pcVar1)(*(unaff_EBP + -0x220));\n        *(unaff_EBP + -0x248) = uVar4;\n        *(unaff_EBP + -0x220) = 2;\n        pcVar7 = (*pcVar7)(*(unaff_EBP + -0x238), \"GetSystemDefaultUILanguage\");\n        if (pcVar7 != NULL) {\n            uVar3 = (*pcVar7)();\n            *(unaff_EBP + -0x224) = uVar3;\n            uVar4 = (*pcVar1)(uVar3);\n            *(unaff_EBP + -0x244) = uVar4;\n            uVar4 = (*pcVar1)(uVar3 & 0x3ff);\n            *(unaff_EBP + -0x240) = uVar4;\n            *(unaff_EBP + -0x220) = 4;\n        }\n    }\n    iVar8 = *(unaff_EBP + -0x220);\n    *(unaff_EBP + -0x220) = *(unaff_EBP + -0x220) + 1;\n    *(unaff_EBP + -0x24c + iVar8 * 4) = 0x800;\n    *(unaff_EBP + -0x12) = 0;\n    *(unaff_EBP + -0x14) = 0;\n    iVar8 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0x400000, unaff_EBP + -0x21c, 0x105);\n    if (iVar8 != 0) {\n        fcn.00430820(unaff_EBP + -0x26c, 0, 0x20);\n        *(unaff_EBP + -0x26c) = 0x20;\n        *(unaff_EBP + -0x264) = unaff_EBP + -0x21c;\n        *(unaff_EBP + -600) = 1000;\n        *(unaff_EBP + -0x250) = 0x400000;\n        *(unaff_EBP + -0x268) = 0x88;\n        fcn.00416ee9(0xffffffff);\n        *(unaff_EBP + -4) = 0;\n        cVar2 = fcn.00416fa0(unaff_EBP + -0x26c);\n        if (cVar2 != '\\0') {\n            fcn.00416fda();\n        }\n        iVar8 = 0;\n        if (0 < *(unaff_EBP + -0x220)) {\n            do {\n                iVar9 = fcn.00417496(*(unaff_EBP + -0x24c + iVar8 * 4));\n                if (iVar9 != 0) break;\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < *(unaff_EBP + -0x220));\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00417562();\n    }\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 1480
    },
    "0041a225": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_25ch\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041a225(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    ulong uVar3;\n    uint var_25ch;\n    uint lpFindFileData;\n    uint var_250h;\n    uint var_248h;\n    uint var_240h;\n    uint var_238h;\n    uint32_t var_234h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    if ((arg_8h != 0) && (iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_8h),  iVar1 < 0x104)) {\n        iVar1 = fcn.00419a25(arg_ch + 0x22, arg_8h);\n        if (iVar1 == 0) {\n            *(arg_ch + 0x22) = 0;\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileW)(arg_8h, &lpFindFileData);\n            if (iVar1 != -1) {\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n                *(arg_ch + 8) = lpFindFileData & 0x7f;\n                uVar3 = fcn.00431df0();\n                arg_ch[6] = uVar3;\n                arg_ch[6] = arg_ch[6] | var_234h;\n                arg_ch[7] = uVar3 >> 0x20;\n                arg_ch[7] = arg_ch[7];\n                iVar1 = fcn.00419fa4(&var_250h);\n                if (iVar1 == 0) {\n                    *arg_ch = 0;\n                    arg_ch[1] = 0;\n                }\n                else {\n                    puVar2 = fcn.0041a0c7(&var_250h, 0xffffffff);\n                    *arg_ch = *puVar2;\n                    arg_ch[1] = puVar2[1];\n                }\n                iVar1 = fcn.00419fa4(&var_248h);\n                if (iVar1 == 0) {\n                    arg_ch[4] = 0;\n                    arg_ch[5] = 0;\n                }\n                else {\n                    puVar2 = fcn.0041a0c7(&var_248h, 0xffffffff);\n                    arg_ch[4] = *puVar2;\n                    arg_ch[5] = puVar2[1];\n                }\n                iVar1 = fcn.00419fa4(&var_240h);\n                if (iVar1 == 0) {\n                    arg_ch[2] = 0;\n                    arg_ch[3] = 0;\n                }\n                else {\n                    puVar2 = fcn.0041a0c7(&var_240h, 0xffffffff);\n                    arg_ch[2] = *puVar2;\n                    arg_ch[3] = puVar2[1];\n                }\n                if ((*arg_ch | arg_ch[1]) == 0) {\n                    *arg_ch = arg_ch[2];\n                    arg_ch[1] = arg_ch[3];\n                }\n                if ((arg_ch[4] | arg_ch[5]) == 0) {\n                    arg_ch[4] = arg_ch[2];\n                    arg_ch[5] = arg_ch[3];\n                }\n            }\n        }\n    }\n    fcn.0042e09f(var_25ch);\n    return;\n}\n",
        "token_count": 808
    },
    "00421610": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421610(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    \n    if (arg_8h != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(arg_8h);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(arg_8h);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 137
    },
    "00423716": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00423716(void)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_20ch;\n    uint pvParam;\n    uint var_128h;\n    uint var_4h;\n    \n    fcn.00430f04(0x200);\n    extraout_ECX[1] = NULL;\n    *(unaff_EBP + -0x20c) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CChevronOwnerDrawMenu.0;\n    extraout_ECX[3] = NULL;\n    extraout_ECX[2] = vtable.CFont.0;\n    *(unaff_EBP + -4) = 1;\n    uVar1 = fcn.0041ddc5();\n    iVar2 = (-(uVar1 < 0x60001) & 0xfffffffc) + 0x1f8;\n    *(unaff_EBP + -0x208) = iVar2;\n    (*_sym.imp.USER32.dll_SystemParametersInfoW)(0x29, iVar2, unaff_EBP + -0x208, 0);\n    fcn.00423324(unaff_EBP + -0x128);\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 325
    },
    "00428d52": {
        "rules": [
            "hash data using djb2/6ad21e310d674441ba35d7276afbe57d",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00428d52(uint16_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t extraout_ECX;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = 0;\n    if (arg_8h != NULL) goto code_r0x00428d6f;\n    uVar3 = fcn.00407ad1();\n    uVar2 = extraout_ECX;\n    do {\n        iVar1 = uVar3 * 0x21 + (uVar2 & 0xffff);\n        arg_8h = (uVar3 >> 0x20) + 2;\ncode_r0x00428d6f:\n        uVar3 = CONCAT44(arg_8h, iVar1);\n        uVar2 = *arg_8h;\n    } while (*arg_8h != 0);\n    return iVar1;\n}\n",
        "token_count": 204
    },
    "00401080": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401080(code **param_1)\n\n{\n    int32_t **in_FS_OFFSET;\n    uint in_stack_fffffbe0;\n    int32_t *piStack1044;\n    uint uStack1040;\n    uint uStack1036;\n    uchar auStack1032 [1024];\n    uint32_t uStack8;\n    \n    uStack1040 = 0x4462a8;\n    piStack1044 = *in_FS_OFFSET;\n    uStack8 = *0x45c240 ^ auStack1032;\n    *in_FS_OFFSET = &piStack1044;\n    *param_1 = vtable.CGdiObject.0;\n    uStack1036 = 0;\n    fcn.00409f57();\n    *in_FS_OFFSET = piStack1044;\n    fcn.0042e09f(in_stack_fffffbe0);\n    return;\n}\n",
        "token_count": 195
    },
    "00401890": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00401890(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.00406b74();\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00401000(0x80004005);\n    }\n    iVar2 = (**(*piVar1 + 0xc))();\n    *param_1 = iVar2 + 0x10;\n    return param_1;\n}\n",
        "token_count": 118
    },
    "004018e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004018e0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    \n    if (param_2 == NULL) {\n        fcn.00401000(0x80004005);\n        param_2 = extraout_ECX;\n    }\n    iVar1 = (**(*param_2 + 0xc))();\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 122
    },
    "00401a80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401a80(int32_t *param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t arg_ch;\n    int32_t arg_14h;\n    uint unaff_EBP;\n    uint32_t uVar4;\n    \n    if (param_3 == 0) {\n        fcn.00401a10();\n        return;\n    }\n    if (param_2 == 0) {\n        fcn.00401000(0x80070057);\n    }\n    iVar1 = *param_1;\n    uVar4 = param_2 - iVar1 >> 1;\n    uVar2 = *(iVar1 + -0xc);\n    if ((1U - *(iVar1 + -4) | *(iVar1 + -8) - param_3) < 0) {\n        fcn.00401b30(param_3);\n    }\n    iVar1 = *param_1;\n    arg_ch = *(iVar1 + -8) * 2;\n    arg_14h = param_3 * 2;\n    if (uVar2 < uVar4) {\n        fcn.0042e44a(iVar1, arg_ch, unaff_EBP, arg_14h);\n    }\n    else {\n        fcn.0042e0ae(iVar1, arg_ch, iVar1 + uVar4 * 2, arg_14h);\n    }\n    if ((-1 < param_3) && (param_3 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = param_3;\n        *(arg_14h + *param_1) = 0;\n        return;\n    }\n    fcn.00401000(0x80070057);\n    pcVar3 = swi(3);\n    (*pcVar3)();\n    return;\n}\n",
        "token_count": 431
    },
    "00401c20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401c20(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t arg_ch;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t *unaff_EBP;\n    int32_t **ppiVar6;\n    \n    iVar2 = *param_1;\n    iVar3 = *(iVar2 + -0xc);\n    ppiVar6 = iVar2 + -0x10;\n    puVar4 = (**(**ppiVar6 + 0x10))();\n    iVar5 = (***puVar4)(param_2, 2);\n    if (iVar5 == 0) {\n        fcn.00401c10();\n    }\n    if (iVar3 < param_2) {\n        param_2 = iVar3;\n    }\n    arg_ch = param_2 * 2 + 2;\n    fcn.0042e44a(iVar5 + 0x10, arg_ch, iVar2, arg_ch);\n    *(iVar5 + 4) = iVar3;\n    piVar1 = iVar2 + -4;\n    LOCK();\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    if (iVar2 == 1 || iVar2 + -1 < 0) {\n        (**(**ppiVar6 + 4))(ppiVar6);\n    }\n    *unaff_EBP = iVar5 + 0x10;\n    return;\n}\n",
        "token_count": 347
    },
    "0042e44a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042e44a(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if (arg_14h == 0) {\ncode_r0x0042e45a:\n        uVar1 = 0;\n    }\n    else {\n        if (arg_8h == 0) {\ncode_r0x0042e463:\n            puVar2 = fcn.0043147b();\n            uVar1 = 0x16;\n            *puVar2 = 0x16;\n        }\n        else {\n            if ((arg_10h != 0) && (arg_14h <= arg_ch)) {\n                fcn.00435310(arg_8h, arg_10h, arg_14h);\n                goto code_r0x0042e45a;\n            }\n            fcn.00430820(arg_8h, 0, arg_ch);\n            if (arg_10h == 0) goto code_r0x0042e463;\n            if (arg_14h <= arg_ch) {\n                return 0x16;\n            }\n            puVar2 = fcn.0043147b();\n            uVar1 = 0x22;\n            *puVar2 = 0x22;\n        }\n        fcn.0043399c(0, 0, 0, 0, 0);\n    }\n    return uVar1;\n}\n",
        "token_count": 338
    },
    "00401d00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00401d00(int32_t *param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    if (param_2 == 0) {\n        fcn.00401000(0x80070057);\n    }\n    iVar2 = fcn.0042e162(param_2, param_2);\n    if ((1U - *(*param_1 + -4) | *(*param_1 + -8) - iVar2) < 0) {\n        fcn.00401b30(iVar2);\n    }\n    fcn.0042e301(*param_1, iVar2 + 1, param_2, param_2);\n    if ((-1 < iVar2) && (iVar2 <= *(*param_1 + -8))) {\n        *(*param_1 + -0xc) = iVar2;\n        *(*param_1 + iVar2 * 2) = 0;\n        return;\n    }\n    fcn.00401000(0x80070057);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 254
    },
    "00401e10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00401e10(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    uint16_t *puVar3;\n    uint32_t unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(param_1, param_2);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    puVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    if (puVar2 != NULL) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_SizeofResource)(param_1, param_2);\n        puVar3 = iVar1 + puVar2;\n        for (unaff_EDI = unaff_EDI & 0xf; unaff_EDI != 0; unaff_EDI = unaff_EDI - 1) {\n            if (puVar3 <= puVar2) {\n                return 0;\n            }\n            puVar2 = puVar2 + *puVar2 + 1;\n        }\n        if (puVar2 < puVar3) {\n            return -(*puVar2 != 0) & puVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 278
    },
    "00401e80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401e80(uint param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceW)(param_1, (param_2 >> 4) + 1 & 0xffff, 6);\n    if (iVar1 == 0) {\n        return;\n    }\n    fcn.00401e10(param_1, iVar1, param_2);\n    return;\n}\n",
        "token_count": 107
    },
    "004023c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004023c0(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    int32_t in_EAX;\n    uint unaff_ESI;\n    \n    cVar2 = fcn.00402000();\n    if (cVar2 == '\\0') {\n        fcn.0040797a(0xc, 0, 0xffffffff);\n        return 0;\n    }\n    iVar1 = param_1[0x1f];\n    fcn.00402490();\n    (**(*param_1 + 0xcc))(unaff_ESI, in_EAX - iVar1, param_1 + 0x20);\n    return 1;\n}\n",
        "token_count": 157
    },
    "00402440": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00402440(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *unaff_ESI;\n    int32_t iStack4;\n    \n    iStack4 = (**(*unaff_ESI + 0x60))();\n    do {\n        if (iStack4 == 0) {\n            return 1;\n        }\n        uVar1 = (**(*unaff_ESI + 100))(&iStack4);\n        iVar2 = fcn.004075eb(0x44fc00, uVar1);\n    } while (iVar2 == 0);\n    uVar1 = fcn.00402ef0();\n    return uVar1;\n}\n",
        "token_count": 153
    },
    "00402490": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00402490(uint param_1, uint param_2, uint param_3)\n\n{\n    uint in_EAX;\n    int32_t unaff_ESI;\n    \n    *(unaff_ESI + 0x80) = in_EAX;\n    fcn.0042e85e(unaff_ESI + 0x84, param_1, 0x27);\n    *(unaff_ESI + 0xd2) = 0;\n    fcn.0042e85e(unaff_ESI + 0xd4, param_2, 0xb);\n    *(unaff_ESI + 0xea) = 0;\n    fcn.0042e85e(unaff_ESI + 0xec, param_3, 0x27);\n    *(unaff_ESI + 0x13a) = 0;\n    return;\n}\n",
        "token_count": 194
    },
    "004024f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004024f0(uint *param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    int32_t in_EAX;\n    int32_t iVar3;\n    int16_t *piVar4;\n    \n    *param_1 = *(in_EAX + 0x80);\n    piVar1 = in_EAX + 0x84;\n    if (piVar1 == NULL) {\n        iVar3 = 0;\n    }\n    else {\n        piVar4 = piVar1;\n        do {\n            iVar2 = *piVar4;\n            piVar4 = piVar4 + 1;\n        } while (iVar2 != 0);\n        iVar3 = piVar4 - (in_EAX + 0x86) >> 1;\n    }\n    fcn.00401a80(piVar1, iVar3);\n    piVar1 = in_EAX + 0xd4;\n    if (piVar1 == NULL) {\n        iVar3 = 0;\n    }\n    else {\n        piVar4 = piVar1;\n        do {\n            iVar2 = *piVar4;\n            piVar4 = piVar4 + 1;\n        } while (iVar2 != 0);\n        iVar3 = piVar4 - (in_EAX + 0xd6) >> 1;\n    }\n    fcn.00401a80(piVar1, iVar3);\n    piVar1 = in_EAX + 0xec;\n    if (piVar1 == NULL) {\n        fcn.00401a80(0, 0);\n        return;\n    }\n    piVar4 = piVar1;\n    do {\n        iVar2 = *piVar4;\n        piVar4 = piVar4 + 1;\n    } while (iVar2 != 0);\n    fcn.00401a80(piVar1, piVar4 - (in_EAX + 0xee) >> 1);\n    return;\n}\n",
        "token_count": 429
    },
    "00402680": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00402680(int32_t *param_1)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int16_t *piVar5;\n    int32_t *unaff_EDI;\n    int32_t **in_FS_OFFSET;\n    int16_t *unaff_retaddr;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack4 = 0xffffffff;\n    uStack8 = 0x4463e8;\n    piStack12 = *in_FS_OFFSET;\n    uVar2 = *0x45c240 ^ &stack0xffffffe8;\n    *in_FS_OFFSET = &piStack12;\n    piVar3 = fcn.00406b74(uVar2);\n    if (piVar3 == NULL) {\n        piVar3 = fcn.00401000(0x80004005);\n    }\n    iVar4 = (**(*piVar3 + 0xc))();\n    *param_1 = iVar4 + 0x10;\n    uStack8 = 0;\n    if (unaff_retaddr == NULL) {\n        iVar4 = 0;\n    }\n    else {\n        if ((unaff_retaddr & 0xffff0000) == 0) {\n            iVar4 = fcn.00410c44(unaff_retaddr & 0xffff);\n            if (iVar4 != 0) {\n                fcn.004028e0(iVar4, unaff_retaddr & 0xffff);\n            }\n            goto code_r0x00402728;\n        }\n        piVar5 = unaff_retaddr;\n        do {\n            iVar1 = *piVar5;\n            piVar5 = piVar5 + 1;\n        } while (iVar1 != 0);\n        iVar4 = piVar5 - (unaff_retaddr + 1) >> 1;\n    }\n    fcn.00401a80(unaff_retaddr, iVar4);\ncode_r0x00402728:\n    *in_FS_OFFSET = unaff_EDI;\n    return param_1;\n}\n",
        "token_count": 474
    },
    "004027e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004027e0(uint param_1, int16_t *param_2)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    if (param_2 == NULL) {\n        fcn.00401a80(0, 0);\n        return param_1;\n    }\n    piVar2 = param_2;\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    fcn.00401a80(param_2, piVar2 - (param_2 + 1) >> 1);\n    return param_1;\n}\n",
        "token_count": 153
    },
    "004029f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004029f0(int16_t *param_1)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    if (param_1 == NULL) {\n        fcn.00401a80(0, 0);\n        return;\n    }\n    piVar2 = param_1;\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    fcn.00401a80(param_1, piVar2 - (param_1 + 1) >> 1);\n    return;\n}\n",
        "token_count": 139
    },
    "00402a30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint16_t * fcn.00402a30(int16_t *param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    \n    if (param_1 == NULL) {\n        return param_1;\n    }\n    piVar1 = param_1 + 1;\n    do {\n        iVar2 = *param_1;\n        param_1 = param_1 + 1;\n    } while (iVar2 != 0);\n    return param_1 - piVar1 >> 1;\n}\n",
        "token_count": 116
    },
    "004034a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.004034a0(uint16_t **param_1, uint16_t **param_2)\n\n{\n    uint16_t uVar1;\n    uint16_t *puVar2;\n    uint32_t uVar3;\n    uint16_t *extraout_ECX;\n    uint16_t *puVar4;\n    bool bVar5;\n    \n    puVar4 = *param_2;\n    if (puVar4 == NULL) {\n        fcn.00401000(0x80004005);\n        puVar4 = extraout_ECX;\n    }\n    puVar2 = *param_1;\n    while( true ) {\n        uVar1 = *puVar2;\n        bVar5 = uVar1 < *puVar4;\n        if (uVar1 != *puVar4) break;\n        if (uVar1 == 0) {\n            return 1;\n        }\n        uVar1 = puVar2[1];\n        bVar5 = uVar1 < puVar4[1];\n        if (uVar1 != puVar4[1]) break;\n        puVar2 = puVar2 + 2;\n        puVar4 = puVar4 + 2;\n        if (uVar1 == 0) {\n            return 1;\n        }\n    }\n    uVar3 = (1 - bVar5) - (bVar5 != 0);\n    return uVar3 & 0xffffff00 | uVar3 == 0;\n}\n",
        "token_count": 322
    },
    "00403500": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00403500(uint16_t **param_1, uint16_t *param_2)\n\n{\n    uint16_t uVar1;\n    uint16_t *puVar2;\n    uint16_t **extraout_ECX;\n    uint16_t *extraout_EDX;\n    bool bVar3;\n    \n    if (param_2 == NULL) {\n        fcn.00401000(0x80004005);\n        param_1 = extraout_ECX;\n        param_2 = extraout_EDX;\n    }\n    puVar2 = *param_1;\n    while( true ) {\n        uVar1 = *puVar2;\n        bVar3 = uVar1 < *param_2;\n        if (uVar1 != *param_2) break;\n        if (uVar1 == 0) {\n            return 0;\n        }\n        uVar1 = puVar2[1];\n        bVar3 = uVar1 < param_2[1];\n        if (uVar1 != param_2[1]) break;\n        puVar2 = puVar2 + 2;\n        param_2 = param_2 + 2;\n        if (uVar1 == 0) {\n            return 0;\n        }\n    }\n    return (1 - bVar3) - (bVar3 != 0);\n}\n",
        "token_count": 296
    },
    "00403640": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403640(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t in_FS_OFFSET;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = *(*(*(in_FS_OFFSET + 0x18) + 0x30) + 0xc) + 0x1c;\n    piVar4 = piVar1;\n    while( true ) {\n        ppiVar2 = *piVar4;\n        if ((ppiVar2[8] != NULL) && (iVar3 = fcn.0042ecde(ppiVar2[8], L\"kernel32.dll\"),  iVar3 == 0)) break;\n        piVar4 = *ppiVar2;\n        if (piVar4 == piVar1) {\n            return 0;\n        }\n    }\n    return ppiVar2[2];\n}\n",
        "token_count": 225
    },
    "00403d30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00403d30(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    int32_t **in_FS_OFFSET;\n    uint arg_8h;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint uStack616;\n    int32_t iStack612;\n    uint uStack608;\n    uint uStack604;\n    uint uStack600;\n    uint uStack596;\n    int32_t *piStack44;\n    uint uStack36;\n    uint32_t uStack28;\n    int32_t *piStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0xffffffff;\n    uStack16 = 0x446211;\n    piStack20 = *in_FS_OFFSET;\n    uStack28 = *0x45c240 ^ &uStack616;\n    uVar1 = *0x45c240 ^ &stack0xfffffd90;\n    *in_FS_OFFSET = &piStack20;\n    piVar2 = fcn.00406b74(uVar1);\n    if (piVar2 == NULL) {\n        piVar2 = fcn.00401000(0x80004005);\n    }\n    (**(*piVar2 + 0xc))();\n    piVar2 = 0x1;\n    arg_8h = 8;\n    uStack16 = 0;\n    iVar3 = fcn.00418114(&stack0xfffffd94, 8, 0x2004, 1, 0);\n    if (iVar3 == 0) {\n        uStack36 = 0xffffffff;\n        piVar4 = piVar2 + -1;\n        LOCK();\n        iVar3 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        piVar4 = piVar2;\n        goto code_r0x00403efc;\n    }\n    fcn.00419589();\n    uStack36._0_1_ = 1;\n    uStack616 = 0;\n    iStack612 = 0;\n    uStack608 = 0;\n    uStack604 = 0;\n    uStack600 = 0;\n    uStack596 = 0;\n    piVar4 = piVar2;\n    iVar3 = fcn.0041a225(piVar2, &uStack616);\n    if (iVar3 == 0) {\n        iVar3 = fcn.00419aae(arg_8h, 0x1000, 0);\n        if (iVar3 != 0) {\n            fcn.00419523();\n            goto code_r0x00403ebc;\n        }\n        piVar2 = fcn.00406b74();\n        if (piVar2 == NULL) {\n            piVar2 = fcn.00401000(0x80004005);\n        }\n        iStack612 = (**(*piVar2 + 0xc))();\n        iStack612 = iStack612 + 0x10;\n        uStack12 = CONCAT31(uStack12._1_3_, 2);\n        iVar5 = 10;\n        piVar4 = &iStack612;\n        fcn.0041baa6(piVar4, 10, uStack616);\n        fcn.0040792c(unaff_ESI, 0, 0);\n        uStack36._0_1_ = 1;\n        piVar2 = iVar5 + -4;\n        LOCK();\n        iVar3 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        if (iVar3 == 1 || iVar3 + -1 < 0) {\n            (**(**(iVar5 + -0x10) + 4))(iVar5 + -0x10);\n        }\n    }\n    else {\ncode_r0x00403ebc:\n        (**(*param_1 + 0x88))(piVar2);\n    }\n    uStack36 = uStack36._1_3_ << 8;\n    fcn.00419719();\n    uStack36 = 0xffffffff;\n    piVar2 = piVar4 + -1;\n    LOCK();\n    iVar3 = *piVar2;\n    *piVar2 = *piVar2 + -1;\ncode_r0x00403efc:\n    if (iVar3 == 1 || iVar3 + -1 < 0) {\n        (**(*piVar4[-4] + 4))(piVar4 + -4);\n    }\n    *in_FS_OFFSET = piStack44;\n    fcn.0042e09f(piVar4);\n    return;\n}\n",
        "token_count": 1036
    },
    "004040a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004040a0(int32_t param_1, int32_t param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    int32_t *arg_8h;\n    int32_t *piVar1;\n    uint32_t arg_14h;\n    \n    if (*(param_2 + 0x14) < param_3) {\n        fcn.00443d61();\n    }\n    arg_14h = *(param_2 + 0x14) - param_3;\n    if (param_4 < arg_14h) {\n        arg_14h = param_4;\n    }\n    if (param_1 != param_2) {\n        if (arg_14h == 0xffffffff) {\n            fcn.00443d29();\n        }\n        if (*(param_1 + 0x18) < arg_14h) {\n            fcn.00404360(arg_14h, *(param_1 + 0x14));\n        }\n        else if (arg_14h == 0) {\n            *(param_1 + 0x14) = 0;\n            if (*(param_1 + 0x18) < 0x10) {\n                *(param_1 + 4) = 0;\n                return param_1;\n            }\n            **(param_1 + 4) = 0;\n            return param_1;\n        }\n        if (arg_14h != 0) {\n            if (*(param_2 + 0x18) < 0x10) {\n                param_2 = param_2 + 4;\n            }\n            else {\n                param_2 = *(param_2 + 4);\n            }\n            piVar1 = param_1 + 4;\n            arg_8h = piVar1;\n            if (0xf < *(param_1 + 0x18)) {\n                arg_8h = *piVar1;\n            }\n            fcn.0042e44a(arg_8h, *(param_1 + 0x18), param_2 + param_3, arg_14h);\n            *(param_1 + 0x14) = arg_14h;\n            if (0xf < *(param_1 + 0x18)) {\n                piVar1 = *piVar1;\n            }\n            *(piVar1 + arg_14h) = 0;\n        }\n        return param_1;\n    }\n    fcn.004042b0(arg_14h + param_3, 0xffffffff);\n    fcn.004042b0(0, param_3);\n    return param_1;\n}\n",
        "token_count": 582
    },
    "004041d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004041d0(int32_t param_1, uint *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *arg_8h;\n    uint *puVar4;\n    int32_t *piVar5;\n    \n    if (param_2 != NULL) {\n        uVar1 = *(param_1 + 0x18);\n        puVar2 = param_1 + 4;\n        puVar4 = puVar2;\n        if (0xf < uVar1) {\n            puVar4 = *puVar2;\n        }\n        if (puVar4 <= param_2) {\n            puVar4 = puVar2;\n            if (0xf < uVar1) {\n                puVar4 = *puVar2;\n            }\n            if (param_2 < *(param_1 + 0x14) + puVar4) {\n                if (0xf < uVar1) {\n                    puVar2 = *puVar2;\n                }\n                iVar3 = fcn.004040a0(param_1, param_2 - puVar2, param_3);\n                return iVar3;\n            }\n        }\n    }\n    if (param_3 == 0xffffffff) {\n        fcn.00443d29();\n    }\n    if (*(param_1 + 0x18) < param_3) {\n        fcn.00404360(param_3, *(param_1 + 0x14));\n    }\n    else if (param_3 == 0) {\n        *(param_1 + 0x14) = 0;\n        if (*(param_1 + 0x18) < 0x10) {\n            *(param_1 + 4) = 0;\n            return param_1;\n        }\n        **(param_1 + 4) = 0;\n        return param_1;\n    }\n    if (param_3 != 0) {\n        piVar5 = param_1 + 4;\n        arg_8h = piVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            arg_8h = *piVar5;\n        }\n        fcn.0042e44a(arg_8h, *(param_1 + 0x18), param_2, param_3);\n        *(param_1 + 0x14) = param_3;\n        if (0xf < *(param_1 + 0x18)) {\n            piVar5 = *piVar5;\n        }\n        *(piVar5 + param_3) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 597
    },
    "004042b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004042b0(int32_t param_1, uint *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint *puVar5;\n    \n    uVar1 = param_2;\n    if (*(param_1 + 0x14) < param_2) {\n        fcn.00443d61();\n    }\n    uVar2 = *(param_1 + 0x14) - param_2;\n    if (uVar2 < param_3) {\n        param_3 = uVar2;\n    }\n    if (param_3 != 0) {\n        puVar5 = param_1 + 4;\n        puVar4 = puVar5;\n        param_2 = puVar5;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar4 = *puVar5;\n            param_2 = *puVar5;\n        }\n        fcn.0042e0ae(puVar4 + uVar1, *(param_1 + 0x18) - uVar1, param_2 + param_3 + uVar1, uVar2 - param_3);\n        iVar3 = *(param_1 + 0x14) - param_3;\n        *(param_1 + 0x14) = iVar3;\n        if (0xf < *(param_1 + 0x18)) {\n            puVar5 = *puVar5;\n        }\n        *(iVar3 + puVar5) = 0;\n    }\n    return param_1;\n}\n",
        "token_count": 372
    },
    "00404560": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00404560(uint *param_1, uint param_2)\n\n{\n    uint16_t *puVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint16_t *puVar4;\n    uint16_t *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint16_t unaff_SI;\n    uint16_t *puVar8;\n    int32_t *arg_8h;\n    uint *apuStack52 [2];\n    int32_t aiStack44 [10];\n    uint32_t uStack4;\n    \n    uStack4 = *0x45c240 ^ apuStack52;\n    arg_8h = aiStack44;\n    apuStack52[0] = param_1;\n    (*_sym.imp.USER32.dll_GetWindowTextW)(param_2, arg_8h, 0x13);\n    puVar5 = &stack0xffffffc8;\n    if (unaff_SI == 0x20) {\n        uVar3 = 0x20;\n        do {\n            if (uVar3 == 0) {\n                *param_1 = 0;\n                fcn.0042e09f(arg_8h);\n                return;\n            }\n            uVar3 = puVar5[1];\n            puVar5 = puVar5 + 1;\n        } while (uVar3 == 0x20);\n    }\n    uVar3 = *puVar5;\n    puVar8 = puVar5;\n    while (((uVar3 != 0x2e && (uVar3 = *puVar8,  uVar3 != 0x20)) && (uVar3 != 0))) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            fcn.0042e09f(arg_8h);\n            return;\n        }\n        puVar8 = puVar8 + 1;\n        uVar3 = *puVar8;\n    }\n    uVar3 = *puVar8;\n    *puVar8 = 0;\n    puVar4 = puVar5;\n    do {\n        uVar2 = *puVar4;\n        puVar4 = puVar4 + 1;\n    } while (uVar2 != 0);\n    if (8 < puVar4 - (puVar5 + 1) >> 1) {\n        fcn.0042e09f(arg_8h);\n        return;\n    }\n    puVar4 = puVar5;\n    do {\n        uVar2 = *puVar4;\n        puVar4 = puVar4 + 1;\n    } while (uVar2 != 0);\n    if (puVar4 - (puVar5 + 1) >> 1 == 0) {\n        uVar7 = 0;\n    }\n    else {\n        uVar7 = fcn.0042f0cd(puVar5);\n        if (0x28f5c28 < uVar7) goto code_r0x004046f5;\n    }\n    if (uVar3 != 0) {\n        puVar4 = puVar8 + 1;\n        uVar3 = puVar8[1];\n        puVar5 = puVar4;\n        while (uVar3 != 0) {\n            if (uVar3 == 0x20) goto code_r0x004046b4;\n            if ((uVar3 < 0x30) || (0x39 < uVar3)) goto code_r0x004046f5;\n            puVar1 = puVar5 + 1;\n            puVar5 = puVar5 + 1;\n            uVar3 = *puVar1;\n        }\n        if (*puVar5 == 0x20) {\ncode_r0x004046b4:\n            uVar3 = puVar5[1];\n            while (uVar3 != 0) {\n                if (uVar3 != 0x20) goto code_r0x004046f5;\n                uVar3 = puVar5[2];\n                puVar5 = puVar5 + 1;\n            }\n        }\n        puVar5 = puVar4;\n        do {\n            uVar3 = *puVar5;\n            puVar5 = puVar5 + 1;\n        } while (uVar3 != 0);\n        iVar6 = puVar5 - (puVar8 + 2) >> 1;\n        if (iVar6 != 0) {\n            if (iVar6 == 1) {\n                iVar6 = fcn.0042f0e3(puVar4);\n                iVar6 = iVar6 * 10;\n            }\n            else {\n                if (iVar6 != 2) {\ncode_r0x004046f5:\n                    fcn.0042e09f(arg_8h);\n                    return;\n                }\n                iVar6 = fcn.0042f0e3(puVar4);\n            }\n            goto code_r0x00404727;\n        }\n    }\n    iVar6 = 0;\ncode_r0x00404727:\n    *arg_8h = uVar7 * 100 + iVar6;\n    fcn.0042e09f(arg_8h);\n    return;\n}\n",
        "token_count": 1154
    },
    "004052f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.004052f0(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401b80(*param_2 + -0x10);\n    *param_1 = iVar1 + 0x10;\n    return param_1;\n}\n",
        "token_count": 82
    },
    "00405370": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00405370(int32_t *param_1, int16_t *param_2, int16_t *param_3)\n\n{\n    int16_t *piVar1;\n    int32_t iVar2;\n    int16_t iVar3;\n    uint32_t uVar4;\n    bool bVar5;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    int32_t iVar6;\n    int32_t *unaff_EBX;\n    uint32_t arg_10h;\n    uint32_t unaff_retaddr;\n    \n    iVar6 = *param_1;\n    uVar4 = *(iVar6 + -0xc);\n    arg_10h = param_2 - iVar6 >> 1;\n    if (param_3 < 0) {\n        param_2 = fcn.00401000(0x80070057);\n        iVar6 = extraout_ECX;\n    }\n    if (param_2 != NULL) {\n        piVar1 = param_2 + 1;\n        do {\n            iVar3 = *param_2;\n            param_2 = param_2 + 1;\n        } while (iVar3 != 0);\n        param_2 = param_2 - piVar1 >> 1;\n    }\n    if (param_2 < param_3) {\n        param_3 = param_2;\n    }\n    if (uVar4 <= 0x7fffffff - param_3) goto code_r0x004053cb;\n    do {\n        do {\n            fcn.00401000();\n            iVar6 = extraout_ECX_00;\ncode_r0x004053cb:\n            iVar2 = param_3 + uVar4;\n            if ((1U - *(iVar6 + -4) | *(iVar6 + -8) - iVar2) < 0) {\n                fcn.00401b30(iVar2);\n            }\n            bVar5 = uVar4 < arg_10h;\n            arg_10h = *unaff_EBX + arg_10h * 2;\n            if (bVar5) {\n                arg_10h = unaff_retaddr;\n            }\n            fcn.0042e44a(*unaff_EBX + uVar4 * 2, param_3 * 2, arg_10h, param_3 * 2);\n        } while (iVar2 < 0);\n    } while (*(*unaff_EBX + -8) < iVar2);\n    *(*unaff_EBX + -0xc) = iVar2;\n    *(*unaff_EBX + iVar2 * 2) = 0;\n    return;\n}\n",
        "token_count": 578
    },
    "00405500": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405500(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack8 = 0x446048;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x45c240 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = vtable.CFixedLenRecDoc.0;\n    uStack4 = 0;\n    fcn.00419719(uVar1);\n    uStack4 = 0xffffffff;\n    fcn.0041118d();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 173
    },
    "004058d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004058d0(code **param_1)\n\n{\n    uint32_t uVar1;\n    int32_t **in_FS_OFFSET;\n    int32_t *piStack12;\n    uint uStack8;\n    uint32_t uStack4;\n    \n    uStack8 = 0x446176;\n    piStack12 = *in_FS_OFFSET;\n    uVar1 = *0x45c240 ^ &stack0xffffffec;\n    *in_FS_OFFSET = &piStack12;\n    *param_1 = vtable.CMainFrame.0;\n    uStack4 = 1;\n    fcn.0041cb79(uVar1);\n    uStack4 = uStack4 & 0xffffff00;\n    fcn.0041c617();\n    uStack4 = 0xffffffff;\n    fcn.00416422();\n    *in_FS_OFFSET = piStack12;\n    return;\n}\n",
        "token_count": 196
    },
    "00406455": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00406455(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0042f196(arg_8h, arg_ch, 0x10);\n    return iVar1 == 0;\n}\n",
        "token_count": 62
    },
    "00406471": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.00406471(int32_t arg_8h, uint *arg_ch, uint noname_2, code *arg_14h, uint *arg_18h, int32_t arg_1ch, \n            int32_t *arg_20h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    uint unaff_EBX;\n    uint uVar3;\n    uint *unaff_ESI;\n    uint *puVar4;\n    \n    uVar3 = unaff_EBX;\n    puVar4 = unaff_ESI;\n    if (arg_8h != 0) goto code_r0x00406482;\ncode_r0x0040647d:\n    fcn.00407ad1();\n    arg_8h = extraout_ECX;\n    uVar3 = unaff_EBX;\n    puVar4 = unaff_ESI;\ncode_r0x00406482:\n    unaff_EBX = 1;\n    if (arg_20h != NULL) {\n        *arg_20h = arg_8h;\n        arg_20h[1] = arg_14h;\n        return 1;\n    }\n    if (0xb < arg_1ch - 0x39U) {\n        return 0;\n    }\n    // switch table (12 cases) at 0x406579\n    unaff_ESI = puVar4;\n    switch(*((arg_1ch - 0x39U) * 4 + 0x406579)) {\n    case 0x4064b3:\n        (*arg_14h)();\n        return 1;\n    case 0x4064bb:\n        uVar2 = (*arg_14h)();\n        return uVar2;\n    case 0x4064c3:\n        arg_18h = arg_ch;\n        break;\n    case 0x4064ce:\n        arg_18h = arg_ch;\n        goto code_r0x00406567;\n    case 0x4064d6:\n        if (arg_18h != NULL) {\n            (*arg_14h)(arg_18h[1], *arg_18h);\n            return 1;\n        }\n        goto code_r0x0040647d;\n    case 0x4064ea:\n        if (arg_18h != NULL) {\n            uVar2 = (*arg_14h)(arg_18h[1], *arg_18h);\n            return uVar2;\n        }\n        goto code_r0x0040647d;\n    case 0x4064fb:\n        if (arg_18h != NULL) {\n            (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n            return 1;\n        }\n        goto code_r0x0040647d;\n    case 0x406513:\n        if (arg_18h != NULL) {\n            uVar2 = (*arg_14h)(arg_ch, arg_18h[1], *arg_18h);\n            return uVar2;\n        }\n        goto code_r0x0040647d;\n    case 0x40652b:\n        unaff_ESI = arg_18h;\n        if (arg_18h != NULL) {\n            (*arg_14h)(arg_18h);\n            goto code_r0x0040653a;\n        }\n        goto code_r0x0040647d;\n    case 0x406548:\n        goto code_r0x00406548;\n    case 0x40655c:\n        break;\n    case 0x406564:\ncode_r0x00406567:\n        uVar2 = (*arg_14h)(arg_18h);\n        return uVar2;\n    }\n    (*arg_14h)(arg_18h);\n    return 1;\ncode_r0x00406548:\n    unaff_ESI = arg_18h;\n    if (arg_18h != NULL) {\n        (*arg_14h)(arg_18h, arg_ch, puVar4, uVar3);\ncode_r0x0040653a:\n        iVar1 = arg_18h[7];\n        arg_18h[7] = 0;\n        return iVar1 == 0;\n    }\n    goto code_r0x0040647d;\n}\n",
        "token_count": 951
    },
    "00406c7a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406c7a(int32_t arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    \n    ppiVar1 = *in_ECX + -0x10;\n    if ((*(*in_ECX + -8) < arg_8h) && (0 < arg_8h)) {\n        iVar2 = (**(**ppiVar1 + 8))(ppiVar1, arg_8h, 1);\n        if (iVar2 != 0) goto code_r0x00406ca9;\n    }\n    iVar2 = fcn.00406c6f();\ncode_r0x00406ca9:\n    *in_ECX = iVar2 + 0x10;\n    return;\n}\n",
        "token_count": 176
    },
    "00406cb3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406cb3(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.00406c00(&var_4h, arg_8h, arg_ch);\n    if (iVar1 < 0) {\n        fcn.00401000(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 93
    },
    "00406d27": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406d27(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = *param_1;\n    piVar1 = *(iVar2 + -0x10);\n    if (*(iVar2 + -0xc) != 0) {\n        if (*(iVar2 + -4) < 0) {\n            fcn.00406c24(0);\n        }\n        else {\n            fcn.00401020();\n            iVar2 = (**(*piVar1 + 0xc))();\n            *param_1 = iVar2 + 0x10;\n        }\n    }\n    return;\n}\n",
        "token_count": 150
    },
    "00406dc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406dc0(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *extraout_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.00401000(0x80004005);\n        arg_8h = extraout_ECX;\n    }\n    iVar1 = (**(*arg_8h + 0xc))();\n    *in_ECX = iVar1 + 0x10;\n    return;\n}\n",
        "token_count": 120
    },
    "00406dea": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406dea(int32_t arg_8h)\n\n{\n    int32_t arg_10h;\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_10h = *in_ECX;\n    iVar1 = *(arg_10h + -0xc);\n    puVar2 = (**(**(arg_10h + -0x10) + 0x10))();\n    iVar3 = (***puVar2)(arg_8h, 1);\n    if (iVar3 == 0) {\n        fcn.00406c6f();\n    }\n    if (iVar1 < arg_8h) {\n        arg_8h = iVar1;\n    }\n    fcn.0042e44a(iVar3 + 0x10, arg_8h + 1, arg_10h, arg_8h + 1);\n    *(iVar3 + 4) = iVar1;\n    fcn.00401020();\n    *in_ECX = iVar3 + 0x10;\n    return;\n}\n",
        "token_count": 263
    },
    "00407020": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407020(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    \n    iVar1 = fcn.00420e14();\n    in_ECX[1] = iVar1;\n    in_ECX[2] = *(iVar1 + 0x148);\n    *in_ECX = *(iVar1 + 0x144);\n    *(iVar1 + 0x144) = arg_8h;\n    *(in_ECX[1] + 0x148) = in_ECX;\n    return;\n}\n",
        "token_count": 126
    },
    "0040792c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040792c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004213cc();\n    if (*(iVar1 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x00407942. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(iVar1 + 4) + 0x98))();\n        return;\n    }\n    fcn.004077c7(0, arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 143
    },
    "00407b1c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00407b1c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.004312b8(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00401d80(uVar1);\n    return;\n}\n",
        "token_count": 88
    },
    "00408151": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00408151(code **param_1)\n\n{\n    fcn.00406eda();\n    *param_1 = vtable.CScrollView.0;\n    fcn.00430820(param_1 + 0x16, 0, 0x30);\n    param_1[0x16] = NULL;\n    param_1[0x17] = NULL;\n    return param_1;\n}\n",
        "token_count": 94
    },
    "004082aa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004082aa(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    uVar1 = fcn.004109b6();\n    fcn.00407c9e(arg_ch);\n    if ((*arg_ch != 0) && ((uVar1 & 0x200000) != 0)) {\n        *arg_8h = *arg_8h + *arg_ch;\n    }\n    if ((arg_ch[1] != 0) && ((uVar1 & 0x100000) != 0)) {\n        arg_8h[1] = arg_8h[1] + arg_ch[1];\n    }\n    if ((*arg_ch < *arg_8h) && (arg_ch[1] < arg_8h[1])) {\n        uVar2 = 1;\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 305
    },
    "00408327": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00408327(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h, int32_t *arg_14h, int32_t *arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    fcn.00407c9e(&var_8h);\n    iVar1 = *(in_ECX + 0x6c);\n    *arg_14h = *(in_ECX + 0x68) - arg_8h;\n    arg_14h[1] = iVar1 - arg_ch;\n    piVar2 = fcn.0040819f(&var_10h);\n    *arg_18h = *piVar2;\n    arg_18h[1] = piVar2[1];\n    uVar3 = 0 < *arg_14h;\n    if (uVar3 == 0) {\n        *arg_18h = 0;\n    }\n    else if (arg_1ch != 0) {\n        arg_14h[1] = arg_14h[1] + var_4h;\n    }\n    uVar4 = 0 < arg_14h[1];\n    if (uVar4 == 0) {\n        arg_18h[1] = 0;\n    }\n    else {\n        if (arg_1ch != 0) {\n            *arg_14h = *arg_14h + var_8h;\n        }\n        if (uVar3 == 0) {\n            if (*arg_14h < 1) goto code_r0x004083c4;\n            uVar3 = 1;\n            arg_14h[1] = arg_14h[1] + var_4h;\n        }\n    }\n    iVar1 = *arg_14h;\n    if ((0 < iVar1) && (iVar1 <= *arg_18h)) {\n        *arg_18h = iVar1;\n    }\ncode_r0x004083c4:\n    iVar1 = arg_14h[1];\n    if ((0 < iVar1) && (iVar1 <= arg_18h[1])) {\n        arg_18h[1] = iVar1;\n    }\n    *arg_10h = uVar3;\n    arg_10h[1] = uVar4;\n    return;\n}\n",
        "token_count": 579
    },
    "00408f79": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408f79(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0042e44a(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00401d80(uVar1);\n    return;\n}\n",
        "token_count": 88
    },
    "0040974d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040974d(uint arg_8h, uint arg_ch)\n\n{\n    uint *puVar1;\n    \n    puVar1 = fcn.00422f50(arg_8h);\n    *puVar1 = arg_ch;\n    return;\n}\n",
        "token_count": 60
    },
    "0040a902": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040a902(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.0040a73a();\n    if (iVar2 == 0) {\n        if (((arg_8h == 0x12340042) && (arg_ch != NULL)) &&\n           ((0x27 < *arg_ch && (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)\n            ))) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar3;\n            uVar3 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            iVar2 = 1;\n            arg_ch[4] = uVar3;\n            arg_ch[9] = 1;\n            if (0x67 < *arg_ch) {\n                (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, \"DISPLAY\", 0xffffffff, arg_ch + 10, 0x20);\n            }\n        }\n        else {\n            iVar2 = 0;\n        }\n    }\n    else {\n        iVar2 = (**0x45f3b0)(arg_8h, arg_ch);\n        if (((iVar2 != 0) && (*0x45f3c0 == 0)) && (0x67 < *arg_ch)) {\n            (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, arg_ch + 10, 0xffffffff, arg_ch + 10, 0x20);\n        }\n    }\n    return iVar2;\n}\n",
        "token_count": 504
    },
    "0040b31f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.0040b31f(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *extraout_ECX;\n    \n    piVar1 = *arg_8h;\n    if (piVar1 == NULL) {\n        piVar1 = fcn.00407ad1();\n        arg_8h = extraout_ECX;\n    }\n    *arg_8h = *piVar1;\n    return piVar1 + 2;\n}\n",
        "token_count": 114
    },
    "0040cc9c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040cc9c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.00430ece(0x24);\n    *(unaff_EBP + -0x2c) = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x28) = extraout_ECX;\n    *(unaff_EBP + -0x24) = 0;\n    iVar1 = fcn.00420e14();\n    *(unaff_EBP + -0x18) = iVar1;\n    *(unaff_EBP + -0x14) = *(iVar1 + 0x13c);\n    *(iVar1 + 0x13c) = extraout_ECX[8];\n    iVar1 = *extraout_ECX;\n    *(unaff_EBP + 8) = 0;\n    *(unaff_EBP + -4) = 0;\n    (**(iVar1 + 0xfc))(unaff_EBP + -0x2c);\n    *(unaff_EBP + 8) = 1;\n    *(*(unaff_EBP + -0x18) + 0x13c) = *(unaff_EBP + -0x14);\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 361
    },
    "0040cd27": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040cd27(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t lpPoints;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.004109b6();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x20), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        }\n        if (iVar5 != 0) {\n            iVar4 = (*_sym.imp.USER32.dll_SendMessageW)(iVar5, 0x36b, 0, 0);\n            if (iVar4 != 0) {\n                iVar5 = iVar4;\n            }\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x20);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x20), &var_38h);\n    if ((var_4h & 0x40000000) == 0) {\n        if (iVar5 != 0) {\n            uVar2 = (*_sym.imp.USER32.dll_GetWindowLongW)(iVar5, 0xfffffff0);\n            if (((uVar2 & 0x10000000) == 0) || ((uVar2 & 0x20000000) != 0)) {\n                iVar5 = 0;\n            }\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.0040700d();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x20);\n            }\n            uVar3 = fcn.0040a895(iVar5, 1);\n            fcn.0040a902(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.0040a895(iVar5, 2);\n            fcn.0040a902(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x20));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_20h) / 2 - (var_30h - var_38h) / 2;\n    iVar4 = (var_24h + var_1ch) / 2 - (var_2ch - var_34h) / 2;\n    if (var_10h < (var_30h - var_38h) + iVar5) {\n        iVar5 = (var_38h - var_30h) + var_10h;\n    }\n    if (iVar5 < lprcDst) {\n        iVar5 = lprcDst;\n    }\n    if (var_ch < (var_2ch - var_34h) + iVar4) {\n        iVar4 = (var_34h - var_2ch) + var_ch;\n    }\n    if (iVar4 < var_14h) {\n        iVar4 = var_14h;\n    }\n    fcn.00410b5a(0, iVar5, iVar4, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1085
    },
    "0040d489": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0040d489(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    uint uVar3;\n    \n    uVar3 = 0;\n    iVar1 = fcn.0040d3e9(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = iVar1 + 0x1c;\n    if (iVar1 == 0) {\n        fcn.00407ad1(uVar3);\n        iVar1 = extraout_ECX;\n    }\n    if (*(iVar1 + 4) != 0) {\n        for (puVar2 = *(*(iVar1 + 4) + ((unaff_retaddr >> 4) % *(iVar1 + 8)) * 4); puVar2 != NULL; puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 241
    },
    "004102c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004102c6(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t *piVar4;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00420e14();\n    iVar1 = iVar1 + 0x7c;\n    iVar2 = fcn.004213cc();\n    var_1ch = *(iVar2 + 8);\n    if (((arg_ch == 0) && (arg_10h == 0)) && (arg_14h == 0)) {\n        puVar3 = fcn.0043147b();\n        var_4h = *puVar3;\n        puVar3 = fcn.0043147b();\n        *puVar3 = 0;\n        fcn.00431418(iVar1, 0x60, 0x5f, L\"Afx:%p:%x\", var_1ch);\n    }\n    else {\n        puVar3 = fcn.0043147b();\n        var_4h = *puVar3;\n        puVar3 = fcn.0043147b();\n        *puVar3 = 0;\n        fcn.00431418(iVar1, 0x60, 0x5f, L\"Afx:%p:%x:%p:%p:%p\", var_1ch);\n    }\n    piVar4 = fcn.0043147b();\n    if (*piVar4 == 0) {\n        puVar3 = fcn.0043147b();\n        *puVar3 = var_4h;\n    }\n    else {\n        puVar3 = fcn.0043147b();\n        fcn.0040904e(*puVar3);\n    }\n    iVar2 = fcn.0040b8f8(var_1ch, iVar1, &var_2ch);\n    if (iVar2 == 0) {\n        var_2ch = arg_8h;\n        var_28h = _sym.imp.USER32.dll_DefWindowProcW;\n        var_18h = arg_14h;\n        var_14h = arg_ch;\n        var_10h = arg_10h;\n        var_20h = 0;\n        var_24h = 0;\n        var_ch = 0;\n        var_8h = iVar1;\n        iVar2 = fcn.00410239(&var_2ch);\n        if (iVar2 == 0) {\n            fcn.004096be();\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 665
    },
    "00410bdc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint16_t * __cdecl fcn.00410bdc(uint arg_8h, ushort *arg_ch, int32_t arg_10h)\n\n{\n    uint16_t *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint16_t *puVar4;\n    uint16_t *puVar5;\n    \n    if ((arg_ch != NULL) && (arg_10h != 0)) {\n        iVar3 = fcn.004213cc();\n        puVar4 = fcn.00401e80(*(iVar3 + 0xc), arg_8h);\n        if (puVar4 == NULL) {\n            *arg_ch = 0;\n            puVar5 = puVar4;\n        }\n        else {\n            puVar1 = arg_10h - 1;\n            puVar5 = *puVar4;\n            if (puVar1 < *puVar4) {\n                puVar5 = puVar1;\n            }\n            fcn.00408f79(arg_ch, puVar1 * 2, puVar4 + 1, puVar5 * 2);\n            arg_ch[puVar5] = 0;\n        }\n        return puVar5;\n    }\n    fcn.00407ad1();\n    pcVar2 = swi(3);\n    puVar4 = (*pcVar2)();\n    return puVar4;\n}\n",
        "token_count": 300
    },
    "00410e58": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00410e58(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    if (0x7fffffff - arg_ch < arg_10h) {\n        return 0x80070057;\n    }\n    *arg_8h = arg_ch + arg_10h;\n    return 0;\n}\n",
        "token_count": 84
    },
    "00411096": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00411096(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.00410e58(&var_4h, arg_8h, arg_ch);\n    if (iVar1 < 0) {\n        fcn.00401000(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 92
    },
    "00412b2d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412b2d(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.004316e2(arg_8h, arg_ch, arg_10h);\n    fcn.00401d80(uVar1);\n    return;\n}\n",
        "token_count": 77
    },
    "00412bb3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00412bb3(uint param_1)\n\n{\n    fcn.00430820(param_1, 0, 0x14);\n    return param_1;\n}\n",
        "token_count": 43
    },
    "00412bc9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00412bc9(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    \n    iVar1 = fcn.00420e14();\n    in_ECX[1] = iVar1;\n    in_ECX[2] = *(iVar1 + 0x150);\n    *in_ECX = *(iVar1 + 0x14c);\n    *(iVar1 + 0x14c) = arg_8h;\n    *(in_ECX[1] + 0x150) = in_ECX;\n    return;\n}\n",
        "token_count": 129
    },
    "00413764": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00413764(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.004052f0(in_ECX + 0xc4, 0);\n    return arg_8h;\n}\n",
        "token_count": 77
    },
    "00414286": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00414286(uint noname_0, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_ch == 0) {\n        iVar1 = fcn.0040b7f2();\n        if (iVar1 == 0) {\n            arg_ch = *(in_ECX + 0xa4) + 0x20000;\n        }\n        else {\n            arg_ch = *(in_ECX + 0xa8) + 0x10000;\n        }\n        if (arg_ch == 0) {\n            return 0;\n        }\n    }\n    iVar1 = fcn.004213cc();\n    if (*(iVar1 + 4) != NULL) {\n        (**(**(iVar1 + 4) + 0xac))(arg_ch, 1);\n    }\n    return 1;\n}\n",
        "token_count": 194
    },
    "004142e3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004142e3(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint32_t uVar5;\n    \n    uVar5 = arg_8h & 0xffff;\n    iVar2 = fcn.0040dfaa();\n    iVar4 = 0;\n    if (iVar2 == 0) {\n        iVar2 = fcn.00407ad1();\n        iVar4 = extraout_ECX;\n    }\n    pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n    if ((((*(iVar2 + 0x68) == iVar4) || (arg_ch != iVar4)) || (uVar5 == 0xe146)) ||\n       ((uVar5 == 0xe147 || (uVar5 == 0xe145)))) {\n        uVar3 = fcn.0040eae4(arg_8h, arg_ch);\n    }\n    else {\n        iVar4 = (*_sym.imp.USER32.dll_SendMessageW)(*(in_ECX + 0x20), 0x365, iVar4, uVar5 + 0x10000);\n        if (iVar4 == 0) {\n            (*pcVar1)(*(in_ECX + 0x20), 0x111, 0xe147, 0);\n        }\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 345
    },
    "00415d71": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00415d71(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    \n    iVar2 = arg_8h;\n    if ((arg_8h == 0) || ((*(in_ECX + 0xf) & 4) == 0)) {\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n        iVar3 = fcn.0040d45d(arg_8h_00);\n        if (iVar3 != 0) {\n            arg_8h = 0;\n            (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(*(iVar3 + 0x20), &arg_8h);\n            iVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)();\n            if (iVar3 == arg_8h) {\n                return;\n            }\n        }\n        pcVar1 = _sym.imp.USER32.dll_SendMessageW;\n        if (iVar2 == 0) {\n            if (in_ECX[0x2e] == 0) {\n                in_ECX[0xf] = in_ECX[0xf] | 0x80;\n                (**(*in_ECX + 0x100))();\n            }\n        }\n        else {\n            if (in_ECX[0xf] < '\\0') {\n                in_ECX[0xf] = in_ECX[0xf] & 0xffffff7f;\n                (**(*in_ECX + 0x104))();\n                arg_8h = in_ECX[8];\n                iVar3 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n                if (iVar3 == arg_8h) {\n                    (*pcVar1)(arg_8h, 6, 1, 0);\n                }\n            }\n            if ((*(in_ECX + 0xf) & 0x20) != 0) {\n                (*pcVar1)(in_ECX[8], 0x86, 1, 0);\n            }\n        }\n        fcn.00414365((-(iVar2 != 0) & 0xfffffff0) + 0x20);\n    }\n    else {\n        fcn.00410af4(0);\n        (*_sym.imp.USER32.dll_SetFocus)(0);\n    }\n    return;\n}\n",
        "token_count": 538
    },
    "00415f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00415f50(uint param_1)\n\n{\n    fcn.004213cc();\n    fcn.00415818();\n    fcn.004222e2(param_1);\n    return;\n}\n",
        "token_count": 49
    },
    "00415f6f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00415f6f(uint param_1)\n\n{\n    fcn.004213cc();\n    fcn.00415818();\n    fcn.00422300(param_1);\n    return;\n}\n",
        "token_count": 49
    },
    "00416567": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00416567(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint32_t lpIconName;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    lpIconName = *(unaff_EBP + 8);\n    extraout_ECX[0x29] = lpIconName;\n    fcn.00401890();\n    *(unaff_EBP + -4) = 0;\n    iVar1 = fcn.00402820(lpIconName);\n    if (iVar1 != 0) {\n        fcn.00410c4f(extraout_ECX + 0x31, *(unaff_EBP + 8), 0, 10);\n    }\n    fcn.0041053c(8);\n    uVar2 = fcn.00414519(*(unaff_EBP + 0xc), lpIconName);\n    fcn.004052f0(extraout_ECX + 0x31);\n    iVar1 = *extraout_ECX;\n    *(unaff_EBP + -4) = 1;\n    iVar1 = (**(iVar1 + 0x13c))(uVar2, *(unaff_EBP + -0x10), *(unaff_EBP + 0xc), 0x45ba80, *(unaff_EBP + 0x10), \n                                lpIconName & 0xffff, 0, *(unaff_EBP + 0x14));\n    if (iVar1 != 0) {\n        if (extraout_ECX[0x35] == 1) {\n            iVar1 = (*_sym.imp.USER32.dll_GetMenu)(extraout_ECX[8]);\n        }\n        else {\n            iVar1 = extraout_ECX[0x36];\n        }\n        extraout_ECX[0x17] = iVar1;\n        fcn.0041415e(lpIconName & 0xffff);\n        if (*(unaff_EBP + 0x14) == 0) {\n            fcn.0040dfeb(extraout_ECX[8], 0x364, 0, 0, 1, 1);\n        }\n    }\n    fcn.00401020();\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 584
    },
    "00416d87": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00416d87(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint32_t uVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_54h;\n    uint var_50h;\n    uint var_4h;\n    \n    fcn.00430f04(0x48);\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.00401890();\n    *(unaff_EBP + -4) = 0;\n    uVar1 = fcn.004109b6();\n    if ((uVar1 & 0x4000) == 0) {\n        fcn.00405370(*(extraout_ECX + 0xc4), *(*(extraout_ECX + 0xc4) + -0xc));\n        if (arg_8h_00 != 0) {\n            fcn.004090aa(0x44a178);\n            fcn.004090aa(arg_8h_00);\n            if (0 < *(extraout_ECX + 0x58)) {\n                fcn.004313fa(unaff_EBP + -0x50, 0x20, 0x449714, *(extraout_ECX + 0x58));\n                fcn.004090aa(unaff_EBP + -0x50);\n            }\n        }\n    }\n    else {\n        if (arg_8h_00 != 0) {\n            fcn.004090aa(arg_8h_00);\n            if (0 < *(extraout_ECX + 0x58)) {\n                fcn.004313fa(unaff_EBP + -0x50, 0x20, 0x449714, *(extraout_ECX + 0x58));\n                fcn.004090aa(unaff_EBP + -0x50);\n            }\n            fcn.004090aa(0x44a178);\n        }\n        fcn.00405370(*(extraout_ECX + 0xc4), *(*(extraout_ECX + 0xc4) + -0xc));\n    }\n    fcn.00421550(*(extraout_ECX + 0x20), *(unaff_EBP + -0x54));\n    fcn.00401020();\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 541
    },
    "0041702d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0041702d(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    *(param_1 + 0xa0) = 0;\n    var_4h = 0;\n    var_8h = 0;\n    var_14h = 4;\n    var_ch = 0;\n    piVar2 = 0x45ba94;\n    var_10h = param_1;\n    iVar1 = *0x45ba94;\n    while (iVar1 != 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001, *piVar2, 0, 1, &var_4h);\n        if (iVar1 == 0) {\n            for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n                iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(var_4h, *piVar3, 0, &var_ch, &var_8h, &var_14h);\n                if ((iVar1 == 0) && (var_ch == 4)) {\n                    if (var_8h == 0) {\n                        *(var_10h + 0xa0) = *(var_10h + 0xa0) & ~piVar3[1];\n                    }\n                    else {\n                        *(var_10h + 0xa0) = *(var_10h + 0xa0) | piVar3[1];\n                    }\n                }\n                var_8h = 0;\n                var_14h = 4;\n                var_ch = 0;\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n            var_4h = 0;\n        }\n        piVar2 = piVar2 + 2;\n        iVar1 = *piVar2;\n    }\n    return 1;\n}\n",
        "token_count": 497
    },
    "00417428": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417428(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0043138b(arg_8h, arg_ch, arg_10h);\n    fcn.00401d80(uVar1);\n    return;\n}\n",
        "token_count": 75
    },
    "00417cae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint16_t * __cdecl fcn.00417cae(uint arg_8h, uint arg_ch)\n\n{\n    uint16_t *puVar1;\n    uint arg_8h_00;\n    uint arg_8h_01;\n    uint var_4h;\n    \n    puVar1 = fcn.00401e80(arg_8h, arg_ch);\n    if (puVar1 != NULL) {\n        arg_8h_00 = fcn.00406d0b(puVar1 + 1, *puVar1);\n        arg_8h_01 = fcn.00406eac(arg_8h_00);\n        fcn.00406c4f(arg_8h_01, arg_8h_00, puVar1 + 1, *puVar1);\n        fcn.00406c24(arg_8h_00);\n        puVar1 = 0x1;\n    }\n    return puVar1;\n}\n",
        "token_count": 209
    },
    "00417dac": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00417dac(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_41ch;\n    uint var_4h;\n    \n    fcn.00430f3a(0x414);\n    *(unaff_EBP + -0x41c) = extraout_ECX;\n    *extraout_ECX = vtable.CWinApp.0;\n    piVar1 = extraout_ECX[0x16];\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n    }\n    if (extraout_ECX[0x22] != NULL) {\n        (**(*extraout_ECX[0x22] + 0x18))(1);\n    }\n    iVar2 = fcn.004213cc();\n    if (*(iVar2 + 0x14) == '\\0') {\n        if (*0x45f538 != NULL) {\n            (**(**0x45f538 + 4))(1);\n            *0x45f538 = NULL;\n        }\n        if (*0x45f534 != NULL) {\n            (**(**0x45f534 + 4))(1);\n            *0x45f534 = NULL;\n        }\n    }\n    if (extraout_ECX[0x1c] != NULL) {\n        fcn.00421610(extraout_ECX[0x1c]);\n    }\n    if (extraout_ECX[0x1d] != NULL) {\n        fcn.00421610(extraout_ECX[0x1d]);\n    }\n    if (*(extraout_ECX + 0x24) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(*(extraout_ECX + 0x24));\n    }\n    if (*(extraout_ECX + 0x92) != 0) {\n        (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(*(extraout_ECX + 0x92));\n    }\n    if (extraout_ECX[0x23] != NULL) {\n        (**(*extraout_ECX[0x23] + 4))(1);\n    }\n    iVar2 = fcn.004213cc();\n    if (*(iVar2 + 0x10) == extraout_ECX[0x14]) {\n        *(iVar2 + 0x10) = 0;\n    }\n    if (*(iVar2 + 4) == extraout_ECX) {\n        *(iVar2 + 4) = 0;\n    }\n    fcn.0042e518(extraout_ECX[0x14]);\n    fcn.0042e518(extraout_ECX[0x15]);\n    fcn.0042e518(extraout_ECX[0x18]);\n    fcn.0042e518(extraout_ECX[0x19]);\n    fcn.0042e518(extraout_ECX[0x1a]);\n    extraout_ECX[0xb] = NULL;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0041a7cc();\n    fcn.00430f96();\n    return;\n}\n",
        "token_count": 743
    },
    "00418760": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00418760(uint32_t arg_8h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t extraout_ECX;\n    \n    iVar2 = in_ECX[0x22];\n    if (iVar2 != 0) goto code_r0x00418778;\n    do {\n        fcn.00407ad1();\n        iVar2 = extraout_ECX;\ncode_r0x00418778:\n    } while ((arg_8h < 0xe110) || (*(iVar2 + 4) + 0xe110U <= arg_8h));\n    puVar1 = fcn.004186f9(arg_8h - 0xe110);\n    iVar2 = (**(*in_ECX + 0x88))(*puVar1);\n    if (iVar2 == 0) {\n        (***in_ECX[0x22])(arg_8h - 0xe110);\n    }\n    return 1;\n}\n",
        "token_count": 226
    },
    "00418834": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00418834(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004019b0(arg_10h + arg_18h);\n    fcn.00401bf0(iVar1, arg_10h, arg_ch, arg_10h);\n    fcn.00401bf0(iVar1 + arg_10h * 2, arg_18h, arg_14h, arg_18h);\n    fcn.004019e0(arg_10h + arg_18h);\n    return;\n}\n",
        "token_count": 154
    },
    "004188d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004188d3(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    uint arg_10h_00;\n    int32_t unaff_EBP;\n    uint var_10h;\n    int32_t arg_14h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    piVar1 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x10) = 0;\n    uVar2 = fcn.004110fa();\n    fcn.004110e3(uVar2);\n    arg_14h = *piVar1;\n    uVar2 = *(arg_14h + -0xc);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    arg_10h_00 = fcn.00402a30(*(unaff_EBP + 0xc));\n    fcn.00418834(*(unaff_EBP + 8), *(unaff_EBP + 0xc), arg_10h_00, arg_14h, uVar2);\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 321
    },
    "004196d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004196d3(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    \n    arg_8h_00 = fcn.004019b0(0x104);\n    fcn.00430820(arg_8h_00, 0, 0x104);\n    fcn.00407b1c(arg_8h_00, 0x104, arg_8h, 0xffffffff);\n    (*_sym.imp.SHLWAPI.dll_PathStripToRootW)(arg_8h_00);\n    fcn.0040d34f(0xffffffff);\n    return;\n}\n",
        "token_count": 144
    },
    "00419c98": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419c98(uint arg_8h, uint *arg_ch)\n\n{\n    uint unaff_ESI;\n    uint var_208h;\n    uint var_204h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    fcn.004313fa(&var_204h, 0x100, L\"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", *arg_ch);\n    fcn.00402680(&var_204h);\n    fcn.0042e09f(unaff_ESI);\n    return;\n}\n",
        "token_count": 162
    },
    "00419d27": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00419d27(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_ch_00;\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    arg_ch_00 = *(unaff_EBP + 8);\n    puVar1 = *(unaff_EBP + 0x10);\n    *puVar1 = 0;\n    fcn.00419c98(unaff_EBP + -0x10, arg_ch_00);\n    *(unaff_EBP + -4) = 0;\n    fcn.00401890();\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0041961e(*(unaff_EBP + -0x10), unaff_EBP + 0x10);\n    if (iVar2 == 0) {\n        fcn.00401020();\n        fcn.00401020();\n    }\n    else {\n        iVar2 = fcn.004191b8(*(unaff_EBP + 0x10));\n        if ((iVar2 != 0) &&\n           (pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"DllGetClassObject\"),  pcVar3 != NULL)) {\n            (*pcVar3)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), puVar1);\n        }\n        fcn.00401020();\n        fcn.00401020();\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 414
    },
    "00419e34": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00419e34(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    ushort *puVar2;\n    uint *puVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t unaff_EBP;\n    uint var_2d1h;\n    uint var_2cch;\n    uint var_2c8h;\n    uint psfi;\n    uint var_2bch;\n    uint var_4h;\n    \n    fcn.00430f04(0x2c8);\n    iVar6 = *(unaff_EBP + 8);\n    uVar1 = *(unaff_EBP + 0xc);\n    puVar2 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -0x2cc) = uVar1;\n    *(unaff_EBP + -0x2c8) = 0;\n    *puVar2 = 0;\n    if ((((iVar6 != 0) &&\n         (iVar5 = (*_sym.imp.SHELL32.dll_SHGetFileInfoW)(uVar1, 0, unaff_EBP + -0x2c4, 0x2b4, 0x800),  iVar5 != 0)) &&\n        ((*(unaff_EBP + -700) & 0x10000) != 0)) &&\n       ((iVar5 = fcn.00419dd6(0x44a950, 0, 0x44a960, unaff_EBP + -0x2c8),  -1 < iVar5 &&\n        (puVar3 = *(unaff_EBP + -0x2c8),  puVar3 != NULL)))) {\n        *(unaff_EBP + -0x2d0) = 0;\n        iVar5 = (***puVar3)(puVar3, 0x44f670, unaff_EBP + -0x2d0);\n        if (-1 < iVar5) {\n            fcn.00402680(*(unaff_EBP + -0x2cc));\n            piVar4 = *(unaff_EBP + -0x2d0);\n            *(unaff_EBP + -4) = 0;\n            if (piVar4 != NULL) {\n                iVar5 = (**(*piVar4 + 0x14))(piVar4, *(unaff_EBP + -0x2cc), 0);\n                if ((-1 < iVar5) &&\n                   (iVar6 = (**(**(unaff_EBP + -0x2c8) + 0x4c))(*(unaff_EBP + -0x2c8), *(iVar6 + 0x20), 2),  -1 < iVar6)\n                   ) {\n                    (**(**(unaff_EBP + -0x2c8) + 0xc))(*(unaff_EBP + -0x2c8), puVar2, *(unaff_EBP + 0x14), 0, 0);\n                    (**(**(unaff_EBP + -0x2d0) + 8))(*(unaff_EBP + -0x2d0));\n                    (**(**(unaff_EBP + -0x2c8) + 8))(*(unaff_EBP + -0x2c8));\n                    fcn.00401020();\n                    goto code_r0x00419f9c;\n                }\n                piVar4 = *(unaff_EBP + -0x2d0);\n                if (piVar4 != NULL) {\n                    (**(*piVar4 + 8))(piVar4);\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00401020();\n        }\n        (**(**(unaff_EBP + -0x2c8) + 8))(*(unaff_EBP + -0x2c8));\n    }\ncode_r0x00419f9c:\n    fcn.00430f87();\n    return;\n}\n",
        "token_count": 917
    },
    "0041a169": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0041a169(void)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    \n    iVar1 = fcn.0041a127(&var_24h);\n    if (iVar1 != 0) {\n        return *(iVar1 + 0x14) + 0x76c;\n    }\n    return 0;\n}\n",
        "token_count": 82
    },
    "0041a793": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041a793(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0x20) = 0;\n    *(param_1 + 0x24) = 0;\n    *(param_1 + 0x2c) = 0;\n    *(param_1 + 0x30) = 0;\n    iVar1 = fcn.00420e14();\n    *(iVar1 + 0x34) = 0;\n    *(iVar1 + 0x54) = 0;\n    (*_sym.imp.USER32.dll_GetCursorPos)(iVar1 + 0x4c);\n    *(param_1 + 0x40) = 0;\n    *(param_1 + 0x3c) = 0;\n    *(param_1 + 0x28) = 1;\n    return;\n}\n",
        "token_count": 199
    },
    "0041a8bf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041a8bf(int32_t arg_8h)\n\n{\n    code **ppcVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t *in_ECX;\n    uint arg_14h;\n    uint var_4h;\n    \n    ppcVar1 = (**(*in_ECX + 0x28))();\n    pcVar3 = *ppcVar1;\n    do {\n        if (pcVar3 == NULL) {\n            return 0;\n        }\n        arg_14h = 0;\n        if (*(arg_8h + 4) < 0xc000) {\n            iVar2 = fcn.0040b1e3(ppcVar1[1], *(arg_8h + 4), 0, 0);\n            if (iVar2 != 0) {\ncode_r0x0041a8f9:\n                (**(iVar2 + 0x14))(*(arg_8h + 8), *(arg_8h + 0xc));\n                return 1;\n            }\n        }\n        else {\n            pcVar3 = ppcVar1[1];\n            while (iVar2 = fcn.0040b1e3(pcVar3, 0xc000, 0, arg_14h),  iVar2 != 0) {\n                if (**(iVar2 + 0x10) == *(arg_8h + 4)) goto code_r0x0041a8f9;\n                pcVar3 = iVar2 + 0x18;\n            }\n        }\n        ppcVar1 = (**ppcVar1)();\n        pcVar3 = *ppcVar1;\n    } while( true );\n}\n",
        "token_count": 374
    },
    "0041aeab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0041aeab(code **param_1)\n\n{\n    fcn.0040bca1();\n    *param_1 = vtable.CDialog.0;\n    fcn.00430820(param_1 + 0x15, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 73
    },
    "0041af5f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041af5f(code *arg_8h, code *arg_ch)\n\n{\n    code **in_ECX;\n    \n    fcn.0040bca1();\n    *in_ECX = vtable.CDialog.0;\n    fcn.00430820(in_ECX + 0x15, 0, 0x20);\n    in_ECX[0x1a] = arg_ch;\n    in_ECX[0x15] = arg_8h;\n    in_ECX[0x16] = arg_8h & 0xffff;\n    return;\n}\n",
        "token_count": 132
    },
    "0041b453": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: hMem\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0041b453(uint arg_8h, uint arg_ch, uint hInstance)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_48h;\n    uint var_38h;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hMem;\n    uint var_4h;\n    \n    fcn.00430ece(0x3c);\n    *(unaff_EBP + -0x20) = arg_8h_00;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar2 = fcn.004213cc();\n        *(unaff_EBP + 0x10) = *(iVar2 + 0xc);\n    }\n    iVar2 = fcn.004213cc();\n    piVar1 = *(iVar2 + 0x3c);\n    *(unaff_EBP + -0x28) = piVar1;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0041053c(0x10);\n    fcn.0041053c(0xfc000);\n    fcn.0040dba8();\n    if (piVar1 == NULL) {\n        iVar2 = *(unaff_EBP + 8);\n    }\n    else {\n        iVar2 = (**(*arg_8h_00 + 0x134))(unaff_EBP + -0x48);\n        if (iVar2 == 0) goto code_r0x0041b606;\n        iVar2 = (**(*piVar1 + 0x14))(unaff_EBP + -0x48, *(unaff_EBP + 8));\n    }\n    if (iVar2 != 0) {\n        fcn.00401890();\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x18) = 0;\n        iVar3 = fcn.00427332(iVar2, unaff_EBP + -0x1c, unaff_EBP + -0x18);\n        if (iVar3 == 0) {\n            fcn.004272f6(iVar2);\n            *(unaff_EBP + -4) = 2;\n            fcn.00427252(*(unaff_EBP + -0x18));\n            uVar4 = fcn.00426f8e();\n            *(unaff_EBP + -0x14) = uVar4;\n            *(unaff_EBP + -4) = 1;\n            fcn.00426f80();\n            if (*(unaff_EBP + -0x14) != 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n            }\n        }\n        arg_8h_00[0x11] = -1;\n        arg_8h_00[0xf] = arg_8h_00[0xf] | 0x10;\n        fcn.0040f4b1(arg_8h_00);\n        if (*(unaff_EBP + 0xc) == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = *(*(unaff_EBP + 0xc) + 0x20);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamW)(*(unaff_EBP + 0x10), iVar2, uVar4, fcn.0041ae6d, 0);\n        fcn.00401020();\n        *(unaff_EBP + -4) = 0xffffffff;\n        if ((*(unaff_EBP + -0x28) != NULL) && (iVar2 != 0)) {\n            (**(**(unaff_EBP + -0x28) + 0x18))(unaff_EBP + -0x48);\n            (**(*arg_8h_00 + 0x134))(0);\n        }\n        iVar3 = fcn.0040d516();\n        if (iVar3 == 0) {\n            (**(*arg_8h_00 + 0x11c))();\n        }\n        if ((iVar2 != 0) && ((*(arg_8h_00 + 0xf) & 0x10) == 0)) {\n            (*_sym.imp.USER32.dll_DestroyWindow)(iVar2);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n            (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n        }\n    }\ncode_r0x0041b606:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1194
    },
    "0041ba55": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0041ba55(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    fcn.00401890();\n    *(unaff_EBP + -4) = 0;\n    iVar1 = fcn.00402820(*(unaff_EBP + 0xc));\n    if (iVar1 != 0) {\n        fcn.0041b912(*(unaff_EBP + 8), *(unaff_EBP + -0x10), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 234
    },
    "0041c017": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041c017(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    \n    iVar1 = *(in_ECX + 0x74);\n    if (0 < iVar1) {\n        piVar3 = *(in_ECX + 0x78);\n        iVar2 = 0;\n        if (0 < iVar1) {\n            do {\n                if (*piVar3 == arg_8h) {\n                    return iVar2;\n                }\n                iVar2 = iVar2 + 1;\n                piVar3 = piVar3 + 5;\n            } while (iVar2 < iVar1);\n        }\n    }\n    return -1;\n}\n",
        "token_count": 173
    },
    "0041c26f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c26f(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.00427c50(&var_10h, 1);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 169
    },
    "0041c329": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c329(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t unaff_EDI;\n    \n    iVar2 = arg_8h;\n    iVar4 = unaff_EDI;\n    if (-1 < arg_8h) goto code_r0x0041c33e;\n    do {\n        fcn.00407ad1();\n        iVar4 = unaff_EDI;\ncode_r0x0041c33e:\n        if (-1 < arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (iVar2 == 0) {\n            if (*(in_ECX + 4) != 0) {\n                fcn.0040644a(*(in_ECX + 4));\n                *(in_ECX + 4) = 0;\n            }\n            *(in_ECX + 0xc) = 0;\n            *(in_ECX + 8) = 0;\n            return;\n        }\n        if (*(in_ECX + 4) == 0) {\n            iVar4 = *(in_ECX + 0x10);\n            if (*(in_ECX + 0x10) < iVar2) {\n                iVar4 = iVar2;\n            }\n            uVar3 = fcn.0040641b(iVar4 << 2);\n            *(in_ECX + 4) = uVar3;\n            fcn.00430820(uVar3, 0, iVar4 << 2);\n            *(in_ECX + 0xc) = iVar4;\n            goto code_r0x0041c45a;\n        }\n        unaff_EDI = *(in_ECX + 0xc);\n        if (iVar2 <= unaff_EDI) {\n            iVar1 = *(in_ECX + 8);\n            if (iVar1 < iVar2) {\n                fcn.00430820(*(in_ECX + 4) + iVar1 * 4, 0, (iVar2 - iVar1) * 4, iVar4);\n            }\n            goto code_r0x0041c45a;\n        }\n        iVar4 = *(in_ECX + 0x10);\n        if (iVar4 == 0) {\n            iVar4 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar4 < 4) {\n                iVar4 = 4;\n            }\n            else if (0x400 < iVar4) {\n                iVar4 = 0x400;\n            }\n        }\n        arg_8h = iVar4 + unaff_EDI;\n        if (iVar4 + unaff_EDI <= iVar2) {\n            arg_8h = iVar2;\n        }\n    } while (arg_8h < unaff_EDI);\n    iVar4 = fcn.0040641b(arg_8h << 2);\n    fcn.00408f79(iVar4, arg_8h << 2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.00430820(iVar4 + *(in_ECX + 8) * 4, 0, (iVar2 - *(in_ECX + 8)) * 4);\n    fcn.0040644a(*(in_ECX + 4));\n    *(in_ECX + 4) = iVar4;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x0041c45a:\n    *(in_ECX + 8) = iVar2;\n    return;\n}\n",
        "token_count": 826
    },
    "0041c49a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041c49a(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (arg_8h == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar1 = fcn.0041c017(0);\n        if (-1 < iVar1) {\n            iVar1 = *(iVar1 * 0x14 + *(in_ECX + 0x78) + 0x10);\n            iVar2 = *(iVar1 + -0xc);\n            if (arg_8h < iVar2) {\n                iVar2 = arg_8h + -1;\n            }\n            fcn.00408f79(arg_ch, arg_8h * 2, iVar1, iVar2 * 2);\n        }\n        *(arg_ch + iVar2 * 2) = 0;\n        iVar2 = iVar2 + 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 236
    },
    "0041c5b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0041c5b2(uint arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(in_ECX + 0x74)) {\n        do {\n            fcn.0041c58c(0);\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(in_ECX + 0x74));\n    }\n    iVar2 = fcn.00427916(arg_8h, arg_ch);\n    if (iVar2 != 0) {\n        iVar2 = 0;\n        if (0 < *(in_ECX + 0x74)) {\n            iVar1 = *(in_ECX + 0x78) + 0x10;\n            do {\n                if (iVar1 != 0) {\n                    fcn.00401890();\n                }\n                iVar1 = iVar1 + 0x14;\n                iVar2 = iVar2 + 1;\n            } while (iVar2 < *(in_ECX + 0x74));\n        }\n        iVar2 = 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 266
    },
    "0041c8cc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041c8cc(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = arg_8h * 0x14 + *(in_ECX + 0x78);\n    if (*(iVar1 + 8) != arg_ch) {\n        if (((*(iVar1 + 8) ^ arg_ch) & 0x8000000) != 0) {\n            *(iVar1 + 8) = arg_ch;\n            fcn.0041c761(1, 0);\n        }\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) | 1;\n        *(iVar1 + 8) = arg_ch;\n        fcn.0041c66c(arg_8h, *(iVar1 + 0x10), 1);\n    }\n    return;\n}\n",
        "token_count": 202
    },
    "0041cc62": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0041cc62(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint unaff_EDI;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    for (iVar1 = (**(*in_ECX + 0x118))(0x418, 0, 0); iVar1 != 0; iVar1 = iVar1 + -1) {\n        (**(*in_ECX + 0x118))(0x416, 0, 0);\n    }\n    fcn.00430820(&var_18h, 0, 0x14);\n    var_8h = 0xffffffff;\n    if (arg_8h == NULL) {\n        iVar1 = 0;\n        var_10h._0_1_ = 4;\n        if (0 < arg_ch) {\n            do {\n                iVar3 = (**(*in_ECX + 0x118))(0x414, 1, &var_18h);\n                if (iVar3 == 0) goto code_r0x0041cd92;\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < arg_ch);\n        }\n    }\n    else {\n        var_20h = 0;\n        var_1ch = 0;\n        if (0 < arg_ch) {\n            do {\n                var_14h = *arg_8h;\n                arg_8h = arg_8h + 1;\n                var_10h._0_1_ = 4;\n                if (var_14h == 0) {\n                    var_10h._1_1_ = 1;\n                    uVar2 = fcn.004109b6();\n                    if (((uVar2 & 0x800) == 0) && (*0x45bc5c != 0x40047)) {\n                        var_18h = 8;\n                    }\n                    else {\n                        var_18h = 6;\n                    }\n                }\n                else {\n                    var_10h._1_1_ = 0;\n                    var_18h = var_20h;\n                    var_20h = var_20h + 1;\n                }\n                iVar1 = (**(*in_ECX + 0x118))(0x414, 1, &var_18h);\n                if (iVar1 == 0) goto code_r0x0041cd92;\n                var_1ch = var_1ch + 1;\n            } while (var_1ch < arg_ch);\n        }\n    }\n    iVar1 = (**(*in_ECX + 0x118))(0x418, 0, 0);\n    in_ECX[0x1d] = iVar1;\n    in_ECX[0x29] = 1;\ncode_r0x0041cd92:\n    fcn.0042e09f(unaff_EDI);\n    return;\n}\n",
        "token_count": 738
    },
    "0041d732": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d732(uint arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint var_20h;\n    uint var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    if (arg_14h == 0) {\n        arg_14h = arg_10h;\n        var_4h = fcn.0041ce77(arg_8h, arg_ch, arg_10h);\n        iVar1 = fcn.0041ce77(arg_8h, arg_ch, 0);\n        if ((iVar1 != var_4h) && (0 < arg_10h)) {\n            do {\n                iVar1 = (arg_14h + iVar4) / 2;\n                iVar2 = fcn.0041ce77(arg_8h, arg_ch, iVar1);\n                if ((iVar2 != var_4h) && (bVar5 = iVar4 == iVar1,  iVar4 = iVar1,  iVar1 = arg_14h,  bVar5)) {\n                    fcn.0041ce77(arg_8h, arg_ch, arg_14h);\n                    break;\n                }\n                arg_14h = iVar1;\n            } while (iVar4 < arg_14h);\n        }\n        fcn.0041d600(&var_10h, arg_8h, arg_ch);\n        iVar1 = var_10h;\ncode_r0x0041d8aa:\n        fcn.0041ce77(arg_8h, arg_ch, iVar1);\n    }\n    else {\n        fcn.0041ce77(arg_8h, arg_ch, 0);\n        piVar3 = fcn.0041d600(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        var_4h = piVar3[1];\n        var_8h = iVar4;\n        fcn.0041ce77(arg_8h, arg_ch, 0x7fff);\n        piVar3 = fcn.0041d600(&var_18h, arg_8h, arg_ch);\n        iVar1 = *piVar3;\n        var_ch = piVar3[1];\n        var_10h = iVar1;\n        if (iVar4 < iVar1) {\n            do {\n                fcn.0041ce77(arg_8h, arg_ch, (iVar1 + iVar4) / 2);\n                piVar3 = fcn.0041d600(&var_18h, arg_8h, arg_ch);\n                iVar4 = piVar3[1];\n                if (arg_10h < iVar4) {\n                    iVar4 = fcn.0041a96e(*piVar3, iVar4);\n                    if (iVar4 != 0) goto code_r0x0041d8aa;\n                    var_8h = *piVar3;\n                    var_4h = piVar3[1];\n                }\n                else {\n                    if (arg_10h <= iVar4) {\n                        return;\n                    }\n                    iVar4 = fcn.0041a96e(*piVar3, iVar4);\n                    iVar1 = var_8h;\n                    if (iVar4 != 0) goto code_r0x0041d8aa;\n                    iVar1 = *piVar3;\n                    var_ch = piVar3[1];\n                    var_10h = iVar1;\n                }\n                iVar4 = var_8h;\n            } while (var_8h < iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 855
    },
    "0041d9a3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041d9a3(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.00427c50(&var_10h, (*(in_ECX + 0x84) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    if (*0x45bc5c < 0x40047) {\n        arg_ch[1] = arg_ch[1] + -2;\n    }\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 227
    },
    "0041e647": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041e647(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t in_ECX;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    if (*(in_ECX + 0x10c) == 0) {\n        uVar1 = 0;\n        if (*(in_ECX + 0x110) != 0) {\n            iVar2 = 0;\n            do {\n                *(iVar2 + 0x18 + *(in_ECX + 0xb0)) = 0;\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x28;\n            } while (uVar1 < *(in_ECX + 0x110));\n        }\n        fcn.0040d3b7();\n    }\n    else {\n        *(in_ECX + 0x70) = arg_ch;\n        *(in_ECX + 0x74) = arg_10h;\n        *(in_ECX + 0x78) = arg_ch / 10;\n        *(in_ECX + 0x7c) = arg_10h / 10;\n        fcn.00408c21(arg_8h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 291
    },
    "0041eb73": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041eb73(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    *(in_ECX + 0x114) = arg_8h;\n    uVar1 = *(*(**(in_ECX + 0x134) + 0x74) + 0x1e);\n    if (uVar1 < arg_8h) {\n        *(in_ECX + 0x114) = uVar1;\n    }\n    uVar1 = *(*(**(in_ECX + 0x134) + 0x74) + 0x1c);\n    if (*(in_ECX + 0x114) < uVar1) {\n        *(in_ECX + 0x114) = uVar1;\n    }\n    if (*(in_ECX + 0x10c) == 0) {\n        fcn.0040bf62(1, *(in_ECX + 0x114), 1);\n    }\n    if (arg_ch != 0) {\n        uVar1 = 0;\n        if (*(in_ECX + 0x110) != 0) {\n            iVar2 = 0;\n            do {\n                *(*(in_ECX + 0xb0) + 0x18 + iVar2) = 0;\n                uVar1 = uVar1 + 1;\n                iVar2 = iVar2 + 0x28;\n            } while (uVar1 < *(in_ECX + 0x110));\n        }\n    }\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    return;\n}\n",
        "token_count": 386
    },
    "0041f205": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041f205(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    \n    pcVar3 = _sym.imp.USER32.dll_ShowScrollBar;\n    if (*(in_ECX + 0x10c) == 0) {\n        *(in_ECX + 0x118) = *(in_ECX + 0x108);\n        (*pcVar3)(*(in_ECX + 0x20), 0);\n        iVar4 = *(**(in_ECX + 0x134) + 0x74);\n        uVar2 = *(iVar4 + 0x1e);\n        if ((0x7fff < uVar2) || (arg_8h = 1,  0x7fff < uVar2 - *(iVar4 + 0x1c))) {\n            arg_8h = 0;\n        }\n        (*pcVar3)(*(in_ECX + 0x20), 1, arg_8h);\n        if (arg_8h != 0) {\n            var_18h = 3;\n            var_14h = *(*(**(in_ECX + 0x134) + 0x74) + 0x1c);\n            var_10h = *(*(**(in_ECX + 0x134) + 0x74) + 0x1e);\n            var_ch = 1;\n            iVar4 = fcn.0040b29f(1, &var_1ch, 0);\n            if (iVar4 == 0) {\n                fcn.0040bfc2(1, var_14h, var_10h, 0);\n            }\n        }\n        fcn.0041eb73(*(in_ECX + 0x114), 1);\n    }\n    else {\n        iVar4 = *(in_ECX + 0xb0);\n        iVar5 = arg_8h * 0x28;\n        *(in_ECX + 0x118) = 1;\n        *(iVar4 + 0x20) = *(iVar4 + 0x20 + iVar5);\n        *(iVar4 + 0x24) = *(iVar4 + 0x24 + iVar5);\n        iVar4 = *(in_ECX + 0xb0);\n        *(iVar4 + 0x10) = *(iVar4 + 0x10 + iVar5);\n        *(iVar4 + 0x14) = *(iVar4 + 0x14 + iVar5);\n        fcn.0041eb73(*(in_ECX + 0x114) + arg_8h, 0);\n        fcn.0041e8a5(0);\n        pcVar3 = _sym.imp.KERNEL32.dll_MulDiv;\n        puVar1 = iVar5 + 0x18 + *(in_ECX + 0xb0);\n        iVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_ch, *puVar1, puVar1[1]);\n        iVar5 = (*pcVar3)(arg_10h, *puVar1, puVar1[1]);\n        fcn.00408209(iVar4 + **(in_ECX + 0xb0), iVar5 + (*(in_ECX + 0xb0))[1]);\n    }\n    return;\n}\n",
        "token_count": 805
    },
    "00420f3e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00420f3e(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    fcn.00402680(0x44bb08);\n    *(unaff_EBP + -4) = 0;\n    fcn.00420ed0(unaff_EBP + -0x10);\n    fcn.00401020();\n    *extraout_ECX = vtable.CComCtlWrapper.0;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[10] = NULL;\n    extraout_ECX[0xb] = NULL;\n    extraout_ECX[0xc] = NULL;\n    extraout_ECX[0xd] = NULL;\n    extraout_ECX[0xe] = NULL;\n    extraout_ECX[0xf] = NULL;\n    extraout_ECX[0x10] = NULL;\n    extraout_ECX[0x11] = NULL;\n    extraout_ECX[0x12] = NULL;\n    extraout_ECX[0x13] = NULL;\n    extraout_ECX[0x14] = NULL;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x16] = NULL;\n    extraout_ECX[0x17] = NULL;\n    extraout_ECX[0x18] = NULL;\n    extraout_ECX[0x19] = NULL;\n    extraout_ECX[0x1a] = NULL;\n    extraout_ECX[0x1b] = NULL;\n    extraout_ECX[0x1c] = NULL;\n    extraout_ECX[0x1d] = NULL;\n    extraout_ECX[0x1e] = NULL;\n    extraout_ECX[0x1f] = NULL;\n    extraout_ECX[0x20] = NULL;\n    extraout_ECX[0x21] = NULL;\n    extraout_ECX[0x22] = NULL;\n    extraout_ECX[0x23] = NULL;\n    extraout_ECX[0x24] = NULL;\n    extraout_ECX[0x25] = NULL;\n    extraout_ECX[0x26] = NULL;\n    extraout_ECX[0x27] = NULL;\n    extraout_ECX[0x28] = NULL;\n    extraout_ECX[0x29] = NULL;\n    extraout_ECX[0x2a] = NULL;\n    extraout_ECX[0x2b] = NULL;\n    extraout_ECX[0x2c] = NULL;\n    extraout_ECX[0x2d] = NULL;\n    extraout_ECX[0x2e] = NULL;\n    extraout_ECX[0x2f] = NULL;\n    extraout_ECX[0x30] = NULL;\n    extraout_ECX[0x31] = NULL;\n    extraout_ECX[0x32] = NULL;\n    extraout_ECX[0x33] = NULL;\n    extraout_ECX[0x34] = NULL;\n    extraout_ECX[0x35] = NULL;\n    extraout_ECX[0x36] = NULL;\n    extraout_ECX[0x37] = NULL;\n    extraout_ECX[0x38] = NULL;\n    extraout_ECX[0x39] = NULL;\n    extraout_ECX[0x3a] = NULL;\n    extraout_ECX[0x3b] = NULL;\n    extraout_ECX[0x3c] = NULL;\n    extraout_ECX[0x3d] = NULL;\n    extraout_ECX[0x3e] = NULL;\n    extraout_ECX[0x3f] = NULL;\n    extraout_ECX[0x40] = NULL;\n    extraout_ECX[0x41] = NULL;\n    extraout_ECX[0x42] = NULL;\n    extraout_ECX[0x43] = NULL;\n    extraout_ECX[0x44] = NULL;\n    extraout_ECX[0x45] = NULL;\n    extraout_ECX[0x46] = NULL;\n    extraout_ECX[0x47] = NULL;\n    extraout_ECX[0x48] = NULL;\n    extraout_ECX[0x49] = NULL;\n    extraout_ECX[0x4a] = NULL;\n    extraout_ECX[0x4b] = NULL;\n    extraout_ECX[0x4c] = NULL;\n    extraout_ECX[0x4d] = NULL;\n    extraout_ECX[0x4e] = NULL;\n    extraout_ECX[0x4f] = NULL;\n    extraout_ECX[0x50] = NULL;\n    extraout_ECX[0x51] = NULL;\n    extraout_ECX[0x52] = NULL;\n    extraout_ECX[0x53] = NULL;\n    extraout_ECX[0x54] = NULL;\n    extraout_ECX[0x55] = NULL;\n    extraout_ECX[0x56] = NULL;\n    extraout_ECX[0x57] = NULL;\n    extraout_ECX[0x58] = NULL;\n    extraout_ECX[0x59] = NULL;\n    extraout_ECX[0x5a] = NULL;\n    extraout_ECX[0x5b] = NULL;\n    extraout_ECX[0x5c] = NULL;\n    extraout_ECX[0x5d] = NULL;\n    extraout_ECX[0x5e] = NULL;\n    extraout_ECX[0x5f] = NULL;\n    extraout_ECX[0x60] = NULL;\n    extraout_ECX[0x61] = NULL;\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1389
    },
    "00421162": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00421162(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    fcn.00402680(0x44bb2c);\n    *(unaff_EBP + -4) = 0;\n    fcn.00420ed0(unaff_EBP + -0x10);\n    fcn.00401020();\n    *extraout_ECX = vtable.CCommDlgWrapper.0;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[10] = NULL;\n    extraout_ECX[0xb] = NULL;\n    extraout_ECX[0xc] = NULL;\n    extraout_ECX[0xd] = NULL;\n    extraout_ECX[0xe] = NULL;\n    extraout_ECX[0xf] = NULL;\n    extraout_ECX[0x10] = NULL;\n    extraout_ECX[0x11] = NULL;\n    extraout_ECX[0x12] = NULL;\n    extraout_ECX[0x13] = NULL;\n    extraout_ECX[0x14] = NULL;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x16] = NULL;\n    extraout_ECX[0x17] = NULL;\n    extraout_ECX[0x18] = NULL;\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 409
    },
    "004211e5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004211e5(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    fcn.00402680(0x44bb50);\n    *(unaff_EBP + -4) = 0;\n    fcn.00420ed0(unaff_EBP + -0x10);\n    fcn.00401020();\n    *extraout_ECX = vtable.CShellWrapper.0;\n    extraout_ECX[4] = NULL;\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 165
    },
    "004213ff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004213ff(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uStack8;\n    \n    fcn.004213cc();\n    iVar2 = fcn.00415818();\n    if (iVar2 == 0) {\n        uStack8 = 0x45b3f0;\n        fcn.0043126c(&uStack8, 0x454764);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 119
    },
    "0042152b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042152b(uint32_t arg_8h)\n\n{\n    if (0x10 < arg_8h) {\n        arg_8h = fcn.00407ad1();\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(arg_8h * 0x18 + 0x45f578);\n    return;\n}\n",
        "token_count": 83
    },
    "00421550": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00421550(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint lpString1;\n    uint32_t var_4h;\n    \n    var_4h = *0x45c240 ^ &stack0xfffffffc;\n    if (arg_8h != 0) goto code_r0x00421577;\n    do {\n        fcn.00407ad1();\ncode_r0x00421577:\n    } while (arg_ch == 0);\n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenW)(arg_ch);\n    lpString1._0_2_ = 0;\n    fcn.00430820(&lpString1 + 2, 0, 0x1fe);\n    if (uVar1 < 0x101) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowTextW)(arg_8h, &lpString1, 0x100);\n        if (uVar2 == uVar1) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(&lpString1, arg_ch);\n            if (iVar3 == 0) goto code_r0x004215d8;\n        }\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextW)(arg_8h, arg_ch);\ncode_r0x004215d8:\n    fcn.0042e09f(unaff_EBX);\n    return;\n}\n",
        "token_count": 357
    },
    "00421a61": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00421a61(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.0042e0ae(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.00401d80(uVar1);\n    return;\n}\n",
        "token_count": 88
    },
    "00422530": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: lpCriticalSection\n\nvoid __cdecl fcn.00422530(uint arg_8h, uint arg_ch)\n\n{\n    code **arg_8h_00;\n    uint uVar1;\n    code *pcVar2;\n    uint *extraout_ECX;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint lpCriticalSection;\n    uint uVar4;\n    uint *puVar5;\n    uint var_4h;\n    \n    fcn.00430ece(0x10);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    puVar5 = extraout_ECX + 7;\n    *(unaff_EBP + -0x14) = puVar5;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar5);\n    if ((*(unaff_EBP + 8) < 1) || (extraout_ECX[3] <= *(unaff_EBP + 8))) goto code_r0x00422657;\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*extraout_ECX);\n    if (arg_8h_00 == NULL) {\n        *(unaff_EBP + -4) = 0;\n        arg_8h_00 = fcn.004221af(0x10);\n        if (arg_8h_00 == NULL) {\n            arg_8h_00 = NULL;\n        }\n        else {\n            *arg_8h_00 = vtable.CThreadData.0;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        arg_8h_00[2] = NULL;\n        arg_8h_00[3] = NULL;\n        fcn.004222e2(arg_8h_00);\ncode_r0x00422587:\n        if (arg_8h_00[3] == NULL) {\n            uVar1 = fcn.00406cb3(extraout_ECX[3], 4);\n            pcVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, uVar1);\n        }\n        else {\n            uVar4 = 2;\n            uVar1 = fcn.00406cb3(extraout_ECX[3], 4);\n            pcVar2 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(arg_8h_00[3], uVar1, uVar4);\n        }\n        if (pcVar2 == NULL) {\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*(unaff_EBP + -0x14));\n            pcVar2 = fcn.00407a99();\n        }\n        arg_8h_00[3] = pcVar2;\n        fcn.00430820(pcVar2 + arg_8h_00[2] * 4, 0, (extraout_ECX[3] - arg_8h_00[2]) * 4);\n        arg_8h_00[2] = extraout_ECX[3];\n        (*_sym.imp.KERNEL32.dll_TlsSetValue)(*extraout_ECX, arg_8h_00);\n        iVar3 = *(unaff_EBP + 8);\n    }\n    else {\n        iVar3 = *(unaff_EBP + 8);\n        if ((arg_8h_00[2] <= iVar3) && (*(unaff_EBP + 0xc) != 0)) goto code_r0x00422587;\n    }\n    if ((arg_8h_00[3] != NULL) && (iVar3 < arg_8h_00[2])) {\n        *(arg_8h_00[3] + iVar3 * 4) = *(unaff_EBP + 0xc);\n    }\n    puVar5 = *(unaff_EBP + -0x14);\ncode_r0x00422657:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar5);\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 924
    },
    "00422f50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00422f50(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.00422d4e(arg_8h, &arg_8h, &var_4h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.00428d7b(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.00422f00();\n        puVar2[1] = iVar1;\n        *puVar2 = *(arg_8h * 4 + *(in_ECX + 4));\n        *(arg_8h * 4 + *(in_ECX + 4)) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 219
    },
    "00423342": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423342(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t Y, uint crColor)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    var_10h = arg_8h;\n    var_8h = arg_8h + arg_10h;\n    var_ch = arg_ch;\n    var_4h = arg_ch + Y;\n    (*_sym.imp.GDI32.dll_ExtTextOutW)(*(in_ECX + 4), 0, 0, 2, &var_10h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 206
    },
    "00423390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423390(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint var_4h;\n    \n    fcn.00423342(arg_8h, arg_ch, arg_10h + -1, 1, arg_18h);\n    fcn.00423342(arg_8h, arg_ch, 1, arg_14h + -1, arg_18h);\n    fcn.00423342(arg_8h + arg_10h, arg_ch, 0xffffffff, arg_14h, arg_1ch);\n    fcn.00423342(arg_8h, arg_ch + arg_14h, arg_10h, 0xffffffff, arg_1ch);\n    return;\n}\n",
        "token_count": 195
    },
    "004234be": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004234be(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint *puVar2;\n    uint32_t unaff_retaddr;\n    uint uVar3;\n    \n    uVar3 = 0;\n    iVar1 = fcn.00423436(0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = iVar1 + 0x1c;\n    if (iVar1 == 0) {\n        fcn.00407ad1(uVar3);\n        iVar1 = extraout_ECX;\n    }\n    if (*(iVar1 + 4) != 0) {\n        for (puVar2 = *(*(iVar1 + 4) + ((unaff_retaddr >> 4) % *(iVar1 + 8)) * 4); puVar2 != NULL; puVar2 = *puVar2) {\n            if (puVar2[1] == unaff_retaddr) {\n                return puVar2[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 237
    },
    "00423c2c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00423c2c(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004213cc();\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + 0x2c);\n    return;\n}\n",
        "token_count": 58
    },
    "00423e69": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00423e69(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    \n    if (0x10b < arg_8h) {\n        if (arg_8h == 0x3e3) {\n            return 10;\n        }\n        if (arg_8h == 0x3e4) {\n            return 10;\n        }\n        if (arg_8h == 0x3e5) {\n            return 10;\n        }\n        if (arg_8h != 999) {\n            return 1;\n        }\n        return 5;\n    }\n    if (arg_8h == 0x10b) {\n        return 3;\n    }\n    if (arg_8h < 0x3f) {\n        if (arg_8h == 0x3e) {\n            return 8;\n        }\n        if (arg_8h < 0x1a) {\n            if (arg_8h == 0x19) {\n                return 9;\n            }\n            if (arg_8h < 0x19) {\n    // switch table (25 cases) at 0x424079\n                switch(*(arg_8h * 4 + 0x424079)) {\n                case 0x423eaa:\n                    return 0;\n                case 0x423eb1:\n                    return 2;\n                case 0x423eb8:\n                    return 4;\n                case 0x423ebf:\n                    return 7;\n                case 0x423eef:\n                    return 9;\n                case 0x423f75:\n                    return 3;\n                case 0x423f9e:\n                    return 10;\n                case 0x423fda:\n                    return 6;\n                case 0x42402d:\n                    return 5;\n                case 0x42406f:\n                    return 1;\n                }\n            }\n            return 1;\n        }\n        if (0x27 < arg_8h) {\n            if (8 < arg_8h - 0x34) {\n                return 1;\n            }\n    // switch table (9 cases) at 0x4240dd\n            switch(*((arg_8h - 0x34) * 4 + 0x4240dd)) {\n            case 0x423f75:\n                return 3;\n            case 0x423f9e:\n                return 10;\n            case 0x423fda:\n                return 6;\n            case 0x42402d:\n                return 5;\n            case 0x42406f:\n                return 1;\n            }\n        }\n        if (arg_8h == 0x27) {\n            return 0xd;\n        }\n        if (0x20 < arg_8h) {\n            if (arg_8h == 0x21) {\n                return 0xc;\n            }\n            if (arg_8h == 0x22) {\n                return 3;\n            }\n            if (arg_8h == 0x24) {\n                return 4;\n            }\n            if (arg_8h != 0x26) {\n                return 1;\n            }\n            return 0xe;\n        }\n        if (arg_8h == 0x20) {\n            return 0xb;\n        }\n        if (arg_8h == 0x1a) {\n            return 6;\n        }\n        if (arg_8h == 0x1b) {\n            return 9;\n        }\n        iVar1 = arg_8h - 0x1d;\n        if (iVar1 == 0) {\n            return 5;\n        }\ncode_r0x00423ee8:\n        if (iVar1 == 1) {\n            return 9;\n        }\n    }\n    else {\n        if (arg_8h < 0x6c) {\n            if (arg_8h == 0x6b) {\n                return 2;\n            }\n            if (0x47 < arg_8h) {\n                if (arg_8h == 0x50) {\n                    return 5;\n                }\n                if (arg_8h == 0x52) {\n                    return 5;\n                }\n                if (arg_8h == 0x55) {\n                    return 3;\n                }\n                if (arg_8h == 0x56) {\n                    return 5;\n                }\n                if (arg_8h != 0x58) {\n                    return 1;\n                }\n                return 10;\n            }\n            if (arg_8h == 0x47) {\n                return 5;\n            }\n            if (arg_8h == 0x40) {\n                return 5;\n            }\n            if (arg_8h == 0x41) {\n                return 5;\n            }\n            if (arg_8h == 0x42) {\n                return 6;\n            }\n            if (arg_8h == 0x43) {\n                return 3;\n            }\n            iVar1 = arg_8h - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\n        }\n        else {\n            if (arg_8h < 0x91) {\n                if (arg_8h == 0x90) {\n                    return 3;\n                }\n                if (arg_8h < 0x76) {\n                    if (arg_8h == 0x75) {\n                        return 10;\n                    }\n                    if (arg_8h == 0x6c) {\n                        return 0xc;\n                    }\n                    if (arg_8h == 0x6f) {\n                        return 3;\n                    }\n                    if (arg_8h != 0x70) {\n                        if (arg_8h == 0x71) {\n                            return 4;\n                        }\n                        if (arg_8h == 0x72) {\n                            return 6;\n                        }\n                        return 1;\n                    }\n                    return 0xd;\n                }\n                if (arg_8h == 0x7b) {\n                    return 3;\n                }\n                if (arg_8h == 0x7c) {\n                    return 3;\n                }\n                if (arg_8h == 0x7d) {\n                    return 3;\n                }\n                iVar1 = arg_8h - 0x83;\n                if (iVar1 == 0) {\n                    return 9;\n                }\n                goto code_r0x00423ee8;\n            }\n            if (arg_8h < 0xb7) {\n                if (arg_8h == 0xb6) {\n                    return 6;\n                }\n                if (arg_8h == 0x91) {\n                    return 7;\n                }\n                if (arg_8h == 0x9a) {\n                    return 3;\n                }\n                if (arg_8h == 0xa1) {\n                    return 3;\n                }\n                if (arg_8h == 0xa7) {\n                    return 0xc;\n                }\n                if (arg_8h != 0xaa) {\n                    return 1;\n                }\n                return 5;\n            }\n            if (arg_8h == 0xb7) {\n                return 5;\n            }\n            if (arg_8h == 0xbf) {\n                return 6;\n            }\n            if (arg_8h == 0xc1) {\n                return 6;\n            }\n            iVar1 = arg_8h - 0xce;\n            if (iVar1 == 0) {\n                return 3;\n            }\n        }\n        if (iVar1 == 2) {\n            return 3;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 1707
    },
    "00424abd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00424abd(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t arg_14h;\n    int32_t arg_ch_00;\n    uint arg_10h_00;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    piVar1 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x10) = 0;\n    uVar2 = fcn.004110fa();\n    fcn.004110e3(uVar2);\n    arg_14h = **(unaff_EBP + 0x10);\n    uVar2 = *(arg_14h + -0xc);\n    arg_ch_00 = *piVar1;\n    arg_10h_00 = *(arg_ch_00 + -0xc);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = 1;\n    fcn.00418834(*(unaff_EBP + 8), arg_ch_00, arg_10h_00, arg_14h, uVar2);\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 334
    },
    "00426fa8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00426fa8(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    \n    if (*(arg_8h + 2) == -1) {\n        piVar2 = arg_8h + 0x1a;\n    }\n    else {\n        piVar2 = arg_8h + 0x12;\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 257
    },
    "00429214": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00429214(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.0041512f(arg_8h);\n    if (((iVar1 == 0) && ((*(in_ECX + 0x108) == 0 || (iVar1 = fcn.0041512f(arg_8h),  iVar1 == 0)))) &&\n       ((*(in_ECX + 0x10c) == 0 || (iVar1 = fcn.0041512f(arg_8h),  iVar1 == 0)))) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = fcn.004151c4(arg_8h);\n    }\n    return uVar2;\n}\n",
        "token_count": 184
    },
    "00429563": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00429563(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = (**(*in_ECX + 0x144))();\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_CopyRect)(&var_10h, arg_ch);\n        arg_8h = (*_sym.imp.USER32.dll_GetParent)(in_ECX[8]);\n        fcn.0040d45d(arg_8h);\n        fcn.00409b04(&var_10h);\n        fcn.00409ac3(&var_10h);\n        piVar2 = fcn.00410902(0xe900);\n        var_20h = in_ECX[0x4c];\n        var_1ch = in_ECX[0x4d];\n        var_18h = in_ECX[0x4e];\n        var_14h = in_ECX[0x4f];\n        (**(*piVar2 + 0x68))(&var_20h, 1);\n        var_10h = var_10h + (in_ECX[0x4c] - var_20h);\n        var_ch = var_ch + (in_ECX[0x4d] - var_1ch);\n        var_8h = var_8h + (in_ECX[0x4e] - var_18h);\n        var_4h = var_4h + (in_ECX[0x4f] - var_14h);\n        (**(*in_ECX + 0x1b0))(&var_10h);\n    }\n    return 0;\n}\n",
        "token_count": 463
    },
    "004297f6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004297f6(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    iVar1 = fcn.0041512f(*(arg_8h + 4));\n    if (((iVar1 == 0) && ((*(in_ECX + 0x108) == 0 || (iVar1 = fcn.0041512f(*(arg_8h + 4)),  iVar1 == 0)))) &&\n       ((*(in_ECX + 0x10c) == 0 || (iVar1 = fcn.0041512f(*(arg_8h + 4)),  iVar1 == 0)))) {\n        *(arg_8h + 0x1c) = 1;\n    }\n    else {\n        fcn.00415181(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 194
    },
    "00429939": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00429939(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar8 = arg_ch * arg_10h;\n    iVar4 = iVar8 >> 0x20;\n    iVar1 = iVar8;\n    iVar7 = arg_14h * arg_18h;\n    iVar5 = iVar7 >> 0x20;\n    iVar9 = iVar8;\n    if ((iVar4 == 0 || iVar8 < 0) && (iVar8 < 0)) {\n        iVar9 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    iVar6 = 0;\n    while (iVar9 != 0) {\n        iVar9 = fcn.00432330();\n        iVar6 = iVar6 + 1;\n    }\n    iVar2 = arg_8h;\n    if (arg_8h < 0) {\n        iVar2 = -arg_8h;\n    }\n    arg_ch = 0;\n    iVar9 = iVar2;\n    while (iVar9 != 0) {\n        iVar9 = fcn.00432330();\n        arg_ch = arg_ch + 1;\n    }\n    iVar6 = iVar6 + arg_ch;\n    if ((iVar5 == 0 || iVar7 < 0) && (iVar7 < 0)) {\n        iVar7 = CONCAT44(-(iVar5 + (iVar7 != 0)), -iVar7);\n        iVar8 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    while (0x1f < iVar6) {\n        iVar8 = fcn.00432330();\n        iVar7 = fcn.00432330();\n        iVar1 = iVar6 + -2;\n        if (iVar6 + -1 < 0x20) break;\n        iVar8 = fcn.00432330();\n        iVar7 = fcn.00432330();\n        iVar6 = iVar6 + -3;\n        if (iVar1 < 0x20) break;\n        arg_8h = arg_8h >> 1;\n        iVar7 = fcn.00432330();\n    }\n    iVar8 = fcn.00431620(arg_8h, arg_8h >> 0x1f, iVar8);\n    if (iVar7 == 0) {\n        if ((iVar8 < 0x100000000) && (iVar8 < 0)) {\n            uVar3 = 0x80000000;\n        }\n        else {\n            uVar3 = 0x7fffffff;\n        }\n    }\n    else {\n        iVar9 = fcn.004321b0(iVar7, 2, 0);\n        uVar3 = fcn.004321b0(iVar9 + iVar8, iVar7);\n    }\n    return uVar3;\n}\n",
        "token_count": 715
    },
    "00429ba8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00429ba8(int32_t arg_8h, uint32_t arg_ch, int32_t *arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint32_t uVar1;\n    uint32_t extraout_EDX;\n    \n    uVar1 = 0;\n    if (arg_18h == 0) {\n        fcn.00407ad1();\n        uVar1 = extraout_EDX;\n    }\n    arg_8h = arg_8h - arg_14h;\n    do {\n        if (arg_ch <= uVar1) {\n            arg_18h = (arg_8h / arg_18h + 1) * arg_18h;\ncode_r0x00429bdd:\n            return arg_18h + arg_14h;\n        }\n        if (*arg_10h != arg_8h && arg_8h <= *arg_10h) {\n            arg_18h = *arg_10h;\n            goto code_r0x00429bdd;\n        }\n        uVar1 = uVar1 + 1;\n        arg_10h = arg_10h + 1;\n    } while( true );\n}\n",
        "token_count": 272
    },
    "0042a867": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a867(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t nRightRect;\n    int32_t nBottomRect;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    nRightRect = param_1;\n    nBottomRect = param_1;\n    iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(param_1 + 8), 10);\n    nRightRect = (*pcVar1)(*(param_1 + 8), 8);\n    nBottomRect = iVar2;\n    fcn.0042a345(&nRightRect);\n    (*_sym.imp.GDI32.dll_SetMapMode)(*(param_1 + 4), 1);\n    (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), 0, 0, 0);\n    (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), *(param_1 + 0x20), *(param_1 + 0x24), 0);\n    (*_sym.imp.GDI32.dll_IntersectClipRect)(*(param_1 + 4), 0xffffffff, 0xffffffff, nRightRect + 2, nBottomRect + 2);\n    fcn.0042a768(0);\n    return;\n}\n",
        "token_count": 312
    },
    "0042bf16": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: pv\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0042bf16(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint arg_8h_00;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint pv;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(8);\n    *(unaff_EBP + -0x14) = 0;\n    if (*(extraout_ECX + 0x78) == 1) {\n        if (*(extraout_ECX + 0x20) != 0) {\n            iVar1 = (**(**(extraout_ECX + 0x80) + 0x40))(*(extraout_ECX + 0x80), unaff_EBP + -0x14);\n            fcn.00402680();\n            *(unaff_EBP + -4) = 0;\n            if (-1 < iVar1) {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x14));\n            }\ncode_r0x0042bf6a:\n            fcn.0040d34f(0xffffffff);\n            fcn.004052f0(unaff_EBP + -0x10);\n            fcn.00401020();\n            goto code_r0x0042bffe;\n        }\n    }\n    else if (((*(*(extraout_ECX + 0x74) + 0x34) & 0x80000) != 0) && (*(extraout_ECX + 0x20) != 0)) {\n        fcn.00401890();\n        *(unaff_EBP + -4) = 1;\n        uVar2 = fcn.004019b0(0x104);\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetParent)(*(extraout_ECX + 0x20));\n        iVar1 = fcn.0040d45d(arg_8h_00);\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageW)(*(iVar1 + 0x20), 0x464, 0x104, uVar2);\n        if (-1 < iVar1) goto code_r0x0042bf6a;\n        fcn.00401a10();\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00401020();\n    }\n    fcn.00402680(*(*(extraout_ECX + 0x74) + 0x24));\ncode_r0x0042bffe:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 628
    },
    "0042c162": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: pszPath\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_34h\n\nvoid fcn.0042c162(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    ushort *arg_8h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint pszPath;\n    uint var_4h;\n    \n    fcn.00430e9b(0x28);\n    if (*(extraout_ECX + 0x78) != 1) goto code_r0x0042c4d7;\n    iVar2 = (**(**(extraout_ECX + 0x80) + 0x50))(*(extraout_ECX + 0x80), unaff_EBP + -0x28);\n    if (iVar2 < 0) {\n        if ((*(*(extraout_ECX + 0x74) + 0x34) & 0x200) != 0) {\n            puVar1 = *(extraout_ECX + 0x80);\n            *(unaff_EBP + -0x24) = 0;\n            iVar2 = (***puVar1)();\n            if (-1 < iVar2) {\n                *(unaff_EBP + -0x20) = 0;\n                iVar2 = (**(**(unaff_EBP + -0x24) + 0x6c))();\n                if (-1 < iVar2) {\n                    iVar2 = (**(**(unaff_EBP + -0x20) + 0x24))(*(unaff_EBP + -0x20), unaff_EBP + -0x1c);\n                    if (-1 < iVar2) {\n                        *(unaff_EBP + -0x2c) = 0;\n                        iVar2 = (**(**(unaff_EBP + -0x1c) + 0xc))\n                                          (*(unaff_EBP + -0x1c), 1, unaff_EBP + -0x18, unaff_EBP + -0x2c);\n                        if (iVar2 == 0) {\n                            fcn.00401890();\n                            iVar2 = *(extraout_ECX + 0x74);\n                            *(unaff_EBP + -4) = 1;\n                            arg_8h = *(iVar2 + 0x1c);\n                            *(unaff_EBP + -0x10) = 0;\n                            iVar2 = (**(**(unaff_EBP + -0x18) + 0x14))\n                                              (*(unaff_EBP + -0x18), 0x80058000, unaff_EBP + -0x10);\n                            if (-1 < iVar2) {\n                                (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(*(unaff_EBP + -0x10));\n                                fcn.004312b8(arg_8h, *(*(extraout_ECX + 0x74) + 0x20) + -1, *(unaff_EBP + -0x10), \n                                             0xffffffff);\n                                iVar2 = fcn.00430fa5(*(unaff_EBP + -0x10));\n                                arg_8h = arg_8h + iVar2 + 1;\n                                (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x10));\n                            }\n                            do {\n                                *(unaff_EBP + -0x10) = 0;\n                                iVar2 = (**(**(unaff_EBP + -0x18) + 0x14))\n                                                  (*(unaff_EBP + -0x18), 0x80058000, unaff_EBP + -0x10);\n                                if (-1 < iVar2) {\n                                    fcn.004029f0(*(unaff_EBP + -0x10));\n                                    uVar3 = fcn.004157fc();\n                                    (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(uVar3);\n                                    fcn.0040d34f(0xffffffff);\n                                    iVar2 = *(*(unaff_EBP + -0x14) + -0xc);\n                                    if (*(*(unaff_EBP + -0x10) + iVar2 * 2) == 0x5c) {\n                                        iVar2 = iVar2 + 1;\n                                    }\n                                    fcn.004312b8(arg_8h, (*(*(extraout_ECX + 0x74) + 0x20) -\n                                                         (arg_8h - *(*(extraout_ECX + 0x74) + 0x1c) >> 1)) + -1, \n                                                 iVar2 * 2 + *(unaff_EBP + -0x10), 0xffffffff);\n                                    iVar2 = fcn.00430fa5(iVar2 * 2 + *(unaff_EBP + -0x10));\n                                    arg_8h = arg_8h + iVar2 + 1;\n                                    (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x10));\n                                }\n                                (**(**(unaff_EBP + -0x18) + 8))(*(unaff_EBP + -0x18));\n                                if (*(*(extraout_ECX + 0x74) + 0x1c) + -2 + *(*(extraout_ECX + 0x74) + 0x20) * 2 <=\n                                    arg_8h) break;\n                                iVar2 = (**(**(unaff_EBP + -0x1c) + 0xc))\n                                                  (*(unaff_EBP + -0x1c), 1, unaff_EBP + -0x18, unaff_EBP + -0x2c);\n                            } while (iVar2 == 0);\n                            if (arg_8h < *(*(extraout_ECX + 0x74) + 0x1c) + -2 + *(*(extraout_ECX + 0x74) + 0x20) * 2) {\n                                *arg_8h = 0;\n                            }\n                            else {\n                                *(*(*(extraout_ECX + 0x74) + 0x1c) + -4 + *(*(extraout_ECX + 0x74) + 0x20) * 2) = 0;\n                                *(*(*(extraout_ECX + 0x74) + 0x1c) + -2 + *(*(extraout_ECX + 0x74) + 0x20) * 2) = 0;\n                            }\n                            *(unaff_EBP + -4) = 0xffffffff;\n                            fcn.00401020();\n                        }\n                        (**(**(unaff_EBP + -0x1c) + 8))(*(unaff_EBP + -0x1c));\n                    }\n                    (**(**(unaff_EBP + -0x20) + 8))(*(unaff_EBP + -0x20));\n                }\n                piVar5 = *(unaff_EBP + -0x24);\n                goto code_r0x0042c43d;\n            }\n        }\n    }\n    else {\n        *(unaff_EBP + -0x10) = 0;\n        iVar2 = (**(**(unaff_EBP + -0x28) + 0x14))();\n        if (-1 < iVar2) {\n            fcn.00402680(*(unaff_EBP + -0x10));\n            *(unaff_EBP + -4) = 0;\n            uVar3 = fcn.004157fc();\n            (*_sym.imp.SHLWAPI.dll_PathRemoveFileSpecW)(uVar3);\n            fcn.0040d34f(0xffffffff);\n            iVar2 = *(*(unaff_EBP + -0x14) + -0xc);\n            if (*(*(unaff_EBP + -0x10) + iVar2 * 2) == 0x5c) {\n                iVar2 = iVar2 + 1;\n            }\n            fcn.004312b8(*(*(extraout_ECX + 0x74) + 0x1c), *(*(extraout_ECX + 0x74) + 0x20) + -1, *(unaff_EBP + -0x10), \n                         0xffffffff);\n            fcn.004312b8(*(*(extraout_ECX + 0x74) + 0x24), *(*(extraout_ECX + 0x74) + 0x28), \n                         *(unaff_EBP + -0x10) + iVar2 * 2, 0xffffffff);\n            iVar2 = *(extraout_ECX + 0x74);\n            iVar4 = fcn.00430fa5(*(iVar2 + 0x1c));\n            *(*(iVar2 + 0x1c) + 2 + iVar4 * 2) = 0;\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x10));\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00401020();\n        }\n        piVar5 = *(unaff_EBP + -0x28);\ncode_r0x0042c43d:\n        (**(*piVar5 + 8))(piVar5);\n    }\n    piVar5 = fcn.0042bd59(unaff_EBP + -0x24);\n    *(unaff_EBP + -4) = 2;\n    piVar6 = fcn.0042bf16(unaff_EBP + -0x2c);\n    *(*(extraout_ECX + 0x74) + 0x38) = *(*piVar5 + -0xc) - *(*piVar6 + -0xc);\n    fcn.00401020();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00401020();\n    piVar5 = fcn.0042bd59(unaff_EBP + -0x34);\n    *(unaff_EBP + -4) = 3;\n    piVar6 = fcn.0042c009(unaff_EBP + -0x30);\n    *(*(extraout_ECX + 0x74) + 0x3a) = *(*piVar5 + -0xc) - *(*piVar6 + -0xc);\n    fcn.00401020();\n    fcn.00401020();\ncode_r0x0042c4d7:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 2544
    },
    "0042c52c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: lpClassName\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042c52c(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint lpClassName;\n    uint var_4h;\n    \n    fcn.00430e9b(0xc);\n    fcn.004213cc();\n    fcn.004214b9(1);\n    *(unaff_EBP + -0x14) = 0;\n    fcn.00411d9c(unaff_EBP + -0x10, 0x44d0e8, unaff_EBP + -0x14);\n    *(unaff_EBP + -4) = 0;\n    while (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n        iVar1 = fcn.004213cc();\n        (*_sym.imp.USER32.dll_UnregisterClassW)(*(unaff_EBP + -0x10), *(iVar1 + 8));\n        uVar2 = fcn.00411d9c(unaff_EBP + -0x18, 0x44d0e8, unaff_EBP + -0x14);\n        *(unaff_EBP + -4) = 1;\n        fcn.00401930(uVar2);\n        *(unaff_EBP + -4) = 0;\n        fcn.00401020();\n    }\n    fcn.00401a10();\n    fcn.0042152b(1);\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 422
    },
    "0042c8ee": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c8ee(int32_t arg_8h, uint *arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar2 = *(in_ECX + 8);\n            fcn.0041c329(iVar2 + arg_10h, 0xffffffff);\n            iVar2 = (iVar2 - arg_8h) * 4;\n            fcn.00421a61(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, iVar2, *(in_ECX + 4) + arg_8h * 4, iVar2);\n            fcn.00430820(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n        }\n        else {\n            fcn.0041c329(arg_8h + arg_10h, 0xffffffff);\n        }\n        arg_8h = arg_8h << 2;\n        do {\n            arg_10h = arg_10h + -1;\n            *(arg_8h + *(in_ECX + 4)) = *arg_ch;\n            arg_8h = arg_8h + 4;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.00407ad1();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 375
    },
    "0042d09d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d09d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    \n    iVar1 = arg_8h;\n    iVar4 = 0;\n    if (-1 < arg_8h) goto code_r0x0042d0b5;\n    do {\n        fcn.00407ad1();\ncode_r0x0042d0b5:\n        if (iVar4 <= arg_ch) {\n            *(in_ECX + 0x10) = arg_ch;\n        }\n        if (iVar1 == iVar4) {\n            fcn.0040644a(*(in_ECX + 4));\n            *(in_ECX + 0xc) = iVar4;\n            *(in_ECX + 8) = iVar4;\n            goto code_r0x0042d1b9;\n        }\n        if (*(in_ECX + 4) == iVar4) {\n            uVar2 = fcn.0040641b(iVar1 << 2);\n            *(in_ECX + 4) = uVar2;\n            fcn.00430820(uVar2, 0, iVar1 << 2);\n            *(in_ECX + 0xc) = iVar1;\ncode_r0x0042d121:\n            *(in_ECX + 8) = iVar1;\n            return;\n        }\n        iVar4 = *(in_ECX + 0xc);\n        if (iVar1 <= iVar4) {\n            iVar4 = *(in_ECX + 8);\n            if (iVar4 < iVar1) {\n                fcn.00430820(*(in_ECX + 4) + iVar4 * 4, 0, (iVar1 - iVar4) * 4);\n            }\n            goto code_r0x0042d121;\n        }\n        iVar3 = *(in_ECX + 0x10);\n        if (iVar3 == 0) {\n            iVar3 = *(in_ECX + 8) + (*(in_ECX + 8) >> 0x1f & 7U) >> 3;\n            if (iVar3 < 4) {\ncode_r0x0042d153:\n                iVar3 = 4;\n            }\n            else if (iVar3 < 0x401) {\n                if (iVar3 < 4) goto code_r0x0042d153;\n            }\n            else {\n                iVar3 = 0x400;\n            }\n        }\n        arg_8h = iVar3 + iVar4;\n        if (iVar3 + iVar4 <= iVar1) {\n            arg_8h = iVar1;\n        }\n    } while (arg_8h < iVar4);\n    iVar4 = fcn.0040641b(arg_8h << 2);\n    fcn.00408f79(iVar4, arg_8h << 2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.00430820(iVar4 + *(in_ECX + 8) * 4, 0, (iVar1 - *(in_ECX + 8)) * 4);\n    fcn.0040644a(*(in_ECX + 4));\n    *(in_ECX + 8) = iVar1;\n    *(in_ECX + 0xc) = arg_8h;\ncode_r0x0042d1b9:\n    *(in_ECX + 4) = iVar4;\n    return;\n}\n",
        "token_count": 784
    },
    "0042d1c3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d1c3(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    \n    if ((-1 < arg_8h) && (0 < arg_10h)) {\n        if (arg_8h < *(in_ECX + 8)) {\n            iVar1 = *(in_ECX + 8);\n            fcn.0042d09d(iVar1 + arg_10h, 0xffffffff);\n            fcn.00421a61(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, ((*(in_ECX + 8) - arg_8h) - arg_10h) * 4, \n                         *(in_ECX + 4) + arg_8h * 4, (iVar1 - arg_8h) * 4);\n            fcn.00430820(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n        }\n        else {\n            fcn.0042d09d(arg_8h + arg_10h, 0xffffffff);\n        }\n        arg_8h = arg_8h << 2;\n        do {\n            arg_10h = arg_10h + -1;\n            *(arg_8h + *(in_ECX + 4)) = arg_ch;\n            arg_8h = arg_8h + 4;\n        } while (arg_10h != 0);\n        return;\n    }\n    fcn.00407ad1();\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 393
    },
    "0042e162": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e162(uint arg_8h, uint arg_ch)\n\n{\n    fcn.0042e10b(fcn.00433b26, arg_8h, 0, arg_ch);\n    return;\n}\n",
        "token_count": 54
    },
    "0042f0cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f0cd(uint arg_8h)\n\n{\n    fcn.00438f5d(arg_8h, 0, 10);\n    return;\n}\n",
        "token_count": 43
    },
    "004316bf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004316bf(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    fcn.00431654(fcn.0043a427, arg_10h, 0, &arg_14h);\n    return;\n}\n",
        "token_count": 66
    },
    "004319ff": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004319ff(uint arg_8h)\n\n{\n    fcn.004318d3(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 40
    },
    "00432136": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.00432136(void)\n\n{\n    uint64_t uVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    float fVar4;\n    float10 in_ST0;\n    uint32_t uStack32;\n    float fStack28;\n    \n    uVar1 = ROUND(in_ST0);\n    uStack32 = uVar1;\n    fStack28 = uVar1 >> 0x20;\n    fVar4 = in_ST0;\n    if ((uStack32 != 0) || (fVar4 = fStack28,  (uVar1 & 0x7fffffff00000000) != 0)) {\n        if (fVar4 < 0) {\n            uVar2 = 0x80000000 < (in_ST0 - uVar1 ^ 0x80000000);\n            bVar3 = CARRY4(uStack32, uVar2);\n            uStack32 = uStack32 + uVar2;\n            fStack28 = fStack28 + bVar3;\n        }\n        else {\n            uVar2 = 0x80000000 < in_ST0 - uVar1;\n            bVar3 = uStack32 < uVar2;\n            uStack32 = uStack32 - uVar2;\n            fStack28 = fStack28 - bVar3;\n        }\n    }\n    return CONCAT44(fStack28, uStack32);\n}\n",
        "token_count": 305
    },
    "00432d44": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00432d58)\n// WARNING: Removing unreachable block (ram,0x00432d5e)\n// WARNING: Removing unreachable block (ram,0x00432d60)\n\nvoid fcn.00432d44(void)\n\n{\n    return;\n}\n",
        "token_count": 65
    },
    "00436e06": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00436e06(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (arg_8h == NULL) {\n        puVar1 = fcn.0043147b();\n        *puVar1 = 0x16;\n        fcn.0043399c(0, 0, 0, 0, 0);\n        uVar2 = 0x16;\n    }\n    else {\n        *arg_8h = *0x45c64c;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 138
    },
    "00436e3f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00436e3f(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (arg_8h == NULL) {\n        puVar1 = fcn.0043147b();\n        *puVar1 = 0x16;\n        fcn.0043399c(0, 0, 0, 0, 0);\n        uVar2 = 0x16;\n    }\n    else {\n        *arg_8h = *0x45c650;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 138
    },
    "00436e78": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00436e78(uint *arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (arg_8h == NULL) {\n        puVar1 = fcn.0043147b();\n        *puVar1 = 0x16;\n        fcn.0043399c(0, 0, 0, 0, 0);\n        uVar2 = 0x16;\n    }\n    else {\n        *arg_8h = *0x45c648;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 137
    },
    "00443dc4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00443dc4(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    arg_8h_00 = *(unaff_EBP + 8);\n    fcn.0042edd5(arg_8h_00);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.std::logic_error.0;\n    fcn.00443d99(arg_8h_00 + 0xc);\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 201
    },
    "00443e57": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00443e57(uint param_1)\n\n{\n    fcn.00430820(param_1, 0, 0x18);\n    return param_1;\n}\n",
        "token_count": 43
    },
    "00430b42": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00430b42(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00439ee4(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 111
    },
    "0040672c": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040672c(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 126
    },
    "00406810": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00406810(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.004213cc();\n    *(param_1 + 0x1c) = uVar1;\n    *(param_1 + 4) = 1;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x18) = 0;\n    return param_1;\n}\n",
        "token_count": 148
    },
    "00407a6e": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00407a6e(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.00410bdc(*(param_1 + 0x114), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 99
    },
    "00409de3": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00409de3(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint arg_8h_00;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[1] = NULL;\n    extraout_ECX[2] = NULL;\n    extraout_ECX[3] = NULL;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CPaintDC.0;\n    pcVar1 = *(iVar2 + 0x20);\n    extraout_ECX[4] = pcVar1;\n    arg_8h_00 = (*_sym.imp.USER32.dll_BeginPaint)(pcVar1, extraout_ECX + 5);\n    iVar2 = fcn.00409c43(arg_8h_00);\n    if (iVar2 == 0) {\n        fcn.004096be();\n    }\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 302
    },
    "0040ee18": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0040ee18(code **param_1)\n\n{\n    param_1[5] = NULL;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    fcn.00423c2c();\n    return param_1;\n}\n",
        "token_count": 146
    },
    "00414027": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00414027(int32_t param_1)\n\n{\n    uint *puVar1;\n    \n    for (puVar1 = *(param_1 + 4); puVar1 != NULL; puVar1 = *puVar1) {\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00424365();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 141
    },
    "0041587c": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041587c(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[2] = NULL;\n    in_ECX[1] = NULL;\n    in_ECX[5] = NULL;\n    *in_ECX = vtable.CList_struct_HWND_____struct_HWND____.0;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 115
    },
    "00417bdd": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.00417bdd(code **param_1)\n\n{\n    *param_1 = vtable.CCommandLineInfo.0;\n    fcn.00401890();\n    fcn.00401890();\n    fcn.00401890();\n    fcn.00401890();\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    param_1[1] = 0x1;\n    return param_1;\n}\n",
        "token_count": 124
    },
    "00422d03": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422d03(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.0040644a(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00424365();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 121
    },
    "00422ec2": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00422ec2(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    *in_ECX = vtable.CMapPtrToPtr.0;\n    if (arg_8h < 1) {\n        arg_8h = 0xa;\n    }\n    in_ECX[1] = NULL;\n    in_ECX[2] = 0x11;\n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[5] = NULL;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 137
    },
    "00423d84": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423d84(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[2] = NULL;\n    in_ECX[1] = NULL;\n    in_ECX[5] = NULL;\n    *in_ECX = vtable.CPtrList.0;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 108
    },
    "0042dd78": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042dd78(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00424365();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 101
    },
    "00428ddf": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428ddf(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    *in_ECX = vtable.CMapStringToPtr.0;\n    if (arg_8h < 1) {\n        arg_8h = 0xa;\n    }\n    in_ECX[1] = NULL;\n    in_ECX[2] = 0x11;\n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[5] = NULL;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 136
    },
    "00428f17": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428f17(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    uVar2 = 0;\n    if (*(param_1 + 4) != 0) {\n        if (*(param_1 + 8) != 0) {\n            do {\n                for (puVar3 = *(*(param_1 + 4) + uVar2 * 4); puVar3 != NULL; puVar3 = *puVar3) {\n                    if (puVar3 == 0xfffffff8) {\n                        fcn.00407ad1();\n                        pcVar1 = swi(3);\n                        (*pcVar1)();\n                        return;\n                    }\n                    fcn.0041c58c(0);\n                }\n                uVar2 = uVar2 + 1;\n            } while (uVar2 < *(param_1 + 8));\n        }\n        fcn.0040644a(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00424365();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 298
    },
    "0042dda0": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042dda0(code *arg_8h)\n\n{\n    code **in_ECX;\n    \n    in_ECX[3] = NULL;\n    in_ECX[4] = NULL;\n    in_ECX[2] = NULL;\n    in_ECX[1] = NULL;\n    in_ECX[5] = NULL;\n    *in_ECX = vtable.CObList.0;\n    in_ECX[6] = arg_8h;\n    return;\n}\n",
        "token_count": 108
    },
    "00443eec": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00443eec(uint *param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.00443eb8();\n    *param_1 = 0x38;\n    param_1[2] = 0x400000;\n    param_1[1] = 0x400000;\n    param_1[3] = 0x900;\n    param_1[4] = 0x44f708;\n    iVar1 = fcn.00443e6d();\n    if (iVar1 < 0) {\n        *0x4604a5 = 1;\n    }\n    return param_1;\n}\n",
        "token_count": 146
    },
    "00408a6f": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408a6f(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *(in_ECX + 0x5c) = 0xffffffff;\n    *(in_ECX + 0x60) = arg_8h;\n    *(in_ECX + 100) = arg_ch;\n    if (*(in_ECX + 0x20) != 0) {\n        uVar1 = fcn.004109b6();\n        if ((uVar1 & 0x300000) != 0) {\n            fcn.0040bf62(0, 0, 1);\n            fcn.0040bf62(1, 0, 1);\n            fcn.0040c02d(3, 0);\n        }\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x20), &lpRect);\n    *(in_ECX + 0x68) = var_8h - lpRect;\n    *(in_ECX + 0x6c) = var_4h - var_ch;\n    if (*(in_ECX + 0x20) != 0) {\n        fcn.004083e5();\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x20), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 346
    },
    "0040c071": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040c071(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    int32_t var_14h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.0040bff9(arg_8h, &var_8h, &var_4h);\n    iVar1 = fcn.0040b2df(arg_8h, &var_24h, 2);\n    if (iVar1 != 0) {\n        var_4h = var_4h - (-(var_14h != 1) & var_14h - 1U);\n    }\n    return var_4h;\n}\n",
        "token_count": 162
    },
    "00414420": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00414420(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint in_ECX;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = in_ECX;\n    if (arg_8h != NULL) goto code_r0x0041443c;\n    do {\n        fcn.00407ad1();\ncode_r0x0041443c:\n    } while (*arg_8h == 0);\n    piVar1 = fcn.00407558();\n    if (piVar1 != NULL) {\n        var_14h = 0;\n        var_10h = 0;\n        var_ch = 0;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x54))(0, 0, 0x50800000, &var_14h, var_4h, arg_ch, arg_8h);\n        if (iVar2 != 0) {\n            uVar3 = fcn.004109d0();\n            if ((uVar3 & 0x200) == 0) {\n                return piVar1;\n            }\n            fcn.00410a16(0x200, 0, 0x20);\n            return piVar1;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 340
    },
    "0041cbc6": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0041cbc6(int32_t hgdiobj)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint lpvObject;\n    int32_t var_30h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_GetObjectW)(hgdiobj, 0x18, &lpvObject);\n    arg_8h = in_ECX + 0x28;\n    if (*arg_8h == 0) {\n        var_8h = 0;\n        var_4h = hgdiobj;\n        iVar1 = (**(*in_ECX + 0x118))(0x413, var_30h / in_ECX[0x2a], &var_8h);\n        uVar2 = iVar1 == 0;\n    }\n    else {\n        var_ch = var_30h / in_ECX[0x2a];\n        var_1ch = 0;\n        var_14h = 0;\n        var_10h = hgdiobj;\n        var_18h = *arg_8h;\n        uVar2 = (**(*in_ECX + 0x118))(0x42e, 0, &var_1ch);\n    }\n    if (uVar2 != 0) {\n        fcn.004215e9(arg_8h);\n        *arg_8h = hgdiobj;\n    }\n    return uVar2;\n}\n",
        "token_count": 388
    },
    "0041ffa0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nbool fcn.0041ffa0(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    iVar1 = fcn.0042224f(0x41fe5e);\n    if (iVar1 != 0) goto code_r0x0041ffe1;\n    fcn.00407ad1();\n    do {\n        iVar2 = (*_sym.imp.USER32.dll_PeekMessageW)(&lpMsg, 0, 0, 0, 0);\n        if (iVar2 == 0) break;\n        iVar2 = fcn.0041ab8f();\n        if (iVar2 == 0) {\n            return false;\n        }\ncode_r0x0041ffe1:\n    } while (*(iVar1 + 4) == 0);\n    return *(iVar1 + 4) == 0;\n}\n",
        "token_count": 192
    },
    "00404030": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00404030(int32_t param_1, char *param_2)\n\n{\n    char cVar1;\n    char *pcVar2;\n    \n    *(param_1 + 0x18) = 0xf;\n    *(param_1 + 0x14) = 0;\n    *(param_1 + 4) = 0;\n    pcVar2 = param_2;\n    do {\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + 1;\n    } while (cVar1 != '\\0');\n    fcn.004041d0(param_2, pcVar2 - (param_2 + 1));\n    return param_1;\n}\n",
        "token_count": 161
    },
    "00404340": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00404340(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x14) = param_2;\n    if (0xf < *(param_1 + 0x18)) {\n        *(*(param_1 + 4) + param_2) = 0;\n        return;\n    }\n    *(param_1 + 4 + param_2) = 0;\n    return;\n}\n",
        "token_count": 104
    },
    "0041aa21": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041aa21(int32_t arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = *(arg_8h + 4);\n    if ((iVar2 == 0x200) || (iVar2 == 0xa0)) {\n        iVar2 = fcn.00420e14();\n        iVar3 = fcn.0041a96e(*(arg_8h + 0x14), *(arg_8h + 0x18));\n        if ((iVar3 == 0) || (*(arg_8h + 4) != *(iVar2 + 0x54))) {\n            *(iVar2 + 0x4c) = *(arg_8h + 0x14);\n            *(iVar2 + 0x50) = *(arg_8h + 0x18);\n            *(iVar2 + 0x54) = *(arg_8h + 4);\n            uVar1 = 1;\n        }\n        else {\n            uVar1 = 0;\n        }\n    }\n    else if ((iVar2 == 0xf) || (iVar2 == 0x118)) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 294
    },
    "0042122c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0042122c(uint arg_8h)\n\n{\n    uchar uVar1;\n    uint *puVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.00430ece(0xc);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_STATE.0;\n    extraout_ECX[7] = NULL;\n    extraout_ECX[8] = NULL;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[10] = NULL;\n    fcn.00401890();\n    extraout_ECX[0x10] = NULL;\n    extraout_ECX[0x11] = NULL;\n    extraout_ECX[0x14] = 0xffffffff;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0x15] = NULL;\n    extraout_ECX[0x1a] = NULL;\n    extraout_ECX[0x1b] = NULL;\n    uVar1 = *(unaff_EBP + 8);\n    extraout_ECX[10] = 0x20;\n    extraout_ECX[8] = 0x14;\n    extraout_ECX[6] = NULL;\n    *(extraout_ECX + 5) = uVar1;\n    *(unaff_EBP + -4) = 2;\n    fcn.004019b0(0x1000);\n    *(unaff_EBP + -4) = 1;\n    extraout_ECX[0xc] = 0x1;\n    extraout_ECX[0x11] = 0x18;\n    pcVar3 = fcn.0040641b(0xc);\n    extraout_ECX[0x1e] = pcVar3;\n    iVar4 = fcn.004221af(0x188);\n    *(unaff_EBP + 8) = iVar4;\n    *(unaff_EBP + -4) = 4;\n    if (iVar4 == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = fcn.00420f3e();\n    }\n    puVar2 = extraout_ECX[0x1e];\n    *(unaff_EBP + -4) = 1;\n    *puVar2 = uVar5;\n    iVar4 = fcn.004221af(100);\n    *(unaff_EBP + 8) = iVar4;\n    *(unaff_EBP + -4) = 5;\n    if (iVar4 == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = fcn.00421162();\n    }\n    pcVar3 = extraout_ECX[0x1e];\n    *(unaff_EBP + -4) = 1;\n    *(pcVar3 + 4) = uVar5;\n    iVar4 = fcn.004221af(0x14);\n    *(unaff_EBP + 8) = iVar4;\n    *(unaff_EBP + -4) = 6;\n    if (iVar4 == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = fcn.004211e5();\n    }\n    *(extraout_ECX[0x1e] + 8) = uVar5;\n    extraout_ECX[0x1f] = 0x1;\n    extraout_ECX[0x20] = NULL;\n    extraout_ECX[0x21] = NULL;\n    extraout_ECX[0x22] = NULL;\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 878
    },
    "00422fd7": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.00422fd7(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    int32_t arg_ch_00;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    pcVar1 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.CHandleMap.0;\n    fcn.0042c837(*(pcVar1 + 4), 0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.00422ec2(10);\n    *(unaff_EBP + -4) = 1;\n    fcn.00422ec2(4);\n    arg_ch_00 = 0;\n    *(unaff_EBP + -4) = 2;\n    if (*(unaff_EBP + 0xc) != 0) goto code_r0x0042302c;\n    do {\n        arg_ch_00 = fcn.00407ad1();\ncode_r0x0042302c:\n    } while (*(unaff_EBP + 0x10) == arg_ch_00);\n    fcn.00428d7b(7, arg_ch_00);\n    extraout_ECX[5] = *(unaff_EBP + 0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x10);\n    extraout_ECX[0x16] = *(unaff_EBP + 0x14);\n    extraout_ECX[0x17] = *(unaff_EBP + 0x18);\n    extraout_ECX[0x15] = pcVar1;\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 473
    },
    "00410d75": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410d75(int32_t arg_8h)\n\n{\n    int32_t *in_ECX;\n    \n    fcn.00423e14(arg_8h);\n    *(arg_8h + 0x54) = in_ECX;\n    (**(*in_ECX + 0x68))();\n    return;\n}\n",
        "token_count": 77
    },
    "00410d9a": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410d9a(int32_t arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t *in_ECX;\n    \n    arg_8h_00 = fcn.00423d5b(arg_8h, 0);\n    fcn.00423d16(arg_8h_00);\n    *(arg_8h + 0x54) = 0;\n    (**(*in_ECX + 0x68))();\n    return;\n}\n",
        "token_count": 112
    },
    "0041525f": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041525f(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (arg_8h == NULL) {\n        fcn.00407ad1();\n    }\n    iVar1 = fcn.0040700d();\n    if (iVar1 == in_ECX) {\n        (**(*arg_8h + 4))(*(in_ECX + 0x68) != 0);\n    }\n    else {\n        arg_8h[7] = 1;\n    }\n    return;\n}\n",
        "token_count": 130
    },
    "00418c19": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a",
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00418c19(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExW)(0x80000001, L\"software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExW;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)\n                          (var_4h, *(param_1 + 0x54), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 0x68), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 382
    },
    "0040a183": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: hdc\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: lpvObject\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_52h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.0040a183(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint lpvObject;\n    uint var_60h;\n    uint var_5ch;\n    uint var_52h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint hdc;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x58);\n    *(unaff_EBP + -0x3c) = vtable.CDC.0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x4c) = vtable.CDC.0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    pcVar1 = _sym.imp.USER32.dll_GetSysColor;\n    *(unaff_EBP + -4) = 2;\n    uVar2 = (*pcVar1)(0x14);\n    fcn.0040a140(uVar2);\n    *(unaff_EBP + -4) = 3;\n    uVar2 = (*pcVar1)(0x10);\n    fcn.0040a140(uVar2);\n    *(unaff_EBP + -4) = 4;\n    iVar3 = fcn.00409fbd(0);\n    if (iVar3 != 0) {\n        iVar3 = fcn.00409fbd(0);\n        if (iVar3 != 0) {\n            iVar3 = *(unaff_EBP + 8);\n            (*_sym.imp.GDI32.dll_GetObjectW)(*(iVar3 + 4), 0x18, unaff_EBP + -100);\n            fcn.00409f57();\n            iVar4 = fcn.00409f93(*(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), *(unaff_EBP + -0x54), *(unaff_EBP + -0x52)\n                                 , 0);\n            if (iVar4 != 0) {\n                iVar4 = fcn.00409f93(*(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), 1, 1, 0);\n                if (iVar4 != 0) {\n                    uVar2 = fcn.0040a10e(iVar3);\n                    *(unaff_EBP + 8) = uVar2;\n                    iVar3 = fcn.0040a10e(unaff_EBP + -0x1c);\n                    *(unaff_EBP + -0x14) = iVar3;\n                    if ((*(unaff_EBP + 8) != 0) && (iVar3 != 0)) {\n                        uVar2 = (*_sym.imp.GDI32.dll_GetPixel)(*(unaff_EBP + -0x38), 0, 0);\n                        uVar2 = fcn.00409403(uVar2);\n                        pcVar1 = _sym.imp.GDI32.dll_BitBlt;\n                        *(unaff_EBP + -0x10) = uVar2;\n                        (*pcVar1)(*(unaff_EBP + -0x48), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                  *(unaff_EBP + -0x38), 0, 0, 0xcc0020);\n                        fcn.00409403(0xffffff);\n                        (*pcVar1)(*(unaff_EBP + -0x48), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                  *(unaff_EBP + -0x38), 0, 0, 0x1100a6);\n                        iVar3 = fcn.0040a10e(*(unaff_EBP + 0xc));\n                        if (iVar3 != 0) {\n                            fcn.00423342(0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), *(unaff_EBP + 0x10));\n                            fcn.00409403(0xffffff);\n                            uVar2 = fcn.0040a060(unaff_EBP + -0x2c);\n                            *(unaff_EBP + 0xc) = uVar2;\n                            (*pcVar1)(*(unaff_EBP + -0x38), 1, 1, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                      *(unaff_EBP + -0x48), 0, 0, 0xe20746);\n                            fcn.0040a060(unaff_EBP + -0x24);\n                            (*pcVar1)(*(unaff_EBP + -0x38), 0, 0, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c), \n                                      *(unaff_EBP + -0x48), 0, 0, 0xe20746);\n                            fcn.0040a060(*(unaff_EBP + 0xc));\n                            fcn.00409403(*(unaff_EBP + -0x10));\n                        }\n                        fcn.0040a10e(*(unaff_EBP + -0x14));\n                        fcn.0040a10e(*(unaff_EBP + 8));\n                    }\n                }\n            }\n        }\n    }\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x24) = vtable.CBrush.0;\n    fcn.00401080();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x2c) = vtable.CBrush.0;\n    fcn.00401080();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    fcn.00401080();\n    *(unaff_EBP + -4) = 0;\n    fcn.00409cac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00409cac();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1927
    },
    "0040a3da": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: hdc\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_6ah\n// WARNING: Variable defined which should be unmapped: var_64h\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: lpvObject\n// WARNING: Variable defined which should be unmapped: var_78h\n// WARNING: Variable defined which should be unmapped: var_74h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0040a3da(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint lpvObject;\n    uint var_78h;\n    uint var_74h;\n    uint var_6ah;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint hdc;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x70);\n    *(unaff_EBP + -0x44) = vtable.CDC.0;\n    *(unaff_EBP + -0x40) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x54) = vtable.CDC.0;\n    *(unaff_EBP + -0x50) = 0;\n    *(unaff_EBP + -0x4c) = 0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x34) = vtable.CDC.0;\n    *(unaff_EBP + -0x30) = 0;\n    *(unaff_EBP + -0x2c) = 0;\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -0x24) = vtable.CBrush.0;\n    *(unaff_EBP + -4) = 4;\n    iVar2 = fcn.00409fbd(0);\n    if (iVar2 != 0) {\n        iVar2 = fcn.00409fbd(0);\n        if (iVar2 != 0) {\n            iVar2 = fcn.00409fbd(0);\n            if (iVar2 != 0) {\n                iVar2 = (*_sym.imp.GDI32.dll_GetObjectW)(*(*(unaff_EBP + 8) + 4), 0x18, unaff_EBP + -0x7c);\n                if (iVar2 != 0) {\n                    fcn.00409f57();\n                    iVar2 = fcn.00409f93(*(unaff_EBP + -0x78), *(unaff_EBP + -0x74), *(unaff_EBP + -0x6c), \n                                         *(unaff_EBP + -0x6a), 0);\n                    if (iVar2 != 0) {\n                        uVar3 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, 0x4484d4);\n                        fcn.00409eff(uVar3);\n                        fcn.00409f6d(unaff_EBP + -0x1c);\n                        fcn.00409f57();\n                        fcn.00409f93(*(unaff_EBP + -0x78), *(unaff_EBP + -0x74), 1, 1, 0);\n                        uVar3 = fcn.0040a10e(*(unaff_EBP + 8));\n                        *(unaff_EBP + 8) = uVar3;\n                        iVar2 = fcn.0040a10e(unaff_EBP + -0x1c);\n                        *(unaff_EBP + -0x14) = iVar2;\n                        if ((*(unaff_EBP + 8) != 0) && (iVar2 != 0)) {\n                            uVar3 = (*_sym.imp.GDI32.dll_GetPixel)(*(unaff_EBP + -0x40), 0, 0);\n                            uVar3 = fcn.00409403(uVar3);\n                            pcVar1 = _sym.imp.GDI32.dll_BitBlt;\n                            *(unaff_EBP + -0x10) = uVar3;\n                            (*pcVar1)(*(unaff_EBP + -0x50), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                      *(unaff_EBP + -0x40), 0, 0, 0xcc0020);\n                            fcn.00409403(0xffffff);\n                            (*pcVar1)(*(unaff_EBP + -0x50), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                      *(unaff_EBP + -0x40), 0, 0, 0xee0086);\n                            fcn.00409403(*(unaff_EBP + -0x10));\n                            iVar2 = fcn.0040a10e(*(unaff_EBP + 0xc));\n                            *(unaff_EBP + 0xc) = iVar2;\n                            if (iVar2 != 0) {\n                                uVar3 = fcn.004094fe(*(unaff_EBP + 0x10));\n                                uVar4 = fcn.00409403(*(unaff_EBP + 0x14));\n                                *(unaff_EBP + 0x14) = uVar4;\n                                *(unaff_EBP + -0x5c) = *(unaff_EBP + -0x78);\n                                *(unaff_EBP + -0x58) = *(unaff_EBP + -0x74);\n                                *(unaff_EBP + -100) = 0;\n                                *(unaff_EBP + -0x60) = 0;\n                                fcn.004011d0(unaff_EBP + -100, unaff_EBP + -0x24);\n                                fcn.004094fe(uVar3);\n                                fcn.00409403(*(unaff_EBP + 0x14));\n                                (*pcVar1)(*(unaff_EBP + -0x30), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                          *(unaff_EBP + -0x40), 0, 0, 0x660046);\n                                (*pcVar1)(*(unaff_EBP + -0x30), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                          *(unaff_EBP + -0x50), 0, 0, 0x8800c6);\n                                (*pcVar1)(*(unaff_EBP + -0x30), 0, 0, *(unaff_EBP + -0x78), *(unaff_EBP + -0x74), \n                                          *(unaff_EBP + -0x40), 0, 0, 0x660046);\n                            }\n                            fcn.0040a10e(*(unaff_EBP + 0xc));\n                            fcn.0040a10e(*(unaff_EBP + -0x14));\n                            fcn.0040a10e(*(unaff_EBP + 8));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    *(unaff_EBP + -4) = 3;\n    *(unaff_EBP + -0x24) = vtable.CBrush.0;\n    fcn.00401080();\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x1c) = vtable.CBitmap.0;\n    fcn.00401080();\n    *(unaff_EBP + -4) = 1;\n    fcn.00409cac();\n    *(unaff_EBP + -4) = 0;\n    fcn.00409cac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00409cac();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 2370
    },
    "0041a06a": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a06a(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n    }\n    else {\n        fcn.00419fd5(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = in_ECX;\n        in_ECX[1] = in_ECX;\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "0042202b": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042202b(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    uint *in_ECX;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*in_ECX);\n    arg_8h_00 = *(in_ECX + 2);\n    fcn.00421d1a(arg_8h_00);\n    fcn.00421d1a(arg_8h_00);\n    fcn.00421eff(*in_ECX, uVar1 & 0xffff);\n    return;\n}\n",
        "token_count": 138
    },
    "00418cac": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00418cac(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.00418c19();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExW)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 164
    },
    "0041961e": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0041961e(uint hKey, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    bool bVar4;\n    uint lpType;\n    uint lpData;\n    uint lpcbData;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar4 = false;\n    var_8h = 0;\n    lpData = fcn.004019b0(0x104);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegOpenKeyW;\n    lpcbData = 0x208;\n    lpType = 0;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyW)(0x80000000, 0x447a48, &var_8h);\n    if (iVar3 == 0) {\n        var_4h = 0;\n        iVar3 = (*pcVar1)(var_8h, hKey, &var_4h);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar3 == 0) {\n            hKey = 0;\n            iVar3 = (*pcVar1)(var_4h, 0x44a9e8, &hKey);\n            if (iVar3 == 0) {\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExW)(hKey, 0x44fa4c, 0, &lpType, lpData, &lpcbData);\n                bVar4 = iVar3 == 0;\n                (*pcVar2)(hKey);\n            }\n            (*pcVar2)(var_4h);\n        }\n        (*pcVar2)(var_8h);\n    }\n    fcn.0040d34f(0xffffffff);\n    return bVar4;\n}\n",
        "token_count": 408
    },
    "004424f0": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.004424f0(void)\n\n{\n    *0x45d1a8 = (*_sym.imp.KERNEL32.dll_CreateFileA)(\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "0040641b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040641b(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0042eec5(arg_8h);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x45b000 == NULL) break;\n        iVar1 = (**0x45b000)(arg_8h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 121
    },
    "00407435": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00407435(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t arg_8h;\n    int32_t unaff_EBP;\n    uint var_41ch;\n    uint var_4h;\n    \n    fcn.00430f3a(0x414);\n    *(unaff_EBP + -0x41c) = arg_8h;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.00420e14();\n    while (*(iVar2 + 0x144) == arg_8h) {\n        puVar1 = *(iVar2 + 0x148);\n        *(puVar1[1] + 0x144) = *puVar1;\n        *(puVar1[1] + 0x148) = puVar1[2];\n        puVar1[1] = 0;\n    }\n    if (*(arg_8h + 0x54) != 0) {\n        fcn.00410d9a(arg_8h);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040de40();\n    fcn.00430f96();\n    return;\n}\n",
        "token_count": 304
    },
    "004075cd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004075cd(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    uint *extraout_ECX;\n    uint unaff_EBP;\n    \n    if (param_1 != NULL) goto code_r0x004075db;\n    do {\n        fcn.00407ad1();\n        param_1 = extraout_ECX;\ncode_r0x004075db:\n        iVar1 = (***param_1)();\n    } while (iVar1 == 0);\n    if (iVar1 != 0) goto code_r0x004075b2;\n    do {\n        iVar1 = fcn.00407ad1(unaff_EBP);\ncode_r0x004075b2:\n    } while (param_2 == 0);\n    do {\n        if (iVar1 == param_2) {\n            return 1;\n        }\n        iVar1 = *(iVar1 + 0x10);\n    } while (iVar1 != 0);\n    return 0;\n}\n",
        "token_count": 224
    },
    "00408eb0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00408eb0(uint hMenu, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t uPosition;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetMenuItemCount;\n    iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(arg_ch);\n    iVar4 = (*pcVar1)(hMenu);\n    pcVar2 = _sym.imp.USER32.dll_GetSubMenu;\njoined_r0x00408ed0:\n    do {\n        do {\n            iVar4 = iVar4 + -1;\n            if (iVar4 < 0) {\n                return;\n            }\n            iVar5 = (*pcVar2)(hMenu, iVar4);\n        } while (iVar5 == 0);\n        if (arg_10h != 0) {\n            iVar6 = (*pcVar1)(iVar5);\n            uPosition = 0;\n            if (0 < iVar6) {\n                do {\n                    iVar7 = (*pcVar2)(iVar5, uPosition);\n                    if (iVar7 == arg_10h) {\n                        (*_sym.imp.USER32.dll_RemoveMenu)(iVar5, uPosition, 0x400);\n                        arg_10h = 0;\n                        break;\n                    }\n                    uPosition = uPosition + 1;\n                } while (uPosition < iVar6);\n            }\n            goto joined_r0x00408ed0;\n        }\n        uPosition = 0;\n        if (0 < iVar3) {\n            do {\n                iVar6 = (*pcVar2)(arg_ch, uPosition);\n                if (iVar6 == iVar5) {\n                    (*_sym.imp.USER32.dll_RemoveMenu)(hMenu, iVar4, 0x400);\n                    break;\n                }\n                uPosition = uPosition + 1;\n            } while (uPosition < iVar3);\n        }\n    } while( true );\n}\n",
        "token_count": 469
    },
    "0040904e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040904e(int32_t arg_8h)\n\n{\n    uint uVar1;\n    \n    if (arg_8h == 0) {\n        return;\n    }\n    if (arg_8h == 0xc) {\n        uVar1 = 0x8007000e;\n    }\n    else {\n        if (arg_8h == 0x16) goto code_r0x00409078;\n        if (arg_8h == 0x22) goto code_r0x00409078;\n        if (arg_8h == 0x50) {\n            return;\n        }\n        uVar1 = 0x80004005;\n    }\n    do {\n        fcn.00401000(uVar1);\ncode_r0x00409078:\n        uVar1 = 0x80070057;\n    } while( true );\n}\n",
        "token_count": 193
    },
    "0040bc3c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040bc3c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *extraout_ECX;\n    int32_t unaff_ESI;\n    \n    iVar2 = 0x7fffffff;\n    iVar1 = unaff_ESI;\n    if (arg_8h == 0x7fffffff) goto code_r0x0040bc5f;\n    if (*in_ECX == 0x7fffffff) goto code_r0x0040bc5d;\n    if (*in_ECX == arg_8h) goto code_r0x0040bc5d;\n    do {\n        iVar2 = fcn.00407ad1();\n        in_ECX = extraout_ECX;\ncode_r0x0040bc5d:\n        *in_ECX = arg_8h;\n        iVar1 = unaff_ESI;\ncode_r0x0040bc5f:\n        arg_8h = iVar1;\n        unaff_ESI = arg_8h;\n    } while (*in_ECX == iVar2);\n    fcn.004214b9(*in_ECX);\n    return;\n}\n",
        "token_count": 268
    },
    "0040be6b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040be6b(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t nPos;\n    \n    if (arg_8h == 0) {\n        fcn.00407ad1();\n    }\n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n    nPos = 0;\n    if (0 < iVar1) {\n        do {\n            iVar2 = fcn.0040bb82(nPos);\n            if (iVar2 == 0) {\n                iVar2 = fcn.0040bb6d(nPos);\n                if (iVar2 == arg_ch) goto code_r0x0040becd;\n            }\n            else {\n                if (*(iVar2 + 4) == arg_ch) {\ncode_r0x0040becd:\n                    iVar1 = fcn.004234be(*(arg_8h + 4));\n                    return iVar1;\n                }\n                iVar2 = fcn.0040be6b(iVar2, arg_ch);\n                if (iVar2 != 0) {\n                    return iVar2;\n                }\n            }\n            nPos = nPos + 1;\n        } while (nPos < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 295
    },
    "0040d763": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040d763(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t arg_8h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongW;\n    if ((param_1 == 0) || (arg_8h = *(param_1 + 0x20),  arg_8h == 0)) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongW)(arg_8h, 0xfffffff0);\n    while ((uVar2 & 0x40000000) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(arg_8h);\n        if (iVar3 == 0) break;\n        uVar2 = (*pcVar1)(iVar3, 0xfffffff0);\n        arg_8h = iVar3;\n    }\n    uVar4 = fcn.0040d45d(arg_8h);\n    return uVar4;\n}\n",
        "token_count": 249
    },
    "0040d7a9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040d7a9(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.0040d7a9(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return;\n        }\n        if (arg_10h == 0) {\n            fcn.0040d45d(iVar2);\n            return;\n        }\n        iVar2 = fcn.0040d489();\n        if (iVar2 != 0) {\n            return;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return;\n        }\n        iVar3 = fcn.0040d7a9(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return;\n}\n",
        "token_count": 325
    },
    "0040d96e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040d96e(int32_t arg_8h, int32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *arg_ch;\n    while( true ) {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        piVar1 = fcn.0040d489(iVar3);\n        if ((piVar1 != NULL) && (iVar2 = (**(*piVar1 + 0x108))(arg_ch),  iVar2 != 0)) break;\n        if (iVar3 == arg_8h) {\n            return 0;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar3);\n    }\n    return 1;\n}\n",
        "token_count": 180
    },
    "0040dae4": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040dae4(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageW;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageW)(&lpMsg);\n    }\n    fcn.0040d3b7();\n    return;\n}\n",
        "token_count": 129
    },
    "0040df6b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0040df6b(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    int32_t *piVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if ((param_1 != 0) && (iVar2 = *(param_1 + 0x20),  iVar2 != 0)) {\n        while( true ) {\n            arg_8h = (*pcVar1)(iVar2);\n            piVar3 = fcn.0040d45d(arg_8h);\n            if ((piVar3 == NULL) || (iVar2 = (**(*piVar3 + 0x128))(),  iVar2 != 0)) break;\n            iVar2 = piVar3[8];\n        }\n        return piVar3;\n    }\n    return NULL;\n}\n",
        "token_count": 199
    },
    "0040e166": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0040e166(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    iVar1 = fcn.0040dc6f(5);\n    while (iVar1 != 0) {\n        iVar1 = fcn.0040dc6f(2);\n        iVar2 = iVar2 + 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 94
    },
    "0040e19f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040e19f(uint noname_0, uint noname_1, int32_t arg_10h, uint noname_3, uint *arg_18h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if (arg_18h == NULL) {\n        uVar1 = 0x80004003;\n    }\n    else {\n        *arg_18h = 0;\n        arg_10h = arg_10h + -1;\n        if (arg_10h < 0) {\n            uVar1 = 0x80070057;\n        }\n        else {\n            iVar2 = fcn.0040dc6f(5);\n            if (iVar2 != 0) {\n                do {\n                    if (arg_10h == 0) break;\n                    iVar2 = fcn.0040dc6f(2);\n                    arg_10h = arg_10h + -1;\n                } while (iVar2 != 0);\n                if (iVar2 != 0) {\n                    uVar1 = sub.OLEACC.dll_AccessibleObjectFromWindow(*(iVar2 + 0x20), 0, 0x448a4c, arg_18h);\n                    return uVar1;\n                }\n            }\n            uVar1 = 1;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 301
    },
    "0040ec49": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040ec49(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_8h;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x20),  *(param_1 + 0x20) != 0)) {\n        do {\n            arg_8h = iVar1;\n            iVar1 = fcn.0040ebff(arg_8h);\n        } while (iVar1 != 0);\n        uVar2 = fcn.0040d45d(arg_8h);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 153
    },
    "00413b18": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00413b18(int32_t arg_8h, int32_t arg_ch)\n\n{\n    do {\n        if (arg_8h == arg_ch) {\n            return 1;\n        }\n        arg_ch = fcn.0040ebff(arg_ch);\n    } while (arg_ch != 0);\n    return 0;\n}\n",
        "token_count": 78
    },
    "00416422": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00416422(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_41ch;\n    uint var_4h;\n    \n    fcn.00430f3a(0x414);\n    *(unaff_EBP + -0x41c) = extraout_ECX;\n    *extraout_ECX = vtable.CFrameWnd.0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00415f6f();\n    iVar1 = fcn.00420e14();\n    while (*(iVar1 + 0x14c) == extraout_ECX) {\n        fcn.004140b6();\n    }\n    if (extraout_ECX[0x2f] != NULL) {\n        fcn.0040644a(extraout_ECX[0x2f]);\n    }\n    *(unaff_EBP + -4) = 2;\n    fcn.00401020();\n    *(unaff_EBP + -4) = 0;\n    fcn.00423dac();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0040de40();\n    fcn.00430f96();\n    return;\n}\n",
        "token_count": 312
    },
    "0041685b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_50h\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Variable defined which should be unmapped: var_80h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: dy\n// WARNING: Variable defined which should be unmapped: lprc\n// WARNING: Variable defined which should be unmapped: hmenu\n// WARNING: Variable defined which should be unmapped: var_78h\n\nvoid __cdecl fcn.0041685b(uint arg_8h, uint hWnd, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    code **arg_ch;\n    uint *puVar6;\n    uint *puVar7;\n    int32_t **ppiVar8;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_180h;\n    uint var_17ch;\n    uint var_160h;\n    uint var_11ch;\n    uint lprcSrc;\n    uint lprcDst;\n    uint lprcSrc2;\n    uint lpmi;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_cch;\n    uint var_bch;\n    uint var_b8h;\n    uint var_ach;\n    uint var_98h;\n    uint var_8ch;\n    uint lprcSrc1;\n    uint var_80h;\n    uint var_78h;\n    uint hmenu;\n    uint lprc;\n    uint dy;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_3ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0x174);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    fcn.00401890();\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrlenW;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (*pcVar1)(L\"ReBarWindow32\");\n    uVar3 = fcn.004019b0(iVar2 + 1);\n    puVar6 = *(unaff_EBP + 0xc);\n    (*_sym.imp.USER32.dll_GetClassNameW)(*puVar6, uVar3, iVar2 + 1);\n    fcn.0040d34f(0xffffffff);\n    uVar3 = fcn.0040d489(*puVar6);\n    *(unaff_EBP + -0x14) = uVar3;\n    iVar2 = fcn.00403500(L\"ReBarWindow32\");\n    if (((iVar2 == 0) && (iVar2 = *(unaff_EBP + -0x14),  iVar2 != 0)) && (iVar4 = fcn.004075cd(0x44bdf0),  iVar4 != 0))\n    {\n        iVar4 = fcn.0040df6b();\n        if ((iVar4 == 0) || (*(unaff_EBP + -0x18) == iVar4)) {\n            fcn.00423716();\n            fcn.00401890();\n            fcn.00401890();\n            *(unaff_EBP + -4) = 3;\n            fcn.00409766();\n            *(unaff_EBP + -4) = 4;\n            fcn.00409cc5(*(unaff_EBP + -0x18));\n            *(unaff_EBP + -0x180) = *(iVar2 + 0x98);\n            uVar3 = puVar6[3];\n            *(unaff_EBP + -4) = 5;\n            *(unaff_EBP + -0x17c) = 0x10;\n            fcn.00414124(uVar3, unaff_EBP + -0x180);\n            fcn.00414141(puVar6[3], unaff_EBP + -0x88);\n            iVar2 = (*pcVar1)(0x449cb4);\n            uVar3 = fcn.004019b0(iVar2 + 1);\n            (*_sym.imp.USER32.dll_GetClassNameW)(*(unaff_EBP + -0x160), uVar3, iVar2 + 1);\n            fcn.0040d34f(0xffffffff);\n            iVar2 = fcn.0040d489(*(unaff_EBP + -0x160));\n            *(unaff_EBP + -0x58) = iVar2;\n            iVar4 = fcn.00403500();\n            if (((iVar4 == 0) && (iVar2 != 0)) && (iVar2 = fcn.004075cd(0x44b254),  iVar2 != 0)) {\n                *(unaff_EBP + -0x80) = puVar6[6];\n                *(unaff_EBP + -0x54) = puVar6 + 6;\n                fcn.00409b04(unaff_EBP + -0x88);\n                fcn.00409ac3(unaff_EBP + -0x88);\n                uVar5 = fcn.004140db();\n                *(unaff_EBP + -0x14) = uVar5;\n                do {\n                    uVar5 = uVar5 - 1;\n                    *(unaff_EBP + -0x24) = uVar5;\n                    fcn.004140ee(uVar5, unaff_EBP + -0xec);\n                    iVar2 = (*_sym.imp.USER32.dll_IntersectRect)\n                                      (unaff_EBP + -0xfc, unaff_EBP + -0x88, unaff_EBP + -0xec);\n                    if (iVar2 != 0) break;\n                } while (uVar5 != 0);\n                fcn.00430820(unaff_EBP + -0xdc, 0, 0x30);\n                *(unaff_EBP + -0xdc) = 0x30;\n                uVar3 = fcn.0041410b();\n                *(unaff_EBP + -0x28) = uVar3;\n                fcn.00424256();\n                *(unaff_EBP + -0x3c) = 0x449a30;\n                *(unaff_EBP + -4) = 6;\n                fcn.0042d09d(*(unaff_EBP + -0x14) - uVar5, 0xffffffff);\n                uVar3 = (*_sym.imp.USER32.dll_CreatePopupMenu)();\n                fcn.004234df(uVar3);\n                fcn.00409fbd(unaff_EBP + -0xac);\n                arg_8h_00 = 0;\n                while (uVar5 < *(unaff_EBP + -0x14)) {\n                    fcn.0041cf45(uVar5, unaff_EBP + -0x20, unaff_EBP + -0x50, unaff_EBP + -0x1c);\n                    if ((*(unaff_EBP + -0x50) & 1) == 0) {\n                        *(unaff_EBP + -0xd8) = 0x162;\n                        iVar2 = fcn.00402820(*(unaff_EBP + -0x20));\n                        if (iVar2 == 0) {\n                            fcn.00401a10();\n                        }\n                        else {\n                            fcn.00410c4f(unaff_EBP + 0xc, *(unaff_EBP + 8), 1, 10);\n                        }\n                        arg_ch = fcn.0040641b(8);\n                        if (arg_ch == NULL) {\n                            arg_ch = NULL;\n                        }\n                        else {\n                            arg_ch[1] = NULL;\n                            *arg_ch = vtable.CBitmap.0;\n                        }\n                        fcn.0042427d(arg_8h_00, arg_ch);\n                        if ((*(unaff_EBP + -0x28) == 0) ||\n                           (iVar2 = fcn.00415bd8(*(*(unaff_EBP + -0x28) + 4), *(unaff_EBP + -0x1c), unaff_EBP + -0x11c)\n                           ,  iVar2 == 0)) {\n                            *(unaff_EBP + -0xbc) = 0;\n                        }\n                        else {\n                            (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x68, unaff_EBP + -0x10c);\n                            (*_sym.imp.USER32.dll_OffsetRect)\n                                      (unaff_EBP + -0x68, -*(unaff_EBP + -0x68), -*(unaff_EBP + -100));\n                            fcn.0041c0f4(arg_8h_00);\n                            fcn.00414084(unaff_EBP + -0xac, *(unaff_EBP + -0x60), *(unaff_EBP + -0x5c));\n                            puVar6 = fcn.0041c0f4(arg_8h_00);\n                            puVar7 = fcn.0041c0f4(arg_8h_00);\n                            uVar3 = fcn.0040a10e(*puVar6);\n                            *puVar7 = uVar3;\n                            uVar3 = (*_sym.imp.USER32.dll_GetSysColor)(4);\n                            fcn.004232e1(unaff_EBP + -0x68, uVar3);\n                            fcn.00415bf9(unaff_EBP + -0x4c, *(unaff_EBP + -0x1c), 0, 0, 1);\n                            puVar6 = fcn.0041c0f4(arg_8h_00);\n                            puVar7 = fcn.0041c0f4(arg_8h_00);\n                            uVar3 = fcn.0040a10e(*puVar6);\n                            *puVar7 = uVar3;\n                            puVar6 = fcn.0041c0f4(arg_8h_00);\n                            uVar5 = *(unaff_EBP + -0x24);\n                            *(unaff_EBP + -0xbc) = *puVar6;\n                        }\n                        *(unaff_EBP + -0xb8) = *(unaff_EBP + 0xc);\n                        *(unaff_EBP + -0xcc) = *(unaff_EBP + -0x20);\n                        *(unaff_EBP + -0xd4) = 0x100;\n                        arg_8h_00 = arg_8h_00 + 1;\ncode_r0x00416c6e:\n                        (*_sym.imp.USER32.dll_InsertMenuItemW)(*(unaff_EBP + -0x74), uVar5, 1, unaff_EBP + -0xdc);\n                    }\n                    else if (arg_8h_00 != 0) {\n                        *(unaff_EBP + -0xd8) = 0x100;\n                        *(unaff_EBP + -0xd4) = 0x800;\n                        goto code_r0x00416c6e;\n                    }\n                    uVar5 = uVar5 + 1;\n                    *(unaff_EBP + -0x24) = uVar5;\n                }\n                fcn.00414054(*(unaff_EBP + -0x54));\n                fcn.00409b04(unaff_EBP + -0x98);\n                fcn.0040be15(0, *(unaff_EBP + -0x98), *(unaff_EBP + -0x8c), *(unaff_EBP + -0x18), 0);\n                uVar5 = 0;\n                **(unaff_EBP + 0x10) = 0;\n                if (arg_8h_00 != 0) {\n                    do {\n                        ppiVar8 = fcn.0041c0f4(uVar5);\n                        if (*ppiVar8 != NULL) {\n                            (**(**ppiVar8 + 4))(1);\n                        }\n                        uVar5 = uVar5 + 1;\n                    } while (uVar5 < arg_8h_00);\n                }\n                *(unaff_EBP + -4) = 5;\n                fcn.0042426d();\n                *(unaff_EBP + -4) = 4;\n                fcn.00409d19();\n                *(unaff_EBP + -4) = 3;\n                fcn.00409cac();\n                fcn.00401020();\n                fcn.00401020();\n                *(unaff_EBP + -4) = 0;\n                fcn.00416667();\n            }\n            else {\n                *(unaff_EBP + -4) = 4;\n                fcn.00409d19();\n                *(unaff_EBP + -4) = 3;\n                fcn.00409cac();\n                fcn.00401020();\n                fcn.00401020();\n                *(unaff_EBP + -4) = 0;\n                fcn.00416667();\n            }\n        }\n        else {\n            fcn.0041685b(*(unaff_EBP + 8), puVar6, *(unaff_EBP + 0x10));\n        }\n    }\n    fcn.00401020();\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 3227
    },
    "00416ee9": {
        "rules": [
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00416ee9(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    *in_ECX = arg_8h;\n    in_ECX[1] = 0;\n    if (*0x45f54c == '\\0') {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0x449028);\n        if (iVar2 != 0) goto code_r0x00416f23;\ncode_r0x00416f1e:\n        do {\n            fcn.00407ad1();\ncode_r0x00416f23:\n            pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n            iVar3 = iVar2;\n            *0x45f53c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"CreateActCtxW\");\n            *0x45f540 = (*pcVar1)(iVar2, \"ReleaseActCtx\");\n            *0x45f544 = (*pcVar1)(iVar2, \"ActivateActCtx\");\n            *0x45f548 = (*pcVar1)(iVar2, \"DeactivateActCtx\");\n            iVar2 = iVar3;\n            if (*0x45f53c == 0) {\n                if ((*0x45f540 != 0) || (*0x45f544 != 0)) goto code_r0x00416f1e;\n            }\n            else if ((*0x45f540 == 0) || (*0x45f544 == 0)) goto code_r0x00416f1e;\n        } while (*0x45f548 != 0);\n        *0x45f54c = '\\x01';\n    }\n    return;\n}\n",
        "token_count": 401
    },
    "00419044": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00419044(uint param_1, int32_t param_2)\n\n{\n    int16_t *in_EAX;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *unaff_EDI;\n    \n    iVar1 = 0;\n    iVar2 = param_2;\n    if (param_2 != 0) {\n        do {\n            if (*in_EAX == 0) break;\n            in_EAX = in_EAX + 1;\n            iVar2 = iVar2 + -1;\n        } while (iVar2 != 0);\n        if (iVar2 != 0) goto code_r0x00419064;\n    }\n    iVar1 = -0x7ff8ffa9;\ncode_r0x00419064:\n    if (unaff_EDI != NULL) {\n        if (-1 < iVar1) {\n            *unaff_EDI = param_2 - iVar2;\n            return;\n        }\n        *unaff_EDI = 0;\n    }\n    return;\n}\n",
        "token_count": 226
    },
    "0041a0c7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041a0c7(uint lpFileTime, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    uint lpSystemTime;\n    uint lpLocalFileTime;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_FileTimeToLocalFileTime)(lpFileTime, &lpLocalFileTime);\n    if (iVar1 != 0) goto code_r0x0041a0f4;\n    do {\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n        lpFileTime = 0x80070057;\n        fcn.00401000();\ncode_r0x0041a0f4:\n        iVar1 = (*_sym.imp.KERNEL32.dll_FileTimeToSystemTime)(&lpLocalFileTime, &lpSystemTime, lpFileTime);\n    } while (iVar1 == 0);\n    fcn.0041a06a(&lpSystemTime, arg_ch);\n    *in_ECX = var_8h;\n    in_ECX[1] = var_4h;\n    return;\n}\n",
        "token_count": 256
    },
    "0041dbb0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0041dbb0(void)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = 0;\n    iVar5 = 0;\n    if (0x5ffff < *0x45bc5c) {\n        uVar3 = fcn.004140db();\n        iVar5 = fcn.0040641b(-(uVar3 * 4 >> 0x20 != 0) | uVar3 * 4);\n        uVar4 = 0;\n        if (uVar3 != 0) {\n            do {\n                uVar1 = fcn.0041ce3e(uVar4);\n                *(iVar5 + uVar4 * 4) = uVar1;\n                fcn.0041d59d(uVar4, uVar1 & 0xfffffff7);\n                uVar4 = uVar4 + 1;\n            } while (uVar4 < uVar3);\n        }\n    }\n    uVar2 = fcn.0040d3b7();\n    if (iVar5 != 0) {\n        uVar4 = 0;\n        if (uVar3 != 0) {\n            do {\n                fcn.0041d59d(uVar4, *(iVar5 + uVar4 * 4));\n                uVar4 = uVar4 + 1;\n            } while (uVar4 < uVar3);\n        }\n        fcn.0040644a(iVar5);\n    }\n    return uVar2;\n}\n",
        "token_count": 369
    },
    "00421741": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00421741(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar4 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar4);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != 0xffff) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongW)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar2 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar2 != 0) {\n                return hWnd;\n            }\n        }\n        uVar4 = 2;\n    } while( true );\n}\n",
        "token_count": 293
    },
    "00422300": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00422300(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    int32_t *in_ECX;\n    int32_t arg_8h_00;\n    uint var_4h;\n    \n    arg_8h_00 = *in_ECX;\n    if (arg_8h_00 == 0) {\n        var_4h = 0;\n    }\n    else {\n        if (arg_8h_00 == arg_8h) {\n            piVar1 = fcn.004222c8(arg_8h);\n            *in_ECX = *piVar1;\n        }\n        else {\n            do {\n                piVar1 = fcn.004222c8(arg_8h_00);\n                if (*piVar1 == arg_8h) break;\n                piVar1 = fcn.004222c8(arg_8h_00);\n                arg_8h_00 = *piVar1;\n            } while (arg_8h_00 != 0);\n            if (arg_8h_00 == 0) {\n                return 0;\n            }\n            puVar2 = fcn.004222c8(arg_8h);\n            puVar3 = fcn.004222c8(arg_8h_00);\n            *puVar3 = *puVar2;\n        }\n        var_4h = 1;\n    }\n    return var_4h;\n}\n",
        "token_count": 331
    },
    "004224c8": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004224c8(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    if ((0 < arg_8h) && (arg_8h < *(in_ECX + 0xc))) {\n        for (iVar3 = *(in_ECX + 0x14); iVar3 != 0; iVar3 = *(iVar3 + 4)) {\n            if (arg_8h < *(iVar3 + 8)) {\n                puVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n                if (puVar2 != NULL) {\n                    (***puVar2)(1);\n                }\n                *(*(iVar3 + 0xc) + arg_8h * 4) = 0;\n            }\n        }\n        puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n        *puVar1 = *puVar1 & 0xfffffffe;\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 297
    },
    "00422d4e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00422d4e(uint32_t arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    uint *puVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    \n    *arg_10h = arg_8h >> 4;\n    uVar2 = (arg_8h >> 4) % *(in_ECX + 8);\n    *arg_ch = uVar2;\n    if (*(in_ECX + 4) != 0) {\n        for (puVar1 = *(*(in_ECX + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == arg_8h) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 197
    },
    "00422d89": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00422d89(uint32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    int32_t extraout_ECX;\n    uint *puVar1;\n    \n    if (in_ECX == 0) {\n        fcn.00407ad1();\n        in_ECX = extraout_ECX;\n    }\n    if (*(in_ECX + 4) != 0) {\n        for (puVar1 = *(*(in_ECX + 4) + ((arg_8h >> 4) % *(in_ECX + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == arg_8h) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 183
    },
    "00422df7": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00422df7(uint32_t arg_8h)\n\n{\n    uint *puVar1;\n    uint *arg_8h_00;\n    int32_t in_ECX;\n    uint *puVar2;\n    \n    if (*(in_ECX + 4) == 0) {\n        arg_8h_00 = NULL;\n    }\n    else {\n        puVar2 = *(in_ECX + 4) + ((arg_8h >> 4) % *(in_ECX + 8)) * 4;\n        puVar1 = *puVar2;\n        while (arg_8h_00 = puVar1,  arg_8h_00 != NULL) {\n            if (arg_8h_00[1] == arg_8h) {\n                *puVar2 = *arg_8h_00;\n                fcn.00422d30(arg_8h_00);\n                return 0x1;\n            }\n            puVar2 = arg_8h_00;\n            puVar1 = *arg_8h_00;\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 251
    },
    "004232e1": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004232e1(int32_t arg_8h, uint crColor)\n\n{\n    int32_t in_ECX;\n    \n    if (in_ECX != 0) goto code_r0x004232f5;\n    do {\n        fcn.00407ad1();\ncode_r0x004232f5:\n    } while ((*(in_ECX + 4) == 0) || (arg_8h == 0));\n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    (*_sym.imp.GDI32.dll_ExtTextOutW)(*(in_ECX + 4), 0, 0, 2, arg_8h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 175
    },
    "00423ce5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00423ce5(int32_t param_1)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    \n    if (param_1 != 0) goto code_r0x00423cee;\n    do {\n        fcn.00407ad1();\n        param_1 = extraout_ECX;\ncode_r0x00423cee:\n        arg_8h = *(param_1 + 4);\n    } while (arg_8h == NULL);\n    iVar1 = *arg_8h;\n    iVar2 = arg_8h[2];\n    *(param_1 + 4) = iVar1;\n    if (iVar1 == 0) {\n        *(param_1 + 8) = 0;\n    }\n    else {\n        *(iVar1 + 4) = 0;\n    }\n    fcn.00423cbe(arg_8h);\n    return iVar2;\n}\n",
        "token_count": 224
    },
    "00423d5b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423d5b(int32_t arg_8h, uint *arg_ch)\n\n{\n    int32_t in_ECX;\n    \n    if (arg_ch != NULL) goto code_r0x00423d74;\n    for (arg_ch = *(in_ECX + 4); (arg_ch != NULL && (arg_ch[2] != arg_8h)); arg_ch = *arg_ch) {\ncode_r0x00423d74:\n    }\n    return;\n}\n",
        "token_count": 108
    },
    "00424365": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424365(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.0040644a(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00426f94": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00426f94(int16_t *arg_8h)\n\n{\n    int16_t iVar1;\n    \n    do {\n        iVar1 = *arg_8h;\n        arg_8h = arg_8h + 1;\n    } while (iVar1 != 0);\n    return;\n}\n",
        "token_count": 70
    },
    "00427916": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00427916(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if ((-1 < arg_8h) && (-1 < arg_ch)) goto code_r0x00427933;\n    do {\n        do {\n            fcn.00407ad1();\ncode_r0x00427933:\n        } while ((*(in_ECX + 0x78) == 0) && (*(in_ECX + 0x74) != 0));\n        if (arg_8h < 1) goto code_r0x00427957;\n    } while (arg_ch < 1);\n    iVar1 = fcn.004322eb(arg_8h, arg_ch);\n    if (iVar1 != 0) {\ncode_r0x00427957:\n        fcn.0042e518(*(in_ECX + 0x78));\n        *(in_ECX + 0x78) = iVar1;\n        *(in_ECX + 0x74) = arg_8h;\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 264
    },
    "00428e6e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00428e6e(uint arg_8h, uint32_t *arg_ch, uint32_t *arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint *puVar3;\n    \n    uVar2 = fcn.00428d52(arg_8h);\n    *arg_10h = uVar2;\n    uVar2 = uVar2 % *(in_ECX + 8);\n    *arg_ch = uVar2;\n    if (*(in_ECX + 4) != 0) {\n        for (puVar3 = *(*(in_ECX + 4) + uVar2 * 4); puVar3 != NULL; puVar3 = *puVar3) {\n            if ((puVar3[1] == *arg_10h) && (cVar1 = fcn.00415ea7(puVar3 + 2, arg_8h),  cVar1 != '\\0')) {\n                return puVar3;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 243
    },
    "00428f75": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428f75(code **param_1)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    *param_1 = vtable.CMapStringToPtr.0;\n    pcVar1 = NULL;\n    if (param_1[1] != NULL) {\n        if (param_1[2] != NULL) {\n            do {\n                for (puVar2 = *(param_1[1] + pcVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    if (puVar2 == 0xfffffff8) {\n                        fcn.00407ad1();\n                        pcVar1 = swi(3);\n                        (*pcVar1)();\n                        return;\n                    }\n                    fcn.0041c58c(0);\n                }\n                pcVar1 = pcVar1 + 1;\n            } while (pcVar1 < param_1[2]);\n        }\n        fcn.0040644a(param_1[1]);\n        param_1[1] = NULL;\n    }\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    fcn.00424365();\n    param_1[5] = NULL;\n    return;\n}\n",
        "token_count": 277
    },
    "0042ca98": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.0042ca98(uint arg_8h)\n\n{\n    uint arg_ch;\n    int32_t iVar1;\n    uint uVar2;\n    uint *puVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00430e9b(0xc);\n    if ((~*(extraout_ECX + 0x18) & 1) == 0) {\n        if (*(extraout_ECX + 0x38) != 0) goto code_r0x0042cb86;\n        iVar1 = fcn.0040641b(0x14);\n        *(unaff_EBP + -0x18) = iVar1;\n        *(unaff_EBP + -4) = 1;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.0042d076();\n        }\n        arg_ch = *(extraout_ECX + 0x40);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x38) = uVar2;\n        fcn.0042d09d(1, arg_ch);\n        iVar1 = *(extraout_ECX + 0x38);\n        if (0 < *(iVar1 + 8)) goto code_r0x0042cb5f;\n        do {\n            iVar1 = fcn.00407ad1();\ncode_r0x0042cb5f:\n            **(iVar1 + 4) = 0;\n            *(extraout_ECX + 0x34) = 1;\n            *(unaff_EBP + -0x10) = 0;\n            fcn.0042c9c4(unaff_EBP + -0x10);\n            *(unaff_EBP + -0x18) = 0;\n            fcn.0042c8ee(0, unaff_EBP + -0x18, 1);\ncode_r0x0042cb86:\n            if (*(unaff_EBP + 8) == 0) goto code_r0x0042cbcf;\n            fcn.0042c8c3();\n            fcn.0042d1c3(*(extraout_ECX + 0x34), *(unaff_EBP + 8), 1);\n            *(unaff_EBP + -0x14) = 0;\n            fcn.00422dce(1, unaff_EBP + -0x14);\n        } while (*(unaff_EBP + -0x14) == 0);\n        uVar2 = *(extraout_ECX + 0x34);\n        *(unaff_EBP + 8) = 2;\n        fcn.0042c8ee(uVar2, unaff_EBP + 8, 1);\n    }\n    else {\n        if (*(extraout_ECX + 0x38) == 0) {\n            iVar1 = fcn.0040641b(0x1c);\n            *(unaff_EBP + -0x18) = iVar1;\n            *(unaff_EBP + -4) = 0;\n            if (iVar1 == 0) {\n                uVar2 = 0;\n            }\n            else {\n                uVar2 = fcn.00422ec2(*(extraout_ECX + 0x40));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(extraout_ECX + 0x38) = uVar2;\n            fcn.00428d7b(*(extraout_ECX + 0x44), 1);\n            puVar3 = fcn.00422f50(0);\n            *puVar3 = 0;\n            *(extraout_ECX + 0x34) = 1;\n        }\n        if (*(unaff_EBP + 8) == 0) goto code_r0x0042cbcf;\n        fcn.0042c8c3();\n        puVar3 = fcn.00422f50(*(unaff_EBP + 8));\n        *puVar3 = *(extraout_ECX + 0x34);\n    }\n    *(extraout_ECX + 0x34) = *(extraout_ECX + 0x34) + 1;\ncode_r0x0042cbcf:\n    fcn.00430f73();\n    return;\n}\n",
        "token_count": 1061
    },
    "00435675": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00435675(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00431080(0x457210, 0xc);\n    fcn.004358f4(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x46015c;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x460158;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x004356b9;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.0042e518(arg_8h_00);\ncode_r0x004356b9:\n        fcn.0042e518(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.004356dc();\n    fcn.004310c5();\n    return;\n}\n",
        "token_count": 392
    },
    "00410853": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00410853(int32_t lpName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t arg_8h;\n    uint var_4h;\n    \n    iVar3 = 0;\n    arg_8h = 0;\n    if (lpName != 0) {\n        iVar1 = fcn.004213cc();\n        uVar2 = *(iVar1 + 0xc);\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceW)(uVar2, lpName, 0xf0);\n        if (iVar1 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar2, iVar1);\n            if (iVar3 == 0) {\n                return 0;\n            }\n            arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar3);\n        }\n    }\n    uVar2 = fcn.004103cb(arg_8h);\n    if ((arg_8h != 0) && (iVar3 != 0)) {\n        (*_sym.imp.KERNEL32.dll_FreeResource)(iVar3);\n    }\n    return uVar2;\n}\n",
        "token_count": 266
    },
    "0041b807": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0041b807(uint lpName, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uint arg_8h;\n    uint var_4h;\n    \n    arg_8h = 0;\n    iVar1 = fcn.004213cc();\n    uVar3 = *(iVar1 + 0xc);\n    uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceW)(uVar3, lpName, 5);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar3, uVar2);\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    }\n    uVar3 = fcn.0041b453(arg_8h, arg_ch, uVar3);\n    (*_sym.imp.KERNEL32.dll_FreeResource)(iVar1);\n    return uVar3;\n}\n",
        "token_count": 216
    },
    "0041b85f": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041b85f(uint hResData, uint arg_ch, uint arg_10h)\n\n{\n    uint arg_8h;\n    \n    arg_8h = (*_sym.imp.KERNEL32.dll_LockResource)(hResData);\n    fcn.0041b7da(arg_8h, arg_ch, 0, arg_10h);\n    return;\n}\n",
        "token_count": 87
    },
    "0040a73a": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.0040a73a(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    \n    if (*0x45f3bc != 0) {\n        return *0x45f3b0 != 0;\n    }\n    *0x45f3c0 = fcn.0040a6e0();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(L\"USER32\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if ((((iVar2 != 0) && (*0x45f3a0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x448664),  *0x45f3a0 != 0)) &&\n        (*0x45f3a4 = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x45f3a4 != 0)) &&\n       (((*0x45f3a8 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x45f3a8 != 0 &&\n         (*0x45f3ac = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x45f3ac != 0)) &&\n        ((*0x45f3b4 = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x45f3b4 != 0 &&\n         (*0x45f3b8 = (*pcVar1)(iVar2, \"EnumDisplayDevicesW\"),  *0x45f3b8 != 0)))))) {\n        if (*0x45f3c0 == 0) {\n            pcVar3 = \"GetMonitorInfoA\";\n        }\n        else {\n            pcVar3 = \"GetMonitorInfoW\";\n        }\n        *0x45f3b0 = (*pcVar1)(iVar2, pcVar3);\n        if (*0x45f3b0 != 0) {\n            *0x45f3bc = 1;\n            return true;\n        }\n    }\n    *0x45f3a0 = 0;\n    *0x45f3a4 = 0;\n    *0x45f3a8 = 0;\n    *0x45f3ac = 0;\n    *0x45f3b0 = 0;\n    *0x45f3b4 = 0;\n    *0x45f3b8 = 0;\n    *0x45f3bc = 1;\n    return false;\n}\n",
        "token_count": 568
    },
    "00420cc5": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00420cc5(code **param_1)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    *param_1 = vtable._AFX_THREAD_STATE.0;\n    if (param_1[0xb] != NULL) {\n        (*pcVar1)(param_1[0xb]);\n    }\n    if (param_1[10] != NULL) {\n        (*pcVar1)(param_1[10]);\n    }\n    if (param_1[3] != NULL) {\n        fcn.0042e518(param_1[3]);\n    }\n    return;\n}\n",
        "token_count": 147
    },
    "0042c5cb": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.0042c5cb(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    fcn.0042c52c();\n    iVar2 = fcn.004213cc();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x3c),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.004213ff();\n    if ((*(iVar2 + 0x3c) != NULL) && (iVar3 = (**(**(iVar2 + 0x3c) + 0x144))(),  iVar3 != 0)) {\n        *(iVar2 + 0x3c) = 0;\n    }\n    iVar2 = fcn.00420e14();\n    iVar3 = fcn.004213cc();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar3 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x2c) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n        if (*(iVar2 + 0x28) != 0) {\n            (*pcVar1)(*(iVar2 + 0x28));\n            *(iVar2 + 0x28) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 355
    },
    "00419076": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419076(uint lpExistingFileName, uint lpNewFileName)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileW)(lpExistingFileName, lpNewFileName);\n    if (iVar1 == 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.004241fb(arg_8h, lpExistingFileName);\n    }\n    return;\n}\n",
        "token_count": 109
    },
    "0041909e": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0041909e(uint lpFileName)\n\n{\n    int32_t iVar1;\n    uint arg_8h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileW)(lpFileName);\n    if (iVar1 == 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.004241fb(arg_8h, lpFileName);\n    }\n    return;\n}\n",
        "token_count": 98
    },
    "004221e3": {
        "rules": [
            "get thread local storage value"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004221e3(int32_t arg_8h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint *in_ECX;\n    \n    puVar1 = in_ECX + 7;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n    if ((((0 < arg_8h) && (arg_8h < in_ECX[3])) && (iVar3 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX),  iVar3 != 0))\n       && (arg_8h < *(iVar3 + 8))) {\n        uVar2 = *(*(iVar3 + 0xc) + arg_8h * 4);\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n        return uVar2;\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n    return 0;\n}\n",
        "token_count": 214
    }
}