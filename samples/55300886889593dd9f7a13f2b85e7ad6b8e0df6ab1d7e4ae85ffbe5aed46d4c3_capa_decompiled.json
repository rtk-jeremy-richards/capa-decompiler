{
    "14000100": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140001000(void)\n\n{\n    ushort uVar1;\n    int16_t iVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    int64_t iVar12;\n    ulong uVar13;\n    int64_t iVar14;\n    uint64_t uVar15;\n    int64_t iVar16;\n    int64_t iVar17;\n    int64_t iVar18;\n    int64_t iVar19;\n    int64_t iVar20;\n    int64_t iVar21;\n    int32_t aiStackX32 [2];\n    ulong uStack48;\n    \n    // [00] -r-x section size 16384 named .text\n    uStack48 = 0x140001022;\n    iVar12 = fcn.140004e90();\n    iVar12 = -iVar12;\n    *(&stack0x00001048 + iVar12) = *0x140008228 ^ &stack0xffffffffffffffd8 + iVar12;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x14000103e;\n    uVar4 = sub.api_ms_win_crt_time_l1_1_0.dll__time32(0);\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001046;\n    (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_srand)(uVar4);\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x14000104c;\n    uVar13 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001060;\n    iVar14 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(uVar13, 8, 0x1050);\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001073;\n    sub.VCRUNTIME140.dll_memset();\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001079;\n    iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n    uVar15 = iVar5 / 6 + (iVar5 >> 0x3f) & 0xffffffff;\n    iVar5 = iVar5 + (uVar15 + (uVar15 >> 0x1f)) * -6;\n    *(&stack0x00000030 + iVar12) = iVar5 + 9;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x14000109d;\n    iVar6 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n    uVar15 = iVar6 / 6 + (iVar6 >> 0x3f) & 0xffffffff;\n    *(&stack0x00000008 + iVar12) = iVar6 + (uVar15 + (uVar15 >> 0x1f)) * -6;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x1400010c2;\n    iVar7 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n    uVar15 = iVar7 / 6 + (iVar7 >> 0x3f) & 0xffffffff;\n    iVar7 = iVar7 + (uVar15 + (uVar15 >> 0x1f)) * -6;\n    *(&stack0x0000002c + iVar12) = iVar7 + 9;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x1400010e6;\n    iVar8 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n    uVar15 = iVar8 / 6 + (iVar8 >> 0x3f) & 0xffffffff;\n    iVar8 = iVar8 + (uVar15 + (uVar15 >> 0x1f)) * -6;\n    *(&stack0x00000028 + iVar12) = iVar8;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x14000110b;\n    iVar9 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n    uVar15 = iVar9 / 6 + (iVar9 >> 0x3f) & 0xffffffff;\n    iVar9 = iVar9 + (uVar15 + (uVar15 >> 0x1f)) * -6;\n    *(&stack0x00000024 + iVar12) = iVar9 + 9;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x14000112f;\n    iVar10 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n    uVar15 = iVar10 / 6 + (iVar10 >> 0x3f) & 0xffffffff;\n    iVar10 = iVar10 + (uVar15 + (uVar15 >> 0x1f)) * -6;\n    *(&stack0x00000020 + iVar12) = iVar10;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001165;\n    sub.VCRUNTIME140.dll_memcpy();\n    iVar6 = 0;\n    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001173;\n    uVar1 = (*_sym.imp.WS2_32.dll_ntohs)();\n    *(&stack0xfffffffffffffff8 + iVar12) = uVar1;\n    uVar3 = *(&stack0xfffffffffffffff8 + iVar12);\n    iVar21 = iVar7 + 9;\n    *(&stack0x00000010 + iVar12) = iVar10 + 0xb;\n    iVar19 = iVar5 + 9;\n    iVar17 = *(&stack0x00000008 + iVar12) + 0xb;\n    iVar20 = iVar9 + 9;\n    *(&stack0x00000018 + iVar12) = iVar8 + 0xb;\n    *(&stack0x00000038 + iVar12) = iVar19;\n    *(&stack0x00000000 + iVar12) = iVar17;\n    do {\n        if (uVar3 < 1) {\ncode_r0x000140001778:\n            *(&stack0xffffffffffffffd0 + iVar12) = 0x140001788;\n            fcn.140004180(*(&stack0x00001048 + iVar12) ^ &stack0xffffffffffffffd8 + iVar12);\n            return;\n        }\n        *(&stack0xffffffffffffffd0 + iVar12) = 0x1400011de;\n        iVar2 = (*_sym.imp.WS2_32.dll_ntohs)();\n        *(&stack0xffffffffffffffd0 + iVar12) = 0x1400011ef;\n        uVar1 = (*_sym.imp.WS2_32.dll_ntohs)();\n        iVar18 = uVar3 * 0x2d;\n        *(&stack0xfffffffffffffff8 + iVar12) = uVar1;\n        if (iVar2 == 1) {\n            iVar16 = 0;\n            if (0 < iVar19) {\n                do {\n                    *(&stack0xffffffffffffffd0 + iVar12) = 0x1400015bc;\n                    iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                    *(iVar18 + iVar14 + iVar16) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                    iVar16 = iVar16 + 1;\n                } while (iVar16 < iVar19);\n                iVar17 = *(&stack0x00000000 + iVar12);\n            }\n            *(&stack0xffffffffffffffd0 + iVar12) = 0x1400015f2;\n            uVar11 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n            uVar11 = uVar11 & 0x80000007;\n            if (uVar11 < 0) {\n                uVar11 = (uVar11 - 1 | 0xfffffff8) + 1;\n            }\n            iVar16 = 0;\n            *(iVar18 + iVar19 + iVar14) = uVar11 + 'p';\n            if (0 < iVar17) {\n                iVar17 = *(&stack0x00000000 + iVar12);\n                do {\n                    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001626;\n                    iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                    *(iVar19 + iVar18 + iVar14 + 1 + iVar16) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                    iVar16 = iVar16 + 1;\n                } while (iVar16 < iVar17);\n                iVar19 = *(&stack0x00000038 + iVar12);\n                iVar17 = *(&stack0x00000000 + iVar12);\n            }\n            iVar17 = iVar18 + iVar17 + iVar19 + iVar14;\n            *(&stack0xffffffffffffffd0 + iVar12) = 0x140001674;\n            uVar1 = (*_sym.imp.WS2_32.dll_ntohs)();\n            *(iVar17 + 1) = uVar1;\n            *(&stack0xffffffffffffffd0 + iVar12) = 0x14000167e;\n            iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n            *(iVar17 + -1) = iVar5 + (iVar5 / 10) * -10 + '\\x15';\n            *(&stack0xffffffffffffffd0 + iVar12) = 0x1400016a9;\n            iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n            *(iVar17 + -4) = iVar5 + (iVar5 / 10) * -10 + '\\x1f';\n            *(&stack0xffffffffffffffd0 + iVar12) = 0x1400016d4;\n            iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n            iVar7 = (0x1f - *(&stack0x00000008 + iVar12)) - *(&stack0x00000030 + iVar12);\n            *(iVar17 + -6) = iVar5 + (iVar5 / 10) * -10 + ')';\n            iVar17 = 0;\n            if (0 < iVar7) {\n                iVar16 = *(&stack0x00000000 + iVar12);\n                do {\n                    *(&stack0xffffffffffffffd0 + iVar12) = 0x140001726;\n                    iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                    *(iVar18 + iVar16 + iVar19 + iVar14 + 3 + iVar17) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                    iVar17 = iVar17 + 1;\n                } while (iVar17 < iVar7);\n            }\n            iVar6 = iVar6 + 8;\ncode_r0x000140001756:\n            iVar17 = *(&stack0x00000000 + iVar12);\n        }\n        else {\n            if (iVar2 == 2) {\n                iVar17 = 0;\n                if (0 < iVar21) {\n                    do {\n                        *(&stack0xffffffffffffffd0 + iVar12) = 0x140001416;\n                        iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                        *(iVar18 + iVar14 + iVar17) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                        iVar17 = iVar17 + 1;\n                    } while (iVar17 < iVar21);\n                }\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x140001447;\n                uVar11 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                uVar11 = uVar11 & 0x80000007;\n                if (uVar11 < 0) {\n                    uVar11 = (uVar11 - 1 | 0xfffffff8) + 1;\n                }\n                *(iVar18 + iVar21 + iVar14) = uVar11 + 'z';\n                iVar16 = 0;\n                iVar17 = *(&stack0x00000018 + iVar12);\n                if (0 < iVar17) {\n                    do {\n                        *(&stack0xffffffffffffffd0 + iVar12) = 0x14000147a;\n                        iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                        *(iVar21 + iVar18 + iVar14 + 1 + iVar16) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                        iVar16 = iVar16 + 1;\n                    } while (iVar16 < iVar17);\n                    iVar19 = *(&stack0x00000038 + iVar12);\n                    iVar17 = *(&stack0x00000018 + iVar12);\n                }\n                iVar17 = iVar18 + iVar17 + iVar21 + iVar14;\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x1400014c7;\n                uVar4 = (*_sym.imp.WS2_32.dll_ntohl)();\n                *(iVar17 + 1) = uVar4;\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x1400014d0;\n                iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                *(iVar17 + -2) = iVar5 + (iVar5 / 10) * -10 + '3';\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x1400014fb;\n                iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                *(iVar17 + -4) = iVar5 + (iVar5 / 10) * -10 + '=';\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x140001526;\n                iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                iVar7 = (0x1d - *(&stack0x00000028 + iVar12)) - *(&stack0x0000002c + iVar12);\n                *(iVar17 + -7) = iVar5 + (iVar5 / 10) * -10 + 'G';\n                iVar17 = 0;\n                if (0 < iVar7) {\n                    iVar16 = *(&stack0x00000018 + iVar12);\n                    do {\n                        *(&stack0xffffffffffffffd0 + iVar12) = 0x140001576;\n                        iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                        *(iVar18 + iVar16 + iVar21 + iVar14 + 5 + iVar17) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                        iVar17 = iVar17 + 1;\n                    } while (iVar17 < iVar7);\n                }\n                iVar6 = iVar6 + 10;\n                goto code_r0x000140001756;\n            }\n            if (iVar2 == 3) {\n                iVar17 = 0;\n                if (0 < iVar20) {\n                    do {\n                        *(&stack0xffffffffffffffd0 + iVar12) = 0x140001229;\n                        iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                        *(iVar18 + iVar14 + iVar17) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                        iVar17 = iVar17 + 1;\n                    } while (iVar17 < iVar20);\n                }\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x14000125a;\n                uVar11 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                uVar11 = uVar11 & 0x80000007;\n                if (uVar11 < 0) {\n                    uVar11 = (uVar11 - 1 | 0xfffffff8) + 1;\n                }\n                iVar17 = 0;\n                *(iVar18 + iVar20 + iVar14) = uVar11 + -0x7c;\n                if (0 < *(&stack0x00000010 + iVar12)) {\n                    iVar19 = *(&stack0x00000010 + iVar12);\n                    do {\n                        *(&stack0xffffffffffffffd0 + iVar12) = 0x14000128c;\n                        iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                        *(iVar18 + iVar20 + iVar14 + 1 + iVar17) = iVar5 + (iVar5 / 0x32) * -0x32 + -0x6a;\n                        iVar17 = iVar17 + 1;\n                    } while (iVar17 < iVar19);\n                    iVar19 = *(&stack0x00000038 + iVar12);\n                }\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x1400012c9;\n                (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x1400012da;\n                uVar13 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                *(&stack0x00000040 + iVar12) = uVar13;\n                iVar17 = *(&stack0x00000010 + iVar12) + iVar18 + iVar20 + iVar14;\n                *(iVar17 + 1) = uVar13;\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x1400012f7;\n                iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                *(iVar17 + -1) = iVar5 + (iVar5 / 10) * -10 + 'Q';\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x140001322;\n                iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                *(iVar17 + -4) = iVar5 + (iVar5 / 10) * -10 + '[';\n                *(&stack0xffffffffffffffd0 + iVar12) = 0x14000134d;\n                iVar5 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                iVar2 = *(&stack0xfffffffffffffff8 + iVar12);\n                *(iVar17 + -7) = iVar5 + (iVar5 / 10) * -10 + 'e';\n                if (iVar2 <= 0xffa - iVar6) {\n                    *(&stack0xffffffffffffffd0 + iVar12) = 0x14000139f;\n                    sub.VCRUNTIME140.dll_memcpy();\n                    iVar17 = 0;\n                    iVar5 = (0x19 - *(&stack0x00000020 + iVar12)) - *(&stack0x00000024 + iVar12);\n                    if (0 < iVar5) {\n                        iVar16 = *(&stack0x00000010 + iVar12);\n                        do {\n                            *(&stack0xffffffffffffffd0 + iVar12) = 0x1400013c9;\n                            iVar7 = (*_sym.imp.api_ms_win_crt_utility_l1_1_0.dll_rand)();\n                            *(iVar18 + iVar16 + iVar20 + iVar14 + 9 + iVar17) = iVar7 + (iVar7 / 0x32) * -0x32 + -0x6a;\n                            iVar17 = iVar17 + 1;\n                        } while (iVar17 < iVar5);\n                    }\n                    iVar6 = iVar6 + *(&stack0xfffffffffffffff8 + iVar12) + 6;\n                    goto code_r0x000140001756;\n                }\n                goto code_r0x000140001778;\n            }\n        }\n        *(&stack0xffffffffffffffd0 + iVar12) = 0x140001769;\n        uVar3 = (*_sym.imp.WS2_32.dll_ntohs)();\n    } while( true );\n}\n",
        "token_count": 4585
    },
    "14000193": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.140001930(int64_t arg1)\n\n{\n    uchar *puVar1;\n    uint16_t uVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    uint64_t uVar5;\n    uint16_t uVar6;\n    int64_t iVar7;\n    uint32_t uVar8;\n    uint32_t *puVar9;\n    int64_t iVar10;\n    uint64_t uVar11;\n    uint64_t uVar12;\n    uint64_t uVar13;\n    uint32_t *puVar14;\n    \n    iVar10 = *(*(arg1 + 0x10) + 0x3c) + *(arg1 + 0x10);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)();\n    uVar11 = 0;\n    *(arg1 + 0x30) = iVar4;\n    if (*(iVar10 + 0x54) != 0) {\n        iVar3 = *(arg1 + 0x10);\n        uVar5 = uVar11;\n        uVar12 = uVar11;\n        do {\n            uVar8 = uVar12 + 1;\n            uVar12 = uVar8;\n            *(uVar5 + iVar4) = *(iVar3 + uVar5);\n            uVar5 = uVar5 + 1;\n        } while (uVar8 < *(iVar10 + 0x54));\n    }\n    if (*(iVar10 + 6) != 0) {\n        puVar9 = *(iVar10 + 0x14) + 0x28 + iVar10;\n        uVar5 = uVar11;\n        do {\n            if (*puVar9 != 0) {\n                iVar3 = *(arg1 + 0x10);\n                uVar12 = uVar11;\n                uVar13 = uVar11;\n                do {\n                    uVar8 = uVar13 + 1;\n                    uVar13 = uVar8;\n                    iVar7 = puVar9[-1] + uVar12;\n                    puVar1 = puVar9[1] + iVar3 + uVar12;\n                    uVar12 = uVar12 + 1;\n                    *(iVar7 + iVar4) = *puVar1;\n                } while (uVar8 < *puVar9);\n            }\n            uVar8 = uVar5 + 1;\n            uVar5 = uVar8;\n            puVar9 = puVar9 + 10;\n        } while (uVar8 < *(iVar10 + 6));\n    }\n    uVar11 = iVar4 - *(iVar10 + 0x30);\n    if ((uVar11 != 0) && (iVar10 + 0xb0 != NULL)) {\n        puVar9 = *(iVar10 + 0xb0) + iVar4;\n        do {\n            puVar14 = puVar9 + 2;\n            do {\n                uVar2 = *puVar14;\n                uVar6 = uVar2 >> 0xc;\n                if (uVar6 == 10) {\n                    *((uVar2 & 0xfff) + *puVar9 + iVar4) = *((uVar2 & 0xfff) + *puVar9 + iVar4) + uVar11;\n                }\n                else {\n                    if (uVar6 == 3) {\n                        iVar10 = iVar4 + (uVar2 & 0xfff);\n                        uVar5 = uVar11 & 0xffffffff;\n                    }\n                    else if (uVar6 == 1) {\n                        iVar10 = iVar4 + (uVar2 & 0xfff);\n                        uVar5 = uVar11 >> 0x10 & 0xffff;\n                    }\n                    else {\n                        if (uVar6 != 2) goto code_r0x000140001abc;\n                        iVar10 = iVar4 + (uVar2 & 0xfff);\n                        uVar5 = uVar11 & 0xffff;\n                    }\n                    *(*puVar9 + iVar10) = *(*puVar9 + iVar10) + uVar5;\n                }\ncode_r0x000140001abc:\n                puVar14 = puVar14 + 2;\n            } while (puVar14 != puVar9[1] + puVar9);\n            puVar9 = puVar14;\n        } while (*puVar14 != 0);\n    }\n    return 1;\n}\n",
        "token_count": 949
    },
    "140001b0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140001b00(int64_t arg1)\n\n{\n    uint64_t *puVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    ulong uVar6;\n    uchar *arg2;\n    int64_t iVar7;\n    int64_t iVar8;\n    ulong *puVar9;\n    int64_t iVar10;\n    uint32_t *puVar11;\n    ulong *puVar12;\n    uint64_t *puVar13;\n    uint64_t uVar14;\n    int64_t iVar15;\n    int64_t in_GS_OFFSET;\n    uchar auStack104 [32];\n    uchar auStack72 [16];\n    uint64_t uStack56;\n    \n    uStack56 = *0x140008228 ^ auStack104;\n    auStack72 = ZEXT816(0);\n    iVar15 = *(*(arg1 + 0x10) + 0x3c) + *(arg1 + 0x10);\n    puVar12 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n    puVar9 = *puVar12;\n    do {\n        iVar4 = (*_sym.imp.api_ms_win_crt_string_l1_1_0.dll__wcsicmp)(puVar9[10], 0x140005408);\n        if (iVar4 == 0) {\n            uVar6 = puVar9[4];\n            goto code_r0x000140001b75;\n        }\n        puVar9 = *puVar9;\n    } while (puVar9 != puVar12);\n    uVar6 = 0;\ncode_r0x000140001b75:\n    pcVar5 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar6);\n    if (pcVar5 != NULL) {\n        if (*(iVar15 + 0x94) != 0) {\n            puVar11 = *(iVar15 + 0x90) + *(arg1 + 0x30);\n            uVar3 = puVar11[3];\n            while (uVar3 != 0) {\n                uVar6 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(puVar11[3] + *(arg1 + 0x30));\n                puVar13 = *puVar11 + *(arg1 + 0x30);\n                iVar10 = puVar11[4] + *(arg1 + 0x30);\n                uVar14 = *puVar13;\n                while (uVar14 != 0) {\n                    if (uVar14 < 0) {\n                        uVar14 = uVar14 & 0xffff;\n                        arg2 = NULL;\n                    }\n                    else {\n                        iVar8 = -1;\n                        iVar7 = *(arg1 + 0x30) + 2 + uVar14;\n                        do {\n                            iVar8 = iVar8 + 1;\n                        } while (*(iVar7 + iVar8) != '\\0');\n                        auStack72 = CONCAT88(iVar7, auStack72._0_8_);\n                        uVar14 = 0;\n                        arg2 = auStack72;\n                        auStack72._0_4_ = CONCAT22(iVar8, iVar8);\n                    }\n                    iVar4 = fcn.1400022a0(uVar6, arg2, uVar14, iVar10);\n                    if (iVar4 == 0) goto code_r0x000140001d29;\n                    puVar1 = puVar13 + 1;\n                    puVar13 = puVar13 + 1;\n                    iVar10 = iVar10 + 8;\n                    uVar14 = *puVar1;\n                }\n                uVar3 = puVar11[8];\n                puVar11 = puVar11 + 5;\n            }\n        }\n        if (*(iVar15 + 0xf4) != 0) {\n            puVar11 = *(iVar15 + 0xf0) + 4 + *(arg1 + 0x30);\n            uVar3 = *puVar11;\n            while (uVar3 != 0) {\n                uVar6 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(uVar3 + *(arg1 + 0x30));\n                puVar13 = puVar11[3] + *(arg1 + 0x30);\n                iVar15 = puVar11[2] + *(arg1 + 0x30);\n                uVar14 = *puVar13;\n                while (uVar14 != 0) {\n                    if (uVar14 < 0) {\n                        (*pcVar5)(uVar6, 0, uVar14 & 0xffff, iVar15);\n                    }\n                    else {\n                        iVar10 = -1;\n                        iVar8 = *(arg1 + 0x30) + 2 + uVar14;\n                        do {\n                            iVar10 = iVar10 + 1;\n                        } while (*(iVar8 + iVar10) != '\\0');\n                        auStack72 = CONCAT88(iVar8, auStack72._0_8_);\n                        auStack72._0_4_ = CONCAT22(iVar10, iVar10);\n                        iVar4 = fcn.1400022a0(uVar6, auStack72, 0, iVar15);\n                        if (iVar4 == 0) goto code_r0x000140001d29;\n                    }\n                    puVar1 = puVar13 + 1;\n                    puVar13 = puVar13 + 1;\n                    iVar15 = iVar15 + 8;\n                    uVar14 = *puVar1;\n                }\n                puVar2 = puVar11 + 8;\n                puVar11 = puVar11 + 8;\n                uVar3 = *puVar2;\n            }\n        }\n    }\ncode_r0x000140001d29:\n    fcn.140004180(uStack56 ^ auStack104);\n    return;\n}\n",
        "token_count": 1295
    },
    "140001d5": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpflOldProtect\n\nvoid fcn.140001d50(int64_t arg1)\n\n{\n    code **ppcVar1;\n    uint32_t uVar2;\n    code **ppcVar3;\n    int32_t *piVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    ulong var_10h;\n    ulong lpflOldProtect;\n    uchar auStack88 [32];\n    uint32_t uStack56;\n    uint64_t uStack48;\n    \n    uStack48 = *0x140008228 ^ auStack88;\n    iVar6 = 0;\n    iVar7 = *(*(arg1 + 0x10) + 0x3c) + *(arg1 + 0x10);\n    if (*(iVar7 + 6) != 0) {\n        piVar4 = *(iVar7 + 0x14) + 0x28 + iVar7;\n        do {\n            if (*piVar4 != 0) {\n                uVar2 = piVar4[5];\n                if ((uVar2 >> 0x1d & 1) == 0) {\n                    if ((uVar2 & 0x40000000) == 0) {\n                        uStack56 = 8;\n                        if (-1 < uVar2) {\n                            uStack56 = 1;\n                        }\n                    }\n                    else {\n                        uStack56 = 4;\n                        if (-1 < uVar2) {\n                            uStack56 = 2;\n                        }\n                    }\n                }\n                else if ((uVar2 & 0x40000000) == 0) {\n                    uStack56 = 0x80;\n                    if (-1 < uVar2) {\n                        uStack56 = 0x10;\n                    }\n                }\n                else {\n                    uStack56 = 0x40;\n                    if (-1 < uVar2) {\n                        uStack56 = 0x20;\n                    }\n                }\n                if ((piVar4[5] & 0x4000000U) != 0) {\n                    uStack56 = uStack56 | 0x200;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualProtect)();\n            }\n            iVar6 = iVar6 + 1;\n            piVar4 = piVar4 + 10;\n        } while (iVar6 < *(iVar7 + 6));\n    }\n    (*_sym.imp.KERNEL32.dll_FlushInstructionCache)();\n    if (*(iVar7 + 0xd4) != 0) {\n        ppcVar3 = *(*(iVar7 + 0xd0) + 0x18 + *(arg1 + 0x30));\n        pcVar5 = *ppcVar3;\n        while (pcVar5 != NULL) {\n            (*pcVar5)(*(arg1 + 0x30), 1);\n            ppcVar1 = ppcVar3 + 1;\n            ppcVar3 = ppcVar3 + 1;\n            pcVar5 = *ppcVar1;\n        }\n    }\n    if (*(iVar7 + 0x28) != 0) {\n        iVar6 = fcn.140002fb0();\n        if (iVar6 == 0) {\n            fcn.140002d20(*(arg1 + 0x30) + 0x18db8, fcn.140001000, 0);\n            fcn.140002fa0(*(arg1 + 0x30) + 0x18db8);\n            fcn.140002d20(*(arg1 + 0x30) + 0x18d88, 0x1400017b0, 0);\n            fcn.140002fa0(*(arg1 + 0x30) + 0x18d88);\n            fcn.140002d20(*(arg1 + 0x30) + 0x18d00, 0x140001830, 0);\n            fcn.140002fa0(*(arg1 + 0x30) + 0x18d00);\n            fcn.140002d20(*(arg1 + 0x30) + 0x18d54, 0x1400018b0, 0);\n            fcn.140002fa0(*(arg1 + 0x30) + 0x18d54);\n        }\n        pcVar5 = *(iVar7 + 0x28) + *(arg1 + 0x30);\n        (*pcVar5)(*(arg1 + 0x30), 1, 0);\n        (*pcVar5)(*(arg1 + 0x30), 4);\n    }\n    fcn.140004180(uStack48 ^ auStack88);\n    return;\n}\n",
        "token_count": 1040
    },
    "null": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong main(ulong param_1, char16_t *param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int32_t aiStack72 [4];\n    char *pcStack56;\n    uint uStack48;\n    ulong uStack40;\n    ulong uStack32;\n    \n    uStack48 = 0x40e00;\n    aiStack72[0] = 0;\n    uStack32 = 0;\n    uStack40 = 0;\n    pcStack56 = str.MZARUH;\n    iVar1 = fcn.140001930(aiStack72);\n    if (iVar1 == 0) {\n        param_2 = L\"Failed to map sections\";\n    }\n    else {\n        iVar1 = fcn.140001b00(aiStack72);\n        if (iVar1 == 0) {\n            param_2 = L\"Failed to resolve imports\";\n        }\n        else {\n            iVar1 = fcn.140001d50(aiStack72);\n            if (iVar1 != 0) goto code_r0x0001400020a5;\n            param_2 = L\"Failed to execute\";\n        }\n    }\n    if (aiStack72[0] == 0) {\n        fcn.140001fc0(\"load failed: %S\\n\", param_2, param_3, param_4);\n        return 0;\n    }\ncode_r0x0001400020a5:\n    fcn.140001fc0(0x140005434, param_2, param_3, param_4);\n    return 0;\n}\n",
        "token_count": 349
    },
    "1400024a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.1400024a0(int64_t arg1, uint16_t *arg2, ulong arg3, char **arg4)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint64_t uVar3;\n    char *pcVar4;\n    uint64_t uVar5;\n    uint32_t uVar6;\n    char *pcVar7;\n    uint64_t uVar8;\n    char *pcVar9;\n    int64_t iVar10;\n    int32_t iVar11;\n    int64_t iVar12;\n    uint64_t uVar13;\n    char **arg4_00;\n    int32_t *piVar14;\n    int64_t iVar15;\n    uchar auStack392 [32];\n    char **ppcStack360;\n    char *pcStack352;\n    uchar auStack344 [16];\n    char acStack328 [256];\n    uint64_t uStack72;\n    \n    uStack72 = *0x140008228 ^ auStack392;\n    ppcStack360 = arg4;\n    if (arg1 != 0) {\n        piVar14 = *(arg1 + 0x3c) + arg1;\n        if (*piVar14 == 0x4550) {\n            uVar8 = 0;\n            if (*(piVar14 + 6) != 0) {\n                iVar12 = piVar14 + *(piVar14 + 5) + 0x18;\n                uVar5 = uVar8;\n                do {\n                    uVar3 = uVar8;\n                    while (*(uVar3 + 0x14000558c) == (uVar3 + 0x14000558c)[iVar12 + -0x14000558c]) {\n                        uVar3 = uVar3 + 1;\n                        if (5 < uVar3) {\n                            pcVar9 = *(iVar12 + 0xc) + arg1;\n                            if (((pcVar9 == NULL) || (pcVar9 + *(iVar12 + 0x10) == NULL)) || (piVar14[0x23] == 0))\n                            goto code_r0x0001400024fb;\n                            iVar10 = piVar14[0x22] + arg1;\n                            if (arg2 == NULL) {\n                                iVar2 = *(iVar10 + 0x14);\n                            }\n                            else {\n                                iVar2 = *(iVar10 + 0x18);\n                            }\n                            if (iVar2 < 1) goto code_r0x0001400024fb;\n                            iVar15 = -1;\n                            uVar5 = uVar8;\n                            goto code_r0x0001400025e0;\n                        }\n                    }\n                    uVar5 = uVar5 + 1;\n                    iVar12 = iVar12 + 0x28;\n                } while (uVar5 < *(piVar14 + 6));\n            }\n        }\n        else {\n            fcn.140001fc0(\"LocalLdrGetProcedureAddress: invalid IMAGE_NT_SIGNATURE\\n\", arg2, arg3, arg4);\n        }\n    }\ncode_r0x0001400024fb:\n    fcn.140004180(uStack72 ^ auStack392);\n    return;\ncode_r0x0001400025e0:\n    if (arg2 == NULL) {\n        iVar11 = *(iVar10 + 0x10);\n        uVar6 = *(*(iVar10 + 0x24) + arg1 + uVar5 * 2) + iVar11;\n        if (uVar6 == (arg3 & 0xffff)) {\ncode_r0x00014000265d:\n            pcStack352 = *(*(iVar10 + 0x1c) + (uVar6 - iVar11) * 4 + arg1) + arg1;\n            if ((pcVar9 <= pcStack352) && (pcStack352 <= pcVar9 + *(iVar12 + 0x10))) goto code_r0x0001400027de;\n            uVar5 = 0xffffffffffffffff;\n            do {\n                uVar5 = uVar5 + 1;\n            } while (pcStack352[uVar5] != '\\0');\n            uVar3 = uVar8;\n            pcVar9 = pcStack352;\n            if (uVar5 != 0) {\n                while (iVar2 = uVar3,  *pcVar9 != '.') {\n                    uVar3 = iVar2 + 1U;\n                    pcVar9 = pcVar9 + 1;\n                    if (uVar5 <= iVar2 + 1U) {\n                        *arg4 = pcStack352;\n                        goto code_r0x0001400024fb;\n                    }\n                }\n                if (iVar2 != 0) {\n                    uVar5 = iVar2;\n                    pcVar9 = pcStack352;\n                    do {\n                        pcVar9[acStack328 + -pcStack352] = *pcVar9;\n                        if (*pcVar9 == '\\0') break;\n                        pcVar9 = pcVar9 + 1;\n                    } while (pcVar9 - pcStack352 < uVar5);\n                    do {\n                        cVar1 = \".dll\"[uVar8];\n                        acStack328[uVar8 + uVar5] = cVar1;\n                        if (cVar1 == '\\0') break;\n                        uVar8 = uVar8 + 1;\n                    } while (uVar8 < 5);\n                    pcVar9 = pcStack352 + uVar5 + 1;\n                    do {\n                        iVar15 = iVar15 + 1;\n                    } while (pcVar9[iVar15] != '\\0');\n                    auStack344 = CONCAT88(pcVar9, auStack344._0_8_);\n                    iVar12 = fcn.1400020c0(acStack328);\n                    if ((iVar12 == 0) || (iVar12 == arg1)) goto code_r0x0001400024fb;\n                    arg4_00 = &pcStack352;\n                    iVar2 = fcn.1400022a0(iVar12, auStack344, 0, arg4_00);\n                    if (iVar2 == 0) {\n                        fcn.140001fc0(\"LocalLdrGetProcedureAddress: failed to resolve address of: %s!%s\\n\", acStack328, \n                                      pcVar9, arg4_00);\n                        goto code_r0x0001400024fb;\n                    }\n                }\n            }\ncode_r0x0001400027de:\n            *ppcStack360 = pcStack352;\n            goto code_r0x0001400024fb;\n        }\n    }\n    else {\n        uVar3 = 0xffffffffffffffff;\n        pcVar7 = *(*(iVar10 + 0x20) + arg1 + uVar5 * 4) + arg1;\n        do {\n            uVar3 = uVar3 + 1;\n        } while (pcVar7[uVar3] != '\\0');\n        uVar13 = *arg2;\n        if (uVar3 == uVar13) {\n            if (uVar13 == 0) {\ncode_r0x00014000264b:\n                iVar11 = *(iVar10 + 0x10);\n                uVar6 = *(*(iVar10 + 0x24) + arg1 + uVar5 * 2) + iVar11;\n                goto code_r0x00014000265d;\n            }\n            pcVar4 = pcVar7;\n            while (*pcVar4 == pcVar4[*(arg2 + 4) - pcVar7]) {\n                pcVar4 = pcVar4 + 1;\n                if (uVar13 <= pcVar4 - pcVar7) goto code_r0x00014000264b;\n            }\n        }\n    }\n    uVar5 = uVar5 + 1;\n    if (iVar2 <= uVar5) goto code_r0x0001400024fb;\n    goto code_r0x0001400025e0;\n}\n",
        "token_count": 1722
    },
    "1400027f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.1400027f0(ulong arg1)\n\n{\n    int32_t iVar1;\n    uint8_t *puVar2;\n    int64_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint64_t uVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint *puStack24;\n    uint32_t uStack12;\n    \n    iVar7 = 0;\n    uVar4 = 0;\n    iVar1 = iVar7;\n    if (*0x14004967c != 0) {\n        puVar2 = *0x140049670 + 0x20;\n        while ((*puVar2 >> 1 & 1) == arg1) {\n            uVar4 = uVar4 + 1;\n            puVar2 = puVar2 + 0x38;\n            if (*0x14004967c <= uVar4) {\n                return 0;\n            }\n        }\n        iVar1 = 0;\n        if (uVar4 != 0xffffffff) {\n            fcn.140002b70(&puStack24, 0xffffffff, arg1 != 0);\n            iVar1 = iVar7;\n            uVar8 = *0x14004967c;\n            if (uVar4 < *0x14004967c) {\n                do {\n                    iVar1 = iVar7;\n                    if (((*(uVar4 * 0x38 + 0x20 + *0x140049670) >> 1 & 1) != arg1) &&\n                       (iVar1 = fcn.140002a60(uVar4, arg1),  uVar8 = *0x14004967c,  iVar1 != 0)) break;\n                    uVar4 = uVar4 + 1;\n                    iVar7 = iVar1;\n                } while (uVar4 < uVar8);\n            }\n            if (puStack24 != NULL) {\n                if (uStack12 != 0) {\n                    uVar6 = uStack12;\n                    puVar5 = puStack24;\n                    do {\n                        iVar3 = (*_sym.imp.KERNEL32.dll_OpenThread)(0x5a, 0, *puVar5);\n                        if (iVar3 != 0) {\n                            (*_sym.imp.KERNEL32.dll_ResumeThread)(iVar3);\n                            (*_sym.imp.KERNEL32.dll_CloseHandle)();\n                        }\n                        puVar5 = puVar5 + 1;\n                        uVar6 = uVar6 - 1;\n                    } while (uVar6 != 0);\n                }\n                (*_sym.imp.KERNEL32.dll_HeapFree)(*0x140049068, 0, puStack24);\n            }\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 600
    },
    "14000305": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140003050(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    int32_t iVar1;\n    int64_t *piVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    uint32_t uVar5;\n    uint64_t uVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    uint64_t uVar9;\n    int64_t iVar10;\n    uchar auStack1288 [80];\n    uint uStack1208;\n    int64_t iStack1008;\n    uint64_t uStack24;\n    \n    uStack24 = *0x140008228 ^ auStack1288;\n    uStack1208 = 0x100001;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetThreadContext)();\n    if (iVar1 != 0) {\n        uVar3 = *0x14004967c;\n        if (arg2 != 0xffffffff) {\n            uVar3 = arg2 + 1;\n        }\n        uVar9 = 0;\n        if (arg2 != 0xffffffff) {\n            uVar9 = arg2;\n        }\n        if (uVar9 < uVar3) {\n            iVar8 = uVar9 * 0x38;\n            uVar9 = uVar3 - uVar9;\n            iVar10 = iStack1008;\n            do {\n                piVar2 = *0x140049670 + iVar8;\n                if (arg3 == 0) {\n                    uVar4 = 0;\n                }\n                else if (arg3 == 1) {\n                    uVar4 = 1;\n                }\n                else {\n                    uVar4 = *(piVar2 + 4) >> 2 & 1;\n                }\n                if ((*(piVar2 + 4) >> 1 & 1) != uVar4) {\n                    if (uVar4 == 0) {\n                        if (((*(piVar2 + 4) & 1) == 0) || (iVar7 = *piVar2,  iVar10 != iVar7 + -5)) {\n                            uVar6 = 0;\n                            uVar3 = *(piVar2 + 0x24) & 0xf;\n                            if (uVar3 != 0) {\n                                do {\n                                    if (iVar10 == *(uVar6 + 0x30 + piVar2) + piVar2[2]) {\n                                        iVar7 = *(uVar6 + 0x28 + piVar2) + *piVar2;\n                                        goto code_r0x000140003190;\n                                    }\n                                    uVar5 = uVar6 + 1;\n                                    uVar6 = uVar5;\n                                } while (uVar5 < uVar3);\n                            }\n                            if (iVar10 != piVar2[1]) goto code_r0x0001400031b3;\n                            iVar7 = *piVar2;\n                        }\ncode_r0x000140003190:\n                        if (iVar7 != 0) {\n                            iStack1008 = iVar7;\n                            (*_sym.imp.KERNEL32.dll_SetThreadContext)();\n                            iVar10 = iStack1008;\n                        }\n                    }\n                    else {\n                        uVar6 = 0;\n                        uVar3 = *(piVar2 + 0x24) & 0xf;\n                        if (uVar3 != 0) {\n                            do {\n                                if (iVar10 == *(uVar6 + 0x28 + piVar2) + *piVar2) {\n                                    iVar7 = *(uVar6 + 0x30 + piVar2) + piVar2[2];\n                                    goto code_r0x000140003190;\n                                }\n                                uVar5 = uVar6 + 1;\n                                uVar6 = uVar5;\n                            } while (uVar5 < uVar3);\n                        }\n                    }\n                }\ncode_r0x0001400031b3:\n                iVar8 = iVar8 + 0x38;\n                uVar9 = uVar9 - 1;\n            } while (uVar9 != 0);\n        }\n    }\n    fcn.140004180(uStack24 ^ auStack1288);\n    return;\n}\n",
        "token_count": 910
    },
    "14000333": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nulong * fcn.140003330(ulong *arg1)\n\n{\n    uint32_t uVar1;\n    int64_t iVar2;\n    ulong *puVar3;\n    uint64_t uVar4;\n    ulong *puVar5;\n    uint64_t uVar6;\n    ulong *puVar7;\n    uchar auStack120 [8];\n    ulong *puStack112;\n    ulong *puStack104;\n    uint32_t uStack80;\n    int64_t iStack72;\n    uint64_t uStack64;\n    int64_t iStack48;\n    int32_t iStack40;\n    ulong var_1h;\n    \n    (*_sym.imp.KERNEL32.dll_GetSystemInfo)(auStack120);\n    if ((0x40000000 < arg1) && (puStack112 < arg1 + -0x8000000)) {\n        puStack112 = arg1 + -0x8000000;\n    }\n    puVar7 = arg1 + 0x8000000;\n    if (puStack104 <= arg1 + 0x8000000) {\n        puVar7 = puStack104;\n    }\n    puVar7 = puVar7 - 0xfff;\n    for (puVar3 = *0x140049660; puVar3 != NULL; puVar3 = *puVar3) {\n        if (((puStack112 <= puVar3) && (puVar3 < puVar7)) && (puVar3[1] != 0)) {\n            return puVar3;\n        }\n    }\n    puVar5 = arg1;\n    if (puStack112 <= arg1) {\n        do {\n            uVar4 = uStack80;\n            puVar5 = puVar5 + (-uVar4 - puVar5 % uVar4);\n            while( true ) {\n                if ((puVar5 < puStack112) ||\n                   (iVar2 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar5, &iStack72, 0x30),  iVar2 == 0))\n                goto code_r0x000140003429;\n                if (iStack40 == 0x10000) break;\n                if (uStack64 < uVar4) goto code_r0x000140003429;\n                puVar5 = uStack64 - uVar4;\n            }\n            if (puVar5 == NULL) {\ncode_r0x000140003429:\n                if (puVar3 != NULL) goto code_r0x000140003516;\n                break;\n            }\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(puVar5, 0x1000, 0x3000, 0x40);\n            if (puVar3 != NULL) goto code_r0x000140003516;\n        } while (puStack112 <= puVar5);\n    }\n    if (arg1 <= puVar7) {\n        do {\n            uVar1 = uStack80;\n            uVar4 = uStack80;\n            arg1 = (uStack80 - arg1 % uVar4) + arg1;\n            while( true ) {\n                if (puVar7 < arg1) {\n                    return puVar3;\n                }\n                iVar2 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(arg1, &iStack72, 0x30);\n                if (iVar2 == 0) {\n                    return puVar3;\n                }\n                if (iStack40 == 0x10000) break;\n                uVar6 = (uVar1 - 1) + iStack48 + iStack72;\n                arg1 = uVar6 - uVar6 % uVar4;\n            }\n            if (arg1 == NULL) {\n                return puVar3;\n            }\n            puVar3 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(arg1, 0x1000, 0x3000, 0x40);\n            if (puVar3 != NULL) {\ncode_r0x000140003516:\n                puVar7 = puVar3 + 8;\n                puVar3[1] = 0;\n                uVar4 = puVar7 - puVar3;\n                *(puVar3 + 2) = 0;\n                do {\n                    uVar4 = uVar4 + 0x40;\n                    *puVar7 = puVar3[1];\n                    puVar3[1] = puVar7;\n                    puVar7 = puVar7 + 8;\n                } while (uVar4 < 0xfc1);\n                *puVar3 = *0x140049660;\n                *0x140049660 = puVar3;\n                return puVar3;\n            }\n        } while (arg1 <= puVar7);\n    }\n    return puVar3;\n}\n",
        "token_count": 1053
    },
    "1400039d": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint8_t fcn.1400039d0(ulong *arg1, uint8_t *arg2)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    ushort uVar3;\n    uint uVar4;\n    ulong uVar5;\n    uint8_t uVar6;\n    uint8_t uVar7;\n    uint8_t uVar8;\n    int64_t iVar9;\n    uint8_t *puVar10;\n    uint8_t *puVar11;\n    uint8_t uVar12;\n    uint32_t uVar13;\n    uint8_t uVar14;\n    uint64_t uVar15;\n    ulong *puVar16;\n    ulong *puVar17;\n    ushort *puVar18;\n    uint *puVar19;\n    char cVar20;\n    uint8_t uVar21;\n    uint32_t uVar22;\n    uint32_t uVar23;\n    int64_t iVar24;\n    uint8_t uVar25;\n    char cVar26;\n    char cStackX8;\n    uint8_t uStackX32;\n    \n    iVar24 = 0x140008000;\n    uVar6 = 0;\n    cVar26 = false;\n    puVar10 = arg2;\n    for (iVar9 = 0x25; iVar9 != 0; iVar9 = iVar9 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    cVar20 = '\\x10';\n    puVar17 = arg1;\n    do {\n        puVar16 = puVar17;\n        uVar14 = *puVar16;\n        uVar15 = uVar14;\n        puVar17 = puVar16 + 1;\n    // switch table (7 cases) at 0x140004084\n        switch(uVar14) {\n        case 0x26:\n        case 0x2e:\n        case 0x36:\n        case 0x3e:\n        case 100:\n        case 0x65:\n            arg2[3] = uVar14;\n            uVar12 = 0x40;\n            break;\n        default:\n            goto code_r0x000140003a8d;\n        case 0x66:\n            arg2[4] = uVar14;\n            uVar12 = 8;\n            break;\n        case 0x67:\n            arg2[5] = uVar14;\n            uVar12 = 0x10;\n            break;\n        case 0xf0:\n            arg2[2] = uVar14;\n            uVar12 = 0x20;\n            break;\n        case 0xf2:\n            arg2[1] = uVar14;\n            uVar12 = 2;\n            break;\n        case 0xf3:\n            arg2[1] = uVar14;\n            uVar12 = 4;\n        }\n        uVar6 = uVar6 | uVar12;\n        cVar20 = cVar20 + -1;\n    } while (cVar20 != '\\0');\ncode_r0x000140003a8d:\n    uVar22 = uVar6 << 0x17;\n    uVar12 = 1;\n    if (uVar6 != 0) {\n        uVar12 = uVar6;\n    }\n    *(arg2 + 0x21) = uVar22;\n    if ((uVar14 & 0xf0) == 0x40) {\n        uVar22 = uVar22 | 0x40000000;\n        uVar6 = uVar14 >> 3 & 1;\n        *(arg2 + 0x21) = uVar22;\n        arg2[7] = uVar6;\n        if (uVar6 != 0) {\n            cVar26 = (*puVar17 & 0xf8) == 0xb8;\n        }\n        arg2[8] = uVar14 >> 2 & 1;\n        arg2[10] = uVar14 & 1;\n        arg2[9] = uVar14 >> 1 & 1;\n        uVar6 = *puVar17;\n        uVar15 = uVar6;\n        puVar17 = puVar16 + 2;\n        if ((uVar6 & 0xf0) != 0x40) goto code_r0x000140003b28;\ncode_r0x000140003b8d:\n        uVar22 = uVar22 | 0x3000;\n        uVar14 = uVar15;\n        *(arg2 + 0x21) = uVar22;\n        uVar13 = 0;\n        if ((uVar14 & 0xfd) != 0x24) goto code_r0x000140003bb2;\n        uVar13 = 1;\n        cVar20 = '\\0';\n    }\n    else {\ncode_r0x000140003b28:\n        uVar6 = uVar15;\n        arg2[0xb] = uVar6;\n        if (uVar6 == 0xf) {\n            uVar15 = *puVar17;\n            iVar24 = 0x14000804a;\n            arg2[0xc] = *puVar17;\n            puVar17 = puVar17 + 1;\n        }\n        else if ((0x9f < uVar6) && (uVar6 < 0xa4)) {\n            cVar26 = cVar26 + '\\x01';\n            if ((uVar12 & 0x10) == 0) {\n                uVar12 = uVar12 & 0xf7;\n            }\n            else {\n                uVar12 = uVar12 | 8;\n            }\n        }\n        uVar6 = uVar15;\n        uVar14 = *((uVar15 & 3) + *((uVar15 >> 2) + iVar24) + iVar24);\n        uVar13 = uVar14;\n        if (uVar14 == 0xff) goto code_r0x000140003b8d;\ncode_r0x000140003bb2:\n        cVar20 = '\\0';\n        uVar14 = uVar15;\n        if (uVar13 < '\\0') {\n            uVar2 = *((uVar13 & 0x7f) + iVar24);\n            uVar13 = uVar2;\n            cVar20 = uVar2 >> 8;\n        }\n    }\n    uVar1 = arg2[0xc];\n    if ((uVar1 != 0) &&\n       ((\"@@@@AI@@@@LB@@@@@@@@ODS@@@DWC\\\\@`@@@@@@@@@@@@@@dfnk@@jF@@DF@@[D@@\"\n         [\"@@@@AI@@@@LB@@@@@@@@ODS@@@DWC\\\\@`@@@@@@@@@@@@@@dfnk@@jF@@DF@@[D@@\"[uVar15 >> 2] + (uVar15 & 3)] & uVar12) !=\n        0)) {\n        uVar22 = uVar22 | 0x3000;\n        *(arg2 + 0x21) = uVar22;\n    }\n    if ((uVar13 & 1) == 0) {\n        if ((uVar12 & 0x20) != 0) {\n            *(arg2 + 0x21) = uVar22 | 0x9000;\n        }\n    }\n    else {\n        uVar23 = uVar22 | 1;\n        *(arg2 + 0x21) = uVar23;\n        uVar21 = *puVar17;\n        arg2[0xd] = uVar21;\n        uVar25 = uVar21 >> 6;\n        uVar7 = uVar21 & 7;\n        uVar21 = uVar21 >> 3 & 7;\n        arg2[0xe] = uVar25;\n        arg2[0x10] = uVar7;\n        arg2[0xf] = uVar21;\n        if ((cVar20 != '\\0') && (cVar20 << uVar21 < '\\0')) {\n            uVar23 = uVar22 | 0x3001;\n            *(arg2 + 0x21) = uVar23;\n        }\n        if (((uVar1 == 0) && (0xd8 < uVar6)) && (uVar6 < 0xe0)) {\n            if (uVar25 == 3) {\n                cVar20 = *(uVar21 + (uVar6 + 0x27) * 8 + 0x140008104);\n                uVar8 = uVar7;\n            }\n            else {\n                cVar20 = *(uVar6 + 0x27 + 0x1400080fd);\n                uVar8 = uVar21;\n            }\n            if (cVar20 << uVar8 < '\\0') {\n                uVar23 = uVar23 | 0x3000;\n                *(arg2 + 0x21) = uVar23;\n            }\n        }\n        if ((uVar12 & 0x20) != 0) {\n            if (uVar25 == 3) {\n                *(arg2 + 0x21) = uVar23 | 0x9000;\n            }\n            else {\n                if (uVar1 == 0) {\n                    puVar11 = 0x1400081c6;\n                    puVar10 = 0x1400081ae;\n                    uVar8 = uVar6 & 0xfe;\n                }\n                else {\n                    puVar11 = 0x1400081d8;\n                    puVar10 = 0x1400081c6;\n                    uVar8 = uVar6;\n                }\n                do {\n                    if (*puVar10 == uVar8) {\n                        if (-1 < puVar10[1] << uVar21) goto code_r0x000140003d3d;\n                        break;\n                    }\n                    puVar10 = puVar10 + 2;\n                } while (puVar10 != puVar11);\n                *(arg2 + 0x21) = *(arg2 + 0x21) | 0x9000;\n            }\n        }\ncode_r0x000140003d3d:\n        if (uVar1 == 0) {\n            if (uVar14 == 0x8c) {\ncode_r0x000140003e1d:\n                if (5 < uVar21) goto code_r0x000140003e23;\n            }\n            else {\n                if (uVar14 == 0x8e) {\n                    if (uVar21 != 1) goto code_r0x000140003e1d;\n                    goto code_r0x000140003e23;\n                }\ncode_r0x000140003d9d:\n                if (uVar25 == 3) {\n                    if (uVar1 == 0) {\n                        puVar11 = 0x1400081e7;\n                        puVar10 = 0x1400081d8;\n                    }\n                    else {\n                        puVar11 = 0x140008211;\n                        puVar10 = 0x1400081e7;\n                    }\n                    do {\n                        if (*puVar10 == uVar6) {\n                            if (((puVar10[1] & uVar12) != 0) && (-1 < puVar10[2] << uVar21)) goto code_r0x000140003e23;\n                            break;\n                        }\n                        puVar10 = puVar10 + 3;\n                    } while (puVar10 != puVar11);\n                }\n                else if (uVar1 != 0) {\n                    if (uVar14 == 0x50) {\ncode_r0x000140003e09:\n                        uVar14 = uVar12 & 9;\n                    }\n                    else {\n                        if (uVar14 == 0xc5) goto code_r0x000140003e23;\n                        if (uVar14 != 0xd6) {\n                            if ((uVar14 != 0xd7) && (uVar14 != 0xf7)) goto code_r0x000140003e2b;\n                            goto code_r0x000140003e09;\n                        }\n                        uVar14 = uVar12 & 6;\n                    }\n                    if (uVar14 != 0) goto code_r0x000140003e23;\n                }\n            }\n        }\n        else if (uVar14 == 0x20) {\ncode_r0x000140003d70:\n            uVar25 = 3;\n            if ((4 < uVar21) || (uVar21 == 1)) goto code_r0x000140003e23;\n        }\n        else {\n            if (uVar14 != 0x21) {\n                if (uVar14 == 0x22) goto code_r0x000140003d70;\n                if (uVar14 != 0x23) goto code_r0x000140003d9d;\n            }\n            uVar25 = 3;\n            if (uVar21 - 4 < 2) {\ncode_r0x000140003e23:\n                *(arg2 + 0x21) = *(arg2 + 0x21) | 0x11000;\n            }\n        }\ncode_r0x000140003e2b:\n        uVar14 = *(puVar17 + 1);\n        puVar18 = puVar17 + 2;\n        if (uVar21 < 2) {\n            if (uVar6 == 0xf6) {\n                uVar13 = uVar13 | 2;\n            }\n            else if (uVar6 == 0xf7) {\n                uVar13 = uVar13 | 0x10;\n            }\n        }\n        if (uVar25 == 0) {\n            if ((uVar12 & 0x10) == 0) {\n                uStackX32 = 0;\n                if (uVar7 == 5) {\n                    uStackX32 = 4;\n                }\n            }\n            else {\n                uStackX32 = 2;\n                if (uVar7 != 6) {\n                    uStackX32 = 0;\n                }\n            }\n        }\n        else if (uVar25 == 1) {\n            uStackX32 = 1;\n        }\n        else if (uVar25 == 2) {\n            uStackX32 = 2;\n            if ((uVar12 & 0x10) == 0) {\n                uStackX32 = 4;\n            }\n        }\n        else {\n            uStackX32 = 0;\n        }\n        if ((uVar25 != 3) && (uVar7 == 4)) {\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 2;\n            puVar18 = puVar17 + 3;\n            arg2[0x12] = uVar14 >> 6;\n            arg2[0x11] = uVar14;\n            arg2[0x13] = uVar14 >> 3 & 7;\n            arg2[0x14] = uVar14 & 7;\n            if (((uVar14 & 7) == 5) && ((uVar25 & 1) == 0)) {\n                uStackX32 = 4;\n            }\n        }\n        puVar19 = puVar18 + -1;\n        if (uStackX32 == 1) {\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 0x40;\n            arg2[0x1d] = *puVar19;\ncode_r0x000140003f55:\n            puVar17 = puVar19 + uStackX32;\n        }\n        else if (uStackX32 == 2) {\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 0x80;\n            *(arg2 + 0x1d) = *puVar19;\n            puVar17 = puVar18 + 1;\n        }\n        else {\n            if (uStackX32 != 4) goto code_r0x000140003f55;\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 0x100;\n            *(arg2 + 0x1d) = *puVar19;\n            puVar17 = puVar18 + 3;\n        }\n    }\n    if ((uVar13 & 0x10) == 0) goto code_r0x000140003fe3;\n    if ((uVar13 & 0x40) == 0) {\n        if (cVar26 == '\\0') {\n            if ((uVar12 & 8) == 0) {\n                *(arg2 + 0x21) = *(arg2 + 0x21) | 0x10;\n                uVar4 = *puVar17;\n                puVar17 = puVar17 + 4;\n                *(arg2 + 0x15) = uVar4;\n                goto code_r0x000140003fe3;\n            }\ncode_r0x000140003fe9:\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 8;\n            uVar3 = *puVar17;\n            puVar17 = puVar17 + 2;\n            *(arg2 + 0x15) = uVar3;\n        }\n        else {\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 0x20;\n            uVar5 = *puVar17;\n            puVar17 = puVar17 + 1;\n            *(arg2 + 0x15) = uVar5;\ncode_r0x000140003fe3:\n            if ((uVar13 & 4) != 0) goto code_r0x000140003fe9;\n        }\n        if ((uVar13 & 2) != 0) {\n            *(arg2 + 0x21) = *(arg2 + 0x21) | 4;\n            uVar6 = *puVar17;\n            puVar17 = puVar17 + 1;\n            arg2[0x15] = uVar6;\n        }\n        if ((uVar13 & 0x40) == 0) {\n            if ((uVar13 & 0x20) != 0) {\n                *(arg2 + 0x21) = *(arg2 + 0x21) | 0x204;\n                uVar6 = *puVar17;\n                puVar17 = puVar17 + 1;\n                arg2[0x15] = uVar6;\n            }\n            goto code_r0x000140004045;\n        }\n    }\n    else if ((uVar12 & 8) != 0) {\n        *(arg2 + 0x21) = *(arg2 + 0x21) | 0x208;\n        uVar3 = *puVar17;\n        puVar17 = puVar17 + 2;\n        *(arg2 + 0x15) = uVar3;\n        goto code_r0x000140004045;\n    }\n    *(arg2 + 0x21) = *(arg2 + 0x21) | 0x210;\n    uVar4 = *puVar17;\n    puVar17 = puVar17 + 4;\n    *(arg2 + 0x15) = uVar4;\ncode_r0x000140004045:\n    cStackX8 = arg1;\n    uVar6 = puVar17 - cStackX8;\n    *arg2 = uVar6;\n    if (0xf < uVar6) {\n        *(arg2 + 0x21) = *(arg2 + 0x21) | 0x5000;\n        *arg2 = 0xf;\n        return 0xf;\n    }\n    return uVar6;\n}\n",
        "token_count": 4358
    },
    "1400035e": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1fh\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Variable defined which should be unmapped: var_2fh\n// WARNING: Variable defined which should be unmapped: var_11h_2\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.1400035e0(uint64_t **arg1)\n\n{\n    char cVar1;\n    uint64_t *puVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    char *pcVar5;\n    uint32_t uVar6;\n    uint64_t uVar7;\n    int64_t iVar8;\n    uint64_t *puVar9;\n    uint64_t *arg1_00;\n    uint64_t uVar10;\n    uint64_t *puVar11;\n    uint64_t *puVar12;\n    uchar *puVar13;\n    uint8_t uVar14;\n    uint8_t uVar15;\n    uint64_t *puVar16;\n    ulong var_fh;\n    ulong var_1fh;\n    ulong var_2fh;\n    uchar auStack200 [32];\n    uint8_t uStack168;\n    uint8_t uStack167;\n    uint64_t uStack160;\n    uint8_t auStack152 [11];\n    uint8_t uStack141;\n    uint8_t uStack140;\n    uint8_t uStack139;\n    char cStack137;\n    int32_t iStack131;\n    int32_t iStack123;\n    uint32_t uStack119;\n    ushort uStack112;\n    uint uStack110;\n    ushort uStack106;\n    uint uStack104;\n    ushort uStack100;\n    uint64_t uStack96;\n    uchar auStack88 [7];\n    ulong var_49h;\n    uchar auStack72 [7];\n    ulong var_39h;\n    uint64_t var_2ch;\n    ulong var_24h;\n    ulong var_11h_2;\n    ulong var_1h;\n    \n    *NULL = *0x140008228 ^ auStack200;\n    puVar9 = NULL;\n    var_49h._1_2_ = 0x15ff;\n    uVar7 = 0;\n    var_49h._3_4_ = 2;\n    stack0xffffffffffffffb6 = 0x8eb;\n    uStack168 = 0;\n    _auStack72 = NULL;\n    uStack112 = 0x25ff;\n    uStack110 = 0;\n    uStack106 = 0;\n    uStack104 = 0;\n    uStack100 = 0;\n    uStack96 = 0x25ff0e70;\n    _auStack88 = NULL;\n    uStack167 = 0;\n    arg1[4] = NULL;\n    puVar11 = puVar9;\n    do {\n        uVar10 = uStack168;\n        puVar2 = arg1[2];\n        uVar6 = uStack168;\n        arg1_00 = uVar7 + *arg1;\n        uStack160 = uVar10;\n        uVar3 = fcn.1400039d0(arg1_00, auStack152);\n        uVar7 = uVar3;\n        if ((uStack119 >> 0xc & 1) != 0) goto code_r0x00014000395a;\n        puVar16 = puVar11;\n        if (uStack167 < 5) {\n            if ((uStack139 & 199) == 5) {\n                puVar12 = &var_39h + 1;\n                puVar11 = arg1_00;\n                puVar13 = &var_39h + 1;\n                for (; uVar7 != 0; uVar7 = uVar7 - 1) {\n                    *puVar13 = *puVar11;\n                    puVar11 = puVar11 + 1;\n                    puVar13 = puVar13 + 1;\n                }\n                *(auStack72 + (auStack152[0] - (uStack119 >> 2 & 0xf)) + 4) = (arg1_00 - (puVar2 + uVar6)) + iStack123;\n                uVar10 = uStack160;\n                if ((uStack141 == 0xff) && (cStack137 == '\\x04')) {\n                    puVar9 = 0x1;\n                }\n            }\n            else if (uStack141 == 0xe8) {\n                uVar3 = 0x10;\n                _auStack72 = arg1_00 + auStack152[0] + iStack131;\n                puVar12 = &var_49h + 1;\n            }\n            else {\n                puVar12 = arg1_00;\n                if ((uStack141 & 0xfd) == 0xe9) {\n                    iVar8 = iStack131;\n                    if (uStack141 != 0xeb) {\n                        iVar8 = iStack131;\n                    }\n                    puVar16 = arg1_00 + iVar8 + auStack152[0];\n                    if ((puVar16 < *arg1) || (*arg1 + 5 <= puVar16)) {\n                        uStack106 = SUB82(puVar16, 0);\n                        uStack104 = puVar16 >> 0x10;\n                        uStack100 = puVar16 >> 0x30;\n                        puVar9 = puVar11 <= arg1_00;\n                        uVar3 = 0xe;\n                        puVar12 = &uStack112;\n                        puVar16 = puVar11;\n                    }\n                    else if (puVar16 <= puVar11) {\n                        puVar16 = puVar11;\n                    }\n                }\n                else if ((((uStack141 & 0xf0) == 0x70) || ((uStack141 & 0xfc) == 0xe0)) || ((uStack140 & 0xf0) == 0x80))\n                {\n                    if (((uStack141 & 0xf0) == 0x70) || (iVar8 = iStack131,  (uStack141 & 0xfc) == 0xe0)) {\n                        iVar8 = iStack131;\n                    }\n                    puVar16 = arg1_00 + iVar8 + auStack152[0];\n                    if ((puVar16 < *arg1) || (*arg1 + 5 <= puVar16)) {\n                        if ((uStack141 & 0xfc) == 0xe0) goto code_r0x00014000395a;\n                        uVar15 = uStack141;\n                        if (uStack141 == 0xf) {\n                            uVar15 = uStack140;\n                        }\n                        _auStack88 = puVar16;\n                        uStack96 = (uStack96 & 0xffffffffffffff00 | uVar15 & 0xffffffffffffff0f) ^ 0x71;\n                        uVar3 = 0x10;\n                        uVar10 = uStack160;\n                        puVar12 = &uStack96;\n                        puVar16 = puVar11;\n                    }\n                    else {\n                        uVar10 = uStack160;\n                        if (puVar16 <= puVar11) {\n                            puVar16 = puVar11;\n                        }\n                    }\n                }\n                else {\n                    uVar10 = uStack160;\n                    if ((uStack141 & 0xfe) == 0xc2) {\n                        puVar9 = puVar11 <= arg1_00;\n                    }\n                }\n            }\n        }\n        else {\n            uVar3 = 0xe;\n            uStack106 = SUB82(arg1_00, 0);\n            uStack104 = arg1_00 >> 0x10;\n            uStack100 = arg1_00 >> 0x30;\n            puVar9 = 0x1;\n            puVar12 = &uStack112;\n        }\n        if ((((arg1_00 < puVar16) && (uVar3 != auStack152[0])) || (0x32 < uVar3 + uStack168)) || (7 < *(arg1 + 0x24)))\n        goto code_r0x00014000395a;\n        *(*(arg1 + 0x24) + 0x28 + arg1) = uStack167;\n        *(*(arg1 + 0x24) + 0x30 + arg1) = uStack168;\n        uVar15 = uStack168 + uVar3;\n        *(arg1 + 0x24) = *(arg1 + 0x24) + 1;\n        puVar13 = arg1[2] + uVar10;\n        for (uVar7 = uVar3; uVar7 != 0; uVar7 = uVar7 - 1) {\n            *puVar13 = *puVar12;\n            puVar12 = puVar12 + 1;\n            puVar13 = puVar13 + 1;\n        }\n        uVar14 = uStack167 + auStack152[0];\n        uVar7 = uVar14;\n        puVar11 = puVar16;\n        uStack168 = uVar15;\n        uStack167 = uVar14;\n    } while (puVar9 == 0);\n    if (uVar14 < 5) {\n        puVar9 = *arg1;\n        uVar6 = uVar14;\n        iVar8 = uVar14 + puVar9;\n        iVar4 = fcn.140003990(iVar8, 5 - uVar6);\n        if (iVar4 == 0) {\n            if (((uVar14 < 2) && (iVar4 = fcn.140003990(iVar8, 2 - uVar6),  iVar4 == 0)) ||\n               (iVar4 = fcn.1400035a0(puVar9 + -5),  iVar4 == 0)) goto code_r0x00014000395a;\n            cVar1 = *(*arg1 + -5);\n            if (((cVar1 != '\\0') && (cVar1 != -0x70)) && (cVar1 != -0x34)) goto code_r0x00014000395a;\n            uVar6 = 1;\n            pcVar5 = *arg1 + -4;\n            do {\n                if (*pcVar5 != cVar1) goto code_r0x00014000395a;\n                uVar6 = uVar6 + 1;\n                pcVar5 = pcVar5 + 1;\n            } while (uVar6 < 5);\n            *(arg1 + 4) = 1;\n        }\n    }\n    puVar9 = arg1[1];\n    uStack106 = SUB82(puVar9, 0);\n    uStack104 = puVar9 >> 0x10;\n    uStack100 = puVar9 >> 0x30;\n    puVar9 = uVar15 + arg1[2];\n    arg1[3] = puVar9;\n    *puVar9 = CONCAT26(uStack106, CONCAT42(uStack110, uStack112));\n    *(puVar9 + 1) = uStack104;\n    *(puVar9 + 0xc) = uStack100;\ncode_r0x00014000395a:\n    fcn.140004180(stack0xffffffffffffffd0 ^ auStack200);\n    return;\n}\n",
        "token_count": 2487
    },
    "140001fc": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nvoid fcn.140001fc0(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong uVar1;\n    ulong *puVar2;\n    ulong uStackX16;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX16 = arg2;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    uVar1 = (*_sym.imp.api_ms_win_crt_stdio_l1_1_0.dll___acrt_iob_func)(1);\n    puVar2 = fcn.140001fb0();\n    (*_sym.imp.api_ms_win_crt_stdio_l1_1_0.dll___stdio_common_vfprintf)(*puVar2, uVar1, arg1, 0, &uStackX16);\n    return;\n}\n",
        "token_count": 181
    },
    "140002fa": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nuint fcn.140002fa0(int64_t arg1)\n\n{\n    uint uVar1;\n    int64_t *piVar2;\n    uint32_t uVar3;\n    uchar auStack24 [16];\n    uint64_t arg2;\n    \n    arg2 = 0;\n    LOCK();\n    if (*0x140049060 != 0) {\n        do {\n            (*_sym.imp.KERNEL32.dll_Sleep)();\n            LOCK();\n        } while (*0x140049060 != 0);\n    }\n    *0x140049060 = 1;\n    if (*0x140049068 == 0) {\n        uVar1 = 2;\n    }\n    else if (arg1 == 0) {\n        uVar1 = fcn.1400027f0(1);\n    }\n    else {\n        piVar2 = *0x140049670;\n        if (*0x14004967c != 0) {\n            do {\n                if (arg1 == *piVar2) {\n                    if (arg2 != -1) {\n                        if ((*(*0x140049670 + arg2 * 7 + 4) >> 1 & 1) != 1) {\n                            fcn.140002b70(auStack24, arg2, 1);\n                            uVar1 = fcn.140002a60(arg2, 1);\n                            fcn.140003200(auStack24);\n                            *0x140049060 = 0;\n                            return uVar1;\n                        }\n                        *0x140049060 = 0;\n                        return 5;\n                    }\n                    break;\n                }\n                uVar3 = arg2 + 1;\n                arg2 = uVar3;\n                piVar2 = piVar2 + 7;\n            } while (uVar3 < *0x14004967c);\n        }\n        uVar1 = 4;\n    }\n    *0x140049060 = 0;\n    return uVar1;\n}\n",
        "token_count": 427
    },
    "140002a6": {
        "rules": [
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong fcn.140002a60(uint64_t arg1, ulong arg2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    ulong uVar3;\n    ulong *puVar4;\n    uint8_t uVar5;\n    uint *puVar6;\n    uint auStackX8 [2];\n    \n    puVar4 = (arg1 & 0xffffffff) * 0x38 + *0x140049670;\n    puVar6 = *puVar4 + -5;\n    if ((*(puVar4 + 4) & 1) == 0) {\n        puVar6 = *puVar4;\n    }\n    cVar1 = (*(puVar4 + 4) & 1) * '\\x02' + '\\x05';\n    iVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)(puVar6, cVar1, 0x40, auStackX8);\n    if (iVar2 == 0) {\n        uVar3 = 10;\n    }\n    else {\n        if (arg2 == 0) {\n            uVar5 = *(puVar4 + 4);\n            *puVar6 = *(puVar4 + 3);\n            if ((uVar5 & 1) == 0) {\n                *(puVar6 + 1) = *(puVar4 + 0x1c);\n            }\n            else {\n                *(puVar6 + 1) = *(puVar4 + 0x1c);\n                *(puVar6 + 6) = *(puVar4 + 0x1e);\n            }\n        }\n        else {\n            *puVar6 = 0xe9;\n            *(puVar6 + 1) = (*(puVar4 + 1) - puVar6) + -5;\n            if ((*(puVar4 + 4) & 1) != 0) {\n                **puVar4 = 0xf9eb;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_VirtualProtect)(puVar6, cVar1, auStackX8[0], auStackX8);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n        (*_sym.imp.KERNEL32.dll_FlushInstructionCache)(uVar3, puVar6, cVar1);\n        *(puVar4 + 4) = *(puVar4 + 4) & 0xfd;\n        uVar5 = arg2 & 1;\n        *(puVar4 + 4) = (uVar5 * '\\x02' | *(puVar4 + 4)) & 0xfb | uVar5 << 2;\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 594
    },
    "140002d2": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140002d20(uint *arg1, ulong arg2, ulong *arg3)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int64_t arg1_00;\n    ulong *puVar3;\n    uint64_t uVar4;\n    uchar auStack152 [32];\n    uint *puStack120;\n    ulong uStack112;\n    int64_t iStack104;\n    ulong uStack96;\n    int32_t iStack88;\n    uint32_t uStack84;\n    ulong uStack80;\n    ulong uStack72;\n    uint64_t uStack64;\n    \n    uStack64 = *0x140008228 ^ auStack152;\n    uVar4 = 0;\n    LOCK();\n    if (*0x140049060 != 0) {\n        do {\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x1f < uVar4);\n            uVar4 = uVar4 + 1;\n            LOCK();\n        } while (*0x140049060 != 0);\n    }\n    *0x140049060 = 1;\n    if (((*0x140049068 == 0) || (iVar1 = fcn.1400035a0(arg1),  iVar1 == 0)) ||\n       (iVar1 = fcn.1400035a0(arg2),  iVar1 == 0)) goto code_r0x000140002f70;\n    uVar2 = 0;\n    puVar3 = *0x140049670;\n    if (*0x14004967c != 0) {\n        do {\n            if (arg1 == *puVar3) {\n                if (uVar2 != 0xffffffff) goto code_r0x000140002f70;\n                break;\n            }\n            uVar2 = uVar2 + 1;\n            puVar3 = puVar3 + 7;\n        } while (uVar2 < *0x14004967c);\n    }\n    arg1_00 = fcn.140003280(arg1);\n    if (arg1_00 == 0) goto code_r0x000140002f70;\n    puStack120 = arg1;\n    uStack112 = arg2;\n    iStack104 = arg1_00;\n    iVar1 = fcn.1400035e0(&puStack120);\n    if (iVar1 == 0) {\n        fcn.1400032b0(arg1_00);\n        goto code_r0x000140002f70;\n    }\n    if (*0x140049670 == NULL) {\n        *0x140049678 = 0x20;\n        *0x140049670 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x140049068, 0, 0x700);\n        if (*0x140049670 != NULL) goto code_r0x000140002eb3;\n    }\n    else {\n        if (*0x140049678 <= *0x14004967c) {\n            puVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x140049068, 0, *0x140049670, *0x140049678 * 2 * 0x38);\n            if (puVar3 == NULL) goto code_r0x000140002e45;\n            *0x140049678 = *0x140049678 * 2;\n            *0x140049670 = puVar3;\n        }\ncode_r0x000140002eb3:\n        uVar4 = *0x14004967c;\n        *0x14004967c = *0x14004967c + 1;\n        puVar3 = *0x140049670 + uVar4 * 7;\n        if (puVar3 != NULL) {\n            *puVar3 = puStack120;\n            puVar3[1] = uStack96;\n            puVar3[2] = iStack104;\n            *(puVar3 + 4) = *(puVar3 + 4) & 0xf8 | iStack88 & 1;\n            *(puVar3 + 0x24) = *(puVar3 + 0x24) ^ (uStack84 ^ *(puVar3 + 0x24)) & 0xf;\n            puVar3[5] = uStack80;\n            puVar3[6] = uStack72;\n            if (iStack88 == 0) {\n                *(puVar3 + 3) = *arg1;\n                *(puVar3 + 0x1c) = *(arg1 + 1);\n            }\n            else {\n                *(puVar3 + 3) = *(arg1 + -5);\n                *(puVar3 + 0x1c) = *(arg1 + -1);\n                *(puVar3 + 0x1e) = *(arg1 + 1);\n            }\n            if (arg3 != NULL) {\n                *arg3 = puVar3[2];\n            }\n            goto code_r0x000140002f70;\n        }\n    }\ncode_r0x000140002e45:\n    fcn.1400032b0(arg1_00);\ncode_r0x000140002f70:\n    *0x140049060 = 0;\n    fcn.140004180(uStack64 ^ auStack152);\n    return;\n}\n",
        "token_count": 1177
    },
    "14000399": {
        "rules": [
            "check for software breakpoints/4e3f376d71b04339ae2f170b8ad32c49"
        ],
        "decompiled_code": "\nulong fcn.140003990(char *arg1, ulong arg2)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint64_t uVar3;\n    \n    cVar1 = *arg1;\n    if (((cVar1 != '\\0') && (cVar1 != -0x70)) && (cVar1 != -0x34)) {\n        return 0;\n    }\n    uVar3 = 1;\n    if (1 < arg2) {\n        do {\n            if (arg1[uVar3] != cVar1) {\n                return 0;\n            }\n            uVar2 = uVar3 + 1;\n            uVar3 = uVar2;\n        } while (uVar2 < arg2);\n    }\n    return 1;\n}\n",
        "token_count": 172
    },
    "1400020c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "PEB access",
            "access PEB ldr_data",
            "get kernel32 base address",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_bp_20h\n\nvoid fcn.1400020c0(ulong arg1)\n\n{\n    code *pcVar1;\n    ulong uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int64_t iVar5;\n    uint *puVar6;\n    code *pcVar7;\n    uint64_t arg1_00;\n    ulong *puVar8;\n    uchar *puVar9;\n    uchar *puVar10;\n    code *pcVar11;\n    ulong *puVar12;\n    int64_t in_GS_OFFSET;\n    ulong var_8h;\n    ulong var_10h;\n    ulong var_18h;\n    ulong var_bp_20h;\n    ulong var_48h;\n    ulong var_50h;\n    ulong var_58h;\n    uchar auStack104 [32];\n    ulong uStack72;\n    uint32_t uStack64;\n    code *pcStack56;\n    ulong uStack48;\n    ulong uStack40;\n    uint64_t uStack32;\n    \n    puVar9 = &stack0xffffffffffffff98;\n    puVar10 = &stack0xffffffffffffff98;\n    uStack32 = *0x140008228 ^ &stack0xffffffffffffffc8;\n    puVar12 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n    puVar8 = *puVar12;\n    do {\n        iVar4 = (*_sym.imp.api_ms_win_crt_string_l1_1_0.dll__wcsicmp)(puVar8[10], 0x140005450);\n        pcVar11 = NULL;\n        if (iVar4 == 0) {\n            pcVar7 = puVar8[4];\n            break;\n        }\n        puVar8 = *puVar8;\n        pcVar7 = pcVar11;\n    } while (puVar8 != puVar12);\n    uStack48 = 0x130013;\n    uStack40 = 0x140005438;\n    pcStack56 = NULL;\n    iVar4 = fcn.1400022a0(pcVar7, &stack0xffffffffffffffd0, 0, &stack0xffffffffffffffc8);\n    uStack64 = 0;\n    pcVar7 = pcStack56;\n    if (iVar4 == 0) {\n        pcVar7 = pcVar11;\n    }\n    uStack72 = 0;\n    iVar4 = (*pcVar7)(0xfde9, 0, arg1, 0xffffffff);\n    uVar3 = iVar4 * 2;\n    pcVar1 = uVar3 + 0x10;\n    if (uVar3 < pcVar1) {\n        pcVar11 = pcVar1;\n    }\n    if (pcVar11 == NULL) {\n        uStack72 = 0;\n        uStack64 = uVar3;\n        (*pcVar7)(0xfde9, 0, arg1, 0xffffffff);\n        goto code_r0x000140002270;\n    }\n    if (pcVar11 < 0x401) {\n        iVar5 = fcn.140004e90();\n        iVar5 = -iVar5;\n        puVar9 = &stack0xffffffffffffff98 + iVar5;\n        puVar6 = &stack0xffffffffffffffc8 + iVar5;\n        puVar10 = &stack0xffffffffffffff98 + iVar5;\n        if (puVar6 != NULL) {\n            *puVar6 = 0xcccc;\ncode_r0x0001400021e4:\n            puVar6 = puVar6 + 4;\n            puVar10 = puVar9;\n        }\n    }\n    else {\n        puVar6 = (*_sym.imp.api_ms_win_crt_heap_l1_1_0.dll_malloc)(pcVar11);\n        puVar10 = &stack0xffffffffffffff98;\n        if (puVar6 != NULL) {\n            *puVar6 = 0xdddd;\n            goto code_r0x0001400021e4;\n        }\n    }\n    *(puVar10 + 0x28) = uVar3;\n    *(puVar10 + 0x20) = puVar6;\n    *(puVar10 + -8) = 0x140002204;\n    (*pcVar7)(0xfde9, 0, arg1, 0xffffffff);\n    if (puVar6 != NULL) {\n        puVar12 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n        puVar8 = *puVar12;\n        do {\n            uVar2 = puVar8[10];\n            *(puVar10 + -8) = 0x14000222d;\n            iVar4 = (*_sym.imp.api_ms_win_crt_string_l1_1_0.dll__wcsicmp)(uVar2, puVar6);\n            if (iVar4 == 0) break;\n            puVar8 = *puVar8;\n        } while (puVar8 != puVar12);\n        if (puVar6[-4] == 0xdddd) {\n            *(puVar10 + -8) = 0x140002252;\n            (*_sym.imp.api_ms_win_crt_heap_l1_1_0.dll_free)(puVar6 + -4);\n        }\n    }\ncode_r0x000140002270:\n    arg1_00 = uStack32 ^ &stack0xffffffffffffffc8;\n    *(puVar10 + -8) = 0x14000227f;\n    fcn.140004180(arg1_00);\n    return;\n}\n",
        "token_count": 1242
    },
    "1400022a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.1400022a0(int64_t arg1, code *arg2, uint64_t noname_2, int64_t *arg4)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int64_t iVar4;\n    int64_t arg1_00;\n    ulong *puVar5;\n    ulong *puVar6;\n    uint64_t arg3;\n    int64_t in_GS_OFFSET;\n    code *pcStackX16;\n    ulong uStack56;\n    char *pcStack48;\n    \n    arg3 = noname_2 & 0xffff;\n    pcStackX16 = arg2;\n    if (arg2 == NULL) {\n        if (arg3 == 0) {\n            fcn.140001fc0(\"LocalLdrGetProcedureAddress: provide either a Function name or Ordinal\\n\", 0, noname_2, arg4)\n            ;\n            return false;\n        }\n    }\n    else if (arg3 != 0) {\n        fcn.140001fc0(\"LocalLdrGetProcedureAddress: provide Function name or Ordinal, not both\\n\", arg2, noname_2, arg4)\n        ;\n        return false;\n    }\n    arg1_00 = 0;\n    iVar2 = 0;\n    if ((arg1 == 0) || (iVar2 = fcn.1400024a0(arg1, arg2, arg3, arg4),  iVar2 == 0)) {\n        puVar6 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n        puVar5 = *puVar6;\n        do {\n            iVar3 = (*_sym.imp.api_ms_win_crt_string_l1_1_0.dll__wcsicmp)(puVar5[10], 0x140005510);\n            if (iVar3 == 0) {\n                iVar4 = puVar5[4];\n                break;\n            }\n            puVar5 = *puVar5;\n            iVar4 = arg1_00;\n        } while (puVar5 != puVar6);\n        if (iVar4 != arg1) {\n            iVar2 = fcn.1400024a0(iVar4, pcStackX16, arg3, arg4);\n        }\n        if (iVar2 == 0) {\n            puVar6 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n            puVar5 = *puVar6;\n            do {\n                iVar2 = (*_sym.imp.api_ms_win_crt_string_l1_1_0.dll__wcsicmp)(puVar5[10], L\"KERNELBASE.dll\");\n                pcVar1 = pcStackX16;\n                if (iVar2 == 0) {\n                    iVar4 = puVar5[4];\n                    break;\n                }\n                puVar5 = *puVar5;\n                iVar4 = arg1_00;\n            } while (puVar5 != puVar6);\n            if ((iVar4 == arg1) || (iVar2 = fcn.1400024a0(iVar4, pcStackX16, arg3, arg4),  iVar2 == 0)) {\n                *arg4 = 0;\n                pcStack48 = \"LdrGetProcedureAddress\";\n                pcStackX16 = NULL;\n                uStack56 = 0x160016;\n                puVar6 = *(*(in_GS_OFFSET + 0x60) + 0x18) + 0x20;\n                puVar5 = *puVar6;\n                do {\n                    iVar2 = (*_sym.imp.api_ms_win_crt_string_l1_1_0.dll__wcsicmp)(puVar5[10], 0x140005408);\n                    if (iVar2 == 0) {\n                        arg1_00 = puVar5[4];\n                        break;\n                    }\n                    puVar5 = *puVar5;\n                } while (puVar5 != puVar6);\n                fcn.1400024a0(arg1_00, &uStack56, 0, &pcStackX16);\n                (*pcStackX16)(arg1, pcVar1, arg3, arg4);\n                return *arg4 != 0;\n            }\n        }\n    }\n    return true;\n}\n",
        "token_count": 940
    },
    "140002b7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002b70(int64_t *arg1, ulong arg2, uint64_t arg3)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint32_t uVar3;\n    uchar auStack104 [32];\n    uint32_t uStack72;\n    int32_t iStack64;\n    int32_t iStack60;\n    uint64_t uStack40;\n    \n    uStack40 = *0x140008228 ^ auStack104;\n    uVar3 = 0;\n    *arg1 = 0;\n    arg1[1] = 0;\n    iVar2 = sub.KERNEL32.dll_CreateToolhelp32Snapshot();\n    if (iVar2 != -1) {\n        uStack72 = 0x1c;\n        iVar1 = sub.KERNEL32.dll_Thread32First();\n        while (iVar1 != 0) {\n            if (((0xf < uStack72) && (iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcessId)(),  iStack60 == iVar1)) &&\n               (iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)(),  iStack64 != iVar1)) {\n                iVar2 = *arg1;\n                if (iVar2 == 0) {\n                    *(arg1 + 1) = 0x80;\n                    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)();\n                    *arg1 = iVar2;\n                    if (iVar2 == 0) break;\n                }\n                else if (*(arg1 + 1) <= *(arg1 + 0xc)) {\n                    iVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x140049068, 0, iVar2, *(arg1 + 1) * 2 << 2);\n                    if (iVar2 == 0) break;\n                    *arg1 = iVar2;\n                    *(arg1 + 1) = *(arg1 + 1) * 2;\n                }\n                *(iVar2 + *(arg1 + 0xc) * 4) = iStack64;\n                *(arg1 + 0xc) = *(arg1 + 0xc) + 1;\n            }\n            uStack72 = 0x1c;\n            iVar1 = sub.KERNEL32.dll_Thread32Next();\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    if ((*arg1 != 0) && (*(arg1 + 0xc) != 0)) {\n        do {\n            iVar2 = (*_sym.imp.KERNEL32.dll_OpenThread)();\n            if (iVar2 != 0) {\n                (*_sym.imp.KERNEL32.dll_SuspendThread)(iVar2);\n                fcn.140003050(iVar2, arg2, arg3 & 0xffffffff);\n                (*_sym.imp.KERNEL32.dll_CloseHandle)();\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < *(arg1 + 0xc));\n    }\n    fcn.140004180(uStack40 ^ auStack104);\n    return;\n}\n",
        "token_count": 666
    },
    "140002fb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint64_t fcn.140002fb0(void)\n\n{\n    uint64_t uVar1;\n    uint64_t uVar2;\n    \n    uVar2 = 0;\n    LOCK();\n    uVar1 = uVar2;\n    if (*0x140049060 != 0) {\n        do {\n            (*_sym.imp.KERNEL32.dll_Sleep)(0x1f < uVar1);\n            uVar1 = uVar1 + 1;\n            LOCK();\n        } while (*0x140049060 != 0);\n    }\n    *0x140049060 = 1;\n    if (*0x140049068 == 0) {\n        *0x140049068 = (*_sym.imp.KERNEL32.dll_HeapCreate)(0, 0, 0);\n        if (*0x140049068 == 0) {\n            uVar2 = 9;\n        }\n        else {\n            fcn.140003590();\n        }\n    }\n    else {\n        uVar2 = 1;\n    }\n    *0x140049060 = 0;\n    return uVar2;\n}\n",
        "token_count": 239
    },
    "14000320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140003200(int64_t *arg1)\n\n{\n    int64_t iVar1;\n    uint32_t uVar2;\n    uint64_t uVar3;\n    \n    iVar1 = *arg1;\n    if (iVar1 != 0) {\n        uVar3 = 0;\n        if (*(arg1 + 0xc) != 0) {\n            do {\n                iVar1 = (*_sym.imp.KERNEL32.dll_OpenThread)(0x5a, 0, *(*arg1 + uVar3 * 4));\n                if (iVar1 != 0) {\n                    (*_sym.imp.KERNEL32.dll_ResumeThread)(iVar1);\n                    (*_sym.imp.KERNEL32.dll_CloseHandle)();\n                }\n                uVar2 = uVar3 + 1;\n                uVar3 = uVar2;\n            } while (uVar2 < *(arg1 + 0xc));\n            iVar1 = *arg1;\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x140049068, 0, iVar1);\n    }\n    return;\n}\n",
        "token_count": 236
    },
    "14000328": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140003280(ulong param_1)\n\n{\n    ulong uVar1;\n    int64_t iVar2;\n    \n    iVar2 = fcn.140003330(param_1);\n    if (iVar2 == 0) {\n        return;\n    }\n    uVar1 = **(iVar2 + 8);\n    *(iVar2 + 0x10) = *(iVar2 + 0x10) + 1;\n    *(iVar2 + 8) = uVar1;\n    return;\n}\n",
        "token_count": 112
    },
    "1400032b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400032b0(int64_t *arg1)\n\n{\n    int64_t *piVar1;\n    int64_t *piVar2;\n    int64_t *piVar3;\n    \n    piVar3 = NULL;\n    piVar1 = *0x140049660;\n    if (*0x140049660 != NULL) {\n        while (piVar2 = piVar1,  piVar2 != (arg1 & 0xfffffffffffff000)) {\n            piVar1 = *piVar2;\n            piVar3 = piVar2;\n            if (*piVar2 == NULL) {\n                return;\n            }\n        }\n        *arg1 = piVar2[1];\n        piVar1 = piVar2 + 2;\n        *piVar1 = *piVar1 + -1;\n        piVar2[1] = arg1;\n        if (*piVar1 == 0) {\n            if (piVar3 == NULL) {\n                *0x140049660 = *piVar2;\n    // WARNING: Could not recover jumptable at 0x00014000331b. Too many branches\n    // WARNING: Treating indirect jump as call\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar2, 0, 0x8000);\n                return;\n            }\n            *piVar3 = *piVar2;\n    // WARNING: Could not recover jumptable at 0x000140003305. Too many branches\n    // WARNING: Treating indirect jump as call\n            (*_sym.imp.KERNEL32.dll_VirtualFree)(piVar2, 0, 0x8000);\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 371
    },
    "1400035a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.1400035a0(ulong lpAddress)\n\n{\n    uchar auStack56 [32];\n    int32_t iStack24;\n    uint8_t uStack20;\n    \n    (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, auStack56, 0x30);\n    if ((iStack24 == 0x1000) && ((uStack20 & 0xf0) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 108
    },
    "140004b8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140004b8c(void)\n\n{\n    int64_t *piVar1;\n    \n    for (piVar1 = 0x140006b98; piVar1 < 0x140006b98; piVar1 = piVar1 + 1) {\n        if (*piVar1 != 0) {\n            (**0x1400052d0)();\n        }\n    }\n    return;\n}\n",
        "token_count": 91
    }
}