{
    "01001160": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01001160(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    if (*0x103c028 - *0x103c040 == 0x326) {\n        var_8h = *0x103c06c * -2 + 0x160c;\n    }\n    else {\n        *0x103c048 = arg_8h + 0x1089d + *0x103c06c + *0x103c048 * 2;\n        var_8h = *0x103c06c * 2 + 0x13523;\n    }\n    iVar3 = var_ch - (var_14h + 0x37 + var_8h);\n    *0x103c06c = iVar3 + ((var_14h + 0x2698) - var_8h);\n    for (var_4h = 0x2b; cVar1 = arg_8h,  1 < var_4h; var_4h = var_4h + -2) {\n        if (*0x103c068 != *0x103c034) {\n            *(var_4h * 4 + 0x103c018) = *(var_4h * 4 + 0x103c018) - arg_8h;\n            *0x103c068 = cVar1 + -99 + *0x103c068;\n        }\n    }\n    iVar2 = iVar3 + 0x1089d + *0x103c06c + var_14h * 2;\n    var_8h = (iVar3 + -5) - iVar2;\n    if (*0x103c068 <= var_8h) {\n        var_8h = arg_8h + 0x1089d + *0x103c068 + var_8h + var_8h;\n        *0x103c044 = *0x103c044 - arg_8h;\n        *0x103c068 = cVar1 + -99 + *0x103c068;\n    }\n    iVar3 = iVar2 + 0x5c + iVar3;\n    *0x103c068 = *0x103c068 - (var_8h * '\\x1d' + iVar2 + '7' + iVar3);\n    if (*0x103c030 != 4) {\n        *0x103c068 = var_8h * '\\x1d' + cVar1;\n    }\n    *0x103c06c = iVar2 + ((var_8h * -2 + -0x269d) - iVar3);\n    return *0x103c06c + -5 + var_8h + iVar2;\n}\n",
        "token_count": 663
    },
    "01001810": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.01001810(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    *0x103c008 = var_ch * 0x1d + *0x103c004;\n    *0x103c00c = 0;\n    *0x103c06c = *0x103c008 + 0x1089d + *0x103c010 + *0x103c06c * 2;\n    *0x103c068 = fcn.01001160(*0x103c004);\n    uVar3 = *0x103c004;\n    if (*0x103c048 <= *0x103c004) {\n        *0x103c024 = *0x103c008;\n        *0x103c06c = *0x103c004 + 0x1089d + *0x103c008 + *0x103c06c * 2;\n        *0x103c008 = (*0x103c06c + -5) - *0x103c004;\n        *0x103c00c = 0;\n        iVar2 = fcn.01019b10(*0x103c008, 0, 0x1d, 0);\n        *0x103c06c = uVar3 + iVar2;\n    }\n    iVar2 = *0x103c008 - var_ch;\n    var_ch = iVar2 + 0x269d;\n    *0x103c008 = iVar2 + 0x26a3 + *0x103c004;\n    *0x103c00c = 0;\n    *0x103c010 = (*0x103c06c - 5) - *0x103c008;\n    if (*0x103c048 <= *0x103c008) {\n        *0x103c024 = *0x103c068;\n        *0x103c068 = *0x103c068 + *0x103c06c * '\\x02' + 0x98;\n        *0x103c06c = *0x103c068 * 0x1d + *0x103c008;\n    }\n    cVar1 = fcn.010013e0(*0x103c004);\n    if ((*0x103c00c == 0) && (*0x103c008 <= *0x103c06c)) {\n        *0x103c06c = *0x103c004 + 0x1089d + *0x103c008 + *0x103c06c * 2;\n        *0x103c044 = *0x103c044 - *0x103c004;\n        bVar4 = CARRY4(*0x103c004 + 0x269d, *0x103c008);\n        *0x103c008 = *0x103c004 + 0x269d + *0x103c008;\n        *0x103c00c = bVar4;\n    }\n    *0x103c068 = (*0x103c008 - cVar1) - var_ch;\n    for (var_4h = 0x2b; 1 < var_4h; var_4h = var_4h + -2) {\n        if (*0x103c06c != *0x103c05f) {\n            var_ch = (*0x103c06c - 5) + var_ch * 2;\n            *(var_4h + 0x103c058) = *(var_4h + 0x103c058) - var_ch;\n            *0x103c06c = var_ch + 0x269d + *0x103c06c;\n        }\n    }\n    iVar2 = *0x103c06c + *0x103c010 + -5 + *0x103c008;\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c06c = iVar2 - (*0x103c068 + 0x37 + *0x103c068);\n        *0x103c068 = (*0x103c06c - 5) - *0x103c008;\n        uVar3 = -(*0x103c06c - 5 < *0x103c008) - *0x103c00c;\n    }\n    else {\n        *0x103c048 = *0x103c008 + 0x1089d + *0x103c068 + *0x103c048 * 2;\n        uVar3 = *0x103c068;\n        *0x103c06c = uVar3 + 0x1089d + *0x103c068 + iVar2 + iVar2;\n    }\n    if (*0x103c048 <= *0x103c068) {\n        *0x103c024 = *0x103c068;\n        *0x103c068 = *0x103c068 + *0x103c06c * '\\x02' + 0x98;\n        uVar3 = *0x103c068 + *0x103c068 * 0x1d;\n        *0x103c06c = uVar3;\n    }\n    return CONCAT44(uVar3, *0x103c008);\n}\n",
        "token_count": 1246
    },
    "0100e9d0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0100e9d0(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t var_4h;\n    \n    for (var_4h = 1; var_4h < 0x23; var_4h = var_4h + 1) {\n        if (*0x103c010 != *0x103c028) {\n            *0x103c010 = *0x103c010 - *(var_4h * 4 + 0x103c018);\n            *0x103c06c = (*0x103c010 + -5) - arg_8h;\n            if (*0x103c010 == *0x103c028) break;\n        }\n    }\n    *0x103c068 = ((*0x103c014 + -99) - *0x103c06c) + *0x103c068 * '\\x02' + (*0x103c010 + '7') * -2;\n    for (var_4h = 0x2b; 1 < var_4h; var_4h = var_4h + -2) {\n        if (*0x103c068 != *0x103c034) {\n            *0x103c010 = (*0x103c068 - 5) + arg_8h + *0x103c010;\n            *(var_4h * 4 + 0x103c018) = *(var_4h * 4 + 0x103c018) - arg_8h;\n            *0x103c068 = arg_8h + -99 + *0x103c068;\n        }\n    }\n    iVar1 = *0x103c014 + 0x269d + *0x103c06c;\n    *0x103c008 = iVar1 * 0x1d + *0x103c010;\n    *0x103c00c = 0;\n    *0x103c068 = *0x103c068 + *0x103c06c + -5 + *0x103c014;\n    *0x103c06c = iVar1;\n    return *0x103c008;\n}\n",
        "token_count": 492
    },
    "0100ee10": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0100ee10(uint32_t arg_8h)\n\n{\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = 0x9b;\n    if (*0x103c06c < 0x9c) {\n        var_8h = arg_8h + *0x103c06c + 0x109d3;\n        *0x103c044 = *0x103c044 - arg_8h;\n        *0x103c06c = arg_8h + 0x269d + *0x103c06c;\n    }\n    *0x103c068 = var_8h + -99 + *0x103c06c + *0x103c068 * '\\x02';\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        var_8h = var_8h - (*0x103c068 + 0x37 + *0x103c068);\n        *0x103c068 = (var_8h + -5) - arg_8h;\n    }\n    else {\n        *0x103c048 = arg_8h + 0x1089d + *0x103c068 + *0x103c048 * 2;\n        var_8h = *0x103c068 + 0x1089d + *0x103c068 + var_8h * 2;\n    }\n    *0x103c068 = *0x103c068 + *0x103c06c + -5 + var_ch;\n    if (*0x103c048 <= arg_8h) {\n        *0x103c024 = *0x103c068;\n        *0x103c068 = *0x103c068 + var_8h * '\\x02' + 0x98;\n        var_8h = *0x103c068 * 0x1d + arg_8h;\n    }\n    *0x103c06c = var_ch + 0x269d + *0x103c06c;\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        var_8h = var_8h + *0x103c06c * -2 + -0x37;\n        *0x103c06c = (var_8h + -5) - arg_8h;\n    }\n    else {\n        *0x103c048 = arg_8h + 0x1089d + *0x103c06c + *0x103c048 * 2;\n        var_8h = *0x103c06c * 2 + 0x1089d + var_8h * 2;\n    }\n    *0x103c06c = (*0x103c068 - *0x103c06c) - var_8h;\n    for (var_4h = 0x2b; 1 < var_4h; var_4h = var_4h + -2) {\n        if (*0x103c068 != *0x103c034) {\n            *(var_4h * 4 + 0x103c018) = *(var_4h * 4 + 0x103c018) - arg_8h;\n            *0x103c068 = arg_8h + -99 + *0x103c068;\n        }\n    }\n    *0x103c06c = (*0x103c008 - *0x103c06c) - var_ch;\n    return var_ch;\n}\n",
        "token_count": 817
    },
    "0100f650": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0100f650(uint32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint arg_8h_00;\n    uint var_83ch;\n    uint var_838h;\n    uint32_t var_834h;\n    uint lpBuffer;\n    uint32_t var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uint var_1h;\n    \n    var_28h = *0x103c470 ^ &var_1h + 1U;\n    var_ch = 0;\n    var_20h = 0;\n    iVar2 = *0x103c068 * 0x1d + arg_8h;\n    *0x103c044 = *0x103c044 - *0x103c06c;\n    if (*0x103c064 <= arg_8h) {\n        *0x103c05b = *0x103c068;\n        *0x103c068 = *0x103c068 + *0x103c010 * '\\x02' + 0x98;\n        *0x103c010 = *0x103c068 * 0x1d + arg_8h;\n    }\n    iVar4 = (*0x103c06c + 0x12f55) - (iVar2 + 0x37);\n    if (*0x103c030 == 4) {\n        *0x103c004 = (iVar4 - *0x103c004) - *0x103c06c;\n    }\n    else {\n        *0x103c06c = iVar4 * 0x1d + *0x103c004;\n    }\n    *0x10d93b4 = 0x103dfa8;\n    iVar4 = arg_8h + 0x1089d + *0x103c010 + iVar4 * 2;\n    *0x103c014 = iVar2 - (iVar4 + 0x37 + *0x103c068);\n    *0x103c010 = fcn.0100e9d0(*0x103c014);\n    iVar2 = iVar4 * 0x1d + *0x103c06c;\n    var_18h = 0x102d280;\n    *0x103c068 = (*0x103c014 - *0x103c068) - iVar2;\n    if (*0x103c030 == 4) {\n        *0x103c010 = (*0x103c014 - *0x103c010) - *0x103c06c;\n    }\n    else {\n        *0x103c06c = *0x103c014 * 0x1d + *0x103c010;\n    }\n    *0x103c010 = fcn.0100f0c0(*0x103c014);\n    var_834h = iVar2 * 2 + -5 + *0x103c06c;\n    arg_8h_00 = 0x804;\n    *0x103c010 = (*_sym.imp.KERNEL32.dll_GetTempPathA)(0x804, &lpBuffer);\n    for (var_ch = 1; var_ch < 0x23; var_ch = var_ch + 1) {\n        if (*0x103c004 != str.8jz[0]) {\n            *0x103c004 = *0x103c004 - *(var_ch + 0x103c058);\n            var_834h = (*0x103c004 - 5) - *0x103c010;\n            if (*0x103c004 == str.8jz[0]) break;\n        }\n    }\n    if (*0x103c024 == 0x15ef) {\n        *0x103c06c = *0x103c06c + *0x103c020;\n        *0x103c014 = *0x103c06c * 2 + -5 + *0x103c014;\n    }\n    fcn.01012da0(*0x103c014, *0x103c010, *0x10d93b4, var_18h, 0x3fa9);\n    *0x103c068 = *0x103c014 + '\\\\' + var_834h;\n    for (var_ch = 0x2b; 1 < var_ch; var_ch = var_ch + -2) {\n        if (*0x103c06c != *0x103c034) {\n            var_834h = (*0x103c06c - 5) + *0x103c004 + var_834h;\n            *(var_ch * 4 + 0x103c018) = *(var_ch * 4 + 0x103c018) - *0x103c004;\n            *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n        }\n    }\n    var_834h = *0x103c06c + 0x269d + var_834h;\n    var_20h = 0x1492c12;\n    if (*0x103c06c <= *0x103c014) {\n        *0x103c044 = *0x103c044 - *0x103c010;\n        *0x103c06c = *0x103c010 + 0x269d + *0x103c06c;\n    }\n    *0x103c014 = *0x103c068 + 6 + var_834h;\n    if (*0x103c06c <= var_834h) {\n        var_834h = *0x103c004 + 0x1089d + *0x103c06c + var_834h * 2;\n        *0x103c044 = *0x103c044 - *0x103c004;\n        *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n    }\n    *0x103c010 = fcn.0100ee10(*0x103c014);\n    iVar2 = *0x103c06c + 0x269d + var_834h;\n    *0x103c014 = *0x103c06c + (-0x31 - *0x103c068);\n    var_14h = 0xe;\n    var_1ch = 0xc1;\n    *0x103c068 = *0x103c004 + '\\\\' + iVar2;\n    if (*0x103c048 <= *0x103c004) {\n        *0x103c024 = *0x103c06c;\n        *0x103c06c = *0x103c06c + iVar2 * 2 + 0x10898;\n    }\n    var_8h = 0xb6;\n    var_834h = (*0x103c014 - 5) - *0x103c06c;\n    var_10h = 0;\n    if (*0x103c048 <= *0x103c004) {\n        *0x103c024 = *0x103c06c;\n        *0x103c06c = *0x103c06c + var_834h * 2 + 0x10898;\n        var_834h = *0x103c06c * 0x1d + *0x103c004;\n    }\n    var_834h = (var_834h + -5) - *0x103c06c;\n    if (*0x103c06c <= *0x103c068) {\n        *0x103c068 = *0x103c010 + -99 + *0x103c06c + *0x103c068 * '\\x02';\n        *0x103c044 = *0x103c044 - *0x103c010;\n        *0x103c06c = *0x103c010 + 0x269d + *0x103c06c;\n    }\n    var_24h = 0;\n    for (var_ch = 0x2b; 1 < var_ch; var_ch = var_ch + -2) {\n        if (*0x103c06c != *0x103c034) {\n            var_834h = (*0x103c06c - 5) + *0x103c004 + var_834h;\n            *(var_ch * 4 + 0x103c018) = *(var_ch * 4 + 0x103c018) - *0x103c004;\n            *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n        }\n    }\n    var_834h = (var_834h + -5) - *0x103c06c;\n    cVar1 = *0x103c010;\n    if (*0x103c048 <= *0x103c010) {\n        *0x103c024 = *0x103c06c;\n        *0x103c06c = ((cVar1 + -99 + *0x103c06c + *0x103c068 * '\\x02') - 5) - *0x103c010;\n        *0x103c068 = *0x103c06c * '\\x1d' + cVar1;\n    }\n    var_1h._0_1_ = 1;\n    if (*0x103c048 <= *0x103c004) {\n        *0x103c024 = *0x103c06c;\n        *0x103c06c = *0x103c06c + var_834h * 2 + 0x10898;\n        var_834h = *0x103c06c * 0x1d + *0x103c004;\n    }\n    var_834h = var_834h * 0x1d + *0x103c06c;\n    if (*0x103c048 <= *0x103c010) {\n        *0x103c024 = *0x103c06c;\n        *0x103c06c = ((cVar1 + -99 + *0x103c06c + *0x103c068 * '\\x02') - 5) - *0x103c010;\n    }\n    while( true ) {\n        if (*0x103c024 == 0x15ef) {\n            *0x103c06c = *0x103c06c + *0x103c020;\n        }\n        var_834h = var_834h * 2 + -5 + *0x103c06c;\n        if (var_834h <= *0x103c014) {\n            *0x103c014 = *0x103c06c + 0x1089d + var_834h + *0x103c014 * 2;\n            *0x103c044 = *0x103c044 - *0x103c06c;\n            var_834h = *0x103c06c + 0x269d + var_834h;\n        }\n        if (*0x103c010 < var_834h) {\n            var_834h = var_834h * 0x1d + *0x103c06c * -0x1c + -0x63b + *0x103c004 * -0x1d;\n            *0x103c014 = *0x103c010 == 0;\n            if (*0x103c014 != 0) {\n                if (*0x103c030 == 4) {\n                    *0x103c06c = (*0x103c014 - *0x103c06c) - *0x103c004;\n                }\n                else {\n                    *0x103c004 = *0x103c014 * 0x1d + *0x103c06c;\n                }\n            }\n            *0x103c014 = (*0x103c010 - 5) + *0x103c004 + *0x103c014;\n        }\n        var_834h = (var_834h - 5) - *0x103c06c;\n        *0x103c068 = *0x103c014 + '\\\\' + var_834h;\n        if (*0x103c014 < var_834h) {\n            *0x103c068 = (*0x103c014 - *0x103c068) - var_834h;\n            var_834h = *0x103c06c + 0x1089d + var_834h * 3;\n            *0x103c014 = *0x103c068 + 6 + var_834h;\n        }\n        else if (*0x103c028 - *0x103c040 == 0x326) {\n            *0x103c014 = *0x103c014 + *0x103c06c * -2 + -0x37;\n            *0x103c06c = (*0x103c014 + -5) - *0x103c010;\n        }\n        else {\n            *0x103c048 = *0x103c010 + 0x1089d + *0x103c06c + *0x103c048 * 2;\n            *0x103c014 = *0x103c06c * 2 + 0x1089d + *0x103c014 * 2;\n        }\n        if (var_20h == 0) break;\n        *0x103c068 = (*0x103c014 - *0x103c068) - var_834h;\n        fcn.0100ebb0();\n        if (*0x103c048 <= var_834h) {\n            *0x103c024 = *0x103c068;\n        }\n        var_834h = var_834h + 0x5c + *0x103c06c;\n        var_20h = var_20h + -1;\n        *0x103c014 = *0x103c010 + 6 + *0x103c06c;\n    }\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c014 = *0x103c014 - (*0x103c068 + 0x37 + *0x103c068);\n        *0x103c068 = (*0x103c014 + -5) - var_834h;\n    }\n    else {\n        *0x103c048 = var_834h + 0x1089d + *0x103c068 + *0x103c048 * 2;\n        *0x103c014 = *0x103c068 + 0x1089d + *0x103c068 + *0x103c014 * 2;\n    }\n    if (var_834h < *0x103c014) {\n        iVar2 = var_834h + 0x37;\n        var_834h = -(*0x103c06c + 0x37);\n        *0x103c014 = var_834h + 0x1089d + *0x103c068 + (*0x103c014 - (iVar2 + *0x103c068)) * 2;\n    }\n    if (*0x103c06c <= var_834h) {\n        *0x103c044 = *0x103c044 - *0x103c004;\n        *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n    }\n    var_834h = -*0x103c06c;\n    var_20h = 0x1492c12;\n    *0x103c014 = *0x103c06c * -2 + *0x103c014 * 2 + *0x103c010 * -2 + 0x1082f;\n    for (var_ch = 1; var_ch < 0x23; var_ch = var_ch + 1) {\n        if (var_834h != str.8jz[0]) {\n            var_834h = var_834h - *(var_ch + 0x103c058);\n            *0x103c068 = (var_834h + -5) - *0x103c004;\n            if (var_834h == str.8jz[0]) break;\n        }\n    }\n    if (*0x103c010 <= *0x103c06c) {\n        *0x103c06c = *0x103c014 + 0x1089d + *0x103c010 + *0x103c06c * 2;\n        *0x103c044 = *0x103c044 - *0x103c014;\n        *0x103c010 = *0x103c014 + 0x269d + *0x103c010;\n    }\n    if (*0x103c064 <= *0x103c014) {\n        *0x103c05b = *0x103c068;\n        var_834h = (*0x103c068 + var_834h * '\\x02' + 0x98) * 0x1d + *0x103c014;\n    }\n    *0x103c014 = *0x103c014 + 0xf8938c;\n    *0x103c068 = *0x103c004 + '\\\\' + var_834h;\n    if (str.8jz[2] == '\\x04') {\n        var_834h = (*0x103c014 - var_834h) - *0x103c068;\n    }\n    else {\n        *0x103c068 = *0x103c014 * '\\x1d' + var_834h;\n    }\n    while( true ) {\n        iVar2 = var_10h + 1;\n        if (*0x103c030 == 4) {\n            var_834h = (*0x103c014 - var_834h) - *0x103c068;\n        }\n        else {\n            *0x103c068 = *0x103c014 * '\\x1d' + var_834h;\n        }\n        if ((0x4ca5 < *0x103c014) && (*0x103c014 = *0x103c010 * 0x1d + *0x103c06c,  *0x103c048 <= var_834h)) {\n            *0x103c024 = *0x103c068;\n            *0x103c068 = *0x103c068 + *0x103c014 * '\\x02' + 0x98;\n            *0x103c014 = *0x103c068 * 0x1d + var_834h;\n        }\n        if (*0x103c028 - *0x103c040 == 0x326) {\n            *0x103c014 = *0x103c014 + var_834h * -2 + -0x37;\n            var_834h = (*0x103c014 + -5) - *0x103c06c;\n        }\n        else {\n            *0x103c048 = *0x103c06c + 0x1089d + var_834h + *0x103c048 * 2;\n            *0x103c014 = var_834h * 2 + 0x1089d + *0x103c014 * 2;\n        }\n        if (iVar2 < 0x34) {\n            if (*0x103c068 <= var_834h) {\n                var_834h = var_10h + 0x1089e + *0x103c068 + var_834h * 2;\n                *0x103c044 = *0x103c044 - iVar2;\n                *0x103c068 = iVar2 + -99 + *0x103c068;\n            }\n            *0x103c014 = *0x103c010 + 6 + *0x103c06c;\n            var_10h = iVar2;\n            *0x103c014 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x804);\n            iVar2 = var_10h;\n            if (*0x103c028 - *0x103c040 == 0x326) {\n                var_834h = var_834h - (*0x103c068 + 0x37 + *0x103c068);\n                *0x103c068 = (var_834h + -5) - var_10h;\n            }\n            else {\n                *0x103c048 = var_10h + 0x1089d + *0x103c068 + *0x103c048 * 2;\n                var_834h = *0x103c068 + 0x1089d + *0x103c068 + var_834h * 2;\n            }\n        }\n        var_10h = iVar2;\n        if (*0x103c028 - *0x103c040 == 0x326) {\n            *0x103c014 = *0x103c014 + *0x103c004 * -2 + -0x37;\n            *0x103c004 = (*0x103c014 + -5) - *0x103c06c;\n        }\n        else {\n            *0x103c048 = *0x103c06c + 0x1089d + *0x103c004 + *0x103c048 * 2;\n            *0x103c014 = *0x103c004 * 2 + 0x1089d + *0x103c014 * 2;\n        }\n        *0x103c010 = *0x103c014 + 0x5c + *0x103c06c;\n        if (*0x103c024 == 0x15ef) {\n            *0x103c068 = *0x103c068 + *0x103c020;\n        }\n        if (var_1ch < 3) {\n            var_1ch = var_1ch - 1;\n            *0x103c010 = (*0x103c004 - *0x103c010) - var_1ch;\n        }\n        iVar2 = *0x103c010 * 0x1d + *0x103c06c;\n        if (*0x103c028 - *0x103c040 == 0x326) {\n            *0x103c014 = iVar2 - (*0x103c068 + 0x37 + *0x103c068);\n            *0x103c068 = (*0x103c014 + -5) - var_834h;\n        }\n        else {\n            *0x103c048 = var_834h + 0x1089d + *0x103c068 + *0x103c048 * 2;\n            *0x103c014 = *0x103c068 + 0x1089d + *0x103c068 + iVar2 * 2;\n        }\n        *0x103c010 = (*0x103c004 - 5) - var_8h;\n        if (0x2b3d < *0x103c010) {\n            *0x103c014 = *0x103c06c + 0x1089d + *0x103c010 + *0x103c014 * 2;\n            if (*0x103c004 == var_834h) {\n                if (*0x103c030 == 4) {\n                    var_834h = (*0x103c014 - var_834h) - *0x103c068;\n                }\n                else {\n                    *0x103c068 = *0x103c014 * '\\x1d' + var_834h;\n                }\n                *0x103c014 = fcn.0100e9d0(*0x103c010);\n                if (*0x103c030 == 4) {\n                    *0x103c068 = (*0x103c06c - *0x103c068) - var_834h;\n                }\n                else {\n                    var_834h = *0x103c068 + *0x103c06c * 0x1d;\n                }\n                *0x103c068 = var_834h + -99 + *0x103c068;\n            }\n            if (*0x103c024 == 0x15ef) {\n                var_834h = var_834h + *0x103c020;\n                *0x103c014 = var_834h * 2 + -5 + *0x103c014;\n            }\n        }\n        uVar3 = var_8h;\n        if (var_8h < 0x11) {\n            if (*0x103c024 == 0x15ef) {\n                *0x103c010 = *0x103c010 + *0x103c020;\n                *0x103c014 = *0x103c010 * 2 + -5 + *0x103c014;\n            }\n            if (*0x103c028 - *0x103c040 == 0x326) {\n                *0x103c004 = *0x103c004 + *0x103c06c * -2 + -0x37;\n                *0x103c06c = (*0x103c004 - 5) - *0x103c014;\n            }\n            else {\n                *0x103c048 = *0x103c014 + 0x1089d + *0x103c06c + *0x103c048 * 2;\n                *0x103c004 = *0x103c06c * 2 + 0x1089d + *0x103c004 * 2;\n            }\n            uVar3 = var_8h - 1;\n            if (*0x103c010 <= *0x103c004) {\n                *0x103c004 = var_8h + 0x1089c + *0x103c010 + *0x103c004 * 2;\n                *0x103c044 = *0x103c044 - uVar3;\n                *0x103c010 = var_8h + 0x269c + *0x103c010;\n            }\n        }\n        var_8h = uVar3;\n        if (*0x103c06c <= *0x103c014) {\n            *0x103c014 = *0x103c010 + 0x1089d + *0x103c06c + *0x103c014 * 2;\n            *0x103c044 = *0x103c044 - *0x103c010;\n            *0x103c06c = *0x103c010 + 0x269d + *0x103c06c;\n        }\n        if (*0x103c028 - *0x103c040 == 0x326) {\n            var_834h = var_834h + *0x103c010 * -2 + -0x37;\n            *0x103c010 = (var_834h + -5) - *0x103c068;\n        }\n        else {\n            *0x103c048 = *0x103c068 + 0x1089d + *0x103c010 + *0x103c048 * 2;\n            var_834h = *0x103c010 * 2 + 0x1089d + var_834h * 2;\n        }\n        if (*0x103c030 == 4) {\n            *0x103c06c = (*0x103c014 - *0x103c06c) - var_834h;\n        }\n        else {\n            var_834h = *0x103c014 * 0x1d + *0x103c06c;\n        }\n        iVar2 = var_834h * 0x1d + *0x103c06c;\n        if (var_20h == 0) break;\n        *0x103c004 = var_20h + 0x269d + *0x103c004;\n        fcn.0100ebb0();\n        if (*0x103c048 <= *0x103c010) {\n            *0x103c024 = *0x103c06c;\n            *0x103c06c = *0x103c06c + iVar2 * 2 + 0x10898;\n        }\n        var_20h = var_20h + -1;\n        var_834h = (*0x103c004 - 5) - var_14h;\n        if (var_14h < 5) {\n            if (*0x103c048 <= *0x103c06c) {\n                *0x103c024 = *0x103c010;\n                *0x103c010 = *0x103c010 + *0x103c014 * 2 + 0x10898;\n                *0x103c014 = *0x103c010 * 0x1d + *0x103c06c;\n            }\n            if (*0x103c024 == 0x15ef) {\n                var_834h = var_834h + *0x103c020;\n                *0x103c014 = var_834h * 2 + -5 + *0x103c014;\n            }\n            *0x103c004 = *0x103c004 - (var_14h + 0x36 + *0x103c010);\n            var_14h = var_14h - 1;\n        }\n        else if (*0x103c048 <= var_8h) {\n            *0x103c024 = *0x103c068;\n            *0x103c068 = *0x103c068 + *0x103c014 * '\\x02' + 0x98;\n            *0x103c014 = *0x103c068 * 0x1d + var_8h;\n        }\n        var_834h = (*0x103c06c - var_834h) - 8;\n    }\n    uVar3 = (*0x103c014 - *0x103c06c) + 0x57 + arg_8h;\n    if (*0x103c048 <= uVar3) {\n        *0x103c024 = *0x103c068;\n        *0x103c068 = *0x103c068 + *0x103c06c * '\\x02' + 0x98;\n        *0x103c06c = *0x103c068 * 0x1d + uVar3;\n    }\n    *0x103c010 = uVar3 + 6 + arg_8h;\n    if (*0x103c030 == 4) {\n        *0x103c010 = (*0x103c068 - *0x103c010) - *0x103c06c;\n    }\n    else {\n        *0x103c06c = *0x103c068 * 0x1d + *0x103c010;\n    }\n    iVar2 = *0x103c014 + 0x1ef0;\n    var_834h = iVar2 * -2 - 0x5c;\n    if (*0x103c068 <= var_834h) {\n        var_834h = *0x103c014 + 0x1278d + *0x103c068 + var_834h * 2;\n        *0x103c063 = *0x103c063 - iVar2;\n        *0x103c068 = iVar2 + -99 + *0x103c068;\n    }\n    *0x103c014 = iVar2;\n    iVar4 = fcn.01001ce0(iVar2, *0x10d93b4);\n    uVar3 = *0x103c068;\n    iVar2 = var_834h + 0x269d + uVar3;\n    *0x103c068 = iVar2;\n    out(iVar2, uVar3);\n    *0x103c06c = iVar4 + *0x103c020;\n    fcn.01019b44(arg_8h_00);\n    return;\n}\n",
        "token_count": 7320
    },
    "0100ff25": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0100ff25(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t unaff_EBP;\n    uint unaff_retaddr;\n    uint var_858h;\n    uint var_854h;\n    uint var_850h;\n    uint var_84ch;\n    uint var_848h;\n    uint var_844h;\n    uint var_840h;\n    uint var_834h;\n    uint lpBuffer;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    do {\n        *0x103c06c = *0x103c06c + *0x103c020;\n        do {\n            *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) + -5 + *0x103c06c + *(unaff_EBP + -0x834);\n            if (*(unaff_EBP + -0x834) <= *0x103c014) {\n                *0x103c014 = *0x103c06c + 0x1089d + *(unaff_EBP + -0x834) + *0x103c014 * 2;\n                *0x103c044 = *0x103c044 - *0x103c06c;\n                *(unaff_EBP + -0x834) = *0x103c06c + 0x269d + *(unaff_EBP + -0x834);\n            }\n            if (*0x103c010 < *(unaff_EBP + -0x834)) {\n                *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) - (*0x103c06c + 0x37 + *0x103c004);\n                *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) * 0x1d + *0x103c06c;\n                *0x103c014 = *0x103c010 == 0;\n                if (*0x103c014 != 0) {\n                    *(unaff_EBP + -0x840) = *0x103c030;\n                    if (*(unaff_EBP + -0x840) == 4) {\n                        *0x103c06c = (*0x103c014 - *0x103c06c) - *0x103c004;\n                    }\n                    else {\n                        *0x103c004 = *0x103c014 * 0x1d + *0x103c06c;\n                    }\n                }\n                *0x103c014 = (*0x103c010 - 5) + *0x103c004 + *0x103c014;\n            }\n            *(unaff_EBP + -0x834) = (*(unaff_EBP + -0x834) + -5) - *0x103c06c;\n            *0x103c068 = *0x103c014 + '\\\\' + *(unaff_EBP + -0x834);\n            if (*0x103c014 < *(unaff_EBP + -0x834)) {\n                *0x103c068 = (*0x103c014 - *0x103c068) - *(unaff_EBP + -0x834);\n                *(unaff_EBP + -0x834) =\n                     *0x103c06c + 0x1089d + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n                *0x103c014 = *0x103c068 + 6 + *(unaff_EBP + -0x834);\n            }\n            else if (*0x103c028 - *0x103c040 == 0x326) {\n                *0x103c014 = *0x103c014 + *0x103c06c * -2 + -0x37;\n                *0x103c06c = (*0x103c014 + -5) - *0x103c010;\n            }\n            else {\n                *0x103c048 = *0x103c010 + 0x1089d + *0x103c06c + *0x103c048 * 2;\n                *0x103c014 = *0x103c06c * 2 + 0x1089d + *0x103c014 * 2;\n            }\n            if (*(unaff_EBP + -0x20) == 0) {\n                if (*0x103c028 - *0x103c040 == 0x326) {\n                    *0x103c014 = *0x103c014 - (*0x103c068 + 0x37 + *0x103c068);\n                    *0x103c068 = (*0x103c014 + -5) - *(unaff_EBP + -0x834);\n                }\n                else {\n                    *0x103c048 = *(unaff_EBP + -0x834) + 0x1089d + *0x103c068 + *0x103c048 * 2;\n                    *0x103c014 = *0x103c068 + 0x1089d + *0x103c068 + *0x103c014 * 2;\n                }\n                if (*(unaff_EBP + -0x834) <= *0x103c014 && *0x103c014 != *(unaff_EBP + -0x834)) {\n                    *0x103c014 = *0x103c014 - (*(unaff_EBP + -0x834) + 0x37 + *0x103c068);\n                    *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) - (*0x103c06c + 0x37 + *(unaff_EBP + -0x834));\n                    *0x103c014 = *(unaff_EBP + -0x834) + 0x1089d + *0x103c068 + *0x103c014 * 2;\n                }\n                if (*0x103c06c <= *(unaff_EBP + -0x834)) {\n                    *(unaff_EBP + -0x834) =\n                         *0x103c004 + 0x1089d + *0x103c06c + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n                    *0x103c044 = *0x103c044 - *0x103c004;\n                    *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n                }\n                *(unaff_EBP + -0x834) = (*(unaff_EBP + -0x834) - *(unaff_EBP + -0x834)) - *0x103c06c;\n                *0x103c014 = *0x103c014 - (*0x103c06c + 0x37 + *0x103c010);\n                *(unaff_EBP + -0x20) = 0x1492c12;\n                *0x103c014 = *(unaff_EBP + -0x834) + 0x1089d + *0x103c06c + *0x103c014 * 2;\n                *(unaff_EBP + -0xc) = 1;\n                goto code_r0x010104aa;\n            }\n            *0x103c068 = (*0x103c014 - *0x103c068) - *(unaff_EBP + -0x834);\n            fcn.0100ebb0();\n            if (*0x103c048 < *(unaff_EBP + -0x834) || *0x103c048 == *(unaff_EBP + -0x834)) {\n                *0x103c024 = *0x103c068;\n            }\n            *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) + 0x5c + *0x103c06c;\n            *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + -1;\n            *0x103c014 = *0x103c010 + 6 + *0x103c06c;\n        } while (*0x103c024 != 0x15ef);\n    } while( true );\ncode_r0x010104aa:\n    if (0x22 < *(unaff_EBP + -0xc)) {\ncode_r0x01010501:\n        if (*0x103c010 <= *0x103c06c) {\n            *0x103c06c = *0x103c014 + 0x1089d + *0x103c010 + *0x103c06c * 2;\n            *0x103c044 = *0x103c044 - *0x103c014;\n            *0x103c010 = *0x103c014 + 0x269d + *0x103c010;\n        }\n        if (*0x103c064 <= *0x103c014) {\n            *0x103c05b = *0x103c068;\n            *(unaff_EBP + -0x834) = *0x103c014 + 0x1089d + *0x103c068 + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n            *(unaff_EBP + -0x834) = ((*(unaff_EBP + -0x834) + -5) - *0x103c014) * 0x1d + *0x103c014;\n        }\n        *0x103c014 = *0x103c014 + 0xf8938c;\n        *0x103c068 = *0x103c004 + '\\\\' + *(unaff_EBP + -0x834);\n        *(unaff_EBP + -0x844) = str.8jz[2];\n        if (*(unaff_EBP + -0x844) == '\\x04') {\n            *(unaff_EBP + -0x834) = (*0x103c014 - *(unaff_EBP + -0x834)) - *0x103c068;\n        }\n        else {\n            *0x103c068 = *0x103c014 * '\\x1d' + *(unaff_EBP + -0x834);\n        }\n        while( true ) {\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n            *(unaff_EBP + -0x848) = *0x103c030;\n            if (*(unaff_EBP + -0x848) == 4) {\n                *(unaff_EBP + -0x834) = (*0x103c014 - *(unaff_EBP + -0x834)) - *0x103c068;\n            }\n            else {\n                *0x103c068 = *0x103c014 * '\\x1d' + *(unaff_EBP + -0x834);\n            }\n            if ((0x4ca5 < *0x103c014) &&\n               (*0x103c014 = *0x103c010 * 0x1d + *0x103c06c, \n               *0x103c048 < *(unaff_EBP + -0x834) || *0x103c048 == *(unaff_EBP + -0x834))) {\n                *0x103c024 = *0x103c068;\n                *0x103c068 = (*(unaff_EBP + -0x834) + *0x103c068 + *0x103c014 * '\\x02' + -0x68) - *(unaff_EBP + -0x834);\n                *0x103c014 = *0x103c068 * 0x1d + *(unaff_EBP + -0x834);\n            }\n            if (*0x103c028 - *0x103c040 == 0x326) {\n                *0x103c014 = *0x103c014 - (*(unaff_EBP + -0x834) + 0x37 + *(unaff_EBP + -0x834));\n                *(unaff_EBP + -0x834) = (*0x103c014 + -5) - *0x103c06c;\n            }\n            else {\n                *0x103c048 = *0x103c06c + 0x1089d + *(unaff_EBP + -0x834) + *0x103c048 * 2;\n                *0x103c014 = *(unaff_EBP + -0x834) + 0x1089d + *(unaff_EBP + -0x834) + *0x103c014 * 2;\n            }\n            if (*(unaff_EBP + -0x10) < 0x34) {\n                if (*0x103c068 <= *(unaff_EBP + -0x834)) {\n                    *(unaff_EBP + -0x834) =\n                         *(unaff_EBP + -0x10) + 0x1089d + *0x103c068 + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n                    *0x103c044 = *0x103c044 - *(unaff_EBP + -0x10);\n                    *0x103c068 = *(unaff_EBP + -0x10) + -99 + *0x103c068;\n                }\n                *0x103c014 = *0x103c010 + 6 + *0x103c06c;\n                *0x103c014 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(unaff_EBP + -0x830, 0x804);\n                if (*0x103c028 - *0x103c040 == 0x326) {\n                    *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) - (*0x103c068 + 0x37 + *0x103c068);\n                    *0x103c068 = (*(unaff_EBP + -0x834) + -5) - *(unaff_EBP + -0x10);\n                }\n                else {\n                    *0x103c048 = *(unaff_EBP + -0x10) + 0x1089d + *0x103c068 + *0x103c048 * 2;\n                    *(unaff_EBP + -0x834) =\n                         *0x103c068 + 0x1089d + *0x103c068 + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n                }\n            }\n            if (*0x103c028 - *0x103c040 == 0x326) {\n                *0x103c014 = *0x103c014 + *0x103c004 * -2 + -0x37;\n                *0x103c004 = (*0x103c014 + -5) - *0x103c06c;\n            }\n            else {\n                *0x103c048 = *0x103c06c + 0x1089d + *0x103c004 + *0x103c048 * 2;\n                *0x103c014 = *0x103c004 * 2 + 0x1089d + *0x103c014 * 2;\n            }\n            *0x103c010 = *0x103c014 + 0x5c + *0x103c06c;\n            if (*0x103c024 == 0x15ef) {\n                *0x103c068 = *0x103c068 + *0x103c020;\n            }\n            if (*(unaff_EBP + -0x1c) < 3) {\n                *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + -1;\n                *0x103c010 = (*0x103c004 - *0x103c010) - *(unaff_EBP + -0x1c);\n            }\n            iVar1 = *0x103c010 * 0x1d + *0x103c06c;\n            if (*0x103c028 - *0x103c040 == 0x326) {\n                *0x103c014 = iVar1 - (*0x103c068 + 0x37 + *0x103c068);\n                *0x103c068 = (*0x103c014 + -5) - *(unaff_EBP + -0x834);\n            }\n            else {\n                *0x103c048 = *(unaff_EBP + -0x834) + 0x1089d + *0x103c068 + *0x103c048 * 2;\n                *0x103c014 = *0x103c068 + 0x1089d + *0x103c068 + iVar1 * 2;\n            }\n            *0x103c010 = (*0x103c004 - 5) - *(unaff_EBP + -8);\n            if (0x2b3d < *0x103c010) {\n                *0x103c014 = *0x103c06c + 0x1089d + *0x103c010 + *0x103c014 * 2;\n                if (*0x103c004 == *(unaff_EBP + -0x834)) {\n                    *(unaff_EBP + -0x84c) = *0x103c030;\n                    if (*(unaff_EBP + -0x84c) == 4) {\n                        *(unaff_EBP + -0x834) = (*0x103c014 - *(unaff_EBP + -0x834)) - *0x103c068;\n                    }\n                    else {\n                        *0x103c068 = *0x103c014 * '\\x1d' + *(unaff_EBP + -0x834);\n                    }\n                    *0x103c014 = fcn.0100e9d0(*0x103c010);\n                    *(unaff_EBP + -0x850) = *0x103c030;\n                    if (*(unaff_EBP + -0x850) == 4) {\n                        *0x103c068 = (*0x103c06c - *0x103c068) - *(unaff_EBP + -0x834);\n                    }\n                    else {\n                        *(unaff_EBP + -0x834) = *0x103c068 + *0x103c06c * 0x1d;\n                    }\n                    *0x103c068 = *(unaff_EBP + -0x834) + -99 + *0x103c068;\n                }\n                if (*0x103c024 == 0x15ef) {\n                    *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) + *0x103c020;\n                    *0x103c014 = *(unaff_EBP + -0x834) + -5 + *(unaff_EBP + -0x834) + *0x103c014;\n                }\n            }\n            if (*(unaff_EBP + -8) < 0x11) {\n                if (*0x103c024 == 0x15ef) {\n                    *0x103c010 = *0x103c010 + *0x103c020;\n                    *0x103c014 = *0x103c010 * 2 + -5 + *0x103c014;\n                }\n                if (*0x103c028 - *0x103c040 == 0x326) {\n                    *0x103c004 = *0x103c004 + *0x103c06c * -2 + -0x37;\n                    *0x103c06c = (*0x103c004 - 5) - *0x103c014;\n                }\n                else {\n                    *0x103c048 = *0x103c014 + 0x1089d + *0x103c06c + *0x103c048 * 2;\n                    *0x103c004 = *0x103c06c * 2 + 0x1089d + *0x103c004 * 2;\n                }\n                *(unaff_EBP + -8) = *(unaff_EBP + -8) + -1;\n                if (*0x103c010 <= *0x103c004) {\n                    *0x103c004 = *(unaff_EBP + -8) + 0x1089d + *0x103c010 + *0x103c004 * 2;\n                    *0x103c044 = *0x103c044 - *(unaff_EBP + -8);\n                    *0x103c010 = *(unaff_EBP + -8) + 0x269d + *0x103c010;\n                }\n            }\n            if (*0x103c06c <= *0x103c014) {\n                *0x103c014 = *0x103c010 + 0x1089d + *0x103c06c + *0x103c014 * 2;\n                *0x103c044 = *0x103c044 - *0x103c010;\n                *0x103c06c = *0x103c010 + 0x269d + *0x103c06c;\n            }\n            if (*0x103c028 - *0x103c040 == 0x326) {\n                *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) + *0x103c010 * -2 + -0x37;\n                *0x103c010 = (*(unaff_EBP + -0x834) + -5) - *0x103c068;\n            }\n            else {\n                *0x103c048 = *0x103c068 + 0x1089d + *0x103c010 + *0x103c048 * 2;\n                *(unaff_EBP + -0x834) = *0x103c010 * 2 + 0x1089d + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n            }\n            *(unaff_EBP + -0x854) = *0x103c030;\n            if (*(unaff_EBP + -0x854) == 4) {\n                *0x103c06c = (*0x103c014 - *0x103c06c) - *(unaff_EBP + -0x834);\n            }\n            else {\n                *(unaff_EBP + -0x834) = *0x103c014 * 0x1d + *0x103c06c;\n            }\n            *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) * 0x1d + *0x103c06c;\n            if (*(unaff_EBP + -0x20) == 0) break;\n            *0x103c004 = *(unaff_EBP + -0x20) + 0x269d + *0x103c004;\n            fcn.0100ebb0();\n            if (*0x103c048 <= *0x103c010) {\n                *0x103c024 = *0x103c06c;\n                *(unaff_EBP + -0x834) =\n                     *0x103c010 + 0x1089d + *0x103c06c + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n                *0x103c06c = (*(unaff_EBP + -0x834) + -5) - *0x103c010;\n                *(unaff_EBP + -0x834) = *0x103c06c * 0x1d + *0x103c010;\n            }\n            *(unaff_EBP + -0x834) = *0x103c06c + 0x269d + *(unaff_EBP + -0x834);\n            *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + -1;\n            *(unaff_EBP + -0x834) = (*0x103c004 - 5) - *(unaff_EBP + -0x14);\n            if (*(unaff_EBP + -0x14) < 5) {\n                if (*0x103c048 <= *0x103c06c) {\n                    *0x103c024 = *0x103c010;\n                    *0x103c010 = *0x103c010 + *0x103c014 * 2 + 0x10898;\n                    *0x103c014 = *0x103c010 * 0x1d + *0x103c06c;\n                }\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + -1;\n                if (*0x103c024 == 0x15ef) {\n                    *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) + *0x103c020;\n                    *0x103c014 = *(unaff_EBP + -0x834) + -5 + *(unaff_EBP + -0x834) + *0x103c014;\n                }\n                *0x103c004 = *0x103c004 - (*(unaff_EBP + -0x14) + 0x37 + *0x103c010);\n            }\n            else if (*0x103c048 < *(unaff_EBP + -8) || *0x103c048 == *(unaff_EBP + -8)) {\n                *0x103c024 = *0x103c068;\n                *0x103c068 = (*(unaff_EBP + -8) + *0x103c068 + *0x103c014 * '\\x02' + -0x68) - *(unaff_EBP + -8);\n                *0x103c014 = *0x103c068 * 0x1d + *(unaff_EBP + -8);\n            }\n            *(unaff_EBP + -0x834) = (*0x103c06c - *(unaff_EBP + -0x834)) + -8;\n        }\n        *(unaff_EBP + -0x834) = (*0x103c014 - *0x103c06c) + 0x57 + *(unaff_EBP + 8);\n        if (*0x103c048 < *(unaff_EBP + -0x834) || *0x103c048 == *(unaff_EBP + -0x834)) {\n            *0x103c024 = *0x103c068;\n            *0x103c068 = (*(unaff_EBP + -0x834) + *0x103c068 + *0x103c06c * '\\x02' + -0x68) - *(unaff_EBP + -0x834);\n            *0x103c06c = *0x103c068 * 0x1d + *(unaff_EBP + -0x834);\n        }\n        *0x103c010 = *(unaff_EBP + -0x834) + 6 + *(unaff_EBP + 8);\n        *(unaff_EBP + -0x858) = *0x103c030;\n        if (*(unaff_EBP + -0x858) == 4) {\n            *0x103c010 = (*0x103c068 - *0x103c010) - *0x103c06c;\n        }\n        else {\n            *0x103c06c = *0x103c068 * 0x1d + *0x103c010;\n        }\n        *(unaff_EBP + -0x834) = 0x776;\n        *0x103c014 = (*0x103c014 - (*(unaff_EBP + -0x834) + 0x37)) + 0x269d;\n        *(unaff_EBP + -0x834) = *0x103c010 + 0x5c + *0x103c014;\n        *(unaff_EBP + -0x834) = (*0x103c010 - *(unaff_EBP + -0x834)) - *0x103c014;\n        if (*0x103c068 <= *(unaff_EBP + -0x834)) {\n            *(unaff_EBP + -0x834) = *0x103c014 + 0x1089d + *0x103c068 + *(unaff_EBP + -0x834) + *(unaff_EBP + -0x834);\n            *0x103c063 = *0x103c063 - *0x103c014;\n            *0x103c068 = *0x103c014 + -99 + *0x103c068;\n        }\n        iVar2 = fcn.01001ce0(*0x103c014, *0x10d93b4);\n        uVar3 = *0x103c068;\n        iVar1 = *(unaff_EBP + -0x834) + 0x269d + uVar3;\n        *0x103c068 = iVar1;\n        out(iVar1, uVar3);\n        *0x103c06c = iVar2 + *0x103c020;\n        *(unaff_EBP + -0x834) = *0x103c06c * 2 + -5 + *(unaff_EBP + -0x834);\n        fcn.01019b44(unaff_retaddr);\n        return;\n    }\n    if (*(unaff_EBP + -0x834) != str.8jz[0]) {\n        *(unaff_EBP + -0x834) = *(unaff_EBP + -0x834) - *(*(unaff_EBP + -0xc) + 0x103c058);\n        *0x103c068 = (*(unaff_EBP + -0x834) + -5) - *0x103c004;\n        if (*(unaff_EBP + -0x834) == str.8jz[0]) goto code_r0x01010501;\n    }\n    *(unaff_EBP + -0xc) = *(unaff_EBP + -0xc) + 1;\n    goto code_r0x010104aa;\n}\n",
        "token_count": 6881
    },
    "01011ac0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01011ac0(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    bool bVar3;\n    uint var_8h;\n    int32_t var_4h;\n    \n    uVar2 = *0x103c010 + -99 + *0x103c06c + *0x103c068 * '\\x02';\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c010 = *0x103c010 - (uVar2 + 0x37 + uVar2);\n    }\n    else {\n        *0x103c048 = arg_8h + 0x1089d + uVar2 + *0x103c048 * 2;\n        *0x103c010 = uVar2 + 0x1089d + uVar2 + *0x103c010 * 2;\n    }\n    uVar1 = *0x103c06c + -5 + var_4h;\n    bVar3 = CARRY4(uVar1, *0x103c008);\n    *0x103c008 = uVar1 + *0x103c008;\n    *0x103c00c = *0x103c00c + bVar3;\n    if (*0x103c024 == 0x15ef) {\n        *0x103c06c = *0x103c06c + *0x103c020;\n        *0x103c010 = *0x103c06c * 2 + -5 + *0x103c010;\n    }\n    if (*0x103c030 == 4) {\n        arg_8h = (*0x103c010 - arg_8h) - (*0x103c06c + '\\x06' + *0x103c010);\n    }\n    *0x103c06c = (*0x103c008 - *0x103c06c) - var_4h;\n    for (*0x10da108 = 0x2b; 1 < *0x10da108; *0x10da108 = *0x10da108 + -2) {\n        if (*0x103c06c != *0x103c034) {\n            *0x103c010 = *0x103c06c + -5 + arg_8h + *0x103c010;\n            *(*0x10da108 * 4 + 0x103c018) = *(*0x10da108 * 4 + 0x103c018) - arg_8h;\n            *0x103c06c = arg_8h + 0x269d + *0x103c06c;\n        }\n    }\n    *0x103c068 = *0x103c06c + '\\x06' + *0x103c010;\n    if (*0x103c068 <= *0x103c010) {\n        *0x103c010 = arg_8h + 0x1089d + *0x103c068 + *0x103c010 * 2;\n        *0x103c044 = *0x103c044 - arg_8h;\n        *0x103c068 = arg_8h + -99 + *0x103c068;\n    }\n    *0x103c06c = (*0x103c068 - 5) - *0x103c010;\n    uVar1 = var_4h + 0x37 + *0x103c06c;\n    bVar3 = *0x103c008 < uVar1;\n    *0x103c008 = *0x103c008 - uVar1;\n    *0x103c068 = *0x103c010 + -99 + *0x103c06c + *0x103c068 * '\\x02';\n    if (*0x103c068 <= *0x103c010) {\n        *0x103c010 = arg_8h + 0x1089d + *0x103c068 + *0x103c010 * 2;\n        *0x103c044 = *0x103c044 - arg_8h;\n        *0x103c068 = arg_8h + -99 + *0x103c068;\n    }\n    *0x103c00c = *0x103c00c - bVar3;\n    return *0x103c008;\n}\n",
        "token_count": 1000
    },
    "01011e10": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.01011e10(void)\n\n{\n    uint32_t uVar1;\n    int32_t *in_FS_OFFSET;\n    bool bVar2;\n    int32_t arg_8h;\n    uint var_878h;\n    uint var_874h;\n    uint var_870h;\n    uint var_86ch;\n    uint var_868h;\n    uint var_864h;\n    uint var_860h;\n    uint var_85ch;\n    uint var_858h;\n    uint var_854h;\n    uint var_850h;\n    uint var_84ch;\n    uint var_848h;\n    uint var_844h;\n    uint var_840h;\n    uint lpBuffer;\n    uint32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102be3b;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    var_14h = 0;\n    *0x103c008 = *0x103c06c + 6 + *0x103c070;\n    *0x103c00c = 0;\n    *0x103c06c = *0x103c014 + 0x5c + *0x103c004;\n    var_18h = uVar1;\n    fcn.0101a941(0, 0x102d26f);\n    (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableA)(0x10367f4, &lpBuffer, 0x804, uVar1);\n    if ((*0x103c00c == 0) && (*0x103c008 <= *0x103c004)) {\n        *0x103c004 = *0x103c010 + 0x1089d + *0x103c008 + *0x103c004 * 2;\n        *0x103c063 = *0x103c063 - *0x103c010;\n        bVar2 = CARRY4(*0x103c010 + 0x269dU, *0x103c008);\n        *0x103c008 = *0x103c010 + 0x269dU + *0x103c008;\n        *0x103c00c = bVar2;\n    }\n    var_10h = fcn.01017818(0x804);\n    *0x103c014 = *0x103c06c * 0x1d + *0x103c004;\n    for (var_14h = 0x2b; uVar1 = *0x103c004,  1 < var_14h; var_14h = var_14h + -2) {\n        if (*0x103c06c != *0x103c034) {\n            uVar1 = *0x103c06c + -5 + *0x103c004;\n            bVar2 = CARRY4(uVar1, *0x103c008);\n            *0x103c008 = uVar1 + *0x103c008;\n            *0x103c00c = *0x103c00c + bVar2;\n            *(var_14h * 4 + 0x103c018) = *(var_14h * 4 + 0x103c018) - *0x103c004;\n            *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n        }\n    }\n    if (*0x103c030 == 4) {\n        *0x103c004 = (*0x103c008 - *0x103c004) - *0x103c06c;\n    }\n    else {\n        *0x103c06c = fcn.01019b10(*0x103c008, *0x103c00c, 0x1d, 0);\n        *0x103c06c = uVar1 + *0x103c06c;\n    }\n    *0x103c014 = fcn.010117b0(*0x103c008);\n    *0x103c06c = *0x103c014 + 0x5c + *0x103c010;\n    *0x103c008 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, var_10h, 0x804);\n    *0x103c00c = 0;\n    if (*0x103c024 == 0x15ef) {\n        *0x103c06c = *0x103c06c + *0x103c020;\n        *0x103c068 = *0x103c068 + *0x103c06c * '\\x02' + -5;\n    }\n    for (var_14h = 1; var_14h < 0x23; var_14h = var_14h + 1) {\n        if (*0x103c014 != str.8jz[0]) {\n            *0x103c014 = *0x103c014 - *(var_14h + 0x103c058);\n            *0x103c06c = (*0x103c014 - 5) - *0x103c008;\n            if (*0x103c014 == str.8jz[0]) break;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_SetConsoleCP)(0);\n    fcn.01013150(&lpBuffer);\n    var_4h = 0;\n    *0x103c06c = *0x103c004 + 0x1089d + *0x103c008 + *0x103c06c * 2;\n    *0x103c014 = *0x103c06c + -5 + *0x103c004 + *0x103c014;\n    fcn.010131b0(var_10h);\n    *0x103c014 = *0x103c06c * 0x1d + *0x103c010;\n    *0x103c004 = fcn.010112f0(*0x103c010);\n    *0x103c06c = (*0x103c014 + -5) - *0x103c010;\n    *0x103c010 = fcn.01015ab0();\n    *0x103c008 = *0x103c010 + 0x5c + *0x103c06c;\n    *0x103c00c = 0;\n    *0x103c014 = *0x103c06c + 0x5c + *0x103c008;\n    *0x103c004 = fcn.010117b0(*0x103c06c);\n    *0x103c010 = *0x103c010 - (*0x103c06c + 0x37 + *0x103c008);\n    for (var_14h = 1; var_14h < 0x23; var_14h = var_14h + 1) {\n        if ((*0x103c008 != *0x103c028) || (*0x103c00c != 0)) {\n            uVar1 = *(var_14h * 4 + 0x103c018);\n            bVar2 = *0x103c008 < uVar1;\n            *0x103c008 = *0x103c008 - uVar1;\n            *0x103c00c = *0x103c00c - bVar2;\n            *0x103c06c = (*0x103c008 - 5) - *0x103c004;\n            if ((*0x103c008 == *0x103c028) && (*0x103c00c == 0)) break;\n        }\n    }\n    *0x103c014 = *0x103c06c * 0x1d + *0x103c010;\n    if (*0x103c05b == 0x15ef) {\n        bVar2 = CARRY4(*0x103c05a, *0x103c008);\n        *0x103c008 = *0x103c05a + *0x103c008;\n        *0x103c00c = *0x103c00c + bVar2;\n        *0x103c014 = *0x103c014 + *0x103c008 * 2 + -5;\n    }\n    arg_8h = *0x103c010;\n    uVar1 = fcn.010117b0(*0x103c010);\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c06c = *0x103c06c + *0x103c014 * -2 + -0x37;\n        *0x103c014 = -5;\n    }\n    else {\n        *0x103c048 = *0x103c06c + 0x1089d + *0x103c014 + *0x103c048 * 2;\n        *0x103c06c = *0x103c014 * 2 + 0x1089d + *0x103c06c * 2;\n    }\n    *0x103c06c = *0x103c06c - (*0x103c008 + 0x37 + *0x103c014);\n    *0x103c014 = *0x103c06c + -5 + *0x103c010 + *0x103c014;\n    if (*0x103c030 == 4) {\n        *0x103c004 = (*0x103c008 - uVar1) - *0x103c06c;\n    }\n    else {\n        arg_8h = 0;\n        *0x103c004 = uVar1;\n        *0x103c06c = fcn.01019b10(*0x103c008, *0x103c00c, 0x1d);\n        *0x103c06c = uVar1 + *0x103c06c;\n    }\n    if ((*0x103c00c == 0) && (*0x103c008 <= *0x103c004)) {\n        *0x103c004 = *0x103c010 + 0x1089d + *0x103c008 + *0x103c004 * 2;\n        *0x103c063 = *0x103c063 - *0x103c010;\n        bVar2 = CARRY4(*0x103c010 + 0x269dU, *0x103c008);\n        *0x103c008 = *0x103c010 + 0x269dU + *0x103c008;\n        *0x103c00c = bVar2;\n    }\n    for (var_14h = 0x2b; 1 < var_14h; var_14h = var_14h + -2) {\n        if ((*0x103c008 != str.8jz[3]) || (*0x103c00c != 0)) {\n            *0x103c004 = *0x103c004 + (*0x103c008 - 5) + *0x103c010;\n            *(var_14h + 0x103c058) = *(var_14h + 0x103c058) - *0x103c010;\n            bVar2 = CARRY4(*0x103c010 + 0x269dU, *0x103c008);\n            *0x103c008 = *0x103c010 + 0x269dU + *0x103c008;\n            *0x103c00c = *0x103c00c + bVar2;\n        }\n    }\n    fcn.0100f650(*0x103c008);\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c06c = (*0x103c008 + *0x103c06c * -2 + -0x3c) - *0x103c004;\n    }\n    else {\n        *0x103c048 = *0x103c004 + 0x1089d + *0x103c06c + *0x103c048 * 2;\n    }\n    *0x103c06c = (*0x103c014 - *0x103c06c) - *0x103c004;\n    *0x103c008 = *0x103c06c + 6 + *0x103c068;\n    *0x103c00c = 0;\n    var_4h = 0xffffffff;\n    fcn.01013190();\n    *in_FS_OFFSET = var_ch;\n    fcn.01019b44(arg_8h);\n    return;\n}\n",
        "token_count": 2930
    },
    "01012da0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong __cdecl fcn.01012da0(uint arg_8h, uint noname_1, uchar *arg_10h, uchar *arg_14h, int32_t arg_18h)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    int32_t var_14h;\n    uchar *var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    uchar *var_4h;\n    \n    var_18h = 0x23;\n    var_14h = 0;\n    var_4h = arg_10h;\n    uVar2 = arg_8h + 0x8f3;\n    if (*0x103c024 == 0x15ef) {\n        *0x103c068 = *0x103c068 + *0x103c020;\n    }\n    var_10h = arg_14h;\n    var_1ch = *0x103c06c + *0x103c068 + 0x271c;\n    if (*0x103c030 == 4) {\n        uVar3 = uVar2 - 0x23;\n        var_18h = uVar3 - *0x103c068;\n        var_14h = -(uVar3 < *0x103c068) - (uVar2 < 0x23);\n    }\n    else {\n        *0x103c068 = uVar2 * '\\x1d' + 0x23;\n    }\n    var_8h = 0x2b;\n    while( true ) {\n        if (var_8h < 2) break;\n        if (*0x103c068 != *0x103c034) {\n            *(var_8h * 4 + 0x103c018) = *(var_8h * 4 + 0x103c018) - var_18h;\n            *0x103c068 = var_18h + -99 + *0x103c068;\n        }\n        var_8h = var_8h + -2;\n    }\n    if (*0x103c024 == 0x15ef) {\n        *0x103c068 = *0x103c068 + *0x103c020;\n        var_1ch = *0x103c068 + var_1ch + -5 + *0x103c068;\n    }\n    while (iVar4 = arg_18h + -1,  arg_18h != 0) {\n        *var_4h = *var_10h;\n        var_4h = var_4h + 1;\n        var_10h = var_10h + 1;\n        arg_18h = iVar4;\n        if (*0x103c068 <= var_18h + 0x89d + var_1ch * 0x3b + iVar4 * 2) {\n            *0x103c044 = *0x103c044 - var_18h;\n            *0x103c068 = var_18h + -99 + *0x103c068;\n        }\n    }\n    uVar3 = *0x103c06c + 0x1089d + var_1ch;\n    uVar5 = uVar3 + var_18h;\n    cVar1 = fcn.0100ee10(var_1ch);\n    if ((var_14h * 2 + CARRY4(uVar3, var_18h) + CARRY4(uVar5, var_18h) != 0) ||\n       (uVar3 = *0x103c048,  *0x103c048 <= uVar5 + var_18h)) {\n        *0x103c024 = *0x103c068;\n        *0x103c068 = *0x103c068 + cVar1 * '\\x02' + 0x98;\n        uVar3 = 0;\n    }\n    return CONCAT44(uVar3, arg_10h);\n}\n",
        "token_count": 943
    },
    "010131d0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.010131d0(int32_t *param_1)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint32_t extraout_ECX;\n    uint32_t arg_20h;\n    int32_t *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t uStack112;\n    uint var_5ch;\n    uint var_58h;\n    int32_t var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_30h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_14h;\n    uint32_t *puStack20;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102be80;\n    var_ch_2 = *in_FS_OFFSET;\n    uStack112 = *0x103c470 ^ &stack0xfffffffc;\n    puStack20 = &uStack112;\n    *in_FS_OFFSET = &var_ch_2;\n    var_14h = 0;\n    fcn.01013d40(param_1);\n    var_4h = 0;\n    cVar1 = fcn.01013f30();\n    if (cVar1 != '\\0') {\n        uVar3 = fcn.01013420(&var_24h);\n        var_4h._0_1_ = 1;\n        var_20h = fcn.01014c40(uVar3);\n        var_4h._0_1_ = 0;\n        fcn.01013370();\n        var_4h = CONCAT31(var_4h._1_3_, 2);\n        if (param_1 == NULL) {\n            var_50h = 0;\n        }\n        else {\n            var_50h = param_1 + *(*param_1 + 4);\n        }\n        uVar2 = fcn.01013d20();\n        uVar3 = fcn.010136c0();\n        arg_20h = extraout_ECX & 0xffffff00 | uVar2;\n        puVar4 = fcn.01013fa0(uVar3);\n        fcn.01013f50(&var_3ch, *puVar4, puVar4[1], puVar4[2], uVar3, var_50h, arg_20h);\n        cVar1 = fcn.01013f30();\n        if (cVar1 != '\\0') {\n            var_14h = var_14h | 4;\n        }\n        var_4h = 0;\n    }\n    fcn.01013670(var_14h, 0);\n    var_4h = 0xffffffff;\n    fcn.01013ec0();\n    *in_FS_OFFSET = var_ch_2;\n    return param_1;\n}\n",
        "token_count": 712
    },
    "01013370": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.01013370(int32_t *param_1)\n\n{\n    uint *puVar1;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((*param_1 != 0) && (puVar1 = fcn.010133c0(),  puVar1 != NULL)) {\n        (***puVar1)(1);\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "010134d0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t * __fastcall fcn.010134d0(int32_t *param_1)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint32_t extraout_ECX;\n    uint32_t arg_20h;\n    int32_t *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t uStack112;\n    uint var_5ch;\n    uint var_58h;\n    int32_t var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_30h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_14h;\n    uint32_t *puStack20;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102beb0;\n    var_ch_2 = *in_FS_OFFSET;\n    uStack112 = *0x103c470 ^ &stack0xfffffffc;\n    puStack20 = &uStack112;\n    *in_FS_OFFSET = &var_ch_2;\n    var_14h = 0;\n    fcn.01013d40(param_1);\n    var_4h = 0;\n    cVar1 = fcn.01013f30();\n    if (cVar1 != '\\0') {\n        uVar3 = fcn.01013420(&var_24h);\n        var_4h._0_1_ = 1;\n        var_20h = fcn.01014c40(uVar3);\n        var_4h._0_1_ = 0;\n        fcn.01013370();\n        var_4h = CONCAT31(var_4h._1_3_, 2);\n        if (param_1 == NULL) {\n            var_50h = 0;\n        }\n        else {\n            var_50h = param_1 + *(*param_1 + 4);\n        }\n        uVar2 = fcn.01013d20();\n        uVar3 = fcn.010136c0();\n        arg_20h = extraout_ECX & 0xffffff00 | uVar2;\n        puVar4 = fcn.01013fa0(uVar3);\n        fcn.01013f50(&var_3ch, *puVar4, puVar4[1], puVar4[2], uVar3, var_50h, arg_20h);\n        cVar1 = fcn.01013f30();\n        if (cVar1 != '\\0') {\n            var_14h = var_14h | 4;\n        }\n        var_4h = 0;\n    }\n    fcn.01013670(var_14h, 0);\n    var_4h = 0xffffffff;\n    fcn.01013ec0();\n    *in_FS_OFFSET = var_ch_2;\n    return param_1;\n}\n",
        "token_count": 712
    },
    "01013670": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.01013670(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t in_EAX;\n    uint32_t arg_ch_00;\n    uint32_t uVar1;\n    uint var_4h;\n    \n    if (arg_8h != 0) {\n        arg_ch_00 = in_EAX & 0xffffff00 | arg_ch & 0xff;\n        uVar1 = fcn.010136a0();\n        fcn.01013810(uVar1 | arg_8h, arg_ch_00);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "01013760": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.01013760(uint arg_8h, int32_t arg_ch)\n\n{\n    uint arg_10h;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((arg_8h != '\\0') && (0xf < *(in_ECX + 0x18))) {\n        arg_10h = *(in_ECX + 4);\n        if (arg_ch != 0) {\n            fcn.01014e30(in_ECX + 4, 0x10, arg_10h, arg_ch);\n        }\n        fcn.01014350(arg_10h);\n    }\n    *(in_ECX + 0x18) = 0xf;\n    fcn.01014230(arg_ch);\n    return;\n}\n",
        "token_count": 178
    },
    "01014190": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01014190(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t arg_ch_00;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t arg_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.01018cbf();\n    }\n    if (*(in_ECX + 0x14) - arg_8h < arg_ch) {\n        arg_ch = *(in_ECX + 0x14) - arg_8h;\n    }\n    if (arg_ch != 0) {\n        arg_14h = (*(in_ECX + 0x14) - arg_8h) - arg_ch;\n        iVar1 = fcn.01014320();\n        iVar1 = iVar1 + arg_8h + arg_ch;\n        arg_ch_00 = *(in_ECX + 0x18) - arg_8h;\n        iVar2 = fcn.01014320();\n        fcn.01014e60(iVar2 + arg_8h, arg_ch_00, iVar1, arg_14h);\n        fcn.01014230(*(in_ECX + 0x14) - arg_ch);\n    }\n    return in_ECX;\n}\n",
        "token_count": 311
    },
    "01014280": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nbool __cdecl fcn.01014280(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.010145d0();\n    if (uVar1 < arg_8h) {\n        fcn.01018c2e();\n    }\n    if (*(in_ECX + 0x18) < arg_8h) {\n        fcn.01014610(arg_8h, *(in_ECX + 0x14));\n    }\n    else if ((arg_ch == '\\0') || (0xf < arg_8h)) {\n        if (arg_8h == 0) {\n            fcn.01014230(0);\n        }\n    }\n    else {\n        if (arg_8h < *(in_ECX + 0x14)) {\n            var_8h = arg_8h;\n        }\n        else {\n            var_8h = *(in_ECX + 0x14);\n        }\n        fcn.01013760(1, var_8h);\n    }\n    return arg_8h != 0;\n}\n",
        "token_count": 268
    },
    "010145d0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t fcn.010145d0(void)\n\n{\n    uint32_t uVar1;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.010147f0();\n    if (uVar1 < 2) {\n        var_ch = 1;\n    }\n    else {\n        var_ch = uVar1 - 1;\n    }\n    return var_ch;\n}\n",
        "token_count": 99
    },
    "01014610": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.01014610(int32_t param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint arg_8h;\n    uint arg_10h;\n    int32_t *in_FS_OFFSET;\n    uint32_t var_8h;\n    int32_t var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint var_14h;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102bf90;\n    var_ch_3 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_3;\n    var_18h = var_8h | 0xf;\n    uVar1 = fcn.010145d0();\n    if (uVar1 < var_18h) {\n        var_18h = var_8h;\n    }\n    else if (var_18h / 3 < *(param_1 + 0x18) >> 1) {\n        uVar1 = *(param_1 + 0x18);\n        iVar2 = fcn.010145d0();\n        uVar1 = iVar2 - (uVar1 >> 1);\n        if (*(param_1 + 0x18) < uVar1 || *(param_1 + 0x18) == uVar1) {\n            var_18h = (*(param_1 + 0x18) >> 1) + *(param_1 + 0x18);\n        }\n    }\n    var_4h = 0;\n    arg_8h = fcn.010147d0(var_18h + 1);\n    var_4h = 0xffffffff;\n    if (var_ch_2 != 0) {\n        iVar2 = var_ch_2;\n        arg_10h = fcn.01014320();\n        fcn.01014e30(arg_8h, var_18h + 1, arg_10h, iVar2);\n    }\n    fcn.01013760(1, 0);\n    *(param_1 + 4) = arg_8h;\n    *(param_1 + 0x18) = var_18h;\n    fcn.01014230(var_ch_2);\n    *in_FS_OFFSET = var_ch_3;\n    return;\n}\n",
        "token_count": 568
    },
    "01014820": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.01014820(uint param_1, uint param_2)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch_2;\n    uint var_10h;\n    uint var_ch;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_5dh;\n    uint var_58h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uchar *puStack20;\n    int32_t var_ch_3;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102bfb8;\n    var_ch_3 = *in_FS_OFFSET;\n    puStack20 = &stack0xffffff7c;\n    *in_FS_OFFSET = &var_ch_3;\n    var_14h = 0;\n    var_18h = fcn.01013710(var_ch_2);\n    iVar3 = fcn.01014b00();\n    if ((iVar3 < 1) || (iVar3 = fcn.01014b00(),  iVar3 <= var_18h)) {\n        var_3ch = 0;\n    }\n    else {\n        var_3ch = fcn.01014b00();\n        var_3ch = var_3ch - var_18h;\n    }\n    var_1ch = var_3ch;\n    fcn.01013d40(var_8h);\n    var_4h = 0;\n    cVar1 = fcn.01013f30();\n    if (cVar1 == '\\0') {\n        var_14h = var_14h | 4;\n    }\n    else {\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        uVar4 = fcn.010143f0();\n        if ((uVar4 & 0x1c0) != 0x40) {\n            for (; 0 < var_1ch; var_1ch = var_1ch + -1) {\n                uVar2 = fcn.01013d20();\n                uVar4 = fcn.010136c0();\n                var_28h = fcn.01014b50(uVar4 & 0xffffff00 | uVar2);\n                var_2ch = fcn.01014af0();\n                cVar1 = fcn.01014ad0(&var_2ch, &var_28h);\n                if (cVar1 != '\\0') {\n                    var_14h = var_14h | 4;\n                    break;\n                }\n            }\n        }\n        if (var_14h == 0) {\n            fcn.010136c0();\n            iVar3 = fcn.01014f90(var_ch_2, var_18h);\n            if (iVar3 != var_18h) {\n                var_14h = var_14h | 4;\n            }\n        }\n        if (var_14h == 0) {\n            for (; 0 < var_1ch; var_1ch = var_1ch + -1) {\n                uVar2 = fcn.01013d20();\n                uVar4 = fcn.010136c0();\n                var_30h = fcn.01014b50(uVar4 & 0xffffff00 | uVar2);\n                var_34h = fcn.01014af0();\n                cVar1 = fcn.01014ad0(&var_34h, &var_30h);\n                if (cVar1 != '\\0') {\n                    var_14h = var_14h | 4;\n                    break;\n                }\n            }\n        }\n        fcn.01014b20(0);\n        var_4h = 0;\n    }\n    fcn.01013670(var_14h, 0);\n    var_4h = 0xffffffff;\n    fcn.01013ec0();\n    *in_FS_OFFSET = var_ch_3;\n    return var_8h;\n}\n",
        "token_count": 1025
    },
    "01014c40": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01014c40(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t *in_FS_OFFSET;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c1a8;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.01018b25(0, uVar1);\n    var_4h = 0;\n    var_1ch = *0x10da120;\n    var_14h = fcn.01014d30();\n    var_10h = fcn.01014da0(var_14h);\n    if (var_10h == 0) {\n        if (var_1ch == 0) {\n            iVar2 = fcn.01014fc0(&var_1ch);\n            if (iVar2 == -1) {\n                fcn.0101aff9(\"bad cast\");\n                fcn.0101ae78(&var_2ch, 0x10398c0);\n            }\n            else {\n                var_10h = var_1ch;\n                *0x10da120 = var_1ch;\n                var_20h = var_1ch;\n                fcn.01013490();\n                fcn.01014d80();\n            }\n        }\n        else {\n            var_10h = var_1ch;\n        }\n    }\n    iVar2 = var_10h;\n    var_4h = 0xffffffff;\n    fcn.01018b46();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 457
    },
    "01014fc0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.01014fc0(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c1db;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if ((arg_8h != NULL) && (*arg_8h == 0)) {\n        iVar1 = fcn.0101b091(0x10);\n        var_4h = 0;\n        if (iVar1 == 0) {\n            var_18h = 0;\n        }\n        else {\n            var_18h = fcn.01015050(0);\n        }\n        *arg_8h = var_18h;\n    }\n    *in_FS_OFFSET = var_ch;\n    return 4;\n}\n",
        "token_count": 239
    },
    "01015100": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.01015100(int32_t arg_8h)\n\n{\n    uchar uVar1;\n    uint32_t uVar2;\n    uint in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_54h;\n    uint var_50h;\n    uint var_34h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c05c;\n    var_ch = *in_FS_OFFSET;\n    uVar2 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.01018b25(0, uVar2);\n    var_4h = 0;\n    fcn.01015300();\n    var_4h._0_1_ = 1;\n    fcn.01015300();\n    var_4h._0_1_ = 2;\n    fcn.01015300();\n    var_4h._0_1_ = 3;\n    fcn.01015300();\n    var_4h._0_1_ = 4;\n    uVar1 = var_4h;\n    var_4h._0_1_ = 4;\n    if (arg_8h == 0) {\n        fcn.01013150(\"bad locale name\");\n        var_4h._0_1_ = 5;\n        fcn.01013b00(&var_50h);\n        fcn.0101ae78(&var_34h, 0x1039964);\n        var_4h._0_1_ = 4;\n        fcn.01013190();\n        uVar1 = var_4h;\n    }\n    var_4h._0_1_ = uVar1;\n    fcn.0101901b(in_ECX, arg_8h);\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 451
    },
    "01015ed0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.01015ed0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint32_t arg_18h, uint arg_1ch, uint32_t arg_20h, \n            char *arg_24h, int32_t arg_28h, int32_t arg_2ch, int32_t arg_30h, int32_t arg_34h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    char **ppcVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint arg_1ch_00;\n    uint *puVar7;\n    uint32_t extraout_ECX;\n    uint32_t extraout_EDX;\n    int32_t *in_FS_OFFSET;\n    uint arg_20h_00;\n    uint in_stack_fffffe90;\n    uint uVar8;\n    uint var_124h;\n    int32_t var_120h;\n    int32_t var_11ch;\n    uint var_118h;\n    uint var_114h;\n    uint var_110h;\n    uint var_104h;\n    uint var_f8h;\n    uint var_ech;\n    uint var_e0h;\n    uint var_d4h;\n    uint var_c8h;\n    uint var_bch;\n    uint var_b0h;\n    uint var_a4h;\n    uint var_98h;\n    uint var_8ch;\n    uint var_80h;\n    int32_t var_7ch;\n    int32_t var_78h;\n    uint *var_74h;\n    char *var_70h;\n    uint var_6ch;\n    uint var_50h;\n    uint32_t var_34h;\n    uint32_t var_30h;\n    uint32_t var_2ch;\n    int32_t var_25h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint8_t var_15h;\n    uint var_14h;\n    char *var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c138;\n    var_ch = *in_FS_OFFSET;\n    uVar2 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    puVar7 = &var_80h;\n    var_34h = uVar2;\n    uVar3 = fcn.01013420(puVar7);\n    var_4h = 0;\n    var_14h = fcn.01017090(uVar3);\n    var_4h = 0xffffffff;\n    fcn.01013370(puVar7, uVar2);\n    fcn.01016fe0(&var_50h);\n    var_4h = 1;\n    var_25h._0_1_ = fcn.01016fc0();\n    fcn.01015300();\n    var_4h = CONCAT31(var_4h._1_3_, 2);\n    var_15h = fcn.01017180(0x30);\n    if ((*arg_24h == '+') || (*arg_24h == '-')) {\n        var_11ch = 1;\n    }\n    else {\n        var_11ch = 0;\n    }\n    stack0xffffffd8 = var_11ch;\n    ppcVar4 = fcn.0101b29d();\n    var_1ch._0_1_ = **ppcVar4;\n    var_1ch._1_1_ = 0x65;\n    var_1ch._2_1_ = 0;\n    var_30h = fcn.0101b1f0(arg_24h, 0x65, arg_34h);\n    var_20h = fcn.0101b1f0(arg_24h, var_1ch, arg_34h);\n    if (var_20h == 0) {\n        arg_30h = 0;\n    }\n    pcVar5 = fcn.01013c40();\n    if ((*pcVar5 != '\\x7f') && (pcVar5 = fcn.01013c40(),  '\\0' < *pcVar5)) {\n        fcn.01014030(arg_24h, arg_34h);\n        if (var_30h == 0) {\n            fcn.01016c40(arg_30h, 0x30);\n        }\n        else {\n            if (var_20h == 0) {\n                fcn.01016c40(arg_28h, 0x30);\n                arg_28h = 0;\n            }\n            fcn.01016cc0(var_30h - arg_24h, arg_30h, 0x30);\n        }\n        if (var_20h == 0) {\n            fcn.01016c40(arg_28h, 0x30);\n        }\n        else {\n            fcn.01016cc0((var_20h - arg_24h) + 1, arg_2ch, 0x30);\n            fcn.01016cc0(var_20h - arg_24h, arg_28h, 0x30);\n            arg_2ch = 0;\n        }\n        arg_28h = 0;\n        var_70h = fcn.01013c40();\n        puVar7 = &var_1ch;\n        uVar8 = 0;\n        uVar3 = fcn.01016d80(0);\n        var_74h = fcn.0101b1a0(uVar3, uVar8);\n        while (((*var_70h != '\\x7f' && ('\\0' < *var_70h)) && (*var_70h < var_74h - stack0xffffffd8))) {\n            puVar7 = var_74h - *var_70h;\n            var_74h = puVar7;\n            fcn.01016cc0(puVar7, 1, 0);\n            if ('\\0' < var_70h[1]) {\n                var_70h = var_70h + 1;\n            }\n        }\n        in_stack_fffffe90 = 0;\n        arg_24h = fcn.01016d80(0);\n        arg_30h = 0;\n        arg_34h = fcn.01015ab0(in_stack_fffffe90, puVar7);\n    }\n    var_2ch = arg_28h + arg_2ch + arg_30h + arg_34h;\n    iVar6 = fcn.01014b00();\n    if ((iVar6 < 1) || (uVar2 = fcn.01014b00(),  uVar2 <= var_2ch)) {\n        var_120h = 0;\n    }\n    else {\n        var_120h = fcn.01014b00();\n        var_120h = var_120h - var_2ch;\n    }\n    var_2ch = var_120h;\n    uVar2 = fcn.010143f0();\n    pcVar5 = uVar2 & 0x1c0;\n    var_10h = pcVar5;\n    if ((pcVar5 == 0x40) || (pcVar5 == 0x100)) {\n        if (pcVar5 == 0x100) {\n            if (stack0xffffffd8 != 0) {\n                puVar7 = fcn.01016db0(arg_8h, &var_98h, arg_10h, arg_14h, arg_18h, arg_24h, 1);\n                arg_10h = *puVar7;\n                arg_14h = puVar7[1];\n                arg_18h = puVar7[2];\n                pcVar5 = arg_24h + 1;\n                arg_34h = arg_34h + -1;\n                arg_24h = pcVar5;\n            }\n            puVar7 = fcn.01016b70(arg_8h, &var_a4h, arg_10h, arg_14h, arg_18h, pcVar5 & 0xffffff00 | arg_20h & 0xff, \n                                  var_2ch);\n            arg_10h = *puVar7;\n            arg_14h = puVar7[1];\n            arg_18h = puVar7[2];\n            var_2ch = 0;\n        }\n    }\n    else {\n        puVar7 = fcn.01016b70(arg_8h, &var_8ch, arg_10h, arg_14h, arg_18h, uVar2 & 0x100 | arg_20h & 0xff, var_2ch);\n        arg_10h = *puVar7;\n        arg_14h = puVar7[1];\n        arg_18h = puVar7[2];\n        var_2ch = 0;\n    }\n    var_20h = fcn.0101b1f0(arg_24h, var_1ch, arg_34h);\n    if (var_20h != 0) {\n        var_78h = (var_20h - arg_24h) + 1;\n        puVar7 = fcn.01016e20(arg_8h, &var_b0h, arg_10h, arg_14h, arg_18h, arg_24h, var_20h - arg_24h, \n                              extraout_ECX & 0xffffff00 | var_25h);\n        puVar7 = fcn.01016b70(arg_8h, &var_bch, *puVar7, puVar7[1], puVar7[2], puVar7[1] & 0xffffff00 | var_15h, arg_28h\n                             );\n        uVar3 = *puVar7;\n        uVar8 = puVar7[1];\n        uVar1 = puVar7[2];\n        arg_20h_00 = 1;\n        arg_1ch_00 = fcn.01016fa0();\n        puVar7 = fcn.01016b70(arg_8h, &var_c8h, uVar3, uVar8, uVar1, arg_1ch_00, arg_20h_00);\n        puVar7 = fcn.01016b70(arg_8h, &var_d4h, *puVar7, puVar7[1], puVar7[2], puVar7[1] & 0xffffff00 | var_15h, arg_2ch\n                             );\n        arg_10h = *puVar7;\n        arg_14h = puVar7[1];\n        arg_18h = puVar7[2];\n        arg_24h = arg_24h + var_78h;\n        arg_34h = arg_34h - var_78h;\n    }\n    uVar2 = fcn.0101b1f0(arg_24h, 0x65, arg_34h);\n    var_30h = uVar2;\n    if (uVar2 != 0) {\n        var_7ch = (uVar2 - arg_24h) + 1;\n        puVar7 = fcn.01016e20(arg_8h, &var_e0h, arg_10h, arg_14h, arg_18h, arg_24h, uVar2 - arg_24h, \n                              uVar2 & 0xffffff00 | var_25h);\n        puVar7 = fcn.01016b70(arg_8h, &var_ech, *puVar7, puVar7[1], puVar7[2], puVar7[1] & 0xffffff00 | var_15h, arg_30h\n                             );\n        uVar3 = *puVar7;\n        uVar8 = puVar7[1];\n        uVar1 = puVar7[2];\n        arg_30h = 0;\n        uVar2 = fcn.010143f0();\n        if ((uVar2 & 4) == 0) {\n            var_124h = 0x10368f4;\n        }\n        else {\n            var_124h = 0x10368f8;\n        }\n        puVar7 = fcn.01016db0(arg_8h, &var_f8h, uVar3, uVar8, uVar1, var_124h, 1);\n        arg_10h = *puVar7;\n        arg_14h = puVar7[1];\n        uVar2 = puVar7[2];\n        arg_24h = arg_24h + var_7ch;\n        arg_34h = arg_34h - var_7ch;\n        arg_18h = uVar2;\n    }\n    puVar7 = fcn.01016e20(arg_8h, &var_104h, arg_10h, arg_14h, arg_18h, arg_24h, arg_34h, uVar2 & 0xffffff00 | var_25h);\n    puVar7 = fcn.01016b70(arg_8h, &var_110h, *puVar7, puVar7[1], puVar7[2], puVar7[1] & 0xffffff00 | var_15h, arg_30h);\n    uVar3 = *puVar7;\n    uVar8 = puVar7[1];\n    uVar1 = puVar7[2];\n    fcn.01014b20(0);\n    fcn.01016b70(arg_8h, arg_ch, uVar3, uVar8, uVar1, extraout_EDX & 0xffffff00 | arg_20h & 0xff, var_2ch);\n    var_4h = CONCAT31(var_4h._1_3_, 1);\n    fcn.01013190();\n    var_4h = 0xffffffff;\n    fcn.01013190();\n    *in_FS_OFFSET = var_ch;\n    fcn.01019b44(in_stack_fffffe90);\n    return;\n}\n",
        "token_count": 3183
    },
    "01016b10": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.01016b10(uint noname_0, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint8_t *arg_1ch, int32_t arg_20h)\n\n{\n    uint32_t in_EAX;\n    uint32_t arg_8h;\n    \n    while (arg_20h != 0) {\n        arg_8h = in_EAX & 0xffffff00 | *arg_1ch;\n        fcn.01016f90();\n        fcn.01016f30(arg_8h);\n        arg_20h = arg_20h + -1;\n        in_EAX = fcn.01016f90();\n        arg_1ch = arg_1ch + 1;\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    arg_ch[2] = arg_18h;\n    return arg_ch;\n}\n",
        "token_count": 215
    },
    "01016b70": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.01016b70(uint noname_0, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint32_t arg_1ch, int32_t arg_20h)\n\n{\n    uint32_t in_ECX;\n    uint32_t extraout_ECX;\n    uint32_t arg_8h;\n    \n    while (arg_20h != 0) {\n        arg_8h = in_ECX & 0xffffff00 | arg_1ch & 0xff;\n        fcn.01016f90();\n        fcn.01016f30(arg_8h);\n        arg_20h = arg_20h + -1;\n        fcn.01016f90();\n        in_ECX = extraout_ECX;\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    arg_ch[2] = arg_18h;\n    return arg_ch;\n}\n",
        "token_count": 218
    },
    "01016c40": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01016c40(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t arg_8h_00;\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*0x1036860 - *(in_ECX + 0x14) <= arg_8h) {\n        fcn.01018c2e();\n    }\n    if (arg_8h != 0) {\n        arg_8h_00 = *(in_ECX + 0x14) + arg_8h;\n        uVar1 = fcn.01014280(arg_8h_00, 0);\n        if ((uVar1 & 0xff) != 0) {\n            fcn.01017020(*(in_ECX + 0x14), arg_8h, uVar1 & 0xffffff00 | arg_ch & 0xff);\n            fcn.01014230(arg_8h_00);\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 244
    },
    "01016cc0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01016cc0(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    int32_t arg_14h;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t in_ECX;\n    int32_t arg_8h_00;\n    int32_t arg_ch_00;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x14) < arg_8h) {\n        fcn.01018cbf();\n    }\n    if (*0x1036860 - *(in_ECX + 0x14) <= arg_ch) {\n        fcn.01018c2e();\n    }\n    if (arg_ch != 0) {\n        arg_8h_00 = *(in_ECX + 0x14) + arg_ch;\n        cVar1 = fcn.01014280(arg_8h_00, 0);\n        if (cVar1 != '\\0') {\n            arg_14h = *(in_ECX + 0x14) - arg_8h;\n            iVar2 = fcn.01014320();\n            iVar2 = iVar2 + arg_8h;\n            arg_ch_00 = (*(in_ECX + 0x18) - arg_8h) - arg_ch;\n            iVar3 = fcn.01014320();\n            uVar4 = fcn.01014e60(iVar3 + arg_8h + arg_ch, arg_ch_00, iVar2, arg_14h);\n            fcn.01017020(arg_8h, arg_ch, uVar4 & 0xffffff00 | arg_10h & 0xff);\n            fcn.01014230(arg_8h_00);\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 423
    },
    "01016db0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.01016db0(int32_t arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint8_t *arg_1ch, int32_t arg_20h)\n\n{\n    uint arg_8h_00;\n    uint8_t *in_ECX;\n    int32_t iVar1;\n    \n    while (arg_20h != 0) {\n        iVar1 = arg_8h + 8;\n        arg_8h_00 = fcn.01017180(in_ECX & 0xffffff00 | *arg_1ch);\n        fcn.01016f90(iVar1);\n        fcn.01016f30(arg_8h_00);\n        arg_20h = arg_20h + -1;\n        fcn.01016f90();\n        in_ECX = arg_1ch + 1;\n        arg_1ch = in_ECX;\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    arg_ch[2] = arg_18h;\n    return arg_ch;\n}\n",
        "token_count": 255
    },
    "01016e20": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __cdecl\nfcn.01016e20(uint arg_8h, uint *arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, int32_t arg_20h, \n            uint arg_24h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t var_24h;\n    uint var_20h;\n    uint var_14h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    while( true ) {\n        var_4h = fcn.0101b1f0(arg_1ch, 0, arg_20h);\n        if (var_4h == 0) {\n            var_24h = arg_20h;\n        }\n        else {\n            var_24h = var_4h - arg_1ch;\n        }\n        var_8h = var_24h;\n        puVar1 = fcn.01016db0(arg_8h, &var_14h, arg_10h, arg_14h, arg_18h, arg_1ch, var_24h);\n        arg_10h = *puVar1;\n        arg_14h = puVar1[1];\n        arg_18h = puVar1[2];\n        uVar2 = arg_1ch + var_8h;\n        arg_20h = arg_20h - var_8h;\n        if (arg_20h == 0) break;\n        if (arg_24h != 0) {\n            puVar1 = fcn.01016b70(arg_8h, &var_20h, arg_10h, arg_14h, arg_18h, uVar2 & 0xffffff00 | arg_24h, 1);\n            arg_10h = *puVar1;\n            arg_14h = puVar1[1];\n            arg_18h = puVar1[2];\n        }\n        arg_1ch = uVar2 + 1;\n        arg_20h = arg_20h + -1;\n    }\n    *arg_ch = arg_10h;\n    arg_ch[1] = arg_14h;\n    arg_ch[2] = arg_18h;\n    return arg_ch;\n}\n",
        "token_count": 514
    },
    "01016f30": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.01016f30(uint32_t arg_8h)\n\n{\n    char cVar1;\n    uint32_t in_ECX;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (*(in_ECX + 8) != 0) {\n        var_4h = fcn.01014b50(in_ECX & 0xffffff00 | arg_8h & 0xff);\n        var_8h = fcn.01014af0();\n        cVar1 = fcn.01014ad0(&var_8h, &var_4h);\n        if (cVar1 == '\\0') {\n            return in_ECX;\n        }\n    }\n    *(in_ECX + 4) = 1;\n    return in_ECX;\n}\n",
        "token_count": 181
    },
    "01017090": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01017090(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t *in_FS_OFFSET;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c1a8;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.01018b25(0, uVar1);\n    var_4h = 0;\n    var_1ch = *0x10da124;\n    var_14h = fcn.01014d30();\n    var_10h = fcn.01014da0(var_14h);\n    if (var_10h == 0) {\n        if (var_1ch == 0) {\n            iVar2 = fcn.01017190(&var_1ch);\n            if (iVar2 == -1) {\n                fcn.0101aff9(\"bad cast\");\n                fcn.0101ae78(&var_2ch, 0x10398c0);\n            }\n            else {\n                var_10h = var_1ch;\n                *0x10da124 = var_1ch;\n                var_20h = var_1ch;\n                fcn.01013490();\n                fcn.01014d80();\n            }\n        }\n        else {\n            var_10h = var_1ch;\n        }\n    }\n    iVar2 = var_10h;\n    var_4h = 0xffffffff;\n    fcn.01018b46();\n    *in_FS_OFFSET = var_ch;\n    return iVar2;\n}\n",
        "token_count": 455
    },
    "01017190": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.01017190(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c1db;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if ((arg_8h != NULL) && (*arg_8h == 0)) {\n        iVar1 = fcn.0101b091(0x18);\n        var_4h = 0;\n        if (iVar1 == 0) {\n            var_18h = 0;\n        }\n        else {\n            var_18h = fcn.01017220(0);\n        }\n        *arg_8h = var_18h;\n    }\n    *in_FS_OFFSET = var_ch;\n    return 4;\n}\n",
        "token_count": 238
    },
    "01017790": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.01017790(uchar *arg_8h)\n\n{\n    uchar *puVar1;\n    uint var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_8h = fcn.010196c0(arg_8h);\n    var_8h = var_8h + 1;\n    puVar1 = fcn.01017818(var_8h);\n    var_ch = puVar1;\n    for (; var_8h != 0; var_8h = var_8h + -1) {\n        *var_ch = *arg_8h;\n        var_ch = var_ch + 1;\n        arg_8h = arg_8h + 1;\n    }\n    return puVar1;\n}\n",
        "token_count": 182
    },
    "01018761": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.01018761(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0101b84a(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    *(unaff_EBP + -4) = 0;\n    if (*(extraout_ECX + 0x12) != '\\0') {\n        fcn.010184c6();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.010179ab();\n    fcn.0101b8e9();\n    return;\n}\n",
        "token_count": 179
    },
    "0101afd6": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0101afd6(code **param_1)\n\n{\n    *param_1 = vtable.std::exception.0;\n    if (param_1[2] != NULL) {\n        fcn.01019966(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 64
    },
    "01019b44": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.01019b44(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x103c470) {\n        return;\n    }\n    *0x10daa58 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                 (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                 ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                 (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x10daa5c = &arg_8h;\n    *0x10da998 = 0x10001;\n    *0x10da940 = 0xc0000409;\n    *0x10da944 = 1;\n    var_328h = *0x103c470;\n    var_324h = *0x103c474;\n    *0x10da94c = unaff_retaddr;\n    *0x10daa24 = in_GS;\n    *0x10daa28 = in_FS;\n    *0x10daa2c = in_ES;\n    *0x10daa30 = in_DS;\n    *0x10daa34 = unaff_EDI;\n    *0x10daa38 = unaff_ESI;\n    *0x10daa3c = unaff_EBX;\n    *0x10daa40 = in_EDX;\n    *0x10daa44 = in_ECX;\n    *0x10daa48 = in_EAX;\n    *0x10daa4c = unaff_EBP;\n    *0x10daa50 = unaff_retaddr;\n    *0x10daa54 = in_CS;\n    *0x10daa60 = in_SS;\n    *0x10da990 = (*_sym.imp.KERNEL32.dll_IsDebuggerPresent)();\n    fcn.01024895(1);\n    (*_sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter)(0);\n    (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(0x1037a64);\n    if (*0x10da990 == 0) {\n        fcn.01024895(1);\n    }\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(0xc0000409);\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    return;\n}\n",
        "token_count": 846
    },
    "0101aba0": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0101aba0(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x101ac49;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.0101ac75;\n        uStack36 = *0x103c470 ^ &fcn.0101aba0::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.0101aba0::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.0101eca3();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.0101aba0::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 723
    },
    "01019966": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01019966(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x1039f68, 0xc);\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 != 0) {\n        if (*0x10db018 == 3) {\n            fcn.0101f296(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.0101f438(iVar1);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.0101f463(arg_8h_00, iVar1);\n            }\n            *(unaff_EBP + -4) = 0xfffffffe;\n            fcn.010199bc();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x010199ee;\n            iVar1 = *(unaff_EBP + 8);\n        }\n        iVar1 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x10da5d8, 0, iVar1);\n        if (iVar1 == 0) {\n            puVar2 = fcn.0101d3b6();\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            uVar3 = fcn.0101d37b(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\ncode_r0x010199ee:\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 432
    },
    "0101c7ab": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0101c7ab(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a188, 0x10);\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar2 = *(unaff_EBP + 8);\n    if (*(iVar1 + 4) < 0x81) {\n        iVar5 = *(iVar2 + 8);\n    }\n    else {\n        iVar5 = *(iVar2 + 8);\n    }\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar3 = fcn.0101eca3();\n    *(iVar3 + 0x90) = *(iVar3 + 0x90) + 1;\n    *(unaff_EBP + -4) = 0;\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar1 + 4) <= iVar5)) {\n            fcn.0102355c();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar1 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar2 + 8) = iVar5;\n            fcn.010235b0(*(*(iVar1 + 8) + 4 + iVar3), iVar2, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0101c871();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.0102355c();\n    }\n    *(iVar2 + 8) = iVar5;\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 568
    },
    "0101c871": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0101c871(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0101eca3();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.0101eca3();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "0101cb45": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0101cb45(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.0101adce(*(unaff_EBP + -0x28));\n    iVar1 = fcn.0101eca3();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.0101eca3();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.0101adad(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.0101c8d1(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 384
    },
    "01020294": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x01020329: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x0102032e)\n// WARNING: Removing unreachable block (ram,0x0102035c)\n// WARNING: Removing unreachable block (ram,0x01020334)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01020294(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a370, 0xc);\n    fcn.0101f296(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x10da624 != 1) {\n        *0x10da620 = 1;\n        *0x10da61c = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            uVar1 = fcn.0101ea99(*0x10daff4);\n            uVar2 = fcn.0101ea99(*0x10daff0);\n            *(unaff_EBP + -0x1c) = uVar2;\n            if (uVar1 != 0) {\n                while (*(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + -4,  uVar1 <= *(unaff_EBP + -0x1c)) {\n                    if (**(unaff_EBP + -0x1c) != NULL) {\n                        (***(unaff_EBP + -0x1c))();\n                    }\n                }\n            }\n            fcn.01020157(0x102d224);\n        }\n        fcn.01020157(0x102d230);\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.0101f1be(8);\n    }\n    return;\n}\n",
        "token_count": 494
    },
    "01026d48": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.01026d48(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.0101f1be(0);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "01027148": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.01027148(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code *pcVar4;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_10h = fcn.0101ea90();\n    var_4h = 0;\n    var_8h = 0;\n    var_ch = 0;\n    if (*0x10dadb4 == 0) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"USER32.DLL\");\n        pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar1 == 0) || (iVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"MessageBoxA\"),  iVar2 == 0)) {\n            return 0;\n        }\n        *0x10dadb4 = fcn.0101ea2d(iVar2);\n        uVar3 = (*pcVar4)(iVar1, \"GetActiveWindow\");\n        *0x10dadb8 = fcn.0101ea2d(uVar3);\n        uVar3 = (*pcVar4)(iVar1, \"GetLastActivePopup\");\n        *0x10dadbc = fcn.0101ea2d(uVar3);\n        iVar2 = fcn.0102018f(&var_8h);\n        if (iVar2 != 0) {\n            fcn.0101b328(0, 0, 0, 0, 0);\n        }\n        if (var_8h == 2) {\n            uVar3 = (*pcVar4)(iVar1, \"GetUserObjectInformationA\");\n            *0x10dadc4 = fcn.0101ea2d(uVar3);\n            if (*0x10dadc4 != 0) {\n                uVar3 = (*pcVar4)(iVar1, \"GetProcessWindowStation\");\n                *0x10dadc0 = fcn.0101ea2d(uVar3);\n            }\n        }\n    }\n    iVar1 = var_10h;\n    if ((*0x10dadc0 == var_10h) || (*0x10dadc4 == var_10h)) {\ncode_r0x01027296:\n        if (*0x10dadb8 != iVar1) {\n            pcVar4 = fcn.0101ea99(*0x10dadb8);\n            var_4h = (*pcVar4)();\n            if ((var_4h != 0) && (*0x10dadbc != iVar1)) {\n                pcVar4 = fcn.0101ea99(*0x10dadbc, var_4h);\n                var_4h = (*pcVar4)();\n            }\n        }\n    }\n    else {\n        pcVar4 = fcn.0101ea99(*0x10dadc0);\n        iVar2 = (*pcVar4)();\n        if (iVar2 != 0) {\n            pcVar4 = fcn.0101ea99(*0x10dadc4, iVar2, 1, &var_20h, 0xc, &var_14h);\n            iVar2 = (*pcVar4)();\n            if ((iVar2 != 0) && ((var_18h & 1) != 0)) goto code_r0x01027296;\n        }\n        iVar1 = fcn.010201c6(&var_ch);\n        if (iVar1 != 0) {\n            fcn.0101b328(0, 0, 0, 0, 0);\n        }\n        if (var_ch < 4) {\n            arg_10h = arg_10h | 0x40000;\n        }\n        else {\n            arg_10h = arg_10h | 0x200000;\n        }\n    }\n    pcVar4 = fcn.0101ea99(*0x10dadb4, var_4h, arg_8h, arg_ch, arg_10h);\n    uVar3 = (*pcVar4)();\n    return uVar3;\n}\n",
        "token_count": 963
    },
    "010286ab": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.010286ab(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x103c470 ^ &stack0xfffffffc;\n    fcn.010194af(arg_10h);\n    var_14h = fcn.0102a705(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.01029c81(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x01028702:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x01028742;\n        }\n        if (iVar1 != 2) {\ncode_r0x01028734:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x01028742;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x01028734;\n        goto code_r0x01028702;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x01028742:\n    fcn.01019b44(unaff_EBX);\n    return;\n}\n",
        "token_count": 494
    },
    "01028751": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.01028751(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint var_28h;\n    uint var_24h;\n    int32_t var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint var_10h;\n    uint32_t var_4h;\n    \n    var_4h = *0x103c470 ^ &stack0xfffffffc;\n    fcn.010194af(arg_10h);\n    var_14h = fcn.0102a705(&var_10h, &var_28h, arg_ch, 0, 0, 0, 0, &var_24h);\n    iVar1 = fcn.0102a1c3(&var_10h, arg_8h);\n    if ((var_14h & 3) == 0) {\n        if (iVar1 == 1) {\ncode_r0x010287a8:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x010287e8;\n        }\n        if (iVar1 != 2) {\ncode_r0x010287da:\n            if (var_18h != '\\0') {\n                *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n            }\n            goto code_r0x010287e8;\n        }\n    }\n    else if ((var_14h & 1) == 0) {\n        if ((var_14h & 2) == 0) goto code_r0x010287da;\n        goto code_r0x010287a8;\n    }\n    if (var_18h != '\\0') {\n        *(var_1ch + 0x70) = *(var_1ch + 0x70) & 0xfffffffd;\n    }\ncode_r0x010287e8:\n    fcn.01019b44(unaff_EBX);\n    return;\n}\n",
        "token_count": 501
    },
    "01029c81": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.01029c81(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0102a180;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = str.5_v_[0] + L'\\xffffffff';\n        iVar4 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n        uVar9 = str.5_v_[0] & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x01029db4;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x01029dbb;\ncode_r0x01029db4:\n                        do {\n                            var_4h = 1;\ncode_r0x01029dbb:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x01029dc9;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x01029dc9:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x103d524 - str.5_v_[0]) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x103d524 < iVar12) {\n                if (iVar12 < *0x103d520) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + str.5_v_[3];\n                    iVar4 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = str.5_v_[1] + (str.5_v_[1] >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = str.5_v_[1] & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = str.5_v_[3] + *0x103d520;\n                    uVar5 = 1;\n                }\n                goto code_r0x0102a180;\n            }\n            var_10h = *0x103d524 - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = str.5_v_[0] + L'\\xffffffff';\n            iVar12 = str.5_v_[0] + (str.5_v_[0] >> 0x1f & 0x1fU) >> 5;\n            uVar10 = str.5_v_[0] & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x01029f6c;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x01029f6c:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = str.5_v_[1] + L'\\x01';\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0102a180:\n    var_20h = iVar12 << (0x1fU - str.5_v_[1] & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (str.5_v_[2] == L'@') {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (str.5_v_[2] == L' ') {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3666
    },
    "0102a1c3": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0102a1c3(uint16_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    bool bVar14;\n    uint var_2ch;\n    uint32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = arg_8h[5] & 0x8000;\n    uVar10 = *(arg_8h + 3);\n    var_20h = uVar10;\n    uVar3 = *(arg_8h + 1);\n    uVar2 = *arg_8h;\n    uVar11 = arg_8h[5] & 0x7fff;\n    iVar12 = uVar11 - 0x3fff;\n    var_1ch = uVar3;\n    var_18h = uVar2 << 0x10;\n    if (iVar12 == -0x3fff) {\n        iVar12 = 0;\n        iVar4 = 0;\n        do {\n            if ((&var_20h)[iVar4] != 0) {\n                var_20h = 0;\n                var_1ch = 0;\n                uVar5 = 2;\n                goto code_r0x0102a6c2;\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < 3);\n        uVar5 = 0;\n    }\n    else {\n        arg_8h = NULL;\n        iVar13 = *0x103d540 - 1;\n        iVar4 = *0x103d540 + (*0x103d540 >> 0x1f & 0x1fU) >> 5;\n        uVar9 = *0x103d540 & 0x8000001f;\n        var_10h = iVar12;\n        var_ch = iVar4;\n        if (uVar9 < 0) {\n            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;\n        }\n        puVar1 = &var_20h + iVar4;\n        uVar6 = 0x1f - uVar9;\n        var_8h = 0x1f - uVar9;\n        if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n            uVar9 = (&var_20h)[iVar4] & ~(-1 << (uVar6 & 0x1f));\n            while( true ) {\n                if (uVar9 != 0) {\n                    iVar4 = iVar13 + (iVar13 >> 0x1f & 0x1fU) >> 5;\n                    var_4h = 0;\n                    uVar9 = 1 << (0x1f - (iVar13 & 0x1f) & 0x1f);\n                    puVar7 = &var_20h + iVar4;\n                    arg_8h = *puVar7 + uVar9;\n                    if (arg_8h < *puVar7) goto code_r0x0102a2f6;\n                    bVar14 = arg_8h < uVar9;\n                    do {\n                        var_4h = 0;\n                        if (!bVar14) goto code_r0x0102a2fd;\ncode_r0x0102a2f6:\n                        do {\n                            var_4h = 1;\ncode_r0x0102a2fd:\n                            iVar4 = iVar4 + -1;\n                            *puVar7 = arg_8h;\n                            if ((iVar4 < 0) || (var_4h == 0)) {\n                                arg_8h = var_4h;\n                                goto code_r0x0102a30b;\n                            }\n                            var_4h = 0;\n                            puVar7 = &var_20h + iVar4;\n                            arg_8h = *puVar7 + 1;\n                        } while (arg_8h < *puVar7);\n                        bVar14 = arg_8h == NULL;\n                    } while( true );\n                }\n                iVar4 = iVar4 + 1;\n                if (2 < iVar4) break;\n                uVar9 = (&var_20h)[iVar4];\n            }\n        }\ncode_r0x0102a30b:\n        *puVar1 = *puVar1 & -1 << (var_8h & 0x1f);\n        iVar4 = var_ch + 1;\n        if (iVar4 < 3) {\n            puVar8 = &var_20h + iVar4;\n            for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {\n                *puVar8 = 0;\n                puVar8 = puVar8 + 1;\n            }\n        }\n        if (arg_8h != NULL) {\n            iVar12 = uVar11 - 0x3ffe;\n        }\n        if (iVar12 < *0x103d53c - *0x103d540) {\n            var_20h = 0;\n            var_1ch = 0;\n        }\n        else {\n            if (*0x103d53c < iVar12) {\n                if (iVar12 < *0x103d538) {\n                    var_20h = var_20h & 0x7fffffff;\n                    iVar12 = iVar12 + *0x103d54c;\n                    iVar4 = *0x103d544 + (*0x103d544 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x103d544 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        var_10h = (&var_20h)[arg_8h] & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = (&var_20h)[arg_8h] >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar13 = 2;\n                    puVar8 = &var_18h + -iVar4;\n                    do {\n                        if (iVar13 < iVar4) {\n                            (&var_20h)[iVar13] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar13] = *puVar8;\n                        }\n                        iVar13 = iVar13 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar13);\n                    uVar5 = 0;\n                }\n                else {\n                    var_1ch = 0;\n                    var_18h = 0;\n                    var_20h = 0x80000000;\n                    iVar12 = *0x103d544 + (*0x103d544 >> 0x1f & 0x1fU) >> 5;\n                    uVar10 = *0x103d544 & 0x8000001f;\n                    if (uVar10 < 0) {\n                        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n                    }\n                    var_ch = 0;\n                    arg_8h = NULL;\n                    var_4h = 0x20 - uVar10;\n                    do {\n                        uVar3 = (&var_20h)[arg_8h];\n                        var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                        (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                        arg_8h = arg_8h + 1;\n                        var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n                    } while (arg_8h < 3);\n                    iVar4 = 2;\n                    puVar8 = &var_18h + -iVar12;\n                    do {\n                        if (iVar4 < iVar12) {\n                            (&var_20h)[iVar4] = 0;\n                        }\n                        else {\n                            (&var_20h)[iVar4] = *puVar8;\n                        }\n                        iVar4 = iVar4 + -1;\n                        puVar8 = puVar8 + -1;\n                    } while (-1 < iVar4);\n                    iVar12 = *0x103d54c + *0x103d538;\n                    uVar5 = 1;\n                }\n                goto code_r0x0102a6c2;\n            }\n            var_10h = *0x103d53c - var_10h;\n            var_20h = uVar10;\n            var_1ch = uVar3;\n            iVar12 = var_10h + (var_10h >> 0x1f & 0x1fU) >> 5;\n            uVar10 = var_10h & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n            iVar4 = *0x103d540 - 1;\n            iVar12 = *0x103d540 + (*0x103d540 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = *0x103d540 & 0x8000001f;\n            var_ch = iVar12;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            uVar6 = 0x1f - uVar10;\n            puVar1 = &var_20h + iVar12;\n            var_10h = 0x1f - uVar10;\n            if ((*puVar1 & 1 << (uVar6 & 0x1f)) != 0) {\n                uVar10 = (&var_20h)[iVar12] & ~(-1 << (uVar6 & 0x1f));\n                while (uVar10 == 0) {\n                    iVar12 = iVar12 + 1;\n                    if (2 < iVar12) goto code_r0x0102a4ae;\n                    uVar10 = (&var_20h)[iVar12];\n                }\n                iVar12 = iVar4 + (iVar4 >> 0x1f & 0x1fU) >> 5;\n                bVar14 = false;\n                uVar11 = 1 << (0x1f - (iVar4 & 0x1f) & 0x1f);\n                uVar3 = (&var_20h)[iVar12];\n                uVar10 = uVar3 + uVar11;\n                if ((uVar10 < uVar3) || (uVar10 < uVar11)) {\n                    bVar14 = true;\n                }\n                (&var_20h)[iVar12] = uVar10;\n                while ((iVar12 = iVar12 + -1,  -1 < iVar12 && (bVar14))) {\n                    uVar3 = (&var_20h)[iVar12];\n                    uVar10 = uVar3 + 1;\n                    bVar14 = false;\n                    if ((uVar10 < uVar3) || (uVar10 == 0)) {\n                        bVar14 = true;\n                    }\n                    (&var_20h)[iVar12] = uVar10;\n                }\n            }\ncode_r0x0102a4ae:\n            *puVar1 = *puVar1 & -1 << (var_10h & 0x1f);\n            iVar12 = var_ch + 1;\n            if (iVar12 < 3) {\n                puVar8 = &var_20h + iVar12;\n                for (iVar4 = 3 - iVar12; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar8 = 0;\n                    puVar8 = puVar8 + 1;\n                }\n            }\n            uVar10 = *0x103d544 + 1;\n            iVar12 = uVar10 + (uVar10 >> 0x1f & 0x1fU) >> 5;\n            uVar10 = uVar10 & 0x8000001f;\n            if (uVar10 < 0) {\n                uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;\n            }\n            var_ch = 0;\n            arg_8h = NULL;\n            var_4h = 0x20 - uVar10;\n            do {\n                uVar3 = (&var_20h)[arg_8h];\n                var_10h = uVar3 & ~(-1 << (uVar10 & 0x1f));\n                (&var_20h)[arg_8h] = uVar3 >> (uVar10 & 0x1f) | var_ch;\n                arg_8h = arg_8h + 1;\n                var_ch = var_10h << (0x20 - uVar10 & 0x1f);\n            } while (arg_8h < 3);\n            iVar4 = 2;\n            puVar8 = &var_18h + -iVar12;\n            do {\n                if (iVar4 < iVar12) {\n                    (&var_20h)[iVar4] = 0;\n                }\n                else {\n                    (&var_20h)[iVar4] = *puVar8;\n                }\n                iVar4 = iVar4 + -1;\n                puVar8 = puVar8 + -1;\n            } while (-1 < iVar4);\n        }\n        iVar12 = 0;\n        uVar5 = 2;\n    }\ncode_r0x0102a6c2:\n    var_20h = iVar12 << (0x1fU - *0x103d544 & 0x1f) | -(var_14h != 0) & 0x80000000 | var_20h;\n    if (*0x103d548 == 0x40) {\n        arg_ch[1] = var_20h;\n        *arg_ch = var_1ch;\n    }\n    else if (*0x103d548 == 0x20) {\n        *arg_ch = var_20h;\n    }\n    return uVar5;\n}\n",
        "token_count": 3661
    },
    "0102a705": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0102a9c5)\n// WARNING: Removing unreachable block (ram,0x0102a98e)\n// WARNING: Removing unreachable block (ram,0x0102ad42)\n// WARNING: Removing unreachable block (ram,0x0102a99d)\n// WARNING: Removing unreachable block (ram,0x0102a9a5)\n// WARNING: Removing unreachable block (ram,0x0102a9ab)\n// WARNING: Removing unreachable block (ram,0x0102a9ae)\n// WARNING: Removing unreachable block (ram,0x0102a9b5)\n// WARNING: Removing unreachable block (ram,0x0102a9bf)\n// WARNING: Removing unreachable block (ram,0x0102aa1a)\n// WARNING: Removing unreachable block (ram,0x0102aa14)\n// WARNING: Removing unreachable block (ram,0x0102aa20)\n// WARNING: Removing unreachable block (ram,0x0102aa3d)\n// WARNING: Removing unreachable block (ram,0x0102aa3f)\n// WARNING: Removing unreachable block (ram,0x0102aa47)\n// WARNING: Removing unreachable block (ram,0x0102aa4a)\n// WARNING: Removing unreachable block (ram,0x0102aa4f)\n// WARNING: Removing unreachable block (ram,0x0102aa52)\n// WARNING: Removing unreachable block (ram,0x0102ad4b)\n// WARNING: Removing unreachable block (ram,0x0102aa5d)\n// WARNING: Removing unreachable block (ram,0x0102ad62)\n// WARNING: Removing unreachable block (ram,0x0102ad69)\n// WARNING: Removing unreachable block (ram,0x0102aa68)\n// WARNING: Removing unreachable block (ram,0x0102aa7b)\n// WARNING: Removing unreachable block (ram,0x0102aa7d)\n// WARNING: Removing unreachable block (ram,0x0102aa8a)\n// WARNING: Removing unreachable block (ram,0x0102aa8f)\n// WARNING: Removing unreachable block (ram,0x0102aa93)\n// WARNING: Removing unreachable block (ram,0x0102aa9c)\n// WARNING: Removing unreachable block (ram,0x0102aab4)\n// WARNING: Removing unreachable block (ram,0x0102aac5)\n// WARNING: Removing unreachable block (ram,0x0102aad9)\n// WARNING: Removing unreachable block (ram,0x0102ab11)\n// WARNING: Removing unreachable block (ram,0x0102ab1c)\n// WARNING: Removing unreachable block (ram,0x0102ab27)\n// WARNING: Removing unreachable block (ram,0x0102ab2e)\n// WARNING: Removing unreachable block (ram,0x0102ab3b)\n// WARNING: Removing unreachable block (ram,0x0102ab40)\n// WARNING: Removing unreachable block (ram,0x0102ab4a)\n// WARNING: Removing unreachable block (ram,0x0102ab50)\n// WARNING: Removing unreachable block (ram,0x0102ab5f)\n// WARNING: Removing unreachable block (ram,0x0102ab66)\n// WARNING: Removing unreachable block (ram,0x0102ab70)\n// WARNING: Removing unreachable block (ram,0x0102ab75)\n// WARNING: Removing unreachable block (ram,0x0102ab87)\n// WARNING: Removing unreachable block (ram,0x0102ab94)\n// WARNING: Removing unreachable block (ram,0x0102aba3)\n// WARNING: Removing unreachable block (ram,0x0102abb0)\n// WARNING: Removing unreachable block (ram,0x0102abcd)\n// WARNING: Removing unreachable block (ram,0x0102abd1)\n// WARNING: Removing unreachable block (ram,0x0102abd8)\n// WARNING: Removing unreachable block (ram,0x0102abe1)\n// WARNING: Removing unreachable block (ram,0x0102abe4)\n// WARNING: Removing unreachable block (ram,0x0102abf5)\n// WARNING: Removing unreachable block (ram,0x0102abf8)\n// WARNING: Removing unreachable block (ram,0x0102ac06)\n// WARNING: Removing unreachable block (ram,0x0102ac11)\n// WARNING: Removing unreachable block (ram,0x0102ac1a)\n// WARNING: Removing unreachable block (ram,0x0102ac47)\n// WARNING: Removing unreachable block (ram,0x0102ac4c)\n// WARNING: Removing unreachable block (ram,0x0102ac57)\n// WARNING: Removing unreachable block (ram,0x0102ac60)\n// WARNING: Removing unreachable block (ram,0x0102ac66)\n// WARNING: Removing unreachable block (ram,0x0102ac69)\n// WARNING: Removing unreachable block (ram,0x0102ac8f)\n// WARNING: Removing unreachable block (ram,0x0102ac95)\n// WARNING: Removing unreachable block (ram,0x0102ac9a)\n// WARNING: Removing unreachable block (ram,0x0102aca2)\n// WARNING: Removing unreachable block (ram,0x0102acb3)\n// WARNING: Removing unreachable block (ram,0x0102ace3)\n// WARNING: Removing unreachable block (ram,0x0102acb9)\n// WARNING: Removing unreachable block (ram,0x0102acde)\n// WARNING: Removing unreachable block (ram,0x0102acc3)\n// WARNING: Removing unreachable block (ram,0x0102acd8)\n// WARNING: Removing unreachable block (ram,0x0102accf)\n// WARNING: Removing unreachable block (ram,0x0102ace6)\n// WARNING: Removing unreachable block (ram,0x0102ad0c)\n// WARNING: Removing unreachable block (ram,0x0102ad23)\n// WARNING: Removing unreachable block (ram,0x0102acf0)\n// WARNING: Removing unreachable block (ram,0x0102ab79)\n// WARNING: Removing unreachable block (ram,0x0102ab56)\n// WARNING: Removing unreachable block (ram,0x0102ad26)\n// WARNING: Removing unreachable block (ram,0x0102ad30)\n// WARNING: Removing unreachable block (ram,0x0102ad71)\n// WARNING: Variable defined which should be unmapped: var_7ch\n\nvoid __cdecl\nfcn.0102a705(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            int32_t arg_24h)\n\n{\n    char cVar1;\n    uint *puVar2;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_9h;\n    uint var_4h;\n    \n    if (arg_24h == 0) {\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 0x16;\n        fcn.0101b424(0, 0, 0, 0, 0);\n        fcn.01019b44(arg_8h);\n        return;\n    }\n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x0102a796. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x102ad99\n    (**0x102ad99)();\n    return;\n}\n",
        "token_count": 1831
    },
    "01013850": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.01013850(uint32_t arg_8h, uint arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_dch;\n    uint var_d8h;\n    uint var_bch;\n    uint var_94h;\n    uint var_78h;\n    uint var_50h;\n    uint var_34h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102beee;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    *(in_ECX + 8) = arg_8h & 0x17;\n    if ((*(in_ECX + 8) & *(in_ECX + 0xc)) != 0) {\n        if (arg_ch == '\\0') {\n            if ((*(in_ECX + 8) & *(in_ECX + 0xc) & 4) == 0) {\n                if ((*(in_ECX + 8) & *(in_ECX + 0xc) & 2) == 0) {\n                    fcn.01013150(\"ios_base::eofbit set\");\n                    var_4h = 2;\n                    fcn.01013ad0(&var_d8h);\n                    fcn.0101ae78(&var_bch, 0x1039674);\n                    var_4h = 0xffffffff;\n                    fcn.01013190();\n                }\n                else {\n                    fcn.01013150(\"ios_base::failbit set\");\n                    var_4h = 1;\n                    fcn.01013ad0(&var_94h);\n                    fcn.0101ae78(&var_78h, 0x1039674);\n                    var_4h = 0xffffffff;\n                    fcn.01013190();\n                }\n            }\n            else {\n                fcn.01013150(\"ios_base::badbit set\");\n                var_4h = 0;\n                fcn.01013ad0(&var_50h);\n                fcn.0101ae78(&var_34h, 0x1039674);\n                var_4h = 0xffffffff;\n                fcn.01013190();\n            }\n        }\n        else {\n            fcn.0101ae78(0, 0);\n        }\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 545
    },
    "01014370": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nvoid fcn.01014370(void)\n\n{\n    uint32_t uVar1;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_ch_2;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x102bf70;\n    var_ch_2 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch_2;\n    var_4h = 0;\n    uVar1 = fcn.010143f0();\n    if ((uVar1 & 2) != 0) {\n        fcn.01013e10();\n    }\n    *in_FS_OFFSET = var_ch_2;\n    return;\n}\n",
        "token_count": 175
    },
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\nuint __cdecl method.std::runtime_error.virtual_0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.01013aa0();\n    if ((arg_8h & 1) != 0) {\n        fcn.0101b073(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 81
    },
    "0101b091": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0101b091(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code *var_ch;\n    \n    do {\n        iVar2 = fcn.01019a43(arg_8h);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.0101f0fe(arg_8h);\n    } while (iVar2 != 0);\n    if ((*0x10da400 & 1) == 0) {\n        *0x10da400 = *0x10da400 | 1;\n        fcn.0101b078();\n        fcn.0101c551(0x102c689);\n    }\n    fcn.0101af7e(0x10da3f4);\n    var_ch = vtable.std::bad_alloc.0;\n    fcn.0101ae78(&var_ch, 0x10398f8);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 232
    },
    "01025a41": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01025a41(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a410, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0101d3c9();\n        *puVar2 = 0;\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x10daed4)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x10daee0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x28;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.010295ef(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0101d3b6();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0101d3c9();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.0102547b(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.01025b13(0x103a410);\n                goto code_r0x01025b0d;\n            }\n        }\n        puVar2 = fcn.0101d3c9();\n        *puVar2 = 0;\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 9;\n        fcn.0101b424(0, 0, 0, 0, 0);\n    }\ncode_r0x01025b0d:\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 647
    },
    "01025e9a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01025e9a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a470, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0101d3c9();\n        *puVar2 = 0;\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x10daed4)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x10daee0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x28;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.010295ef(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0101d3b6();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0101d3c9();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.01025e28(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.01025f6c(0x103a470);\n                goto code_r0x01025f66;\n            }\n        }\n        puVar2 = fcn.0101d3c9();\n        *puVar2 = 0;\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 9;\n        fcn.0101b424(0, 0, 0, 0, 0);\n    }\ncode_r0x01025f66:\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 647
    },
    "01029235": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01029235(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint *puVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a5d0, 0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 == 0xfffffffe) {\n        puVar2 = fcn.0101d3c9();\n        *puVar2 = 0;\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 9;\n    }\n    else {\n        if ((-1 < arg_8h_00) && (arg_8h_00 < *0x10daed4)) {\n            piVar1 = (arg_8h_00 >> 5) * 4 + 0x10daee0;\n            iVar4 = (arg_8h_00 & 0x1f) * 0x28;\n            if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n                fcn.010295ef(arg_8h_00);\n                *(unaff_EBP + -4) = 0;\n                if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                    puVar2 = fcn.0101d3b6();\n                    *puVar2 = 9;\n                    puVar2 = fcn.0101d3c9();\n                    *puVar2 = 0;\n                    *(unaff_EBP + -0x1c) = 0xffffffff;\n                }\n                else {\n                    uVar3 = fcn.01028c93(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                    *(unaff_EBP + -0x1c) = uVar3;\n                }\n                *(unaff_EBP + -4) = 0xfffffffe;\n                fcn.01029307(0x103a5d0);\n                goto code_r0x01029301;\n            }\n        }\n        puVar2 = fcn.0101d3c9();\n        *puVar2 = 0;\n        puVar2 = fcn.0101d3b6();\n        *puVar2 = 9;\n        fcn.0101b424(0, 0, 0, 0, 0);\n    }\ncode_r0x01029301:\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 645
    },
    "01013e10": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __fastcall fcn.01013e10(uint param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    cVar1 = fcn.01013e80();\n    if (cVar1 == '\\0') {\n        fcn.010136c0();\n        iVar2 = fcn.01013ea0();\n        if (iVar2 == -1) {\n            var_4h = 4;\n        }\n    }\n    fcn.01013670(var_4h, 0);\n    return param_1;\n}\n",
        "token_count": 144
    },
    "01017e85": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.01017e85(uint param_1, int32_t param_2)\n\n{\n    char cVar1;\n    uint unaff_retaddr;\n    \n    if (param_2 == -1) {\n        fcn.01018c2e();\n    }\n    cVar1 = fcn.01014280(param_2, 0);\n    if (cVar1 != '\\0') {\n        fcn.01017020(0, param_2, unaff_retaddr);\n        fcn.01014230(param_2);\n    }\n    return param_1;\n}\n",
        "token_count": 130
    },
    "010187b4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.010187b4(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0101b84a(0x14);\n    fcn.01018b25(0);\n    iVar2 = *0x10da134;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar2;\n    arg_8h_00 = fcn.01014d30();\n    iVar1 = fcn.01014da0(arg_8h_00);\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.010186d6(unaff_EBP + -0x10);\n        if (iVar2 == -1) {\n            fcn.0101aff9(\"bad cast\");\n            fcn.0101ae78(unaff_EBP + -0x20, 0x10398c0);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x10da134 = iVar2;\n        fcn.01013490();\n        fcn.01018e83(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.01018b46();\n    fcn.0101b8e9();\n    return;\n}\n",
        "token_count": 403
    },
    "010189c1": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.010189c1(uint arg_8h)\n\n{\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0101b84a(0x14);\n    fcn.01018b25(0);\n    iVar2 = *0x10da138;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = iVar2;\n    arg_8h_00 = fcn.01014d30();\n    iVar1 = fcn.01014da0(arg_8h_00);\n    if ((iVar1 == 0) && (iVar2 == 0)) {\n        iVar2 = fcn.01018932(unaff_EBP + -0x10);\n        if (iVar2 == -1) {\n            fcn.0101aff9(\"bad cast\");\n            fcn.0101ae78(unaff_EBP + -0x20, 0x10398c0);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n        *0x10da138 = iVar2;\n        fcn.01013490();\n        fcn.01018e83(iVar2);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.01018b46();\n    fcn.0101b8e9();\n    return;\n}\n",
        "token_count": 402
    },
    "0101b90c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0101b90c(uint arg_8h)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t **ppuVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a040, 0xc);\n    *(unaff_EBP + -0x1c) = 0;\n    ppuVar2 = *(unaff_EBP + 8);\n    if (ppuVar2 == NULL) {\n        puVar3 = fcn.0101d3b6();\n        *puVar3 = 0x16;\n        fcn.0101b424(0, 0, 0, 0, 0);\n        goto code_r0x0101ba32;\n    }\n    fcn.0101c63a(ppuVar2);\n    *(unaff_EBP + -4) = 0;\n    if ((*(ppuVar2 + 3) & 0x40) == 0) {\n        iVar4 = fcn.0102540a(ppuVar2);\n        if (iVar4 == -1) {\ncode_r0x0101b999:\n            iVar4 = 0x103d230;\n        }\n        else {\n            iVar4 = fcn.0102540a(ppuVar2);\n            if (iVar4 == -2) goto code_r0x0101b999;\n            iVar4 = fcn.0102540a(ppuVar2);\n            uVar5 = fcn.0102540a(ppuVar2);\n            iVar4 = (uVar5 & 0x1f) * 0x28 + *((iVar4 >> 5) * 4 + 0x10daee0);\n        }\n        if ((*(iVar4 + 0x24) & 0x7f) == 0) {\n            iVar4 = fcn.0102540a(ppuVar2);\n            if (iVar4 == -1) {\ncode_r0x0101b9de:\n                iVar4 = 0x103d230;\n            }\n            else {\n                iVar4 = fcn.0102540a(ppuVar2);\n                if (iVar4 == -2) goto code_r0x0101b9de;\n                iVar4 = fcn.0102540a(ppuVar2);\n                uVar5 = fcn.0102540a(ppuVar2);\n                iVar4 = (uVar5 & 0x1f) * 0x28 + *((iVar4 >> 5) * 4 + 0x10daee0);\n            }\n            if ((*(iVar4 + 0x24) & 0x80) == 0) goto code_r0x0101ba05;\n        }\n        puVar3 = fcn.0101d3b6();\n        *puVar3 = 0x16;\n        fcn.0101b424(0, 0, 0, 0, 0);\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x0101ba05:\n    if (*(unaff_EBP + -0x1c) == 0) {\n        ppuVar1 = ppuVar2 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar5 = fcn.010252ea(ppuVar2);\n        }\n        else {\n            uVar5 = **ppuVar2;\n            *ppuVar2 = *ppuVar2 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar5;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0101ba3b();\ncode_r0x0101ba32:\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 915
    },
    "0101ba43": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0101ba43(uint arg_8h, uint arg_ch)\n\n{\n    uint8_t **ppuVar1;\n    uint8_t uVar2;\n    uint8_t **arg_ch_00;\n    uint *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a060, 0xc);\n    *(unaff_EBP + -0x1c) = 0;\n    arg_ch_00 = *(unaff_EBP + 0xc);\n    if (arg_ch_00 == NULL) {\n        puVar3 = fcn.0101d3b6();\n        *puVar3 = 0x16;\n        fcn.0101b424(0, 0, 0, 0, 0);\n        goto code_r0x0101bb71;\n    }\n    fcn.0101c63a(arg_ch_00);\n    *(unaff_EBP + -4) = 0;\n    if ((*(arg_ch_00 + 3) & 0x40) == 0) {\n        iVar4 = fcn.0102540a(arg_ch_00);\n        if (iVar4 == -1) {\ncode_r0x0101bad0:\n            iVar4 = 0x103d230;\n        }\n        else {\n            iVar4 = fcn.0102540a(arg_ch_00);\n            if (iVar4 == -2) goto code_r0x0101bad0;\n            iVar4 = fcn.0102540a(arg_ch_00);\n            uVar5 = fcn.0102540a(arg_ch_00);\n            iVar4 = (uVar5 & 0x1f) * 0x28 + *((iVar4 >> 5) * 4 + 0x10daee0);\n        }\n        if ((*(iVar4 + 0x24) & 0x7f) == 0) {\n            iVar4 = fcn.0102540a(arg_ch_00);\n            if (iVar4 == -1) {\ncode_r0x0101bb15:\n                iVar4 = 0x103d230;\n            }\n            else {\n                iVar4 = fcn.0102540a(arg_ch_00);\n                if (iVar4 == -2) goto code_r0x0101bb15;\n                iVar4 = fcn.0102540a(arg_ch_00);\n                uVar5 = fcn.0102540a(arg_ch_00);\n                iVar4 = (uVar5 & 0x1f) * 0x28 + *((iVar4 >> 5) * 4 + 0x10daee0);\n            }\n            if ((*(iVar4 + 0x24) & 0x80) == 0) goto code_r0x0101bb3c;\n        }\n        puVar3 = fcn.0101d3b6();\n        *puVar3 = 0x16;\n        fcn.0101b424(0, 0, 0, 0, 0);\n        *(unaff_EBP + -0x1c) = 0xffffffff;\n    }\ncode_r0x0101bb3c:\n    if (*(unaff_EBP + -0x1c) == 0) {\n        ppuVar1 = arg_ch_00 + 1;\n        *ppuVar1 = *ppuVar1 + -1;\n        if (*ppuVar1 < 0) {\n            uVar5 = fcn.0102371d(*(unaff_EBP + 8), arg_ch_00);\n        }\n        else {\n            uVar2 = *(unaff_EBP + 8);\n            **arg_ch_00 = uVar2;\n            uVar5 = uVar2;\n            *arg_ch_00 = *arg_ch_00 + 1;\n        }\n        *(unaff_EBP + -0x1c) = uVar5;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.0101bb7a();\ncode_r0x0101bb71:\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 960
    },
    "01016760": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.01016760(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint32_t arg_20h, \n            char *arg_24h, uint32_t arg_28h)\n\n{\n    uint arg_14h_00;\n    uint arg_18h_00;\n    uint32_t uVar1;\n    uint uVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint32_t extraout_EDX;\n    int32_t *in_FS_OFFSET;\n    uint *puVar6;\n    int32_t var_8ch;\n    int32_t var_88h;\n    int32_t var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_6ch;\n    uint var_60h;\n    uint var_54h;\n    uint var_48h;\n    uint32_t var_44h;\n    char *var_40h;\n    uint var_3ch;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c170;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    puVar6 = &var_48h;\n    var_20h = uVar1;\n    uVar2 = fcn.01013420(puVar6);\n    var_4h = 0;\n    var_14h = fcn.01017090(uVar2);\n    var_4h = 0xffffffff;\n    fcn.01013370(puVar6, uVar1);\n    puVar6 = &var_3ch;\n    fcn.01016fe0(puVar6);\n    var_4h = 1;\n    if ((*arg_24h == '+') || (*arg_24h == '-')) {\n        var_88h = 1;\n    }\n    else {\n        if ((*arg_24h == '0') && ((arg_24h[1] == 'x' || (arg_24h[1] == 'X')))) {\n            var_84h = 2;\n        }\n        else {\n            var_84h = 0;\n        }\n        var_88h = var_84h;\n    }\n    var_18h = var_88h;\n    pcVar3 = fcn.01013c40();\n    if ((*pcVar3 != '\\x7f') && (pcVar3 = fcn.01013c40(),  '\\0' < *pcVar3)) {\n        var_40h = fcn.01013c40();\n        var_44h = arg_28h;\n        while (((*var_40h != '\\x7f' && ('\\0' < *var_40h)) && (*var_40h < var_44h - var_18h))) {\n            var_44h = var_44h - *var_40h;\n            fcn.0101b2c3(arg_24h + var_44h + 1, (arg_28h + 1) - var_44h, arg_24h + var_44h, (arg_28h + 1) - var_44h);\n            arg_24h[var_44h] = '\\0';\n            arg_28h = arg_28h + 1;\n            if ('\\0' < var_40h[1]) {\n                var_40h = var_40h + 1;\n            }\n        }\n    }\n    iVar4 = fcn.01014b00();\n    if ((iVar4 < 1) || (uVar1 = fcn.01014b00(),  uVar1 <= arg_28h)) {\n        var_8ch = 0;\n    }\n    else {\n        var_8ch = fcn.01014b00();\n        var_8ch = var_8ch - arg_28h;\n    }\n    var_1ch = var_8ch;\n    uVar1 = fcn.010143f0();\n    var_10h = uVar1 & 0x1c0;\n    if ((var_10h == 0x40) || (var_10h == 0x100)) {\n        if (var_10h == 0x100) {\n            puVar5 = fcn.01016db0(arg_8h, &var_60h, arg_10h, arg_14h, arg_18h, arg_24h, var_18h);\n            arg_24h = arg_24h + var_18h;\n            arg_28h = arg_28h - var_18h;\n            puVar5 = fcn.01016b70(arg_8h, &var_6ch, *puVar5, puVar5[1], puVar5[2], arg_24h & 0xffffff00 | arg_20h & 0xff\n                                  , var_1ch);\n            arg_10h = *puVar5;\n            arg_14h = puVar5[1];\n            arg_18h = puVar5[2];\n            var_1ch = 0;\n        }\n    }\n    else {\n        puVar5 = fcn.01016b70(arg_8h, &var_54h, arg_10h, arg_14h, arg_18h, uVar1 & 0x100 | arg_20h & 0xff, var_1ch);\n        arg_10h = *puVar5;\n        arg_14h = puVar5[1];\n        arg_18h = puVar5[2];\n        var_1ch = 0;\n    }\n    uVar2 = fcn.01016fc0();\n    puVar5 = fcn.01016e20(arg_8h, &var_78h, arg_10h, arg_14h, arg_18h, arg_24h, arg_28h, uVar2);\n    uVar2 = *puVar5;\n    arg_14h_00 = puVar5[1];\n    arg_18h_00 = puVar5[2];\n    fcn.01014b20(0);\n    fcn.01016b70(arg_8h, arg_ch, uVar2, arg_14h_00, arg_18h_00, extraout_EDX & 0xffffff00 | arg_20h & 0xff, var_1ch);\n    var_4h = 0xffffffff;\n    fcn.01013190();\n    *in_FS_OFFSET = var_ch;\n    fcn.01019b44(puVar6);\n    return;\n}\n",
        "token_count": 1567
    },
    "01001000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.01001000(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint arg_30h)\n\n{\n    code *pcVar1;\n    \n    // [00] -r-x section size 180224 named .text\n    (**0x4949d)();\n    func_0x00ff00db();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 142
    },
    "010013e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.010013e0(uint32_t arg_8h)\n\n{\n    uint var_14h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0xe0e;\n    if (*0x103c048 <= arg_8h) {\n        *0x103c024 = *0x103c06c;\n        *0x103c06c = *0x103c06c + 0x124b4;\n        var_4h = *0x103c06c * 0x1d + arg_8h;\n    }\n    *0x103c06c = (*0x103c068 - *0x103c06c) - var_4h;\n    if (*0x103c048 <= arg_8h) {\n        *0x103c024 = *0x103c068;\n        *0x103c068 = *0x103c068 + var_4h * '\\x02' + 0x98;\n        var_4h = *0x103c068 * 0x1d + arg_8h;\n    }\n    if (*0x103c030 != 4) {\n        *0x103c06c = var_4h * 0x1d + arg_8h;\n    }\n    return var_8h;\n}\n",
        "token_count": 302
    },
    "010014e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.010014e0(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    \n    *0x103c014 = *0x103c068 + *0x103c06c * 0x1d;\n    for (*0x10da108 = 1; *0x10da108 < 0x23; *0x10da108 = *0x10da108 + 1) {\n        if (*0x103c014 != *0x103c028) {\n            *0x103c014 = *0x103c014 - *(*0x10da108 * 4 + 0x103c018);\n            *0x103c06c = (*0x103c014 - 5) - *0x103c004;\n            if (*0x103c014 == *0x103c028) break;\n        }\n    }\n    *0x103c014 = *0x103c06c * 0x1d + *0x103c004;\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c06c = *0x103c06c - (*0x103c068 + 0x37 + *0x103c068);\n        *0x103c068 = (*0x103c06c + -5) - *0x103c008;\n    }\n    else {\n        *0x103c048 = *0x103c008 + 0x1089d + *0x103c068 + *0x103c048 * 2;\n        *0x103c06c = *0x103c068 + 0x1089d + *0x103c068 + *0x103c06c * 2;\n    }\n    for (*0x10da108 = 1; cVar2 = arg_8h,  *0x10da108 < 0x23; *0x10da108 = *0x10da108 + 1) {\n        if (*0x103c010 != *0x103c028) {\n            *0x103c010 = *0x103c010 - *(*0x10da108 * 4 + 0x103c018);\n            *0x103c068 = (*0x103c010 + -5) - cVar2;\n            if (*0x103c010 == *0x103c028) break;\n        }\n    }\n    if (*0x103c068 <= *0x103c010) {\n        *0x103c010 = arg_8h + 0x1089d + *0x103c068 + *0x103c010 * 2;\n        *0x103c044 = *0x103c044 - arg_8h;\n        *0x103c068 = cVar2 + -99 + *0x103c068;\n    }\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c010 = *0x103c010 - (*0x103c068 + 0x37 + *0x103c068);\n        *0x103c068 = (*0x103c010 + -5) - cVar2;\n    }\n    else {\n        *0x103c048 = arg_8h + 0x1089d + *0x103c068 + *0x103c048 * 2;\n        *0x103c010 = *0x103c068 + 0x1089d + *0x103c068 + *0x103c010 * 2;\n    }\n    uVar3 = *0x103c06c * 0x1d + *0x103c014;\n    uVar1 = *0x103c06c + -5 + *0x103c014;\n    *0x103c008 = uVar1 + uVar3;\n    *0x103c00c = CARRY4(uVar1, uVar3);\n    return *0x103c008;\n}\n",
        "token_count": 916
    },
    "01001ce0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.01001ce0(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint lpflOldProtect;\n    uint flNewProtect;\n    uint32_t var_ch;\n    uint dwSize;\n    int32_t var_4h;\n    \n    flNewProtect = 0x40;\n    dwSize = 0x31b0;\n    for (var_4h = 1; var_4h < 0x23; var_4h = var_4h + 1) {\n        if (*0x103c004 != *0x103c028) {\n            *0x103c004 = *0x103c004 - *(var_4h * 4 + 0x103c018);\n            *0x103c06c = (*0x103c004 - 5) - *0x103c008;\n            if (*0x103c004 == *0x103c028) break;\n        }\n    }\n    uVar2 = *0x103c068 + 0x73825;\n    var_ch = *0x103c068 + arg_8h + 0x73873;\n    if (var_ch <= *0x103c004) {\n        *0x103c004 = *0x103c068 + 0x1089d + var_ch + *0x103c004 * 2;\n        *0x103c044 = *0x103c044 - *0x103c068;\n        var_ch = *0x103c068 + 0x269d + var_ch;\n    }\n    uVar1 = *0x103c014 + 0x1089d + var_ch;\n    uVar3 = uVar1 + uVar2;\n    *0x103c008 = uVar3 + uVar2;\n    *0x103c00c = CARRY4(uVar1, uVar2) + CARRY4(uVar3, uVar2);\n    *0x10da0f8 = arg_ch;\n    iVar4 = var_ch + *0x103c008 + -5 + arg_8h;\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        *0x103c004 = *0x103c004 + iVar4 * -2 + -0x37;\n    }\n    else {\n        *0x103c048 = *0x103c068 + 0x1089d + iVar4 + *0x103c048 * 2;\n        *0x103c004 = iVar4 * 2 + 0x1089d + *0x103c004 * 2;\n    }\n    var_ch = (*0x103c008 + -5) - *0x103c014;\n    var_ch = (*_sym.imp.KERNEL32.dll_GetCurrentDirectoryA)(0x804, 0x103d840);\n    if (*0x103c064 <= *0x103c068) {\n        *0x103c05b = var_ch;\n        var_ch = (*0x103c068 + var_ch + *0x103c004 * 2 + 0x10898) - *0x103c068;\n        *0x103c004 = *0x103c068 + var_ch * 0x1d;\n    }\n    *0x103c068 = (*0x103c008 - *0x103c068) - *0x103c014;\n    (*_sym.imp.KERNEL32.dll_VirtualProtect)(*0x10da0f8, dwSize, flNewProtect, &lpflOldProtect);\n    if (*0x103c024 == 0x15ef) {\n        *0x103c06c = *0x103c06c + *0x103c020;\n        var_ch = var_ch + *0x103c020;\n        *0x103c004 = var_ch * 2 + *0x103c06c * 2 + -10 + *0x103c004;\n    }\n    *0x103c008 = arg_8h + var_ch + 0x2698 + *0x103c014 + *0x103c008;\n    for (var_4h = 1; var_4h < 0x23; var_4h = var_4h + 1) {\n        if (var_ch != *0x103c028) {\n            var_ch = var_ch - *(var_4h * 4 + 0x103c018);\n            *0x103c008 = (var_ch - 5) - arg_8h;\n            if (var_ch == *0x103c028) break;\n        }\n    }\n    *0x103c014 = -0x37 - *0x103c068;\n    *0x103c068 = *0x103c014 + -99 + *0x103c068;\n    if (*0x103c024 == 0x15ef) {\n        var_ch = var_ch + (*0x103c020 + *0x103c008) * 2 + -5;\n    }\n    *0x103c008 = *0x103c068 + 6 + *0x103c014;\n    *0x103c00c = 0;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(0x103d840, 0x804);\n    bVar5 = uVar2 < *0x103c008;\n    uVar2 = uVar2 - *0x103c008;\n    *0x103c008 = uVar2 - arg_8h;\n    *0x103c00c = (-bVar5 - *0x103c00c) - (uVar2 < arg_8h);\n    *0x103c014 = -0x37 - *0x103c068;\n    return;\n}\n",
        "token_count": 1340
    },
    "01002340": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.01002340(int32_t *param_1)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t unaff_EBX;\n    \n    iVar1 = in_EAX + -1;\n    if (param_1 != NULL) {\n        iVar1 = (**(*param_1 + 0x50))();\n        *(unaff_EBX + 8) = iVar1;\n        if (iVar1 != 0) {\n            iVar1 = func_0x00e2b5d8();\n        }\n    }\n    return iVar1 + -1;\n}\n",
        "token_count": 136
    },
    "0100ebb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.0100ebb0(void)\n\n{\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    var_ch._0_2_ = *0x103c004 + 0x26d9;\n    if (*0x103c024 == 0x15ef) {\n        *0x103c010 = *0x103c010 + *0x103c020;\n        var_ch._0_2_ = var_ch + *0x103c010 * 2 + -5;\n    }\n    for (var_10h = 0xf5c; var_10h < 0x1084; var_10h = var_10h + 4) {\n        if (*0x103c048 <= var_ch) {\n            *0x103c024 = *0x103c010;\n            *0x103c010 = (var_ch + *0x103c010 + *0x103c014 * 2 + 0x10898) - var_ch;\n        }\n        *0x103c06c = (*0x103c004 + -5) - *0x103c068;\n        *0x103c014 = var_ch + *0x103c068 * 0x1d;\n        if (*0x103c030 != 4) {\n            *0x103c004 = var_ch + *0x103c014 * 0x1d;\n        }\n        *0x10da100 = *(*0x10d93b4 + var_10h + -0xf5c) + 0x1090c34;\n        *(*0x10d93b4 + var_10h + -0xf5c) = *0x10da100;\n        var_ch._0_2_ = (*0x103c014 + -5) - *0x103c06c;\n    }\n    var_ch._0_2_ = *0x103c004 + 0x269d + var_ch;\n    if (*0x103c010 <= *0x103c014) {\n        *0x103c014 = var_ch + 0x1089d + *0x103c010 + *0x103c014 * 2;\n        *0x103c044 = *0x103c044 - var_ch;\n        *0x103c010 = var_ch + 0x269d + *0x103c010;\n    }\n    if (*0x103c024 == 0x15ef) {\n        *0x103c010 = *0x103c010 + *0x103c020;\n        *0x103c014 = *0x103c010 * 2 + -5 + *0x103c014;\n    }\n    return *0x103c014;\n}\n",
        "token_count": 634
    },
    "0100f0c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nulong __cdecl fcn.0100f0c0(uint32_t arg_8h)\n\n{\n    char cVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint16_t uVar5;\n    uint32_t uVar6;\n    bool bVar7;\n    bool bVar8;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    int32_t var_4h;\n    \n    var_10h = 0x15e8;\n    var_ch = 0;\n    uVar3 = var_14h + 0x5c + *0x103c068;\n    *0x103c06c = uVar3;\n    if (*0x103c048 <= *0x103c004) {\n        *0x103c06c = uVar3 + var_14h * 2 + 0x10898;\n        var_14h = *0x103c06c * 0x1d + *0x103c004;\n        *0x103c024 = uVar3;\n    }\n    if (*0x103c030 == 4) {\n        arg_8h = (0x15e8 - arg_8h) - *0x103c068;\n    }\n    else {\n        cVar1 = fcn.01019b10(0x15e8, 0, 0x1d, 0);\n        *0x103c068 = arg_8h + cVar1;\n    }\n    cVar1 = arg_8h;\n    if (*0x103c068 < 0x15e9) {\n        uVar3 = arg_8h + 0x1089d + *0x103c068;\n        var_10h = uVar3 + 0x2bd0;\n        var_ch = (0xffffea17 < uVar3) + (0xffffea17 < uVar3 + 0x15e8);\n        *0x103c044 = *0x103c044 - arg_8h;\n        *0x103c068 = cVar1 + -99 + *0x103c068;\n    }\n    uVar3 = var_18h + 0x5c + var_14h;\n    *0x103c06c = uVar3;\n    if (*0x103c048 <= arg_8h) {\n        *0x103c06c = uVar3 + var_10h * 2 + 0x10898;\n        var_10h = *0x103c06c * 0x1d + arg_8h;\n        var_ch = 0;\n        *0x103c024 = uVar3;\n    }\n    *0x103c068 = *0x103c068 - (var_10h + '7' + *0x103c06c);\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        var_14h = var_14h + *0x103c06c * -2 + -0x37;\n        *0x103c06c = (var_14h - 5) - *0x103c004;\n    }\n    else {\n        *0x103c048 = *0x103c004 + 0x1089d + *0x103c06c + *0x103c048 * 2;\n        var_14h = *0x103c06c * 2 + 0x1089d + var_14h * 2;\n    }\n    for (var_4h = 1; var_4h < 0x23; var_4h = var_4h + 1) {\n        if ((var_10h != *0x103c028) || (var_ch != 0)) {\n            uVar3 = *(var_4h * 4 + 0x103c018);\n            bVar7 = var_10h < uVar3;\n            var_10h = var_10h - uVar3;\n            var_ch = var_ch - bVar7;\n            *0x103c068 = (var_10h + -5) - cVar1;\n            if ((var_10h == *0x103c028) && (var_ch == 0)) break;\n        }\n    }\n    if (*0x103c028 - *0x103c040 == 0x326) {\n        uVar3 = *0x103c06c * 2 + 0x37;\n        bVar7 = var_10h < uVar3;\n        var_10h = var_10h - uVar3;\n        var_ch = var_ch - bVar7;\n        *0x103c06c = (var_10h - 5) - arg_8h;\n    }\n    else {\n        *0x103c048 = arg_8h + 0x1089d + *0x103c06c + *0x103c048 * 2;\n        uVar3 = *0x103c06c * 2 + 0x1089d;\n        bVar7 = CARRY4(uVar3, var_10h);\n        uVar3 = uVar3 + var_10h;\n        bVar8 = CARRY4(uVar3, var_10h);\n        var_10h = uVar3 + var_10h;\n        var_ch = var_ch * 2 + bVar7 + bVar8;\n    }\n    *0x103c068 = *0x103c068 - (var_10h + '7' + *0x103c06c);\n    if (*0x103c06c <= var_14h) {\n        var_14h = *0x103c004 + 0x1089d + *0x103c06c + var_14h * 2;\n        *0x103c044 = *0x103c044 - *0x103c004;\n        *0x103c06c = *0x103c004 + 0x269d + *0x103c06c;\n    }\n    for (var_4h = 1; var_4h < 0x23; var_4h = var_4h + 1) {\n        if ((var_10h != *0x103c028) || (var_ch != 0)) {\n            uVar3 = *(var_4h * 4 + 0x103c018);\n            bVar7 = var_10h < uVar3;\n            var_10h = var_10h - uVar3;\n            var_ch = var_ch - bVar7;\n            *0x103c068 = (var_10h + -5) - cVar1;\n            if ((var_10h == *0x103c028) && (var_ch == 0)) break;\n        }\n    }\n    uVar5 = (var_18h * 2 + 0x866) - (var_14h + 0x37 + *0x103c06c);\n    if (*0x103c030 != 4) {\n        cVar2 = fcn.01019b10(var_10h, var_ch, 0x1d, 0);\n        *0x103c068 = cVar1 + cVar2;\n    }\n    *0x103c06c = (uVar5 - 5) - var_14h;\n    uVar6 = *0x103c06c - 5;\n    uVar4 = uVar6 + var_10h;\n    uVar3 = *0x103c068;\n    *0x103c068 = *0x103c068 + uVar4;\n    return CONCAT44(var_ch + CARRY4(uVar6, var_10h) + CARRY4(uVar3, uVar4), uVar5);\n}\n",
        "token_count": 1858
    },
    "010112f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.010112f0(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = (*0x103c014 + -0x2294) - arg_8h;\n    iVar4 = ((*0x103c06c * '\\x03' + *0x103c068 * '\\x02' + arg_8h * '\\x02' + '\\'') - 5) - arg_8h;\n    uVar3 = iVar4 * 0x1d + iVar2;\n    *0x103c06c = uVar3 + 0x5c + iVar2;\n    uVar1 = iVar2 + 0x1089d + *0x103c06c;\n    uVar5 = uVar1 + uVar3;\n    *0x103c008 = uVar5 + uVar3;\n    *0x103c00c = CARRY4(uVar1, uVar3) + CARRY4(uVar5, uVar3);\n    *0x103c014 = *0x103c014 * 2 + 0x1082a;\n    *0x103c068 = (uVar3 - iVar4) * '\\x1e' + iVar2 * -0x1d + arg_8h + -5;\n    return *0x103c008;\n}\n",
        "token_count": 347
    },
    "010117b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.010117b0(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint8_t var_5h;\n    int32_t var_4h;\n    \n    if (*0x103c024 == 0x15ef) {\n        *0x103c06c = *0x103c06c + *0x103c020;\n    }\n    *0x103c010 = var_5h + *0x103c06c + *0x103c014 + 0x57 + var_5h;\n    *0x103c06c = var_5h + 0x5c + *0x103c014;\n    for (var_4h = 1; var_4h < 0x23; var_4h = var_4h + 1) {\n        if (*0x103c010 != *0x103c028) {\n            *0x103c010 = *0x103c010 - *(var_4h * 4 + 0x103c018);\n            *0x103c06c = (*0x103c010 + -5) - arg_8h;\n            if (*0x103c010 == *0x103c028) break;\n        }\n    }\n    iVar1 = *0x103c014 + 0x5c + arg_8h;\n    *0x103c06c = iVar1 + ((*0x103c06c + '\\x06' + arg_8h) - (var_5h + 0x32)) + 0x26f9 + arg_8h;\n    *0x103c014 = (-arg_8h - iVar1) + *0x103c014 * 2 + 0x1082f;\n    *0x103c010 = (*0x103c014 - iVar1) - arg_8h;\n    var_4h = 1;\n    while ((var_4h < 0x23 &&\n           ((*0x103c010 == *0x103c028 ||\n            (*0x103c010 = *0x103c010 - *(var_4h * 4 + 0x103c018),  *0x103c010 != *0x103c028))))) {\n        var_4h = var_4h + 1;\n    }\n    *0x103c068 = *0x103c06c + '\\x06' + *0x103c010;\n    return *0x103c014;\n}\n",
        "token_count": 560
    },
    "01013730": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.01013730(uint arg_8h)\n\n{\n    uint arg_ch;\n    uint var_4h;\n    \n    arg_ch = fcn.01013710(arg_8h);\n    fcn.01014100(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 64
    },
    "010139e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __cdecl fcn.010139e0(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    code **in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102bf18;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0101af7e(arg_8h, uVar1);\n    var_4h = 0;\n    *in_ECX = vtable.std::runtime_error.0;\n    fcn.01013bf0(arg_8h + 0xc);\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 207
    },
    "01013aa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.01013aa0(code **param_1)\n\n{\n    uint var_4h;\n    \n    *param_1 = vtable.std::runtime_error.0;\n    fcn.01013190();\n    fcn.0101afd6();\n    return;\n}\n",
        "token_count": 62
    },
    "01013b00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __cdecl fcn.01013b00(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    code **in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102bf18;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.0101af07(uVar1);\n    var_4h = 0;\n    *in_ECX = vtable.std::runtime_error.0;\n    fcn.01013bf0(arg_8h);\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 195
    },
    "01013c60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01013c60(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    uint arg_ch_00;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar2 = fcn.01015ab0();\n    if (uVar2 < arg_ch) {\n        fcn.01018cbf();\n    }\n    iVar3 = fcn.01015ab0();\n    var_4h = iVar3 - arg_ch;\n    if (arg_10h < var_4h) {\n        var_4h = arg_10h;\n    }\n    if (in_ECX == arg_8h) {\n        fcn.01014190(arg_ch + var_4h, *0x1036860);\n        fcn.01014190(0, arg_ch);\n    }\n    else {\n        cVar1 = fcn.01014280(var_4h, 0);\n        if (cVar1 != '\\0') {\n            uVar2 = var_4h;\n            iVar3 = fcn.01014320();\n            iVar3 = iVar3 + arg_ch;\n            arg_ch_00 = *(in_ECX + 0x18);\n            arg_8h_00 = fcn.01014320();\n            fcn.01014e30(arg_8h_00, arg_ch_00, iVar3, uVar2);\n            fcn.01014230(var_4h);\n        }\n    }\n    return in_ECX;\n}\n",
        "token_count": 379
    },
    "01013d40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01013d40(uint arg_8h)\n\n{\n    char cVar1;\n    uchar uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102bf48;\n    var_ch = *in_FS_OFFSET;\n    uVar3 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.01014430(arg_8h);\n    var_4h = 0;\n    cVar1 = fcn.01013df0(arg_8h, uVar3);\n    if (cVar1 != '\\0') {\n        iVar4 = fcn.01014410();\n        if (iVar4 != 0) {\n            fcn.01014410();\n            fcn.01013e10();\n        }\n    }\n    uVar2 = fcn.01013df0(arg_8h, uVar3);\n    *(in_ECX + 4) = uVar2;\n    *in_FS_OFFSET = var_ch;\n    return in_ECX;\n}\n",
        "token_count": 297
    },
    "01013df0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nbool __fastcall fcn.01013df0(uint param_1)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.010136a0(param_1);\n    return iVar1 == 0;\n}\n",
        "token_count": 72
    },
    "01014100": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01014100(int32_t arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint arg_8h_00;\n    int32_t in_ECX;\n    uint arg_ch_00;\n    uint arg_14h;\n    uint var_4h;\n    \n    cVar1 = fcn.01014790(arg_8h);\n    if (cVar1 == '\\0') {\n        cVar1 = fcn.01014280(arg_ch, 0);\n        if (cVar1 != '\\0') {\n            arg_ch_00 = *(in_ECX + 0x18);\n            arg_14h = arg_ch;\n            arg_8h_00 = fcn.01014320();\n            fcn.01014e30(arg_8h_00, arg_ch_00, arg_8h, arg_14h);\n            fcn.01014230(arg_ch);\n        }\n    }\n    else {\n        iVar2 = fcn.01014320();\n        in_ECX = fcn.01013c60(in_ECX, arg_8h - iVar2, arg_ch);\n    }\n    return in_ECX;\n}\n",
        "token_count": 266
    },
    "01014320": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.01014320(int32_t param_1)\n\n{\n    int32_t var_8h;\n    uint var_4h;\n    \n    if (*(param_1 + 0x18) < 0x10) {\n        var_8h = param_1 + 4;\n    }\n    else {\n        var_8h = *(param_1 + 4);\n    }\n    return var_8h;\n}\n",
        "token_count": 98
    },
    "01014350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.01014350(uint arg_8h)\n\n{\n    uint var_4h;\n    \n    fcn.0101b073(arg_8h);\n    return;\n}\n",
        "token_count": 42
    },
    "01014430": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.01014430(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *in_ECX;\n    uint var_4h;\n    \n    *in_ECX = arg_8h;\n    iVar1 = fcn.010136c0();\n    if (iVar1 != 0) {\n        fcn.010136c0();\n        fcn.01014480();\n    }\n    return in_ECX;\n}\n",
        "token_count": 99
    },
    "01014480": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.01014480(uint param_1)\n\n{\n    uint var_4h;\n    \n    fcn.01018d48(param_1);\n    return;\n}\n",
        "token_count": 56
    },
    "010144a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.010144a0(uint param_1)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = fcn.010136c0(param_1);\n    if (iVar1 != 0) {\n        fcn.010136c0(param_1);\n        fcn.010144e0();\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "010144e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __fastcall fcn.010144e0(uint param_1)\n\n{\n    uint var_4h;\n    \n    fcn.01018d51(param_1);\n    return;\n}\n",
        "token_count": 57
    },
    "01014790": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.01014790(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    uVar1 = fcn.01014320();\n    if (uVar1 <= arg_8h) {\n        iVar2 = fcn.01014320();\n        uVar1 = iVar2 + *(in_ECX + 0x14);\n        if (arg_8h < uVar1) {\n            return CONCAT31(uVar1 >> 8, 1);\n        }\n    }\n    return uVar1 & 0xffffff00;\n}\n",
        "token_count": 149
    },
    "01016d80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.01016d80(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    if (*(in_ECX + 0x14) <= arg_8h && arg_8h != *(in_ECX + 0x14)) {\n        fcn.0101b448();\n    }\n    iVar1 = fcn.01014320();\n    return iVar1 + arg_8h;\n}\n",
        "token_count": 112
    },
    "01017220": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.01017220(uint arg_8h)\n\n{\n    uchar uVar1;\n    code **in_ECX;\n    int32_t *in_FS_OFFSET;\n    uint *arg_8h_00;\n    uint var_98h;\n    uint var_94h;\n    uint var_8ch;\n    uint32_t var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x102c216;\n    var_ch = *in_FS_OFFSET;\n    var_10h = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    fcn.010152a0(arg_8h);\n    var_4h = 0;\n    *in_ECX = vtable.std::numpunct_char_.0;\n    fcn.01015100(0x103687c);\n    var_4h = CONCAT31(var_4h._1_3_, 1);\n    arg_8h_00 = &var_8ch;\n    fcn.01017550();\n    if (*(in_ECX + 0xd) == '\\0') {\n        fcn.01017310(&var_94h);\n        uVar1 = fcn.01017180(0x2c);\n        *(in_ECX + 0xd) = uVar1;\n    }\n    var_4h = var_4h & 0xffffff00;\n    fcn.010151e0();\n    var_4h = 0xffffffff;\n    *in_FS_OFFSET = var_ch;\n    fcn.01019b44(arg_8h_00);\n    return;\n}\n",
        "token_count": 393
    },
    "010174d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.010174d0(int32_t param_1)\n\n{\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0101b4da(*(param_1 + 8));\n    fcn.0101b4da(*(param_1 + 0x10));\n    fcn.0101b4da(*(param_1 + 0x14));\n    return;\n}\n",
        "token_count": 105
    },
    "01018a5a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01018a5a(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0101b84a(8);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -0x10) = 0;\n    if (*(unaff_EBP + 0x10) != 0) {\n        *extraout_ECX = 0x1036a1c;\n        extraout_ECX[1] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = 1;\n    }\n    uVar1 = *(unaff_EBP + 0xc);\n    *(extraout_ECX + *(*extraout_ECX + 4)) = vtable.std::basic_ostream_char__struct_std::char_traits_char__.0;\n    fcn.01018975(*(unaff_EBP + 8), uVar1);\n    fcn.0101b8e9();\n    return;\n}\n",
        "token_count": 315
    },
    "01018c6d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.01018c6d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.0101b84a(4);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    iVar1 = *(unaff_EBP + 8);\n    fcn.0101af7e(iVar1);\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.std::logic_error.0;\n    fcn.01013bf0(iVar1 + 0xc);\n    fcn.0101b8e9();\n    return;\n}\n",
        "token_count": 191
    },
    "0102018f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0102018f(int32_t *param_1)\n\n{\n    uint *puVar1;\n    \n    if ((param_1 != NULL) && (*0x10da5e4 != 0)) {\n        *param_1 = *0x10da5e4;\n        return 0;\n    }\n    puVar1 = fcn.0101d3b6();\n    *puVar1 = 0x16;\n    fcn.0101b424(0, 0, 0, 0, 0);\n    return 0x16;\n}\n",
        "token_count": 128
    },
    "010201c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.010201c6(uint *param_1)\n\n{\n    uint *puVar1;\n    \n    if ((param_1 != NULL) && (*0x10da5e4 != 0)) {\n        *param_1 = *0x10da5f0;\n        return 0;\n    }\n    puVar1 = fcn.0101d3b6();\n    *puVar1 = 0x16;\n    fcn.0101b424(0, 0, 0, 0, 0);\n    return 0x16;\n}\n",
        "token_count": 126
    },
    "01025084": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x01025096)\n// WARNING: Removing unreachable block (ram,0x0102509c)\n// WARNING: Removing unreachable block (ram,0x0102509e)\n\nvoid fcn.01025084(void)\n\n{\n    return;\n}\n",
        "token_count": 62
    },
    "0101ab3a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0101ab3a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.0101d297(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 112
    },
    "010151e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.010151e0(uint param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *in_FS_OFFSET;\n    uint var_10h;\n    int32_t var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    uStack12 = 0x102c0b4;\n    var_ch = *in_FS_OFFSET;\n    uVar1 = *0x103c470 ^ &stack0xfffffffc;\n    *in_FS_OFFSET = &var_ch;\n    var_4h = 4;\n    fcn.01018ebc(param_1, uVar1);\n    var_4h._0_1_ = 3;\n    fcn.01013190();\n    var_4h._0_1_ = 2;\n    fcn.01013190();\n    var_4h._0_1_ = 1;\n    fcn.01013190();\n    var_4h = var_4h._1_3_ << 8;\n    fcn.01013190();\n    var_4h = 0xffffffff;\n    fcn.01018b46();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 275
    },
    "01018b46": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.01018b46(int32_t *param_1)\n\n{\n    fcn.01019453(*param_1 * 0x18 + 0x10da1d8);\n    return;\n}\n",
        "token_count": 50
    },
    "0102c540": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0102c540(void)\n\n{\n    *0x10da11c = 0x3fba48c;\n    return;\n}\n",
        "token_count": 34
    },
    "0102bac2": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid fcn.0102bac2(void)\n\n{\n    *0x103d554 = (*_sym.imp.KERNEL32.dll_CreateFileA)(\"CONOUT$\", 0x40000000, 3, 0, 3, 0, 0);\n    return;\n}\n",
        "token_count": 61
    },
    "01017818": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.01017818(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code *apcStack16 [3];\n    \n    do {\n        iVar2 = fcn.01019a43(param_1);\n        if (iVar2 != 0) {\n            return;\n        }\n        iVar2 = fcn.0101f0fe(param_1);\n    } while (iVar2 != 0);\n    if ((*0x10da400 & 1) == 0) {\n        *0x10da400 = *0x10da400 | 1;\n        fcn.0101b078();\n        fcn.0101c551(0x102c689);\n    }\n    fcn.0101af7e(0x10da3f4);\n    apcStack16[0] = vtable.std::bad_alloc.0;\n    fcn.0101ae78(apcStack16, 0x10398f8);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 236
    },
    "010236ad": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.010236ad(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.0101fef0(0x103a3d0, 0xc);\n    fcn.0101f296(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x10dac78;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x10dac74;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x010236f1;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.01019966(arg_8h_00);\ncode_r0x010236f1:\n        fcn.01019966(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.01023714();\n    fcn.0101ff35();\n    return;\n}\n",
        "token_count": 395
    }
}