{
    "00401000": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00401000(uchar *param_1, uchar *param_2)\n\n{\n    uint8_t uVar1;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint8_t *puVar9;\n    uint8_t *puStack24;\n    uint8_t *puStack20;\n    \n    // [00] -r-x section size 4096 named .rsrc\n    *param_2 = *param_1;\n    puStack20 = param_2 + 1;\n    bVar2 = false;\n    bVar3 = false;\n    puStack24 = param_1 + 1;\n    bVar4 = false;\n    puVar8 = param_2;\n    do {\n        iVar5 = fcn.004011b2();\n        if (iVar5 == 0) {\n            *puStack20 = *puStack24;\n            puStack24 = puStack24 + 1;\ncode_r0x00401176:\n            puStack20 = puStack20 + 1;\n            bVar2 = false;\n        }\n        else {\n            iVar5 = fcn.004011b2();\n            if (iVar5 == 0) {\n                iVar5 = fcn.00401191();\n                if (bVar2) {\n                    iVar7 = -2;\n                }\n                else {\n                    if (iVar5 == 2) {\n                        iVar5 = fcn.00401191();\n                        if (iVar5 != 0) {\n                            puVar9 = puStack20 + -puVar8;\n                            do {\n                                *puStack20 = *puVar9;\n                                puStack20 = puStack20 + 1;\n                                puVar9 = puVar9 + 1;\n                                iVar5 = iVar5 + -1;\n                            } while (iVar5 != 0);\n                        }\n                        goto code_r0x0040115f;\n                    }\n                    iVar7 = -3;\n                }\n                puVar8 = (iVar5 + iVar7) * 0x100 + *puStack24;\n                puStack24 = puStack24 + 1;\n                iVar5 = fcn.00401191();\n                if (0x7cff < puVar8) {\n                    iVar5 = iVar5 + 1;\n                }\n                if (0x4ff < puVar8) {\n                    iVar5 = iVar5 + 1;\n                }\n                if (puVar8 < 0x80) {\n                    iVar5 = iVar5 + 2;\n                }\n                if (iVar5 != 0) {\n                    puVar9 = puStack20 + -puVar8;\n                    do {\n                        *puStack20 = *puVar9;\n                        puStack20 = puStack20 + 1;\n                        puVar9 = puVar9 + 1;\n                        iVar5 = iVar5 + -1;\n                    } while (iVar5 != 0);\n                }\n            }\n            else {\n                iVar5 = fcn.004011b2();\n                if (iVar5 != 0) {\n                    iVar5 = 0;\n                    iVar7 = 4;\n                    do {\n                        iVar6 = fcn.004011b2();\n                        iVar5 = iVar6 + iVar5 * 2;\n                        iVar7 = iVar7 + -1;\n                    } while (iVar7 != 0);\n                    bVar3 = bVar4;\n                    if (iVar5 == 0) {\n                        *puStack20 = 0;\n                    }\n                    else {\n                        *puStack20 = puStack20[-iVar5];\n                    }\n                    goto code_r0x00401176;\n                }\n                uVar1 = *puStack24;\n                puStack24 = puStack24 + 1;\n                iVar5 = (uVar1 & 1) + 2;\n                puVar8 = uVar1 >> 1;\n                if (puVar8 == NULL) {\n                    bVar3 = true;\n                    bVar4 = true;\n                }\n                else if (iVar5 != 0) {\n                    puVar9 = puStack20 + -puVar8;\n                    do {\n                        *puStack20 = *puVar9;\n                        puStack20 = puStack20 + 1;\n                        puVar9 = puVar9 + 1;\n                        iVar5 = iVar5 + -1;\n                    } while (iVar5 != 0);\n                }\n            }\ncode_r0x0040115f:\n            bVar2 = true;\n        }\n        if (bVar3) {\n            return puStack20 - param_2;\n        }\n    } while( true );\n}\n",
        "token_count": 1013
    },
    "004011b2": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004011b2(uint8_t **param_1)\n\n{\n    uint8_t *puVar1;\n    \n    puVar1 = param_1[3];\n    param_1[3] = puVar1 + -1;\n    if (puVar1 == NULL) {\n        param_1[3] = 0x7;\n        param_1[2] = **param_1;\n        *param_1 = *param_1 + 1;\n    }\n    puVar1 = param_1[2];\n    param_1[2] = puVar1 * 2;\n    return puVar1 >> 7 & 1;\n}\n",
        "token_count": 149
    },
    "00401790": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401790(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t in_ECX;\n    int32_t in_EDX;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x88);\n    if ((iVar2 != 0) && (*(arg_8h + 0x8c) != 0)) {\n        iVar3 = *(arg_8h + 0x1c);\n        piVar6 = iVar2 + in_ECX;\n        if (piVar6 + (-in_ECX - iVar2) < *(arg_8h + 0x8c)) {\n            do {\n                uVar7 = piVar6[1] - 8U >> 1;\n                uVar5 = 0;\n                if (uVar7 != 0) {\n                    do {\n                        uVar4 = *(piVar6 + uVar5 * 2 + 8);\n                        if ((uVar4 & 0xf000) == 0x3000) {\n                            piVar1 = (uVar4 & 0xfff) + *piVar6 + in_ECX;\n                            *piVar1 = *piVar1 + (in_EDX - iVar3);\n                        }\n                        uVar5 = uVar5 + 1;\n                    } while (uVar5 < uVar7);\n                }\n                piVar6 = piVar6 + piVar6[1];\n            } while (piVar6 + (-in_ECX - *(arg_8h + 0x88)) < *(arg_8h + 0x8c));\n        }\n    }\n    return;\n}\n",
        "token_count": 435
    },
    "00401520": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401520(uint noname_0, int32_t *arg_ch, int32_t *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    int32_t iVar6;\n    int32_t *piVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    *arg_ch = 0;\n    *arg_10h = 0;\n    iVar6 = *(in_ECX + 0x3c);\n    iVar10 = iVar6 + in_ECX;\n    if (*(iVar6 + 4 + in_ECX) != 0x14c) {\n        return 0;\n    }\n    iVar2 = *(iVar6 + 0x88 + in_ECX);\n    if ((iVar2 != 0) && (*(iVar6 + 0x8c + in_ECX) != 0)) {\n        iVar6 = iVar10 + 0x18 + *(iVar10 + 0x14);\n        uVar8 = 0;\n        if (*(iVar10 + 6) != 0) {\n            do {\n                if (*(iVar6 + 0xc) == iVar2) {\n                    iVar10 = *(iVar6 + 0x14);\n                    iVar6 = iVar10 + in_ECX;\n                    uVar8 = *(iVar10 + 0xe + in_ECX) + *(iVar10 + 0xc + in_ECX);\n                    var_10h = 0;\n                    if (uVar8 == 0) {\n                        return 0;\n                    }\n                    uVar3 = 0;\n                    do {\n                        iVar10 = (*(iVar6 + 0x14 + uVar3 * 8) & 0x7fffffff) + iVar6;\n                        uVar3 = *(iVar10 + 0xe) + *(iVar10 + 0xc);\n                        uVar12 = 0;\n                        if (uVar3 != 0) {\n                            uVar4 = 0;\n                            do {\n                                if (*(iVar10 + 0x10 + uVar4 * 8) == 0x65) {\n                                    iVar9 = (*(iVar10 + 0x14 + uVar4 * 8) & 0x7fffffff) + iVar6;\n                                    uVar4 = 0;\n                                    uVar11 = *(iVar9 + 0xe) + *(iVar9 + 0xc);\n                                    if (uVar11 != 0) {\n                                        uVar5 = 0;\n                                        do {\n                                            iVar1 = iVar9 + uVar5 * 8;\n                                            if (*(iVar1 + 0x10) == 0x409) {\n                                                piVar7 = *(iVar1 + 0x14) + iVar6;\n                                                *arg_ch = (*piVar7 - iVar2) + iVar6;\n                                                *arg_10h = piVar7[1];\n                                                return 1;\n                                            }\n                                            uVar4 = uVar4 + 1;\n                                            uVar5 = uVar4 & 0xffff;\n                                        } while (uVar5 < uVar11);\n                                    }\n                                }\n                                uVar12 = uVar12 + 1;\n                                uVar4 = uVar12 & 0xffff;\n                            } while (uVar4 < uVar3);\n                        }\n                        var_10h = var_10h + 1;\n                        uVar3 = var_10h & 0xffff;\n                    } while (uVar3 < uVar8);\n                    return 0;\n                }\n                uVar8 = uVar8 + 1;\n                iVar6 = iVar6 + 0x28;\n            } while (uVar8 < *(iVar10 + 6));\n        }\n    }\n    return 0;\n}\n",
        "token_count": 916
    },
    "0040120f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040120f(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint uVar5;\n    code *pcVar6;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint lpFilename;\n    uint32_t var_28h;\n    int32_t lpNumberOfBytesRead;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_ch;\n    uint *lpModuleName;\n    int32_t var_4h;\n    \n    lpFilename._0_2_ = 0;\n    iVar7 = 0;\n    var_18h = 0;\n    var_14h = 0;\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &lpFilename, 0x400);\n    iVar1 = (*_sym.imp.KERNEL32.dll_CreateFileW)(&lpFilename, 0x80000000, 1, 0, 3, 0x8000000, 0);\n    uVar4 = extraout_ECX;\n    if (iVar1 != -1) {\n        iVar7 = (*_sym.imp.KERNEL32.dll_GetFileSize)(iVar1, 0);\n        var_18h = iVar7;\n        var_14h = fcn.00401450();\n        iVar2 = (*_sym.imp.KERNEL32.dll_ReadFile)(iVar1, var_14h, iVar7, &lpNumberOfBytesRead, 0);\n        if ((iVar2 == 0) || (lpNumberOfBytesRead != iVar7)) {\n            fcn.00401460();\n            iVar7 = 0;\n            var_14h = 0;\n            var_18h = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        uVar4 = extraout_ECX_00;\n    }\n    fcn.00401520(uVar4, &var_10h, &var_4h);\n    fcn.00401690(&var_ch, &lpModuleName);\n    var_ch = *(var_ch + 0x3c) + var_ch;\n    lpModuleName = *(var_ch + 0x50);\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, lpModuleName + iVar7 + 0x18, 0x3000, 0x40);\n    var_4h = iVar1;\n    if (iVar1 != 0) {\n        fcn.00401470(0x40);\n        var_1ch = *(iVar1 + 0x3c) + iVar1;\n        fcn.00401470(*(var_ch + 0x14));\n        uVar8 = *(var_ch + 6);\n        var_20h = *(var_ch + 0x14) + var_ch + 0x18;\n        var_28h = uVar8;\n        if (uVar8 != 0) {\n            do {\n                fcn.00401470(0x28);\n                iVar1 = var_4h;\n                uVar8 = uVar8 - 1;\n            } while (uVar8 != 0);\n            if (var_28h != 0) {\n                iVar7 = var_20h + 0x14;\n                uVar8 = var_28h;\n                do {\n                    fcn.00401470(*(iVar7 + -4));\n                    iVar7 = iVar7 + 0x28;\n                    uVar8 = uVar8 - 1;\n                } while (uVar8 != 0);\n            }\n        }\n        var_1ch = var_1ch + 0x18;\n        fcn.00401790(var_1ch);\n        puVar3 = lpModuleName + iVar1;\n        lpModuleName = puVar3 + 6;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0x40203c);\n        pcVar6 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        *puVar3 = uVar4;\n        uVar5 = (*pcVar6)(uVar4, 0x402048);\n        puVar3[3] = uVar5;\n        uVar5 = (*pcVar6)(uVar4, 0x402058);\n        puVar3[2] = uVar5;\n        uVar4 = (*pcVar6)(uVar4, 0x402068);\n        puVar3[1] = uVar4;\n        puVar3[4] = lpModuleName - puVar3;\n        puVar3[5] = var_18h;\n        fcn.00401470(var_18h);\n        iVar7 = var_4h;\n        iVar1 = *(var_1ch + 0x60) + var_4h;\n        uVar8 = 1 - *(iVar1 + 0x10);\n        if (uVar8 < *(iVar1 + 0x14)) {\n            pcVar6 = fcn.00401830(*(var_1ch + 100), iVar1, uVar8);\n        }\n        else {\n            pcVar6 = NULL;\n        }\n        (*pcVar6)(iVar7);\n        (*_sym.imp.KERNEL32.dll_VirtualFree)(iVar7, 0, 0x8000);\n    }\n    fcn.00401460();\n    fcn.00401460();\n    return 1;\n}\n",
        "token_count": 1240
    },
    "00401470": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401470(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uchar *puVar2;\n    uint *in_ECX;\n    uint32_t uVar3;\n    int32_t in_EDX;\n    uint *puVar4;\n    int32_t iVar5;\n    uint var_4h;\n    \n    uVar1 = arg_8h >> 2;\n    if (uVar1 != 0) {\n        uVar3 = uVar1;\n        puVar4 = in_ECX;\n        do {\n            *puVar4 = *((in_EDX - in_ECX) + puVar4);\n            puVar4 = puVar4 + 1;\n            uVar3 = uVar3 - 1;\n        } while (uVar3 != 0);\n    }\n    if ((arg_8h & 0xfffffffc) < arg_8h) {\n        puVar2 = (arg_8h & 0xfffffffc) + in_ECX;\n        iVar5 = arg_8h + uVar1 * -4;\n        do {\n            *puVar2 = puVar2[in_EDX - in_ECX];\n            puVar2 = puVar2 + 1;\n            iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n    }\n    return;\n}\n",
        "token_count": 296
    },
    "004014d0": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004014d0(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint8_t uVar1;\n    uint32_t *in_ECX;\n    uint32_t in_EDX;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    uVar3 = in_EDX & 3;\n    for (uVar2 = in_EDX >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {\n        uVar1 = arg_ch + uVar2 & 0x1f;\n        *in_ECX = ((*in_ECX >> uVar1 | *in_ECX << 0x20 - uVar1) ^ arg_8h) - uVar2;\n        in_ECX = in_ECX + 1;\n    }\n    for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *in_ECX = *in_ECX ^ arg_8h;\n        in_ECX = in_ECX + 1;\n    }\n    return;\n}\n",
        "token_count": 239
    },
    "00401690": {
        "rules": [
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8",
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401690(uint *arg_8h, uint32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint32_t *puVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    uint32_t *puVar5;\n    uint8_t *puVar6;\n    uint32_t *puVar7;\n    uint32_t in_EDX;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x403000, 0);\n    uVar9 = in_EDX >> 2;\n    if (uVar9 != 0) {\n        puVar5 = puVar3;\n        do {\n            *puVar5 = *((in_ECX - puVar3) + puVar5);\n            puVar5 = puVar5 + 1;\n            uVar9 = uVar9 - 1;\n        } while (uVar9 != 0);\n    }\n    uVar9 = in_EDX & 0xfffffffc;\n    if (uVar9 < in_EDX) {\n        puVar6 = uVar9 + puVar3;\n        iVar8 = in_EDX - uVar9;\n        do {\n            *puVar6 = puVar6[in_ECX - puVar3];\n            puVar6 = puVar6 + 1;\n            iVar8 = iVar8 + -1;\n        } while (iVar8 != 0);\n    }\n    puVar7 = puVar3 + (in_EDX - 8);\n    uVar9 = puVar7[1];\n    uVar1 = *puVar7;\n    uVar11 = in_EDX - 8 & 3;\n    puVar5 = puVar3;\n    for (uVar10 = in_EDX - 8 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {\n        uVar2 = uVar10 + uVar9 & 0x1f;\n        *puVar5 = ((*puVar5 >> uVar2 | *puVar5 << 0x20 - uVar2) ^ uVar1) - uVar10;\n        puVar5 = puVar5 + 1;\n    }\n    for (; uVar11 != 0; uVar11 = uVar11 - 1) {\n        *puVar5 = *puVar5 ^ uVar1;\n        puVar5 = puVar5 + 1;\n    }\n    uVar9 = puVar7[-1];\n    uVar4 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x403000, 0, uVar9);\n    fcn.00401000();\n    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x403000, 0, puVar3);\n    *arg_ch = uVar9;\n    *arg_8h = uVar4;\n    return;\n}\n",
        "token_count": 712
    },
    "00401830": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401830(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint32_t in_EDX;\n    \n    uVar1 = *(*(arg_ch + 0x1c) + arg_10h * 4 + in_ECX);\n    if ((in_EDX <= uVar1) && (uVar1 < arg_8h + in_EDX)) {\n        return 0;\n    }\n    return uVar1 + in_ECX;\n}\n",
        "token_count": 134
    },
    "00401191": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00401191(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = 1;\n    do {\n        iVar1 = fcn.004011b2();\n        iVar2 = iVar1 + iVar2 * 2;\n        iVar1 = fcn.004011b2();\n    } while (iVar1 != 0);\n    return iVar2;\n}\n",
        "token_count": 91
    },
    "null": {
        "rules": [
            "terminate process"
        ],
        "decompiled_code": "\nuint entry0(void)\n\n{\n    uint uVar1;\n    \n    *0x403000 = (*_sym.imp.KERNEL32.dll_GetProcessHeap)();\n    fcn.0040120f();\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1, 0);\n    return 0;\n}\n",
        "token_count": 86
    }
}