{
    "0040348b": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040348b(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != '\\0') {\n        fcn.00403597(*(param_1 + 4));\n    }\n    *(param_1 + 4) = 0;\n    *(param_1 + 8) = 0;\n    return;\n}\n",
        "token_count": 81
    },
    "null": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong __cdecl\nmethod.std::basic_streambuf_char__struct_std::char_traits_char__.virtual_32\n          (uchar *arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t arg_10h_00;\n    int32_t *in_ECX;\n    int32_t iVar1;\n    bool bVar2;\n    uint32_t uStack16;\n    int32_t iStack12;\n    \n    uStack16 = 0;\n    iStack12 = 0;\n    if ((-1 < arg_10h) && ((0 < arg_10h || (arg_ch != 0)))) {\n        do {\n            arg_10h_00 = 0;\n            if (*in_ECX[8] != 0) {\n                arg_10h_00 = *in_ECX[0xc];\n            }\n            iVar1 = arg_10h_00 >> 0x1f;\n            if ((iVar1 < 0) || ((-1 < arg_10h_00 || iVar1 < 0 && (arg_10h_00 == 0)))) {\n                iVar1 = (**(*in_ECX + 0x1c))();\n                if (iVar1 == -1) break;\n                bVar2 = 0xfffffffe < uStack16;\n                uStack16 = uStack16 + 1;\n                *arg_8h = iVar1;\n                iStack12 = iStack12 + bVar2;\n                bVar2 = arg_ch != 0;\n                arg_ch = arg_ch - 1;\n                arg_10h = arg_10h + -1 + bVar2;\n                arg_8h = arg_8h + 1;\n            }\n            else {\n                if ((arg_10h <= iVar1) && ((arg_10h < iVar1 || (arg_ch < arg_10h_00)))) {\n                    iVar1 = arg_10h;\n                    arg_10h_00 = arg_ch;\n                }\n                fcn.004030c0(arg_8h, *in_ECX[8], arg_10h_00);\n                bVar2 = CARRY4(uStack16, arg_10h_00);\n                uStack16 = uStack16 + arg_10h_00;\n                iStack12 = iStack12 + iVar1 + bVar2;\n                bVar2 = arg_ch < arg_10h_00;\n                arg_ch = arg_ch - arg_10h_00;\n                arg_10h = (arg_10h - iVar1) - bVar2;\n                *in_ECX[0xc] = *in_ECX[0xc] - arg_10h_00;\n                *in_ECX[8] = *in_ECX[8] + arg_10h_00;\n                arg_8h = arg_8h + arg_10h_00;\n            }\n            if ((arg_10h < 1) && ((arg_10h < 0 || (arg_ch == 0)))) break;\n        } while( true );\n    }\n    return CONCAT44(iStack12, uStack16);\n}\n",
        "token_count": 682
    },
    "00403597": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403597(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    \n    if (arg_8h != 0) {\n        iVar1 = (**0x40e084)(*0x41465c, 0, arg_8h);\n        if (iVar1 == 0) {\n            puVar2 = fcn.00405ab3();\n            uVar3 = (**0x40e080)();\n            uVar3 = fcn.00405a71(uVar3);\n            *puVar2 = uVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 146
    },
    "00403dc3": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00403dc3(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h, uint arg_ch, uint noname_17, uint noname_18, uint arg_18h, uint arg_1ch, \n            uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_38h;\n    uint *var_34h;\n    uint var_30h;\n    code *var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc0;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x403e6e;\n        var_38h = 1;\n    }\n    else {\n        pcStack40 = fcn.00403e9a;\n        uStack36 = *0x4133d0 ^ &fcn.00403dc3::var_28h_2;\n        uStack32 = var_24h;\n        puStack28 = var_ch_2;\n        uStack24 = var_20h;\n        uStack20 = var_1ch;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.00403dc3::var_28h_2;\n        var_34h = var_8h_3;\n        var_30h = var_10h_2;\n        iVar1 = fcn.00406b1a();\n        var_2ch = *(iVar1 + 0x80);\n        (*var_2ch)(*var_8h_3, &fcn.00403dc3::var_34h);\n        var_38h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_38h;\n}\n",
        "token_count": 727
    },
    "004040b1": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004040b1(uint arg_8h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    int32_t in_ECX;\n    uint in_EDX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    ushort in_DS;\n    ushort in_FS;\n    ushort in_GS;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint unaff_retaddr;\n    int32_t var_328h;\n    uint var_324h;\n    uint var_320h;\n    \n    if (in_ECX == *0x4133d0) {\n        return;\n    }\n    *0x414f00 = (in_NT & 1) * 0x4000 | SBORROW4(&stack0xfffffffc, 0x328) * 0x800 | (in_IF & 1) * 0x200 |\n                (in_TF & 1) * 0x100 | (&var_328h < 0) * 0x80 | (*0x10 == 0x32c) * 0x40 | (in_AF & 1) * 0x10 |\n                ((POPCOUNT(&var_328h & 0xff) & 1U) == 0) * 4 | &stack0xfffffffc < 0x328 | (in_ID & 1) * 0x200000 |\n                (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n    *0x414f04 = &arg_8h;\n    *0x414e40 = 0x10001;\n    *0x414de8 = 0xc0000409;\n    *0x414dec = 1;\n    var_328h = *0x4133d0;\n    var_324h = *0x4133d4;\n    *0x414df4 = unaff_retaddr;\n    *0x414ecc = in_GS;\n    *0x414ed0 = in_FS;\n    *0x414ed4 = in_ES;\n    *0x414ed8 = in_DS;\n    *0x414edc = unaff_EDI;\n    *0x414ee0 = unaff_ESI;\n    *0x414ee4 = unaff_EBX;\n    *0x414ee8 = in_EDX;\n    *0x414eec = in_ECX;\n    *0x414ef0 = in_EAX;\n    *0x414ef4 = unaff_EBP;\n    *0x414ef8 = unaff_retaddr;\n    *0x414efc = in_CS;\n    *0x414f08 = in_SS;\n    *0x414e38 = (**0x40e124)();\n    fcn.0040cf77(1);\n    (**0x40e0b8)(0);\n    (**0x40e120)(0x40f7d0);\n    if (*0x414e38 == 0) {\n        fcn.0040cf77(1);\n    }\n    uVar1 = (**0x40e11c)(0xc0000409);\n    (**0x40e118)(uVar1);\n    return;\n}\n",
        "token_count": 803
    },
    "00405db2": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00405eb8: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00405ebd)\n// WARNING: Removing unreachable block (ram,0x00405eec)\n// WARNING: Removing unreachable block (ram,0x00405ec3)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00405db2(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t unaff_EBP;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00406de0(0x411b90, 0x20);\n    fcn.00409add(8);\n    *(unaff_EBP + -4) = 0;\n    pcVar1 = *0x40e068;\n    if (*0x41469c != 1) {\n        *0x414698 = 1;\n        *0x414694 = *(unaff_EBP + 0x10);\n        if (*(unaff_EBP + 0xc) == 0) {\n            piVar2 = (**0x40e068)(*0xa97a548);\n            *(unaff_EBP + -0x30) = piVar2;\n            if (piVar2 != NULL) {\n                piVar3 = (*pcVar1)(*0xa97a544);\n                *(unaff_EBP + -0x2c) = piVar3;\n                *(unaff_EBP + -0x24) = piVar2;\n                *(unaff_EBP + -0x28) = piVar3;\n                while( true ) {\n                    piVar3 = piVar3 + -1;\n                    *(unaff_EBP + -0x2c) = piVar3;\n                    if (piVar3 < piVar2) break;\n                    iVar4 = fcn.0040696a();\n                    if (*piVar3 != iVar4) {\n                        if (piVar3 < piVar2) break;\n                        pcVar5 = (*pcVar1)(*piVar3);\n                        iVar4 = fcn.0040696a();\n                        *piVar3 = iVar4;\n                        (*pcVar5)();\n                        iVar4 = (*pcVar1)(*0xa97a548);\n                        piVar2 = (*pcVar1)(*0xa97a544);\n                        if ((*(unaff_EBP + -0x24) != iVar4) || (*(unaff_EBP + -0x28) != piVar2)) {\n                            *(unaff_EBP + -0x24) = iVar4;\n                            *(unaff_EBP + -0x30) = iVar4;\n                            *(unaff_EBP + -0x28) = piVar2;\n                            *(unaff_EBP + -0x2c) = piVar2;\n                            piVar3 = piVar2;\n                        }\n                        piVar2 = *(unaff_EBP + -0x30);\n                    }\n                }\n            }\n            *(unaff_EBP + -0x1c) = 0x40e1a8;\n            while (*(unaff_EBP + -0x1c) < 0x40e1ac) {\n                if (**(unaff_EBP + -0x1c) != NULL) {\n                    (***(unaff_EBP + -0x1c))();\n                }\n                *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n            }\n        }\n        *(unaff_EBP + -0x20) = 0x40e1b0;\n        while (*(unaff_EBP + -0x20) < 0x40e1b4) {\n            if (**(unaff_EBP + -0x20) != NULL) {\n                (***(unaff_EBP + -0x20))();\n            }\n            *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 4;\n        }\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.00409a04(8);\n    }\n    return;\n}\n",
        "token_count": 1009
    },
    "00407305": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00407305(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00406de0(0x411c00, 0x10);\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar2 = *(unaff_EBP + 8);\n    if (*(iVar1 + 4) < 0x81) {\n        iVar5 = *(iVar2 + 8);\n    }\n    else {\n        iVar5 = *(iVar2 + 8);\n    }\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar4 = fcn.00406b1a();\n    *(iVar4 + 0x90) = *(iVar4 + 0x90) + 1;\n    *(unaff_EBP + -4) = 0;\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar1 + 4) <= iVar5)) {\n            fcn.00407f4e();\n        }\n        iVar4 = *(iVar1 + 8);\n        iVar3 = *(iVar4 + iVar5 * 8);\n        *(unaff_EBP + -0x20) = iVar3;\n        *(unaff_EBP + -4) = 1;\n        if (*(iVar4 + 4 + iVar5 * 8) != 0) {\n            *(iVar2 + 8) = iVar3;\n            fcn.00407fa0(*(*(iVar1 + 8) + 4 + iVar5 * 8), iVar2, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar3;\n        iVar5 = iVar3;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.004073c7();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.00407f4e();\n    }\n    *(iVar2 + 8) = iVar5;\n    fcn.00406e25();\n    return;\n}\n",
        "token_count": 573
    },
    "004073c7": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.004073c7(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00406b1a();\n    if (0 < *(iVar1 + 0x90)) {\n        iVar1 = fcn.00406b1a();\n        *(iVar1 + 0x90) = *(iVar1 + 0x90) + -1;\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "0040768e": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040768e(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_1ch;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x24);\n    fcn.00403fff(*(unaff_EBP + -0x28));\n    iVar1 = fcn.00406b1a();\n    *(iVar1 + 0x88) = *(unaff_EBP + -0x2c);\n    iVar1 = fcn.00406b1a();\n    *(iVar1 + 0x8c) = *(unaff_EBP + -0x30);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((iVar1 = unaff_ESI[5],  iVar1 == 0x19930520 || ((iVar1 == 0x19930521 || (iVar1 == 0x19930522)))))) &&\n       ((*(unaff_EBP + -0x34) == 0 && (*(unaff_EBP + -0x1c) != 0)))) {\n        iVar1 = fcn.00403fd8(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.00407426(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 382
    },
    "0040c61c": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.0040c61c(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) != 0) {\n        fcn.00409a04(0);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "0040c93c": {
        "rules": [
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0040c93c(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code *pcVar4;\n    code *pcVar5;\n    code *pcVar6;\n    uint unaff_EBX;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = *0x4133d0 ^ &stack0xfffffffc;\n    var_20h = arg_8h;\n    var_1ch = arg_ch;\n    var_18h = fcn.0040696a();\n    var_14h = 0;\n    if (*0x4152dc == 0) {\n        iVar1 = (**0x40e130)(L\"USER32.DLL\");\n        pcVar6 = *0x40e0bc;\n        if ((iVar1 == 0) || (iVar2 = (**0x40e0bc)(iVar1, \"MessageBoxW\"),  pcVar4 = *0x40e064,  iVar2 == 0))\n        goto code_r0x0040ca99;\n        *0x4152dc = (**0x40e064)(iVar2);\n        uVar3 = (*pcVar6)(iVar1, \"GetActiveWindow\");\n        *0x4152e0 = (*pcVar4)(uVar3);\n        uVar3 = (*pcVar6)(iVar1, \"GetLastActivePopup\");\n        *0x4152e4 = (*pcVar4)(uVar3);\n        uVar3 = (*pcVar6)(iVar1, \"GetUserObjectInformationW\");\n        *0x4152ec = (*pcVar4)(uVar3);\n        if (*0x4152ec != 0) {\n            uVar3 = (*pcVar6)(iVar1, \"GetProcessWindowStation\");\n            *0x4152e8 = (*pcVar4)(uVar3);\n        }\n    }\n    pcVar6 = *0x40e068;\n    if ((*0x4152e8 == var_18h) || (*0x4152ec == var_18h)) {\ncode_r0x0040ca48:\n        if ((((*0x4152e0 != var_18h) && (pcVar4 = (*pcVar6)(*0x4152e0),  pcVar4 != NULL)) &&\n            (var_14h = (*pcVar4)(),  var_14h != 0)) &&\n           ((*0x4152e4 != var_18h && (pcVar4 = (*pcVar6)(*0x4152e4),  pcVar4 != NULL)))) {\n            var_14h = (*pcVar4)(var_14h);\n        }\n    }\n    else {\n        pcVar4 = (**0x40e068)(*0x4152e8);\n        pcVar5 = (*pcVar6)(*0x4152ec);\n        if (((pcVar4 == NULL) || (pcVar5 == NULL)) ||\n           (((iVar1 = (*pcVar4)(),  iVar1 != 0 && (iVar1 = (*pcVar5)(iVar1, 1, &var_10h, 0xc, &var_24h),  iVar1 != 0))\n            && ((var_8h & 1) != 0)))) goto code_r0x0040ca48;\n        arg_10h = arg_10h | 0x200000;\n    }\n    pcVar6 = (*pcVar6)(*0x4152dc);\n    if (pcVar6 != NULL) {\n        (*pcVar6)(var_14h, var_20h, var_1ch, arg_10h);\n    }\ncode_r0x0040ca99:\n    fcn.004040b1(unaff_EBX);\n    return;\n}\n",
        "token_count": 910
    },
    "004011b0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004011b0(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    code **ppcVar1;\n    code **ppcVar2;\n    int32_t arg_8h_00;\n    uint var_38h;\n    uint var_14h;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    if ((arg_8h != NULL) && (*arg_8h == 0)) {\n        ppcVar1 = fcn.004036d2(0x18);\n        if (ppcVar1 == NULL) {\n            ppcVar1 = NULL;\n        }\n        else {\n            arg_8h_00 = *(*arg_ch + 0x18);\n            var_4h = 1;\n            if (arg_8h_00 == 0) {\n                arg_8h_00 = *arg_ch + 0x1c;\n            }\n            fcn.00401035(arg_8h_00);\n            ppcVar1[1] = NULL;\n            *ppcVar1 = vtable.std::ctype_char_.0;\n            ppcVar2 = fcn.00402dd3(&var_14h);\n            ppcVar1[2] = *ppcVar2;\n            ppcVar1[3] = ppcVar2[1];\n            ppcVar1[4] = ppcVar2[2];\n            ppcVar1[5] = ppcVar2[3];\n        }\n        *arg_8h = ppcVar1;\n        if ((var_4h & 1) != 0) {\n            fcn.0040109d();\n        }\n    }\n    return 2;\n}\n",
        "token_count": 383
    },
    "00401a52": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401a52(code **param_1)\n\n{\n    uint unaff_ESI;\n    code *pcVar1;\n    \n    *param_1 = vtable.std::basic_stringbuf_char__struct_std::char_traits_char___class_std::allocator_char__.0;\n    if ((*(param_1 + 0x10) & 1) != 0) {\n        fcn.00403676(*param_1[4]);\n    }\n    *param_1[4] = 0;\n    *param_1[8] = 0;\n    *param_1[0xc] = 0;\n    *param_1[5] = 0;\n    *param_1[9] = 0;\n    *param_1[0xd] = 0;\n    param_1[0x10] = param_1[0x10] & 0xfffffffe;\n    param_1[0xf] = NULL;\n    pcVar1 = param_1[0xe];\n    *param_1 = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    if (pcVar1 != NULL) {\n        fcn.00401178();\n        fcn.00403676(pcVar1);\n    }\n    pcVar1 = param_1[1];\n    fcn.0040308a(pcVar1);\n    fcn.00403676(param_1[1], pcVar1, unaff_ESI);\n    return;\n}\n",
        "token_count": 326
    },
    "00401136": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00401136(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    fcn.00402c44(0);\n    iVar1 = *(param_1 + 4);\n    if ((iVar1 != 0) && (iVar1 != -1)) {\n        *(param_1 + 4) = iVar1 + -1;\n    }\n    iVar1 = *(param_1 + 4);\n    fcn.00402c6c();\n    return ~-(iVar1 != 0) & param_1;\n}\n",
        "token_count": 132
    },
    "0040209c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040209c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *var_ch;\n    \n    if ((arg_8h != 0) && (iVar1 = fcn.004036d2(arg_8h),  iVar1 == 0)) {\n        arg_8h = 0;\n        fcn.004034a9(&arg_8h);\n        var_ch = vtable.std::bad_alloc.0;\n        fcn.00403c81(&var_ch, 0x411f4c);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "00402217": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00402217(int32_t *arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t arg_8h_00;\n    uint var_18h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.00402c44(0);\n    iVar3 = *0xa97a42c;\n    var_4h = *0xa97a42c;\n    if (*0x414568 == 0) {\n        fcn.00402c44(0);\n        if (*0x414568 == 0) {\n            *0x414564 = *0x414564 + 1;\n            *0x414568 = *0x414564;\n        }\n        fcn.00402c6c();\n    }\n    uVar1 = *0x414568;\n    iVar2 = *arg_8h;\n    if (*0x414568 < *(iVar2 + 0xc)) {\n        arg_8h_00 = *(*(iVar2 + 8) + *0x414568 * 4);\n    }\n    else {\n        arg_8h_00 = 0;\n    }\n    if ((arg_8h_00 == 0) && (*(iVar2 + 0x14) != '\\0')) {\n        iVar2 = fcn.0040291a();\n        if (uVar1 < *(iVar2 + 0xc)) {\n            arg_8h_00 = *(*(iVar2 + 8) + uVar1 * 4);\n        }\n        else {\n            arg_8h_00 = 0;\n        }\n    }\n    if ((arg_8h_00 == 0) && (arg_8h_00 = iVar3,  iVar3 == 0)) {\n        iVar3 = fcn.004011b0(&var_4h, arg_8h);\n        if (iVar3 == -1) {\n            fcn.00403510(\"bad cast\");\n            fcn.00403c81(&var_18h, 0x411f14);\n        }\n        arg_8h_00 = var_4h;\n        *0xa97a42c = var_4h;\n        fcn.0040110e();\n        fcn.004028a3(arg_8h_00);\n    }\n    fcn.00402c6c();\n    return arg_8h_00;\n}\n",
        "token_count": 553
    },
    "00401035": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401035(char *arg_8h)\n\n{\n    int32_t unaff_ESI;\n    code *var_ch;\n    \n    fcn.00402c44(0);\n    *(unaff_ESI + 4) = 0;\n    *(unaff_ESI + 8) = 0;\n    *(unaff_ESI + 0xc) = 0;\n    *(unaff_ESI + 0x10) = 0;\n    *(unaff_ESI + 0x14) = 0;\n    *(unaff_ESI + 0x18) = 0;\n    *(unaff_ESI + 0x1c) = 0;\n    *(unaff_ESI + 0x20) = 0;\n    if (arg_8h == NULL) {\n        arg_8h = \"bad locale name\";\n        fcn.004034a9(&arg_8h);\n        var_ch = vtable.std::runtime_error.0;\n        fcn.00403c81(&var_ch, 0x411e80);\n    }\n    fcn.00402a6b(unaff_ESI, arg_8h);\n    return;\n}\n",
        "token_count": 262
    },
    "004020e5": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.004020e5(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    code **unaff_ESI;\n    \n    *unaff_ESI = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    fcn.00402c83();\n    puVar1 = fcn.004036d2(4);\n    if (puVar1 == NULL) {\n        puVar1 = NULL;\n    }\n    else {\n        uVar2 = fcn.00402b5b();\n        *puVar1 = uVar2;\n        fcn.0040291a();\n        fcn.0040110e();\n    }\n    unaff_ESI[0xe] = puVar1;\n    unaff_ESI[8] = unaff_ESI + 6;\n    unaff_ESI[9] = unaff_ESI + 7;\n    unaff_ESI[4] = unaff_ESI + 2;\n    unaff_ESI[0xc] = unaff_ESI + 10;\n    unaff_ESI[5] = unaff_ESI + 3;\n    unaff_ESI[0xd] = unaff_ESI + 0xb;\n    unaff_ESI[3] = NULL;\n    *unaff_ESI[9] = 0;\n    *unaff_ESI[0xd] = 0;\n    *unaff_ESI[4] = 0;\n    *unaff_ESI[8] = 0;\n    *unaff_ESI[0xc] = 0;\n    return;\n}\n",
        "token_count": 350
    },
    "00402165": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402165(uint arg_8h)\n\n{\n    uchar uVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t unaff_ESI;\n    \n    *(unaff_ESI + 0x30) = 0;\n    *(unaff_ESI + 8) = 0;\n    *(unaff_ESI + 0x10) = 0;\n    *(unaff_ESI + 0x14) = 0x201;\n    *(unaff_ESI + 0x18) = 6;\n    *(unaff_ESI + 0x1c) = 0;\n    *(unaff_ESI + 0x20) = 0;\n    *(unaff_ESI + 0x24) = 0;\n    *(unaff_ESI + 0x28) = 0;\n    *(unaff_ESI + 0x2c) = 0;\n    *(unaff_ESI + 0xc) = 0;\n    puVar2 = fcn.004036d2(4);\n    if (puVar2 == NULL) {\n        puVar2 = NULL;\n    }\n    else {\n        uVar3 = fcn.00402b5b();\n        *puVar2 = uVar3;\n        fcn.0040291a();\n        fcn.0040110e();\n    }\n    *(unaff_ESI + 0x38) = arg_8h;\n    *(unaff_ESI + 0x30) = puVar2;\n    *(unaff_ESI + 0x3c) = 0;\n    arg_8h = *puVar2;\n    fcn.0040110e();\n    piVar4 = fcn.00402217(&arg_8h);\n    fcn.00401178();\n    uVar1 = (**(*piVar4 + 0x18))(0x20);\n    *(unaff_ESI + 0x40) = uVar1;\n    if ((*(unaff_ESI + 0x38) == 0) &&\n       (uVar5 = *(unaff_ESI + 0xc) & 0x17 | 4,  *(unaff_ESI + 0xc) = uVar5,  (*(unaff_ESI + 0x10) & uVar5) != 0)) {\n        fcn.00401355();\n    }\n    return;\n}\n",
        "token_count": 551
    },
    "00404fde": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404fde(int32_t arg_8h)\n\n{\n    if ((arg_8h != 0) && (*(arg_8h + -8) == 0xdddd)) {\n        fcn.00403597(arg_8h + -8);\n    }\n    return;\n}\n",
        "token_count": 69
    },
    "00402c6c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402c6c(int32_t *param_1)\n\n{\n    if (*param_1 < 4) {\n        fcn.004030aa(*param_1 * 0x18 + 0x414588);\n    }\n    return;\n}\n",
        "token_count": 61
    },
    "0040144e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "hash data using fnv/71d430608aea45068f0f63fc2cdc3004"
        ],
        "decompiled_code": "\nvoid fcn.0040144e(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = *0x4621e8;\n    iVar2 = *0x4140c0;\n    var_4h = *0xa97a424;\n    (**0x40e14c)(0, 0, 0, 0);\n    *0x4621e4 = iVar2;\n    iVar2 = 0;\n    if (0 < var_4h) {\n        do {\n            if (iVar2 < 0xe37) {\n                (**0x40e044)(0, 0, 0);\n                (**0x40e144)(0, 0);\n            }\n            *0x4621e4 = *0x4621e4 * 0x343fd + 0x269ec3;\n            (**0x40e158)(0, &var_8h);\n            *(iVar2 + iVar1) = *(iVar2 + iVar1) ^ *0x4621e6;\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < var_4h);\n    }\n    return;\n}\n",
        "token_count": 275
    },
    "00401984": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00401984(void)\n\n{\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    *unaff_EDI = 0x410f88;\n    unaff_EDI[4] = 0x410f90;\n    unaff_EDI[0x18] = vtable.std::basic_ios_char__struct_std::char_traits_char__.0;\n    *(unaff_EDI + *(*unaff_EDI + 4)) = vtable.std::basic_istream_char__struct_std::char_traits_char__.0;\n    unaff_EDI[2] = 0;\n    unaff_EDI[3] = 0;\n    fcn.00402165(unaff_EDI + 6);\n    *(unaff_EDI + *(unaff_EDI[4] + 4) + 0x10) = vtable.std::basic_ostream_char__struct_std::char_traits_char__.0;\n    *(unaff_EDI + *(*unaff_EDI + 4)) = vtable.std::basic_iostream_char__struct_std::char_traits_char__.0;\n    *(unaff_EDI + *(*unaff_EDI + 4)) =\n         vtable.std::basic_stringstream_char__struct_std::char_traits_char___class_std::allocator_char__.0;\n    fcn.004020e5();\n    unaff_EDI[0x15] = 0;\n    unaff_EDI[0x16] = 0;\n    unaff_EDI[6] = vtable.std::basic_stringbuf_char__struct_std::char_traits_char___class_std::allocator_char__.0;\n    return;\n}\n",
        "token_count": 356
    },
    "00402506": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00402506(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t arg_10h;\n    uint uVar3;\n    uint *puVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar5;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    \n    fcn.004040f3(0xc);\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    uVar5 = *(unaff_EBP + 8) | 0xf;\n    if (uVar5 == 0xffffffff) {\n        uVar5 = *(unaff_EBP + 8);\n    }\n    else {\n        uVar1 = extraout_ECX[5];\n        *(unaff_EBP + -0x14) = uVar1;\n        *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) >> 1;\n        uVar2 = *(unaff_EBP + -0x14);\n        if ((uVar5 / 3 < uVar2) && (uVar5 = 0xfffffffe,  uVar1 <= -uVar2 - 2)) {\n            uVar5 = uVar2 + uVar1;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar3 = fcn.0040239e(uVar5 + 1);\n    *(unaff_EBP + 8) = uVar3;\n    arg_10h = *(unaff_EBP + 0xc);\n    if (arg_10h != 0) {\n        puVar4 = extraout_ECX;\n        if (0xf < extraout_ECX[5]) {\n            puVar4 = *extraout_ECX;\n        }\n        fcn.004030c0(*(unaff_EBP + 8), puVar4, arg_10h);\n    }\n    fcn.004024c0(1, 0);\n    puVar4 = *(unaff_EBP + 8);\n    *extraout_ECX = puVar4;\n    extraout_ECX[5] = uVar5;\n    extraout_ECX[4] = arg_10h;\n    if (uVar5 < 0x10) {\n        puVar4 = extraout_ECX;\n    }\n    *(puVar4 + arg_10h) = 0;\n    fcn.00404129();\n    return;\n}\n",
        "token_count": 590
    },
    "00405ef2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405ef2(uint arg_8h)\n\n{\n    fcn.00405db2(arg_8h, 0, 0);\n    return;\n}\n",
        "token_count": 41
    },
    "0040691e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00406932)\n// WARNING: Removing unreachable block (ram,0x00406938)\n// WARNING: Removing unreachable block (ram,0x0040693a)\n\nvoid fcn.0040691e(void)\n\n{\n    return;\n}\n",
        "token_count": 62
    },
    "00403d5a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403d5a(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00407e1c(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 113
    },
    "0a9b69d2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b69d2(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b69d8. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x7da))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b69df": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b69df(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b69e5. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x7e3))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b69ec": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b69ec(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b69f2. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x7ec))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b69f9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b69f9(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b69ff. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x7f5))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a06": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a06(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a0c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x7fe))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6a13": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a13(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a19. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x807))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6a20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a20(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a26. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x810))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6a2d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a2d(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a33. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x819))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a3a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a3a(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a40. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x822))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a47": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a47(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a4d. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x82b))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6a54": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a54(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a5a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x834))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a61": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a61(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a67. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x83d))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a6e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a6e(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a74. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x846))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a7b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a7b(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a81. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x84f))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6a88": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a88(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a8e. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x858))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6a95": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6a95(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6a9b. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x861))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6aa2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6aa2(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6aa8. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x86a))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6aaf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6aaf(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6ab5. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x873))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6abc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6abc(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6ac2. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x87c))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6ac9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6ac9(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6acf. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x885))();\n    return;\n}\n",
        "token_count": 79
    },
    "0a9b6ad6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6ad6(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6adc. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x88e))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6ae3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6ae3(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6ae9. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x897))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6af0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6af0(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6af6. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8a0))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6afd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6afd(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b03. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8a9))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6b0a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b0a(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b10. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8b2))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6b17": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b17(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b1d. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8bb))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6b24": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b24(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b2a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8c4))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6b31": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b31(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b37. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8cd))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6b3e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b3e(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b44. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8d6))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6b4b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b4b(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b51. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8df))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6b58": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b58(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b5e. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8e8))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6b65": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b65(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b6b. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x8f1))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6b7f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b7f(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b85. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x903))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6b8c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b8c(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b92. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x90c))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6b99": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6b99(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6b9f. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x915))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6ba6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6ba6(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6bac. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x91e))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6bb3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6bb3(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6bb9. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x927))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6bc0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6bc0(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6bc6. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x930))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6bcd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6bcd(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6bd3. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x939))();\n    return;\n}\n",
        "token_count": 79
    },
    "0a9b6bda": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6bda(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6be0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x942))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6be7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6be7(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6bed. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x94b))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6bf4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6bf4(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6bfa. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x954))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6c01": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c01(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c07. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x95d))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6c0e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c0e(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c14. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x966))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6c1b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c1b(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c21. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x96f))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6c28": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c28(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c2e. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x978))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6c35": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c35(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c3b. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x981))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6c42": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c42(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c48. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x98a))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6c4f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c4f(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c55. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x993))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6c5c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c5c(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c62. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x99c))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6c69": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c69(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c6f. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9a5))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6c76": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c76(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c7c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9ae))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6c83": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c83(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c89. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9b7))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6c90": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c90(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6c96. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9c0))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6c9d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6c9d(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6ca3. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9c9))();\n    return;\n}\n",
        "token_count": 83
    },
    "0a9b6caa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6caa(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6cb0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9d2))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6cb7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6cb7(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6cbd. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9db))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6cc4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6cc4(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6cca. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9e4))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6cd1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6cd1(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6cd7. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9ed))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6cde": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6cde(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6ce4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9f6))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6ceb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6ceb(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6cf1. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0x9ff))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6cf8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6cf8(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6cfe. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa08))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6d05": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d05(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d0b. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa11))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6d12": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d12(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d18. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa1a))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6d1f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d1f(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d25. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa23))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6d2c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d2c(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d32. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa2c))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6d39": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d39(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d3f. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa35))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6d46": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d46(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d4c. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa3e))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6d53": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d53(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d59. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa47))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6d60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d60(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d66. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa50))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6d6d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d6d(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d73. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa55))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6d7a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d7a(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d80. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa5e))();\n    return;\n}\n",
        "token_count": 82
    },
    "0a9b6d87": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d87(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d8d. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa67))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6d94": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6d94(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6d9a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa70))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6da1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6da1(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6da7. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa79))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6dae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6dae(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6db4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa82))();\n    return;\n}\n",
        "token_count": 79
    },
    "0a9b6dbb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6dbb(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6dc1. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa8b))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6dc8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6dc8(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6dce. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa90))();\n    return;\n}\n",
        "token_count": 80
    },
    "0a9b6dd5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6dd5(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6ddb. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa99))();\n    return;\n}\n",
        "token_count": 79
    },
    "0a9b6de2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6de2(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6de8. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xa9e))();\n    return;\n}\n",
        "token_count": 81
    },
    "0a9b6def": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0a9b6def(void)\n\n{\n    int32_t unaff_retaddr;\n    \n    // WARNING: Could not recover jumptable at 0x0a9b6df5. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(unaff_retaddr + -0xaa3))();\n    return;\n}\n",
        "token_count": 79
    },
    "00401355": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00401355(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    code *var_18h;\n    uint var_ch;\n    uint var_8h;\n    char *var_4h;\n    \n    uVar1 = *(param_1 + 0x10) & *(param_1 + 0xc);\n    if ((uVar1 & 4) == 0) goto code_r0x0040139f;\n    uVar2 = fcn.00402398();\n    var_4h = \"ios_base::badbit set\";\n    do {\n        while( true ) {\n            fcn.004034a9(&var_4h);\n            var_ch = 1;\n            var_18h = vtable.std::ios_base::failure.0;\n            var_8h = uVar2;\n            uVar1 = fcn.00403c81(&var_18h, 0x411edc);\ncode_r0x0040139f:\n            if ((uVar1 & 2) == 0) break;\n            uVar2 = fcn.00402398();\n            var_4h = \"ios_base::failbit set\";\n        }\n        uVar2 = fcn.00402398();\n        var_4h = \"ios_base::eofbit set\";\n    } while( true );\n}\n",
        "token_count": 304
    },
    "00405ae4": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00405ae4(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *arg_8h_00;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00406de0(0x411b70, 0xc);\n    fcn.00409add(0xe);\n    *(unaff_EBP + -4) = 0;\n    arg_8h_00 = *0x414664;\n    iVar1 = *(unaff_EBP + 8);\n    iVar2 = *(iVar1 + 4);\n    if (iVar2 != 0) {\n        piVar3 = 0x414660;\n        do {\n            piVar4 = piVar3;\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 == NULL) goto code_r0x00405b28;\n            piVar3 = arg_8h_00;\n        } while (*arg_8h_00 != iVar2);\n        piVar4[1] = arg_8h_00[1];\n        fcn.00403597(arg_8h_00);\ncode_r0x00405b28:\n        fcn.00403597(*(iVar1 + 4));\n        *(iVar1 + 4) = 0;\n    }\n    *(unaff_EBP + -4) = 0xfffffffe;\n    fcn.00405b4b();\n    fcn.00406e25();\n    return;\n}\n",
        "token_count": 393
    }
}