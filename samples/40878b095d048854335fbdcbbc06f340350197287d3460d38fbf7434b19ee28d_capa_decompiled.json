{
    "null": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "0040a920": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a920(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (((*(in_ECX + 0x71) & 0x10) != 0) && ((*(in_ECX + 0x6c) & 1) != arg_8h)) {\n        arg_8h = NULL;\n        *(in_ECX + 0x6c) = *(in_ECX + 0x6c) ^ 1;\n        iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x44d8f8, &arg_8h);\n        if (-1 < iVar1) {\n            (**(*arg_8h + 0x14))(arg_8h, 0xfffffd37);\n            (**(*arg_8h + 8))(arg_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 220
    },
    "0040ebb3": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0040ebb3(int32_t noname_0, int32_t noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, \n            uint noname_6, uint noname_7, uint hWnd)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint noname_3_00;\n    uint noname_4_00;\n    uint in_stack_ffffffe0;\n    uint in_stack_ffffffe4;\n    uint32_t noname_2_00;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (noname_1 == 0) {\ncode_r0x0040ec62:\n        noname_2_00 = 0x40ec6b;\n        uVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(*(noname_0 + 0x1c));\n        iVar3 = fcn.00425960();\n        if (iVar3 == 0) {\n            return noname_0;\n        }\n    }\n    else {\n        noname_2_00 = *(noname_1 + 0x1c);\n        uVar2 = (*_sym.imp.USER32.dll_GetWindow)(noname_2_00, 2);\n        noname_0 = unaff_ESI;\n        iVar3 = fcn.00425960(uVar2);\n        while (iVar3 == 0) {\n            in_stack_ffffffe4 = *(noname_1 + 0x1c);\n            in_stack_ffffffe0 = 0x40ebe7;\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)();\n            uVar2 = fcn.00425960(uVar2);\n            noname_1 = fcn.0040eb5a(noname_0, uVar2);\n            if ((noname_1 == 0) || (noname_1 == noname_0)) goto code_r0x0040ec62;\n            noname_2_00 = *(noname_1 + 0x1c);\n            uVar2 = (*pcVar1)(noname_2_00, 2);\n            iVar3 = fcn.00425960(uVar2);\n        }\n        in_stack_ffffffe0 = *(noname_1 + 0x1c);\n        in_stack_ffffffe4 = 2;\n        uVar2 = (*pcVar1)();\n        iVar3 = fcn.00425960();\n    }\n    noname_4_00 = 0xffffffec;\n    noname_3_00 = *(iVar3 + 0x1c);\n    uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    if ((uVar4 & 0x10000) != 0) {\n        if ((((noname_2_00 & 1) == 0) || (iVar5 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x1c)),  iVar5 != 0))\n           && (((noname_2_00 & 2) == 0 || (iVar5 = fcn.0042896a(),  iVar5 != 0)))) {\n            noname_0 = iVar3;\n            iVar3 = 0;\n        }\n        iVar3 = fcn.0040ebb3(noname_0, iVar3, noname_2_00, noname_3_00, noname_4_00, unaff_EBX, uVar2, in_stack_ffffffe0\n                             , in_stack_ffffffe4);\n    }\n    return iVar3;\n}\n",
        "token_count": 840
    },
    "0040ef42": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t fcn.0040ef42(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (param_1 == 0) {\n        return param_1;\n    }\n    iVar1 = *(param_1 + 0x38);\n    if (iVar1 != 0) {\n        if ((*(iVar1 + 0x71) & 0x10) != 0) {\n            return (-((*(iVar1 + 0x6c) & 1) != 0) & 0xfffffff0) + 0x20;\n        }\n        return 0;\n    }\n    uVar2 = fcn.0040eafe(param_1, 0);\n    return uVar2 & 0x30;\n}\n",
        "token_count": 176
    },
    "0041781f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0041781f(uint arg_8h, uint8_t *arg_ch, uint *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint arg_ch_00;\n    int16_t *piVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint8_t uVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    uint64_t uVar11;\n    uint64_t uVar12;\n    uint var_248h;\n    uint var_49h;\n    uint var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    uint var_38h;\n    uint var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uchar var_16h;\n    char var_15h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    var_30h = 0;\n    uVar8 = *arg_ch;\n    arg_ch = arg_ch + 1;\n    var_ch = 0;\n    var_14h = 0;\n    do {\n        if ((uVar8 == 0) || (var_14h < 0)) {\n            return var_14h;\n        }\n        if ((uVar8 < ' ') || ('x' < uVar8)) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = *(uVar8 + 0x44d5a8) & 0xf;\n        }\n        var_30h = *(var_30h + 0x44d5c8 + uVar2 * 8) >> 4;\n    // switch table (8 cases) at 0x417f40\n        switch(var_30h) {\n        case 0:\ncode_r0x004179be:\n            var_24h = 0;\n            if ((*(*0x45d598 + 1 + uVar8 * 2) & 0x80) != 0) {\n                fcn.00417f60(uVar8, arg_8h, &var_14h);\n                uVar8 = *arg_ch;\n                arg_ch = arg_ch + 1;\n            }\n            fcn.00417f60(uVar8, arg_8h, &var_14h);\n            break;\n        case 1:\n            var_10h = -1;\n            var_34h = 0;\n            var_28h = 0;\n            var_20h = 0;\n            var_1ch = 0;\n            var_4h = 0;\n            var_24h = 0;\n            break;\n        case 2:\n            if (uVar8 == 0x20) {\n                var_4h = var_4h | 2;\n            }\n            else if (uVar8 == 0x23) {\n                var_4h = var_4h | 0x80;\n            }\n            else if (uVar8 == 0x2b) {\n                var_4h = var_4h | 1;\n            }\n            else if (uVar8 == 0x2d) {\n                var_4h = var_4h | 4;\n            }\n            else if (uVar8 == 0x30) {\n                var_4h = var_4h | 8;\n            }\n            break;\n        case 3:\n            if (uVar8 == 0x2a) {\n                var_20h = fcn.00417ffe(&arg_10h);\n                if (var_20h < 0) {\n                    var_4h = var_4h | 4;\n                    var_20h = -var_20h;\n                }\n            }\n            else {\n                var_20h = uVar8 + -0x30 + var_20h * 10;\n            }\n            break;\n        case 4:\n            var_10h = 0;\n            break;\n        case 5:\n            if (uVar8 == 0x2a) {\n                var_10h = fcn.00417ffe(&arg_10h);\n                if (var_10h < 0) {\n                    var_10h = -1;\n                }\n            }\n            else {\n                var_10h = uVar8 + -0x30 + var_10h * 10;\n            }\n            break;\n        case 6:\n            if (uVar8 == 0x49) {\n                if ((*arg_ch != 0x36) || (arg_ch[1] != 0x34)) {\n                    var_30h = 0;\n                    goto code_r0x004179be;\n                }\n                arg_ch = arg_ch + 2;\n                var_4h = var_4h | 0x8000;\n            }\n            else if (uVar8 == 0x68) {\n                var_4h = var_4h | 0x20;\n            }\n            else if (uVar8 == 0x6c) {\n                var_4h = var_4h | 0x10;\n            }\n            else if (uVar8 == 0x77) {\n                var_4h = var_4h | 0x800;\n            }\n            break;\n        case 7:\n            puVar4 = var_8h;\n            if (uVar8 < 'h') {\n                if (uVar8 < 'e') {\n                    if (uVar8 < 'Y') {\n                        if (uVar8 == 0x58) {\ncode_r0x00417c9e:\n                            var_2ch = 7;\ncode_r0x00417ca5:\n                            var_ch = 0x10;\n                            if ((var_4h & 0x80) != 0) {\n                                var_16h = 0x30;\n                                var_15h = var_2ch + 'Q';\n                                var_1ch = 2;\n                            }\n                            goto code_r0x00417d0f;\n                        }\n                        if (uVar8 != 0x43) {\n                            if ((uVar8 != 0x45) && (uVar8 != 0x47)) {\n                                if (uVar8 == 0x53) {\n                                    if ((var_4h & 0x830) == 0) {\n                                        var_4h = var_4h | 0x800;\n                                    }\n                                    goto code_r0x00417a4c;\n                                }\n                                goto code_r0x00417e29;\n                            }\n                            var_34h = 1;\n                            uVar8 = uVar8 + 0x20;\n                            goto code_r0x00417aad;\n                        }\n                        if ((var_4h & 0x830) == 0) {\n                            var_4h = var_4h | 0x800;\n                        }\ncode_r0x00417ada:\n                        if ((var_4h & 0x810) == 0) {\n                            var_248h._0_1_ = fcn.00417ffe(&arg_10h);\n                            var_ch = 1;\n                        }\n                        else {\n                            arg_ch_00 = fcn.0041801b();\n                            var_ch = fcn.0041b0db(&var_248h, arg_ch_00);\n                            if (var_ch < 0) {\n                                var_28h = 1;\n                            }\n                        }\n                        puVar4 = &var_248h;\n                    }\n                    else if (uVar8 == 0x5a) {\n                        piVar5 = fcn.00417ffe(&arg_10h);\n                        if ((piVar5 == NULL) || (puVar4 = *(piVar5 + 2),  puVar4 == NULL)) {\n                            var_8h = *0x45d590;\n                            puVar4 = *0x45d590;\n                            goto code_r0x00417c1f;\n                        }\n                        if ((var_4h & 0x800) == 0) {\n                            var_24h = 0;\n                            var_ch = *piVar5;\n                        }\n                        else {\n                            var_ch = *piVar5 >> 1;\n                            var_24h = 1;\n                        }\n                    }\n                    else {\n                        if (uVar8 == 99) goto code_r0x00417ada;\n                        if (uVar8 == 100) goto code_r0x00417d04;\n                    }\n                }\n                else {\ncode_r0x00417aad:\n                    var_4h = var_4h | 0x40;\n                    puVar4 = &var_248h;\n                    if (var_10h < 0) {\n                        var_10h = 6;\n                    }\n                    else if ((var_10h == 0) && (uVar8 == 0x67)) {\n                        var_10h = 1;\n                    }\n                    unique0x00007a00 = *arg_10h;\n                    var_44h = arg_10h[1];\n                    arg_10h = arg_10h + 2;\n                    var_8h = puVar4;\n                    (**0x45d1a8)(&var_49h + 1, &var_248h, uVar8, var_10h, var_34h);\n                    uVar2 = var_4h & 0x80;\n                    if ((uVar2 != 0) && (var_10h == 0)) {\n                        (**0x45d1b4)(&var_248h);\n                    }\n                    if ((uVar8 == 0x67) && (uVar2 == 0)) {\n                        (**0x45d1ac)(&var_248h);\n                    }\n                    if (var_248h == '-') {\n                        var_4h = var_4h | 0x100;\n                        puVar4 = &var_248h + 1;\n                        var_8h = puVar4;\n                    }\ncode_r0x00417c1f:\n                    var_ch = fcn.004101b0(puVar4);\n                    puVar4 = var_8h;\n                }\n            }\n            else {\n                if (uVar8 == 0x69) {\ncode_r0x00417d04:\n                    var_4h = var_4h | 0x40;\n                }\n                else {\n                    if (uVar8 == 0x6e) {\n                        piVar6 = fcn.00417ffe(&arg_10h);\n                        if ((var_4h & 0x20) == 0) {\n                            *piVar6 = var_14h;\n                        }\n                        else {\n                            *piVar6 = var_14h;\n                        }\n                        var_28h = 1;\n                        break;\n                    }\n                    if (uVar8 == 0x6f) {\n                        var_ch = 8;\n                        if ((var_4h & 0x80) != 0) {\n                            var_4h = var_4h | 0x200;\n                        }\n                        goto code_r0x00417d0f;\n                    }\n                    if (uVar8 == 0x70) {\n                        var_10h = 8;\n                        goto code_r0x00417c9e;\n                    }\n                    if (uVar8 == 0x73) {\ncode_r0x00417a4c:\n                        iVar9 = var_10h;\n                        if (var_10h == -1) {\n                            iVar9 = 0x7fffffff;\n                        }\n                        puVar3 = fcn.00417ffe(&arg_10h);\n                        if ((var_4h & 0x810) == 0) {\n                            puVar4 = puVar3;\n                            if (puVar3 == NULL) {\n                                puVar3 = *0x45d590;\n                                puVar4 = *0x45d590;\n                            }\n                            for (; (iVar9 != 0 && (*puVar3 != '\\0')); puVar3 = puVar3 + 1) {\n                                iVar9 = iVar9 + -1;\n                            }\n                            var_ch = puVar3 - puVar4;\n                        }\n                        else {\n                            if (puVar3 == NULL) {\n                                puVar3 = *0x45d594;\n                            }\n                            var_24h = 1;\n                            for (puVar4 = puVar3; (iVar9 != 0 && (*puVar4 != 0)); puVar4 = puVar4 + 2) {\n                                iVar9 = iVar9 + -1;\n                            }\n                            var_ch = puVar4 - puVar3 >> 1;\n                            puVar4 = puVar3;\n                        }\n                        goto code_r0x00417e29;\n                    }\n                    if (uVar8 != 0x75) {\n                        if (uVar8 != 0x78) goto code_r0x00417e29;\n                        var_2ch = 0x27;\n                        goto code_r0x00417ca5;\n                    }\n                }\n                var_ch = 10;\ncode_r0x00417d0f:\n                if ((var_4h & 0x8000) == 0) {\n                    if ((var_4h & 0x20) == 0) {\n                        if ((var_4h & 0x40) == 0) {\n                            uVar2 = fcn.00417ffe(&arg_10h);\n                            uVar11 = uVar2;\n                            goto code_r0x00417d62;\n                        }\n                        uVar2 = fcn.00417ffe(&arg_10h);\n                    }\n                    else if ((var_4h & 0x40) == 0) {\n                        uVar2 = fcn.00417ffe(&arg_10h);\n                        uVar2 = uVar2 & 0xffff;\n                    }\n                    else {\n                        iVar1 = fcn.00417ffe(&arg_10h);\n                        uVar2 = iVar1;\n                    }\n                    uVar11 = uVar2;\n                }\n                else {\n                    uVar11 = fcn.0041800b(&arg_10h);\n                }\ncode_r0x00417d62:\n                if ((((var_4h & 0x40) != 0) && (uVar11 < 0x100000000)) && (uVar11 < 0)) {\n                    uVar11 = CONCAT44(-((uVar11 >> 0x20) + (uVar11 != 0)), -uVar11);\n                    var_4h = var_4h | 0x100;\n                }\n                uVar2 = uVar11 >> 0x20;\n                if ((var_4h & 0x8000) == 0) {\n                    uVar2 = 0;\n                }\n                uVar12 = uVar11 & 0xffffffff | uVar2 << 0x20;\n                if (var_10h < 0) {\n                    var_10h = 1;\n                }\n                else {\n                    var_4h = var_4h & 0xfffffff7;\n                }\n                if ((uVar11 | uVar2) == 0) {\n                    var_1ch = 0;\n                }\n                var_8h = &var_49h;\n                while ((iVar9 = var_10h + -1,  0 < var_10h || (uVar12 != 0))) {\n                    var_3ch = var_ch >> 0x1f;\n                    var_40h = var_ch;\n                    var_10h = iVar9;\n                    iVar9 = fcn.00418e00(uVar12, var_ch, var_3ch);\n                    iVar9 = iVar9 + 0x30;\n                    uVar12 = fcn.00418d90();\n                    if (0x39 < iVar9) {\n                        iVar9 = iVar9 + var_2ch;\n                    }\n                    puVar4 = var_8h + -1;\n                    *var_8h = iVar9;\n                    var_8h = puVar4;\n                }\n                var_ch = &var_49h + -var_8h;\n                puVar4 = var_8h + 1;\n                var_10h = iVar9;\n                if (((var_4h & 0x200) != 0) && ((*puVar4 != '0' || (var_ch == 0)))) {\n                    var_ch = &var_49h + -var_8h + 1;\n                    *var_8h = '0';\n                    puVar4 = var_8h;\n                }\n            }\ncode_r0x00417e29:\n            var_8h = puVar4;\n            uVar2 = var_4h;\n            if (var_28h == 0) {\n                if ((var_4h & 0x40) != 0) {\n                    if ((var_4h & 0x100) == 0) {\n                        if ((var_4h & 1) == 0) {\n                            if ((var_4h & 2) == 0) goto code_r0x00417e61;\n                            var_16h = 0x20;\n                        }\n                        else {\n                            var_16h = 0x2b;\n                        }\n                    }\n                    else {\n                        var_16h = 0x2d;\n                    }\n                    var_1ch = 1;\n                }\ncode_r0x00417e61:\n                iVar9 = (var_20h - var_1ch) - var_ch;\n                if ((var_4h & 0xc) == 0) {\n                    fcn.00417f95(0x20, iVar9, arg_8h, &var_14h);\n                }\n                fcn.00417fc6(&var_16h, var_1ch, arg_8h, &var_14h);\n                if (((uVar2 & 8) != 0) && ((uVar2 & 4) == 0)) {\n                    fcn.00417f95(0x30, iVar9, arg_8h, &var_14h);\n                }\n                if ((var_24h == 0) || (uVar2 = var_ch,  puVar4 = var_8h,  var_ch < 1)) {\n                    fcn.00417fc6(var_8h, var_ch, arg_8h, &var_14h);\n                }\n                else {\n                    do {\n                        uVar10 = uVar2 - 1;\n                        iVar7 = fcn.0041b0db(&var_38h, uVar2 & 0xffff0000 | *puVar4);\n                        if (iVar7 < 1) break;\n                        fcn.00417fc6(&var_38h, iVar7, arg_8h, &var_14h);\n                        uVar2 = uVar10;\n                        puVar4 = puVar4 + 2;\n                    } while (uVar10 != 0);\n                }\n                if ((var_4h & 4) != 0) {\n                    fcn.00417f95(0x20, iVar9, arg_8h, &var_14h);\n                }\n            }\n        }\n        uVar8 = *arg_ch;\n        arg_ch = arg_ch + 1;\n    } while( true );\n}\n",
        "token_count": 4346
    },
    "0041f4e0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.0041f4e0(uint param_1, uint16_t param_2, uint32_t param_3)\n\n{\n    uint uVar1;\n    \n    uVar1 = (*_sym.imp.GDI32.dll_SetBkColor)(param_1, *((param_3 & 0xffff) * 4 + 0x4622a4));\n    if ((param_3 & 2) != 0) {\n        (*_sym.imp.GDI32.dll_ExtTextOutA)(param_1, 0, 0, 2, &stack0xffffffe8, 0, 0, 0);\n    }\n    if ((param_3 & 1) != 0) {\n        (*_sym.imp.GDI32.dll_ExtTextOutA)(param_1, 0, 0, 2, &stack0xffffffe8, 0, 0, 0);\n    }\n    if (param_1 != param_2) {\n        (*_sym.imp.GDI32.dll_SetBkColor)(param_1, *(param_2 * 4 + 0x4622a4));\n    }\n    if ((param_3 & 4) != 0) {\n        (*_sym.imp.GDI32.dll_ExtTextOutA)(param_1, 0, 0, 2, &stack0xffffffe8, 0, 0, 0);\n    }\n    if ((param_3 & 8) != 0) {\n        (*_sym.imp.GDI32.dll_ExtTextOutA)(param_1, 0, 0, 2, &stack0xffffffe8, 0, 0, 0);\n    }\n    (*_sym.imp.GDI32.dll_SetBkColor)(param_1, uVar1);\n    return;\n}\n",
        "token_count": 399
    },
    "00420ea0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid fcn.00420ea0(uint param_1)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    uchar *puStack64;\n    uint uStack60;\n    uchar *puStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint uStack40;\n    uint uStack36;\n    uchar *puStack32;\n    uchar auStack16 [8];\n    int32_t iStack8;\n    \n    puStack32 = &stack0xfffffff0;\n    uStack36 = param_1;\n    uStack40 = 0x420eb6;\n    (*_sym.imp.USER32.dll_GetWindowRect)();\n    uStack40 = 0xfffffff0;\n    uStack44 = param_1;\n    uStack48 = 0x420ebf;\n    uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    if (((uVar3 & 0x10000000) != 0) &&\n       ((((iStack8 == 0 || (uVar1 = *(iStack8 + 0x18),  (uVar1 & 0xc0) != 0)) || ((uVar1 & 2) == 0)) ||\n        ((uVar1 & 1) == 0)))) {\n        puStack56 = &stack0xffffffe0;\n        uStack48 = 1;\n        uStack52 = 1;\n        uStack60 = 0x420f1e;\n        (*_sym.imp.USER32.dll_InflateRect)();\n        uStack60 = param_1;\n        puStack64 = 0x420f25;\n        uVar4 = (*_sym.imp.USER32.dll_GetParent)();\n        pcVar2 = _sym.imp.USER32.dll_ScreenToClient;\n        puStack64 = &stack0xffffffd0;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar4);\n        (*pcVar2)(uVar4, &stack0xffffffd0);\n        if ((uVar3 & 0x200000) != 0) {\n            puStack56 = puStack56 + 1;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(uVar4, &stack0xffffffc0, 0);\n    }\n    return;\n}\n",
        "token_count": 513
    },
    "0042813e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00428196)\n// WARNING: Removing unreachable block (ram,0x004281a5)\n// WARNING: Removing unreachable block (ram,0x004281ab)\n// WARNING: Removing unreachable block (ram,0x004281bd)\n// WARNING: Removing unreachable block (ram,0x004281c4)\n// WARNING: Removing unreachable block (ram,0x004281ca)\n// WARNING: Removing unreachable block (ram,0x004281d0)\n// WARNING: Removing unreachable block (ram,0x004281e3)\n// WARNING: Removing unreachable block (ram,0x004281ea)\n// WARNING: Removing unreachable block (ram,0x00428206)\n\nint32_t __thiscall fcn.0042813e(int32_t *param_1, uint8_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t unaff_EBX;\n    \n    if ((param_2 & 4) != 0) {\n        fcn.00428783();\n    }\n    (*_sym.imp.USER32.dll_GetParent)(param_1[7]);\n    param_1[9] = param_1[9] | 0x18;\n    iVar2 = fcn.00429b18();\n    pcVar1 = _sym.imp.USER32.dll_UpdateWindow;\n    while( true ) {\n        piVar3 = fcn.00429b18();\n        iVar4 = (**(*piVar3 + 0x5c))();\n        if (iVar4 == 0) {\n            fcn.00443db3(0);\n            return -1;\n        }\n        if ((unaff_EBX != 0) && ((*(iVar2 + 0x34) == 0x118 || (*(iVar2 + 0x34) == 0x104)))) {\n            fcn.00428943(1);\n            (*pcVar1)(param_1[7]);\n            unaff_EBX = 0;\n        }\n        iVar4 = (**(*param_1 + 0x70))();\n        if (iVar4 == 0) break;\n        piVar3 = fcn.00429b18();\n        iVar4 = (**(*piVar3 + 100))(iVar2 + 0x30);\n        if (iVar4 != 0) {\n            unaff_EBX = 0;\n        }\n        (*_sym.imp.USER32.dll_PeekMessageA)(iVar2 + 0x30, 0, 0, 0, 0);\n    }\n    param_1[9] = param_1[9] & 0xffffffe7;\n    return param_1[0xb];\n}\n",
        "token_count": 602
    },
    "00428380": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n\nbool __cdecl fcn.00428380(uint32_t arg_8h)\n\n{\n    uint noname_8;\n    uint noname_11;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    bool bVar4;\n    uint *noname_0;\n    uint32_t var_34h;\n    uint var_30h;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint var_1ch;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.0043d8de();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.0040ffd0(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.0043d8de();\n        noname_11 = *0x460370;\n        noname_8 = *(iVar1 + 8);\n        noname_0 = 0x8;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            noname_0 = &var_34h;\n            var_34h = 0xb;\n            iVar1 = fcn.004264e3(noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0xb, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, *0x460370, var_18h, in_stack_ffffffe8, \n                                 \"AfxWnd42s\", 8, var_8h);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            iVar1 = fcn.004264e3(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, var_34h, var_30h, \n                                 in_stack_ffffffd0, in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, var_18h, \n                                 in_stack_ffffffe8, \"AfxOleControl42s\", var_ch);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            iVar1 = fcn.004264e3(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, 0x10, in_stack_ffffffe8, \n                                 \"AfxControlBar42s\", var_ch);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            iVar1 = fcn.004282c8(&var_34h, \"AfxMDIFrame42s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            iVar1 = fcn.004282c8(&var_34h, \"AfxFrameOrView42s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.00428309(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.00428309(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.00428309(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.00428309(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.00428309(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.00428309(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.00428309(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.00428309(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.00428309(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.00428309(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.00428309(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.00428309(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.00428309(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            uVar3 = uVar3 | 0x10;\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 2126
    },
    "00428750": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00428750(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((*(param_1 + 0x25) & 1) == 0) {\n        (*_sym.imp.USER32.dll_IsDialogMessageA)(*(param_1 + 0x1c), param_2);\n    }\n    else {\n        iVar1 = fcn.0043d8de();\n        (**(**(iVar1 + 0x1038) + 0x24))(param_1, param_2);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "0042953e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t fcn.0042953e(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint noname_1;\n    uint32_t uVar4;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_10h;\n    int32_t *noname_4;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint hWnd;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    uint noname_13;\n    \n    noname_13 = 0x429548;\n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &fcn.0042953e::var_20h;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    iVar2 = extraout_ECX[0x11];\n    *(unaff_EBP + -0x18) = extraout_ECX[0x12];\n    var_20h = unaff_EDI;\n    var_1ch = unaff_ESI;\n    var_18h = unaff_EBX;\n    iVar1 = fcn.0043d8de();\n    uVar5 = *(iVar1 + 0xc);\n    if (extraout_ECX[0x10] != 0) {\n        iVar2 = fcn.0043d8de();\n        uVar5 = *(iVar2 + 0xc);\n        uVar3 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar5, extraout_ECX[0x10], 5);\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar5, uVar3);\n    }\n    if (iVar2 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        *(unaff_EBP + -0x18) = uVar3;\n    }\n    if (*(unaff_EBP + -0x18) == 0) {\n        iVar2 = -1;\n    }\n    else {\n        uVar3 = fcn.004294c2();\n        *(unaff_EBP + -0x14) = uVar3;\n        fcn.00425e5e();\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14));\n            if (iVar2 != 0) {\n                (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n                *(unaff_EBP + -0x20) = 1;\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        noname_4 = extraout_ECX;\n        fcn.00425e12();\n        uVar3 = *(unaff_EBP + -0x14);\n        noname_1 = fcn.00425960();\n        iVar2 = fcn.0042924f(*(unaff_EBP + -0x18), noname_1, uVar5, uVar3, noname_4, var_20h, var_1ch, var_18h, hWnd, \n                             in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h, noname_13, unaff_retaddr, param_1, \n                             param_2, param_3, var_10h);\n        if (iVar2 != 0) {\n            if ((*(extraout_ECX + 9) & 0x10) != 0) {\n                uVar5 = 4;\n                uVar4 = fcn.00428783();\n                if ((uVar4 & 0x100) != 0) {\n                    uVar5 = 5;\n                }\n                fcn.0042813e(uVar5);\n            }\n            if (extraout_ECX[7] != 0) {\n                fcn.004288f4(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x20) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar2 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar2 == extraout_ECX[7]) {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n            }\n        }\n        (**(*extraout_ECX + 0x58))();\n        fcn.004294fc();\n        iVar2 = extraout_ECX[0xb];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 1312
    },
    "0042b37e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_178h\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0042b37e(int32_t arg_8h, uint32_t lpMultiByteStr, uchar *arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uchar *puVar4;\n    int32_t *piStack432;\n    int32_t *piStack428;\n    uint uStack424;\n    uint *puStack420;\n    uint var_178h;\n    uint psfi;\n    uint var_162h;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    uVar3 = 0;\n    *arg_10h = 0;\n    iVar1 = (*_sym.imp.SHELL32.dll_SHGetFileInfoA)();\n    if ((iVar1 != 0) && ((var_162h & 1) != 0)) {\n        puStack420 = 0x42b3d8;\n        iVar1 = fcn.0042b184(0x44b048, 0, 0x44b038, &fcn.0042b37e::var_4h);\n        if (-1 < iVar1) {\n            puStack420 = &fcn.0042b37e::var_8h;\n            uStack424 = 0x44d728;\n            piStack428 = var_4h;\n            piStack432 = 0x42b3f1;\n            iVar1 = (***var_4h)();\n            if (-1 < iVar1) {\n                if (lpMultiByteStr == 0) {\n                    puVar4 = NULL;\n                }\n                else {\n                    piStack432 = lpMultiByteStr;\n                    puVar4 = &stack0xfffffe50;\n                    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n                    fcn.00410700();\n                    piStack432 = piStack432 & 0xffff0000;\n                    (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (0, 0, lpMultiByteStr, 0xffffffff, &stack0xfffffe50, iVar1 + 1);\n                }\n                piStack432 = NULL;\n                iVar1 = (**(*var_8h + 0x14))(var_8h, puVar4);\n                if (-1 < iVar1) {\n                    if (arg_8h == 0) {\n                        uVar2 = 0;\n                    }\n                    else {\n                        uVar2 = *(arg_8h + 0x1c);\n                    }\n                    iVar1 = (**(*var_4h + 0x4c))(var_4h, uVar2, 2);\n                    if (-1 < iVar1) {\n                        (**(*var_4h + 0xc))(var_4h, arg_10h, arg_14h, 0, 0);\n                        (**(*var_8h + 8))(var_8h);\n                        uVar3 = 1;\n                        goto code_r0x0042b484;\n                    }\n                }\n                (**(*var_8h + 8))(var_8h);\n            }\ncode_r0x0042b484:\n            piStack432 = var_4h;\n            (**(*var_4h + 8))();\n            return uVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 761
    },
    "0042c1af": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042c1af(int32_t *param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    uint32_t *arg_8h;\n    uint32_t uVar2;\n    \n    param_1[1] = param_3;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40);\n    *param_1 = iVar1;\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n        fcn.0040fc90(arg_8h, param_3 + 0x40, param_1[1]);\n        if (*(arg_8h + 2) == -1) {\n            uVar2 = arg_8h[3];\n        }\n        else {\n            uVar2 = *arg_8h;\n        }\n        param_1[2] = ~uVar2 >> 6 & 1;\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*param_1);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 256
    },
    "0042c6f0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042c6f0(uint *param_1, uint8_t param_2)\n\n{\n    uint *puVar1;\n    \n    if ((param_2 & 2) == 0) {\n        fcn.0042a358();\n        puVar1 = param_1;\n        if ((param_2 & 1) != 0) {\n            fcn.00425426(param_1);\n        }\n    }\n    else {\n        puVar1 = param_1 + -1;\n        fcn.00410bca(param_1, 4, *puVar1, fcn.0042a358);\n        if ((param_2 & 1) != 0) {\n            fcn.00425426(puVar1);\n        }\n    }\n    return puVar1;\n}\n",
        "token_count": 181
    },
    "0042fc23": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * __cdecl fcn.0042fc23(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *extraout_ECX;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    piVar1 = *(unaff_EBP + 8);\n    iVar2 = *piVar1;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    (**(iVar2 + 0x18))(extraout_ECX + 4);\n    uVar3 = *(unaff_EBP + 0xc);\n    extraout_ECX[3] = 0xffffffff;\n    extraout_ECX[5] = uVar3;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[8] = piVar1;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[0xd] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[1] = 1;\n    if ((~uVar3 & 1) == 0) {\n        extraout_ECX[0xf] = 0x40;\n    }\n    else {\n        extraout_ECX[0xf] = 0x10;\n    }\n    uVar3 = *(unaff_EBP + 0x14);\n    extraout_ECX[6] = 1;\n    extraout_ECX[0xb] = uVar3;\n    iVar2 = *(unaff_EBP + 0x10);\n    extraout_ECX[0x10] = 0x89;\n    extraout_ECX[2] = 0;\n    if (iVar2 < 0x80) {\n        extraout_ECX[7] = 0x80;\n        extraout_ECX[0xb] = 0;\n    }\n    else {\n        extraout_ECX[7] = iVar2;\n    }\n    iVar2 = extraout_ECX[0xb];\n    *(unaff_EBP + 0x10) = extraout_ECX[7];\n    if (iVar2 == 0) {\n        iVar2 = (**(*piVar1 + 0x50))(3, 0, 0, 0);\n        extraout_ECX[2] = iVar2;\n        if (iVar2 == 0) {\n            uVar3 = fcn.004253fd(extraout_ECX[7]);\n            extraout_ECX[0xb] = uVar3;\n            extraout_ECX[6] = 0;\n        }\n        else {\n            *(unaff_EBP + 0x10) = 0;\n        }\n    }\n    iVar4 = *(unaff_EBP + 0x10) + extraout_ECX[0xb];\n    extraout_ECX[10] = iVar4;\n    iVar2 = extraout_ECX[0xb];\n    if ((*(extraout_ECX + 5) & 1) != 0) {\n        iVar2 = iVar4;\n    }\n    uVar3 = *(unaff_EBP + -0xc);\n    extraout_ECX[9] = iVar2;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 818
    },
    "0042ff34": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042ff34(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    if ((*(param_1 + 0x14) & 1) == 0) {\n        iVar1 = *(param_1 + 0x24);\n        iVar2 = *(param_1 + 0x2c);\n        if (*(param_1 + 8) == 0) {\n            if (iVar1 != iVar2) {\n                (**(**(param_1 + 0x20) + 0x38))(iVar2, iVar1 - iVar2);\n            }\n        }\n        else {\n            if (iVar1 != iVar2) {\n                (**(**(param_1 + 0x20) + 0x50))(2, iVar1 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x20) + 0x50))(1, *(param_1 + 0x1c), param_1 + 0x2c, param_1 + 0x28);\n        }\n        *(param_1 + 0x24) = *(param_1 + 0x2c);\n    }\n    else {\n        if (*(param_1 + 0x28) != *(param_1 + 0x24)) {\n            (**(**(param_1 + 0x20) + 0x28))(*(param_1 + 0x24) - *(param_1 + 0x28), 1);\n        }\n        *(param_1 + 0x24) = *(param_1 + 0x28);\n    }\n    return;\n}\n",
        "token_count": 368
    },
    "00430d3e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch_2\n\nuint __cdecl fcn.00430d3e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint uVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar2 = extraout_ECX[0x17];\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    iVar1 = iVar2 + *(unaff_EBP + 8) * 0x14;\n    if ((*(iVar2 + 0xc + *(unaff_EBP + 8) * 0x14) & 1) == 0) {\n        if (*(unaff_EBP + 0xc) == 0) {\n            iVar2 = *(*(iVar1 + 0x10) + -8);\n        }\n        else {\n            iVar2 = fcn.0041110c(*(iVar1 + 0x10), *(unaff_EBP + 0xc));\n        }\n        if (iVar2 == 0) goto code_r0x00430dea;\n    }\n    *(unaff_EBP + -4) = 0;\n    if (*(unaff_EBP + 0xc) == 0) {\n        fcn.0042a2e3();\n    }\n    else {\n        fcn.0042a4e1(*(unaff_EBP + 0xc));\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) == 0) {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) | 1;\n    }\n    else {\n        *(iVar1 + 0xc) = *(iVar1 + 0xc) & 0xfffffffe;\n        if ((*(iVar1 + 0xb) & 4) == 0) {\n            uVar3 = *(iVar1 + 0x10);\n        }\n        else {\n            uVar3 = 0;\n        }\n        (**(*extraout_ECX + 0xa0))(0x401, *(iVar1 + 8) | *(unaff_EBP + 8), uVar3);\n    }\ncode_r0x00430dea:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 617
    },
    "00431432": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00431432(int32_t *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *var_8h;\n    int32_t *piStack8;\n    \n    uVar1 = param_1[0x19];\n    param_1[0x21] = 0;\n    if (((uVar1 & 1) == 0) || ((uVar1 & 4) == 0)) {\n        iVar2 = *param_1;\n        if ((uVar1 & 0xa000) == 0) {\n            uVar3 = 0x50;\n        }\n        else {\n            uVar3 = 0x4a;\n        }\n    }\n    else {\n        iVar2 = *param_1;\n        uVar3 = 0x46;\n    }\n    var_8h = param_1;\n    piStack8 = param_1;\n    (**(iVar2 + 0xbc))(&var_8h, 0, uVar3);\n    return;\n}\n",
        "token_count": 240
    },
    "004314f2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004314f2(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    int32_t var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar6 = 0;\n    var_18h = 0;\n    var_10h = 0;\n    var_ch = 0;\n    uVar2 = (**(*in_ECX + 0xa0))(0x455, 0, 0);\n    if (0 < arg_10h) {\n        var_4h = arg_10h;\n        puVar7 = arg_ch + 9;\n        do {\n            arg_ch = *(puVar7 + -9);\n            uVar3 = fcn.00428783();\n            if (((uVar3 & 0x800) == 0) && (*0x45bed4 != 0x40047)) {\n                arg_ch = (arg_ch * 2) / 3;\n            }\n            if ((puVar7[-1] & 8) == 0) {\n                uVar1 = *puVar7;\n                iVar5 = in_ECX[0x24];\n                if ((uVar1 & 1) == 0) {\n                    if (((uVar1 & 8) != 0) && ((uVar2 & 1) != 0)) {\n                        iVar5 = iVar5 + *0x45bed8;\n                    }\n                    if (var_10h < var_18h + iVar5) {\n                        var_10h = var_18h + iVar5;\n                    }\n                    iVar4 = in_ECX[0x25] + iVar6;\ncode_r0x004315c1:\n                    if (var_ch < iVar4) {\n                        var_ch = iVar4;\n                    }\n                }\n                else {\n                    if ((puVar7[-1] & 0x20) != 0) {\n                        iVar4 = in_ECX[0x25] + iVar6 + arg_ch;\n                        goto code_r0x004315c1;\n                    }\n                    if (var_10h < *(puVar7 + -9) + var_18h) {\n                        var_10h = *(puVar7 + -9) + var_18h;\n                    }\n                }\n                if ((uVar1 & 1) != 0) {\n                    iVar5 = *(puVar7 + -9);\n                }\n                var_18h = var_18h + iVar5;\n                if ((puVar7[-1] & 0x20) != 0) {\n                    var_18h = 0;\n                    iVar6 = iVar6 + in_ECX[0x25];\n                    if ((uVar1 & 1) != 0) {\n                        iVar6 = iVar6 + arg_ch;\n                    }\n                }\n            }\n            puVar7 = puVar7 + 0x14;\n            var_4h = var_4h + -1;\n        } while (var_4h != 0);\n    }\n    *arg_8h = var_10h;\n    arg_8h[1] = var_ch;\n    return;\n}\n",
        "token_count": 774
    },
    "00431614": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00431614(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint8_t *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar6 = 0;\n    iVar5 = 0;\n    var_4h = 0;\n    if (arg_ch < 1) {\ncode_r0x004316e4:\n        return var_4h + 1;\n    }\ncode_r0x00431632:\n    piVar1 = arg_8h + iVar6 * 0x14;\n    *(piVar1 + 2) = *(piVar1 + 2) & 0xdf;\n    piVar2 = piVar1 + 2;\n    if ((*piVar2 & 8) == 0) {\n        if ((*(piVar1 + 9) & 1) == 0) {\n            iVar3 = *(in_ECX + 0x90);\n        }\n        else {\n            iVar3 = *piVar1;\n        }\n        iVar5 = iVar3 + iVar5;\n        iVar3 = iVar6;\n        if (arg_10h < iVar5) {\n            for (; (-1 < iVar3 && ((*piVar2 & 0x20) == 0)); piVar2 = piVar2 + -5) {\n                if (((*(piVar2 + 1) & 1) != 0) && ((piVar2[-1] == 0 && ((*piVar2 & 8) == 0)))) goto code_r0x004316c9;\n                iVar3 = iVar3 + -1;\n            }\n            iVar3 = iVar6 + -1;\n            if (-1 < iVar3) {\n                puVar4 = arg_8h + 8 + iVar3 * 0x14;\n                do {\n                    if ((*puVar4 & 0x20) != 0) break;\n                    if (((*puVar4 & 8) == 0) && (((puVar4[1] & 1) == 0 || (*(puVar4 + -4) == 0))))\n                    goto code_r0x004316c9;\n                    iVar3 = iVar3 + -1;\n                    puVar4 = puVar4 + -0x14;\n                } while (-1 < iVar3);\n            }\n        }\n    }\n    goto code_r0x004316d9;\ncode_r0x004316c9:\n    iVar5 = 0;\n    puVar4 = arg_8h + 8 + iVar3 * 0x14;\n    *puVar4 = *puVar4 | 0x20;\n    var_4h = var_4h + 1;\n    iVar6 = iVar3;\ncode_r0x004316d9:\n    iVar6 = iVar6 + 1;\n    if (arg_ch <= iVar6) goto code_r0x004316e4;\n    goto code_r0x00431632;\n}\n",
        "token_count": 705
    },
    "0043184b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpRect\n\nvoid __cdecl fcn.0043184b(int32_t *arg_8h, uint32_t arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint32_t *puVar3;\n    int32_t *in_ECX;\n    int32_t iVar4;\n    uint *puVar5;\n    uint32_t *puVar6;\n    uint32_t *puVar7;\n    uint *arg_8h_00;\n    uint32_t uVar8;\n    uint32_t lpRect;\n    uint *var_3ch;\n    uint32_t var_38h;\n    uint32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t lprc;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint32_t var_1ch;\n    int32_t var_18h;\n    uint32_t *var_14h;\n    int32_t var_10h;\n    uint32_t *var_ch;\n    uint32_t *var_8h;\n    uint32_t *var_4h;\n    \n    puVar5 = NULL;\n    arg_8h_00 = 0x418;\n    var_4h = NULL;\n    var_30h = 0;\n    var_2ch = 0;\n    iVar1 = (**(*in_ECX + 0xa0))(0x418, 0, 0);\n    var_18h = iVar1;\n    if ((iVar1 == 0) || (var_4h = fcn.004253fd(iVar1 * 0x14),  puVar6 = var_4h,  iVar1 < 1)) goto code_r0x00431b08;\n    do {\n        var_8h = puVar6;\n        arg_8h_00 = puVar5;\n        fcn.004312d1();\n        var_8h = var_8h + 5;\n        puVar5 = puVar5 + 1;\n        puVar6 = var_8h;\n    } while (puVar5 < iVar1);\n    puVar6 = NULL;\n    if (iVar1 < 1) goto code_r0x00431b08;\n    uVar8 = in_ECX[0x19];\n    if ((uVar8 & 2) == 0) {\n        var_1ch = uVar8 & 4;\n        if (var_1ch == 0) {\ncode_r0x00431934:\n            uVar8 = -((arg_ch & 2) != 0) & 0x7fff;\n        }\n        else if ((arg_ch & 4) == 0) {\n            if ((arg_ch & 8) == 0) {\n                if ((arg_ch & 0x10) == 0) {\n                    if (arg_10h == 0xffffffff) {\n                        if ((uVar8 & 1) == 0) goto code_r0x00431934;\n                        goto code_r0x0043192e;\n                    }\n                    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.0043184b::lprc);\n                    var_38h = arg_ch & 2;\n                    var_3ch = &fcn.0043184b::lprc;\n                    lpRect = 0x43190b;\n                    fcn.0043418a();\n                    lpRect = arg_ch & 0x20;\n                    if (lpRect == 0) {\n                        var_24h = var_20h - lprc;\n                    }\n                    else {\n                        var_24h = var_1ch - var_24h;\n                    }\n                    uVar8 = var_24h + arg_10h;\n                }\n                else {\n                    uVar8 = 0;\n                }\n            }\n            else {\n                uVar8 = 0x7fff;\n            }\n        }\n        else {\ncode_r0x0043192e:\n            uVar8 = in_ECX[0x15];\n        }\n        fcn.004316ee(var_4h, iVar1, uVar8, lpRect);\n    }\n    arg_8h_00 = &fcn.0043184b::var_20h;\n    piVar2 = fcn.004314f2(arg_8h_00, var_4h, iVar1);\n    var_30h = *piVar2;\n    var_2ch = piVar2[1];\n    if ((arg_ch & 0x40) != 0) {\n        var_1ch = in_ECX[0x21];\n        in_ECX[0x21] = 0;\n        var_10h = 0;\n        if (0 < iVar1) {\n            var_14h = var_4h + 1;\n            puVar3 = var_14h;\n            iVar4 = iVar1;\n            do {\n                if (((*(puVar3 + 5) & 1) != 0) && (*puVar3 != 0)) {\n                    puVar6 = puVar6 + 1;\n                }\n                puVar3 = puVar3 + 5;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n            if (0 < puVar6) {\n                var_10h = fcn.004253fd(puVar6 * 0x18);\n                if (var_10h == 0) {\n                    var_10h = 0;\n                }\n                var_ch = NULL;\n                arg_10h = NULL;\n                var_8h = var_10h + 8;\n                puVar3 = var_8h;\n                do {\n                    puVar7 = puVar3;\n                    if (((*(var_14h + 5) & 1) != 0) && (*var_14h != 0)) {\n                        puVar3[-2] = arg_10h;\n                        puVar3[-1] = *var_14h;\n                        (**(*in_ECX + 0xe0))(arg_10h, &fcn.0043184b::lpRect);\n                        arg_8h_00 = &fcn.0043184b::lpRect;\n                        fcn.0042eed8(arg_8h_00);\n                        var_ch = var_ch + 1;\n                        *puVar3 = lpRect;\n                        puVar3[1] = var_3ch;\n                        puVar7 = var_8h + 6;\n                        puVar3[2] = var_38h;\n                        puVar3[3] = var_34h;\n                        iVar1 = var_18h;\n                        var_8h = puVar7;\n                    }\n                    arg_10h = arg_10h + 1;\n                    var_14h = var_14h + 5;\n                    puVar6 = var_ch;\n                    puVar3 = puVar7;\n                } while (arg_10h < iVar1);\n            }\n        }\n        if (((in_ECX[0x19] & 1U) != 0) && ((in_ECX[0x19] & 4U) != 0)) {\n            in_ECX[0x15] = var_30h;\n        }\n        arg_10h = NULL;\n        if (0 < iVar1) {\n            var_ch = var_4h;\n            do {\n                arg_8h_00 = arg_10h;\n                fcn.004312f0(arg_10h, var_ch);\n                arg_10h = arg_10h + 1;\n                var_ch = var_ch + 5;\n            } while (arg_10h < iVar1);\n        }\n        if (0 < puVar6) {\n            piVar2 = var_10h + 8;\n            var_14h = puVar6;\n            do {\n                arg_8h_00 = piVar2[-1];\n                var_18h = fcn.004286f7();\n                if (var_18h != 0) {\n                    (*_sym.imp.USER32.dll_GetWindowRect)(*(var_18h + 0x1c), &fcn.0043184b::lpRect);\n                    iVar4 = var_3ch - piVar2[1];\n                    iVar1 = lpRect - *piVar2;\n                    (**(*in_ECX + 0xe0))(piVar2[-2], &fcn.0043184b::lpRect);\n                    arg_8h_00 = NULL;\n                    fcn.004288f4(0, iVar1 + lpRect, iVar4 + var_3ch, 0, 0, 0x15);\n                }\n                piVar2 = piVar2 + 6;\n                var_14h = var_14h + -1;\n            } while (var_14h != NULL);\n            fcn.00425426(var_10h, arg_8h_00);\n        }\n        in_ECX[0x21] = var_1ch;\n    }\n    fcn.00425426(var_4h);\ncode_r0x00431b08:\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&fcn.0043184b::lpRect, arg_8h_00);\n    fcn.0043418a(&fcn.0043184b::lpRect, arg_ch & 2);\n    var_2ch = var_3ch + (var_2ch - var_34h);\n    var_30h = var_30h + (lpRect - var_38h);\n    piVar2 = fcn.00433317(&fcn.0043184b::var_20h, arg_ch & 1, arg_ch & 2);\n    if (var_30h <= *piVar2) {\n        var_30h = *piVar2;\n    }\n    if (var_2ch <= piVar2[1]) {\n        var_2ch = piVar2[1];\n    }\n    *arg_8h = var_30h;\n    arg_8h[1] = var_2ch;\n    return;\n}\n",
        "token_count": 2238
    },
    "004338be": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004338be(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_DefWindowProcA)(*(in_ECX + 0x1c), 0x46, 0, arg_8h);\n    if ((*(arg_8h + 0x18) & 1) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n        var_ch = var_ch - lpRect;\n        var_4h = *(arg_8h + 0x10);\n        var_8h = var_8h - var_10h;\n        iVar1 = *(arg_8h + 0x14);\n        if ((var_4h != var_ch) && ((*(in_ECX + 0x65) & 4) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_4h - *0x460340, 0, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, var_ch - *0x460340, 0, var_ch, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n        pcVar2 = _sym.imp.USER32.dll_SetRect;\n        if ((iVar1 != var_8h) && ((*(in_ECX + 0x65) & 8) != 0)) {\n            (*_sym.imp.USER32.dll_SetRect)(&lpRect, 0, iVar1 - *0x460344, var_4h, iVar1);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n            (*pcVar2)(&lpRect, 0, var_8h - *0x460344, var_4h, var_8h);\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), &lpRect, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 575
    },
    "00433da5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00433da5(uint noname_0, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint8_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    bool bVar7;\n    int32_t lprcDst;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    uVar1 = (**(*in_ECX + 0xcc))(arg_ch);\n    if (((uVar1 & 0x10000000) != 0) && ((uVar1 & 0xf000) != 0)) {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, arg_ch + 1);\n        iVar6 = var_14h - lprcDst;\n        iVar5 = var_10h - var_18h;\n        bVar7 = arg_ch[7] != 0;\n        if (((var_4h[0x19] & 4U) == 0) || ((var_4h[0x19] & 1U) == 0)) {\n            if ((uVar1 & 0xa000) == 0) {\n                uVar4 = bVar7 | 0x10;\n            }\n            else {\n                uVar4 = bVar7 | 10;\n            }\n        }\n        else {\n            uVar4 = bVar7 | 6;\n        }\n        piVar2 = (**(*var_4h + 0xbc))(&var_ch, 0xffffffff, uVar4);\n        iVar3 = *piVar2;\n        if (iVar6 <= *piVar2) {\n            iVar3 = iVar6;\n        }\n        iVar6 = piVar2[1];\n        if (iVar5 <= piVar2[1]) {\n            iVar6 = iVar5;\n        }\n        if ((uVar1 & 0xa000) == 0) {\n            if ((uVar1 & 0x5000) != 0) {\n                arg_ch[5] = arg_ch[5] + iVar3;\n                iVar5 = arg_ch[6];\n                if (arg_ch[6] <= iVar6) {\n                    iVar5 = iVar6;\n                }\n                arg_ch[6] = iVar5;\n                if ((uVar1 & 0x1000) == 0) {\n                    if ((uVar1 & 0x4000) != 0) {\n                        lprcDst = var_14h - iVar3;\n                        arg_ch[3] = arg_ch[3] - iVar3;\n                    }\n                }\n                else {\n                    arg_ch[1] = arg_ch[1] + iVar3;\n                }\n            }\n        }\n        else {\n            arg_ch[6] = arg_ch[6] + iVar6;\n            iVar5 = arg_ch[5];\n            if (arg_ch[5] <= iVar3) {\n                iVar5 = iVar3;\n            }\n            arg_ch[5] = iVar5;\n            if ((uVar1 & 0x2000) == 0) {\n                if ((uVar1 & 0x8000) != 0) {\n                    var_18h = var_10h - iVar6;\n                    arg_ch[4] = arg_ch[4] - iVar6;\n                }\n            }\n            else {\n                arg_ch[2] = arg_ch[2] + iVar6;\n            }\n        }\n        var_14h = iVar3 + lprcDst;\n        var_10h = var_18h + iVar6;\n        if (*arg_ch != 0) {\n            fcn.004274ea(arg_ch, var_4h[7], &lprcDst);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 877
    },
    "0043418a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043418a(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_1 + 100);\n    if ((uVar1 & 0x100) != 0) {\n        *param_2 = *param_2 + *0x460340;\n    }\n    if ((uVar1 & 0x200) != 0) {\n        param_2[1] = param_2[1] + *0x460344;\n    }\n    if ((uVar1 & 0x400) != 0) {\n        param_2[2] = param_2[2] - *0x460340;\n    }\n    if ((uVar1 & 0x800) != 0) {\n        param_2[3] = param_2[3] - *0x460344;\n    }\n    if (param_3 == 0) {\n        *param_2 = *param_2 + *(param_1 + 0x48);\n        param_2[1] = param_2[1] + *(param_1 + 0x40);\n        param_2[2] = param_2[2] - *(param_1 + 0x4c);\n        param_2[3] = param_2[3] - *(param_1 + 0x44);\n        if ((*(param_1 + 100) & 0x400001) == 0x400000) {\n            param_2[1] = param_2[1] + 7;\n        }\n    }\n    else {\n        *param_2 = *param_2 + *(param_1 + 0x40);\n        param_2[1] = param_2[1] + *(param_1 + 0x48);\n        param_2[2] = param_2[2] - *(param_1 + 0x44);\n        param_2[3] = param_2[3] - *(param_1 + 0x4c);\n        if ((*(param_1 + 100) & 0x400001) == 0x400000) {\n            *param_2 = *param_2 + 7;\n        }\n    }\n    return;\n}\n",
        "token_count": 517
    },
    "004371ef": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004371ef(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if ((*0x46038c != 0) && ((*(arg_8h + 0x18) & 1) == 0)) {\n        iVar1 = fcn.00437114(&var_10h);\n        if (iVar1 != 0) {\n            uVar2 = fcn.00428783();\n            if ((uVar2 & 0x1000000) != 0) {\n                uVar3 = fcn.0042879d();\n                uVar3 = fcn.00428783(0, uVar3);\n                (*_sym.imp.USER32.dll_AdjustWindowRectEx)(&var_10h, uVar3);\n                *(arg_8h + 8) = var_10h;\n                *(arg_8h + 0xc) = var_ch;\n                *(arg_8h + 0x10) = var_8h - var_10h;\n                *(arg_8h + 0x14) = var_4h - var_ch;\n            }\n        }\n    }\n    fcn.004258c7();\n    return;\n}\n",
        "token_count": 314
    },
    "0043928b": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_110h\n\nuint __cdecl fcn.0043928b(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_110h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = *0x45c084;\n    puVar1 = *(unaff_EBP + 0xc);\n    uVar4 = 0;\n    iVar3 = puVar1[2];\n    uVar2 = puVar1[1];\n    *(unaff_EBP + -4) = 0;\n    if (((iVar3 == -0x208) && ((*(puVar1 + 0x19) & 1) != 0)) || ((iVar3 == -0x212 && ((*(puVar1 + 0x2d) & 1) != 0)))) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar2);\n        uVar2 = uVar2 & 0xffff;\n    }\n    if (uVar2 != 0) {\n        iVar3 = fcn.0042be55(uVar2, unaff_EBP + -0x110, 0x100);\n        if (iVar3 == 0) goto code_r0x00439343;\n        fcn.0042be7c(unaff_EBP + -0x10, unaff_EBP + -0x110, 1, 10);\n    }\n    if (puVar1[2] == -0x208) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)();\n    }\n    else {\n        fcn.0042a84e(puVar1 + 4, *(unaff_EBP + -0x10), 0x50);\n    }\n    **(unaff_EBP + 0x10) = 0;\n    (*_sym.imp.USER32.dll_SetWindowPos)(*puVar1, 0, 0, 0, 0, 0, 0x213);\n    uVar4 = 1;\ncode_r0x00439343:\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 584
    },
    "00439762": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00439762(int32_t *param_1)\n\n{\n    if ((*(param_1 + 0x2e) & 1) != 0) {\n        (**(*param_1 + 0xe4))(param_1[0x2a]);\n    }\n    if ((*(param_1 + 0x2e) & 2) != 0) {\n        (**(*param_1 + 0xe0))(1);\n    }\n    if ((param_1[0x2e] & 8U) != 0) {\n        (**(*param_1 + 200))(param_1[0x2e] & 4);\n        (*_sym.imp.USER32.dll_UpdateWindow)(param_1[7]);\n    }\n    if (param_1[0x24] != param_1[0x25]) {\n        fcn.00439147(param_1[0x24]);\n    }\n    param_1[0x2e] = 0;\n    return;\n}\n",
        "token_count": 224
    },
    "0043adc4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043adc4(uint32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    \n    uVar3 = fcn.00428783();\n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if (((uVar3 & 0x80000000) != 0) &&\n       ((((arg_8h & 0xfff0) != 0xf060 ||\n         (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x73),  iVar2 < 0 && (iVar2 = (*pcVar1)(0x12),  iVar2 < 0)) &&\n          ((uVar3 & 0x100) != 0)))) && (iVar4 = fcn.004275af(arg_8h, arg_ch),  iVar4 != 0)))) {\n        return;\n    }\n    fcn.004388c0(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 233
    },
    "0043b1eb": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid fcn.0043b1eb(void)\n\n{\n    uint8_t uVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint lpvBits;\n    \n    fcn.0043e309(8);\n    if (*0x4605f4 == 0) {\n        iVar3 = 0;\n        puVar2 = &lpvBits;\n        do {\n            uVar1 = iVar3;\n            iVar3 = iVar3 + 1;\n            *puVar2 = 0x5555 << (uVar1 & 1);\n            puVar2 = puVar2 + 2;\n        } while (iVar3 < 8);\n        iVar3 = (*_sym.imp.GDI32.dll_CreateBitmap)(8, 8, 1, 1, &lpvBits);\n        if (iVar3 != 0) {\n            *0x4605f4 = (*_sym.imp.GDI32.dll_CreatePatternBrush)(iVar3);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar3);\n        }\n    }\n    fcn.0043e379(8);\n    fcn.0042f279(*0x4605f4);\n    return;\n}\n",
        "token_count": 262
    },
    "0043bc3e": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043bc3e(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t *in_ECX;\n    int32_t var_ch;\n    \n    fcn.0043418a(arg_8h, arg_ch);\n    uVar2 = fcn.00428783();\n    if ((uVar2 & 0x100) != 0) {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        iVar4 = (*_sym.imp.USER32.dll_IsZoomed)(uVar3);\n        if (iVar4 == 0) {\n            (**(*in_ECX + 0xa0))(0x407, 0, &var_ch);\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            iVar5 = (*_sym.imp.USER32.dll_GetSystemMetrics)(5);\n            iVar4 = *(arg_8h + 8);\n            iVar6 = (*pcVar1)(2);\n            *(arg_8h + 8) = ((iVar4 + iVar5 * -2) - var_ch) - iVar6;\n        }\n    }\n    return;\n}\n",
        "token_count": 295
    },
    "0043bcae": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n\nvoid __cdecl fcn.0043bcae(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t iVar3;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t iVar5;\n    uint *puVar6;\n    int32_t aiStack96 [2];\n    uint *puStack88;\n    uint var_34h;\n    int32_t lpRect;\n    uint dy;\n    int32_t var_20h;\n    int32_t var_18h;\n    int32_t var_10h;\n    uchar *var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_34h = unaff_EDI;\n    if (arg_8h != 0) {\n        (*_sym.imp.USER32.dll_GetWindowRect)();\n        (*_sym.imp.USER32.dll_OffsetRect)();\n        puStack88 = 0x43bcf4;\n        fcn.0043bc3e(&fcn.0043bcae::lpRect, 1);\n        puStack88 = &fcn.0043bcae::var_18h;\n        aiStack96[1] = 0;\n        aiStack96[0] = 0x407;\n        var_ch = &stack0xffffffa0;\n        (**(*in_ECX + 0xa0))();\n        arg_8h = 0;\n        iVar4 = in_ECX[0x16];\n        iVar5 = (var_20h - lpRect) + var_10h;\n        if (0 < iVar4) {\n            piVar2 = in_ECX[0x17] + 4;\n            iVar3 = iVar4;\n            do {\n                if ((*(piVar2 + 7) & 8) != 0) {\n                    arg_8h = arg_8h + 1;\n                }\n                iVar1 = *piVar2;\n                piVar2 = piVar2 + 5;\n                iVar5 = iVar5 + ((-6 - iVar1) - var_10h);\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n        fcn.00410700();\n        var_8h = 0;\n        if (0 < iVar4) {\n            iVar4 = in_ECX[0x17] + 8;\n            var_ch = &stack0xffffffa0;\n            var_4h = &stack0xffffffa0;\n            do {\n                var_18h = var_18h + 6 + *(iVar4 + -4);\n                if (((*(iVar4 + 3) & 8) != 0) && (0 < iVar5)) {\n                    iVar3 = iVar5 / arg_8h;\n                    var_18h = var_18h + iVar3;\n                    arg_8h = arg_8h + -1;\n                    iVar5 = iVar5 - iVar3;\n                }\n                iVar4 = iVar4 + 0x14;\n                piVar2 = var_4h + 1;\n                *var_4h = var_18h;\n                var_4h = piVar2;\n                var_18h = var_18h + var_10h;\n                var_8h = var_8h + 1;\n            } while (var_8h < in_ECX[0x16]);\n        }\n        (**(*in_ECX + 0xa0))(0x404, in_ECX[0x16], var_ch);\n    }\n    iVar4 = 0;\n    if ((arg_ch != 0) && (0 < in_ECX[0x16])) {\n        puVar6 = in_ECX[0x17] + 0x10;\n        do {\n            if ((*(puVar6 + -1) & 1) != 0) {\n                fcn.00430d3e(iVar4, *puVar6, 1, var_34h, unaff_ESI, unaff_EBX);\n            }\n            puVar6 = puVar6 + 5;\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < in_ECX[0x16]);\n    }\n    return;\n}\n",
        "token_count": 972
    },
    "0043dcb6": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0043dcb6(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    code *pcVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    \n    iVar6 = param_1 + 0x1c;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(iVar6);\n    iVar7 = *(param_1 + 4);\n    iVar8 = *(param_1 + 8);\n    if ((iVar7 <= iVar8) || ((*(*(param_1 + 0x10) + iVar8 * 8) & 1) != 0)) {\n        iVar8 = 1;\n        if (1 < iVar7) {\n            puVar3 = *(param_1 + 0x10);\n            do {\n                puVar3 = puVar3 + 8;\n                if ((*puVar3 & 1) == 0) break;\n                iVar8 = iVar8 + 1;\n            } while (iVar8 < iVar7);\n            if (iVar8 < iVar7) goto code_r0x0043dd9b;\n        }\n        iVar7 = iVar7 + 0x20;\n        if (*(param_1 + 0x10) == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x2002, iVar7 * 8);\n        }\n        else {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar5);\n            iVar4 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)(uVar5, iVar7 * 8, 0x2002);\n        }\n        pcVar2 = _sym.imp.KERNEL32.dll_GlobalLock;\n        if (iVar4 == 0) {\n            uVar5 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(*(param_1 + 0x10));\n            (*pcVar2)(uVar5);\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(iVar6);\n            fcn.00423259();\n        }\n        iVar6 = (*pcVar2)(iVar4);\n        fcn.0040ffd0(iVar6 + *(param_1 + 4) * 8, 0, (*(param_1 + 4) * 0x1fffffff + iVar7) * 8);\n        *(param_1 + 0x10) = iVar6;\n        *(param_1 + 4) = iVar7;\n    }\ncode_r0x0043dd9b:\n    if (*(param_1 + 0xc) <= iVar8) {\n        *(param_1 + 0xc) = iVar8 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar8 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar8 + 1;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1);\n    return iVar8;\n}\n",
        "token_count": 710
    },
    "00440adb": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_160h\n\nvoid __cdecl fcn.00440adb(uint arg_8h)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    code *pcVar3;\n    uint16_t *puVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar7;\n    uint var_160h;\n    uint var_104h;\n    uint var_bch;\n    uint var_60h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    if ((*(unaff_EBP + 8) == 0) && (*(extraout_ECX + 0x98) != 0)) {\n        puVar4 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(extraout_ECX + 0x98));\n        if ((*(puVar4 + 3) & 1) == 0) goto code_r0x00440cd3;\n        fcn.00423758(0x440b2f, 0x14000c, 0);\n        *(unaff_EBP + -4) = 0;\n        fcn.004239c8();\n        if (*(*(unaff_EBP + -0x60) + 0xc) == 0) {\n            if (*(extraout_ECX + 0x94) != 0) {\n                fcn.0042f5a8(*(extraout_ECX + 0x94));\n            }\n            fcn.0042f5a8(*(extraout_ECX + 0x98));\n            *(extraout_ECX + 0x94) = 0;\n            *(extraout_ECX + 0x98) = 0;\n        }\n        else {\n            puVar5 = fcn.0042390f(unaff_EBP + -0x10);\n            pcVar3 = _sym.imp.KERNEL32.dll_lstrcmpA;\n            uVar2 = *puVar5;\n            uVar1 = *puVar4;\n            *(unaff_EBP + -4) = 1;\n            iVar6 = (*pcVar3)(uVar1 + puVar4, uVar2);\n            if (iVar6 == 0) {\n                puVar5 = fcn.0042394c(unaff_EBP + -0x14);\n                iVar6 = (*pcVar3)(puVar4[1] + puVar4, *puVar5);\n                *(unaff_EBP + 0xb) = iVar6 != 0;\n                fcn.0042a358();\n                if (*(unaff_EBP + 0xb) != '\\0') goto code_r0x00440bf3;\n                puVar5 = fcn.0042398a(unaff_EBP + -0x18);\n                iVar6 = (*pcVar3)(puVar4[2] + puVar4, *puVar5);\n                bVar7 = iVar6 != 0;\n                fcn.0042a358();\n                if (bVar7) goto code_r0x00440bf3;\n            }\n            else {\ncode_r0x00440bf3:\n                bVar7 = true;\n            }\n            *(unaff_EBP + -4) = 0;\n            fcn.0042a358();\n            if (bVar7) {\n                if (*(extraout_ECX + 0x94) != 0) {\n                    fcn.0042f5a8(*(extraout_ECX + 0x94));\n                }\n                fcn.0042f5a8();\n                iVar6 = *(unaff_EBP + -0x60);\n                *(extraout_ECX + 0x94) = *(iVar6 + 8);\n                *(extraout_ECX + 0x98) = *(iVar6 + 0xc);\n            }\n            else {\n                if (*(*(unaff_EBP + -0x60) + 8) != 0) {\n                    fcn.0042f5a8();\n                }\n                if (*(*(unaff_EBP + -0x60) + 0xc) != 0) {\n                    fcn.0042f5a8();\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    else {\n        fcn.00423758(1, 0x14000c, 0);\n        *(unaff_EBP + -4) = 2;\n        fcn.004239c8();\n        if (*(extraout_ECX + 0x94) != 0) {\n            fcn.0042f5a8(*(extraout_ECX + 0x94));\n        }\n        if (*(extraout_ECX + 0x98) != 0) {\n            fcn.0042f5a8(*(extraout_ECX + 0x98));\n        }\n        iVar6 = *(unaff_EBP + -0x104);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x94) = *(iVar6 + 8);\n        *(extraout_ECX + 0x98) = *(iVar6 + 0xc);\n    }\n    fcn.00429130();\ncode_r0x00440cd3:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1225
    },
    "0044358a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0044358a(int32_t *arg_8h, int32_t *arg_ch, uint8_t *arg_10h, uint32_t *arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            uint32_t *arg_20h, uint arg_24h, uint8_t *arg_28h, int32_t *arg_2ch, int32_t *arg_30h)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    uint8_t *puVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    int32_t in_ECX;\n    int32_t *piVar8;\n    uint var_ach;\n    int32_t var_98h;\n    int32_t var_8ch;\n    uint var_74h;\n    int32_t var_60h;\n    int32_t var_54h;\n    uint var_45h;\n    int32_t var_3ch;\n    int32_t lpPoint;\n    uint Y;\n    int32_t lpSize;\n    int32_t var_28h;\n    uint32_t var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint8_t *cbString;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t lpBuffer;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    pcVar2 = _sym.imp.GDI32.dll_GetTextMetricsA;\n    (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(in_ECX + 8), &var_74h);\n    (*pcVar2)(*(in_ECX + 4), &var_ach);\n    (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)(*(in_ECX + 8), 0x44c530, 1, &lpSize);\n    var_24h = (*_sym.imp.GDI32.dll_GetTextAlign)(*(in_ECX + 8));\n    var_20h = var_24h & 1;\n    if (var_20h != 0) {\n        (*_sym.imp.GDI32.dll_GetCurrentPositionEx)(*(in_ECX + 4), &lpPoint);\n        *arg_ch = lpPoint;\n    }\n    iVar5 = *arg_ch;\n    cbString = arg_10h;\n    var_8h = 0;\n    var_10h = 0;\n    var_1ch = iVar5;\n    if (arg_18h != 0) {\n        if (arg_1ch == 1) {\n            var_10h = *arg_20h;\n        }\n        else {\n            var_10h = (*_sym.imp.USER32.dll_GetTabbedTextExtentA)(*(in_ECX + 8), 0x44c52c, 1, 0, 0);\n            var_10h = var_10h & 0xffff;\n        }\n    }\n    var_4h = 0;\n    puVar7 = arg_10h;\n    piVar8 = arg_2ch;\n    arg_10h = iVar5;\n    if (*arg_14h != 0) {\n        do {\n            uVar1 = *puVar7;\n            var_14h = uVar1 == var_45h;\n            if ((var_14h == 0) && ((arg_18h == 0 || (uVar1 != 9)))) {\n                uVar4 = uVar1;\n                if ((*(uVar4 + 0x462121) & 4) == 0) {\n                    (*_sym.imp.GDI32.dll_GetCharWidthA)(*(in_ECX + 4), uVar4, uVar4, &lpBuffer);\n                    iVar5 = (*_sym.imp.GDI32.dll_GetCharWidthA)(*(in_ECX + 8), *puVar7, *puVar7, piVar8);\n                    if (iVar5 == 0) {\n                        *piVar8 = var_60h;\n                    }\n                }\n                else {\n                    *piVar8 = var_60h;\n                    lpBuffer = var_98h;\n                }\n                lpBuffer = lpBuffer - var_8ch;\n                *piVar8 = *piVar8 - var_54h;\n                iVar5 = *piVar8;\n                arg_10h = arg_10h + iVar5;\n                if (piVar8 != arg_2ch) {\n                    iVar6 = (iVar5 - lpBuffer) / 2;\n                    piVar8[-1] = piVar8[-1] + iVar6;\n                    *piVar8 = iVar5 - iVar6;\n                }\n                *arg_28h = *puVar7;\n                puVar3 = arg_28h + 1;\n                if ((*(*puVar7 + 0x462121) & 4) != 0) {\n                    arg_28h[1] = puVar7[1];\n                    iVar5 = *piVar8;\n                    arg_10h = arg_10h + iVar5;\n                    piVar8 = piVar8 + 1;\n                    var_4h = var_4h + 1;\n                    *piVar8 = iVar5;\n                    puVar3 = arg_28h + 2;\n                }\n                arg_28h = puVar3;\n                piVar8 = piVar8 + 1;\n            }\n            else {\n                (*_sym.imp.GDI32.dll_GetTextExtentPoint32A)\n                          (*(in_ECX + 8), cbString, puVar7 + (var_14h - cbString), &var_3ch);\n                iVar5 = (var_3ch - var_54h) + var_1ch;\n                if (var_14h == 0) {\n                    iVar5 = fcn.00443556(iVar5, arg_1ch, arg_20h, arg_24h, var_10h);\n                }\n                if (piVar8 == arg_2ch) {\n                    var_8h = var_8h + (iVar5 - arg_10h);\n                }\n                else {\n                    piVar8[-1] = piVar8[-1] + (iVar5 - arg_10h);\n                }\n                cbString = puVar7 + 1;\n                arg_10h = iVar5;\n                var_1ch = iVar5;\n            }\n            puVar7 = fcn.004114cf(puVar7);\n            var_4h = var_4h + 1;\n        } while (var_4h < *arg_14h);\n    }\n    lpSize = arg_10h - *arg_ch;\n    uVar4 = var_24h & 6;\n    *arg_30h = 0;\n    iVar5 = var_8h;\n    if (uVar4 != 0) {\n        if (uVar4 != 6) {\n            if (uVar4 == 2) {\n                *arg_30h = var_8h;\n            }\n            goto code_r0x004437c3;\n        }\n        iVar5 = var_8h / 2;\n    }\n    *arg_ch = *arg_ch + iVar5;\ncode_r0x004437c3:\n    if (var_20h != 0) {\n        (*_sym.imp.GDI32.dll_MoveToEx)(*(in_ECX + 4), *arg_ch, Y, 0);\n    }\n    *arg_14h = piVar8 - arg_2ch >> 2;\n    *arg_8h = lpSize;\n    arg_8h[1] = var_28h;\n    return;\n}\n",
        "token_count": 1724
    },
    "0040118c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040118c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0x300) = 1;\n    *(*(param_1 + 0x500) + 0x2ff + param_1) = 1;\n    iVar1 = 0;\n    *(param_1 + 0x504) = 0;\n    if (0 < *(param_1 + 0x500)) {\n        do {\n            if (*(param_1 + 0x300 + iVar1) == '\\x01') {\n                *(param_1 + 0x400 + *(param_1 + 0x504)) = iVar1;\n                *(param_1 + 0x504) = *(param_1 + 0x504) + 1;\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x500));\n    }\n    return 1;\n}\n",
        "token_count": 219
    },
    "00401431": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint8_t __fastcall fcn.00401431(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    uint8_t uVar5;\n    int32_t iVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar6 = *(param_1 + 0x1c);\n    iVar4 = *(param_1 + 0x20);\n    iVar1 = *(param_1 + 0x24);\n    uVar5 = 1;\n    if ((iVar6 == iVar4) && (iVar6 != 0)) {\n        uVar5 = 0;\n    }\n    if ((iVar6 == iVar1) && (iVar6 != 0)) {\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = 1;\n    }\n    if ((iVar4 == iVar1) && (iVar4 != 0)) {\n        uVar2 = 0;\n    }\n    else {\n        uVar2 = 1;\n    }\n    uVar5 = ((iVar6 != param_1 && iVar4 != param_1) && iVar1 != param_1) & uVar5 & uVar3 &\n            ((*(param_1 + 4) != *(param_1 + 8) && *(param_1 + 4) != *(param_1 + 0xc)) &&\n            *(param_1 + 8) != *(param_1 + 0xc)) & uVar2;\n    iVar6 = 0;\n    do {\n        if (*(param_1 + 0x1c + (iVar6 % 3) * 4) != 0) {\n            iVar4 = fcn.00401688(param_1);\n            if (iVar4 == 0) {\n                uVar5 = 0;\n            }\n        }\n        iVar6 = iVar6 + 1;\n    } while (iVar6 < 3);\n    return uVar5;\n}\n",
        "token_count": 443
    },
    "004016a5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004016a5(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    bool bVar4;\n    int32_t var_4h;\n    \n    iVar1 = arg_8h;\n    iVar3 = 0;\n    if (arg_8h == 0) {\n        bVar4 = false;\n    }\n    else {\n        arg_8h = 0;\n        do {\n            var_4h = 3;\n            piVar2 = in_ECX + 4;\n            do {\n                iVar3 = iVar3 + (*(iVar1 + 4 + (arg_8h % 6) * 4) == *piVar2);\n                piVar2 = piVar2 + 1;\n                var_4h = var_4h + -1;\n            } while (var_4h != 0);\n            arg_8h = arg_8h + 1;\n        } while (arg_8h < 3);\n        bVar4 = iVar3 == 2;\n    }\n    return bVar4;\n}\n",
        "token_count": 260
    },
    "004016fe": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004016fe(int32_t arg_8h, uint *arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    uint uVar7;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.004016a5(arg_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_14h = 0;\n    var_10h = 0;\n    var_ch = 0;\n    var_20h = 0;\n    var_1ch = 0;\n    var_18h = 0;\n    var_4h = 0;\n    puVar4 = &var_20h;\n    uVar7 = 1;\n    do {\n        iVar5 = 3;\n        iVar1 = *(arg_8h + 4 + (var_4h % 6) * 4);\n        puVar2 = &var_14h;\n        piVar6 = var_8h;\n        do {\n            piVar6 = piVar6 + 1;\n            if (iVar1 == *piVar6) {\n                *puVar2 = 1;\n                *puVar4 = 1;\n            }\n            puVar2 = puVar2 + 1;\n            iVar5 = iVar5 + -1;\n        } while (iVar5 != 0);\n        var_4h = var_4h + 1;\n        puVar4 = puVar4 + 1;\n    } while (var_4h < 3);\n    if (var_14h == 0) {\n        if ((var_10h == 0) || (uVar3 = uVar7,  var_ch == 0)) goto code_r0x0040178e;\n    }\n    else if (var_10h == 0) {\ncode_r0x0040178e:\n        uVar3 = 2;\n    }\n    else {\n        uVar3 = 0;\n    }\n    *arg_ch = uVar3;\n    if (var_20h == 0) {\n        if ((var_1ch != 0) && (var_18h != 0)) goto code_r0x004017b5;\n    }\n    else if (var_1ch != 0) {\n        uVar7 = 0;\n        goto code_r0x004017b5;\n    }\n    uVar7 = 2;\ncode_r0x004017b5:\n    *arg_10h = uVar7;\n    return 1;\n}\n",
        "token_count": 658
    },
    "00401bde": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00401bde(uint noname_0, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    uint var_2ch;\n    ushort var_28h;\n    ushort var_26h;\n    ushort var_24h;\n    ushort var_22h;\n    ushort var_20h;\n    ushort var_1eh;\n    ushort var_1ch;\n    ushort var_1ah;\n    ushort var_18h;\n    int32_t var_16h;\n    int32_t var_10h;\n    int32_t **var_ch;\n    int32_t *var_8h;\n    uint32_t var_4h;\n    \n    iVar2 = fcn.00401b5b();\n    var_16h._0_2_ = 0;\n    var_2ch._0_2_ = 0x61;\n    var_2ch._2_2_ = 0x73;\n    var_28h = 0x77;\n    var_26h = 0x68;\n    var_24h = 0x6f;\n    var_22h = 0x6f;\n    var_20h = 0x6b;\n    var_1eh = 0x2e;\n    var_1ch = 100;\n    var_1ah = 0x6c;\n    var_18h = 0x6c;\n    var_ch = *(*(iVar2 + 0xc) + 0xc);\n    ppiVar4 = *var_ch;\n    if (ppiVar4 != var_ch) {\n        do {\n            piVar1 = ppiVar4[6];\n            if (piVar1 == NULL) {\n                return 0;\n            }\n            iVar2 = *(piVar1[0xf] + 0x78 + piVar1);\n            var_8h = *(iVar2 + 0x20 + piVar1) + piVar1;\n            *NULL = *(piVar1 + iVar2 + 0x1c) + piVar1;\n            var_10h = *(piVar1 + iVar2 + 0x24) + piVar1;\n            iVar3 = fcn.004100e7(ppiVar4[0xc], &var_2ch);\n            if ((iVar3 != 0) && (var_4h = 0,  *(piVar1 + iVar2 + 0x18) != 0)) {\n                do {\n                    iVar3 = fcn.00401b6d(piVar1 + *var_8h, arg_ch);\n                    if (iVar3 == 0) {\n                        return *(stack0xffffffe8 + *(var_10h + var_4h * 2) * 4) + piVar1;\n                    }\n                    var_4h = var_4h + 1;\n                    var_8h = var_8h + 1;\n                } while (var_4h < *(piVar1 + iVar2 + 0x18));\n            }\n            ppiVar4 = *ppiVar4;\n        } while (ppiVar4 != var_ch);\n    }\n    return 0;\n}\n",
        "token_count": 724
    },
    "00403704": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00403704(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = *(param_1 + 8);\n    iVar2 = *(param_1 + 0x18);\n    if ((iVar1 < 3) || (iVar2 < 1)) {\n        uVar7 = 0;\n    }\n    else {\n        iVar9 = 0;\n        if (0 < iVar2) {\n            do {\n                iVar8 = 0;\n                do {\n                    *(*(*(param_1 + 0x14) + iVar9 * 4) + 0x1c + (iVar8 % 3) * 4) = 0;\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < 6);\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < iVar2);\n        }\n        iVar9 = 0;\n        if (0 < iVar1) {\n            do {\n                fcn.00407b9e();\n                fcn.00407b45();\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < iVar1);\n        }\n        iVar9 = 0;\n        if (0 < iVar2) {\n            do {\n                var_4h = 0;\n                uVar7 = *(*(param_1 + 0x14) + iVar9 * 4);\n                do {\n                    fcn.00407b52(uVar7);\n                    var_4h = var_4h + 1;\n                } while (var_4h < 3);\n                iVar9 = iVar9 + 1;\n            } while (iVar9 < iVar2);\n        }\n        var_4h = 0;\n        if (0 < iVar1) {\n            do {\n                iVar9 = *(*(param_1 + 4) + var_4h * 4);\n                iVar8 = fcn.00407b9a();\n                var_10h = 0;\n                if (0 < iVar8) {\n                    do {\n                        var_ch = 0;\n                        iVar3 = *(*(iVar9 + 0x3c) + var_10h * 4);\n                        do {\n                            fcn.00407b1d(*(iVar3 + 4 + (var_ch % 6) * 4));\n                            var_ch = var_ch + 1;\n                        } while (var_ch < 3);\n                        var_10h = var_10h + 1;\n                    } while (var_10h < iVar8);\n                }\n                var_4h = var_4h + 1;\n            } while (var_4h < iVar1);\n        }\n        var_4h = 0;\n        if (0 < iVar2) {\n            do {\n                iVar1 = *(*(param_1 + 0x14) + var_4h * 4);\n                iVar9 = 0;\n                do {\n                    iVar8 = iVar9 + 1;\n                    iVar3 = *(iVar1 + 4 + (iVar9 % 6) * 4);\n                    iVar5 = fcn.00407b9a();\n                    var_10h = 0;\n                    if (0 < iVar5) {\n                        do {\n                            iVar4 = *(*(iVar3 + 0x3c) + var_10h * 4);\n                            if ((((iVar4 != iVar1) && (*(iVar1 + 0x1c + (iVar9 % 3) * 4) == 0)) &&\n                                (iVar6 = fcn.0040166b(3, iVar3),  iVar6 != 0)) && (iVar6 = fcn.0040166b(),  iVar6 != 0))\n                            {\n                                *(iVar1 + 0x1c + (iVar9 % 3) * 4) = iVar4;\n                            }\n                            var_10h = var_10h + 1;\n                        } while (var_10h < iVar5);\n                    }\n                    iVar9 = iVar8;\n                } while (iVar8 < 3);\n                var_4h = var_4h + 1;\n            } while (var_4h < iVar2);\n        }\n        uVar7 = 1;\n    }\n    return uVar7;\n}\n",
        "token_count": 1051
    },
    "0040390c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.0040390c(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = 0;\n    iVar2 = *(extraout_ECX + 8);\n    *(unaff_EBP + -0x18) = iVar2;\n    if (0 < iVar2) {\n        do {\n            *(unaff_EBP + -0x28) = 0x447940;\n            *(unaff_EBP + -0x1c) = 0;\n            *(unaff_EBP + -0x20) = 0;\n            *(unaff_EBP + -0x24) = 0;\n            iVar3 = 0;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = fcn.00407b9a();\n            *(unaff_EBP + -0x14) = iVar2;\n            if (0 < iVar2) {\n                do {\n                    fcn.00407a5a();\n                    iVar3 = iVar3 + 1;\n                } while (iVar3 < *(unaff_EBP + -0x14));\n                if (0 < *(unaff_EBP + -0x14)) {\n                    fcn.00407abe();\n                    fcn.00407a39(unaff_EBP + -0x28);\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00407990();\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n        } while (*(unaff_EBP + -0x10) < *(unaff_EBP + -0x18));\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 0xbc) = 1;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 503
    },
    "00403a57": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Variable defined which should be unmapped: var_44h\n\nuint __cdecl fcn.00403a57(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    float *pfVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t extraout_ECX;\n    int32_t *piVar10;\n    int32_t iVar11;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    float *pfVar12;\n    uint *in_FS_OFFSET;\n    float10 fVar13;\n    float10 fVar14;\n    uint var_5ch;\n    uint var_54h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *(unaff_EBP + -0x14) = *(extraout_ECX + 8);\n    iVar5 = *(extraout_ECX + 0x18);\n    *(unaff_EBP + -0x20) = iVar5;\n    iVar11 = extraout_ECX;\n    if (0 < iVar5) {\n        do {\n            iVar5 = *(*(iVar11 + 0x14) + *(unaff_EBP + -0x10) * 4);\n            iVar3 = fcn.004015d4();\n            if ((iVar3 != 0) && (iVar3 = fcn.00401431(),  iVar3 != 0)) {\n                *(unaff_EBP + -0x1c) = 0;\n                do {\n                    iVar3 = *(unaff_EBP + -0x1c) % 3;\n                    iVar11 = *(iVar5 + 0x1c + iVar3 * 4);\n                    if (iVar11 != 0) {\n                        fcn.004016fe(iVar11, unaff_EBP + -0x30, unaff_EBP + -0x24);\n                        if (*(iVar11 + 0x40) == 0) {\n                            iVar3 = *(unaff_EBP + -0x1c);\n                            *(unaff_EBP + -0x28) = 3;\n                            *(unaff_EBP + -0x5c) = *(iVar5 + 4 + (iVar3 % 6) * 4);\n                            pfVar4 = *(iVar5 + 4 + (((iVar3 + 1) % 3) % 6) * 4);\n                            *(unaff_EBP + -0x54) = *(iVar5 + 4 + (((iVar3 + 2) % 3) % 6) * 4);\n                            pfVar12 = unaff_EBP + -0x3c;\n                            iVar11 = *(iVar11 + 4 + (((*(unaff_EBP + -0x24) + 2) % 3) % 6) * 4);\n                            *(unaff_EBP + -0x2c) = *(unaff_EBP + -0x5c) - pfVar4;\n                            iVar3 = *(unaff_EBP + -0x54) - pfVar4;\n                            iVar11 = iVar11 - pfVar4;\n                            do {\n                                pfVar4 = pfVar4 + 1;\n                                *pfVar12 = ((*(*(unaff_EBP + -0x2c) + pfVar4) + *pfVar4) * *0x447cf8 +\n                                            *(iVar11 + pfVar4) + *(iVar3 + pfVar4)) * *0x447d00;\n                                pfVar12 = pfVar12 + 1;\n                                piVar10 = unaff_EBP + -0x28;\n                                *piVar10 = *piVar10 + -1;\n                            } while (*piVar10 != 0);\n                            iVar11 = fcn.004253fd(0x4c);\n                            *(unaff_EBP + -0x2c) = iVar11;\n                            uVar6 = 0;\n                            *(unaff_EBP + -4) = 0;\n                            if (iVar11 != 0) {\n                                unaff_EBX = *(unaff_EBP + -0x3c);\n                                uVar6 = fcn.0040411b();\n                            }\n                            *(unaff_EBP + -4) = 0xffffffff;\n                            fcn.0040477f(*(*(unaff_EBP + -0x18) + 8), uVar6);\n                            *(iVar5 + 4 + ((*(unaff_EBP + -0x30) + 3) % 6) * 4) = uVar6;\n                        }\n                        else {\n                            *(iVar5 + 4 + ((iVar3 + 3) % 6) * 4) =\n                                 *(iVar11 + 4 + ((*(unaff_EBP + -0x24) % 3 + 3) % 6) * 4);\n                        }\n                    }\n                    *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 1;\n                } while (*(unaff_EBP + -0x1c) < 3);\n                iVar11 = *(unaff_EBP + -0x18);\n                *(iVar5 + 0x40) = 1;\n            }\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n        } while (*(unaff_EBP + -0x10) < *(unaff_EBP + -0x20));\n    }\n    iVar5 = 0;\n    *(unaff_EBP + -0x10) = 0;\n    if (0 < *(unaff_EBP + -0x20)) {\n        do {\n            iVar5 = *(*(iVar11 + 0x14) + iVar5 * 4);\n            *(iVar5 + 0x40) = 0;\n            iVar3 = fcn.004015ba();\n            if (iVar3 == 4) {\n                if (*(iVar5 + 0x10) == 0) {\n                    if (*(iVar5 + 0x14) != 0) {\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x2c) = iVar3;\n                        *(unaff_EBP + -4) = 2;\n                        if (iVar3 == 0) {\n                            uVar6 = 0;\n                        }\n                        else {\n                            unaff_EBX = *(iVar5 + 4);\n                            uVar6 = fcn.0040139c(unaff_EBX, *(iVar5 + 0x14), *(iVar5 + 0xc));\n                        }\n                        uVar1 = *(iVar11 + 0x18);\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.0040477f(uVar1, uVar6);\n                        uVar6 = *(iVar5 + 0x14);\n                        goto code_r0x00403f8a;\n                    }\n                    if (*(iVar5 + 0x18) != 0) {\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x2c) = iVar3;\n                        *(unaff_EBP + -4) = 3;\n                        if (iVar3 != 0) {\n                            var_54h = *(iVar5 + 0x18);\n                            goto code_r0x00403f72;\n                        }\ncode_r0x00403f79:\n                        uVar6 = 0;\n                        goto code_r0x00403f7b;\n                    }\n                }\n                else {\n                    iVar3 = fcn.004253fd(0x44);\n                    *(unaff_EBP + -0x2c) = iVar3;\n                    *(unaff_EBP + -4) = 1;\n                    if (iVar3 == 0) {\n                        uVar6 = 0;\n                    }\n                    else {\n                        unaff_EBX = *(iVar5 + 0x10);\n                        uVar6 = fcn.0040139c(unaff_EBX, *(iVar5 + 8), *(iVar5 + 0xc));\n                    }\n                    uVar1 = *(iVar11 + 0x18);\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.0040477f(uVar1, uVar6);\n                    uVar6 = *(iVar5 + 0x10);\ncode_r0x00403e33:\n                    *(iVar5 + 8) = uVar6;\n                }\n            }\n            else if (iVar3 == 5) {\n                if (*(iVar5 + 0x10) == 0) {\ncode_r0x00403e3b:\n                    if ((*(iVar5 + 0x14) != 0) && (*(iVar5 + 0x18) != 0)) {\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x2c) = iVar3;\n                        *(unaff_EBP + -4) = 8;\n                        if (iVar3 == 0) {\n                            var_54h = 0;\n                        }\n                        else {\n                            unaff_EBX = *(iVar5 + 8);\n                            var_54h = fcn.0040139c(unaff_EBX, *(iVar5 + 0x14), *(iVar5 + 0x18));\n                        }\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.00404619();\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x2c) = iVar3;\n                        *(unaff_EBP + -4) = 9;\n                        if (iVar3 == 0) goto code_r0x00403f79;\ncode_r0x00403f72:\n                        uVar6 = fcn.0040139c(var_54h, unaff_EBX, var_4ch);\ncode_r0x00403f7b:\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.00404619(uVar6);\n                        goto code_r0x00403f87;\n                    }\n                }\n                else if (*(iVar5 + 0x18) == 0) {\n                    if (*(iVar5 + 0x10) == 0) goto code_r0x00403e3b;\n                    if (*(iVar5 + 0x14) != 0) {\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x2c) = iVar3;\n                        *(unaff_EBP + -4) = 6;\n                        if (iVar3 == 0) {\n                            uVar6 = 0;\n                        }\n                        else {\n                            unaff_EBX = *(iVar5 + 0x10);\n                            uVar6 = fcn.0040139c(unaff_EBX, *(iVar5 + 8), *(iVar5 + 0x14));\n                        }\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.00404619(uVar6);\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x2c) = iVar3;\n                        *(unaff_EBP + -4) = 7;\n                        if (iVar3 == 0) {\n                            uVar6 = 0;\n                        }\n                        else {\n                            uVar6 = fcn.0040139c(*(iVar5 + 4), *(iVar5 + 0x10), *(iVar5 + 0x14));\n                        }\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        fcn.00404619(uVar6);\n                        uVar6 = *(iVar5 + 0x14);\n                        goto code_r0x00403e33;\n                    }\n                }\n                else {\n                    iVar3 = fcn.004253fd(0x44);\n                    *(unaff_EBP + -0x2c) = iVar3;\n                    *(unaff_EBP + -4) = 4;\n                    if (iVar3 == 0) {\n                        uVar6 = 0;\n                    }\n                    else {\n                        unaff_EBX = *(iVar5 + 4);\n                        uVar6 = fcn.0040139c(unaff_EBX, *(iVar5 + 0x10), *(iVar5 + 0x18));\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.00404619(uVar6);\n                    iVar3 = fcn.004253fd(0x44);\n                    *(unaff_EBP + -0x2c) = iVar3;\n                    *(unaff_EBP + -4) = 5;\n                    if (iVar3 == 0) {\n                        uVar6 = 0;\n                    }\n                    else {\n                        uVar6 = fcn.0040139c(*(iVar5 + 0x18), *(iVar5 + 0x10), *(iVar5 + 0xc));\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.00404619(uVar6);\n                    *(iVar5 + 4) = *(iVar5 + 0x10);\n                }\n            }\n            else {\n                if (iVar3 != 6) goto code_r0x00403f8d;\n                iVar3 = fcn.004253fd(0x44);\n                *(unaff_EBP + -0x2c) = iVar3;\n                *(unaff_EBP + -4) = 10;\n                if (iVar3 == 0) {\n                    unaff_EBX = 0;\n                }\n                else {\n                    var_4ch = *(iVar5 + 0x10);\n                    unaff_EBX = fcn.0040139c(var_4ch, *(iVar5 + 8), *(iVar5 + 0x14));\n                }\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00404619();\n                iVar3 = fcn.004253fd(0x44);\n                *(unaff_EBP + -0x2c) = iVar3;\n                *(unaff_EBP + -4) = 0xb;\n                if (iVar3 == 0) {\n                    uVar6 = 0;\n                }\n                else {\n                    unaff_EBX = *(iVar5 + 0x10);\n                    uVar6 = fcn.0040139c(unaff_EBX, *(iVar5 + 0x14), *(iVar5 + 0x18));\n                }\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00404619(uVar6);\n                iVar3 = fcn.004253fd(0x44);\n                *(unaff_EBP + -0x2c) = iVar3;\n                *(unaff_EBP + -4) = 0xc;\n                if (iVar3 == 0) {\n                    uVar6 = 0;\n                }\n                else {\n                    uVar6 = fcn.0040139c(*(iVar5 + 0x18), *(iVar5 + 0x14), *(iVar5 + 0xc));\n                }\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00404619(uVar6);\n                *(iVar5 + 8) = *(iVar5 + 0x10);\ncode_r0x00403f87:\n                uVar6 = *(iVar5 + 0x18);\ncode_r0x00403f8a:\n                *(iVar5 + 0xc) = uVar6;\n            }\ncode_r0x00403f8d:\n            iVar3 = 3;\n            do {\n                *(iVar5 + 4 + (iVar3 % 6) * 4) = 0;\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < 6);\n            iVar5 = *(unaff_EBP + -0x10) + 1;\n            *(unaff_EBP + -0x10) = iVar5;\n        } while (iVar5 < *(unaff_EBP + -0x20));\n        iVar11 = *(unaff_EBP + -0x18);\n    }\n    *(unaff_EBP + -0x4c) = 0;\n    *(unaff_EBP + -0x48) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    iVar5 = *(unaff_EBP + -0x14);\n    *(unaff_EBP + -4) = 0xd;\n    fcn.0040465e(iVar5, 0xffffffff);\n    iVar3 = 0;\n    if (0 < *(unaff_EBP + -0x14)) {\n        do {\n            iVar7 = fcn.004253fd(0x4c);\n            *(unaff_EBP + -0x2c) = iVar7;\n            *(unaff_EBP + -4) = 0xe;\n            if (iVar7 == 0) {\n                uVar6 = 0;\n            }\n            else {\n                uVar6 = fcn.004014f0();\n            }\n            *(unaff_EBP + -4) = 0xd;\n            *(*(unaff_EBP + -0x4c) + iVar3 * 4) = uVar6;\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(unaff_EBP + -0x14));\n    }\n    iVar3 = 0;\n    *(unaff_EBP + -0x10) = 0;\n    if (0 < *(unaff_EBP + -0x14)) {\n        do {\n            iVar11 = *(*(iVar11 + 4) + iVar3 * 4);\n            if ((*(unaff_EBP + 8) == 0) && (iVar7 = fcn.00407bab(),  iVar7 != 0)) {\n                iVar7 = *(*(unaff_EBP + -0x4c) + iVar3 * 4);\n                *(iVar7 + 4) = *(iVar11 + 4);\n                *(iVar7 + 8) = *(iVar11 + 8);\n                *(iVar7 + 0xc) = *(iVar11 + 0xc);\n            }\n            else {\n                iVar8 = fcn.00407b41();\n                *(unaff_EBP + -0x2c) = iVar8;\n                iVar5 = iVar8;\n                fVar13 = fcn.00403a10();\n                iVar7 = *(unaff_EBP + -0x2c);\n                iVar9 = 4;\n                do {\n                    fVar14 = *(iVar9 + iVar11) * fVar13;\n                    if (0 < iVar8) {\n                        piVar10 = *(iVar11 + 0x2c);\n                        iVar3 = iVar8;\n                        do {\n                            iVar2 = *piVar10;\n                            piVar10 = piVar10 + 1;\n                            iVar3 = iVar3 + -1;\n                            fVar14 = fVar14 + *(iVar9 + iVar2);\n                        } while (iVar3 != 0);\n                        iVar3 = *(unaff_EBP + -0x10);\n                    }\n                    *(iVar9 + *(*(unaff_EBP + -0x4c) + iVar3 * 4)) = fVar14 / (iVar7 + fVar13);\n                    iVar9 = iVar9 + 4;\n                } while (iVar9 < 0x10);\n            }\n            iVar11 = *(unaff_EBP + -0x18);\n            iVar3 = iVar3 + 1;\n            *(unaff_EBP + -0x10) = iVar3;\n        } while (iVar3 < *(unaff_EBP + -0x14));\n    }\n    iVar3 = 0;\n    if (0 < *(unaff_EBP + -0x14)) {\n        do {\n            iVar7 = 4;\n            do {\n                *(iVar7 + *(*(iVar11 + 4) + iVar3 * 4)) = *(iVar7 + *(*(unaff_EBP + -0x4c) + iVar3 * 4));\n                iVar7 = iVar7 + 4;\n            } while (iVar7 < 0x10);\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(unaff_EBP + -0x14));\n    }\n    fcn.004045e5(iVar5);\n    fcn.00403704();\n    fcn.004039bf();\n    fcn.0040390c();\n    *(unaff_EBP + -4) = 0xffffffff;\n    uVar6 = *(unaff_EBP + -0x4c);\n    *(iVar11 + 0xbc) = 1;\n    fcn.00425426(uVar6);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 4815
    },
    "004049e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004049e5(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    \n    (*_sym.imp.OPENGL32.dll_glPolygonMode)(0x408, *(param_1 + 0x9c));\n    pcVar2 = _sym.imp.OPENGL32.dll_glEnable;\n    pcVar1 = _sym.imp.OPENGL32.dll_glDisable;\n    if (*(param_1 + 0x98) == 0) {\n        (*_sym.imp.OPENGL32.dll_glDisable)(0xb50);\n    }\n    else {\n        (*_sym.imp.OPENGL32.dll_glEnable)();\n    }\n    fcn.00406c26();\n    if (*(param_1 + 0x8c) != 0) {\n        (*pcVar1)(0xb50);\n        (*_sym.imp.OPENGL32.dll_glPolygonMode)(0x408, 0x1b01);\n        (*pcVar2)(0x2a02);\n        (*_sym.imp.OPENGL32.dll_glPolygonOffset)(*(param_1 + 0x94), *0x447d10);\n        fcn.00406c7c(5);\n        (*pcVar1)(0x2a02);\n        (*pcVar2)(0xb50);\n    }\n    return;\n}\n",
        "token_count": 287
    },
    "00405d0c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1b8h\n\nuint __cdecl fcn.00405d0c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_1b8h;\n    uint var_b4h;\n    uint var_70h;\n    uint var_60h;\n    uint var_50h;\n    uint var_3ch;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = fcn.00405c91();\n    if (iVar1 != 0) {\n        uVar2 = *(extraout_ECX + 8);\n        fcn.004059e6();\n        iVar1 = fcn.004107e8(extraout_ECX + 0x10, \"DEF %s Transform\", extraout_ECX + 0x2720);\n        if (iVar1 == 1) {\n            *(unaff_EBP + -0x20) = 0xffffffff;\n            *(extraout_ECX + 8) = uVar2;\n            fcn.00405bd1(\"Transform\");\n            fcn.004059e6();\n            fcn.00407804();\n            *(unaff_EBP + -4) = 0;\n            fcn.004078d5();\n            uVar2 = *(extraout_ECX + 8);\n            fcn.004059e6();\n            iVar1 = fcn.00410730(extraout_ECX + 0x10, \"translation\");\n            if (iVar1 != 0) {\n                *(extraout_ECX + 8) = uVar2;\n                fcn.00405a21();\n                fcn.00405a21();\n                uVar3 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                fcn.00405a21();\n                uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x14);\n                fcn.00405a21();\n                uVar5 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x10);\n                if ((uVar3 & uVar4 & uVar5) != 0) {\n                    uVar2 = fcn.00407997(*(unaff_EBP + -0x18), *(unaff_EBP + -0x14), *(unaff_EBP + -0x10));\n                    *(unaff_EBP + -4) = 1;\n                    fcn.00407a11(uVar2);\n                    *(unaff_EBP + -4) = 0;\n                    fcn.00407990();\n                }\n                fcn.004059e6();\n                uVar2 = *(extraout_ECX + 8);\n                fcn.004059e6();\n            }\n            iVar1 = fcn.00410730(extraout_ECX + 0x10, \"rotation\");\n            if (iVar1 != 0) {\n                *(extraout_ECX + 8) = uVar2;\n                fcn.00405a21();\n                fcn.00405a21();\n                uVar3 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x14);\n                fcn.00405a21();\n                uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x10);\n                fcn.00405a21();\n                uVar5 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                fcn.00405a21();\n                uVar6 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x1c);\n                if ((uVar3 & uVar4 & uVar5 & uVar6) != 0) {\n                    uVar2 = fcn.00407997(*(unaff_EBP + -0x14), *(unaff_EBP + -0x10), *(unaff_EBP + -0x18));\n                    *(unaff_EBP + -4) = 2;\n                    fcn.00407a11(uVar2);\n                    *(unaff_EBP + -4) = 0;\n                    fcn.00407990();\n                    *(unaff_EBP + -0x40) = *(unaff_EBP + -0x1c) * *0x448228;\n                }\n                fcn.004059e6();\n                uVar2 = *(extraout_ECX + 8);\n                fcn.004059e6();\n            }\n            iVar1 = fcn.00410730(extraout_ECX + 0x10, \"scale\");\n            if (iVar1 != 0) {\n                *(extraout_ECX + 8) = uVar2;\n                fcn.00405a21();\n                fcn.00405a21();\n                uVar3 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x10);\n                fcn.00405a21();\n                uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                fcn.00405a21();\n                uVar5 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x1c);\n                if ((uVar3 & uVar4 & uVar5) != 0) {\n                    uVar2 = fcn.00407997(*(unaff_EBP + -0x10), *(unaff_EBP + -0x18), *(unaff_EBP + -0x1c));\n                    *(unaff_EBP + -4) = 3;\n                    fcn.00407a11(uVar2);\n                    *(unaff_EBP + -4) = 0;\n                    fcn.00407990();\n                }\n                fcn.004059e6();\n                uVar2 = *(extraout_ECX + 8);\n                fcn.004059e6();\n            }\n            iVar1 = fcn.00410730(extraout_ECX + 0x10, \"scaleOrientation\");\n            if (iVar1 != 0) {\n                *(extraout_ECX + 8) = uVar2;\n                fcn.00405a21();\n                fcn.00405a21();\n                fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x1c);\n                fcn.00405a21();\n                fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                fcn.00405a21();\n                fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x10);\n                fcn.00405a21();\n                fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x14);\n                fcn.004059e6();\n            }\n            fcn.00401944();\n            *(unaff_EBP + -4) = 4;\n            iVar1 = fcn.00405bd1(\"Material\");\n            if (iVar1 != 0) {\n                fcn.004059e6();\n                uVar2 = *(extraout_ECX + 8);\n                fcn.004059e6();\n                iVar1 = fcn.00410730(extraout_ECX + 0x10, \"diffuseColor\");\n                if (iVar1 != 0) {\n                    *(extraout_ECX + 8) = uVar2;\n                    fcn.00405a21();\n                    fcn.00405a21();\n                    uVar7 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x14);\n                    *(unaff_EBP + -0x10) = uVar7;\n                    fcn.00405a21();\n                    uVar3 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) & uVar3;\n                    fcn.00405a21();\n                    uVar3 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x1c);\n                    if ((*(unaff_EBP + -0x10) & uVar3) != 0) {\n                        fcn.004019fc(*(unaff_EBP + -0x14), *(unaff_EBP + -0x18), *(unaff_EBP + -0x1c), 0x3f800000);\n                    }\n                }\n            }\n            *(unaff_EBP + -0x10) = 0;\n            iVar1 = fcn.00405c29(\"texture ImageTexture\", \"geometry\");\n            if (iVar1 == 0) {\n                *(extraout_ECX + 8) = uVar2;\n            }\n            else {\n                *(unaff_EBP + -0x10) = 1;\n                fcn.004059e6();\n                uVar2 = *(extraout_ECX + 8);\n                fcn.004059e6();\n                iVar1 = fcn.00410730(extraout_ECX + 0x10, 0x45b9f0);\n                if (iVar1 != 0) {\n                    *(extraout_ECX + 8) = uVar2;\n                    fcn.00405a21();\n                    fcn.00405a21();\n                    fcn.004107e8(extraout_ECX + 0x2720, 0x45b9ec, unaff_EBP + -0x1b8);\n                    fcn.0042a3c6(unaff_EBP + -0x1b8);\n                    *(unaff_EBP + -4) = 5;\n                    uVar2 = fcn.0042328b(unaff_EBP + -0x1c, 1, *(*(unaff_EBP + -0x14) + -8) + -2);\n                    *(unaff_EBP + -4) = 6;\n                    fcn.0042a491(uVar2);\n                    *(unaff_EBP + -4) = 5;\n                    fcn.0042a358();\n                    uVar2 = fcn.0042a714(0x104);\n                    iVar1 = fcn.00406da9(uVar2, unaff_EBP + -0x20);\n                    if (iVar1 == 0) {\n                        iVar1 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x18) = iVar1;\n                        *(unaff_EBP + -4) = 7;\n                        if (iVar1 == 0) {\n                            uVar7 = 0;\n                        }\n                        else {\n                            uVar7 = fcn.00407061();\n                        }\n                        *(unaff_EBP + -4) = 5;\n                        fcn.00407191(uVar2, 0xffffffff, 0xffffffff, 0xffffffff);\n                        uVar2 = fcn.00404619(uVar7);\n                        *(unaff_EBP + -0x20) = uVar2;\n                    }\n                    fcn.0042a763(0xffffffff);\n                    *(unaff_EBP + -4) = 4;\n                    fcn.0042a358();\n                }\n            }\n            iVar1 = fcn.004063a0(unaff_EBP + -0x2c, unaff_EBP + -0x24, *(unaff_EBP + -0x10), unaff_EBP + -0x28);\n            if (iVar1 == 0) {\n                uVar2 = 0;\n            }\n            else {\n                iVar1 = fcn.004253fd(0xc4);\n                *(unaff_EBP + -0x18) = iVar1;\n                *(unaff_EBP + -4) = 8;\n                if (iVar1 == 0) {\n                    iVar1 = 0;\n                }\n                else {\n                    iVar1 = fcn.0040327d();\n                }\n                *(unaff_EBP + -4) = 4;\n                fcn.00406ac1(iVar1);\n                fcn.0040465e(*(unaff_EBP + -0x2c), 0xffffffff);\n                fcn.0040465e(*(unaff_EBP + -0x24), 0xffffffff);\n                if (*(unaff_EBP + -0x10) != 0) {\n                    uVar2 = fcn.004253fd(*(unaff_EBP + -0x28) << 3);\n                    *(iVar1 + 0xac) = uVar2;\n                    uVar2 = fcn.004253fd(*(unaff_EBP + -0x24) * 0xc);\n                    *(iVar1 + 0xb0) = uVar2;\n                    *(iVar1 + 0xa8) = *(unaff_EBP + -0x20);\n                }\n                fcn.00406665(iVar1 + 4, iVar1 + 0x14, *(unaff_EBP + -0x10), *(iVar1 + 0xac), *(iVar1 + 0xb0));\n                fcn.0040795f(unaff_EBP + -0x70);\n                fcn.00401a63(unaff_EBP + -0xb4);\n                uVar2 = 1;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00403335();\n            goto code_r0x0040638f;\n        }\n    }\n    uVar2 = 0;\ncode_r0x0040638f:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 3366
    },
    "004063a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004063a0(int32_t *arg_8h, int32_t *arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_18h = *(in_ECX + 8);\n    iVar1 = fcn.00405bd1(\"IndexedFaceSet\");\n    if ((iVar1 != 0) && (iVar1 = fcn.00405bd1(\"Coordinate { point [\"),  iVar1 != 0)) {\n        iVar1 = fcn.004101b0(\"Coordinate { point [\");\n        *(in_ECX + 8) = *(in_ECX + 8) + iVar1 + 1;\n        var_ch = 0;\n        iVar1 = in_ECX + 0x2720;\n        do {\n            fcn.00405a21();\n            var_4h = fcn.004107e8(iVar1, 0x45ba50, &var_14h);\n            fcn.00405a21();\n            uVar2 = fcn.004107e8(iVar1, 0x45ba50, &var_10h);\n            var_4h = var_4h & uVar2;\n            fcn.00405a21();\n            uVar2 = fcn.004107e8(iVar1, 0x45ba50, &var_8h);\n            var_ch = var_ch + (var_4h & uVar2);\n        } while ((var_4h & uVar2) != 0);\n        if (0 < var_ch) {\n            var_10h = 0;\n            if (arg_10h != 0) {\n                iVar3 = fcn.00405bd1(\"TextureCoordinate { point [\");\n                if (iVar3 == 0) {\n                    return 0;\n                }\n                iVar3 = fcn.004101b0(\"TextureCoordinate { point [\");\n                *(in_ECX + 8) = *(in_ECX + 8) + iVar3 + 1;\n                do {\n                    fcn.00405a21();\n                    var_14h = fcn.004107e8(iVar1, 0x45ba50, &var_8h);\n                    fcn.00405a21();\n                    uVar2 = fcn.004107e8(iVar1, 0x45ba50, &var_4h);\n                    var_10h = var_10h + (var_14h & uVar2);\n                } while ((var_14h & uVar2) != 0);\n                if (var_10h < 1) {\n                    return 0;\n                }\n            }\n            *(in_ECX + 8) = var_18h;\n            iVar3 = fcn.00405bd1(\"coordIndex [\");\n            if (iVar3 != 0) {\n                iVar3 = fcn.004101b0(\"coordIndex [\");\n                *(in_ECX + 8) = *(in_ECX + 8) + iVar3 + 1;\n                var_8h = 0;\n                do {\n                    fcn.00405a21();\n                    var_4h = fcn.004107e8(iVar1, 0x45ba8c, &var_14h);\n                    fcn.00405a21();\n                    uVar2 = fcn.004107e8(iVar1, 0x45ba8c, &var_1ch);\n                    var_4h = var_4h & uVar2;\n                    fcn.00405a21();\n                    uVar2 = fcn.004107e8(iVar1, 0x45ba8c, &var_20h);\n                    var_4h = var_4h & uVar2;\n                    var_8h = var_8h + var_4h;\n                    fcn.00405a21();\n                    fcn.004107e8(iVar1, 0x45ba88, &var_24h);\n                    iVar3 = fcn.00410730(iVar1, 0x45ba84);\n                    if (iVar3 != 0) {\n                        var_4h = 0;\n                    }\n                } while (var_4h != 0);\n                if (0 < var_8h) {\n                    if (arg_10h == 0) {\ncode_r0x00406637:\n                        *arg_8h = var_ch;\n                        *arg_ch = var_8h;\n                        if (arg_10h != 0) {\n                            *arg_14h = var_10h;\n                        }\n                        *(in_ECX + 8) = var_18h;\n                        return 1;\n                    }\n                    *(in_ECX + 8) = var_18h;\n                    iVar3 = fcn.00405bd1(\"texCoordIndex [\");\n                    if (iVar3 != 0) {\n                        iVar3 = fcn.004101b0(\"texCoordIndex [\");\n                        *(in_ECX + 8) = *(in_ECX + 8) + iVar3 + 1;\n                        var_14h = 0;\n                        do {\n                            fcn.00405a21();\n                            var_4h = fcn.004107e8(iVar1, 0x45ba8c, &var_24h);\n                            fcn.00405a21();\n                            uVar2 = fcn.004107e8(iVar1, 0x45ba8c, &var_20h);\n                            var_4h = var_4h & uVar2;\n                            fcn.00405a21();\n                            uVar2 = fcn.004107e8(iVar1, 0x45ba8c, &var_1ch);\n                            var_4h = var_4h & uVar2;\n                            var_14h = var_14h + var_4h;\n                            fcn.00405a21();\n                            fcn.004107e8(iVar1, 0x45ba88, &var_28h);\n                            iVar3 = fcn.00410730(iVar1, 0x45ba84);\n                            if (iVar3 != 0) {\n                                var_4h = 0;\n                            }\n                        } while (var_4h != 0);\n                        if (var_8h == var_14h) goto code_r0x00406637;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1527
    },
    "00406665": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nuint __cdecl fcn.00406665(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint uVar7;\n    uint *puVar8;\n    int32_t extraout_ECX;\n    int32_t *piVar9;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x20) = *(extraout_ECX + 8);\n    iVar3 = fcn.00405bd1(\"IndexedFaceSet\");\n    if (iVar3 != 0) {\n        iVar3 = fcn.00405bd1(\"Coordinate { point [\");\n        if (iVar3 != 0) {\n            iVar3 = fcn.004101b0(\"Coordinate { point [\");\n            *(extraout_ECX + 8) = *(extraout_ECX + 8) + iVar3 + 1;\n            *(unaff_EBP + -0x10) = 0;\n            while( true ) {\n                fcn.00405a21();\n                uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x14);\n                fcn.00405a21();\n                uVar5 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                fcn.00405a21();\n                uVar6 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x1c);\n                if ((uVar4 & uVar5 & uVar6) == 0) break;\n                iVar3 = fcn.004253fd(0x4c);\n                *(unaff_EBP + -0x24) = iVar3;\n                *(unaff_EBP + -4) = 0;\n                if (iVar3 == 0) {\n                    uVar7 = 0;\n                }\n                else {\n                    uVar7 = fcn.0040411b(*(unaff_EBP + -0x14), *(unaff_EBP + -0x18), *(unaff_EBP + -0x1c));\n                }\n                iVar3 = *(unaff_EBP + -0x10);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 4;\n                *(**(unaff_EBP + 8) + iVar3) = uVar7;\n            }\n            if (*(unaff_EBP + 0x10) != 0) {\n                iVar3 = fcn.00405bd1(\"TextureCoordinate { point [\");\n                if (iVar3 == 0) goto code_r0x00406913;\n                iVar3 = fcn.004101b0(\"TextureCoordinate { point [\");\n                *(extraout_ECX + 8) = *(extraout_ECX + 8) + iVar3 + 1;\n                puVar8 = *(unaff_EBP + 0x14);\n                while( true ) {\n                    *(unaff_EBP + 0x14) = puVar8;\n                    fcn.00405a21();\n                    uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x1c);\n                    fcn.00405a21();\n                    uVar5 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba50, unaff_EBP + -0x18);\n                    if ((uVar4 & uVar5) == 0) break;\n                    puVar8 = *(unaff_EBP + 0x14);\n                    *puVar8 = *(unaff_EBP + -0x1c);\n                    puVar8[1] = *(unaff_EBP + -0x18);\n                    puVar8 = puVar8 + 2;\n                }\n            }\n            *(extraout_ECX + 8) = *(unaff_EBP + -0x20);\n            iVar3 = fcn.00405bd1(\"coordIndex [\");\n            if (iVar3 != 0) {\n                iVar3 = fcn.004101b0(\"coordIndex [\");\n                *(extraout_ECX + 8) = *(extraout_ECX + 8) + iVar3 + 1;\n                *(unaff_EBP + -0x10) = 0;\n                do {\n                    fcn.00405a21();\n                    iVar3 = extraout_ECX + 0x2720;\n                    uVar7 = fcn.004107e8(iVar3, 0x45ba8c, unaff_EBP + -0x1c);\n                    *(unaff_EBP + 0x14) = uVar7;\n                    fcn.00405a21();\n                    uVar4 = fcn.004107e8(iVar3, 0x45ba8c, unaff_EBP + -0x18);\n                    *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) & uVar4;\n                    fcn.00405a21();\n                    uVar4 = fcn.004107e8(iVar3, 0x45ba8c, unaff_EBP + -0x14);\n                    puVar1 = unaff_EBP + 0x14;\n                    *puVar1 = *puVar1 & uVar4;\n                    if ((((*puVar1 != 0) && (-1 < *(unaff_EBP + -0x1c))) && (-1 < *(unaff_EBP + -0x18))) &&\n                       (-1 < *(unaff_EBP + -0x14))) {\n                        iVar3 = fcn.004253fd(0x44);\n                        *(unaff_EBP + -0x24) = iVar3;\n                        *(unaff_EBP + -4) = 1;\n                        if (iVar3 == 0) {\n                            uVar7 = 0;\n                        }\n                        else {\n                            iVar3 = **(unaff_EBP + 8);\n                            uVar7 = fcn.0040139c(*(iVar3 + *(unaff_EBP + -0x1c) * 4), \n                                                 *(iVar3 + *(unaff_EBP + -0x18) * 4), \n                                                 *(iVar3 + *(unaff_EBP + -0x14) * 4));\n                        }\n                        iVar3 = *(unaff_EBP + -0x10);\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 4;\n                        *(**(unaff_EBP + 0xc) + iVar3) = uVar7;\n                    }\n                    fcn.00405a21();\n                    fcn.004107e8(extraout_ECX + 0x2720, 0x45ba88, unaff_EBP + -0x28);\n                    iVar3 = fcn.00410730(extraout_ECX + 0x2720, 0x45ba84);\n                    if (iVar3 != 0) {\n                        *(unaff_EBP + 0x14) = 0;\n                    }\n                } while (*(unaff_EBP + 0x14) != 0);\n                if (*(unaff_EBP + 0x10) != 0) {\n                    *(extraout_ECX + 8) = *(unaff_EBP + -0x20);\n                    iVar3 = fcn.00405bd1(\"texCoordIndex [\");\n                    if (iVar3 == 0) goto code_r0x00406913;\n                    iVar3 = fcn.004101b0(\"texCoordIndex [\");\n                    *(extraout_ECX + 8) = *(extraout_ECX + 8) + iVar3 + 1;\n                    piVar9 = *(unaff_EBP + 0x18) + 8;\n                    do {\n                        fcn.00405a21();\n                        uVar7 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba8c, unaff_EBP + 8);\n                        *(unaff_EBP + 0x14) = uVar7;\n                        fcn.00405a21();\n                        uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba8c, unaff_EBP + 0x10);\n                        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) & uVar4;\n                        fcn.00405a21();\n                        uVar4 = fcn.004107e8(extraout_ECX + 0x2720, 0x45ba8c, unaff_EBP + 0xc);\n                        puVar1 = unaff_EBP + 0x14;\n                        *puVar1 = *puVar1 & uVar4;\n                        if (((*puVar1 != 0) && (-1 < *(unaff_EBP + 8))) &&\n                           ((iVar3 = *(unaff_EBP + 0x10),  -1 < iVar3 && (iVar2 = *(unaff_EBP + 0xc),  -1 < iVar2)))) {\n                            piVar9[-2] = *(unaff_EBP + 8);\n                            piVar9[-1] = iVar3;\n                            *piVar9 = iVar2;\n                            piVar9 = piVar9 + 3;\n                        }\n                        fcn.00405a21();\n                        fcn.004107e8(extraout_ECX + 0x2720, 0x45ba88, unaff_EBP + 0x18);\n                        iVar3 = fcn.00410730(extraout_ECX + 0x2720, 0x45ba84);\n                        if (iVar3 != 0) {\n                            *(unaff_EBP + 0x14) = 0;\n                        }\n                    } while (*(unaff_EBP + 0x14) != 0);\n                }\n                uVar7 = 1;\n                goto code_r0x004069ec;\n            }\n        }\n    }\ncode_r0x00406913:\n    uVar7 = 0;\ncode_r0x004069ec:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar7;\n}\n",
        "token_count": 2525
    },
    "00407281": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_50h\n\nuint fcn.00407281(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_44h;\n    uint var_10h;\n    uint var_58h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h_2;\n    uint var_34h;\n    uint var_24h;\n    uint var_1ch;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &stack0xffffffa8;\n    fcn.0042ad06();\n    uVar2 = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a883();\n    *(unaff_EBP + -0x48) = *0x45c084;\n    *(unaff_EBP + -0x4c) = 0xffffffff;\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x58) = vtable.CFileException.0;\n    *(unaff_EBP + -0x50) = 0;\n    fcn.0042a4e1(0);\n    *(unaff_EBP + -4) = 3;\n    iVar1 = fcn.0042ae18(*(unaff_EBP + 8), 0x8000, unaff_EBP + -0x58);\n    if (iVar1 == 0) {\n        fcn.004344cf(\"Unable to open file for reading\", 0, 0);\n        *(unaff_EBP + -0x58) = vtable.CFileException.0;\n        *(unaff_EBP + -4) = 4;\n    }\n    else {\n        fcn.0042a900();\n        *(unaff_EBP + -4) = 6;\n        fcn.0042af35(unaff_EBP + -0x34, 0xe);\n        *(unaff_EBP + -4) = 3;\n        fcn.0042a93e();\n        if (*(unaff_EBP + -0x34) == 0x4d42) {\n            fcn.0042a900();\n            *(unaff_EBP + -4) = 0xb;\n            fcn.0042af35(extraout_ECX + 0x18, 0x28);\n            *(unaff_EBP + -4) = 3;\n            fcn.0042a93e();\n            if ((*(extraout_ECX + 0x24) == 1) && (*(extraout_ECX + 0x26) == 0x18)) {\n                fcn.0040716e();\n                iVar1 = fcn.004253fd(*(extraout_ECX + 0x2c));\n                *(extraout_ECX + 4) = iVar1;\n                if (iVar1 == 0) {\n                    fcn.004344cf(\"Insuffisant memory\", 0, 0);\n                    fcn.0042b033();\n                    *(unaff_EBP + -0x58) = vtable.CFileException.0;\n                    *(unaff_EBP + -4) = 0xf;\n                }\n                else {\n                    *(extraout_ECX + 8) = *(extraout_ECX + 0x1c);\n                    *(extraout_ECX + 0xc) = *(extraout_ECX + 0x20);\n                    *(extraout_ECX + 0x10) = *(extraout_ECX + 0x26);\n                    fcn.0042a900();\n                    uVar2 = *(extraout_ECX + 0x2c);\n                    *(unaff_EBP + -4) = 0x11;\n                    fcn.0042af35(*(extraout_ECX + 4), uVar2);\n                    *(unaff_EBP + -4) = 3;\n                    fcn.0042a93e();\n                    fcn.0042b033();\n                    fcn.0042a4e1(*(unaff_EBP + 8));\n                    fcn.00407526();\n                    *(unaff_EBP + -0x58) = vtable.CFileException.0;\n                    *(unaff_EBP + -4) = 0x14;\n                    uVar2 = 1;\n                }\n            }\n            else {\n                fcn.004344cf(\"Texture file must have 24 bits depth\", 0, 0);\n                fcn.0042b033();\n                *(unaff_EBP + -0x58) = vtable.CFileException.0;\n                *(unaff_EBP + -4) = 0xe;\n            }\n        }\n        else {\n            fcn.004344cf(\"Invalid BMP file\", 0, 0);\n            fcn.0042b033();\n            *(unaff_EBP + -0x58) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 9;\n        }\n    }\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042ad5b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 1249
    },
    "00407bab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00407bab(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_8h = 0;\n    if (0 < *(param_1 + 0x40)) {\n        var_4h = *(param_1 + 0x3c);\n        do {\n            iVar2 = 0;\n            iVar1 = *var_4h;\n            do {\n                if ((*(iVar1 + 0x1c + (iVar2 % 3) * 4) == 0) &&\n                   ((*(iVar1 + 4 + (iVar2 % 6) * 4) == param_1 ||\n                    (*(iVar1 + 4 + (((iVar2 + 1) % 3) % 6) * 4) == param_1)))) {\n                    return 1;\n                }\n                iVar2 = iVar2 + 1;\n            } while (iVar2 < 3);\n            var_8h = var_8h + 1;\n            var_4h = var_4h + 1;\n        } while (var_8h < *(param_1 + 0x40));\n    }\n    return 0;\n}\n",
        "token_count": 286
    },
    "0040807f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t fcn.0040807f(int32_t param_1, int32_t param_2)\n\n{\n    uint16_t *puVar1;\n    uint16_t uVar2;\n    \n    if (param_2 == 0) {\n        puVar1 = param_1 + 0x12;\n    }\n    else {\n        puVar1 = param_1 + 0x18;\n    }\n    uVar2 = *puVar1;\n    if (uVar2 == 0xffff) {\n        puVar1 = puVar1 + 2;\n    }\n    else {\n        while (puVar1 = puVar1 + 1,  uVar2 != 0) {\n            uVar2 = *puVar1;\n        }\n    }\n    uVar2 = *puVar1;\n    if (uVar2 == 0xffff) {\n        puVar1 = puVar1 + 2;\n    }\n    else {\n        while (puVar1 = puVar1 + 1,  uVar2 != 0) {\n            uVar2 = *puVar1;\n        }\n    }\n    return *puVar1 + 5 + puVar1 & 0xfffffffc;\n}\n",
        "token_count": 262
    },
    "004084bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004084bf(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = arg_8h;\n    if (*(arg_8h + 0x34) != 0) {\n        var_4h = -(*(*(arg_8h + 0x34) + 0x2c) != 0);\n        while (var_4h != 0) {\n            fcn.00425110(&var_4h, &var_8h, &arg_8h);\n            iVar2 = *(arg_8h + 0x8c);\n            while (iVar2 != 0) {\n                fcn.0040e3f1(arg_8h);\n                if (*(iVar2 + 4) != 0) {\n                    iVar2 = fcn.004286f7(*(iVar2 + 4));\n                    fcn.0040e3fa(*(iVar2 + 0x38));\n                }\n                iVar2 = fcn.0040e40e();\n            }\n            if (*(arg_8h + 0x90) != 0) {\n                iVar2 = fcn.004286f7(*(arg_8h + 0x90));\n                (**(**(iVar2 + 0x38) + 0xb0))();\n                *(arg_8h + 0x90) = *(iVar2 + 0x38);\n                (**(**(*(iVar2 + 0x38) + 0x88) + 8))(arg_8h, 1);\n            }\n        }\n        var_4h = -(*(*(iVar1 + 0x34) + 0x2c) != 0);\n        while (var_4h != 0) {\n            fcn.00425110(&var_4h, &var_8h, &arg_8h);\n            if (*(arg_8h + 0x88) != NULL) {\n                (**(**(arg_8h + 0x88) + 0xc))();\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 479
    },
    "004085da": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8ch\n\nuint __cdecl\nfcn.004085da(uint arg_8h, uint hWndInsertAfter, uint pbstr, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    ushort uVar1;\n    ushort uVar2;\n    uint16_t uVar3;\n    int16_t iVar4;\n    int16_t iVar5;\n    int16_t iVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint *puVar10;\n    int32_t unaff_EBP;\n    int32_t *piVar11;\n    int32_t *piVar12;\n    int32_t iVar13;\n    uint *puVar14;\n    uint *in_FS_OFFSET;\n    uint var_8ch;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_56h;\n    uint var_50h;\n    uint lpRect;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    puVar14 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x18) = puVar14 + 0x12;\n    if (*(unaff_EBP + 0x10) != 0) {\n        uVar1 = *(puVar14 + 0x12);\n        *(unaff_EBP + -100) = puVar14[2];\n        *(unaff_EBP + -0x60) = puVar14[1];\n        *(unaff_EBP + -0x5c) = *(puVar14 + 3);\n        *(unaff_EBP + -0x5a) = *(puVar14 + 0xe);\n        uVar2 = *(puVar14 + 4);\n        *(unaff_EBP + -0x56) = uVar1;\n        uVar1 = *(puVar14 + 5);\n        puVar10 = puVar14 + 6;\n        *(unaff_EBP + -0x58) = uVar2;\n        *(unaff_EBP + -0x54) = uVar1;\n        puVar14 = unaff_EBP + -100;\n        *(unaff_EBP + -0x18) = puVar10;\n    }\n    iVar4 = *(puVar14 + 10);\n    iVar5 = *(puVar14 + 3);\n    iVar6 = *(puVar14 + 2);\n    *(unaff_EBP + -0x34) = *(puVar14 + 0xe) + iVar4;\n    *(unaff_EBP + -0x40) = iVar6;\n    iVar13 = *(*(unaff_EBP + 8) + 0x1c);\n    *(unaff_EBP + -0x3c) = iVar4;\n    *(unaff_EBP + -0x38) = iVar5 + iVar6;\n    (*_sym.imp.USER32.dll_MapDialogRect)(iVar13, unaff_EBP + -0x40);\n    piVar11 = *(unaff_EBP + 0x1c);\n    *(unaff_EBP + 0x10) = 0;\n    if (3 < *(unaff_EBP + 0x20)) {\n        iVar8 = *piVar11;\n        *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) + -4;\n        piVar11 = piVar11 + 1;\n        if (iVar8 != 0) {\n            uVar7 = (*_sym.imp.OLEAUT32.dll_SysReAllocStringLen)(piVar11, iVar8);\n            *(unaff_EBP + 0x10) = uVar7;\n            piVar11 = piVar11 + iVar8 * 2;\n            *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) + iVar8 * -2;\n        }\n    }\n    uVar7 = *0x45c084;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x10) = uVar7;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x1c) = 0;\n    *(unaff_EBP + -0x20) = 0;\n    *(unaff_EBP + -0x24) = 0;\n    if ((*(unaff_EBP + 0x18) == 0x37a) || (*(unaff_EBP + 0x18) == 0x37b)) {\n        iVar8 = *piVar11;\n        piVar11 = piVar11 + 3;\n        *(unaff_EBP + -0x2c) = iVar8;\n        *(unaff_EBP + 0x1c) = iVar8 + -0xc;\n        piVar12 = piVar11;\n        if (iVar8 + -0xc != 0) {\n            do {\n                iVar8 = *piVar12;\n                uVar3 = *(piVar12 + 1);\n                *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + -6;\n                *(unaff_EBP + -0x28) = iVar8;\n                piVar11 = piVar12 + 6;\n                if (iVar8 == -0x7ffeffff) {\n                    *(unaff_EBP + -0x20) = *piVar11;\n                    iVar13 = piVar12 + 0x16;\n                    *(unaff_EBP + -0x24) = *(piVar12 + 10);\n                    fcn.0042a4e1();\n                    *(unaff_EBP + -0x1c) = uVar3;\n                    iVar8 = *(*(unaff_EBP + -0x10) + -8);\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + (-0x11 - iVar8);\n                    piVar11 = piVar12 + iVar8 + 0x17;\n                }\n                else {\n                    iVar8 = fcn.004253fd(0x1c);\n                    *(unaff_EBP + -0x30) = iVar8;\n                    *(unaff_EBP + -4) = 1;\n                    if (iVar8 == 0) {\n                        uVar7 = 0;\n                    }\n                    else {\n                        iVar13 = *(unaff_EBP + -0x14);\n                        uVar7 = fcn.0040e3cb();\n                    }\n                    *(unaff_EBP + -4) = 0;\n                    *(unaff_EBP + -0x14) = uVar7;\n                }\n                piVar12 = piVar11;\n            } while (*(unaff_EBP + 0x1c) != 0);\n            iVar8 = *(unaff_EBP + -0x2c);\n        }\n        *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) - iVar8;\n        *(unaff_EBP + 0x18) = *(unaff_EBP + 0x18) + 0xfffc;\n    }\n    uVar7 = 0;\n    if (**(unaff_EBP + -0x18) == 0x7b) {\n        uVar9 = (*_sym.imp.ole32.dll_CLSIDFromString)();\n    }\n    else {\n        uVar9 = (*_sym.imp.ole32.dll_CLSIDFromProgID)(*(unaff_EBP + -0x18), unaff_EBP + -0x50, iVar13);\n    }\n    *(unaff_EBP + 0x1c) = uVar9;\n    fcn.0043621e(piVar11, *(unaff_EBP + 0x20), 0);\n    iVar4 = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + 0x14) = 0;\n    if (((-1 < *(unaff_EBP + 0x1c)) && (iVar13 = fcn.004090b1(),  iVar13 != 0)) &&\n       (iVar13 = fcn.004092bf(0, unaff_EBP + -0x50, 0, *puVar14, unaff_EBP + -0x40, *(puVar14 + 4), \n                              -(iVar4 != 0x378) & unaff_EBP - 0x8cU, *(unaff_EBP + 0x18) == 0x377, *(unaff_EBP + 0x10), \n                              unaff_EBP + 0x14),  iVar13 != 0)) {\n        fcn.0040ace9(1);\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(*(unaff_EBP + 0x14) + 0x20), *(unaff_EBP + 0xc), 0, 0, 0, 0, 0x13);\n        *(*(unaff_EBP + 0x14) + 0x8c) = *(unaff_EBP + -0x14);\n        fcn.0042a491(unaff_EBP + -0x10);\n        *(*(unaff_EBP + 0x14) + 0x90) = *(unaff_EBP + -0x1c);\n        *(*(unaff_EBP + 0x14) + 0x94) = *(unaff_EBP + -0x20);\n        *(*(unaff_EBP + 0x14) + 0x98) = *(unaff_EBP + -0x24);\n    }\n    if (*(unaff_EBP + 0x10) != 0) {\n        (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(unaff_EBP + 0x10));\n    }\n    if (*(unaff_EBP + 0x14) != 0) {\n        uVar7 = *(*(unaff_EBP + 0x14) + 0x20);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0043625a();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar7;\n}\n",
        "token_count": 2417
    },
    "00429130": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00429130(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.0042618f();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00425fd2();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 196
    },
    "00408d12": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nint32_t * fcn.00408d12(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *extraout_ECX;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(extraout_ECX + 4);\n    if (extraout_ECX[3] == 0) {\n        iVar3 = *extraout_ECX;\n        *(unaff_EBP + -4) = 0;\n        iVar1 = fcn.00424ee6(extraout_ECX + 2, extraout_ECX[1], iVar3);\n        iVar3 = extraout_ECX[1];\n        piVar2 = (iVar3 + -1) * *extraout_ECX + 4 + iVar1;\n        if (-1 < iVar3 + -1) {\n            do {\n                *piVar2 = extraout_ECX[3];\n                extraout_ECX[3] = piVar2;\n                piVar2 = piVar2 - *extraout_ECX;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    piVar2 = extraout_ECX[3];\n    extraout_ECX[3] = *piVar2;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(extraout_ECX + 4);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return piVar2;\n}\n",
        "token_count": 442
    },
    "004090b1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nbool fcn.004090b1(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_4h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h_2;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (*(extraout_ECX + 0x34) == 0) {\n        iVar1 = fcn.0043d8de();\n        uVar2 = (**(**(iVar1 + 0x1038) + 8))(extraout_ECX);\n        *(extraout_ECX + 0x34) = uVar2;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    if ((*(extraout_ECX + 0x34) != 0) && (iVar1 = extraout_ECX,  extraout_ECX != 0)) {\n        while ((*(iVar1 + 0x24) & 0x100) == 0) {\n            *(iVar1 + 0x24) = *(iVar1 + 0x24) | 0x100;\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar1 + 0x1c));\n            iVar1 = fcn.00425960(uVar2);\n            iVar3 = iVar1;\n            if (iVar1 != 0) {\n                iVar3 = *(iVar1 + 0x1c);\n            }\n            uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            if (((uVar4 & 0x40000000) == 0) || (iVar1 == 0)) break;\n        }\n    }\n    iVar1 = *(extraout_ECX + 0x34);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1 != 0;\n}\n",
        "token_count": 540
    },
    "004091e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.004091e1(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    *extraout_ECX = vtable.COleControlContainer.0;\n    pcVar1 = extraout_ECX[0xb];\n    *(unaff_EBP + -4) = 1;\n    iVar2 = -(pcVar1 != NULL);\n    *(unaff_EBP + -0x10) = iVar2;\n    while (iVar2 != 0) {\n        fcn.00425110();\n        if (*(*(unaff_EBP + -0x14) + 0x88) == 0) {\n            fcn.004250ce();\n            if (*(unaff_EBP + -0x14) != NULL) {\n                (**(**(unaff_EBP + -0x14) + 4))(1);\n            }\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n    }\n    iVar2 = -(extraout_ECX[0xb] != NULL);\n    *(unaff_EBP + -0x10) = iVar2;\n    while (iVar2 != 0) {\n        fcn.00425110();\n        if (*(unaff_EBP + -0x14) != NULL) {\n            (**(**(unaff_EBP + -0x14) + 4))(1);\n        }\n        iVar2 = *(unaff_EBP + -0x10);\n    }\n    fcn.00424f5f();\n    fcn.0043f13b(extraout_ECX + 0x11);\n    *(unaff_EBP + -4) = 0;\n    fcn.00424f8a();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428a9b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 551
    },
    "004097eb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004097eb(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = -(*(in_ECX + 0x2c) != 0);\n    while (var_4h != 0) {\n        fcn.00425110(&var_4h, &var_ch, &var_8h);\n        fcn.0040ace9(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 123
    },
    "0040a0c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_38h\n\nuint __cdecl\nfcn.0040a0c7(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_38h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar6 = *(unaff_EBP + 8);\n    extraout_ECX[8] = 0;\n    if (iVar6 != 0) {\n        extraout_ECX[9] = iVar6;\n        *(iVar6 + 0x38) = extraout_ECX;\n    }\n    iVar6 = fcn.0043d6a7();\n    if ((*(iVar6 + 0x114) == 0) && (iVar6 = fcn.0043ee8d(),  iVar6 == 0)) {\n        uVar7 = 0x80004005;\n        goto code_r0x0040a354;\n    }\n    iVar6 = fcn.0040a5c1(*(unaff_EBP + 0xc), *(unaff_EBP + 0x24), *(unaff_EBP + 0x28), *(unaff_EBP + 0x2c));\n    *(unaff_EBP + 8) = iVar6;\n    if (-1 < iVar6) {\n        extraout_ECX[10] = *(unaff_EBP + 0x20);\n        piVar2 = *(unaff_EBP + 0x1c);\n        if (piVar2 == NULL) {\n            fcn.0042efe6(0);\n            piVar2 = extraout_ECX[0x13];\n            iVar6 = *piVar2;\n            *(unaff_EBP + -4) = 0;\n            (**(iVar6 + 0x48))(piVar2, 1, unaff_EBP + -0x14);\n            fcn.0043b15d(unaff_EBP + -0x14);\n            iVar6 = **(unaff_EBP + 0x18);\n            iVar3 = (*(unaff_EBP + 0x18))[1];\n            *(unaff_EBP + -0x24) = iVar6;\n            *(unaff_EBP + -0x1c) = iVar6 + *(unaff_EBP + -0x14);\n            *(unaff_EBP + -0x20) = iVar3;\n            *(unaff_EBP + -0x18) = *(unaff_EBP + -0x10) + iVar3;\n            *(unaff_EBP + -4) = 0xffffffff;\n            extraout_ECX[0xb] = *(unaff_EBP + -0x24);\n            extraout_ECX[0xc] = *(unaff_EBP + -0x20);\n            extraout_ECX[0xd] = *(unaff_EBP + -0x1c);\n            extraout_ECX[0xe] = *(unaff_EBP + -0x18);\n            fcn.0042f058();\n        }\n        else {\n            iVar6 = *piVar2;\n            iVar3 = **(unaff_EBP + 0x18);\n            iVar4 = (*(unaff_EBP + 0x18))[1];\n            *(unaff_EBP + -0x18) = piVar2[1] + iVar4;\n            *(unaff_EBP + -0x24) = iVar3;\n            *(unaff_EBP + -0x1c) = iVar6 + iVar3;\n            *(unaff_EBP + -0x20) = iVar4;\n            extraout_ECX[0xb] = *(unaff_EBP + -0x24);\n            extraout_ECX[0xc] = *(unaff_EBP + -0x20);\n            extraout_ECX[0xd] = *(unaff_EBP + -0x1c);\n            extraout_ECX[0xe] = *(unaff_EBP + -0x18);\n        }\n        extraout_ECX[0x1a] = 0x30000;\n        if ((extraout_ECX[0x1c] & 0x1000U) != 0) {\n            extraout_ECX[0x1a] = 0x30001;\n        }\n        if ((extraout_ECX[0x1c] & 0x400U) != 0) {\n            *(unaff_EBP + 0x17) = *(unaff_EBP + 0x17) & 0xef;\n        }\n        iVar6 = *(unaff_EBP + 8);\n        extraout_ECX[0x1b] = extraout_ECX[0x1a] & *(unaff_EBP + 0x14);\n        if (iVar6 != 1) {\n            iVar6 = fcn.0040a970(extraout_ECX + 0xf, extraout_ECX + 0x33);\n            extraout_ECX[0x18] = iVar6;\n            iVar6 = fcn.0040a970(0x44d868, extraout_ECX + 0x32);\n            extraout_ECX[0x19] = iVar6;\n        }\n        iVar6 = fcn.0040a970(0x44d818, extraout_ECX + 0x35);\n        extraout_ECX[0x21] = iVar6;\n        fcn.0040a01f();\n        ppiVar1 = extraout_ECX + 0x14;\n        iVar6 = (***extraout_ECX[0x13])(extraout_ECX[0x13], 0x44d878, ppiVar1);\n        *(unaff_EBP + 8) = iVar6;\n        pcVar5 = _sym.imp.USER32.dll_OffsetRect;\n        if (iVar6 < 0) {\ncode_r0x0040a2c8:\n            piVar2 = *ppiVar1;\n            if (piVar2 != NULL) {\n                (**(*piVar2 + 8))(piVar2);\n                *ppiVar1 = NULL;\n            }\n            fcn.0040a9d8(extraout_ECX + 0xf, extraout_ECX[0x18]);\n            fcn.0040a9d8(0x44d868, extraout_ECX[0x19]);\n            fcn.0040a9d8(0x44d818, extraout_ECX[0x21]);\n            extraout_ECX[0x18] = 0;\n            extraout_ECX[0x19] = 0;\n            extraout_ECX[0x21] = 0;\n            (**(*extraout_ECX[0x13] + 8))(extraout_ECX[0x13]);\n            iVar6 = *(unaff_EBP + 8);\n            extraout_ECX[0x13] = 0;\n            if (iVar6 < 0) goto code_r0x0040a350;\n        }\n        else {\n            if ((*(unaff_EBP + 0x17) & 0x10) == 0) {\n                (*_sym.imp.USER32.dll_OffsetRect)(extraout_ECX + 0xb, 0xffff8300, 0xffff8300);\n                iVar6 = (**(*extraout_ECX + 0x54))(0xfffffffb, 0);\n                *(unaff_EBP + 8) = iVar6;\n                if (-1 < iVar6) {\n                    iVar6 = (**(*extraout_ECX + 0x54))(0xfffffffd, 0);\n                    *(unaff_EBP + 8) = iVar6;\n                    if (-1 < iVar6) {\n                        (*pcVar5)(extraout_ECX + 0xb, 32000, 32000);\n                        uVar7 = (**(**ppiVar1 + 0x1c))(*ppiVar1, extraout_ECX + 0xb, extraout_ECX + 0xb);\n                        *(unaff_EBP + 8) = uVar7;\n                        goto code_r0x0040a2b8;\n                    }\n                }\n                goto code_r0x0040a2c8;\n            }\n            uVar7 = (**(*extraout_ECX + 0x54))(0xfffffffb, 0);\n            *(unaff_EBP + 8) = uVar7;\ncode_r0x0040a2b8:\n            if (*(unaff_EBP + 8) < 0) goto code_r0x0040a2c8;\n            fcn.0040abb0();\n        }\n        fcn.0040ad1f();\n        if (*(unaff_EBP + 0x10) != 0) {\n            (**(*extraout_ECX + 0x80))(*(unaff_EBP + 0x10));\n        }\n        (**(*extraout_ECX + 0x78))(0, *(unaff_EBP + 0x14) & 0x8800000 | extraout_ECX[0x1b], 0);\n    }\ncode_r0x0040a350:\n    uVar7 = *(unaff_EBP + 8);\ncode_r0x0040a354:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar7;\n}\n",
        "token_count": 2208
    },
    "0040a9d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040a9d8(uint arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    if ((arg_ch != 0) && (puVar1 = in_ECX[0x13],  puVar1 != NULL)) {\n        var_8h = in_ECX;\n        iVar2 = (***puVar1)(puVar1, 0x44d908, &var_8h);\n        if (-1 < iVar2) {\n            var_4h = NULL;\n            iVar2 = (**(*var_8h + 0x10))(var_8h, arg_8h, &var_4h);\n            if (-1 < iVar2) {\n                (**(*var_4h + 0x18))(var_4h, arg_ch);\n                (**(*var_4h + 8))(var_4h);\n            }\n            (**(*var_8h + 8))(var_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 259
    },
    "0040aa36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0040aa36(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    int32_t *var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    *arg_8h = *0x44d938;\n    arg_8h[1] = *0x44d93c;\n    arg_8h[2] = *0x44d940;\n    arg_8h[3] = *0x44d944;\n    var_ch = NULL;\n    iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x44d928, &var_ch);\n    if (-1 < iVar1) {\n        (**(*var_ch + 0x10))(var_ch, 1, arg_8h);\n        (**(*var_ch + 8))(var_ch);\n    }\n    var_14h = NULL;\n    iVar1 = fcn.00411060(arg_8h, 0x44d938, 0x10);\n    if ((iVar1 == 0) && (iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x44d918, &var_14h),  -1 < iVar1)) {\n        var_4h = NULL;\n        iVar1 = (**(*var_14h + 0xc))(var_14h, &var_4h);\n        if (-1 < iVar1) {\n            iVar1 = (**(*var_4h + 0xc))(var_4h, &var_10h);\n            if (-1 < iVar1) {\n                uVar2 = 0;\n                if (*(var_10h + 0x30) != 0) {\n                    do {\n                        iVar1 = (**(*var_4h + 0x24))(var_4h, uVar2, &var_1ch);\n                        if ((-1 < iVar1) && ((var_1ch & 7) == 3)) {\n                            var_8h = NULL;\n                            iVar1 = (**(*var_4h + 0x20))(var_4h, uVar2, &var_20h);\n                            if ((-1 < iVar1) && (iVar1 = (**(*var_4h + 0x38))(var_4h, var_20h, &var_8h),  -1 < iVar1)) {\n                                iVar1 = (**(*var_8h + 0xc))(var_8h, &var_18h);\n                                if (-1 < iVar1) {\n                                    *arg_8h = *var_18h;\n                                    arg_8h[1] = var_18h[1];\n                                    arg_8h[2] = var_18h[2];\n                                    arg_8h[3] = var_18h[3];\n                                    (**(*var_8h + 0x4c))(var_8h, var_18h);\n                                }\n                                (**(*var_8h + 8))(var_8h);\n                            }\n                            break;\n                        }\n                        uVar2 = uVar2 + 1;\n                    } while (uVar2 < *(var_10h + 0x30));\n                }\n                (**(*var_4h + 0x4c))(var_4h, var_10h);\n            }\n            (**(*var_4h + 8))(var_4h);\n        }\n        (**(*var_14h + 8))(var_14h);\n    }\n    iVar1 = fcn.00411060(arg_8h, 0x44d938, 0x10);\n    return iVar1 != 0;\n}\n",
        "token_count": 886
    },
    "0040ad5c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040ad5c(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = *(param_1 + 0x24);\n    *(param_1 + 0x20) = 0;\n    if (piVar1 != NULL) {\n        if (piVar1[7] != 0) {\n            piVar1 = (**(*piVar1 + 0x80))();\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(*(param_1 + 0x24) + 0x1c));\n            if ((iVar2 != 0) && (*piVar1 != 0)) {\n                fcn.004286a9();\n            }\n            fcn.004259de();\n        }\n        *(*(param_1 + 0x24) + 0x38) = 0;\n    }\n    return;\n}\n",
        "token_count": 207
    },
    "0040c03e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c03e(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (*param_1 != NULL) {\n        fcn.0040c06d();\n        piVar1 = *param_1;\n        if (piVar1 != NULL) {\n            *param_1 = NULL;\n            (**(*piVar1 + 8))(piVar1);\n        }\n        piVar1 = param_1[1];\n        if (piVar1 != NULL) {\n            param_1[1] = NULL;\n            (**(*piVar1 + 8))(piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 148
    },
    "0040c6bf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040c6bf(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    iVar2 = 0;\n    uVar3 = 0;\n    uVar1 = *(*(param_1 + 8) + 4);\n    if (uVar1 != 0) {\n        do {\n            if ((*(**(param_1 + 8) + 4 + uVar3 * 8) != '\\0') && (iVar2 = fcn.0040c6f3(uVar3),  iVar2 < 0)) {\n                return iVar2;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < uVar1);\n    }\n    return iVar2;\n}\n",
        "token_count": 185
    },
    "0040c72b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nint32_t fcn.0040c72b(void)\n\n{\n    int16_t iVar1;\n    code **ppcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int32_t *extraout_ECX;\n    uint32_t arg_28h;\n    uint *puVar7;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint32_t uVar8;\n    uint unaff_EDI;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint *noname_1;\n    uint uVar9;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    uint uStack4;\n    \n    uStack4 = 0x40c735;\n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &fcn.0040c72b::var_28h;\n    *(unaff_EBP + -0x28) = extraout_ECX;\n    *(unaff_EBP + -0x14) = 0;\n    puVar7 = *(unaff_EBP + 8);\n    uVar9 = 0x45cb38;\n    ppcVar2 = *puVar7;\n    *(unaff_EBP + -4) = 0;\n    noname_1 = puVar7;\n    var_28h = unaff_EDI;\n    var_24h = unaff_ESI;\n    iVar3 = (**ppcVar2)();\n    *(unaff_EBP + 8) = iVar3;\n    if (iVar3 < 0) {\n        piVar6 = *(unaff_EBP + -0x14);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (piVar6 != NULL) {\n            (**(*piVar6 + 8))(piVar6);\n        }\n        iVar3 = *(unaff_EBP + 8);\n        goto code_r0x0040c9cb;\n    }\n    iVar3 = extraout_ECX[4];\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0) {\n        *(unaff_EBP + -0x1c) = 0;\n        ppcVar2 = *puVar7;\n        *(unaff_EBP + -4) = 1;\n        iVar3 = (**ppcVar2)(puVar7, 0x45cb28, unaff_EBP + -0x1c);\n        if ((-1 < iVar3) &&\n           (iVar3 = (**(**(unaff_EBP + -0x1c) + 0xc))\n                              (*(unaff_EBP + -0x1c), extraout_ECX + 3, extraout_ECX + 4, extraout_ECX + 5),  -1 < iVar3)\n           ) {\n            piVar6 = *(unaff_EBP + -0x1c);\n            *(extraout_ECX + 6) = 0;\n            *(unaff_EBP + -4) = 0;\n            if (piVar6 != NULL) {\n                (**(*piVar6 + 8))(piVar6);\n            }\n            goto code_r0x0040c7f1;\n        }\n        piVar6 = *(unaff_EBP + -0x1c);\n        *(unaff_EBP + -4) = 0;\n        if (piVar6 != NULL) {\n            (**(*piVar6 + 8))(piVar6);\n        }\ncode_r0x0040c9b8:\n        piVar6 = *(unaff_EBP + -0x14);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (piVar6 != NULL) {\n            (**(*piVar6 + 8))(piVar6);\n        }\n    }\n    else {\n        *(extraout_ECX + 6) = 1;\ncode_r0x0040c7f1:\n        iVar3 = extraout_ECX[3];\n        *(unaff_EBP + -0x18) = 0;\n        *(unaff_EBP + -4) = 2;\n        uVar4 = fcn.004253fd(iVar3 * 0x34);\n        *(unaff_EBP + -0x18) = uVar4;\n        uVar8 = 0;\n        *(unaff_EBP + -4) = 0;\n        if (*(unaff_EBP + -0x18) == 0) {\n            piVar6 = *(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        else {\n            *(unaff_EBP + -0x24) = *(unaff_EBP + -0x18);\n            *(unaff_EBP + -0x20) = 0;\n            while (uVar8 < extraout_ECX[3]) {\n                iVar3 = uVar8 * 0x30;\n                if ((*(extraout_ECX[4] + iVar3 + 0x10) < 0x401) && (*(extraout_ECX[4] + iVar3 + 0x14) != 0xd)) {\n                    puVar7 = NULL;\n                }\n                else {\n                    *(unaff_EBP + -0x2c) = 0;\n                    *(unaff_EBP + -4) = 4;\n                    puVar7 = fcn.004253fd(0x14);\n                    *(unaff_EBP + -4) = 0;\n                    if (puVar7 == NULL) goto code_r0x0040c980;\n                    *puVar7 = 0;\n                    puVar7[1] = str.0:s_f._0_4_;\n                    puVar7[2] = *0x44dd14;\n                    puVar7[3] = *0x44dd18;\n                    puVar7[4] = *0x44dd1c;\n                    iVar3 = *(unaff_EBP + -0x20) * 0x30;\n                    *(extraout_ECX[4] + 0x14 + iVar3) = 0xd;\n                    *(extraout_ECX[4] + 0x10 + iVar3) = 4;\n                }\n                iVar1 = *(extraout_ECX[4] + iVar3 + 0x14);\n                if ((iVar1 == 0x81) || (iVar1 == 0x82)) {\n                    piVar6 = extraout_ECX[4] + iVar3 + 0x10;\n                    *piVar6 = *piVar6 + 1;\n                }\n                iVar5 = extraout_ECX[4] + iVar3;\n                arg_28h = (*(iVar5 + 0x10) & 3) + *(iVar5 + 0x10) + *(unaff_EBP + 8);\n                fcn.0040ca82(*(unaff_EBP + -0x24), *(iVar5 + 8), arg_28h & 0xffff0000 | *(iVar5 + 0x14), *(iVar5 + 0x10)\n                             , arg_28h & 0xffffff00 | *(iVar5 + 0x16), arg_28h & 0xffffff00 | *(iVar5 + 0x17), 0, \n                             *(unaff_EBP + 8), arg_28h, arg_28h + 4, puVar7);\n                iVar5 = extraout_ECX[4];\n                *(unaff_EBP + -0x24) = *(unaff_EBP + -0x24) + 0x34;\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 1;\n                *(iVar5 + 4 + iVar3) = *(unaff_EBP + 8);\n                uVar8 = *(unaff_EBP + -0x20);\n                *(unaff_EBP + 8) = arg_28h + 8;\n            }\n            if (*extraout_ECX == 0) {\n                iVar3 = fcn.0040c9dc(1, noname_1, uVar9, unaff_EBP + -0x14, var_28h, var_24h);\n                if (iVar3 < 0) {\n                    fcn.00425426(*(unaff_EBP + -0x18));\n                    goto code_r0x0040c9b8;\n                }\n                *(*extraout_ECX + 4) = 1;\n            }\n            uVar9 = *(unaff_EBP + 8);\n            extraout_ECX[2] = 0;\n            *(unaff_EBP + -4) = 6;\n            iVar3 = fcn.004253fd(uVar9);\n            extraout_ECX[2] = iVar3;\n            *(unaff_EBP + -4) = 0;\n            if (extraout_ECX[2] != 0) {\n                iVar3 = fcn.0040ca38(*(unaff_EBP + -0x18), extraout_ECX[3], *extraout_ECX, *(unaff_EBP + 8), \n                                     *(unaff_EBP + -0x14));\n                fcn.00425426(*(unaff_EBP + -0x18));\n                goto code_r0x0040c9b8;\n            }\n            fcn.00425426(*(unaff_EBP + -0x18));\ncode_r0x0040c980:\n            piVar6 = *(unaff_EBP + -0x14);\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        if (piVar6 != NULL) {\n            (**(*piVar6 + 8))(piVar6);\n        }\n        iVar3 = -0x7ff8fff2;\n    }\ncode_r0x0040c9cb:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar3;\n}\n",
        "token_count": 2323
    },
    "0040cca9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.0040cca9(int32_t param_1, uint32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint32_t in_EAX;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    \n    if (*(param_1 + 0x18) == '\\0') {\n        iVar1 = *(*(param_1 + 0x10) + 8);\n        in_EAX = *param_2;\n        if (in_EAX <= *(param_1 + 0xc) + -1 + iVar1) {\n            in_EAX = in_EAX - iVar1;\n            *param_2 = in_EAX;\ncode_r0x0040ccf5:\n            return CONCAT31(in_EAX >> 8, 1);\n        }\n    }\n    else {\n        uVar3 = 0;\n        if (*(param_1 + 0xc) != 0) {\n            puVar2 = *(param_1 + 0x10) + 8;\n            in_EAX = *param_2;\n            do {\n                if (*puVar2 == in_EAX) {\n                    *param_2 = uVar3;\n                    goto code_r0x0040ccf5;\n                }\n                uVar3 = uVar3 + 1;\n                puVar2 = puVar2 + 0xc;\n            } while (uVar3 < *(param_1 + 0xc));\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 336
    },
    "0040cf4b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_140h\n\nuint __cdecl fcn.0040cf4b(uint arg_8h, uint arg_ch)\n\n{\n    ulong uVar1;\n    uchar uVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    int32_t iVar5;\n    double dVar6;\n    code *pcVar7;\n    char cVar8;\n    ulong *puVar9;\n    uint *puVar10;\n    uint uVar11;\n    uint16_t *puVar12;\n    uchar *puVar13;\n    int32_t iVar14;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_140h;\n    uint var_130h;\n    uint var_120h;\n    uint var_110h;\n    uint var_100h;\n    uint var_f0h;\n    uint var_e0h;\n    uint var_d4h;\n    uint var_c4h;\n    uint var_b4h;\n    uint var_ach;\n    uint var_a4h;\n    uint var_94h;\n    uint var_84h;\n    uint var_74h;\n    uint var_64h;\n    uint var_54h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint pvargDest;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x3c) = 0;\n    fcn.0040f641(unaff_EBP + -0x1c);\n    uVar11 = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -4) = 0;\n    fcn.0040d6c7(uVar11, unaff_EBP + -0x3c);\n    if (*(unaff_EBP + -0x3c) != 3) {\n        iVar14 = *(extraout_ECX + 0x54);\n        *(unaff_EBP + 0xc) = uVar11;\n        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n        pcVar7 = _sym.imp.OLEAUT32.dll_VariantCopy;\n        if (cVar8 != '\\0') {\n            uVar3 = *(*(iVar14 + 0x10) + 0x14 + *(unaff_EBP + 0xc) * 0x30);\n            if (uVar3 < 0x82) {\n                if (uVar3 == 0x81) {\n                    iVar14 = *(extraout_ECX + 0x54);\n                    *(unaff_EBP + 0xc) = uVar11;\n                    cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                    if (cVar8 == '\\0') {\n                        iVar14 = 0;\n                    }\n                    else {\n                        iVar14 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                    }\n                    puVar10 = fcn.0042a3c6(iVar14);\n                    uVar11 = *puVar10;\n                    *(unaff_EBP + -4) = 2;\n                    uVar11 = fcn.0040f509(uVar11, 8);\n                    *(unaff_EBP + -4) = 3;\n                    fcn.0040f627(uVar11);\n                    (*pcVar7)(unaff_EBP + -0x120);\n                    *(unaff_EBP + -4) = 0;\n                    goto code_r0x0040d69c;\n                }\n                if (uVar3 < 9) {\n                    if (uVar3 == 8) goto code_r0x0040d636;\n                    if (uVar3 == 2) {\ncode_r0x0040d21b:\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar12 = NULL;\n                        }\n                        else {\n                            puVar12 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar11 = fcn.0040f584(puVar12 & 0xffff0000 | *puVar12, 2);\n                        *(unaff_EBP + -4) = 7;\n                        fcn.0040f627(uVar11);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0x110;\n                    }\n                    else if (uVar3 == 3) {\ncode_r0x0040d1c4:\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar10 = NULL;\n                        }\n                        else {\n                            puVar10 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar11 = fcn.0040f5ba(*puVar10, 3);\n                        *(unaff_EBP + -4) = 8;\n                        fcn.0040f627(uVar11);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0xf0;\n                    }\n                    else if (uVar3 == 4) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar10 = NULL;\n                        }\n                        else {\n                            puVar10 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar11 = *puVar10;\n                        *(unaff_EBP + -100) = 4;\n                        *(unaff_EBP + -0x5c) = uVar11;\n                        *(unaff_EBP + -4) = 9;\n                        fcn.0040f627(unaff_EBP + -100);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -100;\n                    }\n                    else if (uVar3 == 5) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar9 = NULL;\n                        }\n                        else {\n                            puVar9 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar1 = *puVar9;\n                        *(unaff_EBP + -0x94) = 5;\n                        *(unaff_EBP + -0x8c) = uVar1;\n                        *(unaff_EBP + -4) = 10;\n                        fcn.0040f627(unaff_EBP + -0x94);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0x94;\n                    }\n                    else if (uVar3 == 6) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar10 = NULL;\n                        }\n                        else {\n                            puVar10 = *(*(iVar14 + 0x10) + 4 + *(unaff_EBP + 0xc) * 0x30) + *(iVar14 + 8);\n                        }\n                        uVar11 = *puVar10;\n                        uVar4 = puVar10[1];\n                        *(unaff_EBP + -0x54) = 6;\n                        *(unaff_EBP + -0x4c) = uVar11;\n                        *(unaff_EBP + -0x48) = uVar4;\n                        *(unaff_EBP + -4) = 0xd;\n                        fcn.0040f627(unaff_EBP + -0x54);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0x54;\n                    }\n                    else {\n                        if (uVar3 != 7) goto code_r0x0040d6a1;\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar9 = NULL;\n                        }\n                        else {\n                            puVar9 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar1 = *puVar9;\n                        *(unaff_EBP + -0xc4) = 7;\n                        *(unaff_EBP + -0xbc) = uVar1;\n                        *(unaff_EBP + -4) = 0xc;\n                        fcn.0040f627(unaff_EBP + -0xc4);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0xc4;\n                    }\ncode_r0x0040d4a3:\n                    (*pcVar7)(iVar14);\n                }\n                else {\n                    if (uVar3 == 0xb) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            puVar12 = NULL;\n                        }\n                        else {\n                            puVar12 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar11 = fcn.0040f584(puVar12 & 0xffff0000 | *puVar12, 0xb);\n                        *(unaff_EBP + -4) = 0xb;\n                        fcn.0040f627(uVar11);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0x100;\n                        goto code_r0x0040d4a3;\n                    }\n                    if (uVar3 == 0xc) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 == '\\0') {\n                            iVar14 = 0;\n                        }\n                        else {\n                            iVar14 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                        }\n                        uVar11 = fcn.0040f4e9(iVar14);\n                        *(unaff_EBP + -4) = 1;\n                        fcn.0040f627(uVar11);\n                        *(unaff_EBP + -4) = 0;\n                        iVar14 = unaff_EBP + -0x130;\n                        goto code_r0x0040d4a3;\n                    }\n                    if (0xf < uVar3) {\n                        if (uVar3 < 0x12) {\n                            iVar14 = *(extraout_ECX + 0x54);\n                            *(unaff_EBP + 0xc) = uVar11;\n                            cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                            if (cVar8 == '\\0') {\n                                puVar13 = NULL;\n                            }\n                            else {\n                                puVar13 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                            }\n                            uVar2 = *puVar13;\n                            *(unaff_EBP + -0xb4) = 0x11;\n                            *(unaff_EBP + -0xac) = uVar2;\n                            *(unaff_EBP + -4) = 6;\n                            fcn.0040f627(unaff_EBP + -0xb4);\n                            *(unaff_EBP + -4) = 0;\n                            iVar14 = unaff_EBP + -0xb4;\n                            goto code_r0x0040d4a3;\n                        }\n                        if (uVar3 == 0x12) goto code_r0x0040d21b;\n                        if (uVar3 == 0x13) goto code_r0x0040d1c4;\n                    }\n                }\n            }\n            else {\n                if (uVar3 != 0x82) {\n                    if (uVar3 == 0x83) {\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 != '\\0') {\n                            puVar10 = fcn.0040d70b(*(unaff_EBP + 0xc));\n                            *(unaff_EBP + -0x38) = *puVar10;\n                            *(unaff_EBP + -0x34) = puVar10[1];\n                            *(unaff_EBP + -0x30) = puVar10[2];\n                            *(unaff_EBP + -0x2c) = puVar10[3];\n                            *(unaff_EBP + -0x28) = *(puVar10 + 4);\n                            *(unaff_EBP + -0x26) = *(puVar10 + 0x12);\n                            dVar6 = *(unaff_EBP + -0x35);\n                            cVar8 = *(unaff_EBP + -0x37);\n                            while (cVar8 != '\\0') {\n                                dVar6 = dVar6 * *0x448210;\n                                cVar8 = cVar8 + -1;\n                            }\n                            if (*(unaff_EBP + -0x36) == '\\0') {\n                                dVar6 = -dVar6;\n                            }\n                            *(unaff_EBP + -0x7c) = dVar6;\n                            *(unaff_EBP + -0x84) = 5;\n                            *(unaff_EBP + -4) = 0xe;\n                            fcn.0040f627(unaff_EBP + -0x84);\n                            *(unaff_EBP + -4) = 0;\n                            iVar14 = unaff_EBP + -0x84;\n                            goto code_r0x0040d4a3;\n                        }\n                    }\n                    else if (uVar3 == 0x85) {\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 != '\\0') {\n                            puVar10 = fcn.0040d70b(*(unaff_EBP + 0xc));\n                            *(unaff_EBP + -0x24) = *puVar10;\n                            *(unaff_EBP + -0x34) = 0;\n                            *(unaff_EBP + -0x20) = *(puVar10 + 1);\n                            *(unaff_EBP + -0x2c) = 0;\n                            fcn.0040f791(*(unaff_EBP + -0x24), *(unaff_EBP + -0x22), *(unaff_EBP + -0x20), 0, 0, 0);\n                            *(unaff_EBP + -0x74) = 7;\n                            *(unaff_EBP + -0x6c) = *(unaff_EBP + -0x34);\n                            *(unaff_EBP + -4) = 0xf;\n                            fcn.0040f627(unaff_EBP + -0x74);\n                            *(unaff_EBP + -4) = 0;\n                            iVar14 = unaff_EBP + -0x74;\n                            goto code_r0x0040d4a3;\n                        }\n                    }\n                    else if (uVar3 == 0x86) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 != '\\0') {\n                            iVar5 = *(iVar14 + 0x10);\n                            *(unaff_EBP + -0x2c) = 0;\n                            puVar10 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + iVar5) + *(iVar14 + 8);\n                            *(unaff_EBP + -0x34) = 0;\n                            *(unaff_EBP + -0x24) = *puVar10;\n                            *(unaff_EBP + -0x20) = *(puVar10 + 1);\n                            fcn.0040f791(0x76b, 0xc, 0x1e, *(unaff_EBP + -0x24), *(unaff_EBP + -0x22), \n                                         *(unaff_EBP + -0x20));\n                            *(unaff_EBP + -0xa4) = 7;\n                            *(unaff_EBP + -0x9c) = *(unaff_EBP + -0x34);\n                            *(unaff_EBP + -4) = 0x10;\n                            fcn.0040f627(unaff_EBP + -0xa4);\n                            *(unaff_EBP + -4) = 0;\n                            iVar14 = unaff_EBP + -0xa4;\n                            goto code_r0x0040d4a3;\n                        }\n                    }\n                    else if (uVar3 == 0x87) {\n                        iVar14 = *(extraout_ECX + 0x54);\n                        *(unaff_EBP + 0xc) = uVar11;\n                        cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                        if (cVar8 != '\\0') {\n                            puVar10 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                            *(unaff_EBP + -0x38) = *puVar10;\n                            *(unaff_EBP + -0x34) = puVar10[1];\n                            *(unaff_EBP + -0x30) = puVar10[2];\n                            *(unaff_EBP + -0x2c) = puVar10[3];\n                            fcn.0040f791(*(unaff_EBP + -0x38), *(unaff_EBP + -0x36), *(unaff_EBP + -0x34), \n                                         *(unaff_EBP + -0x32), *(unaff_EBP + -0x30), *(unaff_EBP + -0x2e));\n                            *(unaff_EBP + -0xd4) = 7;\n                            *(unaff_EBP + -0xcc) = *(unaff_EBP + -0xe0);\n                            *(unaff_EBP + -4) = 0x11;\n                            fcn.0040f627(unaff_EBP + -0xd4);\n                            *(unaff_EBP + -4) = 0;\n                            iVar14 = unaff_EBP + -0xd4;\n                            goto code_r0x0040d4a3;\n                        }\n                    }\n                    goto code_r0x0040d6a1;\n                }\ncode_r0x0040d636:\n                iVar14 = *(extraout_ECX + 0x54);\n                *(unaff_EBP + 0xc) = uVar11;\n                cVar8 = fcn.0040cca9(unaff_EBP + 0xc);\n                if (cVar8 == '\\0') {\n                    iVar14 = 0;\n                }\n                else {\n                    iVar14 = *(*(unaff_EBP + 0xc) * 0x30 + 4 + *(iVar14 + 0x10)) + *(iVar14 + 8);\n                }\n                puVar10 = fcn.0042a418(iVar14);\n                uVar11 = *puVar10;\n                *(unaff_EBP + -4) = 4;\n                uVar11 = fcn.0040f509(uVar11, 8);\n                *(unaff_EBP + -4) = 5;\n                fcn.0040f627(uVar11);\n                (*pcVar7)(unaff_EBP + -0x140);\n                *(unaff_EBP + -4) = 0;\ncode_r0x0040d69c:\n                fcn.0042a358();\n            }\ncode_r0x0040d6a1:\n            fcn.0040f4e9(unaff_EBP + -0x1c);\n            (*pcVar7)(unaff_EBP + -0x1c);\n            goto code_r0x0040d6b3;\n        }\n    }\n    fcn.0040f4e9(unaff_EBP + -0x1c);\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x1c);\ncode_r0x0040d6b3:\n    uVar11 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar11;\n}\n",
        "token_count": 5086
    },
    "0040e333": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0040e333(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint *in_FS_OFFSET;\n    uint *noname_1;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = 0;\n    noname_1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (***noname_1)();\n    if (iVar2 < 0) {\ncode_r0x0040e375:\n        piVar1 = *(unaff_EBP + -0x10);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n    }\n    else {\n        if (*extraout_ECX == 0) {\n            iVar2 = fcn.0040c9dc(1, noname_1, 0x45cb38, unaff_EBP + -0x10, unaff_ESI, unaff_EBX);\n            if (iVar2 < 0) goto code_r0x0040e375;\n            *(*extraout_ECX + 4) = 1;\n        }\n        iVar2 = fcn.0040ca38(extraout_ECX[3], extraout_ECX[4], *extraout_ECX, extraout_ECX[6], *(unaff_EBP + -0x10));\n        *(unaff_EBP + -4) = 0xffffffff;\n        piVar1 = *(unaff_EBP + -0x10);\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 521
    },
    "0040e412": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040e412(int32_t **param_1)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t **var_4h;\n    \n    if ((param_1[2] != 0x80010001) && (*param_1 != NULL)) {\n        puVar1 = (*param_1)[0x13];\n        var_4h = param_1;\n        iVar2 = (***puVar1)(puVar1, 0x44dd20, &var_4h);\n        if (iVar2 < 0) {\n            iVar2 = fcn.0040e495();\n            if (iVar2 != 0) {\n                uVar3 = 0xd;\n                if (param_1[3][0x22] != 0) {\n                    uVar3 = 0x800d;\n                }\n                (**(**param_1 + 0x68))(*param_1, param_1[2], uVar3, iVar2);\n            }\n        }\n        else {\n            (*(*var_4h)[3])(var_4h, param_1[2], param_1[3] != NULL, param_1 + 4);\n            (*(*var_4h)[2])(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 297
    },
    "0040eff2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040eff2(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    if (arg_10h == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = *(arg_10h + 0x1c);\n    }\n    iVar2 = (*_sym.imp.USER32.dll_IsChild)(*(arg_8h + 0x1c), uVar1);\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_10h != 0) {\n        uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_10h + 0x1c), 0xffffffec);\n        if ((uVar3 & 0x10000) != 0) {\n            return;\n        }\n        var_4h = fcn.0040ef42(arg_10h);\n    }\n    if (arg_ch == arg_10h) {\n        if ((var_4h & 0x20) == 0) {\n            return;\n        }\n        if (arg_ch != 0) {\n            uVar1 = fcn.0040efc5(arg_8h);\n            iVar2 = fcn.0040ee9e(arg_8h, uVar1);\n            if (((iVar2 != 0) && (iVar2 != arg_10h)) && (uVar3 = fcn.0040ef42(iVar2),  (uVar3 & 0x10) != 0))\n            goto code_r0x0040f098;\n        }\n    }\n    else {\n        if (((arg_ch != 0) && (iVar2 = fcn.0040ef42(arg_ch),  iVar2 != 0)) || ((arg_10h != 0 && (var_4h != 0)))) {\ncode_r0x0040f098:\n            fcn.0040ef63(arg_8h);\n        }\n        if ((var_4h & 0x30) == 0) {\n            iVar2 = arg_8h;\n            uVar1 = fcn.0040efc5(arg_8h);\n            arg_10h = fcn.0040ee9e(arg_8h, uVar1);\n            uVar3 = fcn.0040ef42(arg_10h);\n            if ((uVar3 & 0x20) == 0) {\n                return;\n            }\n            iVar4 = fcn.0042896a();\n            if (iVar4 == 0) {\n                return;\n            }\n            goto code_r0x0040f0d1;\n        }\n    }\n    iVar2 = 1;\ncode_r0x0040f0d1:\n    fcn.0040eef5(arg_10h, iVar2);\n    return;\n}\n",
        "token_count": 677
    },
    "0040f584": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040f584(ushort *param_1, int16_t param_2, int16_t param_3)\n\n{\n    if (param_3 == 0xb) {\n        *param_1 = 0xb;\n        if (param_2 == 0) {\n            param_1[4] = 0;\n        }\n        else {\n            param_1[4] = 0xffff;\n        }\n    }\n    else {\n        *param_1 = 2;\n        param_1[4] = param_2;\n    }\n    return;\n}\n",
        "token_count": 129
    },
    "0040f5ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040f5ba(int32_t arg_8h, uint arg_ch)\n\n{\n    ushort *in_ECX;\n    \n    if (arg_ch == 10) {\n        *in_ECX = 10;\n    }\n    else {\n        if (arg_ch == 0xb) {\n            *in_ECX = 0xb;\n            if (arg_8h == 0) {\n                in_ECX[4] = 0;\n                return;\n            }\n            in_ECX[4] = 0xffff;\n            return;\n        }\n        *in_ECX = 3;\n    }\n    *(in_ECX + 4) = arg_8h;\n    return;\n}\n",
        "token_count": 153
    },
    "0040f654": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.0040f654(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, double *arg_20h)\n\n{\n    bool bVar1;\n    double dVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint var_4h;\n    \n    if (9999 < arg_8h) {\n        return 0;\n    }\n    iVar4 = 1;\n    if (arg_ch == 0) {\n        return 0;\n    }\n    if (0xc < arg_ch) {\n        return 0;\n    }\n    if (((arg_8h & 3) == 0) && ((arg_8h % 100 != 0 || (arg_8h % 400 == 0)))) {\n        bVar1 = true;\n        if ((arg_10h == 0x1d) && (arg_ch == 2)) goto code_r0x0040f6c9;\n    }\n    else {\n        bVar1 = false;\n    }\n    iVar4 = 0;\n    if (arg_10h == 0) {\n        return 0;\n    }\ncode_r0x0040f6c9:\n    iVar3 = *(arg_ch * 4 + 0x45cc28);\n    if ((((arg_10h <= (iVar4 - iVar3) + *(arg_ch * 4 + 0x45cc2c)) && (arg_14h < 0x18)) && (arg_18h < 0x3c)) &&\n       (arg_1ch < 0x3c)) {\n        uVar5 = arg_8h;\n        iVar3 = (((arg_8h >> 2) + uVar5 / 400 + uVar5 * 0x16d) - uVar5 / 100) + arg_10h + iVar3;\n        if ((arg_ch < 3) && (bVar1)) {\n            iVar3 = iVar3 + -1;\n        }\n        dVar2 = ((arg_14h * 0x3c + arg_18h) * 0x3c + arg_1ch) * *0x44c818;\n        if (iVar3 + -0xa96c7 < 0) {\n            dVar2 = -dVar2;\n        }\n        *arg_20h = iVar3 + -0xa96c7 + dVar2;\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 568
    },
    "0040fb46": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0040fb46(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    int32_t iStack16;\n    \n    iStack16 = param_1;\n    uStack24 = 0x40fb24;\n    uStack28 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack28;\n    while( true ) {\n        iVar1 = *(param_1 + 8);\n        iVar2 = *(param_1 + 0xc);\n        if ((iVar2 == -1) || (iVar2 == param_2)) break;\n        uStack20 = *(iVar1 + iVar2 * 0xc);\n        *(param_1 + 0xc) = uStack20;\n        if (*(iVar1 + 4 + iVar2 * 0xc) == 0) {\n            fcn.0040fbda(0x101);\n            (**(iVar1 + 8 + iVar2 * 0xc))();\n        }\n    }\n    *in_FS_OFFSET = uStack28;\n    return;\n}\n",
        "token_count": 265
    },
    "0041058d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong __fastcall fcn.0041058d(uint param_1, uint32_t param_2, int32_t param_3, uint param_4)\n\n{\n    uint32_t in_EAX;\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    bool in_ZF;\n    uint16_t in_FPUControlWord;\n    uint16_t in_FPUStatusWord;\n    unkbyte10 in_ST0;\n    float10 fVar4;\n    uint unaff_retaddr;\n    uint32_t arg_8h;\n    \n    arg_8h = param_2 & 0xffff0000 | in_FPUControlWord;\n    if (in_ZF) {\n        if (((in_EAX & 0xfffff) == 0) && (param_3 == 0)) {\n            uVar1 = 1;\n        }\n        else {\n            uVar1 = fcn.0041508c();\n        }\n        if (*0x46066c == 0) {\n            uVar3 = fcn.00415207(arg_8h, unaff_retaddr, param_3, param_4);\n            return CONCAT44(arg_8h, uVar3);\n        }\n    }\n    else {\n        fVar4 = fcos(in_ST0);\n        uVar1 = in_EAX & 0xffff0000 | in_FPUStatusWord;\n        if ((in_FPUStatusWord & 0x400) != 0) {\n            do {\n                fVar4 = fVar4 - (fVar4 / *0x44d1ca) * *0x44d1ca;\n                uVar1 = uVar1 & 0xffff0000 | in_FPUStatusWord;\n            } while ((in_FPUStatusWord & 0x400) != 0);\n            fcos(fVar4);\n        }\n        if (*0x46066c == 0) {\n            uVar2 = uVar1 & 0xffff0000 | in_FPUControlWord;\n            if (in_FPUControlWord != 0x27f) {\n                if (((in_FPUControlWord & 0x20) != 0) &&\n                   (uVar2 = uVar1 & 0xffff0000 | in_FPUStatusWord,  (in_FPUStatusWord & 0x20) != 0)) {\n                    uVar3 = fcn.00415207(arg_8h, unaff_retaddr, param_3, param_4);\n                    return CONCAT44(arg_8h, uVar3);\n                }\n                uVar2 = uVar2 & 0xffff0020;\n            }\n            return CONCAT44(arg_8h, uVar2);\n        }\n    }\n    return CONCAT44(arg_8h, uVar1);\n}\n",
        "token_count": 605
    },
    "00410b2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong __fastcall fcn.00410b2d(uint param_1, uint32_t param_2, int32_t param_3, uint32_t param_4)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    bool in_ZF;\n    uint16_t in_FPUControlWord;\n    uint16_t in_FPUStatusWord;\n    uint unaff_retaddr;\n    uint32_t arg_8h;\n    \n    arg_8h = param_2 & 0xffff0000 | in_FPUControlWord;\n    if (in_ZF) {\n        if (((param_4 & 0xfffff) != 0) || (param_3 != 0)) {\n            uVar1 = fcn.0041508c();\n            goto code_r0x00410bab;\n        }\n        uVar1 = param_4 & 0x80000000;\n        if (uVar1 != 0) goto code_r0x00410b9e;\n    }\n    else {\n        uVar1 = param_4;\n        if (in_FPUControlWord != 0x27f) {\n            uVar1 = fcn.00415075();\n        }\n        if (((uVar1 & 0x80000000) != 0) && ((((uVar1 & 0x7ff00000) != 0 || ((uVar1 & 0xfffff) != 0)) || (param_3 != 0)))\n           ) {\ncode_r0x00410b9e:\n            uVar1 = 1;\ncode_r0x00410bab:\n            if (*0x46066c == 0) {\n                uVar3 = fcn.00415207(arg_8h, unaff_retaddr, param_3, param_4);\n                return CONCAT44(arg_8h, uVar3);\n            }\n            goto code_r0x004150fe;\n        }\n    }\n    if (*0x46066c == 0) {\n        uVar2 = uVar1 & 0xffff0000 | arg_8h & 0xffff;\n        if ((arg_8h & 0xffff) != 0x27f) {\n            if (((arg_8h & 0x20) != 0) &&\n               (uVar2 = uVar1 & 0xffff0000 | in_FPUStatusWord,  (in_FPUStatusWord & 0x20) != 0)) {\n                uVar3 = fcn.00415207(arg_8h, unaff_retaddr, param_3, param_4);\n                return CONCAT44(arg_8h, uVar3);\n            }\n            uVar2 = uVar2 & 0xffff0020;\n        }\n        return CONCAT44(arg_8h, uVar2);\n    }\ncode_r0x004150fe:\n    return CONCAT44(arg_8h, uVar1);\n}\n",
        "token_count": 638
    },
    "00410c32": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410c32(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.00410c4a(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    }\n    return;\n}\n",
        "token_count": 126
    },
    "00410d28": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00410d28(uint arg_8h, uint arg_ch, uint noname_2, uint noname_3, uint arg_18h)\n\n{\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    \n    if (*(unaff_EBP + -0x20) == 0) {\n        fcn.00410c4a(*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), *(unaff_EBP + 0x18));\n    }\n    return;\n}\n",
        "token_count": 139
    },
    "004111bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.004111bb(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t arg_8h;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    arg_8h = param_1 * param_2;\n    uVar1 = arg_8h;\n    if (arg_8h < 0xffffffe1) {\n        if (arg_8h == 0) {\n            uVar1 = 1;\n        }\n        uVar1 = uVar1 + 0xf & 0xfffffff0;\n    }\n    do {\n        iVar2 = 0;\n        if (uVar1 < 0xffffffe1) {\n            if (arg_8h < *0x45d284 || arg_8h - *0x45d284 == 0) {\n                fcn.004142d0(9);\n                iVar2 = fcn.004146da(arg_8h);\n                fcn.00414331(9);\n                if (iVar2 != 0) {\n                    fcn.0040ffd0(iVar2, 0, arg_8h);\n                    return iVar2;\n                }\n            }\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x461ffc, 8, uVar1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n        }\n        if (*0x460704 == 0) {\n            return iVar2;\n        }\n        iVar2 = fcn.00414250(uVar1);\n    } while (iVar2 != 0);\n    return 0;\n}\n",
        "token_count": 358
    },
    "00412d20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00412d20(int32_t arg_8h, uint32_t argv)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    if (arg_8h == 0) {\n        iVar1 = fcn.0041011c(argv);\n    }\n    else {\n        if (argv == 0) {\n            fcn.00410f3f(arg_8h);\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (argv < 0xffffffe1) {\n                    fcn.004142d0(9);\n                    arg_8h_00 = fcn.00414384(arg_8h);\n                    if (arg_8h_00 == 0) {\n                        fcn.00414331(9);\n                        if (argv == 0) {\n                            argv = 1;\n                        }\n                        argv = argv + 0xf & 0xfffffff0;\n                        iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x461ffc, 0, arg_8h, argv);\n                    }\n                    else {\n                        if (*0x45d284 < argv) {\ncode_r0x00412dbf:\n                            if (argv == 0) {\n                                argv = 1;\n                            }\n                            argv = argv + 0xf & 0xfffffff0;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x461ffc, 0, argv);\n                            if (iVar1 != 0) {\n                                uVar3 = *(arg_8h + -4) - 1;\n                                if (argv <= uVar3) {\n                                    uVar3 = argv;\n                                }\n                                fcn.0040fc90(iVar1, arg_8h, uVar3);\n                                main(arg_8h_00, arg_8h);\n                            }\n                        }\n                        else {\n                            iVar2 = fcn.00414b8f(arg_8h_00, arg_8h, argv);\n                            iVar1 = arg_8h;\n                            if (iVar2 == 0) {\n                                iVar1 = fcn.004146da(argv);\n                                if (iVar1 == 0) goto code_r0x00412dbf;\n                                uVar3 = *(arg_8h + -4) - 1;\n                                if (argv <= uVar3) {\n                                    uVar3 = argv;\n                                }\n                                fcn.0040fc90(iVar1, arg_8h, uVar3);\n                                main(arg_8h_00, arg_8h);\n                            }\n                            if (iVar1 == 0) goto code_r0x00412dbf;\n                        }\n                        fcn.00414331(9);\n                    }\n                    if (iVar1 != 0) {\n                        return iVar1;\n                    }\n                }\n                if (*0x460704 == 0) {\n                    return iVar1;\n                }\n                iVar1 = fcn.00414250(argv);\n            } while (iVar1 != 0);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 692
    },
    "00413918": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.00413918(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    \n    *(unaff_ESI + -4) = *(unaff_EBP + -0x28);\n    iVar1 = fcn.00413c93();\n    *(iVar1 + 0x6c) = *(unaff_EBP + -0x1c);\n    iVar1 = fcn.00413c93();\n    *(iVar1 + 0x70) = *(unaff_EBP + -0x20);\n    if ((((*unaff_EDI == -0x1f928c9d) && (unaff_EDI[4] == 3)) && (unaff_EDI[5] == 0x19930520)) &&\n       ((*(unaff_EBP + -0x24) == 0 && (*(unaff_EBP + -0x2c) != 0)))) {\n        fcn.0040fbae();\n        fcn.00413b54();\n    }\n    return;\n}\n",
        "token_count": 283
    },
    "00417129": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00417129(int32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint var_1a4h;\n    uint var_a0h;\n    \n    iVar2 = 0;\n    piVar1 = 0x45d4f8;\n    do {\n        if (arg_8h == *piVar1) break;\n        piVar1 = piVar1 + 2;\n        iVar2 = iVar2 + 1;\n    } while (piVar1 < 0x45d588);\n    if (arg_8h == *(iVar2 * 8 + 0x45d4f8)) {\n        if ((*0x46067c == 1) || ((*0x46067c == 0 && (*0x45ce78 == 1)))) {\n            fcn.004101b0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (arg_8h != 0xfc) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.004172e0();\n            }\n            iVar2 = fcn.004101b0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.004101b0();\n                fcn.0041af70();\n            }\n            fcn.004172e0();\n            fcn.004172f0();\n            fcn.004172f0();\n            fcn.004172f0();\n            fcn.0041aee0(&var_a0h, \"Microsoft Visual C++ Runtime Library\");\n        }\n    }\n    return;\n}\n",
        "token_count": 390
    },
    "0041ebed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041ebed(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::ios_base.0;\n    pcVar1 = extraout_ECX[9];\n    *(unaff_EBP + -4) = 0;\n    if ((pcVar1 == NULL) || (pcVar1 = pcVar1 + 0x460e4c,  *pcVar1 = *pcVar1 + -1,  extraout_ECX[9][0x460e4c] < '\\x01'))\n    {\n        fcn.0041ed01();\n    }\n    fcn.0041cea9();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 252
    },
    "0041d02f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041d02f(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::basic_filebuf_char__struct_std::char_traits_char__.0;\n    cVar1 = *(extraout_ECX + 0x12);\n    *(unaff_EBP + -4) = 1;\n    if (cVar1 != '\\0') {\n        fcn.0041d697();\n    }\n    pcVar2 = extraout_ECX[0x11];\n    if (pcVar2 != NULL) {\n        fcn.00402f1c(1);\n        fcn.00425426(pcVar2);\n    }\n    fcn.0041cea9();\n    *extraout_ECX = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    fcn.0041cea9();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 333
    },
    "0041d5ed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041d5ed(int32_t param_1, uint param_2)\n\n{\n    char unaff_retaddr;\n    \n    *(param_1 + 0x2c) = 0;\n    *(param_1 + 0x28) = param_2;\n    *(param_1 + 0x30) = 0x20;\n    fcn.0041ecc9();\n    if (*(param_1 + 0x28) == 0) {\n        fcn.0041e98c(*(param_1 + 4) & 0xffffff00 | *(param_1 + 4) & 0xff | 4 | 4, 0);\n    }\n    if (unaff_retaddr != '\\0') {\n        fcn.0041ec7b();\n    }\n    return;\n}\n",
        "token_count": 184
    },
    "0041df9a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0041df9a(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::basic_filebuf_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    cVar1 = *(extraout_ECX + 0x12);\n    *(unaff_EBP + -4) = 1;\n    if (cVar1 != '\\0') {\n        fcn.0041e4c6();\n    }\n    pcVar2 = extraout_ECX[0x11];\n    if (pcVar2 != NULL) {\n        fcn.00402f1c(1);\n        fcn.00425426(pcVar2);\n    }\n    fcn.0041cea9();\n    *extraout_ECX = vtable.std::basic_streambuf_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    fcn.0041cea9();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 343
    },
    "0041e423": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0041e423(int32_t param_1, uint param_2)\n\n{\n    ushort uVar1;\n    char unaff_retaddr;\n    \n    *(param_1 + 0x2c) = 0;\n    *(param_1 + 0x28) = param_2;\n    uVar1 = fcn.0041f16a(0x20);\n    *(param_1 + 0x30) = uVar1;\n    fcn.0041ecc9();\n    if (*(param_1 + 0x28) == 0) {\n        fcn.0041e98c(*(param_1 + 4) & 0xffffff00 | *(param_1 + 4) & 0xff | 4 | 4, 0);\n    }\n    if (unaff_retaddr != '\\0') {\n        fcn.0041ec7b();\n    }\n    return;\n}\n",
        "token_count": 206
    },
    "0041f220": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041f220(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uStack76;\n    uint uStack72;\n    uint32_t uStack68;\n    uint uStack64;\n    uint32_t uStack60;\n    uint uStack56;\n    uint32_t uStack52;\n    uint uStack48;\n    uint32_t uStack44;\n    uint uStack40;\n    uint32_t uStack36;\n    uint uStack32;\n    uint32_t uStack28;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetPropA;\n    uStack28 = *0x462288;\n    uStack32 = param_1;\n    uStack36 = 0x41f23b;\n    iVar2 = (*_sym.imp.USER32.dll_GetPropA)();\n    if (iVar2 == 0) {\n        uStack36 = *0x46228e;\n        uStack40 = param_1;\n        uStack44 = 0x41f24f;\n        iVar2 = (*pcVar1)();\n        if (iVar2 == 0) {\n            uStack44 = *0x462292;\n            uStack48 = param_1;\n            uStack52 = 0x41f263;\n            iVar2 = (*pcVar1)();\n            if (iVar2 == 0) {\n                uStack52 = *0x46228c;\n                uStack56 = param_1;\n                uStack60 = 0x41f277;\n                iVar2 = (*pcVar1)();\n                if (iVar2 == 0) {\n                    uStack60 = *0x462290;\n                    uStack64 = param_1;\n                    uStack68 = 0x41f28b;\n                    iVar2 = (*pcVar1)();\n                    if (iVar2 == 0) {\n                        uStack68 = *0x46228a;\n                        uStack72 = param_1;\n                        uStack76 = 0x41f29b;\n                        iVar2 = (*pcVar1)();\n                        if (iVar2 == 0) {\n                            uStack76 = param_1;\n                            iVar2 = fcn.0041f1b0();\n                            if (iVar2 == 0) {\n                                if (*0x462d85 != '\\0') {\n                                    uStack76 = param_1;\n                                    iVar2 = (*_sym.imp.USER32.dll_IsWindowUnicode)();\n                                    if (iVar2 == 0) {\n                                        uStack76 = 0x10;\n                                        (*_sym.imp.USER32.dll_GetClassNameA)(param_1, &stack0xffffffc0);\n                                        (*_sym.imp.KERNEL32.dll_lstrcmpiA)(&stack0xffffffb4, \"edit\");\n                                    }\n                                }\n                                uStack76 = uStack40;\n                                uVar3 = (*_sym.imp.USER32.dll_SetWindowLongA)(param_1, 0xfffffffc);\n                                (*_sym.imp.USER32.dll_SetPropA)(param_1, *0x46228e, uVar3);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 681
    },
    "0041f6d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0041f6d0(uint param_1, char *param_2)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    char *pcVar4;\n    uint unaff_retaddr;\n    uchar *puVar5;\n    uchar auStack264 [4];\n    uchar auStack260 [4];\n    char acStack256 [248];\n    char **ppcStack8;\n    int32_t *piStack4;\n    \n    pcVar2 = _sym.imp.USER32.dll_CharNextA;\n    pcVar4 = acStack256;\n    cVar1 = *param_2;\n    while (cVar1 != '\\0') {\n        cVar1 = *param_2;\n        if (cVar1 == '&') {\n            param_2 = param_2 + 1;\n            if (*param_2 == '\\0') break;\ncode_r0x0041f727:\n            cVar1 = *param_2;\n            param_2 = param_2 + 1;\n            *pcVar4 = cVar1;\n            pcVar4 = pcVar4 + 1;\n        }\n        else {\n            if (*0x462d85 == '\\0') goto code_r0x0041f727;\n            if (cVar1 == *0x462d84) {\n                param_2 = param_2 + 1;\n                if (*param_2 != '\\0') goto code_r0x0041f727;\n                break;\n            }\n            if ((cVar1 != '\\x1e') && (cVar1 != '\\x1f')) goto code_r0x0041f727;\n            if (param_2[1] == '\\0') break;\n            param_2 = (*pcVar2)(param_2 + 1);\n        }\n        cVar1 = *param_2;\n    }\n    puVar5 = auStack264;\n    *pcVar4 = '\\0';\n    uVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n    (*_sym.imp.GDI32.dll_GetTextExtentPointA)(unaff_retaddr, auStack260, uVar3);\n    *ppcStack8 = acStack256;\n    *piStack4 = puVar5;\n    return;\n}\n",
        "token_count": 493
    },
    "0041f8c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0041f8c0(uint param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    uint unaff_retaddr;\n    \n    if (*0x4622a0 < 0x30a) {\n        return 0;\n    }\n    if (*0x462280 == 0) {\n        return 0;\n    }\n    uVar4 = param_2 | 1;\n    if ((param_2 & 2) != 0) {\n        uVar4 = param_2 & 0xfffffffc;\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x462260);\n    if (*0x4622dc != 0x80) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        iVar2 = 0;\n        if (0 < *0x4622dc) {\n            piVar3 = 0x4622e4;\n            do {\n                if (*piVar3 == iVar1) {\n                    piVar3 = iVar2 * 0x14 + 0x4622ec;\n                    *piVar3 = *piVar3 + 1;\n                    goto code_r0x0041f9c6;\n                }\n                piVar3 = piVar3 + 5;\n                iVar2 = iVar2 + 1;\n            } while (iVar2 < *0x4622dc);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, 0x420a20, *0x46229c, iVar1);\n        if (iVar2 != 0) {\n            *(*0x4622dc * 0x14 + 0x4622e0) = unaff_retaddr;\n            *(*0x4622dc * 0x14 + 0x4622e4) = iVar1;\n            *(*0x4622dc * 0x14 + 0x4622e8) = iVar2;\n            *(*0x4622dc * 0x14 + 0x4622ec) = 1;\n            *(*0x4622dc * 0x14 + 0x4622f0) = uVar4;\n            *0x4622d8 = *0x4622dc;\n            *0x4622dc = *0x4622dc + 1;\n            *0x4622d4 = iVar1;\ncode_r0x0041f9c6:\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x462260);\n            return 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x462260);\n    return 0;\n}\n",
        "token_count": 612
    },
    "0041fb00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0041fb00(uint param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    \n    if (*0x462280 != 0) {\n        iVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1, 0xfffffffc);\n        pcVar3 = _sym.imp.USER32.dll_SetWindowLongA;\n        pcVar2 = _sym.imp.USER32.dll_RemovePropA;\n        iVar6 = 0;\n        do {\n            if (*(iVar6 * 0x18 + 0x462ce0) == iVar4) {\n                uVar5 = fcn.0041f1d0(param_1, iVar6);\n                (*pcVar2)(param_1, *0x46228e);\n                (*pcVar3)(param_1, 0xfffffffc, uVar5);\n                iVar4 = 0;\n                iVar6 = 0x10;\n            }\n            pcVar1 = _sym.imp.USER32.dll_GetPropA;\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < 6);\n        if (iVar6 == 6) {\n            if (iVar4 == 0x4206b0) {\n                uVar5 = fcn.0041f1d0(param_1, 6);\n                (*pcVar2)(param_1, *0x46228e);\n                (*pcVar3)(param_1, 0xfffffffc, uVar5);\n            }\n            else {\n                iVar4 = (*_sym.imp.USER32.dll_GetPropA)(param_1, *0x46228e);\n                if (((iVar4 != 0) || (iVar4 = (*pcVar1)(param_1, *0x462292),  iVar4 != 0)) ||\n                   (iVar4 = (*pcVar1)(param_1, *0x462290),  iVar4 != 0)) {\n                    (*_sym.imp.USER32.dll_SetPropA)(param_1, *0x462294, 1);\n                }\n            }\n        }\n        pcVar2 = _sym.imp.USER32.dll_GetWindow;\n        for (iVar4 = (*_sym.imp.USER32.dll_GetWindow)(param_1, 5); iVar4 != 0; iVar4 = (*pcVar2)(iVar4, 2)) {\n            fcn.0041fb00(iVar4);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 562
    },
    "0041fd50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0041fd50(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t unaff_ESI;\n    uint32_t uVar4;\n    uint16_t unaff_retaddr;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (*0x462280 != 0) {\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(param_1, 5);\n        if (iVar2 != 0) {\n            uVar4 = unaff_ESI & 0xffff0000 | unaff_retaddr;\n            do {\n                fcn.0041fca0(iVar2, uVar4, 0);\n                for (iVar3 = (*pcVar1)(iVar2, 5); iVar3 != 0; iVar3 = (*pcVar1)(iVar3, 2)) {\n                    fcn.0041fca0(iVar3, uVar4, iVar2);\n                }\n                iVar2 = (*pcVar1)(iVar2, 2);\n            } while (iVar2 != 0);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 264
    },
    "0041fe40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0041fe40(uint32_t param_1, uint param_2, uint param_3)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    \n    if (((*0x462280 == 0) || (param_1 < 0x134)) || (param_1 == 0x137)) {\n        return 0;\n    }\n    if (param_1 == 0x134) {\n        if (*0x4622a0 < 0x35f) {\n            iVar2 = (*_sym.imp.USER32.dll_GetWindow)(param_3, 5);\n            if (iVar2 != 0) {\n                uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_3, 0xfffffff0);\n                if ((uVar1 & 3) != 3) goto code_r0x0041fe94;\n            }\n        }\n        return 0;\n    }\ncode_r0x0041fe94:\n    (*_sym.imp.GDI32.dll_SetTextColor)(param_2, *0x4622b0);\n    (*_sym.imp.GDI32.dll_SetBkColor)(param_2, *0x4622a8);\n    return *0x4622c8;\n}\n",
        "token_count": 278
    },
    "0041ff00": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuchar * fcn.0041ff00(int32_t param_1, uint param_2, uchar *param_3, uint param_4, int32_t param_5)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint uVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    int32_t iVar9;\n    int32_t iStack136;\n    uchar *puStack132;\n    int32_t iStack128;\n    uchar *puStack124;\n    int32_t iStack120;\n    uchar *puStack116;\n    int32_t iStack112;\n    uchar *puStack108;\n    uchar *puStack104;\n    int32_t iStack100;\n    int32_t iStack96;\n    int32_t iStack92;\n    uint uStack88;\n    uchar *puStack84;\n    uchar *puStack80;\n    \n    if (param_5 == 0) {\n        puStack80 = 0x6;\n        puStack84 = param_1;\n        uStack88 = 0x41ff22;\n        iStack96 = fcn.0041f1d0();\n    }\n    else {\n        iStack96 = 0;\n    }\n    puStack80 = param_4;\n    if (iStack96 == 0) {\n        puStack84 = param_3;\n        uStack88 = param_2;\n        iStack92 = param_1;\n        iStack96 = 0x41ff53;\n        puStack80 = (*_sym.imp.USER32.dll_DefWindowProcA)();\n    }\n    else {\n        puStack84 = param_3;\n        uStack88 = param_2;\n        iStack92 = param_1;\n        iStack100 = 0x41ff40;\n        puStack80 = (*_sym.imp.USER32.dll_CallWindowProcA)();\n    }\n    if (*0x462280 == 0) {\n        return puStack80;\n    }\n    iStack100 = param_1;\n    puStack104 = 0x41ff75;\n    iVar1 = (*_sym.imp.USER32.dll_IsIconic)();\n    if (iVar1 != 0) {\n        return puStack84;\n    }\n    puStack80 = 0x1;\n    puStack104 = &stack0xffffffb0;\n    puStack108 = NULL;\n    iStack112 = 0x11ef;\n    puStack116 = param_1;\n    iStack120 = 0x41ffa2;\n    (*_sym.imp.USER32.dll_SendMessageA)();\n    iStack120 = 0xfffffff0;\n    puStack124 = param_1;\n    iStack128 = 0x41ffad;\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    if ((puStack104 != NULL) && ((uVar2 & 0x10400080) == 0x10400080)) {\n        bVar5 = (uVar2 & 0xc00000) == 0xc00000;\n        iStack128 = param_1;\n        iVar4 = *0x462d78 - bVar5;\n        puStack132 = 0x41fff2;\n        uVar3 = (*_sym.imp.USER32.dll_GetWindowDC)();\n        puStack132 = &stack0xffffff9c;\n        iStack136 = param_1;\n        (*_sym.imp.USER32.dll_GetWindowRect)();\n        iStack100 = iStack100 - puStack108;\n        iStack96 = iStack96 - puStack104;\n        puStack104 = NULL;\n        puStack108 = NULL;\n        fcn.0041f4e0(uVar3, &stack0xffffff94, 2, 7, 0xf);\n        puVar8 = &stack0xffffff94;\n        iVar9 = -1;\n        (*_sym.imp.USER32.dll_InflateRect)(puVar8, 0xffffffff, 0xffffffff);\n        fcn.0041f4e0(uVar3, &stack0xffffff88, 0, 2, 0xf);\n        iVar7 = -1;\n        uVar6 = 0xffffffff;\n        (*_sym.imp.USER32.dll_InflateRect)(&stack0xffffff88, 0xffffffff, 0xffffffff);\n        iVar1 = (*_sym.imp.GDI32.dll_SelectObject)(uVar3, *0x4622c8);\n        iStack120 = iStack136;\n        iStack112 = iStack128;\n        puStack116 = iVar9 + *0x462d74;\n        puStack124 = iVar9;\n        fcn.0041f4b0(uVar3, &stack0xffffff84);\n        (*_sym.imp.USER32.dll_OffsetRect)(&stack0xffffff84, puStack132 + (-*0x462d74 - iVar9), 0);\n        fcn.0041f4b0(uVar3, &stack0xffffff78);\n        iStack136 = iVar7 + *0x462d74;\n        iStack128 = iVar1 - *0x462d74;\n        puStack124 = puStack132 + iVar4;\n        fcn.0041f4b0(uVar3, &stack0xffffff78);\n        if (bVar5) {\n            puStack116 = puStack132 + iVar4;\n            iStack120 = iStack136;\n            iStack112 = iStack128;\n            puStack108 = puStack116 + *0x462d7c;\n            fcn.0041f4e0(uVar3, &stack0xffffff88, 2, 0, 0xf);\n        }\n        puStack132 = puStack132 + ((iVar9 - puVar8) - *0x462d74);\n        puStack124 = puStack132 + *0x462d78;\n        fcn.0041f4b0(uVar3, &stack0xffffff78);\n        (*_sym.imp.GDI32.dll_SelectObject)(uVar3, uVar6);\n        (*_sym.imp.USER32.dll_ReleaseDC)(param_1, uVar3);\n    }\n    return puStack108;\n}\n",
        "token_count": 1345
    },
    "004201b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.004201b0(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    char *pcStack64;\n    uchar *puStack60;\n    uint uStack56;\n    uchar *puStack52;\n    char *pcStack48;\n    char *pcStack44;\n    char *pcStack40;\n    char *pcStack36;\n    uchar *puStack32;\n    uint uStack28;\n    uint uStack24;\n    \n    if (*0x462d85 != '\\0') {\n        uStack24 = 0x462260;\n        uStack28 = 0x4201cd;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)();\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProfileStringA;\n        puStack32 = &stack0xfffffff0;\n        uStack28 = 9;\n        *0x462d84 = 0x1e;\n        pcStack36 = \"roman\";\n        pcStack40 = \"kanjimenu\";\n        pcStack44 = \"windows\";\n        pcStack48 = 0x4201f2;\n        (*_sym.imp.KERNEL32.dll_GetProfileStringA)();\n        pcVar2 = _sym.imp.KERNEL32.dll_lstrcmpiA;\n        puStack52 = &stack0xffffffdc;\n        pcStack48 = \"kanji\";\n        uStack56 = 0x420204;\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)();\n        if (iVar3 == 0) {\n            *0x462d84 = 0x1f;\n        }\n        puStack60 = &stack0xffffffd4;\n        uStack56 = 9;\n        pcStack64 = \"english\";\n        (*pcVar1)(\"windows\", \"hangeulmenu\");\n        iVar3 = (*pcVar2)(&stack0xffffffc0, \"hangeul\");\n        if (iVar3 == 0) {\n            *0x462d84 = 0x1f;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x462260);\n    }\n    return;\n}\n",
        "token_count": 465
    },
    "00420250": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t fcn.00420250(void)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint *puVar8;\n    uint uStack76;\n    uint uStack72;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint uStack56;\n    \n    uStack56 = 0x462260;\n    uStack60 = 0x420261;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)();\n    uStack60 = 0;\n    uStack64 = 0x420269;\n    uVar4 = (*_sym.imp.USER32.dll_GetDC)();\n    pcVar2 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    uStack64 = 0xc;\n    uStack72 = 0x420276;\n    uStack68 = uVar4;\n    iVar5 = (*_sym.imp.GDI32.dll_GetDeviceCaps)();\n    uStack72 = 0xe;\n    uStack76 = uVar4;\n    iVar6 = (*pcVar2)();\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    *0x462280 = 3 < iVar5 * iVar6;\n    iVar5 = (*_sym.imp.USER32.dll_GetSystemMetrics)(1);\n    if ((iVar5 == 0x15e) && (iVar5 = (*pcVar2)(0),  iVar5 == 0x280)) {\n        *0x462280 = 0;\n    }\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar4);\n    pcVar3 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n    if (*0x462280 != 0) {\n        *0x462288 = (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(0x45e50c);\n        if ((*0x462288 != 0) && (*0x46228e = (*pcVar3)(\"C3dNew\"),  *0x46228e != 0)) {\n            *0x46228c = (*pcVar3)(\"C3dL\");\n            *0x46228a = (*pcVar3)(\"C3dH\");\n            if ((*0x46228c == 0) || (*0x46228a == 0)) {\n                *0x462280 = 0;\n                return 0;\n            }\n            *0x462292 = (*pcVar3)(\"C3dLNew\");\n            *0x462290 = (*pcVar3)(\"C3dHNew\");\n            if ((*0x462292 == 0) || (*0x462290 == 0)) {\n                *0x462280 = 0;\n                return 0;\n            }\n            *0x462294 = (*pcVar3)(\"C3dD\");\n            if (*0x462294 != 0) {\n                *0x462d85 = (*pcVar2)(0x2a);\n                fcn.004201b0();\n                iVar5 = fcn.00420520(1);\n                pcVar2 = _sym.imp.USER32.dll_GetClassInfoA;\n                if (iVar5 != 0) {\n                    puVar8 = 0x44dfc4;\n                    puVar7 = 0x462ce0;\n                    do {\n                        puVar1 = puVar8 + -5;\n                        *puVar7 = *puVar8;\n                        puVar8 = puVar8 + 8;\n                        (*pcVar2)(0, puVar1, &stack0xffffffb4);\n                        puVar7[1] = uStack72;\n                        puVar7 = puVar7 + 6;\n                    } while (puVar8 < vtable.exception.0);\n                    iVar5 = (*pcVar2)(0, 0x8002, &stack0xffffffb4);\n                    if (iVar5 == 0) {\n                        *0x462d70 = _sym.imp.USER32.dll_DefDlgProcA;\n                    }\n                    else {\n                        *0x462d70 = uStack72;\n                    }\n                    goto code_r0x004202eb;\n                }\n            }\n        }\n        *0x462280 = 0;\n    }\ncode_r0x004202eb:\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x462260);\n    return *0x462280;\n}\n",
        "token_count": 971
    },
    "00420440": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00420440(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    ushort uVar4;\n    ushort extraout_var;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x462260);\n    piVar2 = 0x462ce0;\n    do {\n        if (*piVar2 != 0) {\n            *piVar2 = 0;\n        }\n        piVar2 = piVar2 + 6;\n    } while (piVar2 < 0x462d70);\n    uVar3 = fcn.0041f480();\n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalDeleteAtom;\n    if (*0x462288 != 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar3 & 0xffff0000 | *0x462288);\n    }\n    if (*0x46228e != 0) {\n        uVar3 = (*pcVar1)(uVar3 & 0xffff0000 | *0x46228e);\n    }\n    if (*0x46228c != 0) {\n        uVar3 = (*pcVar1)(uVar3 & 0xffff0000 | *0x46228c);\n    }\n    if (*0x46228a != 0) {\n        uVar3 = (*pcVar1)(uVar3 & 0xffff0000 | *0x46228a);\n    }\n    if (*0x462292 != 0) {\n        uVar3 = (*pcVar1)(uVar3 & 0xffff0000 | *0x462292);\n    }\n    uVar4 = uVar3 >> 0x10;\n    if (*0x462290 != 0) {\n        (*pcVar1)(uVar3 & 0xffff0000 | *0x462290);\n        uVar4 = extraout_var;\n    }\n    if (*0x462294 != 0) {\n        (*pcVar1)(CONCAT22(uVar4, *0x462294));\n    }\n    *0x462280 = 0;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x462260);\n    return;\n}\n",
        "token_count": 495
    },
    "00420520": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00420520(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint16_t uVar5;\n    char *pcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    uint *puVar9;\n    bool bVar10;\n    int32_t iStack80;\n    int32_t aiStack76 [4];\n    int32_t aiStack32 [4];\n    uint uStack16;\n    uint uStack12;\n    int32_t iStack8;\n    uint uStack4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSysColor;\n    if (*0x462280 == 0) {\n        return 0;\n    }\n    uVar3 = 0;\n    do {\n        uVar5 = uVar3 + 1;\n        aiStack76[3] = *(uVar3 * 2 + 0x44e070);\n        aiStack76[2] = 0x420553;\n        uVar2 = (*pcVar1)();\n        *(&stack0xffffffe0 + uVar3 * 4) = uVar2;\n        uVar3 = uVar5;\n    } while (uVar5 < 8);\n    if (*0x4622a0 == 0x300) {\n        aiStack32[0] = 0xffffff;\n    }\n    if (((iStack8 == 0) || (aiStack32[1] == iStack8)) && (iStack8 = 0xc0c0c0,  aiStack32[1] != 0x808080)) {\n        iStack8 = 0x808080;\n    }\n    bVar10 = param_1 == 0;\n    if (bVar10) {\n        iVar4 = 0x20;\n        pcVar6 = 0x4622a4;\n        pcVar8 = &stack0xffffffe0;\n        do {\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            bVar10 = *pcVar6 == *pcVar8;\n            pcVar6 = pcVar6 + 1;\n            pcVar8 = pcVar8 + 1;\n        } while (bVar10);\n        if (bVar10) {\n            return 1;\n        }\n    }\n    aiStack76[3] = uStack4;\n    aiStack76[2] = uStack16;\n    aiStack76[1] = aiStack32[0];\n    aiStack76[0] = aiStack32[2];\n    iStack80 = aiStack32[1];\n    iStack80 = fcn.00422750(*0x462298, 0x67c7, uStack12);\n    pcVar1 = _sym.imp.GDI32.dll_CreateSolidBrush;\n    uVar3 = 0;\n    do {\n        uVar5 = uVar3 + 1;\n        uVar2 = (*pcVar1)(*(&stack0xffffffc0 + uVar3 * 4));\n        *(&stack0xffffffb4 + uVar3 * 4) = uVar2;\n        uVar3 = uVar5;\n    } while (uVar5 < 3);\n    uVar5 = 0;\n    do {\n        if (*(&stack0xffffffb4 + uVar5 * 4) == 0) goto code_r0x00420678;\n        uVar5 = uVar5 + 1;\n    } while (uVar5 < 3);\n    if (iStack80 != 0) {\n        fcn.0041f480();\n        *0x4622c4 = aiStack76[0];\n        *0x4622c8 = aiStack76[1];\n        *0x4622cc = aiStack76[2];\n        puVar7 = &stack0xffffffc0;\n        puVar9 = 0x4622a4;\n        for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar9 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar9 = puVar9 + 1;\n        }\n        *0x4622d0 = iStack80;\n        return 1;\n    }\ncode_r0x00420678:\n    uVar5 = 0;\n    do {\n        uVar3 = uVar5;\n        uVar5 = uVar5 + 1;\n        fcn.0041f460(&stack0xffffffb4 + uVar3 * 4);\n    } while (uVar5 < 3);\n    fcn.0041f460(&stack0xffffffb0);\n    return 0;\n}\n",
        "token_count": 1048
    },
    "00420db0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nbool fcn.00420db0(uint param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint16_t *puVar5;\n    uint32_t unaff_EDI;\n    uchar auStack16 [8];\n    uint16_t uStack8;\n    uint32_t uStack4;\n    \n    iVar2 = fcn.0041f1b0(param_1);\n    if (iVar2 != 0) {\n        return false;\n    }\n    iVar2 = 0;\n    puVar5 = 0x44dfcc;\n    (*_sym.imp.USER32.dll_GetClassNameA)(param_1, auStack16, 0x10);\n    uVar1 = uStack4 & 0xffff;\n    do {\n        if ((*puVar5 & uVar1) != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(puVar5 + -0xe, &stack0xffffffe4);\n            if (iVar3 == 0) {\n                uVar4 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1, 0xfffffff0);\n                iVar3 = (**(iVar2 * 0x20 + 0x44dfc8))\n                                  (param_1, uVar4, unaff_EDI & 0xffff0000 | uVar1, puVar5 & 0xffff0000 | uStack8, \n                                   uStack4);\n                if (iVar3 == 1) {\n                    if ((uStack8 == 1) && (*0x4622a2 == 0x10)) {\n                        fcn.0041f3c0(param_1, *(iVar2 * 0x18 + 0x462ce0));\n                        return true;\n                    }\n                    fcn.0041f220(param_1, *(iVar2 * 0x18 + 0x462ce0));\n                }\n                return iVar3 != 0;\n            }\n        }\n        puVar5 = puVar5 + 0x10;\n        iVar2 = iVar2 + 1;\n        if (0x44e08b < puVar5) {\n            return false;\n        }\n    } while( true );\n}\n",
        "token_count": 495
    },
    "00420fd0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.00420fd0(uint param_1, int32_t param_2, uint *param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    bool bVar4;\n    int32_t iStack260;\n    uchar *puStack256;\n    uchar *puStack252;\n    uchar *puStack248;\n    int32_t iStack244;\n    int32_t iStack240;\n    int32_t iStack236;\n    int32_t iStack232;\n    int32_t iStack228;\n    int32_t iStack224;\n    uchar *puStack220;\n    int32_t iStack216;\n    int32_t iStack212;\n    int32_t iStack208;\n    int32_t iStack204;\n    int32_t iStack200;\n    int32_t iStack196;\n    int32_t iStack192;\n    int32_t iStack188;\n    int32_t iStack184;\n    int32_t iStack180;\n    int32_t iStack176;\n    int32_t iStack172;\n    int32_t iStack168;\n    uint uStack164;\n    int32_t iStack160;\n    int32_t iStack156;\n    int32_t iStack152;\n    int32_t iStack148;\n    int32_t iStack144;\n    uint uStack140;\n    int32_t iStack136;\n    int32_t iStack132;\n    int32_t iStack128;\n    uint uStack124;\n    int32_t iStack120;\n    uint uStack116;\n    uint uStack112;\n    uint uStack108;\n    int32_t iStack104;\n    int32_t iStack100;\n    uint uStack96;\n    uint uStack92;\n    uint uStack88;\n    uint uStack84;\n    int32_t iStack80;\n    int32_t iStack76;\n    uchar *puStack72;\n    uchar *puStack68;\n    int32_t iStack64;\n    uint *puStack60;\n    uchar *puStack56;\n    uint uStack52;\n    uint uStack48;\n    uchar auStack28 [12];\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack16 = *param_3;\n    uStack12 = param_3[1];\n    uStack8 = param_3[2];\n    uStack48 = 0xf;\n    uStack52 = 7;\n    uStack4 = param_3[3];\n    puStack56 = 0x7;\n    puStack60 = param_3;\n    iStack64 = param_2;\n    puStack68 = 0x421006;\n    fcn.0041f4e0();\n    puStack56 = &stack0xfffffff0;\n    uStack48 = 0xffffffff;\n    uStack52 = 0xffffffff;\n    puStack60 = 0x421018;\n    (*_sym.imp.USER32.dll_InflateRect)();\n    if (param_3 == 1) {\n        puStack60 = uStack8;\n        iStack64 = 0x42102b;\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)();\n        if (iVar1 != 0) {\n            puStack72 = &stack0xffffffe4;\n            puStack60 = 0xf;\n            iStack64 = 7;\n            puStack68 = 0x7;\n            iStack76 = param_2;\n            iStack80 = 0x421040;\n            fcn.0041f4e0();\n            puStack68 = &stack0xffffffe4;\n            puStack60 = 0xffffffff;\n            iStack64 = 0xffffffff;\n            puStack72 = 0x421052;\n            (*_sym.imp.USER32.dll_InflateRect)();\n        }\n    }\n    puStack60 = 0xf00021;\n    puStack72 = param_3[1];\n    iStack64 = 1;\n    iStack76 = *param_3;\n    puStack68 = 0x1;\n    iStack80 = param_2;\n    uStack84 = 0x421069;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    uStack84 = 0xf00021;\n    uStack96 = param_3[1];\n    uStack88 = 1;\n    uStack92 = 1;\n    iStack100 = param_3[2] + -1;\n    iStack104 = param_2;\n    uStack108 = 0x421082;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    uStack108 = 0xf00021;\n    uStack112 = 1;\n    iStack120 = param_3[3] + -1;\n    uStack116 = 1;\n    uStack124 = *param_3;\n    iStack128 = param_2;\n    iStack132 = 0x42109a;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    iStack132 = 0xf00021;\n    iStack136 = 1;\n    iStack144 = param_3[3] + -1;\n    uStack140 = 1;\n    iStack148 = param_3[2] + -1;\n    iStack152 = param_2;\n    iStack156 = 0x4210b4;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    bVar4 = iStack80 == 0;\n    iVar1 = bVar4 + 1;\n    iStack156 = *0x4622c4;\n    if (iStack80 != 0) {\n        iStack156 = *0x4622cc;\n    }\n    iStack160 = param_2;\n    uStack164 = 0x4210d9;\n    iStack144 = (*_sym.imp.GDI32.dll_SelectObject)();\n    uStack164 = 0xf00021;\n    iStack168 = iStack120 - iStack128;\n    iStack176 = iStack128;\n    iStack180 = iStack132;\n    iStack184 = param_2;\n    iStack188 = 0x4210fd;\n    iStack172 = iVar1;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    iStack188 = 0xf00021;\n    iStack196 = iStack148 - iStack156;\n    iStack200 = iStack152;\n    iStack204 = iStack156;\n    iStack208 = param_2;\n    iStack212 = 0x42111d;\n    iStack192 = iVar1;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    if (iStack136 == 0) {\n        iVar3 = 0;\n        iStack212 = *0x4622cc;\n        iStack216 = param_2;\n        puStack220 = 0x421133;\n        (*_sym.imp.GDI32.dll_SelectObject)();\n        iStack168 = iStack168 + -1;\n        iStack172 = iStack172 + -1;\n        if (iVar1 != 0) {\n            do {\n                iStack212 = 0xf00021;\n                iStack216 = 1;\n                puStack220 = (iStack172 - iStack180) + 1;\n                iStack224 = iStack168;\n                iStack228 = iStack180;\n                iStack232 = param_2;\n                iStack236 = 0x421161;\n                (*_sym.imp.GDI32.dll_PatBlt)();\n                iStack236 = 0xf00021;\n                iStack240 = iStack192 - iStack200;\n                iStack244 = 1;\n                puStack248 = iStack200;\n                puStack252 = iStack196;\n                puStack256 = param_2;\n                iStack260 = 0x421182;\n                (*_sym.imp.GDI32.dll_PatBlt)();\n                if (iVar3 < bVar4) {\n                    puStack220 = &stack0xffffff4c;\n                    iStack212 = 0xffffffff;\n                    iStack216 = 0xffffffff;\n                    iStack224 = 0x421198;\n                    (*_sym.imp.USER32.dll_InflateRect)();\n                }\n                iVar3 = iVar3 + 1;\n            } while (iVar3 < iVar1);\n        }\n    }\n    iStack180 = iStack180 + 1;\n    iStack176 = iStack176 + 1;\n    iStack212 = *0x4622c8;\n    iStack216 = param_2;\n    puStack220 = 0x4211b2;\n    (*_sym.imp.GDI32.dll_SelectObject)();\n    puStack220 = 0xf00021;\n    iStack224 = iStack176 - iStack184;\n    iStack228 = iStack180 - iStack188;\n    iStack232 = iStack184;\n    iStack236 = iStack188;\n    iStack240 = param_2;\n    iStack244 = 0x4211da;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    iStack244 = iStack192;\n    puStack248 = 0x4211e5;\n    iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)();\n    if (iVar1 == 0) {\n        puStack248 = *0x4622bc;\n        puStack252 = param_2;\n        puStack256 = 0x4211f6;\n        (*_sym.imp.GDI32.dll_SetTextColor)();\n    }\n    iVar1 = iStack184;\n    puStack248 = &stack0xffffff24;\n    puStack252 = &stack0xffffff20;\n    puStack256 = iStack184;\n    iStack260 = param_2;\n    fcn.0041f6d0();\n    iStack212 = iStack212 + ((iStack204 - iStack212) - puStack220) / 2;\n    iStack216 = iStack216 + ((iStack208 - iStack216) - iStack224) / 2;\n    iVar3 = iStack212 + puStack220;\n    if (iStack204 <= iStack212 + puStack220) {\n        iVar3 = iStack204;\n    }\n    iVar2 = iStack216 + iStack224;\n    if (iStack208 <= iStack216 + iStack224) {\n        iVar2 = iStack208;\n    }\n    iStack208 = iVar2;\n    if (iStack172 != 0) {\n        puStack256 = &stack0xffffff28;\n        puStack248 = 0x1;\n        puStack252 = 0x1;\n        iStack260 = 0x42127e;\n        iStack204 = iVar3;\n        (*_sym.imp.USER32.dll_OffsetRect)();\n        iVar3 = param_3[2] + -3;\n        if (iStack208 <= param_3[2] + -3) {\n            iVar3 = iStack208;\n        }\n        iStack208 = iVar3;\n        iVar3 = param_3[3] + -3;\n        if (iStack204 <= param_3[3] + -3) {\n            iVar3 = iStack204;\n        }\n    }\n    iStack204 = iVar3;\n    puStack252 = &stack0xffffff28;\n    puStack248 = 0x20;\n    puStack256 = iStack180;\n    iStack260 = iVar1;\n    (*_sym.imp.USER32.dll_DrawTextA)(param_2);\n    iVar1 = (*_sym.imp.USER32.dll_GetFocus)();\n    if (iVar1 == iStack216) {\n        (*_sym.imp.USER32.dll_InflateRect)(&stack0xffffff14, 1, 1);\n        (*_sym.imp.USER32.dll_IntersectRect)(&stack0xffffff08, &stack0xffffff08, param_3);\n        (*_sym.imp.USER32.dll_DrawFocusRect)(param_2, &stack0xfffffefc);\n    }\n    if (puStack248 != NULL) {\n        (*_sym.imp.GDI32.dll_SelectObject)(param_2, puStack248);\n    }\n    return;\n}\n",
        "token_count": 2637
    },
    "00421310": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid fcn.00421310(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uchar *puVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iStack460;\n    int32_t iStack456;\n    int32_t iStack452;\n    int32_t iStack448;\n    int32_t iStack444;\n    uint32_t uStack440;\n    int32_t iStack436;\n    int32_t iStack432;\n    int32_t iStack428;\n    int32_t iStack424;\n    int32_t iStack420;\n    int32_t iStack416;\n    int32_t iStack412;\n    int32_t iStack408;\n    uint32_t uStack404;\n    int32_t iStack400;\n    int32_t iStack396;\n    int32_t iStack392;\n    int32_t iStack388;\n    int32_t iStack384;\n    uchar *puStack380;\n    int32_t iStack376;\n    uint uStack372;\n    int32_t iStack368;\n    int32_t iStack364;\n    uint uStack360;\n    uchar auStack308 [208];\n    uint32_t uStack100;\n    int32_t iStack4;\n    \n    uStack360 = 0xfffffff0;\n    iStack364 = param_1;\n    iStack368 = 0x42132a;\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    iStack368 = param_1;\n    uVar2 = uVar2 & 0x1f;\n    uStack372 = 0x42133f;\n    (*_sym.imp.USER32.dll_GetParent)();\n    uStack372 = 2;\n    iStack376 = iStack4;\n    puStack380 = 0x421353;\n    (*_sym.imp.GDI32.dll_SetBkMode)();\n    puStack380 = &stack0xfffffecc;\n    iStack384 = param_1;\n    iStack388 = 0x421361;\n    (*_sym.imp.USER32.dll_GetClientRect)();\n    iStack388 = 0;\n    iStack392 = 0;\n    iStack396 = 0x31;\n    iStack400 = param_1;\n    uStack404 = 0x42138d;\n    uStack404 = (*_sym.imp.USER32.dll_SendMessageA)();\n    iStack384 = uStack404;\n    if (uStack404 != 0) {\n        iStack408 = iStack4;\n        iStack412 = 0x42139d;\n        iStack384 = (*_sym.imp.GDI32.dll_SelectObject)();\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetSysColor;\n    uStack404 = 0xf;\n    iStack408 = 0x4213ab;\n    iStack408 = (*_sym.imp.USER32.dll_GetSysColor)();\n    iStack412 = iStack4;\n    iStack416 = 0x4213b3;\n    (*_sym.imp.GDI32.dll_SetBkColor)();\n    iStack416 = 0x12;\n    iStack420 = 0x4213b7;\n    iStack420 = (*pcVar1)();\n    iStack424 = iStack4;\n    iStack428 = 0x4213bf;\n    (*_sym.imp.GDI32.dll_SetTextColor)();\n    iStack428 = param_1;\n    iStack432 = iStack4;\n    iStack436 = 0x135;\n    uStack440 = iStack396;\n    iStack444 = 0x4213d1;\n    iStack444 = (*_sym.imp.USER32.dll_SendMessageA)();\n    iStack448 = iStack4;\n    iStack452 = 0x4213d9;\n    uStack404 = (*_sym.imp.GDI32.dll_SelectObject)();\n    iStack452 = iStack384;\n    iStack456 = iStack388;\n    iStack460 = iStack392;\n    (*_sym.imp.GDI32.dll_IntersectClipRect)(iStack4, iStack396);\n    if (((uStack100 & 0x10) != 0) && (uVar2 != 7)) {\n        (*_sym.imp.GDI32.dll_PatBlt)\n                  (iStack4, iStack416, iStack412, iStack408 - iStack416, uStack404 - iStack412, 0xf00021);\n    }\n    iVar10 = param_1;\n    iStack432 = (*_sym.imp.USER32.dll_IsWindowEnabled)(param_1);\n    uVar9 = 0;\n    iVar8 = 0;\n    uVar7 = 0xf2;\n    uStack404 = (*_sym.imp.USER32.dll_SendMessageA)(param_1, 0xf2, 0, 0);\n    iVar11 = 0;\n    uStack440 = uStack404 & 3;\n    uStack404 = uStack404 & 4;\n    if ((((uStack100 & 10) != 0) || (uVar2 == 0)) || (uVar2 == 1)) {\n        iStack452 = (*_sym.imp.USER32.dll_GetWindowTextA)(param_1, &stack0xfffffe7c, 0x100);\n    }\n    // switch table (10 cases) at 0x421834\n    switch(uVar2) {\n    case 0:\n    case 1:\n        fcn.00420fd0(param_1, iStack4, &stack0xfffffe5c, &stack0xfffffe7c, iStack452, uVar2, uStack404);\n        goto code_r0x00421809;\n    case 2:\n    case 3:\n        break;\n    case 4:\n    case 9:\n        iVar11 = 0xd;\n        break;\n    case 5:\n    case 6:\n        if (uStack440 == 2) {\n            iVar11 = 0x1a;\n        }\n        break;\n    case 7:\n        if ((uStack100 & 6) != 0) {\n            fcn.0041f6d0(iStack4, &stack0xfffffe7c, &stack0xfffffe48, &stack0xfffffe38);\n            if (iStack456 == 0) {\n                fcn.0041f6d0(iStack4, 0x45e520, &stack0xfffffe6c, &stack0xfffffe38);\n            }\n            pcVar1 = _sym.imp.USER32.dll_ClientToScreen;\n            iStack436 = iStack436 + 4;\n            iStack428 = uStack440 + iStack436 + 4;\n            iStack424 = iStack456 + iStack432;\n            if ((uStack100 & 0x20) != 0) {\n                puVar6 = &stack0xfffffe6c;\n                iStack400 = iStack432;\n                iStack396 = iStack412;\n                uStack404 = iStack436;\n                iStack392 = iStack424;\n                (*_sym.imp.USER32.dll_ClientToScreen)(param_1, puVar6);\n                (*pcVar1)(param_1, &stack0xfffffe6c);\n                pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n                (*_sym.imp.USER32.dll_ScreenToClient)(uVar9, &stack0xfffffe5c);\n                (*pcVar1)(uVar7, &stack0xfffffe5c);\n                (*_sym.imp.USER32.dll_InvalidateRect)(puVar6, &stack0xfffffe4c, 1);\n                return;\n            }\n            iStack412 = iStack412 + -1;\n            iStack408 = iStack408 + -1;\n            iStack416 = iStack416 + iStack456 / 2;\n            fcn.0041f4e0(iStack4, &stack0xfffffe5c, 2, 2, 0xf);\n            (*_sym.imp.USER32.dll_OffsetRect)(&stack0xfffffe5c, 1, 1);\n            fcn.0041f4e0(iStack4, &stack0xfffffe50, 0, 0, 0xf);\n            if (iStack460 == 0) {\n                (*_sym.imp.GDI32.dll_SetTextColor)(iStack4, *0x4622bc);\n            }\n            (*_sym.imp.USER32.dll_DrawTextA)(iStack4, &stack0xfffffe70, iVar11, &stack0xfffffe40, 0x20);\n        }\n    default:\n        goto code_r0x00421809;\n    }\n    if (((uStack100 & 4) != 0) && (iVar3 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(iStack4),  iVar3 != 0)) {\n        iVar4 = (*_sym.imp.GDI32.dll_SelectObject)(iVar3, *0x4622d0);\n        if (iVar4 != 0) {\n            iVar5 = iStack444;\n            if (iVar11 != 0) {\n                iVar5 = iStack436 + -0xe;\n            }\n            (*_sym.imp.GDI32.dll_BitBlt)\n                      (iStack4, iVar5, uStack440 + ((iStack432 - uStack440) + -0xd) / 2, 0xe, 0xd, iVar3, uVar9, iVar10\n                       , 0xcc0020);\n            (*_sym.imp.GDI32.dll_SelectObject)(iVar3, iVar4);\n        }\n        (*_sym.imp.GDI32.dll_DeleteDC)(iVar3);\n    }\n    if ((uStack100 & 2) != 0) {\n        if (iStack456 == 0) {\n            iStack436 = iStack420 + 0x12;\n        }\n        else {\n            iStack428 = iStack412 + -0x12;\n        }\n        if (iStack448 == 0) {\n            (*_sym.imp.GDI32.dll_SetTextColor)(iStack4, *0x4622bc);\n        }\n        (*_sym.imp.USER32.dll_DrawTextA)(iStack4, &stack0xfffffe7c, iStack452, &stack0xfffffe4c, 0x24);\n    }\n    if ((uStack100 & 8) != 0) {\n        fcn.0041f6d0(iStack4, &stack0xfffffe7c, &stack0xfffffe6c, &stack0xfffffe48);\n        iStack432 = ((iStack424 - iStack432) - uStack440) / 2;\n        iStack424 = uStack440 + iStack432;\n        if (iStack456 == 0) {\n            iStack436 = iStack420 + 0x12;\n        }\n        else {\n            iStack412 = iStack412 + -0x12;\n            iStack436 = iStack420;\n        }\n        iStack428 = uStack404 + iStack436;\n        (*_sym.imp.USER32.dll_InflateRect)(&stack0xfffffe4c, 1, 1);\n        (*_sym.imp.USER32.dll_IntersectRect)(&stack0xfffffe40, &stack0xfffffe40, &stack0xfffffe50);\n        (*_sym.imp.USER32.dll_DrawFocusRect)(iStack4, &stack0xfffffe34);\n    }\ncode_r0x00421809:\n    (*_sym.imp.GDI32.dll_SelectObject)(iStack4, iStack444);\n    if (iVar8 != 0) {\n        (*_sym.imp.GDI32.dll_SelectObject)(iStack4, iVar8);\n    }\n    return;\n}\n",
        "token_count": 2584
    },
    "00421b40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.00421b40(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t iVar7;\n    int32_t unaff_EBX;\n    int32_t unaff_EBP;\n    int32_t unaff_EDI;\n    int32_t unaff_retaddr;\n    uint uVar8;\n    int32_t iStack124;\n    int32_t iStack120;\n    uchar *puStack116;\n    int32_t iStack112;\n    uchar *puStack108;\n    int32_t iStack104;\n    int32_t iStack100;\n    uchar *puStack96;\n    uint32_t uStack92;\n    int32_t iStack88;\n    uchar auStack68 [4];\n    uint32_t uStack64;\n    uchar auStack56 [8];\n    int32_t iStack48;\n    int32_t iStack40;\n    int32_t iStack36;\n    \n    iStack88 = -0x10;\n    uStack92 = param_1;\n    puStack96 = 0x421b54;\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    if ((uVar2 & 0x10000000) != 0) {\n        if ((param_1 == 3) && ((uVar2 & 3) == 3)) {\n            puStack96 = NULL;\n            iStack100 = 0;\n            iStack104 = 0x157;\n            puStack108 = param_1;\n            iStack112 = 0x421b80;\n            iVar3 = (*_sym.imp.USER32.dll_SendMessageA)();\n            if (iVar3 != 0) {\n                return;\n            }\n        }\n        if (unaff_retaddr != 0) {\n            puStack96 = param_1;\n            iStack100 = 0x421b96;\n            (*_sym.imp.USER32.dll_HideCaret)();\n        }\n        puStack96 = &stack0xffffffc8;\n        iStack100 = param_1;\n        iStack104 = 0x421ba2;\n        (*_sym.imp.USER32.dll_GetWindowRect)();\n        iStack104 = param_1;\n        puStack108 = 0x421ba9;\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)();\n        pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n        puStack108 = &stack0xffffffbc;\n        puStack116 = 0x421bb9;\n        iStack112 = iVar3;\n        (*_sym.imp.USER32.dll_ScreenToClient)();\n        puStack116 = &stack0xffffffbc;\n        uVar2 = 0xf;\n        iStack124 = 0x421bc5;\n        iStack120 = iVar3;\n        (*pcVar1)();\n        iStack124 = iVar3;\n        uVar4 = (*_sym.imp.USER32.dll_GetDC)();\n        puStack96 = puStack108 & 0x100000;\n        if (puStack96 != NULL) {\n            uVar2 = 7;\n        }\n        uStack92 = puStack108 & 0x200000;\n        if (uStack92 != 0) {\n            uVar2 = uVar2 & 0xfffffffb;\n        }\n        iVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1, 0xfffffff4);\n        if (iStack40 - iVar5 == -1000) {\n            puStack108 = 0x29a;\n            puStack96 = (*_sym.imp.USER32.dll_SendMessageA)(iVar3, 0x1944, 0, &stack0xffffff94);\n            if (iStack124 == 0x29a) {\n                puStack96 = (*_sym.imp.USER32.dll_SendMessageA)(iVar3, 0x1943, 0, &stack0xffffff84);\n            }\n            (*_sym.imp.USER32.dll_GetClassNameA)(iVar3, &stack0xffffffb0, 0x10);\n            iVar5 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&stack0xffffffa4, \"ComboBox\");\n            if ((iVar5 == 0) || ((puStack108 == 0x1 && (unaff_EDI == 0x3eb)))) {\n                puStack116 = (*_sym.imp.USER32.dll_GetParent)(iVar3);\n                uVar8 = 2;\n                (*_sym.imp.USER32.dll_MapWindowPoints)(iVar3, puStack116, &stack0xffffff9c, 2);\n                (*_sym.imp.USER32.dll_ReleaseDC)(iVar3, uVar4);\n                uVar4 = (*_sym.imp.USER32.dll_GetDC)(uVar8);\n                if (iStack40 == 0) {\n                    uVar2 = uVar2 & 0xfffffffd;\n                    uStack92 = uStack92 + 1;\n                    iVar3 = iStack112;\n                }\n                else {\n                    uVar6 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n                    if (((uVar6 & 3) == 2) || ((uVar6 & 3) == 3)) {\n                        iVar5 = (*_sym.imp.USER32.dll_SendMessageA)(iVar3, 0x157, 0, 0);\n                        iVar3 = iStack112;\n                        if (iVar5 != 0) {\n                            (*_sym.imp.USER32.dll_ReleaseDC)(iStack112, uVar4);\n                            (*_sym.imp.USER32.dll_ShowCaret)(param_1);\n                            return;\n                        }\n                    }\n                    else {\n                        uVar2 = uVar2 & 0xfffffff7;\n                        uVar8 = (*_sym.imp.USER32.dll_GetWindow)(iVar3, 5);\n                        (*_sym.imp.USER32.dll_GetWindowRect)(uVar8, &stack0xffffffa0);\n                        iStack88 = iStack88 + (unaff_EDI - unaff_EBX);\n                        fcn.0041f620(uVar4, &stack0xffffffa0, 0x1008);\n                        iStack88 = iStack88 + (unaff_EBX - unaff_EDI);\n                        iVar3 = iStack112;\n                    }\n                }\n            }\n        }\n        fcn.0041f620(uVar4, &stack0xffffffa0, uVar2);\n        iVar5 = iStack88;\n        if ((iStack36 == 3) && ((puStack116 & 3) == 3)) {\n            iVar7 = (*_sym.imp.USER32.dll_GetSystemMetrics)(2);\n            puStack96 = iVar5 - iVar7;\n            fcn.0041f4e0(uVar4, &stack0xffffffa0, 7, 7, 0xc);\n            fcn.00420f60(param_1);\n        }\n        else {\n            if (iStack100 != 0) {\n                iStack88 = iStack88 + 1;\n                fcn.0041f4e0(uVar4, &stack0xffffffa0, 0, 0, 4);\n                iVar5 = iStack88 + -1;\n                uStack64 = puStack96;\n                iStack88 = iVar5;\n                iVar7 = (*_sym.imp.USER32.dll_GetSystemMetrics)(2);\n                puStack96 = iVar5 - iVar7;\n                fcn.0041f4e0(uVar4, &stack0xffffffa0, 7, 7, 8);\n                puStack96 = uStack64;\n            }\n            if (iStack104 != 0) {\n                unaff_EBP = unaff_EBP + 1;\n                fcn.0041f4e0(uVar4, &stack0xffffffa0, 0, 0, 8);\n                iVar5 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x15);\n                uStack92 = (unaff_EBP + -1) - iVar5;\n                fcn.0041f4e0(uVar4, &stack0xffffffa0, 7, 7, 4);\n            }\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(iVar3, uVar4);\n        if (iStack48 != 0) {\n            (*_sym.imp.USER32.dll_ShowCaret)(param_1);\n        }\n    }\n    return;\n}\n",
        "token_count": 1848
    },
    "004222b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid __cdecl\nfcn.004222b0(uint noname_0, uint noname_1, int32_t *noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6\n            , uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint hWnd, uint hdc, \n            uint nXLeft)\n\n{\n    int32_t iVar1;\n    uint16_t uVar2;\n    uint var_ch;\n    uint32_t var_14h_2;\n    uint var_4h;\n    uint uStack52;\n    uint uStack48;\n    int32_t iStack44;\n    int32_t iStack40;\n    int32_t iStack36;\n    int32_t iStack32;\n    uint uStack28;\n    uint var_14h;\n    uint crColor;\n    uint lpchText;\n    \n    uStack28 = 0xf00021;\n    iStack40 = noname_2[1];\n    iStack44 = *noname_2;\n    iStack32 = noname_2[3] - iStack40;\n    iStack36 = noname_2[2] - iStack44;\n    uStack48 = var_ch;\n    uStack52 = 0x4222de;\n    (*_sym.imp.GDI32.dll_PatBlt)();\n    uStack52 = noname_0;\n    iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)();\n    fcn.00410700();\n    if (*0x10 != 0x34) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextA)(noname_0, &stack0xffffffcc, iVar1 + 2);\n        if (iVar1 != 0) {\n            uVar2 = 0x140;\n            if ((var_14h_2 & 0xf) != 0xc) {\n                uVar2 = var_14h_2 & 0xf | 0x150;\n            }\n            if ((var_14h_2 & 0x80) != 0) {\n                uVar2 = uVar2 | 0x800;\n            }\n            if ((var_14h_2 & 0x8000000) != 0) {\n                crColor = (*_sym.imp.GDI32.dll_SetTextColor)(var_ch, *0x4622bc);\n            }\n            (*_sym.imp.USER32.dll_DrawTextA)(var_ch, &stack0xffffffcc, 0xffffffff, noname_2, uVar2);\n            if ((var_14h_2 & 0x8000000) != 0) {\n                (*_sym.imp.GDI32.dll_SetTextColor)(var_ch, crColor);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 638
    },
    "00422680": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint fcn.00422680(uint param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint unaff_ESI;\n    \n    if (param_2 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"KERNEL32.DLL\");\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"DisableThreadLibraryCalls\");\n        if (pcVar2 != NULL) {\n            (*pcVar2)(unaff_ESI);\n        }\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x462260);\n        *0x462298 = unaff_ESI;\n        *0x46229c = unaff_ESI;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n        *0x4622a0 = CONCAT11(uVar3, uVar3 >> 8);\n        if (((uVar3 & 0x80000000) == 0) || (*0x4622a2 = 0x10,  0x35e < *0x4622a0)) {\n            *0x4622a2 = 0x20;\n        }\n        *0x462d74 = (*_sym.imp.USER32.dll_GetSystemMetrics)(7);\n        *0x462d74 = *0x462d74 + -1;\n        *0x462d78 = (*pcVar2)(8);\n        *0x462d78 = *0x462d78 + -1;\n        *0x462d7c = (*pcVar2)(4);\n        *0x462d80 = (*pcVar2)(0x1e);\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x462260);\n    }\n    return 1;\n}\n",
        "token_count": 424
    },
    "00422d75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422d75(code **param_1)\n\n{\n    *param_1 = vtable.exception.0;\n    if (param_1[2] != NULL) {\n        fcn.00425426(param_1[1]);\n    }\n    return;\n}\n",
        "token_count": 62
    },
    "00423437": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00423437(uint *param_1, char *param_2, int32_t *param_3)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint unaff_retaddr;\n    int32_t iStack16;\n    uint32_t uStack12;\n    \n    iStack16 = 0;\n    cVar1 = *param_2;\n    piVar6 = param_3;\n    do {\n        if (cVar1 == '\\0') {\n            fcn.0042a714(iStack16);\n            fcn.00411558(*param_1, unaff_retaddr, param_1);\n            fcn.0042a763(0xffffffff);\n            return;\n        }\n        if (*param_2 == '%') {\n            param_2 = fcn.004114cf(param_2);\n            cVar1 = *param_2;\n            if (cVar1 == '%') goto code_r0x004236f2;\n            iVar7 = 0;\n            param_3 = NULL;\n            if (cVar1 == '\\0') {\ncode_r0x004234c4:\n                param_3 = fcn.004117c8(param_2);\n                while ((piVar5 = piVar6,  *param_2 != '\\0' && (iVar2 = fcn.004116ae(*param_2),  iVar2 != 0))) {\n                    param_2 = fcn.004114cf(param_2);\n                }\n            }\n            else {\n                do {\n                    if (cVar1 == '#') {\n                        iStack16 = iStack16 + 2;\n                    }\n                    else if (cVar1 == '*') {\n                        param_3 = *piVar6;\n                        piVar6 = piVar6 + 1;\n                    }\n                    else if ((((cVar1 != '-') && (cVar1 != '+')) && (cVar1 != '0')) && (cVar1 != ' ')) break;\n                    param_2 = fcn.004114cf(param_2);\n                    cVar1 = *param_2;\n                } while (cVar1 != '\\0');\n                piVar5 = piVar6;\n                if (param_3 == NULL) goto code_r0x004234c4;\n            }\n            iVar2 = 0;\n            if (*param_2 == '.') {\n                param_2 = fcn.004114cf(param_2);\n                if (*param_2 == '*') {\n                    iVar2 = *piVar5;\n                    piVar5 = piVar5 + 1;\n                    param_2 = fcn.004114cf(param_2);\n                }\n                else {\n                    iVar2 = fcn.004117c8(param_2);\n                    while ((*param_2 != '\\0' && (iVar3 = fcn.004116ae(*param_2),  iVar3 != 0))) {\n                        param_2 = fcn.004114cf(param_2);\n                    }\n                }\n            }\n            uStack12 = 0;\n            iVar3 = fcn.004115bf(param_2, 0x44a48c, 3);\n            if (iVar3 == 0) {\n                param_2 = param_2 + 3;\n                uStack12 = 0x40000;\n            }\n            else {\n                cVar1 = *param_2;\n                if (((cVar1 != 'F') && (cVar1 != 'L')) && (cVar1 != 'N')) {\n                    if (cVar1 == 'h') {\n                        uStack12 = 0x10000;\n                    }\n                    else {\n                        if (cVar1 != 'l') goto code_r0x00423596;\n                        uStack12 = 0x20000;\n                    }\n                }\n                param_2 = fcn.004114cf(param_2);\n            }\ncode_r0x00423596:\n            uVar4 = *param_2 | uStack12;\n            piVar6 = piVar5;\n            if (uVar4 < 0x10064) {\n                if ((uVar4 == 0x10063) || (uVar4 == 0x43)) {\ncode_r0x0042364e:\n                    iVar7 = 2;\n                }\n                else {\n                    if (uVar4 == 0x53) goto code_r0x0042363b;\n                    if (uVar4 == 99) goto code_r0x0042364e;\n                    if (uVar4 != 0x73) {\n                        if (uVar4 == 0x10043) goto code_r0x0042364e;\n                        if (uVar4 != 0x10053) goto code_r0x004235d7;\n                    }\ncode_r0x00423656:\n                    if (*piVar5 == 0) goto code_r0x00423660;\n                    iVar7 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*piVar5);\ncode_r0x0042366c:\n                    if (iVar7 < 1) {\n                        iVar7 = 1;\n                    }\n                    piVar6 = piVar5 + 1;\n                    if (iVar7 == 0) goto code_r0x004235d7;\n                }\ncode_r0x0042367e:\n                piVar6 = piVar5 + 1;\n                if ((iVar2 != 0) && (iVar2 <= iVar7)) {\n                    iVar7 = iVar2;\n                }\n                if (iVar7 <= param_3) {\n                    iVar7 = param_3;\n                }\n            }\n            else {\n                if (uVar4 == 0x10073) goto code_r0x00423656;\n                if (uVar4 == 0x20043) goto code_r0x0042364e;\n                if (uVar4 == 0x20053) {\ncode_r0x0042363b:\n                    if (*piVar5 != 0) {\n                        iVar7 = fcn.00411393(*piVar5);\n                        goto code_r0x0042366c;\n                    }\ncode_r0x00423660:\n                    iVar7 = 6;\n                    goto code_r0x0042367e;\n                }\n                if (uVar4 == 0x20063) goto code_r0x0042364e;\n                if (uVar4 == 0x20073) goto code_r0x0042363b;\ncode_r0x004235d7:\n                cVar1 = *param_2;\n                if (cVar1 < 'j') {\n                    if (cVar1 == 'i') goto code_r0x004236d9;\n                    if (cVar1 == 'G') goto code_r0x004236a4;\n                    if ((cVar1 == 'X') || (cVar1 == 'd')) goto code_r0x004236d9;\n                    if (cVar1 == 'e') {\ncode_r0x004236a4:\n                        piVar6 = piVar6 + 2;\n                        iVar7 = 0x80;\n                        goto code_r0x004236cb;\n                    }\n                    if (cVar1 != 'f') {\n                        if (cVar1 != 'g') goto code_r0x004236e8;\n                        goto code_r0x004236a4;\n                    }\n                    piVar6 = piVar6 + 2;\n                    iVar7 = 0x80;\n                    iVar2 = iVar2 + 0x138;\n                }\n                else {\n                    if (cVar1 == 'n') {\n                        piVar6 = piVar6 + 1;\n                        goto code_r0x004236e8;\n                    }\n                    if (cVar1 == 'o') {\ncode_r0x004236d9:\n                        if ((uStack12 & 0x40000) == 0) goto code_r0x004236c5;\n                        piVar6 = piVar6 + 2;\n                    }\n                    else {\n                        if (cVar1 != 'p') {\n                            if ((cVar1 != 'u') && (cVar1 != 'x')) goto code_r0x004236e8;\n                            goto code_r0x004236d9;\n                        }\ncode_r0x004236c5:\n                        piVar6 = piVar6 + 1;\n                    }\n                    iVar7 = 0x20;\ncode_r0x004236cb:\n                    iVar2 = param_3 + iVar2;\n                }\n                if (iVar7 <= iVar2) {\n                    iVar7 = iVar2;\n                }\n            }\ncode_r0x004236e8:\n            iStack16 = iStack16 + iVar7;\n        }\n        else {\ncode_r0x004236f2:\n            iVar7 = fcn.004115a9(param_2);\n            iStack16 = iStack16 + iVar7;\n        }\n        param_2 = fcn.004114cf(param_2);\n        cVar1 = *param_2;\n    } while( true );\n}\n",
        "token_count": 1989
    },
    "004239d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.004239d8(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint16_t *puVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (param_1 != 0) {\n        iVar4 = param_1;\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(param_1);\n        if (param_1 == 0) {\n            uVar3 = 0;\n        }\n        else {\n            uVar3 = (*pcVar1)(param_1);\n        }\n        if (puVar2 != NULL) {\n            uVar3 = (*_sym.imp.GDI32.dll_CreateDCA)(*puVar2 + puVar2, puVar2[1] + puVar2, puVar2[2] + puVar2, uVar3);\n            pcVar1 = _sym.imp.KERNEL32.dll_GlobalUnlock;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar4);\n            if (param_1 == 0) {\n                return uVar3;\n            }\n            (*pcVar1)(param_1);\n            return uVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 277
    },
    "00423ba1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00423ba1(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EDI;\n    uint uVar5;\n    \n    uVar5 = *(param_1 + 0x78);\n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar5);\n    fcn.0040ffd0(iVar3 + 1 + *(param_1 + 0x78), 0, *(param_1 + 0x7c) - (iVar3 + 1));\n    (*_sym.imp.USER32.dll_GetFocus)();\n    bVar1 = false;\n    uVar4 = fcn.004294c2();\n    *(param_1 + 0x60) = uVar4;\n    fcn.00425e5e();\n    pcVar2 = _sym.imp.USER32.dll_EnableWindow;\n    if (*(param_1 + 0x60) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x60));\n        if (iVar3 != 0) {\n            bVar1 = true;\n            (*pcVar2)(*(param_1 + 0x60), 0);\n        }\n    }\n    iVar3 = fcn.0043d6a7();\n    if ((*(param_1 + 0x92) & 8) == 0) {\n        fcn.00425e12(param_1);\n    }\n    else {\n        *(iVar3 + 0x18) = param_1;\n    }\n    if (*(param_1 + 0xa8) == 0) {\n        sub.comdlg32.dll_GetSaveFileNameA(param_1 + 0x5c);\n    }\n    else {\n        sub.comdlg32.dll_GetOpenFileNameA();\n    }\n    *(iVar3 + 0x18) = 0;\n    if (bVar1) {\n        (*pcVar2)(*(param_1 + 0x60), 1);\n    }\n    iVar3 = (*_sym.imp.USER32.dll_IsWindow)(unaff_EDI);\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n    }\n    fcn.004294fc();\n    if (unaff_EDI == 0) {\n        unaff_EDI = 2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 551
    },
    "00423c7c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.00423c7c(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = 0;\n    uVar1 = *(extraout_ECX + 0x92);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    iVar6 = extraout_ECX;\n    if (((uVar1 & 8) != 0) && (iVar2 = *(extraout_ECX + 0x1c),  iVar2 != 0)) {\n        *(unaff_EBP + -0x10) = *0x45c084;\n        pcVar4 = _sym.imp.USER32.dll_GetParent;\n        *(unaff_EBP + -4) = 0;\n        uVar5 = (*pcVar4)(iVar2);\n        iVar6 = fcn.00425960(uVar5);\n        uVar5 = fcn.0042a714(0x104);\n        pcVar3 = _sym.imp.USER32.dll_SendMessageA;\n        iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar6 + 0x1c), 0x464, 0x104, uVar5);\n        if (iVar6 < 0) {\n            fcn.0042a2e3();\n        }\n        else {\n            fcn.0042a763(iVar2, 0xffffffff);\n        }\n        if (*(*(unaff_EBP + -0x10) + -8) != 0) {\n            uVar5 = (*pcVar4)(*(*(unaff_EBP + -0x14) + 0x1c));\n            iVar6 = fcn.00425960(uVar5);\n            uVar5 = fcn.0042a714(0x104);\n            iVar6 = (*pcVar3)(*(iVar6 + 0x1c), 0x465, 0x104, uVar5);\n            if (-1 < iVar6) {\n                fcn.0042a763(0xffffffff);\n                fcn.0042a0cd(unaff_EBP + -0x10);\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.0042a358();\n                goto code_r0x00423d54;\n            }\n            fcn.0042a2e3();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042a358();\n        iVar6 = *(unaff_EBP + -0x14);\n    }\n    fcn.0042a3c6(*(iVar6 + 0x78));\ncode_r0x00423d54:\n    uVar5 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 768
    },
    "00423e95": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00423e95(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    if (arg_8h != 0) {\n        iVar2 = fcn.0043e01d(0x43b7dd);\n        if (*(iVar2 + 0x18) != 0) {\n            fcn.00428666(arg_8h);\n            *(iVar2 + 0x18) = 0;\n        }\n        pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n        if (arg_ch == 0x110) {\n            *0x46061c = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"commdlg_LBSelChangedNotify\");\n            *0x460618 = (*pcVar1)(\"commdlg_ShareViolation\");\n            *0x460614 = (*pcVar1)(\"commdlg_FileNameOK\");\n            *0x460610 = (*pcVar1)(\"commdlg_ColorOK\");\n            *0x46060c = (*pcVar1)(\"commdlg_help\");\n            *0x460608 = (*pcVar1)(\"commdlg_SetRGBColor\");\n            uVar3 = fcn.00428f94(arg_8h, 0x110, arg_10h, arg_14h);\n            return uVar3;\n        }\n        if ((arg_ch == *0x46060c) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x111, 0xe146, 0);\n            return 1;\n        }\n        if (0xbfff < arg_ch) {\n            piVar4 = fcn.00425987(arg_8h);\n            iVar2 = fcn.0042bbbf(0x44c538);\n            if ((iVar2 == 0) || ((*(piVar4 + 0x92) & 8) == 0)) {\n                if (arg_ch == *0x460618) {\n                    uVar3 = (**(*piVar4 + 0xd0))(arg_14h);\n                    return uVar3;\n                }\n                if (arg_ch == *0x460614) {\n                    if (*0x46038c != 0) {\n                        piVar4[0x7d] = arg_14h;\n                    }\n                    uVar3 = (**(*piVar4 + 0xd4))();\n                    piVar4[0x7d] = 0;\n                    return uVar3;\n                }\n                if (arg_ch == *0x46061c) {\n                    (**(*piVar4 + 0xd8))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                }\n                else if (arg_ch == *0x460610) {\n                    uVar3 = (**(*piVar4 + 0xd0))();\n                    return uVar3;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 712
    },
    "0042437c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042437c(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    iVar1 = fcn.0043d6a7();\n    iVar2 = *(iVar1 + 0xcc);\n    if (arg_8h == 0) {\n        if ((*(in_ECX + 0x24) & arg_ch) != 0) {\n            if (*(iVar1 + 0xd0) == in_ECX) {\n                fcn.00426246(1);\n            }\n            if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n                fcn.0040ffd0(&var_2ch, 0, 0x2c);\n                var_24h = *(in_ECX + 0x1c);\n                var_2ch = 0x28;\n                var_28h = 1;\n                var_20h = var_24h;\n                (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_2ch);\n            }\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) & ~arg_ch;\n        }\n    }\n    else if ((*(in_ECX + 0x24) & arg_ch) == 0) {\n        iVar2 = fcn.0043d8de();\n        *(iVar2 + 0x1034) = 0x4244af;\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) | arg_ch;\n    }\n    return 1;\n}\n",
        "token_count": 420
    },
    "00424b65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424b65(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.00424ee6(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 319
    },
    "00424fb3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424fb3(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00424ee6(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 304
    },
    "004251c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004251c5(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        fcn.00425426(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.004253fd(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.0040ffd0(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 171
    },
    "00425285": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint * __fastcall fcn.00425285(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.00424ee6(param_1 + 0x14, *(param_1 + 0x18), 0x10);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -0xc + iVar4 * 0x10;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -4;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    fcn.0040fc90(puVar3 + 2, 0x45c084, 4);\n    puVar3[3] = 0;\n    return puVar3;\n}\n",
        "token_count": 325
    },
    "0042579f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.0042579f(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h_2;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.0043e01d(0x43b7dd);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x14) = iVar1;\n    puVar4 = iVar1 + 0x34;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x34) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x3c) = *(unaff_EBP + 0x14);\n    uVar2 = *(unaff_EBP + 0x18);\n    *(iVar1 + 0x38) = iVar3;\n    *(iVar1 + 0x40) = uVar2;\n    if ((iVar3 == 2) && (arg_8h[0xd] != NULL)) {\n        (**(*arg_8h[0xd] + 0x5c))(0);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.0042562c(arg_8h, unaff_EBP + -0x24, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h + 0x98))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.0042564f(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 0x18);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x34;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 786
    },
    "004258ee": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004258ee(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = fcn.0043d904();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004253eb(0x42f5de);\n        iVar3 = fcn.004253fd(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042bff7(0x448d58, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.004253eb(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 350
    },
    "00425c1c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00425c1c(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    code *pcVar9;\n    uint32_t var_10h;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.0043e01d(0x43b7dd);\n    if (arg_8h != 3) {\n        uVar2 = (*_sym.imp.USER32.dll_CallNextHookEx)(*(var_4h + 0x2c), arg_8h, arg_ch, arg_10h);\n        return uVar2;\n    }\n    piVar1 = *(var_4h + 0x14);\n    iVar6 = *arg_10h;\n    iVar3 = fcn.0043d8de();\n    var_8h = *(iVar3 + 0x14);\n    if ((piVar1 == NULL) && (((*(iVar6 + 0x23) & 0x40) != 0 || (var_8h != 0)))) goto code_r0x00425de5;\n    if (*0x4603e0 != 0) {\n        uVar4 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe6);\n        if ((uVar4 & 0x10000) != 0) goto code_r0x00425de5;\n        puVar5 = *(iVar6 + 0x28);\n        if (puVar5 >> 0x10 == 0) {\n            var_10h = var_10h & 0xffffff00 | var_10h & puVar5 >> 0x10;\n            (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(&var_10h & 0xffff0000 | *(iVar6 + 0x28), &var_10h, 5);\n            puVar5 = &var_10h;\n        }\n        iVar6 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(puVar5, 0x449208);\n        if (iVar6 == 0) goto code_r0x00425de5;\n    }\n    if (piVar1 == NULL) {\n        iVar6 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n        pcVar9 = _sym.imp.USER32.dll_GetPropA;\n        if ((iVar6 != 0) && (iVar3 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc423\"),  iVar3 == 0)) {\n            (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc423\", iVar6);\n            iVar3 = (*pcVar9)(arg_ch, \"AfxOldWndProc423\");\n            if (iVar3 == iVar6) {\n                (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(\"AfxOldWndProc423\");\n                pcVar9 = fcn.00425ba0;\n                if (*(var_4h + 0x28) == 0) {\n                    pcVar9 = fcn.00425a41;\n                }\n                (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, pcVar9);\n            }\n        }\n        goto code_r0x00425de5;\n    }\n    fcn.004259a5(arg_ch);\n    (**(*piVar1 + 0x50))();\n    piVar7 = (**(*piVar1 + 0x80))();\n    iVar6 = *0x4603dc;\n    if ((((*0x46038c == 0) && (var_8h == 0)) && (*0x4603dc != 0)) &&\n       ((*(*0x4603dc + 0x20) != 0 && (var_10h = fcn.0042579f(piVar1, arg_ch, 0x36f, 0, 0),  var_10h != 0)))) {\n        iVar3 = fcn.00425a3b();\n        iVar8 = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n        (**(iVar6 + 0x20))(arg_ch, var_10h);\n        if (iVar8 != iVar3) {\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, iVar3);\ncode_r0x00425d79:\n            *piVar7 = iVar3;\n        }\n    }\n    else {\n        iVar6 = fcn.00425a3b();\n        iVar3 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, iVar6);\n        if (iVar3 != iVar6) goto code_r0x00425d79;\n    }\n    *(var_4h + 0x14) = 0;\ncode_r0x00425de5:\n    iVar6 = var_4h;\n    uVar2 = (*_sym.imp.USER32.dll_CallNextHookEx)(*(var_4h + 0x2c), 3, arg_ch, arg_10h);\n    if (var_8h != 0) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar6 + 0x2c));\n        *(iVar6 + 0x2c) = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 1277
    },
    "00425e12": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00425e12(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.0043e01d(0x43b7dd);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x2c) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.00425c1c, 0, uVar2);\n            *(iVar1 + 0x2c) = iVar3;\n            if (iVar3 == 0) {\n                fcn.00423259();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 208
    },
    "00425e5e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.00425e5e(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.0043e01d(0x43b7dd);\n    iVar2 = fcn.0043d8de();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x2c) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x2c));\n        *(iVar1 + 0x2c) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 177
    },
    "00425fd2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00425fd2(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x45ff28)) && (extraout_ECX != 0x45fee8)) &&\n       ((extraout_ECX != 0x45fea8 && (extraout_ECX != 0x45fe68)))) {\n        fcn.0042618f();\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (**(*extraout_ECX[0xd] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0xe];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428a9b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 352
    },
    "0042606c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042606c(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    \n    iVar2 = fcn.00429b18();\n    if (iVar2 == 0) goto code_r0x004260b7;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.0043d8de();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.0043d8de();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.00439e42();\n                if (iVar3 == 0) goto code_r0x004260ac;\n            }\n            fcn.00443db3(0);\n        }\ncode_r0x004260ac:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x004260b7:\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 0x50))();\n        param_1[0xc] = 0;\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    param_1[0xd] = 0;\n    if ((*(param_1 + 9) & 1) != 0) {\n        iVar2 = fcn.0043d6a7();\n        iVar2 = *(iVar2 + 0xcc);\n        if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n            fcn.0040ffd0(&var_2ch, 0, 0x2c);\n            var_24h = param_1[7];\n            var_2ch = 0x28;\n            var_28h = 1;\n            var_20h = var_24h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_2ch);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.004258c7();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0x80))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.004259de();\n    (**(*param_1 + 0xa4))();\n    return;\n}\n",
        "token_count": 734
    },
    "0042618f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042618f(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x1c) == 0) {\n        return 0;\n    }\n    fcn.004258ee(0);\n    iVar1 = fcn.0042504b(*(param_1 + 0x1c));\n    if (*(param_1 + 0x38) == NULL) {\n        uVar2 = (*_sym.imp.USER32.dll_DestroyWindow)(*(param_1 + 0x1c));\n    }\n    else {\n        uVar2 = (**(**(param_1 + 0x38) + 0x50))();\n    }\n    if (iVar1 == 0) {\n        fcn.004259de();\n    }\n    return uVar2;\n}\n",
        "token_count": 190
    },
    "00426246": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00426246(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    \n    iVar4 = fcn.0043d6a7();\n    if ((*(iVar4 + 0xcc) != 0) && (iVar1 = *(*(iVar4 + 0xcc) + 0x1c),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar1, 0x401, 0, 0);\n    }\n    piVar2 = *(iVar4 + 0x108);\n    if ((param_1 != 0) && (piVar2 != NULL)) {\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n        if (-1 < iVar3) {\n            (**(*piVar2 + 0xdc))(0xffffffff);\n        }\n    }\n    return;\n}\n",
        "token_count": 214
    },
    "00426766": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00426766(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 167
    },
    "004267ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_60h\n\nuint __cdecl fcn.004267ea(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    uint8_t uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t *arg_8h_00;\n    uint *puVar7;\n    uint *puVar8;\n    uint32_t uVar9;\n    code *pcVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    uint uVar12;\n    uint var_60h;\n    uint var_44h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = 0;\n    iVar4 = *(unaff_EBP + 8);\n    if (iVar4 == 0x111) {\n        iVar4 = (**(*arg_8h_00 + 0x78))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar4 != 0) {\ncode_r0x00426c40:\n            *(unaff_EBP + -0x10) = 1;\n            goto code_r0x00426c84;\n        }\ncode_r0x00426973:\n        uVar12 = 0;\n        goto code_r0x00426975;\n    }\n    if (iVar4 == 0x4e) {\n        if (**(unaff_EBP + 0x10) != 0) {\n            iVar4 = (**(*arg_8h_00 + 0x7c))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x00426843:\n            if (iVar4 != 0) goto code_r0x00426c84;\n        }\n        goto code_r0x00426973;\n    }\n    puVar7 = *(unaff_EBP + 0x10);\n    if (iVar4 == 6) {\n        uVar12 = fcn.00425960(puVar7);\n        fcn.004256c8(arg_8h_00, *(unaff_EBP + 0xc), uVar12);\n    }\n    iVar11 = puVar7;\n    if ((iVar4 == 0x20) && (iVar4 = fcn.00425729(arg_8h_00, iVar11, puVar7 >> 0x10),  iVar4 != 0))\n    goto code_r0x00426c40;\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    *(unaff_EBP + -0x14) = uVar5;\n    uVar9 = uVar5 & 0x1ff ^ *(unaff_EBP + 8) & 0x1ff;\n    fcn.0043e309(7);\n    uVar5 = *(unaff_EBP + 8);\n    iVar4 = uVar9 * 0xc;\n    iVar6 = *(unaff_EBP + -0x14);\n    if ((uVar5 != *(uVar9 * 0xc + 0x45e640)) || (iVar6 != *(iVar4 + 0x45e648))) {\n        *(iVar4 + 0x45e640) = uVar5;\n        *(iVar4 + 0x45e648) = iVar6;\n        if (iVar6 != 0) {\n            while( true ) {\n                if (uVar5 < 0xc000) {\n                    iVar6 = fcn.00426766(*(iVar6 + 4), uVar5, 0, 0);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 != 0) {\n                        *(iVar4 + 0x45e644) = iVar6;\n                        fcn.0043e379(7);\n                        iVar4 = *(unaff_EBP + 0x10);\n                        goto code_r0x00426993;\n                    }\n                }\n                else {\n                    iVar6 = fcn.00426766(*(iVar6 + 4), 0xc000, 0, 0);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 != 0) {\n                        while( true ) {\n                            if (**(iVar6 + 0x10) == *(unaff_EBP + 8)) {\n                                *(iVar4 + 0x45e644) = iVar6;\n                                fcn.0043e379(7);\n                                iVar4 = *(unaff_EBP + 0x10);\n                                goto code_r0x00426c76;\n                            }\n                            iVar6 = fcn.00426766(iVar6 + 0x18, 0xc000, 0, 0);\n                            *(unaff_EBP + 0x10) = iVar6;\n                            if (iVar6 == 0) break;\n                            iVar6 = *(unaff_EBP + 0x10);\n                        }\n                    }\n                }\n                iVar6 = **(unaff_EBP + -0x14);\n                *(unaff_EBP + -0x14) = iVar6;\n                if (iVar6 == 0) break;\n                iVar6 = *(unaff_EBP + -0x14);\n                uVar5 = *(unaff_EBP + 8);\n            }\n        }\n        *(iVar4 + 0x45e644) = 0;\n        fcn.0043e379(7);\n        goto code_r0x00426973;\n    }\n    iVar4 = *(iVar4 + 0x45e644);\n    *(unaff_EBP + 0x10) = iVar4;\n    fcn.0043e379(7);\n    if (iVar4 == 0) goto code_r0x00426973;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x00426c76:\n        pcVar10 = *(iVar4 + 0x14);\ncode_r0x00426c79:\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x00426c7d;\n    }\ncode_r0x00426993:\n    iVar6 = *(unaff_EBP + 0x10);\n    pcVar10 = *(iVar4 + 0x14);\n    iVar4 = *(iVar6 + 0x10);\n    if (*(iVar6 + 8) == 0x1a) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        iVar6 = *(unaff_EBP + 0x10);\n        iVar4 = (-(uVar2 < 4) & 0xfffffff0) + 0x2f;\n    }\n    iVar3 = puVar7 >> 0x10;\n    // switch table (49 cases) at 0x426c98\n    switch(iVar4) {\n    case 1:\n        puVar7 = *(unaff_EBP + 0xc);\n        fcn.0042e764(puVar7);\n        goto code_r0x00426ace;\n    case 2:\n        puVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x00426ace;\n    case 3:\n    case 8:\n        uVar9 = puVar7 >> 0x10;\n        puVar7 = iVar11;\n        uVar5 = *(unaff_EBP + 0xc);\n        uVar9 = fcn.00425960(uVar5, puVar7, uVar9);\n        goto code_r0x00426ae9;\n    case 4:\n        fcn.0042e6c2();\n        uVar12 = puVar7[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar12;\n        fcn.0042553f();\n        uVar12 = *puVar7;\n        uVar1 = puVar7[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x44) = uVar12;\n        iVar4 = fcn.00425987(uVar12);\n        if (iVar4 == 0) {\n            if ((arg_8h_00[0xd] != 0) && (iVar4 = fcn.0042504b(*(unaff_EBP + -0x44)),  iVar4 != 0)) {\n                *(unaff_EBP + -0x28) = iVar4;\n            }\n            iVar4 = unaff_EBP + -0x60;\n        }\n        uVar12 = (*pcVar10)(unaff_EBP + -0x24, iVar4, uVar1);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x44) = 0;\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x10) = uVar12;\n        fcn.00425fd2();\n        *(unaff_EBP + -4) = 0xffffffff;\n        goto code_r0x00426aa4;\n    case 5:\n        fcn.0042e6c2();\n        uVar12 = puVar7[2];\n        *(unaff_EBP + -0x20) = puVar7[1];\n        *(unaff_EBP + -4) = 2;\n        uVar12 = (*pcVar10)(unaff_EBP + -0x24, uVar12);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x10) = uVar12;\ncode_r0x00426aa4:\n        fcn.0042e7e1();\n        break;\n    case 6:\n        uVar5 = fcn.00425960(puVar7, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x00426ae4;\n    case 7:\n        puVar7 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x00426c7d;\n    case 9:\n    case 0x2a:\ncode_r0x00426ace:\n        uVar12 = (*pcVar10)(puVar7);\ncode_r0x00426c81:\n        *(unaff_EBP + -0x10) = uVar12;\n        break;\n    case 10:\n    case 0x21:\n        goto code_r0x00426c79;\n    case 0xb:\n        puVar7 = fcn.0042bcc2(puVar7);\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x00426ae4:\n        uVar9 = *(unaff_EBP + 0xc);\ncode_r0x00426ae9:\n        uVar12 = (*pcVar10)(uVar9, uVar5, puVar7);\n        goto code_r0x00426c81;\n    case 0xc:\n        (*pcVar10)();\n        break;\n    case 0xd:\n        puVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x00426c0d;\n    case 0xe:\n    case 0x12:\n    case 0x25:\n    case 0x2f:\n        goto code_r0x00426bed;\n    case 0xf:\n        puVar8 = iVar3;\n        iVar4 = iVar11;\n        goto code_r0x00426bf0;\n    case 0x10:\n    case 0x11:\n        puVar8 = puVar7 >> 0x10;\n        uVar5 = puVar7 & 0xffff;\n        goto code_r0x00426c2e;\n    case 0x13:\n        puVar8 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.00425960(puVar8);\n        fcn.00425960(puVar7, uVar5);\n        uVar9 = arg_8h_00[7] == puVar7;\n        goto code_r0x00426c32;\n    case 0x14:\n        puVar7 = *(unaff_EBP + 0xc);\n        fcn.0042e764(puVar7);\n        goto code_r0x00426c0d;\n    case 0x15:\n        puVar7 = *(unaff_EBP + 0xc);\n        fcn.0042bcc2(puVar7);\n        goto code_r0x00426c0d;\n    case 0x16:\n        puVar8 = puVar7 >> 0x10;\n        uVar5 = puVar7 & 0xffff;\n        uVar9 = fcn.0042bcc2(*(unaff_EBP + 0xc), uVar5, puVar8);\n        goto code_r0x00426c32;\n    case 0x17:\n        puVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x00426b74;\n    case 0x18:\n        puVar8 = puVar7 >> 0x10;\n        uVar5 = puVar7 & 0xffff;\n        goto code_r0x00426b90;\n    case 0x19:\n        uVar5 = iVar11;\n        puVar8 = iVar3;\ncode_r0x00426b90:\n        uVar9 = fcn.00425960(*(unaff_EBP + 0xc), uVar5, puVar8);\n        goto code_r0x00426c32;\n    case 0x1a:\n        iVar4 = fcn.00425960(*(unaff_EBP + 0xc), puVar7);\n        puVar8 = puVar7;\n        goto code_r0x00426bf0;\n    case 0x1b:\n        fcn.00425960(puVar7);\ncode_r0x00426bed:\n        iVar4 = *(unaff_EBP + 0xc);\n        puVar8 = puVar7;\n        goto code_r0x00426bf0;\n    case 0x1c:\n        puVar8 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar5 = fcn.00425960(puVar7, puVar8);\n        goto code_r0x00426c1a;\n    case 0x1d:\n    case 0x1e:\n        iVar4 = *(unaff_EBP + 0xc);\n        iVar6 = *(iVar6 + 0x10);\n        *(unaff_EBP + 8) = iVar4;\n        puVar8 = *(unaff_EBP + 0xc) >> 0x10;\n        *(unaff_EBP + 0xc) = puVar8;\n        if (iVar6 == 0x1d) {\n            uVar5 = fcn.00425960(puVar7);\n            uVar9 = *(unaff_EBP + 0xc);\n            puVar8 = puVar7;\n            goto code_r0x00426c32;\n        }\ncode_r0x00426bf0:\n        (*pcVar10)(iVar4, puVar8);\n        break;\n    case 0x1f:\n    case 0x24:\n        goto code_r0x00426c0d;\n    case 0x20:\n    case 0x2b:\n        (*pcVar10)(*(unaff_EBP + 0xc), puVar7);\n        goto code_r0x00426c40;\n    case 0x22:\n        uVar5 = iVar11;\n        puVar7 = iVar3;\n        goto code_r0x00426c7d;\n    case 0x23:\n        uVar12 = (*pcVar10)();\n        goto code_r0x00426c81;\n    case 0x2c:\ncode_r0x00426b74:\n        fcn.00425960(puVar7);\ncode_r0x00426c0d:\n        (*pcVar10)(puVar7);\n        break;\n    case 0x2d:\n        uVar5 = fcn.00425960(*(unaff_EBP + 0xc), puVar7);\ncode_r0x00426c7d:\n        uVar12 = (*pcVar10)(uVar5, puVar7);\n        goto code_r0x00426c81;\n    case 0x2e:\n        iVar4 = (*pcVar10)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar7 & 0xffff, puVar7 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar4;\n        goto code_r0x00426843;\n    case 0x30:\n        uVar5 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar8 = puVar7;\ncode_r0x00426c1a:\n        uVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x00426c32;\n    case 0x31:\n        uVar5 = iVar11;\n        puVar8 = iVar3;\ncode_r0x00426c2e:\n        uVar9 = *(unaff_EBP + 0xc);\ncode_r0x00426c32:\n        (*pcVar10)(uVar9, uVar5, puVar8);\n    }\ncode_r0x00426c84:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar12 = 1;\ncode_r0x00426975:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar12;\n}\n",
        "token_count": 4114
    },
    "00426fef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00426fef(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[7] != 0)) {\n        iVar2 = (**(*param_1 + 0xb0))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.00426e8f();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.00426e8f();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 187
    },
    "004270a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004270a9(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.00425987(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0042579f(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.004270a9(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 329
    },
    "004271e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004271e6(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint unaff_ESI;\n    \n    if (param_2 == 3) {\n        fcn.004271e6(0, param_3);\n        param_2 = 1;\n    }\n    iVar1 = (**(*param_1 + 0x68))(param_2);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_ShowScrollBar)(param_1[7], param_2, unaff_ESI);\n    }\n    else {\n        fcn.00428985();\n    }\n    return;\n}\n",
        "token_count": 158
    },
    "00427229": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00427229(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (*0x460384 < 0x333) {\n        uVar1 = 0;\n    }\n    else {\n        iVar3 = param_1[7];\n        if (param_2 != 2) {\n            iVar2 = (**(*param_1 + 0x68))(param_2);\n            if (iVar2 != 0) {\n                iVar3 = *(iVar2 + 0x1c);\n                param_2 = 2;\n            }\n        }\n        *param_3 = 0x1c;\n        (*_sym.imp.USER32.dll_SetScrollInfo)(iVar3, param_2, param_3, param_4);\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 218
    },
    "00427276": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00427276(int32_t *param_1, int32_t param_2, uint *param_3, uint param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (*0x460384 < 0x333) {\n        uVar1 = 0;\n    }\n    else {\n        iVar3 = param_1[7];\n        if (param_2 != 2) {\n            iVar2 = (**(*param_1 + 0x68))(param_2);\n            if (iVar2 != 0) {\n                iVar3 = *(iVar2 + 0x1c);\n                param_2 = 2;\n            }\n        }\n        *param_3 = 0x1c;\n        param_3[1] = param_4;\n        uVar1 = (*_sym.imp.USER32.dll_GetScrollInfo)(iVar3, param_2, param_3);\n    }\n    return uVar1;\n}\n",
        "token_count": 222
    },
    "0042730a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042730a(int32_t XAmount, int32_t YAmount, int32_t arg_10h, int32_t lpClipRect)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    int32_t lpRect;\n    int32_t Y;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(in_ECX + 0x1c));\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    if (((iVar2 == 0) && (arg_10h == 0)) && (lpClipRect == 0)) {\n        uVar3 = 5;\n        iVar2 = *(in_ECX + 0x1c);\n        while( true ) {\n            iVar2 = (*pcVar1)(iVar2, uVar3);\n            if (iVar2 == 0) break;\n            (*_sym.imp.USER32.dll_GetWindowRect)(iVar2, &lpRect);\n            fcn.0042ee9c(&lpRect);\n            (*_sym.imp.USER32.dll_SetWindowPos)(iVar2, 0, lpRect + XAmount, Y + YAmount, 0, 0, 0x15);\n            uVar3 = 2;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_ScrollWindow)(*(in_ECX + 0x1c), XAmount, YAmount, arg_10h, lpClipRect);\n    }\n    if ((*(in_ECX + 0x34) != NULL) && (arg_10h == 0)) {\n        (**(**(in_ECX + 0x34) + 0x58))(XAmount, YAmount);\n    }\n    return;\n}\n",
        "token_count": 391
    },
    "004273b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004273b0(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, int32_t *lprcDst, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t in_ECX;\n    int32_t hWinPosInfo;\n    int32_t lprcSrc;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_4h = 0;\n    var_8h = arg_20h;\n    var_ch = 0;\n    var_10h = 0;\n    if (arg_1ch == NULL) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lprcSrc);\n    }\n    else {\n        lprcSrc = *arg_1ch;\n        var_1ch = arg_1ch[1];\n        var_18h = arg_1ch[2];\n        var_14h = arg_1ch[3];\n    }\n    if (arg_14h == 1) {\n        hWinPosInfo = 0;\n    }\n    else {\n        hWinPosInfo = (*_sym.imp.USER32.dll_BeginDeferWindowPos)(8);\n    }\n    for (iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(*(in_ECX + 0x1c)); iVar2 != 0;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2)) {\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        uVar3 = uVar3 & 0xffff;\n        iVar4 = fcn.00425987(iVar2);\n        iVar1 = iVar2;\n        if ((((uVar3 != arg_10h) && (iVar1 = var_4h,  arg_8h <= uVar3)) && (uVar3 <= arg_ch)) && (iVar4 != 0)) {\n            (*_sym.imp.USER32.dll_SendMessageA)(iVar2, 0x361, 0, &hWinPosInfo);\n            iVar1 = var_4h;\n        }\n        var_4h = iVar1;\n    }\n    if (arg_14h == 1) {\n        if (arg_20h == 0) {\n            lprcDst[2] = var_10h;\n            lprcDst[1] = 0;\n            *lprcDst = 0;\n            lprcDst[3] = var_ch;\n        }\n        else {\n            (*_sym.imp.USER32.dll_CopyRect)(lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        if ((arg_10h != 0) && (var_4h != 0)) {\n            piVar5 = fcn.00425960(var_4h);\n            if (arg_14h == 2) {\n                lprcSrc = lprcSrc + *lprcDst;\n                var_1ch = var_1ch + lprcDst[1];\n                var_18h = var_18h - lprcDst[2];\n                var_14h = var_14h - lprcDst[3];\n            }\n            (**(*piVar5 + 0x60))(&lprcSrc, 0);\n            fcn.004274ea(&hWinPosInfo, var_4h, &lprcSrc);\n        }\n        if (hWinPosInfo != 0) {\n            (*_sym.imp.USER32.dll_EndDeferWindowPos)(hWinPosInfo);\n        }\n    }\n    return;\n}\n",
        "token_count": 903
    },
    "004274ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004274ea(int32_t *arg_8h, uint hWnd, int32_t *lprc2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint lpRect;\n    uint var_8h;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetParent)(hWnd);\n    if ((arg_8h == NULL) || (*arg_8h != 0)) {\n        (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n        pcVar2 = _sym.imp.USER32.dll_ScreenToClient;\n        (*_sym.imp.USER32.dll_ScreenToClient)(uVar3, &lpRect);\n        (*pcVar2)(uVar3, &var_8h);\n        iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprc2);\n        if (iVar4 == 0) {\n            iVar4 = lprc2[1];\n            iVar1 = *lprc2;\n            if (arg_8h == NULL) {\n                (*_sym.imp.USER32.dll_SetWindowPos)(hWnd, 0, iVar1, iVar4, lprc2[2] - iVar1, lprc2[3] - iVar4, 0x14);\n            }\n            else {\n                iVar4 = (*_sym.imp.USER32.dll_DeferWindowPos)\n                                  (*arg_8h, hWnd, 0, iVar1, iVar4, lprc2[2] - iVar1, lprc2[3] - iVar4);\n                *arg_8h = iVar4;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 381
    },
    "00427584": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00427584(uint param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    \n    uVar1 = fcn.0042879d();\n    if (param_2 == 0) {\n        uVar1 = uVar1 & 0xfffffdff;\n    }\n    uVar2 = fcn.00428783(0, uVar1);\n    (*_sym.imp.USER32.dll_AdjustWindowRectEx)(param_1, uVar2);\n    return;\n}\n",
        "token_count": 120
    },
    "004275af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004275af(uint32_t wParam, int32_t lParam)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint hWnd;\n    \n    iVar4 = fcn.00426f12();\n    uVar7 = wParam & 0xfff0;\n    if ((uVar7 == 0xf040) || (uVar7 == 0xf050)) {\n        if (lParam != 0x75) {\n            return 0;\n        }\n        if (iVar4 == 0) {\n            return 0;\n        }\n        fcn.004289ac();\n    }\n    else {\n        if ((uVar7 != 0xf060) && (uVar7 != 0xf100)) {\n            return 0;\n        }\n        if (((uVar7 == 0xf060) || (lParam != 0)) && (iVar4 != 0)) {\n            uVar1 = *(in_ECX + 0x1c);\n            uVar5 = (*_sym.imp.USER32.dll_GetFocus)();\n            pcVar2 = _sym.imp.USER32.dll_SetActiveWindow;\n            uVar6 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(iVar4 + 0x1c));\n            fcn.00425960(uVar6);\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x1c), 0x112, wParam, lParam);\n            pcVar3 = _sym.imp.USER32.dll_IsWindow;\n            iVar4 = (*_sym.imp.USER32.dll_IsWindow)(uVar1);\n            if (iVar4 != 0) {\n                (*pcVar2)(uVar1);\n            }\n            iVar4 = (*pcVar3)(uVar5);\n            if (iVar4 != 0) {\n                (*_sym.imp.USER32.dll_SetFocus)(uVar5);\n            }\n        }\n    }\n    return 1;\n}\n",
        "token_count": 456
    },
    "00427784": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00427784(uint32_t arg_8h, uint wParam, uint lParam, int32_t *arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x38) == 0) {\n        iVar1 = fcn.004277df(arg_8h, wParam, lParam, arg_14h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), arg_8h + 0x2000, wParam, lParam);\n        if (((arg_8h < 0x132) || (0x138 < arg_8h)) || (iVar1 != 0)) {\n            if (arg_14h != NULL) {\n                *arg_14h = iVar1;\n            }\n            iVar1 = 1;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 212
    },
    "00427bfd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427bfd(int32_t hdc, uint arg_ch, int32_t arg_10h, int32_t hgdiobj, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint lpvObject;\n    uint crColor;\n    \n    if ((((hdc == 0) || (hgdiobj == 0)) || (arg_10h == 1)) || ((arg_10h == 0 || (arg_10h == 5)))) {\ncode_r0x00427c6c:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h == 2) {\n            iVar1 = fcn.0042f3d6(arg_ch, 2);\n            if (iVar1 == 0) goto code_r0x00427c6c;\n        }\n        (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0xc, &lpvObject);\n        (*_sym.imp.GDI32.dll_SetBkColor)(hdc, crColor);\n        if (arg_18h == -1) {\n            arg_18h = (*_sym.imp.USER32.dll_GetSysColor)(8);\n        }\n        (*_sym.imp.GDI32.dll_SetTextColor)(hdc, arg_18h);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 308
    },
    "00427f37": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00427f37(int16_t *arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_28h;\n    uint var_24h;\n    uint *var_20h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_SendDlgItemMessageA;\n    var_4h = 1;\n    if (arg_8h != NULL) {\n        do {\n            if (*arg_8h == 0) break;\n            iVar3 = arg_8h[1];\n            iVar1 = *(arg_8h + 2);\n            puVar5 = arg_8h + 4;\n            if (iVar3 == 0x1234) {\ncode_r0x00427f99:\n                var_24h = 0xffffffff;\n                var_28h = 1;\n                iVar3 = 0x401;\n                puVar6 = &var_28h;\n                var_20h = puVar5;\ncode_r0x00427fc7:\n                iVar4 = (*pcVar2)(*(in_ECX + 0x1c), *arg_8h, iVar3, 0, puVar6);\n                if (iVar4 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                puVar6 = puVar5;\n                if (iVar3 == 0x401) {\n                    iVar3 = 0x180;\n                    goto code_r0x00427fc7;\n                }\n                if (iVar3 == 0x403) {\n                    iVar3 = 0x143;\n                }\n                if (iVar3 == 0x401) goto code_r0x00427f99;\n                if ((iVar3 == 0x180) || (iVar3 == 0x143)) goto code_r0x00427fc7;\n            }\n            arg_8h = puVar5 + iVar1;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.004270a9(*(in_ECX + 0x1c), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 546
    },
    "00428009": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_74h\n\nvoid __cdecl fcn.00428009(uint arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_74h;\n    uint hWnd;\n    uint var_38h;\n    uint var_34h;\n    uint var_24h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00428d6e();\n    fcn.0042553f();\n    uVar1 = *(extraout_ECX + 0x1c);\n    *(unaff_EBP + -4) = 0;\n    iVar2 = (*_sym.imp.USER32.dll_GetTopWindow)(uVar1);\n    do {\n        if (iVar2 == 0) {\n            *(unaff_EBP + -4) = 0xffffffff;\n            *(unaff_EBP + -0x58) = 0;\n            fcn.00425fd2();\n            *in_FS_OFFSET = *(unaff_EBP + -0xc);\n            return;\n        }\n        *(unaff_EBP + -0x58) = iVar2;\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(iVar2);\n        *(unaff_EBP + -0x34) = uVar3 & 0xffff;\n        *(unaff_EBP + -0x24) = unaff_EBP + -0x74;\n        iVar4 = fcn.00425987(iVar2);\n        if (((iVar4 == 0) || (iVar4 = fcn.00428bcd(0, 0xbd11ffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) &&\n           (iVar4 = fcn.00428bcd(*(unaff_EBP + -0x34), 0xffffffff, unaff_EBP + -0x38, 0),  iVar4 == 0)) {\n            iVar4 = *(unaff_EBP + 0xc);\n            if (iVar4 != 0) {\n                uVar3 = (*_sym.imp.USER32.dll_SendMessageA)(*(unaff_EBP + -0x58), 0x87, 0, 0);\n                if ((uVar3 & 0x2000) != 0) {\n                    uVar3 = fcn.00428783();\n                    uVar3 = uVar3 & 0xf;\n                    if (((uVar3 != 3) && (uVar3 != 6)) && ((uVar3 != 7 && (uVar3 != 9)))) goto code_r0x004280cf;\n                }\n                iVar4 = 0;\n            }\ncode_r0x004280cf:\n            fcn.00428f33(*(unaff_EBP + 8), iVar4);\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    } while( true );\n}\n",
        "token_count": 722
    },
    "00428666": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00428666(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.004259a5(param_2);\n    if (iVar1 != 0) {\n        (**(*param_1 + 0x50))();\n        piVar2 = (**(*param_1 + 0x80))();\n        uVar3 = fcn.00425a3b();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(unaff_retaddr, 0xfffffffc, uVar3);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 193
    },
    "00428a16": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428a16(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x38) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.0042504b(uVar1);\n        if ((iVar2 != 0) && (*(iVar2 + 0x34) != NULL)) {\n            (**(**(iVar2 + 0x34) + 0x8c))(param_1);\n        }\n    }\n    return;\n}\n",
        "token_count": 154
    },
    "00428bcd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00428bcd(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar5;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.0043d8de();\n        iVar1 = (**(**(iVar1 + 0x1038) + 4))();\n        return iVar1;\n    }\n    if (arg_ch == 0xfffffffd) {\n        arg_ch = 0;\n        iVar1 = *(arg_10h + 0x30);\n        puVar2 = (**(*in_ECX + 0x2c))();\n        do {\n            if (puVar2 == NULL) {\n                return arg_ch;\n            }\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            piVar5 = puVar2[1];\n            while (((piVar5[1] != 0 && (piVar5[2] != 0)) && (arg_ch == 0))) {\n                if (arg_8h == piVar5[1]) {\n                    if (iVar1 == 0) {\n                        iVar3 = *piVar5;\n                    }\n                    else {\n                        if (*piVar5 == 0) goto code_r0x00428c70;\n                        iVar3 = fcn.00411060(iVar1, *piVar5, 0x10);\n                    }\n                    if (iVar3 == 0) {\n                        arg_ch = 1;\n                        *(arg_10h + 4) = piVar5[2];\n                    }\n                }\ncode_r0x00428c70:\n                piVar5 = piVar5 + 3;\n            }\n            puVar2 = *puVar2;\n        } while( true );\n    }\n    if (arg_ch != 0xffffffff) {\n        uVar4 = arg_ch & 0xffff;\n        arg_ch_00 = arg_ch >> 0x10;\n        arg_ch = uVar4;\n        if (arg_ch_00 != 0) goto code_r0x00428c95;\n    }\n    arg_ch_00 = 0x111;\ncode_r0x00428c95:\n    puVar2 = (**(*in_ECX + 0x28))();\n    while( true ) {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        iVar1 = fcn.00426766(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n        if (iVar1 != 0) break;\n        puVar2 = *puVar2;\n    }\n    iVar1 = fcn.00428ac6(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n    return iVar1;\n}\n",
        "token_count": 686
    },
    "0042916e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042916e(int32_t param_1, uint32_t param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EDI;\n    \n    *(param_1 + 0x40) = param_2;\n    if ((param_2 >> 0x10 == 0) && (*(param_1 + 0x3c) == 0)) {\n        *(param_1 + 0x3c) = param_2 & 0xffff;\n    }\n    iVar2 = fcn.0043d8de();\n    uVar1 = *(iVar2 + 0xc);\n    uVar3 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, param_2, 5);\n    uVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, uVar3);\n    fcn.004291bd(uVar3, unaff_EDI, uVar1);\n    return;\n}\n",
        "token_count": 227
    },
    "00429a6b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429a6b(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x98) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x98));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if (iVar2 == 0) {\n            iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0);\n            if (iVar2 != 0) {\n                if (*(in_ECX + 0x94) != 0) {\n                    fcn.0042f5a8(*(in_ECX + 0x94));\n                }\n                uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n                uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n                *(in_ECX + 0x94) = uVar3;\n                uVar3 = (*pcVar1)(uVar3);\n                iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n                if (iVar2 != 1) {\n                    fcn.0042f5a8(*(in_ECX + 0x94));\n                    *(in_ECX + 0x94) = 0;\n                }\n                sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 436
    },
    "00429b2d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.00429b2d(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.0043d8de();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.0043d6a7();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, 0x429e85, 0, uVar2);\n        *(iVar1 + 0x30) = uVar2;\n        iVar1 = fcn.0043e0b2(0x43b842);\n        if (*(iVar1 + 0x14) != 0) {\n            iVar3 = fcn.0043d8de();\n            (**(iVar1 + 0x14))(*(iVar3 + 8));\n        }\n        fcn.0043e01d(0x43cc6d);\n    }\n    return;\n}\n",
        "token_count": 236
    },
    "0042a0cd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0042a0cd(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *param_2;\n    if (*(iVar1 + -0xc) < 0) {\n        *param_1 = *0x45c084;\n        fcn.0042a4e1(*param_2);\n    }\n    else {\n        *param_1 = iVar1;\n        (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + -0xc);\n    }\n    return param_1;\n}\n",
        "token_count": 136
    },
    "0042a2e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a2e3(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*(*param_1 + -8) != 0) {\n        if (-1 < *(*param_1 + -0xc)) {\n            if (*param_1 + -0xc != *0x45c088) {\n                iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n                if (iVar1 < 1) {\n                    fcn.0042a247();\n                }\n                *param_1 = *0x45c084;\n            }\n            return;\n        }\n        fcn.0042a4e1(0x460038);\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "0042a301": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a301(int32_t *param_1)\n\n{\n    int32_t arg_ch;\n    \n    arg_ch = *param_1;\n    if (1 < *(arg_ch + -0xc)) {\n        fcn.0042a28f();\n        fcn.0042a1c5(*(arg_ch + -8));\n        fcn.0040fc90(*param_1, arg_ch, *(arg_ch + -8) + 1);\n    }\n    return;\n}\n",
        "token_count": 111
    },
    "0042a32f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a32f(int32_t *param_1, int32_t param_2)\n\n{\n    if ((1 < *(*param_1 + -0xc)) || (*(*param_1 + -4) < param_2)) {\n        fcn.0042a28f();\n        fcn.0042a1c5(param_2);\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "0042a491": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0042a491(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = *param_1;\n    iVar2 = *param_2;\n    if (iVar1 != iVar2) {\n        if (((*(iVar1 + -0xc) < 0) && (iVar1 + -0xc != *0x45c088)) || (*(iVar2 + -0xc) < 0)) {\n            fcn.0042a464(*(iVar2 + -8), iVar2);\n        }\n        else {\n            fcn.0042a28f();\n            iVar1 = *param_2;\n            *param_1 = iVar1;\n            (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(iVar1 + -0xc);\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 202
    },
    "0042a661": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a661(int32_t *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 != 0) {\n        iVar1 = *param_1;\n        if ((*(iVar1 + -0xc) < 2) && (*(iVar1 + -8) + param_2 <= *(iVar1 + -4))) {\n            fcn.0040fc90(*(iVar1 + -8) + iVar1, param_3, param_2);\n            *(*param_1 + -8) = *(*param_1 + -8) + param_2;\n            *(*(*param_1 + -8) + *param_1) = 0;\n        }\n        else {\n            fcn.0042a549(*(iVar1 + -8), iVar1, param_2, param_3);\n            fcn.0042a2c0(iVar1 + -0xc);\n        }\n    }\n    return;\n}\n",
        "token_count": 224
    },
    "0042a714": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042a714(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t arg_ch;\n    int32_t iVar1;\n    \n    arg_ch = *param_1;\n    if ((1 < *(arg_ch + -0xc)) || (*(arg_ch + -4) < param_2)) {\n        iVar1 = *(arg_ch + -8);\n        if (param_2 < iVar1) {\n            param_2 = iVar1;\n        }\n        fcn.0042a1c5(param_2);\n        fcn.0040fc90(*param_1, arg_ch, iVar1 + 1);\n        *(*param_1 + -8) = iVar1;\n        fcn.0042a2c0(arg_ch + -0xc);\n    }\n    return *param_1;\n}\n",
        "token_count": 189
    },
    "0042a84e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.0042a84e(int32_t param_1, uint param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((param_3 == 0) && (param_1 != 0)) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, param_2, 0xffffffff, param_1, param_3);\n    if (0 < iVar1) {\n        *(param_1 + -2 + iVar1 * 2) = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 143
    },
    "0042a899": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a899(int32_t *param_1)\n\n{\n    if ((0 < param_1[1]) && (param_1 != NULL)) {\n        (**(*param_1 + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 58
    },
    "0042a95c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0042a95c(int32_t param_1, uint param_2)\n\n{\n    uint arg_8h;\n    int32_t arg_10h;\n    \n    if (param_1 != 0) {\n        arg_10h = param_1;\n        arg_8h = fcn.0042aa88(param_1, param_1, param_2);\n        fcn.0042aa1d(arg_8h, param_1, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 115
    },
    "0042ad5b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042ad5b(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    pcVar1 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 1;\n    if ((pcVar1 != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.0042b033();\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 226
    },
    "0042af35": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042af35(uint lpBuffer, int32_t nNumberOfBytesToRead)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    \n    if (nNumberOfBytesToRead == 0) {\n        nNumberOfBytesToRead = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                          (*(in_ECX + 4), lpBuffer, nNumberOfBytesToRead, &nNumberOfBytesToRead, 0);\n        if (iVar1 == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n            fcn.0042a95c(uVar2);\n        }\n    }\n    return nNumberOfBytesToRead;\n}\n",
        "token_count": 174
    },
    "0042b636": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042b636(char *lpString1, uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint var_618h;\n    uint var_410h;\n    uint var_208h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString2);\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrlenA;\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString1);\n            iVar3 = (*pcVar1)(lpString2);\n            if (iVar2 != iVar3) goto code_r0x0042b6f5;\n            uVar4 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n            pcVar1 = _sym.imp.KERNEL32.dll_GetStringTypeExA;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeExA)(uVar4, 1, lpString1, 0xffffffff, &var_208h);\n            (*pcVar1)(uVar4, 4, lpString1, 0xffffffff, &var_410h);\n            (*pcVar1)(uVar4, 1, lpString2, 0xffffffff, &var_618h);\n            if (*lpString1 != '\\0') {\n                iVar2 = 0;\n                do {\n                    if (((*(&var_410h + iVar2) & 0x80) != 0) && (*(&var_208h + iVar2) != *(&var_618h + iVar2)))\n                    goto code_r0x0042b6f5;\n                    iVar2 = iVar2 + 2;\n                    lpString1 = fcn.004114cf(lpString1);\n                } while (*lpString1 != '\\0');\n            }\n        }\n        uVar4 = 1;\n    }\n    else {\ncode_r0x0042b6f5:\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 492
    },
    "0042bbd1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0042bbd1(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 != 0) {\n        iVar1 = fcn.0042bbbf(param_1);\n        if (iVar1 != 0) {\n            return param_1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 83
    },
    "0042bc50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042bc50(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = fcn.0043d904();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004253eb(0x42f5de);\n        iVar3 = fcn.004253fd(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042bff7(0x44b1b8, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.004253eb(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 350
    },
    "0042bd1f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042bd1f(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0042bcf5();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 89
    },
    "0042bd79": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042bd79(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0xb);\n    *(param_1 + 8) = uVar2;\n    uVar2 = (*pcVar1)(0xc);\n    *(param_1 + 0xc) = uVar2;\n    if (*(param_1 + 0x68) == 0) {\n        fcn.0043dacf();\n    }\n    else {\n        fcn.0043da9f();\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar2, 0x58);\n    *(param_1 + 0x18) = uVar3;\n    uVar3 = (*pcVar1)(uVar2, 0x5a);\n    *(param_1 + 0x1c) = uVar3;\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    return;\n}\n",
        "token_count": 291
    },
    "0042bdd1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042bdd1(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint var_104h;\n    uint var_4h;\n    \n    iVar1 = fcn.0042be55(arg_8h, &var_104h, 0x100);\n    if (0x100U - iVar1 < 3) {\n        iVar2 = 0x100;\n        do {\n            iVar3 = iVar2 + 0x100;\n            fcn.0042a714(iVar2 + 0xff, iVar3);\n            iVar1 = fcn.0042be55();\n            iVar2 = iVar3;\n        } while (iVar3 - iVar1 < 3);\n        fcn.0042a763(0xffffffff);\n    }\n    else {\n        fcn.0042a4e1(&var_104h);\n    }\n    return 0 < iVar1;\n}\n",
        "token_count": 215
    },
    "0042befd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042befd(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.0043d904();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (arg_8h != -1) {\n                iVar2 = fcn.00429b18();\n                if ((iVar2 != 0) && (*(iVar2 + 0x54) != NULL)) {\n                    (**(iVar2 + 0x54))(0, 0);\n                }\n            }\n            fcn.0042c11b();\n            fcn.0042c11b();\n            fcn.0042c11b();\n            fcn.0042c11b();\n            fcn.0042c11b();\n        }\n        iVar2 = fcn.0043d8de();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.0043e01d(0x43b7dd);\n        if (iVar2 != 0) {\n            if (*(iVar3 + 0xc) != 0) {\n                uVar4 = fcn.00412544(*(iVar3 + 0xc));\n                if (*(iVar2 + 0xb8) <= uVar4) goto code_r0x0042bfe8;\n            }\n            if (*(iVar2 + 0xb8) != 0) {\n                arg_8h = 0;\n                if (*(iVar3 + 0xc) != 0) {\n                    arg_8h = fcn.00412544(*(iVar3 + 0xc));\n                    fcn.00410f3f(*(iVar3 + 0xc));\n                }\n                iVar2 = fcn.0041011c(*(iVar2 + 0xb8));\n                *(iVar3 + 0xc) = iVar2;\n                if ((iVar2 == 0) && (arg_8h != 0)) {\n                    uVar5 = fcn.0041011c(arg_8h);\n                    *(iVar3 + 0xc) = uVar5;\n                }\n            }\n        }\n    }\ncode_r0x0042bfe8:\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 569
    },
    "0042c05c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.0042c05c(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_8h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if (arg_8h_00 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = fcn.0042504b(arg_8h_00);\n        if (iVar2 == 0) {\n            iVar2 = fcn.0042504b(arg_8h_00);\n            if (iVar2 == 0) {\n                uVar3 = fcn.004253eb(0x42f5de);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + 8) = uVar3;\n                iVar2 = fcn.0042bbf1();\n                if (iVar2 == 0) {\n                    fcn.00423259();\n                }\n                piVar4 = fcn.0042507e(arg_8h_00);\n                uVar3 = *(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *piVar4 = iVar2;\n                fcn.004253eb(uVar3);\n                iVar1 = *(extraout_ECX + 0x40);\n                *(iVar1 + iVar2) = arg_8h_00;\n                if (*(extraout_ECX + 0x44) == 2) {\n                    *(iVar1 + iVar2 + 4) = arg_8h_00;\n                }\n            }\n            else {\n                iVar1 = *(extraout_ECX + 0x40);\n                *(iVar1 + iVar2) = arg_8h_00;\n                if (*(extraout_ECX + 0x44) == 2) {\n                    *(iVar1 + iVar2 + 4) = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 607
    },
    "0042c11b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042c11b(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x2c) != 0);\n        while (var_8h != 0) {\n            fcn.00425110(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x40) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x44) == 2) {\n                puVar1[1] = 0;\n            }\n            if (var_4h != NULL) {\n                (**(*var_4h + 4))(1);\n            }\n        }\n        fcn.00424f5f();\n    }\n    return;\n}\n",
        "token_count": 224
    },
    "0042c3a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042c3a0(uint lpMultiByteStr, uint arg_ch)\n\n{\n    uint uVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    ushort *puVar4;\n    uint *in_ECX;\n    int32_t iVar5;\n    int16_t iVar6;\n    int32_t iVar7;\n    uint32_t arg_8h;\n    uint lpWideCharStr;\n    ushort *var_10h;\n    uint32_t var_ch;\n    uint *hMem;\n    uint32_t var_4h;\n    \n    if (in_ECX[1] == 0) {\n        uVar1 = 0;\n    }\n    else {\n        hMem = in_ECX;\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        var_4h = *(puVar2 + 2) == -1;\n        if (*(puVar2 + 2) == -1) {\n            var_ch = puVar2[3];\n        }\n        else {\n            var_ch = *puVar2;\n        }\n        var_ch = var_ch & 0x40;\n        iVar7 = (-(var_4h != 0) & 2) + 1;\n        if (var_4h == 0) {\n            *puVar2 = *puVar2 | 0x40;\n        }\n        else {\n            puVar2[3] = puVar2[3] | 0x40;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &lpWideCharStr, 0x20);\n        iVar3 = iVar7 * 2 + iVar3 * 2;\n        puVar4 = fcn.0042c223(puVar2);\n        iVar5 = 0;\n        var_10h = puVar4;\n        if (var_ch != 0) {\n            iVar5 = fcn.00411393(puVar4 + iVar7);\n            iVar5 = iVar7 * 2 + 2 + iVar5 * 2;\n        }\n        var_ch = iVar5 + 3 + puVar4 & 0xfffffffc;\n        arg_8h = puVar4 + iVar3 + 3 & 0xfffffffc;\n        if (var_4h == 0) {\n            iVar6 = *(puVar2 + 2);\n        }\n        else {\n            iVar6 = *(puVar2 + 4);\n        }\n        if ((iVar3 != iVar5) && (iVar6 != 0)) {\n            fcn.00410230(arg_8h, var_ch, puVar2 + (hMem[1] - var_ch));\n        }\n        *var_10h = arg_ch;\n        fcn.00410230(var_10h + iVar7, &lpWideCharStr, iVar3 + iVar7 * -2);\n        hMem[1] = hMem[1] + (arg_8h - var_ch);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*hMem);\n        hMem[2] = 0;\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 710
    },
    "0042c4ba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c4ba(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *lpMultiByteStr;\n    int32_t lpvObject;\n    uint var_24h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uVar4 = 10;\n    lpMultiByteStr = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x0042c52e;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        lpMultiByteStr = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x0042c52e:\n    if (arg_8h == 0) {\n        arg_8h = uVar4;\n    }\n    fcn.0042c3a0(lpMultiByteStr, arg_8h);\n    return;\n}\n",
        "token_count": 399
    },
    "0042c54b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042c54b(char *lpString, int32_t arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    char *pcVar4;\n    char *pcVar5;\n    uint var_4h;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar3 = fcn.0043ed9c(lpString, 0, 0);\n    iVar3 = iVar3 + -1;\n    pcVar5 = lpString + (iVar2 - iVar3);\n    if (arg_ch < iVar2) {\n        if (arg_ch < iVar3) {\n            if (arg_10h == 0) {\n                pcVar5 = 0x460038;\n            }\n        }\n        else {\n            pcVar4 = lpString + 2;\n            if ((*lpString == '\\\\') && (lpString[1] == '\\\\')) {\n                for (; *pcVar4 != '\\\\'; pcVar4 = fcn.004114cf(pcVar4)) {\n                }\n            }\n            if (3 < iVar2 - iVar3) {\n                do {\n                    pcVar4 = fcn.004114cf(pcVar4);\n                } while (*pcVar4 != '\\\\');\n            }\n            iVar2 = pcVar4 - lpString;\n            if (iVar2 + 5 + iVar3 <= arg_ch) {\n                while (iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar4),  arg_ch < iVar3 + 4 + iVar2) {\n                    do {\n                        pcVar4 = fcn.004114cf(pcVar4);\n                    } while (*pcVar4 != '\\\\');\n                }\n                lpString[iVar2] = '\\0';\n                pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(lpString, \"\\\\...\");\n                (*pcVar1)(lpString, pcVar4);\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, pcVar5);\n    }\n    return;\n}\n",
        "token_count": 476
    },
    "0042c844": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042c844(uint arg_8h, int32_t arg_ch, uint lpString1, int32_t arg_14h, uint arg_18h)\n\n{\n    uchar uVar1;\n    int32_t lpString;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint lpString2;\n    int32_t var_4h;\n    \n    if (*(*(*(in_ECX + 8) + arg_ch * 4) + -8) == 0) {\n        return 0;\n    }\n    var_4h = in_ECX;\n    lpString = fcn.0042a714(0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpyA)(lpString, *(*(var_4h + 8) + arg_ch * 4));\n    iVar2 = fcn.0043ed9c(lpString, 0, 0);\n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n    iVar3 = (1 - iVar2) + iVar3;\n    if (iVar3 == arg_14h) {\n        uVar1 = *(iVar3 + lpString);\n        *(arg_14h + lpString) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(lpString1, lpString);\n        *(iVar3 + lpString) = uVar1;\n        if (iVar2 == 0) {\n            fcn.0042b6f9(arg_14h + lpString, &lpString2, 0x104);\n            (*_sym.imp.KERNEL32.dll_lstrcpynA)(lpString, &lpString2, 0x104);\n            goto code_r0x0042c936;\n        }\n    }\n    if (*(var_4h + 0x18) != -1) {\n        fcn.0042b6f9(iVar3 + lpString, &lpString2, 0x104);\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(iVar3 + lpString, &lpString2, 0x104 - iVar3);\n        fcn.0042c54b(lpString, *(var_4h + 0x18), arg_18h);\n    }\ncode_r0x0042c936:\n    fcn.0042a763(0xffffffff);\n    return 1;\n}\n",
        "token_count": 534
    },
    "0042cdda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042cdda(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    fcn.0040ffd0(arg_8h, 0, 0x118);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_8h + 0x12, *(in_ECX + 0xc), 0x104);\n    if (*(in_ECX + 4) == -1) {\ncode_r0x0042ceaa:\n        uVar2 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetFileSize)(*(in_ECX + 4), 0);\n            arg_8h[3] = iVar1;\n            if (iVar1 != -1) {\n                if (*(*(in_ECX + 0xc) + -8) == 0) {\ncode_r0x0042ce4e:\n                    *(arg_8h + 4) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    if (iVar1 == -1) goto code_r0x0042ce4e;\n                    *(arg_8h + 4) = iVar1;\n                }\n                piVar3 = fcn.004240db(&lpCreationTime, 0xffffffff);\n                *arg_8h = *piVar3;\n                piVar3 = fcn.004240db(&lpLastAccessTime, 0xffffffff);\n                arg_8h[2] = *piVar3;\n                piVar3 = fcn.004240db(&lpLastWriteTime, 0xffffffff);\n                iVar1 = *piVar3;\n                arg_8h[1] = iVar1;\n                if (*arg_8h == 0) {\n                    *arg_8h = iVar1;\n                }\n                if (arg_8h[2] == 0) {\n                    arg_8h[2] = arg_8h[1];\n                }\n                goto code_r0x0042ceaa;\n            }\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 579
    },
    "0042ceb4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0042ceb4(uint lpFileName, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint lpFindFileData;\n    uint var_13ch;\n    uint var_134h;\n    uint var_12ch;\n    int32_t var_120h;\n    \n    iVar1 = fcn.0042b4a0(arg_ch + 0x12, lpFileName);\n    if (iVar1 == 0) {\n        *(arg_ch + 0x12) = 0;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(lpFileName, &lpFindFileData);\n        if (iVar1 != -1) {\n            (*_sym.imp.KERNEL32.dll_FindClose)(iVar1);\n            *(arg_ch + 4) = lpFindFileData & 0x7f;\n            arg_ch[3] = var_120h;\n            piVar2 = fcn.004240db(&var_13ch, 0xffffffff);\n            *arg_ch = *piVar2;\n            piVar2 = fcn.004240db(&var_134h, 0xffffffff);\n            arg_ch[2] = *piVar2;\n            piVar2 = fcn.004240db(&var_12ch, 0xffffffff);\n            iVar1 = *piVar2;\n            arg_ch[1] = iVar1;\n            if (*arg_ch == 0) {\n                *arg_ch = iVar1;\n            }\n            if (arg_ch[2] == 0) {\n                arg_ch[2] = arg_ch[1];\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 389
    },
    "0042d127": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d127(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    fcn.0042f8b4();\n    if ((*(param_1 + 0x3c) != 0) && (*(param_1 + 100) == 0)) {\n        iVar1 = fcn.0043d8de();\n        uVar3 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.USER32.dll_LoadMenuA)(uVar3, *(param_1 + 0x3c));\n        *(param_1 + 100) = uVar2;\n        uVar3 = (*_sym.imp.USER32.dll_LoadAcceleratorsA)(uVar3, *(param_1 + 0x3c));\n        *(param_1 + 0x68) = uVar3;\n    }\n    return;\n}\n",
        "token_count": 207
    },
    "0042d470": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d470(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 0x34);\n    while (iVar1 != 0) {\n        iVar1 = fcn.00424bff();\n        *(iVar1 + 0x3c) = 0;\n        iVar1 = *(param_1 + 0x34);\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "0042d4c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d4c7(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t var_8h;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        iVar1 = (**(*param_1 + 100))(&var_4h);\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n        if ((iVar1 != 0) && (iVar1 = fcn.00426e8f(),  iVar1 != 0)) {\n            *(iVar1 + 0x40) = 0xffffffff;\n        }\n    }\n    var_8h = 0;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        iVar1 = (**(*param_1 + 100))(&var_4h);\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n        if (((iVar1 != 0) && (iVar1 = fcn.00426e8f(),  iVar1 != 0)) && (*(iVar1 + 0x40) == -1)) {\n            var_8h = var_8h + 1;\n            *(iVar1 + 0x40) = var_8h;\n        }\n    }\n    iVar1 = 1;\n    var_4h = (**(*param_1 + 0x60))();\n    while (var_4h != NULL) {\n        iVar2 = (**(*param_1 + 100))(&var_4h);\n        iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar2 + 0x1c));\n        if (((iVar2 != 0) && (piVar3 = fcn.00426e8f(),  piVar3 != NULL)) && (piVar3[0x10] == iVar1)) {\n            if (var_8h == 1) {\n                piVar3[0x10] = 0;\n            }\n            (**(*piVar3 + 0xe0))(1);\n            iVar1 = iVar1 + 1;\n        }\n    }\n    return;\n}\n",
        "token_count": 544
    },
    "0042d5b4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042d5b4(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    var_4h = (**(*param_1 + 0x60))();\n    do {\n        if (var_4h == NULL) {\n            uVar2 = (**(*param_1 + 0x90))();\n            return uVar2;\n        }\n        (**(*param_1 + 100))(&var_4h);\n        iVar1 = fcn.00426e8f();\n    } while ((iVar1 == 0) || (*(iVar1 + 0x40) < 1));\n    return 1;\n}\n",
        "token_count": 172
    },
    "0042d600": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042d600(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint var_204h;\n    uint var_104h;\n    \n    fcn.0042b4a0(&var_104h, arg_8h);\n    fcn.0042a4e1(&var_104h);\n    in_ECX[0x13] = 0;\n    iVar1 = fcn.0042b6f9(&var_104h, &var_204h, 0x100);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0x50))(&var_204h);\n    }\n    if (arg_ch != 0) {\n        iVar1 = in_ECX[8];\n        iVar2 = fcn.0043d8de();\n        (**(**(iVar2 + 4) + 0x80))(iVar1);\n    }\n    return;\n}\n",
        "token_count": 230
    },
    "0042e0e7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e0e7(int32_t *arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t *in_ECX;\n    int32_t var_4h;\n    \n    var_4h = (**(*in_ECX + 0x60))();\n    while (var_4h != 0) {\n        piVar1 = (**(*in_ECX + 100))(&var_4h);\n        if (piVar1 != arg_8h) {\n            (**(*piVar1 + 0xec))(arg_8h, arg_ch, arg_10h);\n        }\n    }\n    return;\n}\n",
        "token_count": 156
    },
    "0042e3ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0042e3ca(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1 != 0) {\n        iVar1 = fcn.00426f7e();\n        if (iVar1 != 0) {\n            fcn.004289ac();\n        }\n    }\n    return;\n}\n",
        "token_count": 76
    },
    "0042e475": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0042e475(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBX;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    uVar2 = fcn.00425960(uVar2);\n    iVar3 = fcn.0042bbbf(0x44a9d8);\n    if (iVar3 != 0) {\n        if (unaff_EBX != 0) {\n            return uVar2;\n        }\n        do {\n            uVar4 = (*pcVar1)(*(param_1 + 0x1c));\n            param_1 = fcn.00425960(uVar4);\n            if (param_1 == 0) {\n                return uVar2;\n            }\n            iVar3 = (*_sym.imp.USER32.dll_IsIconic)(*(param_1 + 0x1c));\n        } while (iVar3 == 0);\n    }\n    return 0;\n}\n",
        "token_count": 260
    },
    "0042e6f2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042e6f2(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = fcn.0043d904();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004253eb(0x42f5de);\n        iVar3 = fcn.004253fd(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042bff7(0x44ab50, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.004253eb(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 353
    },
    "0042e7e1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042e7e1(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDC.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[1] != NULL) {\n        uVar1 = fcn.0042e7b0(extraout_ECX);\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 207
    },
    "0042f207": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042f207(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = fcn.0043d904();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.004253eb(0x42f5de);\n        iVar3 = fcn.004253fd(0x48);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0042bff7(0x44ab28, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.004253eb(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 348
    },
    "0042f2e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042f2e5(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.0042f2bb();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 91
    },
    "0042f3d6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042f3d6(int32_t hWnd, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint lpClassName;\n    \n    if ((hWnd != 0) && (uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar1 & 0xf) == arg_ch)) {\n        (*_sym.imp.USER32.dll_GetClassNameA)(hWnd, &lpClassName, 10);\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(&lpClassName, \"combobox\");\n        return iVar2 == 0;\n    }\n    return false;\n}\n",
        "token_count": 159
    },
    "0042fcff": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0042fcff(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x20) != 0) && ((*(extraout_ECX + 0x14) & 2) == 0)) {\n        fcn.0042fd87();\n    }\n    fcn.0042fd45();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 219
    },
    "0042fd95": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042fd95(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if (arg_ch == 0) {\n        iVar1 = 0;\n    }\n    else {\n        uVar3 = *(in_ECX + 0x28) - *(in_ECX + 0x24);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.0040fc90(arg_8h, *(in_ECX + 0x24), uVar3);\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x1c);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x20) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if (var_8h == iVar1) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    var_4h = uVar3;\n                    if (uVar3 <= *(in_ECX + 0x1c)) {\n                        var_4h = *(in_ECX + 0x1c);\n                    }\n                    var_8h = *(in_ECX + 0x2c);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x20) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x2c);\n                    *(in_ECX + 0x24) = iVar1;\n                    *(in_ECX + 0x28) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x20) + 0x50))(0, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n                    iVar1 = *(in_ECX + 0x2c);\n                    *(in_ECX + 0x24) = iVar1;\n                }\n                uVar4 = *(in_ECX + 0x28) - iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.0040fc90(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x24) = *(in_ECX + 0x24) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 871
    },
    "0042fea4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042fea4(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if (arg_ch != 0) {\n        arg_10h = *(in_ECX + 0x28) - *(in_ECX + 0x24);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.0040fc90(*(in_ECX + 0x24), arg_8h, arg_10h);\n        *(in_ECX + 0x24) = *(in_ECX + 0x24) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.0042ff34();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x1c);\n            (**(**(in_ECX + 0x20) + 0x38))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x20) + 0x50))(1, *(in_ECX + 0x1c), in_ECX + 0x2c, in_ECX + 0x28);\n                *(in_ECX + 0x24) = *(in_ECX + 0x2c);\n            }\n            fcn.0040fc90(*(in_ECX + 0x24), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x24) = *(in_ECX + 0x24) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 417
    },
    "0042ffb6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.0042ffb6(void)\n\n{\n    int32_t iVar1;\n    uint var_8ch;\n    uint var_ch;\n    uint var_8h;\n    uint hKey;\n    \n    if (*0x45e63c != 0) {\n        return *0x460604;\n    }\n    *0x45e63c = 1;\n    if (*0x460600 == 0) {\n        *0x4605fc = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"MSH_SCROLL_LINES_MSG\");\n        if (*0x4605fc == 0) {\n            *0x460600 = 1;\n            goto code_r0x00430006;\n        }\n        *0x460600 = 2;\n    }\n    if (((*0x460600 == 2) && (iVar1 = (*_sym.imp.USER32.dll_FindWindowA)(\"MouseZ\", \"Magellan MSWHEEL\"),  iVar1 != 0)) &&\n       (*0x4605fc != 0)) {\n        *0x460604 = (*_sym.imp.USER32.dll_SendMessageA)(iVar1, *0x4605fc, 0, 0);\n        return *0x460604;\n    }\ncode_r0x00430006:\n    *0x460604 = 3;\n    if (*0x46038c == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"Control Panel\\\\Desktop\", 0, 1, &hKey);\n        if (iVar1 == 0) {\n            var_8h = 0x80;\n            iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, \"WheelScrollLines\", 0, &var_ch, &var_8ch, &var_8h);\n            if (iVar1 == 0) {\n                *0x460604 = fcn.00412c06(&var_8ch, 0, 10);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n        }\n    }\n    else if (*0x460388 == 0) {\n        (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x68, 0, 0x460604, 0);\n    }\n    return *0x460604;\n}\n",
        "token_count": 518
    },
    "00430141": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430141(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t lpRect;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    if (*(in_ECX + 0x40) == -1) {\n        (**(*arg_8h + 0x34))(8);\n        (**(*arg_8h + 0x48))(&var_8h, *(in_ECX + 0x44), *(in_ECX + 0x48));\n        (**(*arg_8h + 0x40))(&var_8h, *(in_ECX + 0x4c), *(in_ECX + 0x50));\n    }\n    else {\n        (**(*arg_8h + 0x34))(*(in_ECX + 0x40));\n    }\n    iVar2 = 0;\n    var_8h = 0;\n    if (arg_8h[3] == 0) {\n        piVar1 = fcn.004303dd(&var_10h);\n        var_8h = -*piVar1;\n        iVar2 = -piVar1[1];\n        if (*(in_ECX + 100) != 0) {\n            (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n            if (*(in_ECX + 0x4c) < var_10h - lpRect) {\n                var_8h = ((var_10h - *(in_ECX + 0x4c)) - lpRect) / 2;\n            }\n            if (*(in_ECX + 0x50) < var_ch - var_14h) {\n                iVar2 = ((var_ch - *(in_ECX + 0x50)) - var_14h) / 2;\n            }\n        }\n    }\n    (**(*arg_8h + 0x38))(&var_10h, var_8h, iVar2);\n    fcn.0042e5f4(arg_8h, arg_ch);\n    return;\n}\n",
        "token_count": 503
    },
    "004302ab": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.004302ab(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    code *pcVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = *(extraout_ECX + 0x40);\n    *(extraout_ECX + 0x40) = *(unaff_EBP + 8);\n    *(extraout_ECX + 0x44) = *(unaff_EBP + 0xc);\n    *(extraout_ECX + 0x48) = *(unaff_EBP + 0x10);\n    fcn.0042f09a(0);\n    uVar2 = *(extraout_ECX + 0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.0042ea3c(uVar2);\n    pcVar5 = _sym.imp.GDI32.dll_LPtoDP;\n    uVar2 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x4c) = *(extraout_ECX + 0x44);\n    *(extraout_ECX + 0x50) = *(extraout_ECX + 0x48);\n    (*pcVar5)(uVar2, extraout_ECX + 0x4c, 1);\n    piVar1 = extraout_ECX + 0x54;\n    iVar3 = (*(unaff_EBP + 0x14))[1];\n    uVar2 = *(unaff_EBP + -0x1c);\n    *piVar1 = **(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x58) = iVar3;\n    (*pcVar5)(uVar2, piVar1, 1);\n    uVar2 = (*(unaff_EBP + 0x18))[1];\n    uVar4 = *(unaff_EBP + -0x1c);\n    *(extraout_ECX + 0x5c) = **(unaff_EBP + 0x18);\n    *(extraout_ECX + 0x60) = uVar2;\n    (*pcVar5)(uVar4, extraout_ECX + 0x5c, 1);\n    if (*(extraout_ECX + 0x50) < 0) {\n        *(extraout_ECX + 0x50) = -*(extraout_ECX + 0x50);\n    }\n    if (*(extraout_ECX + 0x58) < 0) {\n        *(extraout_ECX + 0x58) = -*(extraout_ECX + 0x58);\n    }\n    if (*(extraout_ECX + 0x60) < 0) {\n        *(extraout_ECX + 0x60) = -*(extraout_ECX + 0x60);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042f10c();\n    if (*piVar1 == 0) {\n        *piVar1 = *(extraout_ECX + 0x4c) / 10;\n    }\n    if (*(extraout_ECX + 0x58) == 0) {\n        *(extraout_ECX + 0x58) = *(extraout_ECX + 0x50) / 10;\n    }\n    if (*(extraout_ECX + 0x5c) == 0) {\n        *(extraout_ECX + 0x5c) = *piVar1 / 10;\n    }\n    if (*(extraout_ECX + 0x60) == 0) {\n        *(extraout_ECX + 0x60) = *(extraout_ECX + 0x58) / 10;\n    }\n    if (*(extraout_ECX + 0x1c) != 0) {\n        fcn.00430700();\n        if (*(unaff_EBP + -0x10) != *(extraout_ECX + 0x40)) {\n            (*_sym.imp.USER32.dll_InvalidateRect)(*(extraout_ECX + 0x1c), 0, 1);\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1072
    },
    "004303dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004303dd(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0042715b(1);\n    iVar2 = fcn.0042715b(0);\n    if (*(in_ECX + 100) != 0) {\n        (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n        if (*(in_ECX + 0x4c) < var_8h - lpRect) {\n            iVar2 = ((var_8h - *(in_ECX + 0x4c)) - lpRect) / -2;\n        }\n        if (*(in_ECX + 0x50) < var_4h - var_ch) {\n            iVar1 = ((var_4h - *(in_ECX + 0x50)) - var_ch) / -2;\n        }\n    }\n    *arg_8h = iVar2;\n    arg_8h[1] = iVar1;\n    return;\n}\n",
        "token_count": 278
    },
    "004308fc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004308fc(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.004276b3(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x68))(0);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0xbc))(CONCAT11(0xff, arg_8h), arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 149
    },
    "00430940": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430940(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((arg_10h != 0) && (iVar1 = fcn.004276b3(0),  iVar1 != 0)) {\n        return;\n    }\n    iVar1 = (**(*in_ECX + 0x68))(1);\n    if (arg_10h == iVar1) {\n        (**(*in_ECX + 0xbc))(CONCAT31(arg_8h, 0xff), arg_ch, 1);\n    }\n    return;\n}\n",
        "token_count": 149
    },
    "004309bc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004309bc(uint noname_0, uint nNumber)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    int32_t iVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar3 = fcn.00428783();\n    iVar4 = (**(*in_ECX + 0x68))(1);\n    if (((iVar4 == 0) || (iVar4 = fcn.0042896a(),  iVar4 == 0)) && ((uVar3 & 0x200000) == 0)) {\n        bVar1 = false;\n    }\n    else {\n        bVar1 = true;\n    }\n    iVar4 = (**(*in_ECX + 0x68))(0);\n    if (((iVar4 == 0) || (iVar4 = fcn.0042896a(),  iVar4 == 0)) && ((uVar3 & 0x100000) == 0)) {\n        bVar2 = false;\n    }\n    else {\n        bVar2 = true;\n    }\n    if ((bVar1) || (bVar2)) {\n        iVar4 = fcn.0042ffb6();\n        if (bVar1) {\n            iVar5 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar4, 0x78);\n            if ((iVar5 == -1) || (iVar4 == -1)) {\n                iVar6 = in_ECX[0x16];\n                if (0 < nNumber) {\n                    iVar6 = -iVar6;\n                }\n            }\n            else {\n                iVar6 = in_ECX[0x18] * iVar5;\n                if (in_ECX[0x16] <= in_ECX[0x18] * iVar5) {\n                    iVar6 = in_ECX[0x16];\n                }\n            }\n            iVar5 = *in_ECX;\n            iVar4 = 0;\n        }\n        else {\n            if (!bVar2) {\n                return 0;\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_MulDiv)(-nNumber, iVar4, 0x78);\n            if ((iVar6 == -1) || (iVar4 == -1)) {\n                iVar4 = in_ECX[0x15];\n                if (0 < nNumber) {\n                    iVar4 = -iVar4;\n                }\n            }\n            else {\n                iVar4 = in_ECX[0x17] * iVar6;\n                if (in_ECX[0x15] <= in_ECX[0x17] * iVar6) {\n                    iVar4 = in_ECX[0x15];\n                }\n            }\n            iVar5 = *in_ECX;\n            iVar6 = 0;\n        }\n        iVar4 = (**(iVar5 + 0xc0))(iVar4, iVar6, 1);\n        if (iVar4 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(in_ECX[7]);\n        }\n    }\n    else {\n        iVar4 = 0;\n    }\n    return iVar4;\n}\n",
        "token_count": 706
    },
    "00431165": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00431165(uint hModule, int32_t hResInfo, int32_t arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    uchar uVar4;\n    uchar extraout_AH;\n    int32_t iVar5;\n    int32_t *arg_ch;\n    int32_t *arg_8h;\n    uint32_t uVar6;\n    uint uVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint var_ch;\n    uint var_8h;\n    uint nIndex;\n    \n    iVar5 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if ((iVar5 != 0) && (arg_ch = (*_sym.imp.KERNEL32.dll_LockResource)(iVar5),  arg_ch != NULL)) {\n        iVar5 = *arg_ch;\n        arg_8h = fcn.0041011c(iVar5 + 0x40);\n        if (arg_8h != NULL) {\n            fcn.0040fc90(arg_8h, arg_ch, iVar5 + 0x40);\n            puVar12 = arg_8h + *arg_8h;\n            hResInfo = 0x10;\n            do {\n                iVar5 = 0;\n                puVar11 = 0x4497e8;\n                do {\n                    if (*puVar12 == *puVar11) {\n                        if (arg_10h == 0) {\n                            puVar1 = iVar5 * 8 + 0x4497ec;\n                            (*_sym.imp.USER32.dll_GetSysColor)(*(iVar5 * 8 + 0x4497ec));\n                            uVar4 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            uVar6 = (*_sym.imp.USER32.dll_GetSysColor)(*puVar1);\n                            *puVar12 = CONCAT11(uVar4, extraout_AH) << 8 | uVar6 >> 0x10 & 0xff;\n                        }\n                        else if (*(iVar5 * 8 + 0x4497ec) != 0x12) {\n                            *puVar12 = 0xffffff;\n                        }\n                        break;\n                    }\n                    puVar11 = puVar11 + 2;\n                    iVar5 = iVar5 + 1;\n                } while (puVar11 < 0x449808);\n                puVar12 = puVar12 + 1;\n                hResInfo = hResInfo + -1;\n                if (hResInfo == 0) {\n                    iVar5 = arg_8h[1];\n                    iVar2 = arg_8h[2];\n                    uVar7 = (*_sym.imp.USER32.dll_GetDC)(0);\n                    iVar8 = (*_sym.imp.GDI32.dll_CreateCompatibleBitmap)(uVar7, iVar5, iVar2);\n                    if (iVar8 != 0) {\n                        uVar9 = (*_sym.imp.GDI32.dll_CreateCompatibleDC)(uVar7);\n                        pcVar3 = _sym.imp.GDI32.dll_SelectObject;\n                        uVar10 = (*_sym.imp.GDI32.dll_SelectObject)(uVar9, iVar8);\n                        (*_sym.imp.GDI32.dll_StretchDIBits)\n                                  (uVar9, 0, 0, iVar5, iVar2, 0, 0, iVar5, iVar2, \n                                   arg_ch + (1 << (*(arg_8h + 0xe) & 0x1f)) + 10, arg_8h, 0, 0xcc0020);\n                        (*pcVar3)(uVar9, uVar10);\n                        (*_sym.imp.GDI32.dll_DeleteDC)(uVar9);\n                    }\n                    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar7);\n                    fcn.00410f3f(arg_8h);\n                    return iVar8;\n                }\n            } while( true );\n        }\n    }\n    return 0;\n}\n",
        "token_count": 899
    },
    "004323f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004323f8(int32_t arg_8h, int32_t lprcSrc)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    ushort uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    uint var_124h;\n    uint lpRect;\n    int32_t lprcDst;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n    if (*(arg_8h + 0x70) == in_ECX) {\n        if (lprcSrc == 0) {\n            return;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprcSrc);\n        if (iVar4 != 0) {\n            return;\n        }\n    }\n    if ((*(in_ECX + 0x78) != 0) && ((*(arg_8h + 0x68) & 0x40) != 0)) {\n        *(in_ECX + 100) = *(in_ECX + 100) | 0x40;\n    }\n    *(in_ECX + 100) = *(in_ECX + 100) & 0xfffffff9;\n    uVar5 = *(in_ECX + 100);\n    *(in_ECX + 100) = *(arg_8h + 100) & 6 | uVar5;\n    if ((uVar5 & 0x40) == 0) {\n        fcn.00428840(&var_124h, 0x104);\n        fcn.0042f4c0(*(in_ECX + 0x1c), &var_124h);\n    }\n    uVar5 = *(arg_8h + 100);\n    uVar2 = uVar5 >> 8;\n    uVar1 = CONCAT11((*(in_ECX + 100) >> 8 ^ uVar2) & 0xf0 ^ uVar2, uVar5);\n    if (*(in_ECX + 0x78) == 0) {\n        uVar5 = uVar5 & 0xffff0000 | uVar1 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar5 = uVar5 & 0xffff0000 | uVar1 | 0xf01;\n    }\n    fcn.0043c554(uVar5);\n    uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n    iVar4 = fcn.00432ced(uVar3);\n    if (0 < iVar4) {\n        *(*(in_ECX + 0x80) + iVar4 * 4) = arg_8h;\n    }\n    if (lprcSrc == 0) {\n        if (iVar4 < 1) {\n            fcn.00424df6(*(in_ECX + 0x84), arg_8h);\n            fcn.00424df6(*(in_ECX + 0x84), 0);\n        }\n        uVar6 = 0x115;\n        var_4h = 0;\n        var_ch = -*0x460344;\n        var_8h = 0;\n        lprcDst = -*0x460340;\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, lprcSrc);\n        fcn.0042ee9c();\n        if (iVar4 < 1) {\n            fcn.00432d78(arg_8h, lprcDst, var_ch, var_8h, var_4h, (var_8h - lprcDst) / 2 + lprcDst, \n                         (var_4h - var_ch) / 2 + var_ch);\n        }\n        uVar6 = 0x114;\n        var_4h = var_4h - var_ch;\n        var_8h = var_8h - lprcDst;\n    }\n    fcn.004288f4(0, lprcDst, var_ch, var_8h, var_4h, uVar6);\n    uVar6 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x1c));\n    iVar4 = fcn.00425960(uVar6);\n    if (iVar4 != in_ECX) {\n        if (in_ECX == 0) {\n            uVar6 = 0;\n        }\n        else {\n            uVar6 = *(in_ECX + 0x1c);\n        }\n        uVar6 = (*_sym.imp.USER32.dll_SetParent)(*(arg_8h + 0x1c), uVar6);\n        fcn.00425960(uVar6);\n    }\n    if (*(arg_8h + 0x70) != 0) {\n        fcn.00432640(arg_8h, 0xffffffff, 0);\n    }\n    *(arg_8h + 0x70) = in_ECX;\n    iVar4 = fcn.00439a92();\n    *(iVar4 + 0xb8) = *(iVar4 + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 1209
    },
    "004325df": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004325df(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 >> 0x10 != 0) {\n        param_2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_2 + 0x1c));\n        param_2 = param_2 & 0xffff;\n    }\n    iVar1 = fcn.00432ced(param_2, 0xffffffff);\n    if (0 < iVar1) {\n        fcn.00424eaf(iVar1, 1);\n        if ((*(*(param_1 + 0x80) + -4 + iVar1 * 4) == 0) && (*(*(param_1 + 0x80) + iVar1 * 4) == 0)) {\n            fcn.00424eaf(iVar1, 1);\n        }\n    }\n    return;\n}\n",
        "token_count": 209
    },
    "00432640": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00432640(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    iVar4 = arg_8h;\n    iVar2 = fcn.00432ced(arg_8h, arg_ch);\n    if (arg_10h == 1) {\n        iVar1 = in_ECX[0x20];\n        uVar3 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c));\n        *(iVar1 + iVar2 * 4) = uVar3 & 0xffff;\n        iVar4 = fcn.00432ced(iVar4, iVar2);\n        if (0 < iVar4) {\n            fcn.00424eaf();\n            if ((*(in_ECX[0x20] + -4 + iVar2 * 4) == 0) && (*(in_ECX[0x20] + iVar2 * 4) == 0)) {\n                fcn.00424eaf(iVar2, 1);\n            }\n        }\n    }\n    else {\n        fcn.00424eaf(iVar2, 1);\n        if ((*(in_ECX[0x20] + -4 + iVar2 * 4) == 0) && (*(in_ECX[0x20] + iVar2 * 4) == 0)) {\n            fcn.00424eaf(iVar2, 1);\n        }\n        if (arg_10h != -1) {\n            fcn.004325df(arg_8h);\n        }\n    }\n    if (*(arg_8h + 0x74) != 0) {\n        piVar5 = fcn.00439a92();\n        if ((in_ECX[0x1e] == 0) || (iVar4 = (**(*in_ECX + 0xe0))(),  iVar4 != 0)) {\n            piVar5[0x2e] = piVar5[0x2e] | 0xc;\n        }\n        else {\n            iVar4 = fcn.00432165();\n            if (iVar4 == 0) {\n                (**(*piVar5 + 0x58))();\n                return 1;\n            }\n            fcn.00428943(0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 557
    },
    "00432eb7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00432eb7(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(extraout_ECX + 0x68) = *(unaff_EBP + 8);\n    if (*(extraout_ECX + 0x74) == 0) {\n        iVar1 = fcn.004253fd(0xb0);\n        *(unaff_EBP + 8) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.004347de(extraout_ECX);\n        }\n        *(extraout_ECX + 0x74) = uVar2;\n    }\n    if (*(extraout_ECX + 0x20) == 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(extraout_ECX + 0x1c));\n        *(extraout_ECX + 0x20) = uVar2;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 322
    },
    "00433189": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433189(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    uint uVar3;\n    \n    if (arg_8h == 2) {\n        fcn.00426fb2();\n        if ((*(in_ECX + 0x130) & 0x40) == 0) {\n            uVar3 = 1;\n            iVar1 = 0;\n            iVar2 = 1;\n            do {\n                if (*(in_ECX + 0x150) <= iVar2) break;\n                iVar1 = fcn.00432d5c(uVar3, iVar2);\n                iVar2 = iVar2 + 1;\n            } while (iVar1 == 0);\n            (****(iVar1 + 0x74))(arg_ch, arg_10h);\n            return;\n        }\n    }\n    else if ((9 < arg_8h) && (arg_8h < 0x12)) {\n        fcn.00426fb2();\n        uVar3 = 1;\n        iVar1 = 0;\n        iVar2 = 1;\n        do {\n            if (*(in_ECX + 0x150) <= iVar2) break;\n            iVar1 = fcn.00432d5c(uVar3, iVar2);\n            iVar2 = iVar2 + 1;\n        } while (iVar1 == 0);\n        (**(**(iVar1 + 0x74) + 4))(arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    fcn.0043a5e9(arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 388
    },
    "004333b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004333b5(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint uVar6;\n    int32_t *piVar7;\n    int32_t *in_ECX;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(1);\n    if (iVar2 < 0) {\n        return;\n    }\n    iVar3 = fcn.0043d6a7();\n    var_8h = iVar3;\n    (*_sym.imp.USER32.dll_GetCursorPos)(&var_10h);\n    (*_sym.imp.USER32.dll_ScreenToClient)(in_ECX[7], &var_10h);\n    var_4h = (**(*in_ECX + 100))(var_10h, var_ch, 0);\n    if (var_4h < 0) {\n        *(iVar3 + 0x104) = 0xffffffff;\n    }\n    else {\n        iVar4 = fcn.00426f12();\n        iVar5 = fcn.00426f7e();\n        if ((iVar5 == 0) || (iVar5 = fcn.0042896a(),  iVar5 == 0)) {\n            var_4h = -1;\n        }\n        if (*(iVar3 + 0xcc) == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = *(*(iVar3 + 0xcc) + 0x1c);\n        }\n        uVar6 = (*_sym.imp.USER32.dll_GetCapture)();\n        piVar7 = fcn.00425960(uVar6);\n        if (piVar7 != in_ECX) {\n            if (piVar7 == NULL) {\n                iVar5 = 0;\n            }\n            else {\n                iVar5 = piVar7[7];\n            }\n            if ((iVar5 != iVar3) && (iVar3 = fcn.00426f12(),  iVar3 == iVar4)) {\n                var_4h = -1;\n            }\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_KillTimer;\n    if (-1 < var_4h) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &var_10h);\n        iVar3 = (*_sym.imp.USER32.dll_WindowFromPoint)(var_10h, var_ch);\n        if (iVar3 == 0) {\ncode_r0x004334c5:\n            var_4h = -1;\n            *(var_8h + 0x104) = 0xffffffff;\n        }\n        else if ((iVar3 != in_ECX[7]) && (iVar4 = (*_sym.imp.USER32.dll_IsChild)(in_ECX[7], iVar3),  iVar4 == 0)) {\n            iVar4 = *(var_8h + 0xcc);\n            if (iVar4 != 0) {\n                iVar4 = *(iVar4 + 0x1c);\n            }\n            if (iVar4 != iVar3) goto code_r0x004334c5;\n        }\n        if (-1 < var_4h) goto code_r0x004334fb;\n    }\n    if (*(var_8h + 0x104) == -1) {\n        (*pcVar1)(in_ECX[7], 0xe001);\n    }\n    (**(*in_ECX + 0xdc))(0xffffffff);\ncode_r0x004334fb:\n    if ((arg_8h == 0xe000) && ((*pcVar1)(in_ECX[7], 0xe000),  -1 < var_4h)) {\n        (**(*in_ECX + 0xdc))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 870
    },
    "00433a48": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00433a48(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    if (*(param_1 + 0x1c) != 0) {\n        iVar1 = fcn.00439aa3();\n        if (iVar1 != 0) {\n            piVar2 = fcn.00439a92();\n            (**(*piVar2 + 0x58))();\n            return;\n        }\n    }\n    fcn.0042618f();\n    return;\n}\n",
        "token_count": 122
    },
    "00433c0b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433c0b(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if ((in_ECX[0x1c] != 0) && (iVar1 = (**(*in_ECX + 100))(arg_ch, arg_10h, 0),  iVar1 == -1)) {\n        (*_sym.imp.USER32.dll_ClientToScreen)(in_ECX[7], &arg_ch);\n        (***in_ECX[0x1d])(arg_ch, arg_10h);\n        return;\n    }\n    fcn.004258c7();\n    return;\n}\n",
        "token_count": 155
    },
    "00433f63": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00433f63(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    int32_t in_ECX;\n    int32_t iVar7;\n    uint var_34h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    uint var_24h;\n    int32_t var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = *(in_ECX + 100);\n    if ((uVar1 & 0xf00) != 0) {\n        var_2ch = arg_ch[2];\n        var_28h = arg_ch[3];\n        var_20h = arg_ch[1];\n        iVar7 = arg_ch[3];\n        uVar5 = *0x46035c;\n        if (*0x46038c == 0) {\n            uVar5 = *0x460368;\n        }\n        if ((uVar1 & 0x80) != 0) {\n            var_2ch = var_2ch + -1;\n            var_28h = var_28h + -1;\n        }\n        uVar2 = uVar1 & 0x200;\n        if (uVar2 != 0) {\n            var_20h = var_20h + *0x460344;\n        }\n        uVar3 = uVar1 & 0x800;\n        if (uVar3 != 0) {\n            iVar7 = iVar7 - *0x460344;\n        }\n        uVar4 = uVar1 & 0x100;\n        if (uVar4 != 0) {\n            fcn.0043b562(0, var_20h, 1, iVar7 - var_20h, uVar5);\n        }\n        if (uVar2 != 0) {\n            fcn.0043b562(0, 0, arg_ch[2], 1, uVar5);\n        }\n        uVar6 = uVar1 & 0x400;\n        if (uVar6 != 0) {\n            fcn.0043b562(var_2ch, var_20h, 0xffffffff, iVar7 - var_20h, uVar5);\n        }\n        if (uVar3 != 0) {\n            fcn.0043b562(0, var_28h, arg_ch[2], 0xffffffff, uVar5);\n        }\n        uVar5 = *0x460360;\n        if ((uVar1 & 0x80) != 0) {\n            if (uVar4 != 0) {\n                fcn.0043b562(1, var_20h, 1, iVar7 - var_20h, *0x460360);\n            }\n            if (uVar2 != 0) {\n                fcn.0043b562(0, 1, arg_ch[2], 1, uVar5);\n            }\n            if (uVar6 != 0) {\n                fcn.0043b562(arg_ch[2], var_20h, 0xffffffff, iVar7 - var_20h, uVar5);\n            }\n            if (uVar3 != 0) {\n                fcn.0043b562(0, arg_ch[3], arg_ch[2], 0xffffffff, uVar5);\n            }\n        }\n        if (uVar4 != 0) {\n            *arg_ch = *arg_ch + *0x460340;\n        }\n        if (uVar2 != 0) {\n            arg_ch[1] = arg_ch[1] + *0x460344;\n        }\n        if (uVar6 != 0) {\n            arg_ch[2] = arg_ch[2] - *0x460340;\n        }\n        if (uVar3 != 0) {\n            arg_ch[3] = arg_ch[3] - *0x460344;\n        }\n    }\n    return;\n}\n",
        "token_count": 943
    },
    "004343e8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004343e8(uint lpText, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    uint *puVar4;\n    uint var_114h;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t hWnd;\n    \n    fcn.004343ba(0);\n    var_ch = fcn.00434560(0, &hWnd);\n    if (((var_ch == 0) || (piVar1 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0x376, 0, 0),  piVar1 == NULL)) &&\n       (piVar1 = NULL,  in_ECX != 0)) {\n        piVar1 = in_ECX + 0x9c;\n    }\n    var_8h = 0;\n    if ((piVar1 != NULL) && (var_8h = *piVar1,  arg_10h != 0)) {\n        *piVar1 = arg_10h + 0x30000;\n    }\n    if (((arg_ch & 0xf0) == 0) && ((uVar2 = arg_ch & 0xf,  uVar2 < 2 || ((2 < uVar2 && (uVar2 < 5)))))) {\n        arg_ch = arg_ch | 0x30;\n    }\n    if (in_ECX == 0) {\n        puVar4 = &var_114h;\n        (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, &var_114h, 0x104);\n    }\n    else {\n        puVar4 = *(in_ECX + 0x78);\n    }\n    uVar3 = (*_sym.imp.USER32.dll_MessageBoxA)(var_ch, lpText, puVar4, arg_ch);\n    if (piVar1 != NULL) {\n        *piVar1 = var_8h;\n    }\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    fcn.004343ba(1);\n    return uVar3;\n}\n",
        "token_count": 509
    },
    "00434608": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00434608(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    if (*(extraout_ECX + 0x80) == 0) {\n        iVar1 = fcn.004253fd(0x20);\n        *(unaff_EBP + -0x10) = iVar1;\n        *(unaff_EBP + -4) = 0;\n        if (iVar1 == 0) {\n            uVar2 = 0;\n        }\n        else {\n            uVar2 = fcn.0043e504();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(extraout_ECX + 0x80) = uVar2;\n    }\n    (**(**(extraout_ECX + 0x80) + 0xc))(*(unaff_EBP + 8));\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 284
    },
    "00434688": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00434688(uint lpAppName, uint lpValueName, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint lpString;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, 0x45ba88, arg_10h);\n        uVar1 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, &lpString, *(in_ECX + 0x90))\n        ;\n    }\n    else {\n        uVar1 = fcn.0043d0cf(lpAppName);\n        if (uVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(uVar1, lpValueName, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uVar1);\n            uVar1 = iVar2 == 0;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 258
    },
    "004346fd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004346fd(uint lpAppName, int32_t lpValueName, int32_t lpString)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, lpString, *(in_ECX + 0x90));\n        return uVar3;\n    }\n    if (lpValueName == 0) {\n        iVar1 = fcn.0043d03b();\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(iVar1, lpAppName);\n            goto code_r0x00434770;\n        }\n    }\n    else if (lpString == 0) {\n        iVar1 = fcn.0043d0cf(lpAppName);\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteValueA)(iVar1, lpValueName);\ncode_r0x00434770:\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            return iVar2 == 0;\n        }\n    }\n    else {\n        iVar1 = fcn.0043d0cf(lpAppName);\n        if (iVar1 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 1, lpString, iVar2 + 1);\n            goto code_r0x00434770;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 403
    },
    "00434bb1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434bb1(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_OffsetRect;\n    iVar4 = arg_8h - *(in_ECX + 4);\n    iVar2 = arg_ch - *(in_ECX + 8);\n    (*_sym.imp.USER32.dll_OffsetRect)(in_ECX + 0x28, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x48, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x38, iVar4, iVar2);\n    (*pcVar1)(in_ECX + 0x58, iVar4, iVar2);\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    if (*(in_ECX + 0x80) == 0) {\n        uVar3 = fcn.004353af();\n    }\n    else {\n        uVar3 = 0;\n    }\n    *(in_ECX + 0x74) = uVar3;\n    fcn.00435247(0);\n    return;\n}\n",
        "token_count": 306
    },
    "00434c61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00434c61(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    uint arg_ch;\n    uint arg_10h;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    int32_t var_4h;\n    \n    fcn.004351fe();\n    if (*(param_1 + 0x74) == 0) {\n        uVar1 = *(param_1 + 0x78);\n        if ((((uVar1 & 4) == 0) && (((uVar1 & 0xa000) == 0 || (*(param_1 + 0x7c) != 0)))) &&\n           (((uVar1 & 0x5000) == 0 || (*(param_1 + 0x7c) == 0)))) {\n            *(param_1 + 0xa8) = *(param_1 + 0x58);\n            arg_10h = *(param_1 + 0x5c);\n            uVar1 = CONCAT11(0x10, *(param_1 + 0x70) & 0x40);\n            arg_ch = *(param_1 + 0x58);\n            *(param_1 + 0xa4) = uVar1;\n            *(param_1 + 0xac) = arg_10h;\n        }\n        else {\n            *(param_1 + 0xa8) = *(param_1 + 0x48);\n            arg_10h = *(param_1 + 0x4c);\n            uVar1 = CONCAT11(0x20, *(param_1 + 0x70) & 0x40);\n            arg_ch = *(param_1 + 0x48);\n            *(param_1 + 0xa4) = uVar1;\n            *(param_1 + 0xac) = arg_10h;\n        }\n        fcn.00439c9d(*(param_1 + 0x68), arg_ch, arg_10h, uVar1);\n    }\n    else {\n        var_4h = fcn.004354c6(*(param_1 + 0x74));\n        puVar2 = param_1 + 0x38;\n        if ((*(param_1 + 0x75) & 0x50) == 0) {\n            puVar2 = param_1 + 0x28;\n        }\n        var_14h = *puVar2;\n        uStack20 = puVar2[1];\n        uStack16 = puVar2[2];\n        uStack12 = puVar2[3];\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(var_4h + 0x1c));\n        uVar1 = uVar1 & 0xffff;\n        if ((0xe81a < uVar1) && (uVar1 < 0xe81f)) {\n            *(param_1 + 0x90) = uVar1;\n            *(param_1 + 0x94) = var_14h;\n            *(param_1 + 0x98) = uStack20;\n            *(param_1 + 0x9c) = uStack16;\n            *(param_1 + 0xa0) = uStack12;\n            fcn.0042ee9c(param_1 + 0x94);\n        }\n        fcn.00439bc3(*(param_1 + 0x68), var_4h, &var_14h);\n        (**(**(param_1 + 0x6c) + 200))(1);\n    }\n    return;\n}\n",
        "token_count": 812
    },
    "00435247": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00435247(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t arg_24h;\n    int32_t in_ECX;\n    uint *puVar3;\n    uint lprc;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_14h = 1;\n    var_10h = 1;\n    uVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0);\n    var_8h = fcn.0042f279(uVar2);\n    var_ch = var_8h;\n    var_4h = fcn.0043b1eb();\n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if ((*(in_ECX + 0x74) & 0xa000) == 0) {\n        if ((*(in_ECX + 0x74) & 0x5000) == 0) {\n            var_14h = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x20);\n            var_14h = var_14h + -1;\n            var_10h = (*pcVar1)(0x21);\n            var_10h = var_10h + -1;\n            if ((((*(in_ECX + 0x78) & 0xa000) == 0) || (*(in_ECX + 0x7c) != 0)) &&\n               (((*(in_ECX + 0x78) & 0x5000) == 0 || (*(in_ECX + 0x7c) == 0)))) {\n                puVar3 = in_ECX + 0x58;\n            }\n            else {\n                puVar3 = in_ECX + 0x48;\n            }\n            lprc = *puVar3;\n            uStack36 = puVar3[1];\n            uStack32 = puVar3[2];\n            uStack28 = puVar3[3];\n            var_8h = var_4h;\n            goto code_r0x004352de;\n        }\n        puVar3 = in_ECX + 0x38;\n    }\n    else {\n        puVar3 = in_ECX + 0x28;\n    }\n    lprc = *puVar3;\n    uStack36 = puVar3[1];\n    uStack32 = puVar3[2];\n    uStack28 = puVar3[3];\ncode_r0x004352de:\n    if (arg_8h != 0) {\n        var_10h = 0;\n        var_14h = 0;\n    }\n    if ((*0x46038c != 0) && ((*(in_ECX + 0x75) & 0xf0) != 0)) {\n        (*_sym.imp.USER32.dll_InflateRect)(&lprc, 0xffffffff, 0xffffffff);\n    }\n    arg_24h = var_4h;\n    if (*(in_ECX + 0x24) == 0) {\n        arg_24h = var_ch;\n    }\n    fcn.0043b25e(&lprc, var_14h, var_10h, in_ECX + 0xc, *(in_ECX + 0x1c), *(in_ECX + 0x20), var_8h, arg_24h);\n    *(in_ECX + 0xc) = lprc;\n    *(in_ECX + 0x1c) = var_14h;\n    *(in_ECX + 0x10) = uStack36;\n    *(in_ECX + 0x14) = uStack32;\n    *(in_ECX + 0x20) = var_10h;\n    *(in_ECX + 0x18) = uStack28;\n    *(in_ECX + 0x24) = var_8h == var_4h;\n    return;\n}\n",
        "token_count": 916
    },
    "0043535d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043535d(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (*param_2 != param_3) {\n        *param_2 = param_3;\n        if ((((*(param_1 + 0x70) & 0xa000) == 0) || ((*(param_1 + 0x70) & 0x5000) == 0)) || (*(param_1 + 0x7c) == 0)) {\n            uVar1 = 0;\n        }\n        else {\n            uVar1 = 1;\n        }\n        *(param_1 + 0x7c) = uVar1;\n        if (*(param_1 + 0x80) == 0) {\n            uVar1 = fcn.004353af();\n        }\n        else {\n            uVar1 = 0;\n        }\n        *(param_1 + 0x74) = uVar1;\n        fcn.00435247(0);\n    }\n    return;\n}\n",
        "token_count": 243
    },
    "004353af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004353af(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    \n    uVar1 = 0;\n    uVar2 = *(param_1 + 0x78) & 0xa000;\n    if (*(param_1 + 0x7c) != 0) {\n        uVar2 = uVar2 == 0;\n    }\n    if ((uVar2 == 0) || ((*(param_1 + 0x70) & 0xa000) == 0)) {\n        if ((*(param_1 + 0x70) & 0x5000) == 0) goto code_r0x0043540a;\n        uVar1 = *(param_1 + 0x70) & 0xffff5fff;\n        puVar3 = param_1 + 0x38;\n    }\n    else {\n        uVar1 = *(param_1 + 0x70) & 0xffffafff;\n        puVar3 = param_1 + 0x28;\n    }\n    uVar1 = fcn.00439d9a(*puVar3, puVar3[1], puVar3[2], puVar3[3], uVar1, 0);\ncode_r0x0043540a:\n    if ((*(param_1 + 0x7c) == 0) && (uVar1 == 0)) {\n        if ((*(param_1 + 0x70) & 0xa000) != 0) {\n            fcn.00439d9a(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), \n                         *(param_1 + 0x70) & 0xffffafff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffffafff;\n            uVar1 = fcn.00439d9a(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n            if (uVar1 != 0) {\n                return uVar1;\n            }\n        }\n        if ((*(param_1 + 0x70) & 0x5000) != 0) {\n            fcn.00439d9a(*(param_1 + 0x28), *(param_1 + 0x2c), *(param_1 + 0x30), *(param_1 + 0x34), \n                         *(param_1 + 0x70) & 0xffff5fff, 0);\n            uVar2 = *(param_1 + 0x70) & 0xffff5fff;\n            uVar1 = fcn.00439d9a(*(param_1 + 0x38), *(param_1 + 0x3c), *(param_1 + 0x40), *(param_1 + 0x44), uVar2, 0);\n            uVar1 = ~-(uVar1 != uVar2) & uVar1;\n        }\n    }\n    return uVar1;\n}\n",
        "token_count": 762
    },
    "00435ab4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00435ab4(int32_t param_1)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    puVar3 = *(param_1 + 8);\n    var_4h = param_1;\n    while (puVar3 != NULL) {\n        puVar1 = *puVar3;\n        piVar2 = puVar3[2];\n        var_4h = (**(*piVar2 + 0x54))();\n        while (puVar3 = puVar1,  var_4h != 0) {\n            (**(*piVar2 + 0x58))(&var_4h);\n            iVar4 = iVar4 + 1;\n        }\n    }\n    return iVar4;\n}\n",
        "token_count": 199
    },
    "00436561": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00436561(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '0') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x004365ba;\n                if (uVar1 < ':') goto code_r0x00436598;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x00436598:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x004365c9;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x004365ba:\n            if ((*(*puVar5 + 0x462121) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x004365c9:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.0042a714(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.0042a763(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x00436637:\n            if ((*(uVar1 + 0x462121) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '0') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x00436637;\n            if (uVar2 < ':') goto code_r0x00436607;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x00436607:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 882
    },
    "00436d1b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00436d1b(int32_t param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    \n    if (*(param_1 + 0xbc) == 0) {\n        if (param_2 != NULL) {\n            *param_2 = 0;\n        }\n        iVar1 = 0;\n    }\n    else {\n        uVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0xbc), 0x229, 0, param_2);\n        iVar1 = fcn.00425960(uVar2);\n        if ((((iVar1 != 0) && (*(iVar1 + 0xc0) != 0)) && (uVar3 = fcn.00428783(),  (uVar3 & 0x10000000) == 0)) &&\n           (iVar1 = 0,  param_2 != NULL)) {\n            *param_2 = 0;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 240
    },
    "00437549": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00437549(int32_t arg_8h, int32_t arg_ch)\n\n{\n    bool bVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    in_ECX[0x30] = 0;\n    fcn.00437114(0);\n    piVar2 = fcn.00438b9d();\n    if ((arg_8h == 0) && (piVar2 != NULL)) {\n        (**(*piVar2 + 0xe4))(0, piVar2, piVar2);\n    }\n    bVar1 = false;\n    if (in_ECX[0x1a] != NULL) {\n        iVar3 = (**(*in_ECX[0x1a] + 0x5c))(arg_8h);\n        if (iVar3 != 0) {\n            bVar1 = true;\n            goto code_r0x004375b8;\n        }\n    }\n    uVar4 = 0;\n    if ((arg_8h != 0) || (arg_ch != 0)) {\n        uVar4 = 1;\n    }\n    (**(*in_ECX + 0xe0))(uVar4);\ncode_r0x004375b8:\n    if ((arg_8h != 0) && (piVar2 != NULL)) {\n        uVar4 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n        iVar3 = fcn.00425960(uVar4);\n        iVar5 = fcn.0043748e();\n        if (iVar5 == iVar3) {\n            (**(*piVar2 + 0xe4))(1, piVar2, piVar2);\n        }\n    }\n    if (!bVar1) {\n        (**(*in_ECX + 0xf8))(arg_8h, arg_ch, 0);\n        iVar3 = fcn.0043748e();\n        (*_sym.imp.USER32.dll_DrawMenuBar)(*(iVar3 + 0x1c));\n    }\n    return;\n}\n",
        "token_count": 471
    },
    "00437ead": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00437f05)\n// WARNING: Removing unreachable block (ram,0x00437f11)\n\nvoid fcn.00437ead(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    \n    uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    pcVar2 = _sym.imp.USER32.dll_GetWindow;\n    iVar4 = (*_sym.imp.USER32.dll_GetWindow)(uVar3);\n    pcVar1 = _sym.imp.USER32.dll_ShowWindow;\n    for (; iVar4 != 0; iVar4 = (*pcVar2)(iVar4, 2)) {\n        iVar5 = fcn.00425987(iVar4);\n        if ((((iVar5 != 0) && (*0x21 != iVar4)) && (iVar6 = fcn.00437d02(*0x21, iVar4),  iVar6 != 0)) &&\n           ((uVar7 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar4, 0xfffffff0),  (uVar7 & 0x18000000) == 0 &&\n            ((*(iVar5 + 0x24) & 2) != 0)))) {\n            (*pcVar1)(iVar4, 4);\n            *(iVar5 + 0x24) = *(iVar5 + 0x24) & 0xfffffffd;\n        }\n    }\n    return;\n}\n",
        "token_count": 349
    },
    "00438279": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00438279(uint arg_8h, uint lpIconName)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_58h;\n    uint var_38h;\n    int32_t lpClassName;\n    uint lpWndClass;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar1 = fcn.0043d8de();\n    iVar1 = (*_sym.imp.USER32.dll_LoadIconA)(*(iVar1 + 0xc), lpIconName);\n    if (iVar1 != 0) {\n        fcn.0040ffd0(&var_58h, 0, 0x30);\n        var_38h = arg_8h;\n        (**(*in_ECX + 0x5c))(&var_58h);\n        if (lpClassName != 0) {\n            iVar2 = fcn.0043d8de();\n            iVar2 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar2 + 8), lpClassName, &lpWndClass);\n            if ((iVar2 != 0) && (var_14h != iVar1)) {\n                uVar3 = fcn.00426584(lpWndClass, var_10h, var_ch, iVar1);\n                return uVar3;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 320
    },
    "004384c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004384c2(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t *var_4h;\n    \n    var_4h = param_1;\n    if ((param_1[0x27] != NULL) && (iVar1 = (*param_1[0x27])(param_1),  iVar1 == 0)) {\n        return;\n    }\n    piVar2 = (**(*param_1 + 0xbc))();\n    if ((piVar2 != NULL) && (iVar1 = (**(*piVar2 + 0x8c))(param_1),  iVar1 == 0)) {\n        return;\n    }\n    iVar1 = fcn.0043d8de();\n    piVar3 = *(iVar1 + 4);\n    if ((piVar3 != NULL) && (piVar3[7] == param_1)) {\n        if ((piVar2 == NULL) && (iVar1 = (**(*piVar3 + 0x88))(),  iVar1 == 0)) {\n            return;\n        }\n        fcn.00434269();\n        fcn.00434335();\n        iVar1 = fcn.00439e42();\n        if (iVar1 == 0) {\n            fcn.00439e52(0);\n            return;\n        }\n        iVar1 = fcn.0043d8de();\n        if ((*(iVar1 + 0x14) == '\\0') && (piVar3[7] == 0)) {\n            fcn.00443db3(0);\n            return;\n        }\n    }\n    if ((piVar2 != NULL) && (piVar2[0x12] != 0)) {\n        var_4h = (**(*piVar2 + 0x60))();\n        do {\n            if (var_4h == NULL) {\n                (**(*piVar2 + 0x7c))();\n                return;\n            }\n            (**(*piVar2 + 100))(&var_4h);\n            piVar3 = fcn.00426e8f();\n        } while (piVar3 == param_1);\n        (**(*piVar2 + 0x94))(param_1);\n    }\n    (**(*param_1 + 0x58))();\n    return;\n}\n",
        "token_count": 523
    },
    "004385b9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004385b9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    fcn.0043915e();\n    if (*(param_1 + 0x44) != 0) {\n        iVar2 = *(param_1 + 0x44);\n        iVar1 = (*_sym.imp.USER32.dll_GetMenu)(*(param_1 + 0x1c));\n        if (iVar1 != iVar2) {\n            (*_sym.imp.USER32.dll_SetMenu)(*(param_1 + 0x1c), iVar2);\n        }\n    }\n    iVar2 = fcn.0043d8de();\n    if ((*(iVar2 + 4) != 0) && (*(*(iVar2 + 4) + 0x1c) == param_1)) {\n        (*_sym.imp.USER32.dll_WinHelpA)(*(param_1 + 0x1c), 0, 2, 0);\n    }\n    fcn.0042604e();\n    return;\n}\n",
        "token_count": 235
    },
    "004387b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004387b5(int32_t arg_8h, int32_t *arg_ch, int32_t arg_10h)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t *in_ECX;\n    \n    fcn.004258c7();\n    uVar2 = fcn.00428783();\n    piVar5 = in_ECX;\n    if ((uVar2 & 0x40000000) == 0) {\n        piVar5 = fcn.00426fef();\n    }\n    if (arg_8h != 0) {\n        arg_ch = in_ECX;\n    }\n    if ((piVar5 == arg_ch) ||\n       ((piVar3 = fcn.00426fef(),  piVar5 == piVar3 &&\n        (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(arg_ch[7], 0x36d, 0x40, 0),  iVar4 != 0)))) {\n        bVar1 = true;\n    }\n    else {\n        bVar1 = false;\n    }\n    piVar5[9] = piVar5[9] & 0xffffffdf;\n    if (bVar1) {\n        piVar5[9] = piVar5[9] | 0x20;\n    }\n    fcn.00437ffb((-bVar1 & 0xfffffffc) + 8);\n    piVar5 = fcn.00438b9d();\n    if (piVar5 == NULL) {\n        (**(*in_ECX + 0xc0))();\n        piVar5 = fcn.00438b9d();\n        if (piVar5 == NULL) {\n            return;\n        }\n    }\n    if ((arg_8h != 0) && (arg_10h == 0)) {\n        (**(*piVar5 + 0xe4))(1, piVar5, piVar5);\n    }\n    (**(*piVar5 + 0xe8))(arg_8h);\n    return;\n}\n",
        "token_count": 472
    },
    "004388c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004388c0(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.00426fef();\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    param_2 = param_2 & 0xfff0;\n    if (*(iVar2 + 0x50) == 0) {\ncode_r0x00438949:\n        fcn.004258c7();\n    }\n    else {\n        if (param_2 < 0xf041) {\n            if (((param_2 != 0xf040) && (param_2 != 0xf000)) && (param_2 != 0xf010)) {\n                iVar2 = param_2 - 0xf020;\ncode_r0x0043890a:\n                if ((iVar2 != 0) && (iVar2 != 0x10)) goto code_r0x00438949;\n            }\n        }\n        else if ((param_2 != 0xf050) && (param_2 != 0xf060)) {\n            iVar2 = param_2 - 0xf120;\n            goto code_r0x0043890a;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x365, 0, (param_2 - 0xf000 >> 4) + 0x1ef00);\n        if (iVar2 == 0) {\n            (*pcVar1)(*(param_1 + 0x1c), 0x111, 0xe147, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 376
    },
    "00438a24": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00438a24(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int16_t iVar5;\n    uint var_108h;\n    int32_t var_4h;\n    \n    uVar4 = fcn.0043d8de();\n    pcVar3 = _sym.imp.KERNEL32.dll_GlobalGetAtomNameA;\n    iVar1 = *(uVar4 + 4);\n    if ((((iVar1 != 0) && (arg_ch != 0)) && (iVar5 = arg_ch >> 0x10,  iVar5 != 0)) &&\n       ((arg_ch == *(iVar1 + 0xb0) && (iVar5 == *(iVar1 + 0xb2))))) {\n        (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(uVar4 & 0xffff0000 | *(iVar1 + 0xb0), &var_108h, 0x103);\n        pcVar2 = _sym.imp.KERNEL32.dll_GlobalAddAtomA;\n        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(&var_108h);\n        (*pcVar3)(&var_108h & 0xffff0000 | *(iVar1 + 0xb2), &var_108h, 0x103);\n        (*pcVar2)(&var_108h);\n        (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x3e4, *(var_4h + 0x1c), *(iVar1 + 0xb0));\n    }\n    return 0;\n}\n",
        "token_count": 372
    },
    "00438ba4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00438ba4(int32_t param_1, int32_t *param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *(param_1 + 0x98);\n    if (param_2 != piVar1) {\n        *(param_1 + 0x98) = 0;\n        if (piVar1 != NULL) {\n            (**(*piVar1 + 0xe4))(0, param_2, piVar1);\n        }\n        if (((*(param_1 + 0x98) == 0) && (*(param_1 + 0x98) = param_2,  param_2 != NULL)) && (param_3 != 0)) {\n            (**(*param_2 + 0xe4))(1, param_2, piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 201
    },
    "00438c29": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438c29(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    \n    piVar1 = fcn.00439a92();\n    if (arg_10h == 0) {\n        fcn.004288f4(0, 0, 0, 0, 0, (-(arg_ch != 0) & 0xffffffc0) + 0x80 | 0x17);\n        (**(*arg_8h + 0xc4))(arg_ch);\n        if ((arg_ch != 0) || (iVar2 = fcn.00439aa3(),  iVar2 == 0)) {\n            (**(*piVar1 + 200))(0);\n        }\n    }\n    else {\n        (**(*arg_8h + 0xc4))(arg_ch);\n        piVar1[0x2e] = piVar1[0x2e] | 0xc;\n    }\n    iVar2 = fcn.00439aa3();\n    if (iVar2 == 0) {\n        return;\n    }\n    if (arg_8h[0x1c] == NULL) {\n        uVar3 = arg_ch != 0;\n    }\n    else {\n        uVar3 = (**(*arg_8h[0x1c] + 0xe0))();\n    }\n    if (uVar3 == 1) {\n        if (arg_ch != 0) {\n            piVar1[0x22] = -1;\n            if (arg_10h == 0) {\n                uVar4 = 8;\n                goto code_r0x00438ce7;\n            }\n            piVar1[0x22] = 8;\n            goto code_r0x00438d12;\n        }\n    }\n    else if (uVar3 == 0) {\n        piVar1[0x22] = -1;\n        if (arg_10h != 0) {\n            piVar1[0x22] = 0;\n            return;\n        }\n        uVar4 = 0;\ncode_r0x00438ce7:\n        fcn.00428943(uVar4);\n        return;\n    }\n    if (arg_10h != 0) {\n        return;\n    }\ncode_r0x00438d12:\n    (**(*piVar1 + 200))(0);\n    return;\n}\n",
        "token_count": 559
    },
    "00438d42": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438d42(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    int32_t in_ECX;\n    int32_t iVar8;\n    int32_t iVar9;\n    uint var_2ch;\n    uint32_t var_28h;\n    uint32_t var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0042f531(*(in_ECX + 0x1c));\n    if ((arg_10h == 0) &&\n       ((*(in_ECX + 0x68) == NULL || (iVar2 = (**(**(in_ECX + 0x68) + 0x74))(arg_8h, arg_ch, 0),  iVar2 == 0)))) {\n        fcn.00428d6e();\n        iVar2 = fcn.0043d6a7();\n        pcVar1 = _sym.imp.USER32.dll_GetMenu;\n        if ((*(iVar2 + 0x54) != *(arg_8h + 4)) &&\n           (((iVar2 = (*_sym.imp.USER32.dll_GetMenu)(*(in_ECX + 0x1c)),  iVar2 != 0 &&\n             (iVar2 = fcn.00426f12(),  iVar2 != 0)) && (iVar2 = (*pcVar1)(*(iVar2 + 0x1c)),  iVar2 != 0)))) {\n            iVar3 = (*_sym.imp.USER32.dll_GetMenuItemCount)(iVar2);\n            iVar8 = 0;\n            if (0 < iVar3) {\n                do {\n                    iVar9 = iVar8;\n                    iVar4 = (*_sym.imp.USER32.dll_GetSubMenu)(iVar2, iVar8);\n                    if (iVar4 == *(arg_8h + 4)) {\n                        fcn.0042bcc2(iVar9, iVar2);\n                        break;\n                    }\n                    iVar8 = iVar8 + 1;\n                } while (iVar8 < iVar3);\n            }\n        }\n        var_ch = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n        pcVar1 = _sym.imp.USER32.dll_GetMenuItemID;\n        var_24h = 0;\n        if (var_ch != 0) {\n            do {\n                var_28h = (*pcVar1)(*(arg_8h + 4), var_24h);\n                uVar6 = var_ch;\n                if (var_28h != 0) {\n                    if (var_28h == 0xffffffff) {\n                        uVar5 = (*_sym.imp.USER32.dll_GetSubMenu)(*(arg_8h + 4), var_24h);\n                        iVar2 = fcn.0042bcc2(uVar5);\n                        if (((iVar2 == 0) || (var_28h = (*pcVar1)(*(iVar2 + 4), 0),  var_28h == 0)) ||\n                           (var_28h == 0xffffffff)) goto code_r0x00438ead;\n                        uVar5 = 0;\n                    }\n                    else if ((*(in_ECX + 0x3c) == 0) || (0xefff < var_28h)) {\n                        uVar5 = 0;\n                    }\n                    else {\n                        uVar5 = 1;\n                    }\n                    fcn.00428f33(in_ECX, uVar5);\n                    uVar6 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(arg_8h + 4));\n                    if (uVar6 < var_ch) {\n                        var_24h = var_24h + (uVar6 - var_ch);\n                        while ((var_24h < uVar6 && (uVar7 = (*pcVar1)(*(arg_8h + 4), var_24h),  uVar7 == var_28h))) {\n                            var_24h = var_24h + 1;\n                        }\n                    }\n                }\ncode_r0x00438ead:\n                var_ch = uVar6;\n                var_24h = var_24h + 1;\n            } while (var_24h < var_ch);\n        }\n    }\n    return;\n}\n",
        "token_count": 995
    },
    "00438ec3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438ec3(uint32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    \n    iVar1 = fcn.00426fef();\n    if ((in_ECX[0x1a] != NULL) && (iVar2 = (**(*in_ECX[0x1a] + 0x7c))(arg_8h, arg_ch, arg_10h),  iVar2 != 0)) {\n        return;\n    }\n    if (arg_ch == 0xffff) {\n        in_ECX[9] = in_ECX[9] & 0xffffffbf;\n        if (*(iVar1 + 0x50) == 0) {\n            in_ECX[0x24] = 0xe001;\n        }\n        else {\n            in_ECX[0x24] = 0xe002;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(in_ECX[7], 0x362, in_ECX[0x24], 0);\n        iVar1 = (**(*in_ECX + 0xd4))();\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_UpdateWindow)(*(iVar1 + 0x1c));\n        }\n        goto code_r0x00438f9a;\n    }\n    if ((arg_8h == 0) || ((arg_ch & 0x810) != 0)) {\n        in_ECX[0x24] = 0;\n    }\n    else {\n        if ((arg_8h < 0xf000) || (0xf1ef < arg_8h)) {\n            if (0xfeff < arg_8h) {\n                in_ECX[0x24] = 0xef1f;\n                goto code_r0x00438f96;\n            }\n        }\n        else {\n            arg_8h = (arg_8h - 0xf000 >> 4) + 0xef00;\n        }\n        in_ECX[0x24] = arg_8h;\n    }\ncode_r0x00438f96:\n    *(iVar1 + 0x24) = *(iVar1 + 0x24) | 0x40;\ncode_r0x00438f9a:\n    if (in_ECX[0x24] != in_ECX[0x25]) {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(in_ECX[7]);\n        iVar1 = fcn.00425960(uVar3);\n        if (iVar1 != 0) {\n            (*_sym.imp.USER32.dll_PostMessageA)(in_ECX[7], 0x36a, 0, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 629
    },
    "0043915e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n\nvoid fcn.0043915e(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_24h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    fcn.00424add(10);\n    puVar4 = *(extraout_ECX + 0x70);\n    *(unaff_EBP + -4) = 0;\n    while (puVar4 != NULL) {\n        puVar1 = *puVar4;\n        iVar2 = (**(*puVar4[2] + 0xd0))();\n        puVar4 = puVar1;\n        if (iVar2 != 0) {\n            fcn.00424bd6();\n        }\n    }\n    puVar4 = *(unaff_EBP + -0x24);\n    while (puVar4 != NULL) {\n        puVar1 = *puVar4;\n        if (puVar4[2][0x1e] == 0) {\n            (**(*puVar4[2] + 0x58))();\n            puVar4 = puVar1;\n        }\n        else {\n            piVar3 = fcn.00426e8f();\n            (**(*piVar3 + 0x58))();\n            puVar4 = puVar1;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00424b3c();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 401
    },
    "004391e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004391e9(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    \n    if (param_2 == 0) {\ncode_r0x00439216:\n        iVar3 = 0;\n    }\n    else {\n        puVar4 = *(param_1 + 0x70);\n        do {\n            if (puVar4 == NULL) goto code_r0x00439216;\n            puVar1 = *puVar4;\n            iVar3 = puVar4[2];\n            uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(iVar3 + 0x1c));\n            puVar4 = puVar1;\n        } while ((uVar2 & 0xffff) != param_2);\n    }\n    return iVar3;\n}\n",
        "token_count": 207
    },
    "00439436": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439436(int32_t lpString2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint lpString1;\n    \n    uVar2 = fcn.00428783();\n    pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n    if ((uVar2 & 0x4000) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, *(in_ECX + 0xac));\n        pcVar1 = _sym.imp.KERNEL32.dll_lstrcatA;\n        if (lpString2 != 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcatA)(&lpString1, 0x448d50);\n            (*pcVar1)(&lpString1, lpString2);\n            if (0 < *(in_ECX + 0x40)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString1, 0x448764, *(in_ECX + 0x40));\n                (*_sym.imp.USER32.dll_wsprintfA)(&lpString1 + iVar3);\n            }\n        }\n    }\n    else {\n        lpString1._0_1_ = 0;\n        if (lpString2 != 0) {\n            (*_sym.imp.KERNEL32.dll_lstrcpyA)(&lpString1, lpString2);\n            if (0 < *(in_ECX + 0x40)) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(&lpString1, 0x448764, *(in_ECX + 0x40));\n                (*_sym.imp.USER32.dll_wsprintfA)(&lpString1 + iVar3);\n            }\n            (*pcVar1)(&lpString1, 0x448d50);\n        }\n        (*pcVar1)(&lpString1, *(in_ECX + 0xac));\n    }\n    fcn.0042f4c0(*(in_ECX + 0x1c), &lpString1);\n    return;\n}\n",
        "token_count": 473
    },
    "0043993b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043993b(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.004258c7();\n    if (param_2 != 1) {\n        (**(*param_1 + 200))(1);\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00439aa3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00439aa3(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (**(*param_1 + 0xd0))();\n    if (iVar1 != 0) {\n        return param_1[0x1e];\n    }\n    if ((param_1[0x1c] != 0) && (*(param_1[0x1c] + 0x78) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 120
    },
    "00439c9d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439c9d(int32_t arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    uint var_4h;\n    \n    if ((((*(arg_8h + 0x6c) == 0) || (iVar1 = *(arg_8h + 0x70),  iVar1 == 0)) || (*(iVar1 + 0x78) == 0)) ||\n       ((iVar2 = fcn.00432165(),  iVar2 != 1 || ((*(iVar1 + 100) & arg_14h & 0xf000) == 0)))) {\n        uVar5 = arg_14h;\n        if (((*(arg_8h + 100) & 4) != 0) && (uVar5 = arg_14h | 4,  (arg_14h & 0x5000) != 0)) {\n            uVar5 = arg_14h & 0xffff2fff | 0x2004;\n        }\n        arg_14h = uVar5;\n        piVar4 = fcn.00439acd(arg_14h);\n        fcn.004288f4(0, arg_ch, arg_10h, 0, 0, 0x15);\n        if (piVar4[8] == 0) {\n            piVar4[8] = *(arg_8h + 0x1c);\n        }\n        fcn.004286f7(0xe81f);\n        fcn.004321cd(arg_8h, 0);\n        (**(*piVar4 + 200))(1);\n        uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_8h + 0x1c), 0xfffffff0);\n        if ((uVar5 & 0x10000000) == 0) {\n            return;\n        }\n        fcn.00428943(8);\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar1 + 0x1c));\n        piVar4 = fcn.00425960(uVar3);\n        fcn.004288f4(0, arg_ch, arg_10h, 0, 0, 0x15);\n        (**(*piVar4 + 200))(1);\n    }\n    (*_sym.imp.USER32.dll_UpdateWindow)(piVar4[7]);\n    return;\n}\n",
        "token_count": 582
    },
    "00439d9a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.00439d9a(uint lprcSrc2, uint noname_1, uint noname_2, uint noname_3, uint32_t arg_18h, int32_t **arg_1ch)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    int32_t lprcSrc1;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    ppiVar3 = arg_1ch;\n    arg_18h = arg_18h & 0xf040;\n    if (arg_1ch != NULL) {\n        *arg_1ch = NULL;\n    }\n    puVar5 = *(in_ECX + 0x70);\n    do {\n        do {\n            if (puVar5 == NULL) {\n                return 0;\n            }\n            puVar1 = *puVar5;\n            piVar2 = puVar5[2];\n            iVar4 = (**(*piVar2 + 0xd0))();\n            puVar5 = puVar1;\n        } while ((((iVar4 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowVisible)(piVar2[7]),  iVar4 == 0)) ||\n                 ((piVar2[0x19] & arg_18h & 0xf000) == 0)) ||\n                ((piVar2[0x1e] != 0 && ((piVar2[0x19] & arg_18h & 0x40) == 0))));\n        (*_sym.imp.USER32.dll_GetWindowRect)(piVar2[7], &lprcSrc1);\n        if (var_8h == lprcSrc1) {\n            var_8h = var_8h + 1;\n        }\n        if (var_4h == var_ch) {\n            var_4h = var_4h + 1;\n        }\n        iVar4 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcSrc1, &lprcSrc1, &lprcSrc2);\n    } while (iVar4 == 0);\n    if (ppiVar3 != NULL) {\n        *ppiVar3 = piVar2;\n    }\n    return piVar2[0x19] & arg_18h;\n}\n",
        "token_count": 547
    },
    "0043a284": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043a284(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    uint uVar4;\n    \n    if (*0x460394 == 0) {\n        uVar2 = fcn.00428783();\n        pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n        if ((uVar2 & 0x40600) == 0) {\n            iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(6);\n            uVar4 = 5;\n        }\n        else {\n            iVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n            uVar4 = 0x20;\n        }\n        iVar3 = (*pcVar1)(uVar4, -iVar3);\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_retaddr, -iVar3);\n        if ((uVar2 & 0xc00000) != 0) {\n            *(unaff_retaddr + 4) = *(unaff_retaddr + 4) + *0x4605e4;\n        }\n    }\n    else {\n        fcn.004258c7();\n    }\n    return;\n}\n",
        "token_count": 275
    },
    "0043a2ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0043a2ea(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t in_ECX;\n    int32_t lprcSrc;\n    int32_t var_68h;\n    int32_t var_64h;\n    int32_t var_60h;\n    uint lprcDst;\n    int32_t lpRect;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t dx;\n    int32_t var_10h;\n    uint var_ch;\n    int32_t dy;\n    uint32_t var_4h;\n    \n    var_4h = fcn.00428783();\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &lpRect);\n    pcVar2 = _sym.imp.USER32.dll_GetSystemMetrics;\n    iVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n    dy = iVar4;\n    dx = (*pcVar2)(0x20);\n    pcVar1 = _sym.imp.USER32.dll_PtInRect;\n    if (*0x460394 == 0) {\n        iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, arg_8h, arg_ch);\n        if (iVar4 == 0) {\n            return 0;\n        }\n        iVar4 = (*pcVar2)(6);\n        var_10h = iVar4;\n        iVar6 = (*pcVar2)(5);\n        var_68h = var_24h;\n        lprcSrc = lpRect;\n        var_60h = var_1ch;\n        var_64h = var_20h;\n        fcn.0043a284(0, &lprcSrc);\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        iVar7 = (*pcVar1)(&lprcDst, arg_8h, arg_ch);\n        if (iVar7 != 0) {\n            return 1;\n        }\n        if ((var_4h & 0x40600) == 0) {\ncode_r0x0043a5a7:\n            var_1ch = iVar4 + *0x4605e4 + var_24h;\n            iVar4 = (*pcVar1)(&lpRect, arg_8h, arg_ch);\n            if (iVar4 == 0) {\n                return 0xfffffffe;\n            }\n            if ((arg_8h < *0x4605e0 + -2 + lpRect) && ((var_4h & 0x80000) != 0)) {\n                return 3;\n            }\n        }\n        else {\n            iVar6 = *0x4605e0 + iVar6 * -3 + dx;\n            iVar4 = dy + iVar4 * -2 + *0x4605e4;\n            if (arg_ch < var_24h + dy) {\n                if ((var_4h & 0x200) == 0) {\n                    if (lpRect + iVar6 < arg_8h) {\n                        uVar5 = ((arg_8h < var_20h - iVar6) - 1 & 2) + 0xc;\n                    }\n                    else {\ncode_r0x0043a4c5:\n                        uVar5 = 0xd;\n                    }\n                }\n                else {\n                    uVar5 = 0xc;\n                }\n            }\n            else if (arg_ch < var_1ch - dy) {\n                if (arg_8h < lpRect + dx) {\n                    if ((var_4h & 0x200) == 0) {\n                        if (arg_ch <= var_24h + iVar4) goto code_r0x0043a4c5;\n                        uVar5 = ((arg_ch < var_1ch - iVar4) - 1 & 6) + 10;\n                    }\n                    else {\n                        uVar5 = 10;\n                    }\n                }\n                else {\n                    if (arg_8h < var_20h - dx) {\n                        (*_sym.imp.USER32.dll_InflateRect)(&lpRect, -dx, -dy);\n                        iVar4 = var_10h;\n                        goto code_r0x0043a5a7;\n                    }\n                    if ((var_4h & 0x200) == 0) {\n                        if (var_24h + iVar4 < arg_ch) {\n                            uVar5 = ((arg_ch < var_1ch - iVar4) - 1 & 6) + 0xb;\n                        }\n                        else {\n                            uVar5 = 0xe;\n                        }\n                    }\n                    else {\n                        uVar5 = 0xb;\n                    }\n                }\n            }\n            else if ((var_4h & 0x200) == 0) {\n                if (lpRect + iVar6 < arg_8h) {\n                    uVar5 = ((arg_8h < var_20h - iVar6) - 1 & 2) + 0xf;\n                }\n                else {\n                    uVar5 = 0x10;\n                }\n            }\n            else {\n                uVar5 = 0xf;\n            }\n            if ((var_4h & 0x800) == 0) {\n                return uVar5;\n            }\n        }\n        return 2;\n    }\n    uVar5 = fcn.004258c7();\n    if ((*0x46038c != 0) && ((var_4h & 0x1000) != 0)) {\n        if (uVar5 == 3) {\n            uVar5 = 2;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_GetKeyState)(2);\n        if (iVar3 < 0) {\n            return 0;\n        }\n    }\n    if (((uVar5 < 10) || (0x11 < uVar5)) && (uVar5 != 4)) {\n        return uVar5;\n    }\n    if ((var_4h & 0x800) != 0) {\n        return 2;\n    }\n    (*_sym.imp.USER32.dll_InflateRect)(&lpRect, -dx, -iVar4);\n    if ((var_4h & 0x200) == 0) {\n        return uVar5;\n    }\n    if (uVar5 == 4) {\ncode_r0x0043a3e8:\n        uVar5 = (arg_ch <= var_1ch) - 1 & 4;\ncode_r0x0043a3f7:\n        uVar5 = uVar5 + 0xb;\n    }\n    else {\n        if (uVar5 == 0xd) {\n            uVar5 = (var_24h <= arg_ch) - 1 & 2;\n        }\n        else {\n            if (uVar5 == 0xe) {\n                uVar5 = arg_ch < var_24h;\n                goto code_r0x0043a3f7;\n            }\n            if (uVar5 != 0x10) {\n                if (uVar5 != 0x11) {\n                    return uVar5;\n                }\n                goto code_r0x0043a3e8;\n            }\n            uVar5 = (arg_ch <= var_1ch) - 1 & 5;\n        }\n        uVar5 = uVar5 + 10;\n    }\n    return uVar5;\n}\n",
        "token_count": 1694
    },
    "0043a5e9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043a5e9(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((*0x460394 == 0) && (param_2 == 3)) {\n        *(param_1 + 0xbc) = 1;\n        *(param_1 + 0xc0) = 1;\n        uVar1 = (*_sym.imp.USER32.dll_SetCapture)(*(param_1 + 0x1c));\n        fcn.00425960(uVar1);\n        fcn.0043a715();\n    }\n    else {\n        fcn.004258c7();\n    }\n    return;\n}\n",
        "token_count": 152
    },
    "0043ae94": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043ae94(int32_t lpRect, uint32_t dwStyle)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (*0x460394 == 0) {\n        if ((dwStyle & 0x40600) == 0) {\n            uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(6);\n            uVar3 = 5;\n        }\n        else {\n            uVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x21);\n            uVar3 = 0x20;\n        }\n        uVar2 = (*pcVar1)(uVar3, uVar2);\n        (*_sym.imp.USER32.dll_InflateRect)(lpRect, uVar2);\n        if ((dwStyle & 0xc00000) != 0) {\n            fcn.00439f01();\n            *(lpRect + 4) = *(lpRect + 4) - *0x4605e4;\n        }\n    }\n    else {\n        (*_sym.imp.USER32.dll_AdjustWindowRectEx)(lpRect, dwStyle, 0, 0x188);\n    }\n    return;\n}\n",
        "token_count": 279
    },
    "0043b0cf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b0cf(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x46034c;\n    uVar3 = *0x460348;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.0042ef7d(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, 0x9ec, uVar3);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], 0x9ec, uVar4);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 355
    },
    "0043b15d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b15d(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x46034c;\n    uVar3 = *0x460348;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.0042ef14(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, uVar3, 0x9ec);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], uVar4, 0x9ec);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 354
    },
    "0043c15a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043c15a(uint lpName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t *arg_8h;\n    uint16_t *puVar4;\n    uint32_t *puVar5;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar2 = fcn.0043d8de();\n    uVar1 = *(iVar2 + 0xc);\n    iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, lpName, 0xf1);\n    if (((iVar2 == 0) || (iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, iVar2),  iVar2 == 0)) ||\n       (iVar2 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2),  iVar2 == 0)) {\n        iVar3 = 0;\n    }\n    else {\n        arg_8h = fcn.004253fd(*(iVar2 + 6) << 2);\n        var_4h = 0;\n        if (*(iVar2 + 6) != 0) {\n            puVar4 = iVar2 + 8;\n            puVar5 = arg_8h;\n            do {\n                var_4h = var_4h + 1;\n                *puVar5 = *puVar4;\n                puVar5 = puVar5 + 1;\n                puVar4 = puVar4 + 1;\n            } while (var_4h < *(iVar2 + 6));\n        }\n        iVar3 = fcn.0043c30a(arg_8h, *(iVar2 + 6));\n        fcn.00425426(arg_8h);\n        if (iVar3 != 0) {\n            fcn.0043c0d3(*(iVar2 + 2) + 7, *(iVar2 + 4) + 7, *(iVar2 + 2), *(iVar2 + 4));\n            iVar3 = fcn.0043c21e(lpName);\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 472
    },
    "0043cf1d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_118h\n\nint32_t __cdecl fcn.0043cf1d(uint hKey, uint lpSubKey)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    int32_t iVar3;\n    uint var_118h;\n    uint var_18h;\n    uint phkResult;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(*(unaff_EBP + 8), **(unaff_EBP + 0xc), unaff_EBP + -0x14);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegEnumKeyA;\n    iVar3 = iVar2;\n    if (iVar2 == 0) {\n        do {\n            iVar2 = (*pcVar1)();\n            if (iVar2 != 0) break;\n            fcn.0042a3c6(unaff_EBP + -0x118);\n            *(unaff_EBP + -4) = 0;\n            iVar2 = fcn.0043cf1d(*(unaff_EBP + -0x14), unaff_EBP + -0x18);\n            *(unaff_EBP + -0xd) = iVar2 != 0;\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0042a358(iVar3);\n        } while (*(unaff_EBP + -0xd) == '\\0');\n        if ((iVar2 == 0x103) || (iVar2 == 0x3f2)) {\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(*(unaff_EBP + 8), **(unaff_EBP + 0xc));\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x14));\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar2;\n}\n",
        "token_count": 468
    },
    "0043d115": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043d115(uint lpAppName, uint lpValueName, int32_t nDefault)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if (*(in_ECX + 0x7c) == 0) {\n        nDefault = (*_sym.imp.KERNEL32.dll_GetPrivateProfileIntA)(lpAppName, lpValueName, nDefault, *(in_ECX + 0x90));\n    }\n    else {\n        var_4h = in_ECX;\n        iVar1 = fcn.0043d0cf(lpAppName);\n        if (iVar1 != 0) {\n            lpAppName = 4;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(iVar1, lpValueName, 0, &var_8h, &var_4h, &lpAppName);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n            if (iVar2 == 0) {\n                return var_4h;\n            }\n        }\n    }\n    return nDefault;\n}\n",
        "token_count": 262
    },
    "0043d80a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043d80a(void)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    code *pcVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.AFX_MODULE_THREAD_STATE.0;\n    puVar1 = extraout_ECX[5];\n    *(unaff_EBP + -4) = 0;\n    if (puVar1 != NULL) {\n        (***puVar1)(1);\n    }\n    if (extraout_ECX[6] != NULL) {\n        (***extraout_ECX[6])(1);\n    }\n    if (extraout_ECX[7] != NULL) {\n        (***extraout_ECX[7])(1);\n    }\n    if (extraout_ECX[8] != NULL) {\n        (***extraout_ECX[8])(1);\n    }\n    if (extraout_ECX[9] != NULL) {\n        (***extraout_ECX[9])(1);\n    }\n    pcVar3 = extraout_ECX[0xe];\n    if (pcVar3 != NULL) {\n        while (*(pcVar3 + 0xc) != 0) {\n            uVar2 = fcn.00424bff();\n            fcn.00425426(uVar2);\n            pcVar3 = extraout_ECX[0xe];\n        }\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        (**(*extraout_ECX[0xc] + 4))(1);\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (**(*extraout_ECX[0xd] + 4))(1);\n    }\n    if (extraout_ECX[0xe] != NULL) {\n        (**(*extraout_ECX[0xe] + 4))(1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 512
    },
    "0043da9f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043da9f(void)\n\n{\n    code *pcVar1;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n    if (*0x46038c != 0) {\n        *0x460330 = (*_sym.imp.USER32.dll_GetSystemMetrics)(2);\n        *0x460330 = *0x460330 + 1;\n        *0x460334 = (*pcVar1)(3);\n        *0x460334 = *0x460334 + 1;\n        *0x460398 = 1;\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "0043dc09": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043dc09(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n        (*_sym.imp.KERNEL32.dll_LocalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 50
    },
    "0043de25": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043de25(int32_t arg_8h, int32_t arg_ch)\n\n{\n    code **ppcVar1;\n    code *pcVar2;\n    uint *in_ECX;\n    code **ppcVar3;\n    uint var_4h;\n    \n    ppcVar1 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*in_ECX);\n    if (ppcVar1 == NULL) {\n        ppcVar1 = fcn.0043dbeb(0x10);\n        if (ppcVar1 == NULL) {\n            ppcVar1 = NULL;\n        }\n        else {\n            *ppcVar1 = vtable.CThreadData.0;\n        }\n        ppcVar1[2] = NULL;\n        ppcVar1[3] = NULL;\n        ppcVar3 = ppcVar1 + 2;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n        fcn.0043db92(ppcVar1);\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    }\n    else {\n        ppcVar3 = ppcVar1 + 2;\n        if ((arg_8h < *ppcVar3) || (arg_ch == 0)) goto code_r0x0043defc;\n    }\n    if (ppcVar1[3] == NULL) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LocalAlloc)(0, in_ECX[3] << 2);\n    }\n    else {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_LocalReAlloc)(ppcVar1[3], in_ECX[3] << 2, 2);\n    }\n    ppcVar1[3] = pcVar2;\n    if (pcVar2 == NULL) {\n        fcn.00423259();\n    }\n    fcn.0040ffd0(ppcVar1[3] + *ppcVar3 * 4, 0, (*ppcVar3 * 0x3fffffff + in_ECX[3]) * 4);\n    *ppcVar3 = in_ECX[3];\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, ppcVar1);\ncode_r0x0043defc:\n    *(ppcVar1[3] + arg_8h * 4) = arg_ch;\n    return;\n}\n",
        "token_count": 536
    },
    "0043df2b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043df2b(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.0043dba5(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    if (arg_8h != NULL) {\n        (***arg_8h)(1);\n    }\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 375
    },
    "0043dfc4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043dfc4(uint *param_1, int32_t param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_retaddr;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(param_1 + 7);\n    if (param_2 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*param_1);\n        if (iVar2 != 0) {\n            fcn.0043df2b(iVar2, unaff_retaddr);\n        }\n    }\n    else {\n        iVar2 = param_1[5];\n        while (iVar2 != 0) {\n            iVar1 = *(iVar2 + 4);\n            fcn.0043df2b(iVar2, param_3);\n            iVar2 = iVar1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 222
    },
    "0043e01d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0043e044)\n\nint32_t __fastcall fcn.0043e01d(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    code *unaff_retaddr;\n    \n    if (*param_1 == 0) {\n        if (*0x4603a0 == NULL) {\n            *0x4603a0 = fcn.0043dc1d();\n        }\n        iVar1 = fcn.0043dcb6();\n        *param_1 = iVar1;\n    }\n    iVar1 = *param_1;\n    iVar2 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(**0x4603a0);\n    if ((iVar2 == 0) || (*(iVar2 + 8) <= iVar1)) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = *(*(iVar2 + 0xc) + iVar1 * 4);\n    }\n    if (iVar1 == 0) {\n        iVar1 = (*unaff_retaddr)();\n        fcn.0043de25(*param_1, iVar1);\n    }\n    return iVar1;\n}\n",
        "token_count": 263
    },
    "0043e10d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043e10d(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 67
    },
    "0043e276": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "get OS version"
        ],
        "decompiled_code": "\nint32_t fcn.0043e276(void)\n\n{\n    uint32_t uVar1;\n    \n    if (*0x4605dc == 0) {\n        *0x4605dc = 1;\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if ((uVar1 < 4) && ((uVar1 & 0x80000000) != 0)) {\n            *0x4605d8 = 1;\n        }\n        else {\n            *0x4605d8 = 0;\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x460428);\n        }\n    }\n    return *0x4605dc;\n}\n",
        "token_count": 152
    },
    "0043e309": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043e309(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x4605dc == 0) {\n        fcn.0043e276();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    if (*0x4605d8 == 0) {\n        piVar1 = param_1 * 4 + 0x4603e4;\n        if (*(param_1 * 4 + 0x4603e4) == 0) {\n            (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x460428);\n            if (*piVar1 == 0) {\n                (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x460440);\n                *piVar1 = *piVar1 + 1;\n            }\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x460428);\n        }\n        (*pcVar2)(param_1 * 0x18 + 0x460440);\n    }\n    return;\n}\n",
        "token_count": 249
    },
    "0043e379": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043e379(int32_t param_1)\n\n{\n    if (*0x4605d8 == 0) {\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(param_1 * 0x18 + 0x460440);\n    }\n    return;\n}\n",
        "token_count": 65
    },
    "0043e483": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0043e483(uint phkResult, uint lpString, int32_t lpValueName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    bool bVar4;\n    \n    if (lpValueName == 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueA)(0x80000000, phkResult, 1, lpString, uVar1);\n        bVar4 = iVar2 == 0;\n    }\n    else {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyA)(0x80000000, phkResult, &phkResult);\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString);\n            iVar2 = (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(phkResult, lpValueName, 0, 1, lpString, iVar2 + 1);\n            iVar3 = (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n            if ((iVar3 == 0) && (iVar2 == 0)) {\n                return true;\n            }\n        }\n        bVar4 = false;\n    }\n    return bVar4;\n}\n",
        "token_count": 305
    },
    "0043cfef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid fcn.0043cfef(void)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar5 = *0x45c084;\n    *(unaff_EBP + -0x20) = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = uVar5;\n    *(unaff_EBP + -4) = 1;\n    iVar4 = fcn.0043d8de();\n    fcn.0042b74f(*(iVar4 + 8), unaff_EBP + -0x20);\n    puVar3 = *(extraout_ECX + 8);\n    uVar5 = *0x45c084;\n    while (*0x45c084 = uVar5,  puVar3 != NULL) {\n        puVar1 = *puVar3;\n        piVar2 = puVar3[2];\n        *(unaff_EBP + -0x18) = uVar5;\n        *(unaff_EBP + -0x14) = uVar5;\n        *(unaff_EBP + -0x1c) = uVar5;\n        iVar4 = *piVar2;\n        *(unaff_EBP + -4) = 4;\n        iVar4 = (**(iVar4 + 100))(unaff_EBP + -0x14, 5);\n        if ((iVar4 != 0) && (*(*(unaff_EBP + -0x14) + -8) != 0)) {\n            iVar4 = (**(*piVar2 + 100))(unaff_EBP + -0x1c, 6);\n            if (iVar4 == 0) {\n                fcn.0042a491(unaff_EBP + -0x14);\n            }\n            fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\DefaultIcon\", *(unaff_EBP + -0x14));\n            fcn.0043e3ed(*(unaff_EBP + -0x10));\n            iVar4 = (**(*piVar2 + 100))(unaff_EBP + -0x10, 0);\n            if ((iVar4 == 0) || (*(*(unaff_EBP + -0x10) + -8) == 0)) {\n                fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\shell\\\\open\\\\%s\", *(unaff_EBP + -0x14), \"ddeexec\");\n                fcn.0043e3ed(*(unaff_EBP + -0x10));\n                fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\shell\\\\print\\\\%s\", *(unaff_EBP + -0x14), \"ddeexec\");\n                fcn.0043e3ed(*(unaff_EBP + -0x10));\n                fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\shell\\\\printto\\\\%s\", *(unaff_EBP + -0x14), \"ddeexec\");\n                fcn.0043e3ed(*(unaff_EBP + -0x10));\n            }\n            fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\shell\\\\open\\\\%s\", *(unaff_EBP + -0x14), \"command\");\n            fcn.0043e3ed(*(unaff_EBP + -0x10));\n            fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\shell\\\\print\\\\%s\", *(unaff_EBP + -0x14), \"command\");\n            fcn.0043e3ed(*(unaff_EBP + -0x10));\n            fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\shell\\\\printto\\\\%s\", *(unaff_EBP + -0x14), \"command\");\n            fcn.0043e3ed(*(unaff_EBP + -0x10));\n            (**(*piVar2 + 100))(unaff_EBP + -0x18, 4);\n            iVar4 = *(unaff_EBP + -0x18);\n            if (*(iVar4 + -8) != 0) {\n                *(unaff_EBP + -0x24) = 0x208;\n                uVar5 = fcn.0042a714(0x208, unaff_EBP + -0x24);\n                iVar4 = (*_sym.imp.ADVAPI32.dll_RegQueryValueA)(0x80000000, iVar4, uVar5);\n                fcn.0042a763();\n                if (((iVar4 != 0) || (*(*(unaff_EBP + -0x10) + -8) == 0)) ||\n                   (iVar4 = fcn.0041110c(*(unaff_EBP + -0x10), *(unaff_EBP + -0x14)),  iVar4 == 0)) {\n                    fcn.0042373f(unaff_EBP + -0x10, \"%s\\\\ShellNew\", *(unaff_EBP + -0x18));\n                    fcn.0043e3ed(*(unaff_EBP + -0x10));\n                    fcn.0043e3ed(*(unaff_EBP + -0x18));\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 3;\n        fcn.0042a358();\n        *(unaff_EBP + -4) = 2;\n        fcn.0042a358();\n        *(unaff_EBP + -4) = 1;\n        fcn.0042a358();\n        puVar3 = puVar1;\n        uVar5 = *0x45c084;\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1515
    },
    "0043ec1c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint fcn.0043ec1c(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.0043d8de();\n    *(iVar3 + 8) = unaff_ESI;\n    *(iVar3 + 0xc) = unaff_ESI;\n    iVar3 = fcn.0043d8de();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x68) = unaff_ESI;\n        *(iVar3 + 0x6c) = unaff_retaddr;\n        *(iVar3 + 0x70) = param_1;\n        *(iVar3 + 0x74) = param_2;\n        fcn.0043ec7f();\n    }\n    iVar3 = fcn.0043d8de();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.00429b2d();\n    }\n    return 1;\n}\n",
        "token_count": 307
    },
    "0043ec7f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043ec7f(int32_t param_1)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_30ch;\n    uint lpFilename;\n    uint var_108h;\n    uchar *var_4h;\n    \n    iVar2 = fcn.0043d8de();\n    *(iVar2 + 8) = *(param_1 + 0x68);\n    *(iVar2 + 0xc) = *(param_1 + 0x68);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x68), &lpFilename, 0x104);\n    var_4h = fcn.004114e6(&lpFilename, 0x2e);\n    *var_4h = 0;\n    fcn.0043ed9c(&lpFilename, &var_108h, 0x104);\n    if (*(param_1 + 0x88) == 0) {\n        uVar3 = fcn.00411248(&var_108h);\n        *(param_1 + 0x88) = uVar3;\n    }\n    if (*(param_1 + 0x78) == 0) {\n        iVar4 = fcn.0042be55(0xe000, &var_30ch, 0x100);\n        if (iVar4 == 0) {\n            puVar5 = *(param_1 + 0x88);\n        }\n        else {\n            puVar5 = &var_30ch;\n        }\n        uVar3 = fcn.00411248(puVar5);\n        *(param_1 + 0x78) = uVar3;\n    }\n    puVar1 = var_4h;\n    *(iVar2 + 0x10) = *(param_1 + 0x78);\n    if (*(param_1 + 0x8c) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(var_4h, \".HLP\");\n        uVar3 = fcn.00411248(&lpFilename);\n        *(param_1 + 0x8c) = uVar3;\n        *puVar1 = 0;\n    }\n    if (*(param_1 + 0x90) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcatA)(&var_108h, \".INI\");\n        uVar3 = fcn.00411248(&var_108h);\n        *(param_1 + 0x90) = uVar3;\n    }\n    return;\n}\n",
        "token_count": 590
    },
    "0043ed9c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t fcn.0043ed9c(char *param_1, int32_t param_2, uint param_3)\n\n{\n    char cVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    \n    pcVar2 = param_1;\n    for (; *param_1 != '\\0'; param_1 = fcn.004114cf(param_1)) {\n        cVar1 = *param_1;\n        if (((cVar1 == '\\\\') || (cVar1 == '/')) || (cVar1 == ':')) {\n            pcVar2 = fcn.004114cf(param_1);\n        }\n    }\n    if (param_2 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar2);\n        iVar3 = iVar3 + 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(param_2, pcVar2, param_3);\n        iVar3 = 0;\n    }\n    return iVar3;\n}\n",
        "token_count": 230
    },
    "0043ef2a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.0043ef2a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.0043f838();\n    fcn.00443f0c();\n    fcn.0040f7df();\n    if (param_1 == 0) {\n        iVar1 = fcn.00429b18();\n        if (iVar1 != 0) {\n            if (*(iVar1 + 0x58) != NULL) {\n                (**(**(iVar1 + 0x58) + 4))(1);\n            }\n            *(iVar1 + 0x58) = 0;\n        }\n        iVar1 = fcn.0043d6a7();\n        if (*(iVar1 + 0x114) == 1) {\n            (*_sym.imp.ole32.dll_CoFreeUnusedLibraries)();\n            (*_sym.imp.ole32.dll_OleUninitialize)();\n            *(iVar1 + 0x114) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 221
    },
    "0043f170": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0043f170(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[1] == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(param_1 + 1);\n    if (iVar1 == 0) {\n        (**(*param_1 + 0x10))();\n    }\n    return iVar1;\n}\n",
        "token_count": 106
    },
    "0043f1ad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0043f1ad(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    \n    piVar1 = (**(*param_1 + 0x44))(param_2);\n    if (piVar1 == NULL) {\n        ppiVar2 = (**(*param_1 + 0x38))();\n        if ((((*0x44d948 == *param_2) && (param_2[1] == *0x44d94c)) && (param_2[2] == *0x44d950)) &&\n           (param_2[3] == *0x44d954)) {\n            do {\n                for (piVar1 = ppiVar2[1]; *piVar1 != 0; piVar1 = piVar1 + 2) {\n                    if (*(piVar1[1] + param_1) != 0) {\n                        return piVar1[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        else {\n            do {\n                for (ppiVar3 = ppiVar2[1]; piVar1 = *ppiVar3,  piVar1 != NULL; ppiVar3 = ppiVar3 + 2) {\n                    if (((*piVar1 == *param_2) && (piVar1[1] == param_2[1])) &&\n                       ((piVar1[2] == param_2[2] && ((piVar1[3] == param_2[3] && (*(ppiVar3[1] + param_1) != 0)))))) {\n                        return ppiVar3[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        piVar1 = NULL;\n    }\n    return piVar1;\n}\n",
        "token_count": 456
    },
    "0043f25b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043f25b(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(*piVar3 + in_ECX);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 293
    },
    "0043f42e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0043f42e(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x5c) = param_2;\n    if (param_2 != 1) {\n        param_2 = ((param_2 != 2) - 1 & 3) - 1;\n    }\n    return param_2;\n}\n",
        "token_count": 91
    },
    "0043f4c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043f4c7(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t hWnd;\n    \n    iVar2 = *(param_1 + 0x50);\n    if (iVar2 != 0) {\n        iVar2 = *(iVar2 + 0x1c);\n    }\n    hWnd = param_1;\n    uVar1 = fcn.00434560(iVar2, &hWnd);\n    *(param_1 + 0x68) = uVar1;\n    fcn.00425e12(param_1);\n    iVar2 = sub.oledlg.dll_OleUIBusyA(param_1 + 0x60);\n    fcn.00425e5e();\n    fcn.004259de();\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    uVar1 = 2;\n    if (iVar2 != 2) {\n        if (iVar2 == 0x75) {\n            *(param_1 + 0x8c) = 1;\n        }\n        else {\n            if (iVar2 != 0x76) {\n                if (iVar2 == 0x77) {\n                    *(param_1 + 0x8c) = 3;\n                    return 1;\n                }\n                uVar1 = fcn.0043f42e(iVar2);\n            }\n            *(param_1 + 0x8c) = uVar1;\n        }\n        return 1;\n    }\n    return 2;\n}\n",
        "token_count": 354
    },
    "0043f5b2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043f5b2(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.0043f170();\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        fcn.00425426(extraout_ECX[9]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428a9b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 247
    },
    "0043fc9a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0043fc9a(uint32_t *arg_8h, uint8_t *arg_ch, uint8_t *arg_10h, int32_t arg_14h, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    bool bVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    int16_t iVar8;\n    uint32_t in_ECX;\n    int16_t *piVar9;\n    int16_t *piVar10;\n    ulong *puVar11;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    *arg_8h = in_ECX;\n    puVar11 = arg_8h + 1;\n    if ((arg_14h == 6) || (arg_14h == 0xc)) {\n        *puVar11 = arg_10h;\n        puVar11 = arg_8h + 2;\n    }\n    bVar3 = false;\n    iVar2 = *arg_18h;\n    arg_14h = arg_18h[2];\n    var_4h = arg_18h[3];\n    arg_10h = arg_ch;\n    do {\n        if (*arg_10h == 0) {\ncode_r0x0043fe70:\n            if (arg_14h < 1) {\n                if (*arg_10h == 0) {\n                    iVar4 = 0;\n                }\n                else {\n                    *arg_1ch = arg_18h[2];\n                    iVar4 = -0x7ffdfff1;\n                }\n            }\n            else {\n                iVar4 = -0x7ffdfff2;\ncode_r0x0043fe7b:\n                *arg_1ch = arg_14h;\n            }\n            return iVar4;\n        }\n        arg_14h = arg_14h + -1;\n        uVar1 = *arg_10h;\n        arg_8h = in_ECX & 0xffff0000 | uVar1;\n        if ((uVar1 != 0xff) && ((uVar1 & 0x40) != 0)) {\n            arg_8h = CONCAT11(0x40, uVar1 & 0xbf);\n        }\n        iVar8 = arg_8h;\n        if (arg_14h < var_4h) {\n            if (iVar8 == 0xff) {\n                arg_14h = arg_18h[3];\n                var_4h = 0;\n                bVar3 = true;\n                goto code_r0x0043fe65;\n            }\n            if ((!bVar3) && (iVar8 == 0xc)) {\n                *0x460620 = 10;\n                *0x460628 = 0x80020004;\n                piVar9 = 0x460620;\n                goto code_r0x0043fdbc;\n            }\n            goto code_r0x0043fe70;\n        }\n        if (iVar8 == 0xff) goto code_r0x0043fe70;\n        piVar10 = iVar2 + arg_14h * 0x10;\n        piVar9 = piVar10;\n        if ((iVar8 != 0xc) && (iVar8 != *piVar10)) {\n            arg_ch = 0x8;\n            piVar9 = arg_20h + arg_14h * 0x10;\n            if (iVar8 != 0xe) {\n                arg_ch = arg_8h;\n            }\n            uVar7 = 4;\n            if ((*piVar10 != arg_ch) &&\n               (iVar4 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(piVar9, piVar10, 0, arg_ch),  uVar7 = arg_ch, \n               iVar4 < 0)) goto code_r0x0043fe7b;\n            if (iVar8 == 0xe) {\n                if (*piVar10 == arg_ch) {\n                    uVar6 = fcn.0043f019(uVar7, *(piVar10 + 4));\n                    *(piVar9 + 4) = uVar6;\n                    *piVar9 = 8;\n                }\n                else {\n                    uVar6 = *(piVar9 + 4);\n                    uVar5 = fcn.0043f019(uVar6);\n                    *(piVar9 + 4) = uVar5;\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(uVar6);\n                }\n                arg_8h = 0x8;\n            }\n        }\ncode_r0x0043fdbc:\n        uVar7 = arg_8h & 0xffff;\n        if (0x11 < uVar7) {\n    // switch table (17 cases) at 0x43fed5\n            switch(uVar7) {\n            case 0x4002:\n            case 0x4003:\n            case 0x4004:\n            case 0x4005:\n            case 0x4006:\n            case 0x4007:\n            case 0x4008:\n            case 0x4009:\n            case 0x400a:\n            case 0x400b:\n            case 0x400c:\n            case 0x400d:\n            case 0x4012:\ncode_r0x0043fe5e:\n                uVar7 = *(piVar9 + 4);\n                goto code_r0x0043fe61;\n            }\n            goto code_r0x0043fe65;\n        }\n        if (uVar7 == 0x11) {\n            uVar7 = *(piVar9 + 4);\n            goto code_r0x0043fe61;\n        }\n    // switch table (12 cases) at 0x43fea5\n        switch(uVar7) {\n        case 2:\n            uVar7 = piVar9[4];\n            break;\n        case 3:\n        case 4:\n        case 8:\n        case 9:\n        case 10:\n        case 0xd:\n            goto code_r0x0043fe5e;\n        case 5:\n        case 7:\n            *puVar11 = *(piVar9 + 4);\n            goto code_r0x0043fe33;\n        case 6:\n            *puVar11 = *(piVar9 + 4);\n            *(puVar11 + 4) = *(piVar9 + 6);\ncode_r0x0043fe33:\n            puVar11 = puVar11 + 1;\n            goto code_r0x0043fe65;\n        case 0xb:\n            uVar7 = piVar9[4] != 0;\n            break;\n        case 0xc:\n            *puVar11 = piVar9;\n            goto code_r0x0043fe63;\n        default:\n            goto code_r0x0043fe65;\n        }\ncode_r0x0043fe61:\n        *puVar11 = uVar7;\ncode_r0x0043fe63:\n        puVar11 = puVar11 + 4;\ncode_r0x0043fe65:\n        arg_10h = arg_10h + 1;\n        in_ECX = arg_8h;\n    } while( true );\n}\n",
        "token_count": 1635
    },
    "00440464": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.00440464(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.0042a883();\n    pcVar5 = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[3] = pcVar5;\n    extraout_ECX[5] = *0x45c084;\n    extraout_ECX[6] = *0x45c084;\n    iVar2 = *(unaff_EBP + 0xc);\n    iVar1 = *(unaff_EBP + 0x10);\n    *(unaff_EBP + -4) = 3;\n    iVar4 = *(unaff_EBP + 8);\n    *extraout_ECX = vtable.COleDispatchException.0;\n    extraout_ECX[4] = -(iVar2 != 0) & iVar2 + 0x60000U;\n    *(extraout_ECX + 2) = iVar1;\n    if (iVar4 != 0) {\n        fcn.0042a4e1(*(unaff_EBP + 8));\n    }\n    uVar3 = *(unaff_EBP + -0xc);\n    extraout_ECX[7] = (-(iVar1 != 0) & 0x7fff0001) + 0x8000ffff;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 455
    },
    "0044053a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044053a(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *param_1;\n    if (piVar1 != NULL) {\n        if (param_1[1] != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n        *param_1 = NULL;\n    }\n    return;\n}\n",
        "token_count": 93
    },
    "00440554": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_78h\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_64h\n// WARNING: Variable defined which should be unmapped: var_68h\n\nvoid __cdecl fcn.00440554(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uchar *puVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint16_t uVar4;\n    uint16_t *puVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    int32_t *piVar9;\n    code *pcVar10;\n    int16_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    uint32_t *puVar14;\n    uint uVar15;\n    int32_t **extraout_ECX;\n    int32_t **ppiVar16;\n    int32_t iVar17;\n    int32_t unaff_EBP;\n    ulong *puVar18;\n    char *pcVar19;\n    uint *in_FS_OFFSET;\n    uint noname_1;\n    uint noname_0;\n    uint lpString2;\n    uint noname_3;\n    uint var_78h;\n    char *var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint pvargDest;\n    uint pbstr;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint cchWideChar;\n    uint var_1ch;\n    uint lpMultiByteStr;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    uint uStack4;\n    \n    uStack4 = 0x44055e;\n    fcn.0040fbf4();\n    piVar9 = *extraout_ECX;\n    *(unaff_EBP + -0x28) = extraout_ECX;\n    if (piVar9 != NULL) {\n        var_6ch = 0x10;\n        fcn.0040ffd0(unaff_EBP + -0x4c, 0);\n        pcVar19 = *(unaff_EBP + 0x18);\n        if (pcVar19 == NULL) {\n            iVar12 = *(unaff_EBP + -0x44);\n        }\n        else {\n            var_6ch = pcVar19;\n            iVar12 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n            *(unaff_EBP + -0x44) = iVar12;\n        }\n        *(unaff_EBP + -0x1c) = 0xfffffffd;\n        if ((*(unaff_EBP + 0xc) & 0xc) != 0) {\n            *(unaff_EBP + -0x40) = 1;\n            *(unaff_EBP + -0x48) = unaff_EBP + -0x1c;\n        }\n        ppiVar16 = extraout_ECX;\n        if (iVar12 != 0) {\n            var_6ch = iVar12 << 4;\n            iVar12 = fcn.004253fd();\n            *(unaff_EBP + -0x4c) = iVar12;\n            fcn.0040ffd0(iVar12, 0, *(unaff_EBP + -0x44) << 4);\n            cVar2 = *pcVar19;\n            *(unaff_EBP + -0x14) = pcVar19;\n            iVar12 = *(unaff_EBP + -0x44) * 0x10 + -0x10 + iVar12;\n            *(unaff_EBP + -0x10) = iVar12;\n            if (cVar2 != '\\0') {\n                puVar18 = iVar12 + 8;\n                *(unaff_EBP + -0x18) = puVar18;\n                iVar12 = *(unaff_EBP + 0x1c) + -4;\n                *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + -8;\n                do {\n                    puVar5 = *(unaff_EBP + -0x10);\n                    uVar3 = **(unaff_EBP + -0x14);\n                    *puVar5 = uVar3;\n                    if ((uVar3 & 0x40) != 0) {\n                        *puVar5 = CONCAT11(0x40, uVar3 & 0xbf);\n                    }\n                    uVar4 = *puVar5;\n                    if (0x4002 < uVar4) {\n    // switch table (15 cases) at 0x4409ff\n                        switch(uVar4) {\n                        case 0x4003:\n                        case 0x4004:\n                        case 0x4005:\n                        case 0x4006:\n                        case 0x4007:\n                        case 0x4008:\n                        case 0x4009:\n                        case 0x400a:\n                        case 0x400c:\n                        case 0x400d:\n                        case 0x4011:\n                            goto code_r0x00440794;\n                        case 0x400b:\n                            puVar14 = *(iVar12 + 4);\n                            *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                            *puVar14 = -(*puVar14 != 0) & 0xffff;\n                            break;\n                        default:\n                            goto code_r0x0044079e;\n                        }\ncode_r0x0044079c:\n                        iVar12 = iVar12 + 4;\n                        *puVar18 = puVar14;\n                        goto code_r0x0044079e;\n                    }\n                    if (uVar4 == 0x4002) {\ncode_r0x00440794:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        puVar14 = *(iVar12 + 4);\n                        goto code_r0x0044079c;\n                    }\n    // switch table (16 cases) at 0x4409bf\n                    switch(uVar4) {\n                    case 2:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        iVar11 = *(iVar12 + 4);\n                        goto code_r0x00440664;\n                    case 3:\n                    case 9:\n                    case 10:\n                    case 0xd:\n                        goto code_r0x00440794;\n                    case 4:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 8;\n                        iVar12 = iVar12 + 8;\n                        *puVar18 = **(unaff_EBP + 0x1c);\n                        break;\n                    case 5:\n                    case 7:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 8;\n                        iVar12 = iVar12 + 8;\n                        *puVar18 = **(unaff_EBP + 0x1c);\n                        break;\n                    case 6:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        puVar8 = *(iVar12 + 4);\n                        iVar12 = iVar12 + 4;\n                        *puVar18 = *puVar8;\n                        *(puVar18 + 4) = puVar8[1];\n                        break;\n                    case 8:\n                        var_6ch = *(iVar12 + 4);\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        iVar12 = iVar12 + 4;\n                        *(unaff_EBP + -0x18) = var_6ch;\n                        iVar13 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n                        iVar17 = *(unaff_EBP + -0x18);\n                        *puVar18 = iVar13;\n                        if ((iVar17 != 0) && (iVar13 == 0)) {\n                            var_6ch = 0x4406d4;\n                            fcn.00423259();\n                        }\n                        break;\n                    case 0xb:\n                        iVar17 = *(iVar12 + 4);\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        iVar11 = -(iVar17 != 0);\ncode_r0x00440664:\n                        iVar12 = iVar12 + 4;\n                        *puVar18 = iVar11;\n                        break;\n                    case 0xc:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        puVar8 = *(iVar12 + 4);\n                        puVar6 = *(unaff_EBP + -0x10);\n                        iVar12 = iVar12 + 4;\n                        *puVar6 = *puVar8;\n                        puVar6[1] = puVar8[1];\n                        puVar6[2] = puVar8[2];\n                        puVar6[3] = puVar8[3];\n                        puVar18 = *(unaff_EBP + -0x18);\n                        break;\n                    case 0xe:\n                        var_6ch = *(iVar12 + 4);\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        iVar12 = iVar12 + 4;\n                        *(unaff_EBP + -0x18) = var_6ch;\n                        if (var_6ch != NULL) {\n                            var_6ch = *(unaff_EBP + -0x18);\n                            iVar17 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n                            *(unaff_EBP + -0x20) = iVar17 + 1;\n                            fcn.00410700();\n                            *(unaff_EBP + -0x24) = &fcn.00440554::var_6ch;\n                            var_6ch = var_6ch & 0xffff0000;\n                            (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                      (0, 0, *(unaff_EBP + -0x18), 0xffffffff, &fcn.00440554::var_6ch, \n                                       *(unaff_EBP + -0x20));\n                            var_6ch = *(unaff_EBP + -0x24);\n                        }\n                        iVar13 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n                        iVar17 = *(unaff_EBP + -0x18);\n                        *puVar18 = iVar13;\n                        if ((iVar17 != 0) && (iVar13 == 0)) {\n                            var_6ch = 0x440737;\n                            fcn.00423259();\n                        }\n                        **(unaff_EBP + -0x10) = 8;\n                        break;\n                    case 0x11:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        puVar1 = iVar12 + 4;\n                        iVar12 = iVar12 + 4;\n                        *puVar18 = *puVar1;\n                    }\ncode_r0x0044079e:\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + -0x10;\n                    puVar18 = puVar18 + -2;\n                    *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 1;\n                    *(unaff_EBP + -0x18) = puVar18;\n                } while (**(unaff_EBP + -0x14) != '\\0');\n                ppiVar16 = *(unaff_EBP + -0x28);\n                pcVar19 = *(unaff_EBP + 0x18);\n            }\n        }\n        var_6ch = unaff_EBP + -0x3c;\n        fcn.0040f641();\n        fcn.0040ffd0(unaff_EBP + -0x6c, 0, 0x20);\n        piVar9 = *ppiVar16;\n        *(unaff_EBP + -0x2c) = 0xffffffff;\n        iVar12 = unaff_EBP + -0x4c;\n        noname_3 = *(unaff_EBP + 0xc);\n        lpString2 = 0;\n        noname_0 = 0x44d938;\n        noname_1 = *(unaff_EBP + 8);\n        uVar15 = (**(*piVar9 + 0x18))(piVar9);\n        *(unaff_EBP + 0x18) = uVar15;\n        if (*(unaff_EBP + -0x44) != 0) {\n            iVar17 = *(unaff_EBP + -0x44) * 0x10 + -0x10 + *(unaff_EBP + -0x4c);\n            cVar2 = *pcVar19;\n            while (cVar2 != '\\0') {\n                if ((*pcVar19 == '\\b') || (*pcVar19 == '\\x0e')) {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(iVar17);\n                }\n                iVar17 = iVar17 + -0x10;\n                pcVar19 = pcVar19 + 1;\n                cVar2 = *pcVar19;\n            }\n        }\n        fcn.00425426(*(unaff_EBP + -0x4c));\n        if (*(unaff_EBP + 0x18) < 0) {\n            (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x3c);\n            if (*(unaff_EBP + 0x18) != -0x7ffdfff7) {\n                noname_0 = *(unaff_EBP + 0x18);\n                fcn.0043f323(noname_0, noname_0, lpString2, noname_3, iVar12);\n            }\n            if (*(unaff_EBP + -0x54) != 0) {\n                (**(unaff_EBP + -0x54))(unaff_EBP + -0x6c);\n            }\n            iVar12 = fcn.004253fd(0x20);\n            *(unaff_EBP + 0x14) = iVar12;\n            *(unaff_EBP + -4) = 0;\n            if (iVar12 == 0) {\n                iVar12 = 0;\n            }\n            else {\n                noname_0 = 0;\n                iVar12 = fcn.00440464(0, 0, *(unaff_EBP + -0x6c));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            pcVar10 = _sym.imp.OLEAUT32.dll_SysStringLen;\n            if (*(unaff_EBP + -0x68) != 0) {\n                fcn.0042a508(*(unaff_EBP + -0x68));\n                (*pcVar10)(*(unaff_EBP + -0x68));\n            }\n            if (*(unaff_EBP + -100) != 0) {\n                fcn.0042a508(*(unaff_EBP + -100));\n                (*pcVar10)(*(unaff_EBP + -100));\n            }\n            if (*(unaff_EBP + -0x60) != 0) {\n                fcn.0042a508(*(unaff_EBP + -0x60));\n                (*pcVar10)(*(unaff_EBP + -0x60));\n            }\n            noname_1 = 0x454688;\n            *(iVar12 + 0x10) = *(unaff_EBP + -0x5c);\n            *(iVar12 + 0x1c) = *(unaff_EBP + -0x50);\n            *(unaff_EBP + 0x14) = iVar12;\n            fcn.0041101e(unaff_EBP + 0x14, 0x454688);\n        }\n        uVar7 = *(unaff_EBP + 0x10);\n        if (uVar7 != 0) {\n            if ((uVar7 != 0xc) &&\n               (iVar12 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)\n                                   (unaff_EBP + -0x3c, unaff_EBP + -0x3c, 0, uVar7),  iVar12 < 0)) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x3c);\n                fcn.0043f323(iVar12, noname_1, noname_0, lpString2, noname_3);\n            }\n    // switch table (16 cases) at 0x440a3b\n            switch(uVar7 & 0xffff) {\n            case 2:\n                **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n                break;\n            case 3:\n            case 4:\n            case 9:\n            case 10:\n            case 0xd:\n                **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n                break;\n            case 5:\n            case 6:\n            case 7:\n                puVar8 = *(unaff_EBP + 0x14);\n                *puVar8 = *(unaff_EBP + -0x34);\n                puVar8[1] = *(unaff_EBP + -0x30);\n                break;\n            case 8:\n                fcn.0043efd4(*(unaff_EBP + 0x14), *(unaff_EBP + -0x34));\n                (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(unaff_EBP + -0x34));\n                break;\n            case 0xb:\n                **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34) != 0;\n                break;\n            case 0xc:\n                puVar8 = *(unaff_EBP + 0x14);\n                *puVar8 = *(unaff_EBP + -0x3c);\n                puVar8[1] = *(unaff_EBP + -0x38);\n                puVar8[2] = *(unaff_EBP + -0x34);\n                puVar8[3] = *(unaff_EBP + -0x30);\n                break;\n            case 0x11:\n                **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 4310
    },
    "00440ce9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00440ce9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *unaff_retaddr;\n    \n    fcn.00440adb(0);\n    *(unaff_retaddr[0x17] + 8) = *(param_1 + 0x94);\n    *(unaff_retaddr[0x17] + 0xc) = *(param_1 + 0x98);\n    do {\n        iVar1 = (**(*unaff_retaddr + 0xb8))();\n        if ((iVar1 == 1) || (iVar1 == 2)) {\n            *(param_1 + 0x94) = *(unaff_retaddr[0x17] + 8);\n            *(param_1 + 0x98) = *(unaff_retaddr[0x17] + 0xc);\n            return iVar1;\n        }\n        uVar2 = sub.comdlg32.dll_CommDlgExtendedError();\n        if (uVar2 != 0x1009) {\n            if (uVar2 < 0x100b) {\n                return iVar1;\n            }\n            if (0x100c < uVar2) {\n                return iVar1;\n            }\n        }\n        if (*(unaff_retaddr[0x17] + 0xc) != 0) {\n            fcn.0042f5a8();\n            *(unaff_retaddr[0x17] + 0xc) = 0;\n            *(param_1 + 0x98) = 0;\n        }\n        if (*(unaff_retaddr[0x17] + 8) != 0) {\n            fcn.0042f5a8();\n            *(unaff_retaddr[0x17] + 8) = 0;\n            *(param_1 + 0x94) = 0;\n        }\n    } while( true );\n}\n",
        "token_count": 425
    },
    "004410f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004410f6(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CPreviewView.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.0042e7b0();\n    pcVar1 = extraout_ECX[0x45];\n    if (pcVar1 != NULL) {\n        fcn.00442ce8();\n        fcn.00425426(pcVar1);\n    }\n    fcn.00425426(extraout_ECX[0x22]);\n    if (extraout_ECX[0x1d] != NULL) {\n        (**(*extraout_ECX[0x1d] + 4))(1);\n    }\n    if (extraout_ECX[0x40] != NULL) {\n        uVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n        (*_sym.imp.USER32.dll_SetCursor)(uVar2);\n        (*_sym.imp.USER32.dll_DestroyCursor)(extraout_ECX[0x40]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042e7e1();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00430136();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 429
    },
    "004415e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004415e4(int32_t *arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    fcn.004305c6(&var_8h, &var_10h);\n    if (*(in_ECX + 0xec) == 0) {\n        iVar2 = *(**(in_ECX + 0x114) + 0x5c);\n        iVar1 = *(iVar2 + 0x1e);\n        if ((iVar1 != -1) && (iVar1 != *(iVar2 + 0x1c))) {\n            var_8h = var_8h - var_10h;\n        }\n    }\n    *(in_ECX + 0xfc) = (var_8h + -8) / 2;\n    if (*(in_ECX + 0xf8) == 2) {\n        var_8h = (var_8h + -0x18) / 2;\n    }\n    else {\n        var_8h = var_8h + -0x10;\n    }\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h + -0x10;\n    return;\n}\n",
        "token_count": 308
    },
    "00441668": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00441668(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    code *pcVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    int32_t xRight;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar6 = arg_8h * 0x28 + *(in_ECX + 0x90);\n    piVar4 = fcn.004415e4(&xRight);\n    var_8h = *piVar4;\n    var_4h = piVar4[1];\n    iVar5 = *(iVar6 + 0x24);\n    iVar1 = *(in_ECX + 0xec);\n    bVar2 = iVar5 <= *(iVar6 + 0x20);\n    if (iVar1 == 0) {\n        *(iVar6 + 0x18) = *(iVar6 + 0x20);\n        *(iVar6 + 0x1c) = *(iVar6 + 0x24);\n    }\n    else {\n        if (iVar1 == 1) {\n            *(iVar6 + 0x1c) = iVar5;\n            if (bVar2) {\n                iVar5 = *(iVar6 + 0x20) * 3 - iVar5;\n            }\n            else {\n                iVar5 = *(iVar6 + 0x20) + iVar5;\n            }\n            iVar5 = iVar5 / 2;\n        }\n        else {\n            if (iVar1 != 2) goto code_r0x004416f7;\n            if (bVar2) {\n                *(iVar6 + 0x1c) = iVar5;\n                iVar5 = *(iVar6 + 0x20) * 2 - *(iVar6 + 0x24);\n            }\n            else {\n                iVar5 = 1;\n                *(iVar6 + 0x1c) = 1;\n            }\n        }\n        *(iVar6 + 0x18) = iVar5;\n    }\ncode_r0x004416f7:\n    xRight = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x10), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    iVar6 = (*_sym.imp.KERNEL32.dll_MulDiv)(*(iVar6 + 0x14), *(iVar6 + 0x18), *(iVar6 + 0x1c));\n    piVar4 = arg_8h * 0x28 + *(in_ECX + 0x90);\n    (*_sym.imp.USER32.dll_SetRect)(piVar4, 8, 8, xRight + 0xb, iVar6 + 0xb);\n    pcVar3 = _sym.imp.USER32.dll_OffsetRect;\n    if (*(in_ECX + 0xec) == 0) {\n        (*_sym.imp.USER32.dll_OffsetRect)\n                  (piVar4, (var_8h - (piVar4[2] - *piVar4)) / 2 + -1, (var_4h - (piVar4[3] - piVar4[1])) / 2 + -1);\n        if (arg_8h == 1) {\n            (*pcVar3)(piVar4, *(in_ECX + 0xfc), 0);\n        }\n    }\n    else {\n        fcn.004302ab(1, (piVar4[2] - *piVar4) + 0x10, (piVar4[3] - piVar4[1]) + 0x10, &var_8h, 0x44c150);\n    }\n    return;\n}\n",
        "token_count": 831
    },
    "00441c6e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00441c6e(int32_t arg_8h, uint32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0xec) == 0) {\n        if (arg_8h == 0) {\n            arg_ch = *(in_ECX + 0xf4) - 1;\n        }\n        else if (arg_8h == 1) {\n            arg_ch = *(in_ECX + 0xf4) + 1;\n        }\n        else if (arg_8h == 2) {\n            iVar1 = *(**(in_ECX + 0x114) + 0x5c);\n            arg_ch = *(in_ECX + 0xf4) - ((*(iVar1 + 0x1e) - *(iVar1 + 0x1c)) + 9) / 10;\n        }\n        else if (arg_8h == 3) {\n            iVar1 = *(**(in_ECX + 0x114) + 0x5c);\n            arg_ch = ((*(iVar1 + 0x1e) - *(iVar1 + 0x1c)) + 9) / 10 + *(in_ECX + 0xf4);\n        }\n        else if (arg_8h != 4) {\n            if (arg_8h == 6) {\n                arg_ch = *(*(**(in_ECX + 0x114) + 0x5c) + 0x1c);\n            }\n            else {\n                if (arg_8h != 7) {\n                    return;\n                }\n                arg_ch = *(*(**(in_ECX + 0x114) + 0x5c) + 0x1e);\n            }\n        }\n        fcn.004420ad(arg_ch, 1);\n    }\n    else {\n        fcn.00430940(arg_8h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 448
    },
    "00441ddb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00441ddb(int32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint var_8h;\n    \n    if (*(in_ECX + 0xec) != 0) {\n        piVar1 = fcn.004303dd(&var_8h);\n        iVar2 = piVar1[1];\n        *arg_8h = *arg_8h + *piVar1;\n        arg_8h[1] = arg_8h[1] + iVar2;\n    }\n    *arg_ch = 0;\n    if (*(in_ECX + 0xf8) != 0) {\n        do {\n            iVar2 = (*_sym.imp.USER32.dll_PtInRect)(*(in_ECX + 0x90) + *arg_ch * 0x28, *arg_8h, arg_8h[1]);\n            if (iVar2 != 0) {\n                iVar2 = *(*(in_ECX + 0x90) + 4 + *arg_ch * 0x28);\n                *arg_8h = *arg_8h - *(*(in_ECX + 0x90) + *arg_ch * 0x28);\n                arg_8h[1] = arg_8h[1] - iVar2;\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)\n                                  (*arg_8h, *(*(in_ECX + 0x90) + *arg_ch * 0x28 + 0x1c), \n                                   *(*(in_ECX + 0x90) + 0x18 + *arg_ch * 0x28));\n                *arg_8h = iVar2;\n                iVar2 = (*_sym.imp.KERNEL32.dll_MulDiv)\n                                  (arg_8h[1], *(*(in_ECX + 0x90) + *arg_ch * 0x28 + 0x1c), \n                                   *(*(in_ECX + 0x90) + 0x18 + *arg_ch * 0x28));\n                arg_8h[1] = iVar2;\n                return 1;\n            }\n            *arg_ch = *arg_ch + 1;\n        } while (*arg_ch < *(in_ECX + 0xf8));\n    }\n    return 0;\n}\n",
        "token_count": 535
    },
    "00441ea5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00441ea5(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    var_4h = in_ECX;\n    iVar1 = fcn.00441ddb(&arg_ch, &var_4h);\n    if (iVar1 != 0) {\n        if (*(in_ECX + 0xec) == 2) {\n            iVar1 = 0;\n        }\n        else {\n            iVar1 = *(in_ECX + 0xec) + 1;\n        }\n        fcn.00441ee3(iVar1, var_4h, arg_ch, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 171
    },
    "00442333": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00442333(uint noname_0, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t *piVar3;\n    uint var_8h;\n    \n    if (arg_ch == 1) {\n        (*_sym.imp.USER32.dll_GetCursorPos)(&var_8h);\n        (*_sym.imp.USER32.dll_ScreenToClient)(*(in_ECX + 0x1c), &var_8h);\n        if ((*(in_ECX + 0xec) == 2) || (iVar2 = fcn.00441ddb(&var_8h, &arg_ch),  iVar2 == 0)) {\n            iVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(0, 0x7f00);\n        }\n        else {\n            piVar3 = in_ECX + 0x100;\n            if (*piVar3 == 0) {\n                iVar2 = fcn.0043d8de();\n                iVar2 = (*_sym.imp.USER32.dll_LoadCursorA)(*(iVar2 + 0xc), 0x7902);\n                *piVar3 = iVar2;\n            }\n            iVar2 = *piVar3;\n        }\n        (*_sym.imp.USER32.dll_SetCursor)(iVar2);\n        return 0;\n    }\n    uVar1 = fcn.004258c7();\n    return uVar1;\n}\n",
        "token_count": 323
    },
    "00442fb4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00442fb4(int32_t param_1, uint param_2, uint param_3)\n\n{\n    *(param_1 + 0x10) = param_2;\n    *(param_1 + 0x14) = param_3;\n    if (*(param_1 + 8) != 0) {\n        fcn.00443b26(1);\n        fcn.004431bb();\n    }\n    return;\n}\n",
        "token_count": 102
    },
    "00443071": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00443071(int32_t *param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint uVar3;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    if (param_1[1] != 0) {\n        uVar3 = (*_sym.imp.GDI32.dll_GetStockObject)(7);\n        pcVar2 = _sym.imp.GDI32.dll_SelectObject;\n        uVar3 = (*_sym.imp.GDI32.dll_SelectObject)(param_1[2], uVar3);\n        (*pcVar2)(param_1[2], uVar3);\n        (*pcVar2)(param_1[1], uVar3);\n        uVar3 = (*pcVar1)(4);\n        uVar3 = (*pcVar2)(param_1[2], uVar3);\n        (*pcVar2)(param_1[2], uVar3);\n        (*pcVar2)(param_1[1], uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetROP2)(param_1[2]);\n        fcn.0042e9b1(uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetBkMode)(param_1[2]);\n        fcn.0042e955(uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetTextAlign)(param_1[2]);\n        fcn.0042edeb(uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetPolyFillMode)(param_1[2]);\n        fcn.0042e983(uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetStretchBltMode)(param_1[2]);\n        fcn.0042e9df(uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetTextColor)(param_1[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetNearestColor;\n        uVar3 = (*_sym.imp.GDI32.dll_GetNearestColor)(param_1[2], uVar3);\n        (**(*param_1 + 0x30))(uVar3);\n        uVar3 = (*_sym.imp.GDI32.dll_GetBkColor)(param_1[2]);\n        uVar3 = (*pcVar1)(param_1[2], uVar3);\n        (**(*param_1 + 0x2c))(uVar3);\n    }\n    return;\n}\n",
        "token_count": 558
    },
    "004431bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004431bb(int32_t *param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t var_90h;\n    int32_t var_84h;\n    uint var_7ch;\n    uint var_74h;\n    uint var_60h;\n    uchar var_5ch;\n    int32_t lpvObject;\n    uint var_54h;\n    uint var_48h;\n    uint var_44h;\n    uint8_t var_3dh;\n    uint lpFaceName;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint lpSize;\n    int32_t var_4h;\n    \n    if (param_1[2] != 0) {\n        if (param_1[0xb] == 0) {\n            (**(*param_1 + 0x24))(0xe);\n        }\n        else if (param_1[1] != 0) {\n            (*_sym.imp.GDI32.dll_GetObjectA)(param_1[0xb], 0x3c, &lpvObject);\n            (*_sym.imp.GDI32.dll_GetTextFaceA)(param_1[2], 0x20, &lpFaceName);\n            pcVar2 = _sym.imp.GDI32.dll_GetTextMetricsA;\n            (*_sym.imp.GDI32.dll_GetTextMetricsA)(param_1[2], &var_90h);\n            pcVar1 = _sym.imp.GDI32.dll_CreateFontIndirectA;\n            if (var_90h < 0) {\n                lpvObject = var_90h;\n            }\n            else {\n                lpvObject = var_84h - var_90h;\n            }\n            var_54h = var_7ch;\n            var_48h = var_74h;\n            var_44h._0_1_ = var_60h;\n            var_44h._1_1_ = var_60h._1_1_;\n            var_44h._2_1_ = var_60h._2_1_;\n            var_44h._3_1_ = var_5ch;\n            var_3dh = var_60h._3_1_;\n            var_18h = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(&lpvObject);\n            (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], var_18h);\n            (*pcVar2)(param_1[1], &var_90h);\n            iVar4 = -lpvObject;\n            if (var_90h < 0) {\n                var_ch = -var_90h;\n            }\n            else {\n                var_ch = var_90h - var_84h;\n            }\n            (*_sym.imp.GDI32.dll_GetWindowExtEx)(param_1[1], &lpSize);\n            (*_sym.imp.GDI32.dll_GetViewportExtEx)(param_1[1], &var_14h);\n            pcVar2 = _sym.imp.KERNEL32.dll_MulDiv;\n            if (var_4h < 0) {\n                var_4h = -var_4h;\n            }\n            if (var_10h < 0) {\n                var_10h = -var_10h;\n            }\n            var_1ch = (*_sym.imp.KERNEL32.dll_MulDiv)(iVar4, var_10h, var_4h);\n            iVar3 = (*pcVar2)(var_ch, var_10h, var_4h);\n            iVar4 = var_18h;\n            if (var_1ch < iVar3) {\n                lpFaceName._0_1_ = 0;\n                var_3dh = ((var_3dh & 0xf0) != 0x50) - 1U & 0x50;\n                iVar4 = (*pcVar1)(&lpvObject);\n                (*_sym.imp.GDI32.dll_SelectObject)(param_1[1], iVar4);\n                (*_sym.imp.GDI32.dll_DeleteObject)(var_18h);\n            }\n            fcn.0042f518(param_1 + 10);\n            param_1[10] = iVar4;\n        }\n    }\n    return;\n}\n",
        "token_count": 983
    },
    "00443b26": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00443b26(int32_t param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    \n    if (param_2 != 0) {\n        piVar1 = param_1 + 0x38;\n        (*_sym.imp.GDI32.dll_GetViewportExtEx)(*(param_1 + 8), piVar1);\n        piVar2 = param_1 + 0x30;\n        (*_sym.imp.GDI32.dll_GetWindowExtEx)(*(param_1 + 8), piVar2);\n        iVar6 = *piVar2;\n        while ((((-0x4000 < iVar6 && (*piVar2 < 0x4000)) && (iVar3 = *piVar1,  -0x4000 < iVar3)) && (iVar3 < 0x4000))) {\n            iVar6 = *piVar2 * 2;\n            *piVar2 = iVar6;\n            *piVar1 = iVar3 * 2;\n        }\n        iVar6 = *(param_1 + 0x34);\n        pcVar4 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        while (((_sym.imp.GDI32.dll_GetDeviceCaps = pcVar4,  -0x4000 < iVar6 && (*(param_1 + 0x34) < 0x4000)) &&\n               ((iVar3 = *(param_1 + 0x3c),  -0x4000 < iVar3 && (iVar3 < 0x4000))))) {\n            iVar6 = *(param_1 + 0x34) * 2;\n            *(param_1 + 0x34) = iVar6;\n            *(param_1 + 0x3c) = iVar3 * 2;\n            pcVar4 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        }\n        uVar5 = (*pcVar4)(*(param_1 + 8), 0x58);\n        iVar6 = fcn.00442d43(*piVar1, *(param_1 + 0x10), *0x460348, *(param_1 + 0x14), uVar5);\n        *piVar1 = iVar6;\n        uVar5 = (*pcVar4)(*(param_1 + 8), 0x5a);\n        uVar5 = fcn.00442d43(*(param_1 + 0x3c), *(param_1 + 0x10), *0x46034c, *(param_1 + 0x14), uVar5);\n        *(param_1 + 0x3c) = uVar5;\n    }\n    if (*(param_1 + 4) != 0) {\n        (*_sym.imp.GDI32.dll_SetMapMode)(*(param_1 + 4), 8);\n        (*_sym.imp.GDI32.dll_SetWindowExtEx)(*(param_1 + 4), *(param_1 + 0x30), *(param_1 + 0x34), 0);\n        (*_sym.imp.GDI32.dll_SetViewportExtEx)(*(param_1 + 4), *(param_1 + 0x38), *(param_1 + 0x3c), 0);\n        fcn.00443c2b();\n    }\n    return;\n}\n",
        "token_count": 768
    },
    "00443c2b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00443c2b(int32_t param_1)\n\n{\n    uint X;\n    uint var_ch;\n    int32_t lpPoint;\n    int32_t Y;\n    \n    if ((*(param_1 + 8) != 0) && (*(param_1 + 4) != 0)) {\n        (*_sym.imp.GDI32.dll_GetViewportOrgEx)(*(param_1 + 8), &lpPoint);\n        fcn.00443d2d(&lpPoint);\n        Y = Y + *(param_1 + 0x24);\n        lpPoint = lpPoint + *(param_1 + 0x20);\n        (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), lpPoint, Y, 0);\n        (*_sym.imp.GDI32.dll_GetWindowOrgEx)(*(param_1 + 8), &X);\n        (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), X, var_ch, 0);\n    }\n    return;\n}\n",
        "token_count": 234
    },
    "00443e2f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.00443e2f(void)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDocManager.0;\n    puVar1 = extraout_ECX[2];\n    *(unaff_EBP + -4) = 1;\n    while (puVar3 = puVar1,  puVar3 != NULL) {\n        puVar1 = *puVar3;\n        piVar2 = puVar3[2];\n        if ((piVar2[7] != 0) && (fcn.00424c23(puVar3),  piVar2 != NULL)) {\n            (**(*piVar2 + 4))(1);\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00424b3c();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 329
    },
    "00443ed2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00443ed2(int32_t param_1)\n\n{\n    if (*(param_1 + 0x1c) != 0) {\n        (*_sym.imp.ole32.dll_CoRegisterMessageFilter)(0, 0);\n        *(param_1 + 0x1c) = 0;\n    }\n    return;\n}\n",
        "token_count": 79
    },
    "00443eeb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00443eeb(int32_t param_1)\n\n{\n    if (*(param_1 + 0x42) != '\\0') {\n        if (*(param_1 + 0x20) != 0) {\n            (*_sym.imp.ole32.dll_CoRevokeClassObject)(*(param_1 + 0x20));\n            *(param_1 + 0x20) = 0;\n        }\n        *(param_1 + 0x42) = 0;\n    }\n    return;\n}\n",
        "token_count": 117
    },
    "0040465e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040465e(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    if (arg_ch != -1) {\n        in_ECX[3] = arg_ch;\n    }\n    if (arg_8h == 0) {\n        fcn.00425426(*in_ECX);\n        *in_ECX = 0;\n        in_ECX[1] = 0;\n        in_ECX[2] = 0;\n        return;\n    }\n    if (*in_ECX == 0) {\n        iVar1 = fcn.004253fd(arg_8h << 2);\n        *in_ECX = iVar1;\n        fcn.0040ffd0(iVar1, 0, arg_8h << 2);\n        in_ECX[1] = arg_8h;\n        in_ECX[2] = arg_8h;\n        return;\n    }\n    if (arg_8h <= in_ECX[2]) {\n        iVar1 = in_ECX[1];\n        if (iVar1 < arg_8h) {\n            fcn.0040ffd0(*in_ECX + iVar1 * 4, 0, (iVar1 * 0x3fffffff + arg_8h) * 4);\n        }\n        in_ECX[1] = arg_8h;\n        return;\n    }\n    arg_ch = in_ECX[3];\n    if (arg_ch != 0) goto code_r0x00404715;\n    arg_ch = in_ECX[1] / 8;\n    if (3 < arg_ch) {\n        if (0x400 < arg_ch) {\n            arg_ch = 0x400;\n            goto code_r0x00404715;\n        }\n        if (3 < arg_ch) goto code_r0x00404715;\n    }\n    arg_ch = 4;\ncode_r0x00404715:\n    arg_ch = arg_ch + in_ECX[2];\n    if (arg_ch <= arg_8h) {\n        arg_ch = arg_8h;\n    }\n    iVar1 = fcn.004253fd(arg_ch << 2);\n    fcn.0040fc90(iVar1, *in_ECX, in_ECX[1] << 2);\n    fcn.0040ffd0(iVar1 + in_ECX[1] * 4, 0, (in_ECX[1] * 0x3fffffff + arg_8h) * 4);\n    fcn.00425426(*in_ECX);\n    *in_ECX = iVar1;\n    in_ECX[1] = arg_8h;\n    in_ECX[2] = arg_ch;\n    return;\n}\n",
        "token_count": 609
    },
    "00404ef6": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00404ef6(uint arg_8h)\n\n{\n    double dVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    uint var_44h;\n    uint uStack68;\n    uint uStack64;\n    uint uStack60;\n    uint var_34h;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uint var_24h;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar3 = fcn.0042e1f4(arg_8h);\n    if (iVar3 != -1) {\n        if (in_ECX == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = *(in_ECX + 0x1c);\n        }\n        uVar4 = (*_sym.imp.USER32.dll_GetDC)(uVar4);\n        iVar3 = fcn.00405270(uVar4);\n        if ((iVar3 == 0) || (iVar3 = fcn.0040532c(uVar4),  pcVar2 = _sym.imp.OPENGL32.dll_glPolygonMode,  iVar3 == 0)) {\n            iVar3 = 0;\n        }\n        else {\n            (*_sym.imp.OPENGL32.dll_glPolygonMode)(0x404, 0x1b02);\n            (*pcVar2)(0x405, 0x1b02);\n            (*_sym.imp.OPENGL32.dll_glShadeModel)(0x1d01);\n            pcVar2 = _sym.imp.OPENGL32.dll_glEnable;\n            (*_sym.imp.OPENGL32.dll_glEnable)(0xba1);\n            var_24h = *0x448224;\n            uStack36 = *0x448224;\n            uStack32 = *0x448224;\n            uStack28 = 0x3f800000;\n            var_34h = *0x448220;\n            uStack52 = *0x448220;\n            uStack48 = *0x448220;\n            uStack44 = 0x3f800000;\n            var_44h = 0x3f800000;\n            uStack68 = 0x3f800000;\n            uStack64 = 0x3f800000;\n            uStack60 = 0x3f800000;\n            (*_sym.imp.OPENGL32.dll_glLightfv)(0x4000, 0x1200, &var_24h);\n            (*_sym.imp.OPENGL32.dll_glLightfv)(0x4000, 0x1201, &var_34h);\n            (*_sym.imp.OPENGL32.dll_glLightfv)(0x4000, 0x1202, &var_44h);\n            (*_sym.imp.OPENGL32.dll_glLightModelf)(0xb52, 0x3f800000);\n            (*_sym.imp.OPENGL32.dll_glClearColor)(*(in_ECX + 0x94), *(in_ECX + 0x98), *(in_ECX + 0x9c), 0x3f800000);\n            (*_sym.imp.OPENGL32.dll_glClearDepth)(0x3ff0000000000000);\n            (*_sym.imp.OPENGL32.dll_glPolygonMode)(0x408, 0x1b02);\n            (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &var_14h);\n            var_4h = var_8h - var_10h;\n            if (var_4h == 0) {\n                dVar1 = var_ch - var_14h;\n            }\n            else {\n                dVar1 = (var_ch - var_14h) / var_4h;\n            }\n            sub.GLU32.dll_gluPerspective(*0x448208, dVar1, *0x448210, *0x448218);\n            (*pcVar2)(0x4000);\n            (*pcVar2)(0xb50);\n            (*_sym.imp.OPENGL32.dll_glBlendFunc)(0x302, 0x303);\n            (*pcVar2)(0xbe2);\n            (*pcVar2)(0xb71);\n            (*pcVar2)(0xde1);\n            pcVar2 = _sym.imp.OPENGL32.dll_glTexParameterf;\n            (*_sym.imp.OPENGL32.dll_glTexParameterf)(0xde1, 0x2802, *0x448200);\n            (*pcVar2)(0xde1, 0x2803, *0x448200);\n            (*pcVar2)(0xde1, 0x2800, *0x4481fc);\n            (*pcVar2)(0xde1, 0x2801, *0x4481fc);\n            (*_sym.imp.OPENGL32.dll_glTexEnvf)(0x2300, 0x2200, *0x4481f8);\n            iVar3 = 1;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1154
    },
    "0040903c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040903c(int32_t *arg_8h, uint32_t arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    \n    puVar2 = (**(*arg_8h + 0x3c))();\n    do {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        if (*(puVar2[1] + 0x18) != -1) {\n            iVar3 = puVar2[1];\n            do {\n                if ((*(iVar3 + 4) == arg_10h[1]) && (*(iVar3 + 0x18) == (*arg_10h != 0))) {\n                    if (*(iVar3 + 0x24) == 0xffffffff) {\n                        if (*(iVar3 + 0x20) == 0xffffffff) {\n                            return iVar3;\n                        }\n                        if (*(iVar3 + 0x20) == arg_ch) {\n                            return iVar3;\n                        }\n                    }\n                    else if ((*(iVar3 + 0x20) < arg_ch || *(iVar3 + 0x20) == arg_ch) && (arg_ch <= *(iVar3 + 0x24))) {\n                        return iVar3;\n                    }\n                }\n                piVar1 = iVar3 + 0x40;\n                iVar3 = iVar3 + 0x28;\n            } while (*piVar1 != -1);\n        }\n        puVar2 = *puVar2;\n    } while( true );\n}\n",
        "token_count": 348
    },
    "0040b5e3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __cdecl fcn.0040b5e3(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = *(unaff_EBP + 0xc);\n    if ((iVar1 == 0) || (*(unaff_EBP + 8) == -1)) {\n        iVar1 = *(extraout_ECX + 0x8c);\n        *(unaff_EBP + -0x10) = 0;\n        while (iVar1 != 0) {\n            iVar3 = fcn.0040e40e();\n            if (((*(unaff_EBP + 8) == -1) || (*(iVar1 + 8) == *(unaff_EBP + 8))) &&\n               ((*(unaff_EBP + 0xc) == 0 || (*(*(unaff_EBP + 0xc) + 0x38) == *(iVar1 + 0xc))))) {\n                if (*(unaff_EBP + -0x10) == 0) {\n                    *(extraout_ECX + 0x8c) = iVar3;\n                }\n                else {\n                    *(*(unaff_EBP + -0x10) + 0x18) = iVar3;\n                }\n                if ((*(iVar1 + 0xc) != 0) && (piVar2 = *(*(iVar1 + 0xc) + 0x88),  piVar2 != NULL)) {\n                    (**(*piVar2 + 4))(iVar1, 0);\n                }\n                if (iVar1 != 0) {\n                    fcn.00425426(iVar1);\n                }\n            }\n            iVar1 = iVar3;\n            if (*(unaff_EBP + -0x10) != 0) {\n                uVar4 = fcn.0040e40e();\n                *(unaff_EBP + -0x10) = uVar4;\n            }\n        }\n    }\n    else {\n        iVar3 = fcn.004253fd(0x1c);\n        *(unaff_EBP + 0xc) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = fcn.0040e3cb(*(extraout_ECX + 0x8c), *(unaff_EBP + 8), 0);\n        }\n        *(extraout_ECX + 0x8c) = iVar3;\n        *(iVar3 + 0xc) = *(iVar1 + 0x38);\n        piVar2 = *(extraout_ECX + 0x8c);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *piVar2 = extraout_ECX;\n        (**(**(*(extraout_ECX + 0x8c) + 0xc) + 0xb0))();\n        (**(**(*(*(extraout_ECX + 0x8c) + 0xc) + 0x88) + 4))(*(extraout_ECX + 0x8c), 1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 822
    },
    "00424267": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424267(uint arg_8h, uint *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t *in_ECX;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_2ch;\n    int32_t var_ch;\n    int32_t var_8h;\n    \n    puVar1 = arg_ch;\n    puVar3 = &var_2ch;\n    for (iVar2 = 0xb; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = *puVar1;\n        puVar1 = puVar1 + 1;\n        puVar3 = puVar3 + 1;\n    }\n    if (((var_ch == 0) && (var_8h != -1)) && (var_8h != 0)) {\n        iVar2 = fcn.0042533d(var_8h, &arg_ch);\n        if (iVar2 == 0) {\n            puVar1 = fcn.00425381(var_8h);\n            *puVar1 = 0;\n        }\n        fcn.0042535f(var_8h, &var_8h);\n    }\n    (**(*in_ECX + 0xa0))(0x404, arg_8h, &var_2ch);\n    return;\n}\n",
        "token_count": 297
    },
    "00424cdd": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424cdd(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    if (arg_ch != -1) {\n        *(in_ECX + 0x10) = arg_ch;\n    }\n    if (arg_8h == 0) {\n        fcn.00425426(*(in_ECX + 4));\n        *(in_ECX + 4) = 0;\n        *(in_ECX + 0xc) = 0;\n        *(in_ECX + 8) = 0;\n        return;\n    }\n    if (*(in_ECX + 4) == 0) {\n        uVar1 = fcn.004253fd(arg_8h << 2);\n        *(in_ECX + 4) = uVar1;\n        fcn.0040ffd0(uVar1, 0, arg_8h << 2);\n        *(in_ECX + 0xc) = arg_8h;\ncode_r0x00424d34:\n        *(in_ECX + 8) = arg_8h;\n        return;\n    }\n    if (arg_8h <= *(in_ECX + 0xc)) {\n        iVar2 = *(in_ECX + 8);\n        if (iVar2 < arg_8h) {\n            fcn.0040ffd0(*(in_ECX + 4) + iVar2 * 4, 0, (iVar2 * 0x3fffffff + arg_8h) * 4);\n        }\n        goto code_r0x00424d34;\n    }\n    arg_ch = *(in_ECX + 0x10);\n    if (arg_ch != 0) goto code_r0x00424d92;\n    arg_ch = *(in_ECX + 8) / 8;\n    if (3 < arg_ch) {\n        if (0x400 < arg_ch) {\n            arg_ch = 0x400;\n            goto code_r0x00424d92;\n        }\n        if (3 < arg_ch) goto code_r0x00424d92;\n    }\n    arg_ch = 4;\ncode_r0x00424d92:\n    arg_ch = arg_ch + *(in_ECX + 0xc);\n    if (arg_ch <= arg_8h) {\n        arg_ch = arg_8h;\n    }\n    iVar2 = fcn.004253fd(arg_ch << 2);\n    fcn.0040fc90(iVar2, *(in_ECX + 4), *(in_ECX + 8) << 2);\n    fcn.0040ffd0(iVar2 + *(in_ECX + 8) * 4, 0, (*(in_ECX + 8) * 0x3fffffff + arg_8h) * 4);\n    fcn.00425426(*(in_ECX + 4));\n    *(in_ECX + 4) = iVar2;\n    *(in_ECX + 8) = arg_8h;\n    *(in_ECX + 0xc) = arg_ch;\n    return;\n}\n",
        "token_count": 691
    },
    "00425110": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00425110(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 == 0xffffffff) {\n        uVar4 = 0;\n        if (*(param_1 + 8) != 0) {\n            ppiVar1 = *(param_1 + 4);\n            do {\n                piVar3 = *ppiVar1;\n                if (piVar3 != NULL) break;\n                uVar4 = uVar4 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar4 < *(param_1 + 8));\n        }\n    }\n    piVar5 = *piVar3;\n    if (piVar5 == NULL) {\n        uVar4 = *(param_1 + 8);\n        uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n        if (uVar2 < uVar4) {\n            ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n            do {\n                piVar5 = *ppiVar1;\n                if (piVar5 != NULL) break;\n                uVar2 = uVar2 + 1;\n                ppiVar1 = ppiVar1 + 1;\n            } while (uVar2 < uVar4);\n        }\n    }\n    *param_2 = piVar5;\n    *param_3 = piVar3[1];\n    *param_4 = piVar3[2];\n    return;\n}\n",
        "token_count": 411
    },
    "0042a763": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a763(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.0042a301();\n    if (param_2 == -1) {\n        param_2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*param_1);\n    }\n    *(*param_1 + -8) = param_2;\n    *(*param_1 + param_2) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "0042ae18": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042ae18(uint lpFileName, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint uVar3;\n    uint uVar4;\n    char cVar5;\n    uint uVar6;\n    uint var_110h;\n    uint lpSecurityAttributes;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    *(in_ECX + 8) = 0;\n    *(in_ECX + 4) = 0xffffffff;\n    fcn.0042a2e3();\n    fcn.0042b4a0(&var_110h, lpFileName);\n    fcn.0042a4e1(&var_110h);\n    uVar3 = 0;\n    uVar1 = arg_ch & 3;\n    if (uVar1 == 0) {\n        uVar3 = 0x80000000;\n    }\n    else if (uVar1 == 1) {\n        uVar3 = 0x40000000;\n    }\n    else if (uVar1 == 2) {\n        uVar3 = 0xc0000000;\n    }\n    uVar1 = arg_ch & 0x70;\n    uVar4 = 1;\n    if ((uVar1 != 0) && (uVar1 != 0x10)) {\n        uVar6 = uVar4;\n        if (uVar1 == 0x20) goto code_r0x0042aeaf;\n        if (uVar1 == 0x30) {\n            uVar6 = 2;\n            goto code_r0x0042aeaf;\n        }\n        if (uVar1 == 0x40) {\n            uVar6 = 3;\n            goto code_r0x0042aeaf;\n        }\n    }\n    uVar6 = 0;\ncode_r0x0042aeaf:\n    var_8h = 0;\n    var_4h = ~(arg_ch & 0xffff7fff) >> 7 & 1;\n    lpSecurityAttributes = 0xc;\n    if ((arg_ch & 0x1000) == 0) {\n        cVar5 = '\\x03';\n    }\n    else {\n        cVar5 = (-((arg_ch & 0x2000) != 0) & 2U) + 2;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateFileA)(lpFileName, uVar3, uVar6, &lpSecurityAttributes, cVar5, 0x80, 0);\n    if (iVar2 == -1) {\n        if (arg_10h != 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            *(arg_10h + 0xc) = uVar3;\n            uVar3 = fcn.0042aa88(uVar3);\n            *(arg_10h + 8) = uVar3;\n            fcn.0042a4e1(lpFileName);\n        }\n        uVar4 = 0;\n    }\n    else {\n        *(in_ECX + 4) = iVar2;\n        *(in_ECX + 8) = 1;\n    }\n    return uVar4;\n}\n",
        "token_count": 732
    },
    "0042b033": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042b033(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar3 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.0042a2e3();\n    if (bVar3) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0042a95c(uVar2);\n    }\n    return;\n}\n",
        "token_count": 180
    },
    "0042b074": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042b074(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        *(param_1 + 4) = 0xffffffff;\n    }\n    fcn.0042a2e3();\n    return;\n}\n",
        "token_count": 85
    },
    "0042b4a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpFindFileData\n\nuint __cdecl fcn.0042b4a0(uint lpRootPathName, uint lpFileName)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpFindFileData;\n    uint lpString2;\n    uint var_18h;\n    uint lpFilePart;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar1 = *(unaff_EBP + 8);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, uVar1, unaff_EBP + -0x14);\n    if (iVar2 == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, *(unaff_EBP + 0xc), 0x104);\n        uVar3 = 0;\n    }\n    else {\n        *(unaff_EBP + 8) = *0x45c084;\n        uVar3 = 0;\n        *(unaff_EBP + -4) = 0;\n        fcn.0042b570(uVar1, unaff_EBP + 8);\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                          (*(unaff_EBP + 8), 0, 0, 0, unaff_EBP + -0x18, unaff_EBP + -0x10, 0, 0);\n        if (iVar2 != 0) {\n            if ((*(unaff_EBP + -0x10) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(uVar1);\n            }\n            if ((*(unaff_EBP + -0x10) & 4) == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + 0xc), unaff_EBP + -0x158);\n                if (iVar2 != -1) {\n                    (*_sym.imp.KERNEL32.dll_FindClose)(iVar2);\n                    (*_sym.imp.KERNEL32.dll_lstrcpyA)(*(unaff_EBP + -0x14), unaff_EBP + -300);\n                }\n            }\n            uVar3 = 1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042a358();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 601
    },
    "0042e1f4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042e1f4(uint param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004258c7();\n    if (iVar1 != -1) {\n        if ((*param_2 != 0) && (*(*param_2 + 4) != 0)) {\n            fcn.0042e080(param_1);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 114
    },
    "004304a8": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004304a8(int32_t param_1)\n\n{\n    fcn.004258c7();\n    if (*(param_1 + 0x40) == -1) {\n        fcn.00430220(*(param_1 + 0x44), *(param_1 + 0x48));\n    }\n    else {\n        fcn.00430700();\n    }\n    return;\n}\n",
        "token_count": 91
    },
    "00434507": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.00434507(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t arg_10h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042bdd1(*(unaff_EBP + 8));\n    arg_10h_00 = *(unaff_EBP + 0x10);\n    if (arg_10h_00 == -1) {\n        arg_10h_00 = *(unaff_EBP + 8);\n    }\n    uVar1 = fcn.004344cf(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), arg_10h_00);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 325
    },
    "0043822a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043822a(int32_t *param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004258c7();\n    if ((iVar1 != -1) && (iVar1 = (**(*param_1 + 0xdc))(param_2, param_3),  iVar1 != 0)) {\n        (*_sym.imp.USER32.dll_PostMessageA)(param_1[7], 0x362, 0xe001, 0);\n        (**(*param_1 + 200))(1);\n        return 0;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 148
    },
    "0043bdee": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.0043bdee(void)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    \n    iVar4 = *0x45bed4;\n    if (*0x45bed4 == -1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"DllGetVersion\");\n        iVar4 = 0x40000;\n        if (pcVar2 != NULL) {\n            fcn.0040ffd0(&var_14h, 0, 0x14);\n            var_14h = 0x14;\n            iVar3 = (*pcVar2)(&var_14h);\n            if (-1 < iVar3) {\n                iVar4 = CONCAT22(var_10h, var_ch);\n            }\n        }\n    }\n    *0x45bed4 = iVar4;\n    return iVar4;\n}\n",
        "token_count": 258
    },
    "0043be5c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.0043be5c(void)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    \n    if (*0x45bed8 == -1) {\n        uVar2 = (*_sym.imp.USER32.dll_GetDC)(0);\n        uVar3 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x48, 0, 0, 0, 400, 0, 0, 0, 2, 0, 0, 0, 0, \"Marlett\");\n        iVar4 = (*_sym.imp.GDI32.dll_CreateFontA)(uVar3);\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        if (iVar4 != 0) {\n            iVar4 = (*_sym.imp.GDI32.dll_SelectObject)(uVar2, iVar4);\n        }\n        (*_sym.imp.GDI32.dll_GetCharWidthA)(uVar2, 0x36, 0x36, 0x45bed8);\n        if (iVar4 != 0) {\n            (*pcVar1)(uVar2, iVar4);\n            (*_sym.imp.GDI32.dll_DeleteObject)(iVar4);\n        }\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar2);\n    }\n    return *0x45bed8;\n}\n",
        "token_count": 305
    },
    "0043dc1d": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.0043dc1d(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar1;\n    if (iVar1 == -1) {\n        fcn.00423259();\n    }\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 + 7);\n    return param_1;\n}\n",
        "token_count": 181
    },
    "0043dc5f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043dc5f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.0043df2b(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 232
    },
    "0041f1d0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nint32_t fcn.0041f1d0(uint param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0041f1b0(param_1);\n    if (iVar1 == 0) {\n        iVar1 = *0x462d70;\n        if (param_2 != 6) {\n            iVar1 = *(param_2 * 0x18 + 0x462ce4);\n        }\n        (*_sym.imp.USER32.dll_SetPropA)(param_1, *0x46228e, iVar1);\n    }\n    return iVar1;\n}\n",
        "token_count": 140
    },
    "00439a63": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00439a63(int32_t param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    if ((((param_2 != 0) && (param_2 != 6)) && (param_2 != 7)) && ((param_2 != 8 && (param_2 != 4)))) {\n        uVar1 = (*_sym.imp.USER32.dll_GetLastActivePopup)(*(param_1 + 0x1c));\n        (*_sym.imp.USER32.dll_BringWindowToTop)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 132
    },
    "0041fca0": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041fca0(uint32_t param_1, uint param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint16_t extraout_var;\n    uint32_t uVar3;\n    uint uVar4;\n    uchar *puVar5;\n    \n    iVar2 = fcn.0041f1b0(param_1);\n    if (iVar2 == 0) {\n        fcn.00420db0(param_1, param_2, 0, param_3);\n        return;\n    }\n    iVar2 = (*_sym.imp.USER32.dll_GetPropA)(param_1, *0x462294);\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (iVar2 == 0) {\n        uVar4 = 0x1944;\n        uVar3 = param_1;\n        puVar5 = &stack0xfffffff4;\n        (*_sym.imp.USER32.dll_SendMessageA)(param_1, 0x1944, 0);\n        if (puVar5 == 0x29a) {\n            (*pcVar1)(param_1, 0x1943, 0);\n            if (&stack0xfffffff4 == 0x29a) {\n                (*_sym.imp.USER32.dll_RemovePropA)(param_1, *0x46228e);\n                fcn.00420db0(param_1, uVar3 & 0xffff | extraout_var << 0x10, 0, uVar4);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 352
    },
    "00422750": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint fcn.00422750(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    uint32_t unaff_EBX;\n    uint32_t unaff_EBP;\n    uint32_t unaff_ESI;\n    uint32_t unaff_EDI;\n    uint *puVar8;\n    uint32_t uStack4;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_FindResourceA)(param_1, param_2);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_SizeofResource)(param_1, iVar1);\n    puVar3 = (*_sym.imp.KERNEL32.dll_LoadResource)(param_1, iVar1);\n    if (puVar3 == NULL) {\n        return 0;\n    }\n    puVar4 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x40, uVar2);\n    if (puVar4 == NULL) {\n        return 0;\n    }\n    puVar8 = puVar4;\n    for (uVar7 = uVar2 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar8 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {\n        *puVar8 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    puVar4[10] = 0x20000;\n    puVar4[0x11] = (unaff_EDI >> 8 & 0xff) << 8 | unaff_EDI >> 0x10 & 0xff | (unaff_EDI & 0xff) << 0x10;\n    puVar4[0x12] = (unaff_EBP >> 8 & 0xff) << 8 | unaff_EBP >> 0x10 & 0xff | (unaff_EBP & 0xff) << 0x10;\n    puVar4[0x19] = (unaff_ESI >> 8 & 0xff) << 8 | (unaff_ESI & 0xff) << 0x10 | unaff_ESI >> 0x10 & 0xff;\n    puVar4[0x15] = (unaff_EBX >> 8 & 0xff) << 8 | (unaff_EBX & 0xff) << 0x10 | unaff_EBX >> 0x10 & 0xff;\n    puVar4[0x14] = (uStack4 >> 8 & 0xff) << 8 | (uStack4 & 0xff) << 0x10 | uStack4 >> 0x10 & 0xff;\n    uVar5 = (*_sym.imp.USER32.dll_GetDC)(0);\n    uVar6 = (*_sym.imp.GDI32.dll_CreateDIBitmap)(uVar5, puVar4, 4, puVar4 + 0x1a, puVar4, 0);\n    (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar5);\n    (*_sym.imp.KERNEL32.dll_GlobalFree)(puVar4);\n    return uVar6;\n}\n",
        "token_count": 814
    },
    "0040f8ac": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040f8ac(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.004133dd(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 104
    },
    "00406c26": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406c26(uint *param_1)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    \n    uVar4 = 0;\n    if (param_1[0xe] == 0) {\n        (***param_1)();\n    }\n    uVar1 = param_1[2];\n    if (uVar1 != 0) {\n        do {\n            piVar2 = *(param_1[1] + uVar4 * 4);\n            iVar3 = (**(*piVar2 + 4))();\n            if ((iVar3 == 5) && (-1 < piVar2[0x2a])) {\n                (*_sym.imp.OPENGL32.dll_glBindTexture)(0xde1, *(param_1[0xd] + piVar2[0x2a] * 4));\n            }\n            (**(*piVar2 + 0xc))();\n            uVar4 = uVar4 + 1;\n        } while (uVar4 < uVar1);\n    }\n    return;\n}\n",
        "token_count": 248
    },
    "00406cba": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406cba(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar1 = *(param_1 + 8);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar4 = 0;\n        if (0 < iVar1) {\n            do {\n                iVar3 = (**(**(*(param_1 + 4) + iVar4 * 4) + 4))();\n                if (iVar3 == 5) {\n                    fcn.00403704();\n                }\n                iVar4 = iVar4 + 1;\n            } while (iVar4 < iVar1);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 185
    },
    "00406cf7": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406cf7(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar1 = *(param_1 + 8);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar4 = 0;\n        if (0 < iVar1) {\n            do {\n                iVar3 = (**(**(*(param_1 + 4) + iVar4 * 4) + 4))();\n                if (iVar3 == 5) {\n                    fcn.0040390c();\n                }\n                iVar4 = iVar4 + 1;\n            } while (iVar4 < iVar1);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 187
    },
    "00406d34": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00406d34(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar1 = *(param_1 + 8);\n    if (iVar1 == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar4 = 0;\n        if (0 < iVar1) {\n            do {\n                iVar3 = (**(**(*(param_1 + 4) + iVar4 * 4) + 4))();\n                if (iVar3 == 5) {\n                    fcn.004039bf();\n                }\n                iVar4 = iVar4 + 1;\n            } while (iVar4 < iVar1);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 186
    },
    "00406d71": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00406d71(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = 0;\n    iVar1 = *(param_1 + 8);\n    if (0 < iVar1) {\n        do {\n            iVar2 = (**(**(*(param_1 + 4) + iVar3 * 4) + 4))();\n            if (iVar2 == 5) {\n                fcn.004039f9();\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < iVar1);\n    }\n    return;\n}\n",
        "token_count": 145
    },
    "00406e16": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n\nuint __cdecl fcn.00406e16(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    uint var_34h;\n    uint var_20h;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar2 = 0;\n    if (*(extraout_ECX + 8) == 0) {\n        fcn.004344cf(\"This scene does not contain meshes\", 0, 0);\n        uVar2 = 0;\n    }\n    else {\n        fcn.0042b7a9();\n        *(unaff_EBP + -4) = 0;\n        fcn.0042a883();\n        *(unaff_EBP + -0x10) = *0x45c084;\n        *(unaff_EBP + -0x14) = 0xffffffff;\n        *(unaff_EBP + -4) = 2;\n        *(unaff_EBP + -0x20) = vtable.CFileException.0;\n        *(unaff_EBP + -0x18) = 0;\n        fcn.0042a4e1(0);\n        *(unaff_EBP + -4) = 3;\n        iVar1 = fcn.00406f14(unaff_EBP + -0x34, *(unaff_EBP + 8));\n        if (iVar1 == 0) {\n            fcn.004344cf(\"Error during writing header\", 0, 0);\n            *(unaff_EBP + -0x20) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 4;\n        }\n        else {\n            iVar1 = *(extraout_ECX + 8);\n            *(unaff_EBP + 8) = 0;\n            if (0 < iVar1) {\n                do {\n                    iVar1 = (**(**(*(extraout_ECX + 4) + *(unaff_EBP + 8) * 4) + 4))();\n                    if (iVar1 == 5) {\n                        fcn.0040427f();\n                    }\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + 1;\n                } while (*(unaff_EBP + 8) < *(extraout_ECX + 8));\n            }\n            fcn.0042bb4e();\n            *(unaff_EBP + -0x20) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 5;\n            uVar2 = 1;\n        }\n        fcn.0042a358();\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042b7db();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 692
    },
    "0040569f": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_70h\n// WARNING: Variable defined which should be unmapped: hdc\n\nuint __cdecl fcn.0040569f(uint nXPos)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    code *pcVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t extraout_ECX;\n    int32_t iVar8;\n    int32_t unaff_EBP;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint *in_FS_OFFSET;\n    uint var_70h;\n    uint hdc;\n    uint var_5ch;\n    uint var_58h;\n    uint var_4ch;\n    uint var_48h;\n    uint lpRect;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint nYPos;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x2c) = extraout_ECX;\n    fcn.00428cea();\n    (*_sym.imp.USER32.dll_GetClientRect)(*(extraout_ECX + 0x1c), unaff_EBP + -0x3c);\n    iVar10 = *(unaff_EBP + -0x34) - *(unaff_EBP + -0x3c);\n    piVar1 = *(unaff_EBP + 8);\n    iVar9 = *(unaff_EBP + -0x30) - *(unaff_EBP + -0x38);\n    *piVar1 = iVar10;\n    piVar1[1] = iVar9;\n    uVar5 = fcn.004253fd(iVar10 * iVar9 * 3);\n    *(unaff_EBP + -0x1c) = uVar5;\n    pcVar4 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(extraout_ECX + 0x1c), unaff_EBP + -0x4c);\n    iVar6 = fcn.0043d8de();\n    uVar5 = *(*(iVar6 + 4) + 0x1c);\n    *(unaff_EBP + 8) = uVar5;\n    fcn.0042f09a(uVar5);\n    *(unaff_EBP + -4) = 0;\n    (*pcVar4)(*(*(unaff_EBP + 8) + 0x1c), unaff_EBP + -0x5c);\n    iVar6 = *(unaff_EBP + -0x4c);\n    iVar7 = *(unaff_EBP + -0x48) - *(unaff_EBP + -0x58);\n    iVar2 = *(unaff_EBP + -0x5c);\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x24) = iVar7;\n    if (0 < iVar9) {\n        *(unaff_EBP + -0x28) = iVar10 * -3;\n        iVar8 = (iVar9 * 3 + -3) * iVar10 + 2 + *(unaff_EBP + -0x1c);\n        *(unaff_EBP + -0x18) = iVar8;\n        do {\n            *(unaff_EBP + 8) = 0;\n            if (0 < iVar10) {\n                *(unaff_EBP + -0x14) = iVar8;\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x10) + iVar7;\n                do {\n                    uVar5 = (*_sym.imp.GDI32.dll_GetPixel)\n                                      (*(unaff_EBP + -0x6c), *(unaff_EBP + 8) + (iVar6 - iVar2), *(unaff_EBP + -0x20));\n                    puVar3 = *(unaff_EBP + -0x14);\n                    puVar3[-2] = uVar5 >> 0x10;\n                    *(unaff_EBP + 8) = *(unaff_EBP + 8) + 1;\n                    puVar3[-1] = uVar5 >> 8;\n                    *puVar3 = uVar5;\n                    *(unaff_EBP + -0x14) = puVar3 + 3;\n                } while (*(unaff_EBP + 8) < iVar10);\n                iVar7 = *(unaff_EBP + -0x24);\n            }\n            *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 1;\n            iVar8 = *(unaff_EBP + -0x18) + *(unaff_EBP + -0x28);\n            *(unaff_EBP + -0x18) = iVar8;\n        } while (*(unaff_EBP + -0x10) < iVar9);\n    }\n    fcn.00428cff();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042f10c();\n    uVar5 = *(unaff_EBP + -0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 1229
    },
    "0040efc5": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t fcn.0040efc5(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x400, 0, 0);\n    if (uVar1 >> 0x10 == 0x534b) {\n        uVar1 = uVar1 & 0xffff;\n    }\n    else {\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 121
    },
    "00425892": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.00425892(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.0043e01d(0x43b7dd);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x44) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x48) = uVar2;\n    *(iVar1 + 0x4c) = uVar2 >> 0x10;\n    return iVar1 + 0x34;\n}\n",
        "token_count": 141
    },
    "00425a41": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00425a41(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint hWnd)\n\n{\n    uint uVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint arg_8h;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar4;\n    uint Msg;\n    uint wParam;\n    uint lParam;\n    uint var_10h;\n    uint var_30h;\n    uint var_1ch;\n    uint lpPrevWndFunc;\n    uint var_14h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffb4;\n    uVar1 = (*_sym.imp.USER32.dll_GetPropA)(uVar2, \"AfxOldWndProc423\");\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x18) = uVar1;\n    iVar3 = *(unaff_EBP + 0xc);\n    bVar4 = true;\n    if (iVar3 == 6) {\n        uVar1 = fcn.00425960(*(unaff_EBP + 0x14));\n        arg_8h = fcn.00425960(uVar2);\n        fcn.004256c8(arg_8h, *(unaff_EBP + 0x10), uVar1);\ncode_r0x00425b45:\n        if (!bVar4) goto code_r0x00425ad2;\n    }\n    else {\n        if (iVar3 == 0x20) {\n            uVar1 = fcn.00425960(uVar2);\n            iVar3 = fcn.00425729(uVar1, *(unaff_EBP + 0x14), *(unaff_EBP + 0x14) >> 0x10);\n            bVar4 = iVar3 == 0;\n            goto code_r0x00425b45;\n        }\n        if (iVar3 == 0x82) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(uVar2, 0xfffffffc, *(unaff_EBP + -0x18));\n            (*_sym.imp.USER32.dll_RemovePropA)(uVar2, \"AfxOldWndProc423\");\n            uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFindAtomA)(\"AfxOldWndProc423\");\n            (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar1);\n        }\n        else if (iVar3 == 0x110) {\n            uVar1 = fcn.00425960(uVar2);\n            fcn.0042562c(uVar1, unaff_EBP + -0x30, unaff_EBP + -0x1c);\n            uVar2 = (*_sym.imp.USER32.dll_CallWindowProcA)\n                              (*(unaff_EBP + -0x18), uVar2, 0x110, *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n            *(unaff_EBP + -0x14) = uVar2;\n            fcn.0042564f(uVar1, unaff_EBP + -0x30);\n            goto code_r0x00425ad2;\n        }\n    }\n    uVar2 = (*_sym.imp.USER32.dll_CallWindowProcA)\n                      (*(unaff_EBP + -0x18), uVar2, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n    *(unaff_EBP + -0x14) = uVar2;\ncode_r0x00425ad2:\n    uVar2 = *(unaff_EBP + -0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 1001
    },
    "00426d89": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00426d89(uint32_t arg_8h, int32_t arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    uint32_t uVar3;\n    uint var_2ch;\n    uint32_t var_28h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h & 0xffff;\n    arg_8h = arg_8h >> 0x10;\n    if (arg_ch == 0) {\n        if (uVar3 == 0) {\n            return 0;\n        }\n        fcn.00426d5c();\n        var_28h = uVar3;\n        (**(*in_ECX + 0xc))(uVar3, 0xffffffff, &var_2ch, 0);\n        if (var_4h != 0) {\n            arg_8h = 0;\ncode_r0x00426dcd:\n            uVar1 = (**(*in_ECX + 0xc))(uVar3, arg_8h, 0, 0);\n            return uVar1;\n        }\n    }\n    else {\n        iVar2 = fcn.0043e01d(0x43b7dd);\n        if ((*(iVar2 + 0xb8) != in_ECX[7]) && (iVar2 = fcn.004276e0(arg_ch, 0),  iVar2 == 0)) {\n            if (uVar3 == 0) {\n                return 0;\n            }\n            goto code_r0x00426dcd;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 365
    },
    "004277df": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004277df(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t *arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h < 0x112) {\n        if (arg_8h == 0x111) {\n            iVar2 = fcn.00428bcd(0, arg_ch >> 0x10 | 0xbd110000, 0, 0);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            if (arg_14h != NULL) {\n                *arg_14h = 1;\n                return 1;\n            }\n            return 1;\n        }\n        if (0x2a < arg_8h) {\n            if ((arg_8h < 0x30) || (arg_8h == 0x39)) goto code_r0x00427873;\n            if (arg_8h == 0x4e) {\n                var_8h = arg_14h;\n                var_4h = arg_10h;\n                uVar1 = fcn.00428bcd(0, *(arg_10h + 8) & 0xffff | 0xbc4e0000, &var_8h, 0);\n                return uVar1;\n            }\n        }\n    }\n    else if ((0x113 < arg_8h) && ((arg_8h < 0x116 || (arg_8h == 0x210)))) {\ncode_r0x00427873:\n        uVar1 = fcn.004267ea(arg_8h + 0xbc00, arg_ch, arg_10h, arg_14h);\n        return uVar1;\n    }\n    if ((0x131 < arg_8h) && (arg_8h < 0x139)) {\n        var_4h = arg_8h - 0x132;\n        var_8h = arg_ch;\n        uVar1 = fcn.004267ea(0xbc19, 0, &var_ch, arg_14h);\n        if (*arg_14h != 0) {\n            return uVar1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 528
    },
    "00429edd": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint fcn.00429edd(int32_t param_1)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    if ((((*(param_1 + 4) == 0x100) && (*(param_1 + 8) == 0x70)) && ((*(param_1 + 0xc) >> 0x10 & 0x4000) == 0)) &&\n       (((iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x10),  -1 < iVar2 && (iVar2 = (*pcVar1)(0x11),  -1 < iVar2)) &&\n        (iVar2 = (*pcVar1)(0x12),  -1 < iVar2)))) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 189
    },
    "0042a3c6": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042a3c6(uint *param_1, uint32_t param_2)\n\n{\n    int32_t arg_10h;\n    \n    *param_1 = *0x45c084;\n    if (param_2 != 0) {\n        if (param_2 >> 0x10 == 0) {\n            fcn.0042bdd1(param_2 & 0xffff);\n        }\n        else {\n            arg_10h = (*_sym.imp.KERNEL32.dll_lstrlenA)(param_2);\n            if (arg_10h != 0) {\n                fcn.0042a1c5(arg_10h);\n                fcn.0040fc90(*param_1, param_2, arg_10h);\n            }\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 184
    },
    "004314a5": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004314a5(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    int32_t in_ECX;\n    uint var_14h;\n    char var_ch;\n    uint var_bh;\n    \n    fcn.004312d1(arg_8h, &var_14h);\n    cVar1 = arg_ch >> 0x10;\n    if ((var_bh != arg_ch) || (var_ch != cVar1)) {\n        var_ch = cVar1;\n        var_bh._0_1_ = arg_ch;\n        fcn.004312f0(arg_8h, &var_14h);\n        *(in_ECX + 0x84) = 1;\n    }\n    return;\n}\n",
        "token_count": 175
    },
    "00431e00": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00431e00(int32_t *arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint uVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 0;\n    uVar2 = 0;\n    if (0x40046 < *0x45bed4) {\n        uVar2 = fcn.00428783();\n        iVar3 = fcn.004287b7(0, 0x8800, 0);\n    }\n    iVar1 = fcn.004258c7();\n    if (iVar1 != 0) {\n        *arg_8h = arg_ch;\n        arg_8h[1] = arg_ch >> 0x10;\n    }\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetWindowLongA)(*(in_ECX + 0x1c), 0xfffffff0, uVar2);\n    }\n    return iVar1;\n}\n",
        "token_count": 234
    },
    "00432d5c": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.00432d5c(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(*(param_1 + 0x80) + param_2 * 4);\n    return uVar1 & -(uVar1 >> 0x10 != 0);\n}\n",
        "token_count": 83
    },
    "0043b872": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.0043b872(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint lpvBits;\n    int32_t nHeight;\n    int32_t var_8h;\n    uint8_t *var_4h;\n    \n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    nHeight = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < nHeight) {\n        nHeight = 0x20;\n    }\n    fcn.0040ffd0(&lpvBits, 0xff, 0x80);\n    var_4h = 0x449354;\n    var_8h = 5;\n    puVar4 = &lpvBits + (nHeight + -6 >> 1) * iVar6 * 2;\n    do {\n        uVar1 = *var_4h;\n        uVar3 = var_4h & 0xffff0000;\n        var_4h = var_4h + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        puVar4[1] = uVar3;\n        *puVar4 = uVar3 >> 8;\n        puVar4 = puVar4 + iVar6 * 2;\n        var_8h = var_8h + -1;\n    } while (var_8h != 0);\n    *0x460380 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, nHeight, 1, 1, &lpvBits);\n    if (*0x460380 == 0) {\n        *0x460380 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    return;\n}\n",
        "token_count": 525
    },
    "004058a9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n\nuint fcn.004058a9(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *extraout_ECX;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_18h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &stack0xffffffc4;\n    fcn.0042a4e1(*(unaff_EBP + 8));\n    fcn.0042ad06();\n    uVar3 = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a883();\n    *(unaff_EBP + -0x2c) = *0x45c084;\n    *(unaff_EBP + -0x30) = 0xffffffff;\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n    *(unaff_EBP + -0x34) = 0;\n    fcn.0042a4e1(0);\n    *(unaff_EBP + -4) = 3;\n    iVar1 = fcn.0042ae18(*(unaff_EBP + 8), 0x8000, unaff_EBP + -0x3c);\n    if (iVar1 == 0) {\n        *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n        *(unaff_EBP + -4) = 4;\n    }\n    else {\n        uVar2 = fcn.0042b112();\n        *extraout_ECX = uVar2;\n        iVar1 = fcn.004253fd(uVar2);\n        extraout_ECX[1] = iVar1;\n        if (iVar1 == 0) {\n            *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 5;\n        }\n        else {\n            fcn.0042a900();\n            uVar3 = *extraout_ECX;\n            *(unaff_EBP + -4) = 7;\n            fcn.0042af35(extraout_ECX[1], uVar3);\n            *(unaff_EBP + -4) = 3;\n            fcn.0042a93e();\n            fcn.0042b033();\n            *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 10;\n            uVar3 = 1;\n        }\n    }\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042ad5b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 758
    },
    "00407599": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3ch\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n\nuint fcn.00407599(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_28h;\n    uint var_10h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_18h;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &stack0xffffffc4;\n    fcn.0042ad06();\n    uVar3 = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a883();\n    *(unaff_EBP + -0x2c) = *0x45c084;\n    *(unaff_EBP + -0x30) = 0xffffffff;\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n    *(unaff_EBP + -0x34) = 0;\n    fcn.0042a4e1(0);\n    *(unaff_EBP + -4) = 3;\n    iVar2 = fcn.0042ae18(*(unaff_EBP + 8), 0x8000, unaff_EBP + -0x3c);\n    if (iVar2 == 0) {\n        fcn.004344cf(\"Unable to open file for reading\", 0, 0);\n        *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n        *(unaff_EBP + -4) = 4;\n    }\n    else {\n        iVar2 = fcn.0040710c(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        if (iVar2 == 0) {\n            fcn.004344cf(\"Insuffisant memory\", 0, 0);\n            fcn.0042b033();\n            *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 5;\n        }\n        else {\n            fcn.0042a900();\n            iVar2 = *(extraout_ECX + 0xc);\n            iVar1 = *(extraout_ECX + 8);\n            *(unaff_EBP + -4) = 7;\n            fcn.0042af35(*(extraout_ECX + 4), iVar2 * iVar1 * *(unaff_EBP + 0x14) >> 3);\n            *(unaff_EBP + -4) = 3;\n            fcn.0042a93e();\n            fcn.0042b033();\n            fcn.0042a4e1(*(unaff_EBP + 8));\n            *(unaff_EBP + -0x3c) = vtable.CFileException.0;\n            *(unaff_EBP + -4) = 10;\n            uVar3 = 1;\n        }\n    }\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042ad5b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 862
    },
    "0041e585": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3ch\n\ncode ** __cdecl fcn.0041e585(uint arg_8h)\n\n{\n    uchar *arg_8h_00;\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_3ch;\n    uint var_20h;\n    uint var_14h;\n    uint var_dh;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x20) = *(unaff_EBP + -0xd);\n    fcn.00402f1c(0);\n    uVar1 = fcn.004101b0(\"string too long\");\n    fcn.00402f58(\"string too long\", uVar1);\n    *(unaff_EBP + -4) = 0;\n    fcn.0041e5df(unaff_EBP + -0x20);\n    *(unaff_EBP + -0x3c) = vtable.std::length_error.0;\n    fcn.0041101e(unaff_EBP + -0x3c, 0x454df8);\n    fcn.0040fbf4();\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(unaff_EBP + -0x10) = 0x45e614;\n    fcn.00422cee(unaff_EBP + -0x10);\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 3) = *arg_8h_00;\n    fcn.00402f1c(0);\n    fcn.00402e4e(arg_8h_00, 0, *0x447b64);\n    uVar1 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::logic_error.0;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 473
    },
    "0041e7b1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_3ch\n\nvoid fcn.0041e7b1(void)\n\n{\n    uint uVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    int32_t arg_8h;\n    uint var_3ch;\n    uint var_20h;\n    uint var_dh;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x20) = *(unaff_EBP + -0xd);\n    fcn.00402f1c(0);\n    uVar1 = fcn.004101b0(\"invalid string position\");\n    fcn.00402f58(\"invalid string position\", uVar1);\n    *(unaff_EBP + -4) = 0;\n    fcn.0041e5df(unaff_EBP + -0x20);\n    arg_8h = unaff_EBP + -0x3c;\n    *(unaff_EBP + -0x3c) = vtable.std::out_of_range.0;\n    fcn.0041101e(arg_8h, 0x454f20);\n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.std::logic_error.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00402f1c(1, arg_8h, extraout_ECX);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00422d75();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 394
    },
    "00425ea0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nbool __cdecl\nfcn.00425ea0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, uint arg_28h, uint arg_2ch, uint arg_30h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_ECX;\n    bool bVar3;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint lpWindowName;\n    uint lpClassName;\n    uint dwExStyle;\n    \n    dwExStyle = arg_8h;\n    lpClassName = arg_ch;\n    lpWindowName = arg_10h;\n    var_10h = arg_14h;\n    var_14h = arg_18h;\n    var_18h = arg_1ch;\n    var_1ch = arg_20h;\n    var_20h = arg_24h;\n    var_24h = arg_28h;\n    var_28h = arg_2ch;\n    iVar1 = fcn.0043d8de();\n    var_2ch = *(iVar1 + 8);\n    var_30h = arg_30h;\n    iVar1 = (**(*in_ECX + 0x5c))(&var_30h);\n    if (iVar1 == 0) {\n        (**(*in_ECX + 0xa4))();\n        bVar3 = false;\n    }\n    else {\n        fcn.00425e12();\n        iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                          (dwExStyle, lpClassName, lpWindowName, var_10h, var_14h, var_18h, var_1ch, var_20h, var_24h, \n                           var_28h, var_2ch, var_30h);\n        iVar2 = fcn.00425e5e();\n        if (iVar2 == 0) {\n            (**(*in_ECX + 0xa4))();\n        }\n        bVar3 = iVar1 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 529
    },
    "004264e3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.004264e3(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpWndClass;\n    uint var_ah;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffc4;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x38);\n    if (iVar4 == 0) {\n        iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n        if (iVar3 == 0) {\n            uVar5 = 0;\n            goto code_r0x00426563;\n        }\n        iVar4 = fcn.0043d8de();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.0043e309(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.0043d8de();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            (*_sym.imp.KERNEL32.dll_lstrcatA)(iVar4 + 0x34, *(iVar1 + 0x24));\n            *(unaff_EBP + 10) = 10;\n            *(unaff_EBP + 0xb) = 0;\n            (*pcVar2)(iVar4 + 0x34, unaff_EBP + 10);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043e379(1);\n        }\n    }\n    uVar5 = 1;\ncode_r0x00426563:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 574
    },
    "004059e6": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004059e6(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    *(param_1 + 4) = 0;\n    iVar2 = param_1[1];\n    iVar1 = 0;\n    do {\n        iVar3 = iVar1;\n        *(param_1 + iVar3 + 0x10) = *(param_1[2] + iVar2);\n        param_1[2] = param_1[2] + 1;\n        iVar2 = param_1[1];\n        if ((*(param_1[2] + -1 + iVar2) == '\\n') || (9999 < iVar3 + 1)) break;\n        iVar1 = iVar3 + 1;\n    } while (param_1[2] < *param_1);\n    *(iVar3 + 0x10 + param_1) = 0;\n    return 1;\n}\n",
        "token_count": 220
    },
    "00405a21": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00405a21(int32_t *param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    \n    *(param_1 + 0x9c8) = 0;\n    iVar4 = param_1[1];\n    while( true ) {\n        iVar2 = param_1[2];\n        cVar1 = *(iVar4 + iVar2);\n        if (((((cVar1 != '\\n') && (cVar1 != '\\t')) && (cVar1 != '\\r')) && (cVar1 != ' ')) || (*param_1 <= iVar2)) break;\n        param_1[2] = iVar2 + 1;\n    }\n    iVar2 = 0;\n    if (param_1[2] < *param_1) {\n        do {\n            iVar5 = iVar2;\n            *(param_1 + iVar5 + 0x2720) = *(param_1[2] + iVar4);\n            param_1[2] = param_1[2] + 1;\n            iVar4 = param_1[1];\n            cVar1 = *(param_1[2] + -1 + iVar4);\n            if (((cVar1 == '\\n') || (cVar1 == '\\t')) || ((cVar1 == '\\r' || ((cVar1 == ' ' || (999 < iVar5 + 1))))))\n            break;\n            iVar2 = iVar5 + 1;\n        } while (param_1[2] < *param_1);\n        *(iVar5 + 0x2720 + param_1) = 0;\n        uVar3 = 1;\n    }\n    else {\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 406
    },
    "00434eb9": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434eb9(int32_t arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint uVar5;\n    uint lprcSrc1;\n    int32_t lprcSrc2;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    uint lprcDst;\n    uint var_10h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar1 = arg_8h - *(in_ECX + 4);\n    iVar4 = arg_ch - *(in_ECX + 8);\n    iVar2 = *(in_ECX + 0x8c);\n    uVar5 = 2;\n    if (iVar2 == 10) {\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + iVar1;\n    }\n    else {\n        if (iVar2 != 0xb) {\n            uVar5 = 0x22;\n            if (iVar2 == 0xc) {\n                *(in_ECX + 0x2c) = *(in_ECX + 0x2c) + iVar4;\n            }\n            else {\n                *(in_ECX + 0x34) = *(in_ECX + 0x34) + iVar4;\n            }\n            iVar2 = *(in_ECX + 0x34) - *(in_ECX + 0x2c);\n            goto code_r0x00434f11;\n        }\n        *(in_ECX + 0x30) = *(in_ECX + 0x30) + iVar1;\n    }\n    iVar2 = *(in_ECX + 0x30) - *(in_ECX + 0x28);\ncode_r0x00434f11:\n    if (iVar2 < 0) {\n        iVar2 = 0;\n    }\n    piVar3 = (**(**(in_ECX + 0x68) + 0xbc))(&var_10h, iVar2, uVar5);\n    var_8h = *piVar3;\n    var_4h = piVar3[1];\n    uVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    (*_sym.imp.USER32.dll_GetWindowRect)(uVar5, &lprcSrc1);\n    lprcSrc2 = *(in_ECX + 0x48);\n    var_24h = *(in_ECX + 0x4c);\n    var_20h = *(in_ECX + 0x50);\n    var_1ch = *(in_ECX + 0x54);\n    if ((*(in_ECX + 0x8c) == 10) || (*(in_ECX + 0x8c) == 0xc)) {\n        lprcSrc2 = ((*(in_ECX + 0x58) - *(in_ECX + 0x60)) - var_8h) + var_20h;\n        var_24h = ((*(in_ECX + 0x5c) - *(in_ECX + 100)) - var_4h) + var_1ch;\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar2 != 0) {\n            *(in_ECX + 0x38) = *(in_ECX + 0x40) - var_8h;\n            *(in_ECX + 0x3c) = *(in_ECX + 0x44) - var_4h;\n            *(in_ECX + 0x48) = lprcSrc2;\n            *(in_ECX + 0x4c) = var_24h;\n        }\n    }\n    else {\n        var_20h = (*(in_ECX + 0x60) - *(in_ECX + 0x58)) + lprcSrc2 + var_8h;\n        var_1ch = (*(in_ECX + 100) - *(in_ECX + 0x5c)) + var_24h + var_4h;\n        iVar2 = (*_sym.imp.USER32.dll_IntersectRect)(&lprcDst, &lprcSrc1, &lprcSrc2);\n        if (iVar2 != 0) {\n            *(in_ECX + 0x40) = *(in_ECX + 0x38) + var_8h;\n            *(in_ECX + 0x44) = *(in_ECX + 0x3c) + var_4h;\n            *(in_ECX + 0x50) = var_20h;\n            *(in_ECX + 0x54) = var_1ch;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    *(in_ECX + 8) = arg_ch;\n    fcn.00435247(0);\n    return;\n}\n",
        "token_count": 1139
    },
    "00407539": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuint32_t fcn.00407539(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = param_1 * param_2 >> 3;\n    if ((uVar1 & 3) != 0) {\n        uVar1 = (uVar1 - (uVar1 & 3)) + 4;\n    }\n    return uVar1;\n}\n",
        "token_count": 96
    },
    "0040abfe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040abfe(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint8_t *puVar4;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if ((*(in_ECX + 0x7c) == 0) || (*(in_ECX + 0x78) == 0)) {\n        var_8h = 0;\n    }\n    else {\n        puVar2 = fcn.004253fd(*(in_ECX + 0x7c) * 6);\n        iVar3 = (*_sym.imp.USER32.dll_CopyAcceleratorTableA)(*(in_ECX + 0x78), puVar2, *(in_ECX + 0x7c));\n        var_8h = 0;\n        var_4h = 0;\n        if (0 < iVar3) {\n            puVar4 = puVar2;\n            do {\n                if (*(arg_8h + 4) == 0x106) {\n                    uVar1 = 0x10;\n                }\n                else {\n                    uVar1 = 0;\n                }\n                if (((*puVar4 & 0xfd) == uVar1) && (*(puVar4 + 2) == *(arg_8h + 8))) {\n                    var_8h = 1;\n                    break;\n                }\n                var_4h = var_4h + 1;\n                puVar4 = puVar4 + 6;\n            } while (var_4h < iVar3);\n        }\n        fcn.00425426(puVar2);\n    }\n    return var_8h;\n}\n",
        "token_count": 389
    },
    "00423758": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\ncode ** __cdecl fcn.00423758(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00429489(0, *(unaff_EBP + 0x10));\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0x17] = extraout_ECX + 0x18;\n    *extraout_ECX = vtable.CPrintDialog.0;\n    fcn.0040ffd0(extraout_ECX + 0x18, 0, 0x42);\n    uVar1 = *(unaff_EBP + 0xc);\n    *extraout_ECX[0x17] = 0x42;\n    *(extraout_ECX[0x17] + 0x14) = uVar1;\n    if (*0x46038c == 0) {\n        iVar2 = fcn.0042976e();\n        if (iVar2 != 0) {\n            extraout_ECX[0x17][0x15] = extraout_ECX[0x17][0x15] | 0x38;\n            *(extraout_ECX[0x17] + 0x2a) = fcn.00423e95;\n            *(extraout_ECX[0x17] + 0x2e) = fcn.00423e95;\n        }\n    }\n    if (*(unaff_EBP + 8) == 0) {\n        extraout_ECX[0xf] = 0x7008;\n        extraout_ECX[0x17][0x15] = extraout_ECX[0x17][0x15] | 1;\n    }\n    else {\n        extraout_ECX[0xf] = 0x7009;\n        *(extraout_ECX[0x17] + 0x14) = *(extraout_ECX[0x17] + 0x14) | 0x40;\n    }\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[0x17][0x15] = extraout_ECX[0x17][0x15] & 0xfd;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 630
    },
    "004321cd": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004321cd(int32_t arg_8h, int32_t lprcSrc)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    int32_t in_ECX;\n    uint arg_ch;\n    uint var_12ch;\n    uint lpRect;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t lprcDst;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowRect)(*(arg_8h + 0x1c), &lpRect);\n    if (*(arg_8h + 0x70) == in_ECX) {\n        if (lprcSrc == 0) {\n            return;\n        }\n        iVar3 = (*_sym.imp.USER32.dll_EqualRect)(&lpRect, lprcSrc);\n        if (iVar3 != 0) {\n            return;\n        }\n    }\n    if ((*(in_ECX + 0x78) != 0) && ((*(arg_8h + 0x68) & 0x40) != 0)) {\n        *(in_ECX + 100) = *(in_ECX + 100) | 0x40;\n    }\n    *(in_ECX + 100) = *(in_ECX + 100) & 0xfffffff9;\n    uVar4 = *(in_ECX + 100);\n    *(in_ECX + 100) = *(arg_8h + 100) & 6 | uVar4;\n    if ((uVar4 & 0x40) == 0) {\n        fcn.00428840(&var_12ch, 0x104);\n        fcn.0042f4c0(*(in_ECX + 0x1c), &var_12ch);\n    }\n    uVar4 = *(arg_8h + 100);\n    uVar2 = uVar4 >> 8;\n    uVar1 = CONCAT11((*(in_ECX + 100) >> 8 ^ uVar2) & 0xf0 ^ uVar2, uVar4);\n    if (*(in_ECX + 0x78) == 0) {\n        uVar4 = uVar4 & 0xffff0000 | uVar1 & 0xfffffffe | 0xf00;\n    }\n    else {\n        uVar4 = uVar4 & 0xffff0000 | uVar1 | 0xf01;\n    }\n    fcn.0043c554(uVar4);\n    var_18h = 0;\n    if ((*(arg_8h + 0x70) != in_ECX) && (iVar3 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(arg_8h + 0x1c)),  iVar3 != 0))\n    {\n        fcn.004288f4(0, 0, 0, 0, 0, 0x97);\n        var_18h = 1;\n    }\n    var_14h = 0xffffffff;\n    if (lprcSrc == 0) {\n        fcn.00424df6(*(in_ECX + 0x84), arg_8h);\n        fcn.00424df6(*(in_ECX + 0x84), 0);\n        fcn.004288f4(0, -*0x460340, -*0x460344, 0, 0, 0x115);\n    }\n    else {\n        (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, lprcSrc);\n        fcn.0042ee9c(&lprcDst);\n        var_14h = fcn.00432d78(arg_8h, lprcDst, var_ch, var_8h, var_4h, (var_8h - lprcDst) / 2 + lprcDst, \n                               (var_4h - var_ch) / 2 + var_ch);\n        fcn.004288f4(0, lprcDst, var_ch, var_8h - lprcDst, var_4h - var_ch, 0x114);\n    }\n    uVar5 = (*_sym.imp.USER32.dll_GetParent)(*(arg_8h + 0x1c));\n    iVar3 = fcn.00425960(uVar5);\n    if (iVar3 != in_ECX) {\n        if (in_ECX == 0) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(in_ECX + 0x1c);\n        }\n        uVar5 = (*_sym.imp.USER32.dll_SetParent)(*(arg_8h + 0x1c), uVar5);\n        fcn.00425960(uVar5);\n    }\n    iVar3 = *(arg_8h + 0x70);\n    if (iVar3 == in_ECX) {\n        uVar5 = 0;\n        arg_ch = var_14h;\n    }\n    else {\n        if (iVar3 == 0) goto code_r0x004323c5;\n        if ((*(in_ECX + 0x78) == 0) || (*(iVar3 + 0x78) != 0)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = 1;\n        }\n        arg_ch = 0xffffffff;\n    }\n    fcn.00432640(arg_8h, arg_ch, uVar5);\ncode_r0x004323c5:\n    *(arg_8h + 0x70) = in_ECX;\n    if (var_18h != 0) {\n        fcn.004288f4(0, 0, 0, 0, 0, 0x57);\n    }\n    fcn.004325df(arg_8h);\n    iVar3 = fcn.00439a92();\n    *(iVar3 + 0xb8) = *(iVar3 + 0xb8) | 0xc;\n    return;\n}\n",
        "token_count": 1368
    },
    "004411c3": {
        "rules": [
            "encrypt data using Curve25519/bbf924b96e5b4ce780ce59f68f21b030"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_20h\n\nint32_t __cdecl fcn.004411c3(uint hDC)\n\n{\n    uint32_t *puVar1;\n    uint8_t *puVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    uint uVar8;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(extraout_ECX + 0x70) = *(unaff_EBP + 8);\n    iVar6 = fcn.004253fd(0x3c);\n    *(unaff_EBP + 8) = iVar6;\n    *(unaff_EBP + -4) = 0;\n    if (iVar6 == 0) {\n        piVar7 = NULL;\n    }\n    else {\n        piVar7 = fcn.00442c60();\n    }\n    *(extraout_ECX + 0x114) = piVar7;\n    iVar6 = *piVar7;\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(iVar6 + 0x3c) = 0x7009;\n    puVar1 = *(**(extraout_ECX + 0x114) + 0x5c) + 0x14;\n    *puVar1 = *puVar1 | 0x40;\n    puVar2 = *(**(extraout_ECX + 0x114) + 0x5c) + 0x15;\n    *puVar2 = *puVar2 & 0xfe;\n    *(*(extraout_ECX + 0x114) + 8) = 1;\n    iVar6 = fcn.004253fd(0x40);\n    *(unaff_EBP + 8) = iVar6;\n    *(unaff_EBP + -4) = 1;\n    if (iVar6 == 0) {\n        uVar8 = 0;\n    }\n    else {\n        uVar8 = fcn.00442ea2();\n    }\n    piVar7 = *(extraout_ECX + 0x70);\n    uVar4 = *(extraout_ECX + 0x114);\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(extraout_ECX + 0x74) = uVar8;\n    iVar6 = (**(*piVar7 + 0xf4))(uVar4);\n    if (iVar6 != 0) {\n        fcn.0042e779(*(*(**(extraout_ECX + 0x114) + 0x5c) + 0x10));\n        (**(**(extraout_ECX + 0x74) + 0xc))(*(*(**(extraout_ECX + 0x114) + 0x5c) + 0x10));\n        *(*(extraout_ECX + 0x74) + 0xc) = 1;\n        *(extraout_ECX + 0x84) = 1;\n        (**(*(extraout_ECX + 0x78) + 0x1c))();\n        uVar8 = (*_sym.imp.USER32.dll_GetDC)(*(extraout_ECX + 0x1c));\n        piVar7 = *(extraout_ECX + 0x74);\n        *(unaff_EBP + 8) = uVar8;\n        (**(*piVar7 + 0x10))(uVar8);\n        (**(**(extraout_ECX + 0x70) + 0xf8))(*(extraout_ECX + 0x74), *(extraout_ECX + 0x114));\n        (**(**(extraout_ECX + 0x74) + 0x18))();\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(extraout_ECX + 0x1c), *(unaff_EBP + 8));\n        (**(*(extraout_ECX + 0x78) + 0x20))(0xffffffff);\n        uVar8 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(extraout_ECX + 0x80), 0x58);\n        *(extraout_ECX + 0x104) = uVar8;\n        uVar8 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(extraout_ECX + 0x80), 0x5a);\n        *(extraout_ECX + 0x108) = uVar8;\n        uVar5 = *(*(extraout_ECX + 0x114) + 0x18);\n        *(extraout_ECX + 0xf8) = uVar5;\n        if (uVar5 == 0) {\n            *(extraout_ECX + 0xf8) = 1;\n        }\n        else if (*(extraout_ECX + 0xf0) < uVar5) {\n            *(extraout_ECX + 0xf8) = *(extraout_ECX + 0xf0);\n        }\n        *(extraout_ECX + 0xe8) = *(extraout_ECX + 0xf8);\n        fcn.004302ab(1, 1, 1, 0x44c150, 0x44c150);\n        piVar7 = *(extraout_ECX + 0x114);\n        uVar3 = *(*(*piVar7 + 0x5c) + 0x1e);\n        if ((uVar3 < 0x8000) && (uVar3 - *(*(*piVar7 + 0x5c) + 0x1c) < 0x8000)) {\n            *(unaff_EBP + -0x24) = 3;\n            *(unaff_EBP + -0x20) = *(*(*piVar7 + 0x5c) + 0x1c);\n            *(unaff_EBP + -0x1c) = *(*(*piVar7 + 0x5c) + 0x1e);\n            *(unaff_EBP + -0x18) = 1;\n            iVar6 = fcn.00427229(1, unaff_EBP + -0x28, 0);\n            if (iVar6 == 0) {\n                fcn.00427183(1, *(unaff_EBP + -0x20), *(unaff_EBP + -0x1c), 0);\n            }\n        }\n        else {\n            (*_sym.imp.USER32.dll_ShowScrollBar)(*(extraout_ECX + 0x1c), 1, 0);\n        }\n        fcn.004420ad(*(*(extraout_ECX + 0x114) + 0x14), 1);\n        iVar6 = 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar6;\n}\n",
        "token_count": 1628
    },
    "0040c666": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040c666(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t **in_ECX;\n    uint var_8h;\n    int32_t **var_4h;\n    \n    var_8h = 0;\n    fcn.0040c06d();\n    var_4h = in_ECX + 3;\n    iVar1 = (**(**in_ECX + 0x14))(*in_ECX, 0, arg_8h, (-(arg_ch != '\\0') & 2) - 1, &var_8h, &var_4h);\n    if ((iVar1 == 0) && (iVar1 = fcn.0040c6bf(),  iVar1 < 0)) {\n        fcn.0040c06d();\n    }\n    return iVar1;\n}\n",
        "token_count": 195
    },
    "0040ca38": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040ca38(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t *arg_18h)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    uVar1 = (**(*arg_18h + 0x10))(arg_18h, (-(*(arg_8h + 0x24) != 0) & 2U) + 2, arg_ch, arg_8h, arg_14h, arg_10h, 0);\n    if (0 < arg_ch) {\n        puVar2 = arg_8h + 0x14;\n        do {\n            fcn.00425426(*puVar2);\n            puVar2 = puVar2 + 0xd;\n            arg_ch = arg_ch + -1;\n        } while (arg_ch != 0);\n    }\n    return uVar1;\n}\n",
        "token_count": 210
    },
    "0042c279": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nint32_t fcn.0042c279(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint16_t *puVar3;\n    uint16_t uVar4;\n    uint32_t uVar5;\n    bool bVar6;\n    \n    bVar6 = *(param_1 + 2) == -1;\n    iVar1 = fcn.0042c223(param_1);\n    if (*(param_1 + 2) == -1) {\n        uVar5 = param_1[3];\n    }\n    else {\n        uVar5 = *param_1;\n    }\n    if ((uVar5 & 0x40) != 0) {\n        iVar1 = iVar1 + ((-bVar6 & 2) + 1) * 2;\n        iVar2 = fcn.00411393(iVar1);\n        iVar1 = iVar1 + 2 + iVar2 * 2;\n    }\n    if (bVar6) {\n        uVar4 = *(param_1 + 4);\n    }\n    else {\n        uVar4 = *(param_1 + 2);\n    }\n    if (uVar4 != 0) {\n        uVar5 = uVar4;\n        do {\n            puVar3 = (iVar1 + 3U & 0xfffffffc) + (-bVar6 & 6) + 0x12;\n            uVar4 = *puVar3;\n            if (uVar4 == 0xffff) {\n                puVar3 = puVar3 + 2;\n            }\n            else {\n                while (puVar3 = puVar3 + 1,  uVar4 != 0) {\n                    uVar4 = *puVar3;\n                }\n            }\n            uVar4 = *puVar3;\n            if (uVar4 == 0xffff) {\n                puVar3 = puVar3 + 2;\n            }\n            else {\n                while (puVar3 = puVar3 + 1,  uVar4 != 0) {\n                    uVar4 = *puVar3;\n                }\n            }\n            uVar5 = uVar5 - 1;\n            iVar1 = puVar3 + *puVar3 + 2;\n        } while (uVar5 != 0);\n    }\n    return iVar1 - param_1;\n}\n",
        "token_count": 514
    },
    "0042c331": {
        "rules": [
            "check for kernel debugger via shared user data structure/3e5f0b53f7994283abe93631eebb775f"
        ],
        "decompiled_code": "\nuint fcn.0042c331(uint32_t *param_1, uint param_2, ushort *param_3)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    ushort *puVar3;\n    uint uVar4;\n    \n    if (*(param_1 + 2) == -1) {\n        uVar2 = param_1[3];\n    }\n    else {\n        uVar2 = *param_1;\n    }\n    if ((uVar2 & 0x40) == 0) {\n        return 0;\n    }\n    puVar3 = fcn.0042c223(param_1);\n    *param_3 = *puVar3;\n    iVar1 = *(param_1 + 2);\n    uVar4 = fcn.0042a78b(0x20, 0x20, 0, 0);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, puVar3 + ((iVar1 != -1) - 1 & 2) + 1, 0xffffffff, uVar4);\n    fcn.0042a763(0xffffffff);\n    return 1;\n}\n",
        "token_count": 262
    },
    "004150a5": {
        "rules": [
            "hash data using aphash/ab9c9a8537c84744923d9bbb8bd71d10"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004150a5(uint param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *(param_2 + 4) & 0x7ff00000;\n    if (uVar1 != 0x7ff00000) {\n        return uVar1;\n    }\n    return *(param_2 + 4);\n}\n",
        "token_count": 92
    },
    "0042a247": {
        "rules": [
            "decompress data using aPLib/db7317f0dd944ab688d24dced6f5a7c2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a247(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = *(param_1 + 8);\n    if ((((iVar1 != 0x40) && (iVar1 != 0x80)) && (iVar1 != 0x100)) && (iVar1 != 0x200)) {\n        fcn.00425426(param_1);\n        return;\n    }\n    fcn.00408da1(param_1);\n    return;\n}\n",
        "token_count": 113
    },
    "00422390": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.00422390(uint param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint noname_4;\n    int32_t iVar4;\n    uint unaff_EBX;\n    uint32_t unaff_EBP;\n    uint noname_5;\n    uint noname_6;\n    uint noname_7;\n    uint noname_3;\n    uint noname_9;\n    uint noname_10;\n    uint noname_11;\n    uint hWnd;\n    uint hdc;\n    uint nXLeft;\n    uint uStack44;\n    uint uStack40;\n    uint uStack8;\n    \n    uStack40 = 0xfffffff0;\n    uStack44 = param_1;\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    if ((uVar2 & 0x10000000) != 0) {\n        (*_sym.imp.USER32.dll_GetClientRect)();\n        pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    // switch table (10 cases) at 0x4224f4\n        switch(unaff_EBP & 0x1f) {\n        case 0:\n        case 1:\n        case 2:\n        case 0xc:\n            nXLeft = 0;\n            hdc = 0;\n            hWnd = 0x31;\n            noname_11 = param_1;\n            iVar3 = (*_sym.imp.USER32.dll_SendMessageA)();\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.GDI32.dll_SelectObject)();\n            }\n            noname_10 = 2;\n            noname_9 = unaff_EBX;\n            (*_sym.imp.GDI32.dll_SetBkMode)();\n            noname_6 = 0x138;\n            noname_5 = param_1;\n            noname_7 = unaff_EBX;\n            noname_3 = param_1;\n            noname_4 = (*_sym.imp.USER32.dll_GetParent)();\n            iVar4 = (*pcVar1)();\n            if (iVar4 != 0) {\n                iVar4 = (*_sym.imp.GDI32.dll_SelectObject)(unaff_EBX, iVar4);\n            }\n            fcn.004222b0(param_1, unaff_EBX, &stack0xffffffb4, noname_3, noname_4, noname_5, noname_6, noname_7, \n                         noname_3, noname_9, noname_10, noname_11, hWnd, hdc, nXLeft);\n            if (iVar3 != 0) {\n                (*_sym.imp.GDI32.dll_SelectObject)(unaff_EBX, iVar3);\n            }\n            if (iVar4 != 0) {\n                (*_sym.imp.GDI32.dll_SelectObject)(unaff_EBX, iVar4);\n                return;\n            }\n            break;\n        case 4:\n        case 7:\n            fcn.0041f4e0();\n            return;\n        case 5:\n        case 8:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n            fcn.0041f4e0();\n            (*_sym.imp.USER32.dll_OffsetRect)();\n            fcn.0041f4e0(uStack8, &uStack44);\n            return;\n        case 6:\n        case 9:\n            fcn.0041f4e0();\n        }\n    }\n    return;\n}\n",
        "token_count": 769
    },
    "0042442d": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042442d(int32_t arg_8h, uint *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint var_24h;\n    uint32_t var_20h;\n    uint32_t var_18h;\n    uint var_10h;\n    uint32_t lpPoint;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    puVar3 = arg_ch;\n    puVar4 = &var_24h;\n    for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = *puVar3;\n        puVar3 = puVar3 + 1;\n        puVar4 = puVar4 + 1;\n    }\n    var_24h = (*_sym.imp.USER32.dll_SendMessageA)(*(arg_8h + 0x1c), 0x410, 0, &var_10h);\n    lpPoint = arg_ch[5];\n    var_4h = arg_ch[6];\n    if ((0x1ff < var_20h) && (var_20h < 0x20a)) {\n        (*_sym.imp.USER32.dll_ScreenToClient)(var_24h, &lpPoint);\n    }\n    var_18h = lpPoint & 0xffff | var_4h << 0x10;\n    (*pcVar1)(*(arg_8h + 0x1c), 0x407, 0, &var_24h);\n    return;\n}\n",
        "token_count": 371
    },
    "00431482": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00431482(uint arg_8h)\n\n{\n    uint var_14h;\n    uint var_ch;\n    \n    fcn.004312d1(arg_8h, &var_14h);\n    return var_ch << 0x10 | var_ch._1_1_;\n}\n",
        "token_count": 79
    },
    "00439970": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00439970(int32_t arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t in_ECX;\n    uint32_t uVar7;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetKeyState;\n    iVar2 = (*_sym.imp.USER32.dll_GetKeyState)(0x11);\n    if (iVar2 < 0) {\n        uVar7 = 8;\n    }\n    else {\n        uVar7 = 0;\n    }\n    iVar2 = (*pcVar1)(0x10);\n    if (iVar2 < 0) {\n        uVar3 = 4;\n    }\n    else {\n        uVar3 = 0;\n    }\n    iVar4 = (*_sym.imp.USER32.dll_GetFocus)();\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    if (iVar4 == 0) {\n        iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x20a, arg_8h << 0x10 | uVar7 | uVar3, arg_ch);\n    }\n    else {\n        do {\n            iVar6 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x20a, arg_8h << 0x10 | uVar7 | uVar3, arg_ch);\n            iVar4 = (*_sym.imp.USER32.dll_GetParent)(iVar4);\n            if (iVar6 != 0) {\n                return iVar6;\n            }\n            if (iVar4 == 0) {\n                return 0;\n            }\n        } while (iVar4 != iVar5);\n    }\n    return iVar6;\n}\n",
        "token_count": 419
    },
    "0043c0d3": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c0d3(uint32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, int32_t arg_14h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(in_ECX + 0x1c));\n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (iVar2 == 0) {\n        *(in_ECX + 0x90) = arg_8h;\n        *(in_ECX + 0x94) = arg_ch;\n        *(in_ECX + 0x88) = arg_10h;\n        *(in_ECX + 0x8c) = arg_14h;\n    }\n    else {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x420, 0, arg_10h & 0xffff | arg_14h << 0x10);\n        (*pcVar1)(*(in_ECX + 0x1c), 0x41f, 0, arg_8h & 0xffff | arg_ch << 0x10);\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 317
    },
    "004252e7": {
        "rules": [
            "hash data using djb2/6ad21e310d674441ba35d7276afbe57d",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.004252e7(int32_t param_1, char *param_2, uint32_t *param_3)\n\n{\n    char *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    char cVar4;\n    char *pcVar5;\n    uint *puVar6;\n    \n    uVar2 = 0;\n    cVar4 = *param_2;\n    pcVar5 = param_2;\n    while (cVar4 != '\\0') {\n        uVar2 = uVar2 * 0x21 + cVar4;\n        pcVar1 = pcVar5 + 1;\n        pcVar5 = pcVar5 + 1;\n        cVar4 = *pcVar1;\n    }\n    uVar2 = uVar2 % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar6 = *(*(param_1 + 4) + uVar2 * 4); puVar6 != NULL; puVar6 = *puVar6) {\n            iVar3 = fcn.0041110c(puVar6[2], param_2);\n            if (iVar3 == 0) {\n                return puVar6;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 301
    },
    "0042f5a8": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.0042f5a8(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "004300f3": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.004300f3(code **param_1)\n\n{\n    fcn.0042e16b();\n    *param_1 = vtable.CScrollView.0;\n    fcn.0040ffd0(param_1 + 0x10, 0, 0x2c);\n    param_1[0x10] = NULL;\n    return param_1;\n}\n",
        "token_count": 87
    },
    "0043ba02": {
        "rules": [
            "check for trap flag exception/d5d4160e77a5474aa5157e4631e4f1b3"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043ba02(uint arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    uint lprc;\n    \n    uVar2 = CONCAT31(arg_10h >> 8 & 0xffbf00, 0x4e);\n    *(in_ECX + 100) = arg_10h & 0x40ffff;\n    uVar1 = fcn.00428783();\n    if ((uVar1 & 0x40000) != 0) {\n        uVar2 = uVar2 | 0x100;\n    }\n    fcn.00428380(0x1000);\n    (*_sym.imp.USER32.dll_SetRectEmpty)(&lprc);\n    fcn.00425f86(\"msctls_statusbar32\", 0, arg_ch | uVar2, &lprc, arg_8h, arg_14h, 0);\n    return;\n}\n",
        "token_count": 241
    },
    "004010d8": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004010d8(int32_t param_1)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uchar uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    uint var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_10h = 3;\n    iVar4 = param_1;\n    do {\n        if (*(param_1 + 0x504) != 1 && -1 < *(param_1 + 0x504) + -1) {\n            puVar5 = param_1 + 0x401;\n            do {\n                uVar1 = *puVar5;\n                var_4h = puVar5[-1];\n                if (puVar5[-1] < uVar1) {\n                    do {\n                        uVar3 = fcn.0040fc64();\n                        uVar2 = var_4h + 1;\n                        *(iVar4 + var_4h) = uVar3;\n                        var_4h = uVar2;\n                    } while (uVar2 < uVar1);\n                }\n                puVar5 = puVar5 + 1;\n            } while (puVar5 + (-0x401 - param_1) < *(param_1 + 0x504) + -1);\n        }\n        iVar4 = iVar4 + 0x100;\n        var_10h = var_10h + -1;\n    } while (var_10h != 0);\n    return 1;\n}\n",
        "token_count": 368
    },
    "004031ef": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.004031ef(int32_t param_1, uint param_2, uint32_t param_3)\n\n{\n    char cVar1;\n    uint unaff_EBX;\n    uint unaff_EDI;\n    int32_t iVar2;\n    \n    if (-*(param_1 + 8) - 1U <= param_3) {\n        fcn.0041e585(unaff_EDI);\n    }\n    if (param_3 != 0) {\n        iVar2 = param_3 + *(param_1 + 8);\n        cVar1 = fcn.00402ff4(iVar2, 0);\n        if (cVar1 != '\\0') {\n            fcn.0040fc90(*(param_1 + 8) + *(param_1 + 4), unaff_EBX, param_3);\n            *(param_1 + 8) = iVar2;\n            *(iVar2 + *(param_1 + 4)) = 0;\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 229
    },
    "00405270": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nbool __cdecl fcn.00405270(uint hdc)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint ppfd;\n    uint var_24h;\n    uint var_20h;\n    uchar var_1ch;\n    uchar var_1bh;\n    uchar var_1ah;\n    uchar var_19h;\n    uchar var_18h;\n    uchar var_17h;\n    uchar var_16h;\n    uchar var_15h;\n    uchar var_14h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    uchar var_10h;\n    uchar var_fh;\n    uchar var_eh;\n    uchar var_dh;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    ppfd._0_2_ = 0x28;\n    ppfd._2_2_ = 1;\n    var_24h = 0x80000025;\n    var_20h._0_1_ = 0;\n    var_20h._1_1_ = 0x20;\n    var_20h._2_1_ = 8;\n    var_20h._3_1_ = 0x10;\n    var_1ch = 8;\n    var_1bh = 8;\n    var_1ah = 8;\n    var_19h = 0;\n    var_18h = 0;\n    var_17h = 0;\n    var_16h = 0x40;\n    var_15h = 0x10;\n    var_14h = 0x10;\n    var_13h = 0x10;\n    var_12h = 0;\n    var_11h = 0x20;\n    var_10h = 8;\n    var_fh = 0;\n    var_eh = 0;\n    var_dh = 0;\n    var_ch = 0;\n    var_8h = 0;\n    var_4h = 0;\n    iVar1 = (*_sym.imp.GDI32.dll_ChoosePixelFormat)(hdc, &ppfd);\n    *(in_ECX + 0x44) = iVar1;\n    if (iVar1 == 0) {\n        *(in_ECX + 0x44) = 1;\n        iVar1 = (*_sym.imp.GDI32.dll_DescribePixelFormat)(hdc, 1, 0x28, &ppfd);\n        if (iVar1 == 0) {\n            return false;\n        }\n    }\n    iVar1 = (*_sym.imp.GDI32.dll_SetPixelFormat)(hdc, *(in_ECX + 0x44), &ppfd);\n    return iVar1 != 0;\n}\n",
        "token_count": 614
    },
    "00405387": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00405387(uint noname_0, int32_t arg_ch, int32_t arg_10h)\n\n{\n    double dVar1;\n    code *pcVar2;\n    code *pcVar3;\n    uint uVar4;\n    int32_t in_ECX;\n    uint uVar5;\n    uint var_4h;\n    \n    fcn.004258c7();\n    if (in_ECX == 0) {\n        uVar5 = 0;\n    }\n    else {\n        uVar5 = *(in_ECX + 0x1c);\n    }\n    uVar4 = (*_sym.imp.USER32.dll_GetDC)(uVar5);\n    (*_sym.imp.OPENGL32.dll_wglMakeCurrent)(uVar4, *(in_ECX + 0x40));\n    dVar1 = arg_ch;\n    if (arg_10h != 0) {\n        dVar1 = dVar1 / arg_10h;\n    }\n    (*_sym.imp.OPENGL32.dll_glViewport)(0, 0, arg_ch, arg_10h);\n    pcVar2 = _sym.imp.OPENGL32.dll_glMatrixMode;\n    (*_sym.imp.OPENGL32.dll_glMatrixMode)(0x1701);\n    pcVar3 = _sym.imp.OPENGL32.dll_glLoadIdentity;\n    (*_sym.imp.OPENGL32.dll_glLoadIdentity)();\n    sub.GLU32.dll_gluPerspective(*0x448208, dVar1, *0x448210, *0x448218);\n    (*pcVar2)(0x1700);\n    (*pcVar3)();\n    (*_sym.imp.OPENGL32.dll_glDrawBuffer)(0x405);\n    (*_sym.imp.USER32.dll_ReleaseDC)(uVar5, uVar4);\n    return;\n}\n",
        "token_count": 386
    },
    "00407710": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407710(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    iVar3 = arg_14h;\n    if ((arg_8h == 0) || (iVar1 = fcn.0040710c(arg_ch, arg_10h, arg_14h),  iVar1 == 0)) {\n        uVar2 = 0;\n    }\n    else {\n        arg_14h = 0;\n        iVar3 = iVar3 / 8;\n        if (0 < arg_10h) {\n            var_8h = 0;\n            do {\n                iVar1 = 0;\n                if (0 < arg_ch) {\n                    var_4h = 0;\n                    do {\n                        iVar4 = 0;\n                        if (0 < iVar3) {\n                            do {\n                                *(*(in_ECX + 0x40) * arg_14h + *(in_ECX + 4) + var_4h + iVar4) =\n                                     *((var_8h + iVar1) * iVar3 + arg_8h + iVar4);\n                                iVar4 = iVar4 + 1;\n                            } while (iVar4 < iVar3);\n                        }\n                        var_4h = var_4h + iVar3;\n                        iVar1 = iVar1 + 1;\n                    } while (iVar1 < arg_ch);\n                }\n                arg_14h = arg_14h + 1;\n                var_8h = var_8h + arg_ch;\n            } while (arg_14h < arg_10h);\n        }\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 432
    },
    "0040a5c1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_70h\n\nint32_t __cdecl fcn.0040a5c1(uint arg_8h, uint arg_ch, uint hMem, uint arg_14h)\n\n{\n    int32_t **arg_18h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_70h;\n    uint var_2ch;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    arg_18h = extraout_ECX + 0x13;\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    iVar1 = fcn.0040a393(*(unaff_EBP + 8), 0, 3, 0x44d8e8, arg_18h, *(unaff_EBP + 0x14));\n    *(unaff_EBP + 0x14) = iVar1;\n    if (iVar1 < 0) goto code_r0x0040a8ba;\n    *(unaff_EBP + -0x10) = 0;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + 8) = 0;\n    fcn.0040aa36(extraout_ECX + 0xf);\n    iVar1 = (**(*extraout_ECX + 0xbc))();\n    *(unaff_EBP + -0x20) = iVar1;\n    if (iVar1 == 0) {\n        (**(**arg_18h + 0x58))(*arg_18h, 1, extraout_ECX + 0x1c);\n        if ((*(extraout_ECX + 0x72) & 2) == 0) goto code_r0x0040a64d;\n        iVar1 = (**(**arg_18h + 0xc))(*arg_18h, extraout_ECX + 0x2e);\n        *(unaff_EBP + 0x14) = iVar1;\n        if (-1 < iVar1) goto code_r0x0040a64d;\ncode_r0x0040a881:\n        piVar3 = *arg_18h;\n        if (piVar3 != NULL) {\n            (**(*piVar3 + 0x18))(piVar3, 1);\n            (**(**arg_18h + 8))(*arg_18h);\n            *arg_18h = NULL;\n        }\n    }\n    else {\ncode_r0x0040a64d:\n        piVar3 = *(unaff_EBP + 0xc);\n        if (piVar3 == NULL) {\n            if (*(unaff_EBP + 0x10) == 0) goto code_r0x0040a6bc;\ncode_r0x0040a726:\n            iVar1 = (****arg_18h)(*arg_18h, 0x44d8b8, unaff_EBP + -0x14);\n            if (-1 < iVar1) {\n                if (piVar3 == NULL) {\n                    *(unaff_EBP + 0xc) = 0;\n                    iVar1 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)(0, 1, unaff_EBP + 0xc);\n                    *(unaff_EBP + 0x14) = iVar1;\n                    if (-1 < iVar1) {\n                        *(unaff_EBP + 0x10) = 0;\n                        iVar1 = (*_sym.imp.ole32.dll_StgCreateDocfileOnILockBytes)\n                                          (*(unaff_EBP + 0xc), 0x1012, 0, unaff_EBP + 0x10);\n                        *(unaff_EBP + 0x14) = iVar1;\n                        if (-1 < iVar1) {\n                            uVar2 = (**(**(unaff_EBP + -0x14) + 0x14))(*(unaff_EBP + -0x14), *(unaff_EBP + 0x10));\n                            *(unaff_EBP + 0x14) = uVar2;\n                            (**(**(unaff_EBP + 0x10) + 8))(*(unaff_EBP + 0x10));\n                        }\n                        piVar3 = *(unaff_EBP + 0xc);\ncode_r0x0040a795:\n                        (**(*piVar3 + 8))(piVar3);\n                    }\n                }\n                else {\n                    if (*(unaff_EBP + 0x10) == 0) {\n                        *(unaff_EBP + 0x14) = 0x8000ffff;\n                        goto code_r0x0040a84e;\n                    }\n                    uVar2 = (**(*piVar3 + 0x30))();\n                    *(unaff_EBP + 0xc) = uVar2;\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0, uVar2);\n                    *(unaff_EBP + 0x10) = iVar1;\n                    if (iVar1 == 0) {\ncode_r0x0040a7e3:\n                        *(unaff_EBP + 0x14) = 0x8007000e;\n                        *(unaff_EBP + 0x10) = 0;\n                    }\n                    else {\n                        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n                        if (iVar1 == 0) goto code_r0x0040a7e3;\n                        (**(*piVar3 + 0x34))(iVar1, *(unaff_EBP + 0xc));\n                        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + 0x10));\n                    }\n                    *(unaff_EBP + -0x1c) = 0;\n                    if (*(unaff_EBP + 0x10) != 0) {\n                        iVar1 = (*_sym.imp.ole32.dll_CreateILockBytesOnHGlobal)\n                                          (*(unaff_EBP + 0x10), 1, unaff_EBP + -0x1c);\n                        *(unaff_EBP + 0x14) = iVar1;\n                        if (-1 < iVar1) {\n                            *(unaff_EBP + -0x18) = 0;\n                            iVar1 = (*_sym.imp.ole32.dll_StgOpenStorageOnILockBytes)\n                                              (*(unaff_EBP + -0x1c), 0, 0x12, 0, 0, unaff_EBP + -0x18);\n                            *(unaff_EBP + 0x14) = iVar1;\n                            if (-1 < iVar1) {\n                                uVar2 = (**(**(unaff_EBP + -0x14) + 0x18))(*(unaff_EBP + -0x14), *(unaff_EBP + -0x18));\n                                *(unaff_EBP + 0x14) = uVar2;\n                                (**(**(unaff_EBP + -0x18) + 8))(*(unaff_EBP + -0x18));\n                            }\n                            piVar3 = *(unaff_EBP + -0x1c);\n                            goto code_r0x0040a795;\n                        }\n                    }\n                }\ncode_r0x0040a84e:\n                piVar3 = *(unaff_EBP + -0x14);\ncode_r0x0040a851:\n                (**(*piVar3 + 8))(piVar3);\n                goto code_r0x0040a857;\n            }\n        }\n        else {\n            if (*(unaff_EBP + 0x10) != 0) goto code_r0x0040a726;\n            iVar1 = (****arg_18h)(*arg_18h, 0x44d8d8, unaff_EBP + 8);\n            if (iVar1 < 0) {\ncode_r0x0040a6bc:\n                iVar1 = (****arg_18h)(*arg_18h, 0x44d8c8, unaff_EBP + -0x10);\n                if (iVar1 < 0) goto code_r0x0040a726;\n                if (piVar3 == NULL) {\n                    uVar2 = (**(**(unaff_EBP + -0x10) + 0x20))(*(unaff_EBP + -0x10));\n                    *(unaff_EBP + 0x14) = uVar2;\n                }\n                else {\n                    fcn.0042fc23(piVar3, 1, 0x1000, 0);\n                    *(unaff_EBP + -4) = 0;\n                    fcn.0042492b(unaff_EBP + -0x70);\n                    uVar2 = (**(**(unaff_EBP + -0x10) + 0x14))(*(unaff_EBP + -0x10), unaff_EBP + -0x2c);\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    *(unaff_EBP + 0x14) = uVar2;\n                    fcn.0042fcff();\n                }\n                piVar3 = *(unaff_EBP + -0x10);\n                goto code_r0x0040a851;\n            }\n            iVar1 = (**(*piVar3 + 0x50))(3, 0, 0, 0);\n            if (iVar1 == 0) goto code_r0x0040a6bc;\n            iVar1 = *piVar3;\n            *(unaff_EBP + 0x10) = 0;\n            uVar2 = (**(iVar1 + 0x50))(0, 0xffffffff, unaff_EBP + 0x10, unaff_EBP + 0xc);\n            uVar2 = (**(**(unaff_EBP + 8) + 0x14))(*(unaff_EBP + 8), *(unaff_EBP + 0x10), uVar2);\n            *(unaff_EBP + 0x14) = uVar2;\n            (**(**(unaff_EBP + 8) + 8))(*(unaff_EBP + 8));\n            *(unaff_EBP + 8) = 0;\ncode_r0x0040a857:\n            if (*(unaff_EBP + 0x14) < 0) goto code_r0x0040a881;\n            if ((*(unaff_EBP + -0x20) == 0) && ((*(*(unaff_EBP + -0x24) + 0x72) & 2) == 0)) {\n                uVar2 = (**(**arg_18h + 0xc))(*arg_18h, *(unaff_EBP + -0x24) + 0xb8);\n                *(unaff_EBP + 0x14) = uVar2;\n            }\n        }\n        if (*(unaff_EBP + 0x14) < 0) goto code_r0x0040a881;\n    }\n    piVar3 = *(unaff_EBP + 8);\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 8))(piVar3);\n    }\n    if ((*(unaff_EBP + -0x20) != 0) && (-1 < *(unaff_EBP + 0x14))) {\n        *(unaff_EBP + 0x14) = 1;\n    }\n    iVar1 = *(unaff_EBP + 0x14);\ncode_r0x0040a8ba:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 2634
    },
    "0040bd8c": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid fcn.0040bd8c(void)\n\n{\n    code *pcVar1;\n    int32_t **ppiVar2;\n    int32_t *piVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    code **extraout_ECX;\n    int32_t iVar7;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x20) = extraout_ECX;\n    *extraout_ECX = vtable.CDataSourceControl.0;\n    iVar7 = 0;\n    pcVar1 = extraout_ECX[0x16];\n    *(unaff_EBP + -4) = 0;\n    if (((pcVar1 != NULL) && (extraout_ECX[0x14] != NULL)) &&\n       (puVar6 = *extraout_ECX[0x14],  iVar5 = (***puVar6)(puVar6, 0x44d908, unaff_EBP + -0x18),  -1 < iVar5)) {\n        *(unaff_EBP + -0x10) = 0;\n        iVar5 = (**(**(unaff_EBP + -0x18) + 0x10))(*(unaff_EBP + -0x18), 0x44d7d8, unaff_EBP + -0x10);\n        if (-1 < iVar5) {\n            (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), extraout_ECX[0x16]);\n            (**(**(unaff_EBP + -0x10) + 8))(*(unaff_EBP + -0x10));\n        }\n        (**(**(unaff_EBP + -0x18) + 8))(*(unaff_EBP + -0x18));\n    }\n    while (extraout_ECX[9] != NULL) {\n        ppiVar2 = *(extraout_ECX[7] + 8);\n        (**(**ppiVar2 + 0xb8))(ppiVar2[2], 0);\n        (*ppiVar2)[0x24] = 0;\n    }\n    *(unaff_EBP + -0x1c) = extraout_ECX + 6;\n    fcn.00424b1c();\n    if (extraout_ECX[0x10] != NULL) {\n        iVar5 = 0;\n        pcVar1 = extraout_ECX[0xe];\n        if (0 < pcVar1) {\n            do {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(extraout_ECX[0x10] + iVar7);\n                iVar5 = iVar5 + 1;\n                iVar7 = iVar7 + 0x10;\n            } while (iVar5 < extraout_ECX[0xe]);\n            pcVar1 = extraout_ECX[0xe];\n        }\n        if (pcVar1 != NULL) {\n            fcn.00425426(extraout_ECX[0xf]);\n            fcn.00425426(extraout_ECX[0x10]);\n        }\n    }\n    piVar3 = extraout_ECX[2];\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 8))(piVar3);\n    }\n    piVar3 = extraout_ECX[3];\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 8))(piVar3);\n    }\n    if (extraout_ECX[5] != NULL) {\n        pcVar1 = extraout_ECX[4];\n        *(unaff_EBP + -0x14) = 0;\n        if (0 < pcVar1) {\n            iVar7 = 0;\n            do {\n                puVar6 = *(*(extraout_ECX[5] + iVar7 + 0x24) + 4);\n                while (puVar6 != NULL) {\n                    puVar4 = *puVar6;\n                    *(puVar6[2] + 0x90) = 0;\n                    puVar6 = puVar4;\n                }\n                fcn.00424b1c();\n                if (*(extraout_ECX[5] + iVar7 + 0x24) != NULL) {\n                    (**(**(extraout_ECX[5] + iVar7 + 0x24) + 4))(1);\n                }\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 1;\n                iVar7 = iVar7 + 0x28;\n            } while (*(unaff_EBP + -0x14) < extraout_ECX[4]);\n        }\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(extraout_ECX[5]);\n    }\n    if (extraout_ECX[0xd] != NULL) {\n        (*_sym.imp.ole32.dll_CoTaskMemFree)(extraout_ECX[0xd]);\n    }\n    if (extraout_ECX[0x15] != NULL) {\n        fcn.0040bf6c(*extraout_ECX[0x14]);\n        fcn.0040c08d();\n    }\n    pcVar1 = extraout_ECX[0x15];\n    if (pcVar1 != NULL) {\n        fcn.0040c08d();\n        fcn.00425426(pcVar1);\n    }\n    pcVar1 = extraout_ECX[0x14];\n    if (pcVar1 != NULL) {\n        fcn.0040bff3();\n        fcn.00425426(pcVar1);\n    }\n    piVar3 = extraout_ECX[0x13];\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 8))(piVar3);\n    }\n    piVar3 = extraout_ECX[0x12];\n    if (piVar3 != NULL) {\n        (**(*piVar3 + 8))(piVar3);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00424b3c();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1481
    },
    "0040c2d2": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a4h\n\nint32_t fcn.0040c2d2(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int32_t iVar5;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint uVar6;\n    uint var_a4h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint pv;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar3 = extraout_ECX[0x12];\n    *(unaff_EBP + -0x28) = extraout_ECX[5];\n    *(unaff_EBP + -0x2c) = extraout_ECX[4];\n    if (iVar3 == 0) {\n        piVar1 = extraout_ECX[2];\n        if (piVar1 == NULL) {\n            iVar3 = 0;\n            goto code_r0x0040c5e3;\n        }\n        iVar3 = (**(*piVar1 + 0xc))(piVar1, 0x44d978, unaff_EBP + -0x1c, unaff_EBP + -0x24);\n        if (iVar3 < 0) goto code_r0x0040c5e3;\n        fcn.0040cb01(unaff_EBP + -0xa4, 0x44da48);\n        *(unaff_EBP + -0x84) = 0xffffffff;\n        *(unaff_EBP + -0x8c) = 0;\n        *(unaff_EBP + -0x88) = 0;\n        *(unaff_EBP + -0x80) = 0x18;\n        *(unaff_EBP + -0x7c) = 0;\n        *(unaff_EBP + -0x78) = 0x1fb;\n        fcn.0040cb01(unaff_EBP + -0x74, 0x44db20);\n        *(unaff_EBP + -0x54) = 0xffffffff;\n        *(unaff_EBP + -0x5c) = 0x1c;\n        *(unaff_EBP + -0x58) = 0;\n        *(unaff_EBP + -0x50) = 0x20;\n        *(unaff_EBP + -0x4c) = 0;\n        *(unaff_EBP + -0x48) = 0x1e;\n        iVar3 = (**(**(unaff_EBP + -0x1c) + 0x10))(*(unaff_EBP + -0x1c), 2, unaff_EBP + -0xa4, 0x28, 0);\n        if (iVar3 < 0) {\n            (**(**(unaff_EBP + -0x1c) + 8))(*(unaff_EBP + -0x1c));\n            goto code_r0x0040c5e3;\n        }\n        *(unaff_EBP + -0x44) = *(unaff_EBP + -0x24);\n        *(unaff_EBP + -0x40) = 1;\n        *(unaff_EBP + -0x3c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        iVar3 = (**(**(unaff_EBP + -0x1c) + 0x18))(*(unaff_EBP + -0x1c), 0, 0, unaff_EBP + -0x44);\n        *(unaff_EBP + -0x20) = iVar3;\n        if (-1 < iVar3) {\n            iVar3 = *(unaff_EBP + -0x38);\n            extraout_ECX[5] = *(unaff_EBP + -0x3c);\n            *(unaff_EBP + -0x24) = *(unaff_EBP + -0x30);\n            extraout_ECX[4] = *(unaff_EBP + -0x30);\n            piVar1 = *(unaff_EBP + -0x1c);\n            extraout_ECX[0xd] = iVar3;\n            (**(*piVar1 + 8))(piVar1);\n            goto code_r0x0040c539;\n        }\n        (**(**(unaff_EBP + -0x1c) + 8))(*(unaff_EBP + -0x1c));\n    }\n    else {\n        iVar3 = (**(*extraout_ECX[0x13] + 0x14))(extraout_ECX[0x13], 0x44d7f8, unaff_EBP + -0x14);\n        *(unaff_EBP + -0x20) = iVar3;\n        if (iVar3 < 0) goto code_r0x0040c5e3;\n        iVar3 = (****(unaff_EBP + -0x14))(*(unaff_EBP + -0x14), 0x44d908, unaff_EBP + -0x18);\n        if (-1 < iVar3) {\n            *(unaff_EBP + -0x10) = 0;\n            iVar3 = (**(**(unaff_EBP + -0x18) + 0x10))(*(unaff_EBP + -0x18), 0x44d7d8, unaff_EBP + -0x10);\n            if (-1 < iVar3) {\n                (**(**(unaff_EBP + -0x10) + 0x14))(*(unaff_EBP + -0x10), extraout_ECX[1] + 0xd8, extraout_ECX + 0x16);\n                (**(**(unaff_EBP + -0x10) + 8))(*(unaff_EBP + -0x10));\n            }\n            (**(**(unaff_EBP + -0x18) + 8))(*(unaff_EBP + -0x18));\n        }\n        iVar3 = fcn.004253fd(0x10);\n        *(unaff_EBP + -0x24) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            iVar3 = 0;\n        }\n        else {\n            iVar3 = fcn.0040c5f2(*(unaff_EBP + -0x14));\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        extraout_ECX[0x14] = iVar3;\n        (**(**(unaff_EBP + -0x14) + 8))(*(unaff_EBP + -0x14));\n        fcn.0040c716();\n        puVar4 = fcn.004253fd(0x1c);\n        if (puVar4 == NULL) {\n            puVar4 = NULL;\n        }\n        else {\n            *puVar4 = 0;\n            puVar4[1] = 0;\n            puVar4[2] = 0;\n            puVar4[3] = 0;\n            puVar4[4] = 0;\n            puVar4[5] = 0;\n        }\n        extraout_ECX[0x15] = puVar4;\n        fcn.0040c72b(*extraout_ECX[0x14]);\n        *(extraout_ECX[0x14] + 8) = extraout_ECX[0x15];\n        iVar3 = *(extraout_ECX[0x15] + 0xc);\n        extraout_ECX[4] = iVar3;\n        iVar3 = (*_sym.imp.ole32.dll_CoTaskMemAlloc)(iVar3 * 0x28);\n        extraout_ECX[5] = iVar3;\n        fcn.0040ffd0(iVar3, 0, extraout_ECX[4] * 0x28);\n        fcn.0040c643();\n        fcn.0040c06d();\ncode_r0x0040c539:\n        iVar3 = extraout_ECX[4];\n        *(unaff_EBP + -0x14) = 0;\n        if (0 < iVar3) {\n            iVar3 = 0;\n            do {\n                uVar6 = 0x1c;\n                iVar5 = fcn.004253fd(0x1c);\n                *(unaff_EBP + -0x18) = iVar5;\n                *(unaff_EBP + -4) = 1;\n                if (iVar5 == 0) {\n                    uVar6 = 0;\n                }\n                else {\n                    uVar6 = fcn.00424add(uVar6, 10);\n                }\n                iVar5 = extraout_ECX[5];\n                *(unaff_EBP + -4) = 0xffffffff;\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 1;\n                *(iVar3 + 0x24 + iVar5) = uVar6;\n                iVar3 = iVar3 + 0x28;\n            } while (*(unaff_EBP + -0x14) < extraout_ECX[4]);\n        }\n        if (*(unaff_EBP + -0x28) != 0) {\n            if (0 < *(unaff_EBP + -0x2c)) {\n                *(unaff_EBP + -0x18) = *(unaff_EBP + -0x2c);\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x28) + 0x24;\n                do {\n                    puVar4 = *(**(unaff_EBP + -0x10) + 4);\n                    while (puVar4 != NULL) {\n                        puVar2 = *puVar4;\n                        (**(*extraout_ECX + 8))(puVar4[2], 1);\n                        puVar4 = puVar2;\n                    }\n                    fcn.00424b1c();\n                    if (**(unaff_EBP + -0x10) != NULL) {\n                        (**(***(unaff_EBP + -0x10) + 4))(1);\n                    }\n                    *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 0x28;\n                    piVar1 = unaff_EBP + -0x18;\n                    *piVar1 = *piVar1 + -1;\n                } while (*piVar1 != 0);\n            }\n            (*_sym.imp.ole32.dll_CoTaskMemFree)(*(unaff_EBP + -0x28));\n        }\n    }\n    iVar3 = *(unaff_EBP + -0x20);\ncode_r0x0040c5e3:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar3;\n}\n",
        "token_count": 2608
    },
    "0040ceee": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0040ceee(int32_t param_1)\n\n{\n    uint uVar1;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    \n    if (*(param_1 + 0x48) == 0) {\n        if (*(param_1 + 0x38) != 0) {\n            var_10h = *(param_1 + 0x40);\n            var_ch = 0;\n            var_8h = 0;\n            var_18h = 1;\n            var_14h = 0;\n            uVar1 = (**(**(param_1 + 8) + 0x20))(*(param_1 + 8), 1, 0x44dd04, 0, 0, &var_18h);\n            return uVar1;\n        }\n    }\n    else if ((*(param_1 + 0x50) != 0) && (*(*(param_1 + 0x50) + 0xc) != 0)) {\n        uVar1 = fcn.0040c6bf();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 272
    },
    "00426e15": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00426e15(uint noname_0, uint *hWnd, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *in_ECX;\n    uint var_ch;\n    uint *var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = *hWnd;\n    var_4h = (*_sym.imp.USER32.dll_GetDlgCtrlID)(uVar3);\n    var_4h = var_4h & 0xffff;\n    uVar1 = hWnd[2];\n    iVar2 = fcn.0043e01d(0x43b7dd);\n    if ((*(iVar2 + 0xb8) != in_ECX[7]) && (iVar2 = fcn.004276e0(uVar3, arg_10h),  iVar2 == 0)) {\n        var_ch = arg_10h;\n        var_8h = hWnd;\n        uVar3 = (**(*in_ECX + 0xc))(var_4h, uVar1 & 0xffff | 0x4e0000, &var_ch, 0);\n        return uVar3;\n    }\n    return 1;\n}\n",
        "token_count": 279
    },
    "004272c3": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004272c3(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint var_24h;\n    int32_t var_14h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    fcn.004271b6(arg_8h, &var_8h, &var_4h);\n    iVar1 = fcn.00427276(arg_8h, &var_24h, 2);\n    if (iVar1 != 0) {\n        var_4h = var_4h - (-(var_14h != 1) & var_14h - 1U);\n    }\n    return var_4h;\n}\n",
        "token_count": 160
    },
    "00427d32": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427d32(int32_t arg_8h)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_60h;\n    uint lprcSrc;\n    int32_t lpPoints;\n    int32_t var_34h;\n    int32_t var_30h;\n    int32_t var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    int32_t var_1ch;\n    int32_t lprcDst;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = fcn.00428783();\n    if (arg_8h == 0) {\n        if ((var_4h & 0x40000000) == 0) {\n            iVar5 = (*_sym.imp.USER32.dll_GetWindow)(*(in_ECX + 0x1c), 4);\n        }\n        else {\n            iVar5 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        }\n        if ((iVar5 != 0) && (iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x36b, 0, 0),  iVar4 != 0)) {\n            iVar5 = iVar4;\n        }\n    }\n    else {\n        iVar5 = *(arg_8h + 0x1c);\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowRect;\n    (*_sym.imp.USER32.dll_GetWindowRect)(*(in_ECX + 0x1c), &var_28h);\n    if ((var_4h & 0x40000000) == 0) {\n        if ((iVar5 != 0) &&\n           ((uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0),  (uVar2 & 0x10000000) == 0 ||\n            ((uVar2 & 0x20000000) != 0)))) {\n            iVar5 = 0;\n        }\n        if (iVar5 == 0) {\n            iVar5 = fcn.00407d0c();\n            if (iVar5 != 0) {\n                iVar5 = *(iVar5 + 0x1c);\n            }\n            uVar3 = fcn.00407e4e(iVar5, 1);\n            fcn.00407eb9(uVar3, iVar5);\n            pcVar1 = _sym.imp.USER32.dll_CopyRect;\n            (*_sym.imp.USER32.dll_CopyRect)(&lpPoints, &lprcSrc);\n            (*pcVar1)(&lprcDst, &lprcSrc);\n        }\n        else {\n            (*pcVar1)(iVar5, &lpPoints);\n            uVar3 = fcn.00407e4e(iVar5, 2);\n            fcn.00407eb9(uVar3, iVar5);\n            (*_sym.imp.USER32.dll_CopyRect)(&lprcDst, &lprcSrc);\n        }\n    }\n    else {\n        uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(in_ECX + 0x1c));\n        pcVar1 = _sym.imp.USER32.dll_GetClientRect;\n        (*_sym.imp.USER32.dll_GetClientRect)(uVar3, &lprcDst);\n        (*pcVar1)(iVar5, &lpPoints);\n        (*_sym.imp.USER32.dll_MapWindowPoints)(iVar5, uVar3, &lpPoints, 2);\n    }\n    iVar5 = (lpPoints + var_30h) / 2 - (var_20h - var_28h) / 2;\n    iVar4 = (var_34h + var_2ch) / 2 - (var_1ch - var_24h) / 2;\n    if ((lprcDst <= iVar5) && (lprcDst = iVar5,  var_10h < (var_20h - var_28h) + iVar5)) {\n        lprcDst = (var_10h - var_20h) + var_28h;\n    }\n    if ((var_14h <= iVar4) && (var_14h = iVar4,  var_ch < (var_1ch - var_24h) + iVar4)) {\n        var_14h = (var_24h - var_1ch) + var_ch;\n    }\n    fcn.004288f4(0, lprcDst, var_14h, 0xffffffff, 0xffffffff, 0x15);\n    return;\n}\n",
        "token_count": 1086
    },
    "0042924f": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Variable defined which should be unmapped: var_34h\n\nuint __cdecl\nfcn.0042924f(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpTemplate;\n    uint var_ch_2;\n    uint hInstance;\n    uint var_10h;\n    uint var_40h;\n    uint var_34h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hWnd;\n    uint hMem;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    *(unaff_EBP + -0x24) = extraout_ECX;\n    if (*(unaff_EBP + 0x10) == 0) {\n        iVar2 = fcn.0043d8de();\n        *(unaff_EBP + 0x10) = *(iVar2 + 8);\n    }\n    iVar2 = fcn.0043d8de();\n    piVar1 = *(iVar2 + 0x1038);\n    *(unaff_EBP + -0x28) = piVar1;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x18) = 0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00428380(0x10);\n    fcn.00428380(0x3c000);\n    if (piVar1 == NULL) {\ncode_r0x004292cc:\n        if (*(unaff_EBP + 8) != 0) {\n            *(unaff_EBP + -0x1c) = *0x45c084;\n            *(unaff_EBP + -4) = 1;\n            *(unaff_EBP + -0x20) = 0;\n            iVar2 = fcn.0042c331(*(unaff_EBP + 8), unaff_EBP + -0x1c, unaff_EBP + -0x20);\n            if (iVar2 == 0) {\ncode_r0x00429357:\n                fcn.0042c180(*(unaff_EBP + 8));\n                *(unaff_EBP + -4) = 2;\n                fcn.0042c4ba(*(unaff_EBP + -0x20));\n                uVar3 = fcn.0042c21d();\n                *(unaff_EBP + -0x14) = uVar3;\n                *(unaff_EBP + -4) = 1;\n                fcn.0042c20f();\n                if (*(unaff_EBP + -0x14) != 0) {\n                    uVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(unaff_EBP + -0x14));\n                    *(unaff_EBP + 8) = uVar3;\n                }\n            }\n            else {\n                iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n                if (iVar2 != 0) {\n                    iVar2 = fcn.0041110c(*(unaff_EBP + -0x1c), \"MS Shell Dlg\");\n                    if (iVar2 != 0) {\n                        iVar2 = fcn.0041110c(*(unaff_EBP + -0x1c), \"MS Sans Serif\");\n                        if (iVar2 != 0) {\n                            iVar2 = fcn.0041110c(*(unaff_EBP + -0x1c), \"Helv\");\n                            if (iVar2 != 0) goto code_r0x00429399;\n                        }\n                    }\n                    if (*(unaff_EBP + -0x20) == 8) {\n                        *(unaff_EBP + -0x20) = 0;\n                    }\n                    goto code_r0x00429357;\n                }\n            }\ncode_r0x00429399:\n            extraout_ECX[0xb] = -1;\n            extraout_ECX[9] = extraout_ECX[9] | 0x10;\n            fcn.00425e12(extraout_ECX);\n            if (*(unaff_EBP + 0xc) == 0) {\n                uVar3 = 0;\n            }\n            else {\n                uVar3 = *(*(unaff_EBP + 0xc) + 0x1c);\n            }\n            uVar3 = (*_sym.imp.USER32.dll_CreateDialogIndirectParamA)\n                              (*(unaff_EBP + 0x10), *(unaff_EBP + 8), uVar3, fcn.00428f94, 0);\n            *(unaff_EBP + -0x18) = uVar3;\n            *(unaff_EBP + -4) = 0;\n            fcn.0042a358();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (piVar1 != NULL) {\n                (**(*piVar1 + 0x14))(unaff_EBP + -0x34);\n                if (*(unaff_EBP + -0x18) != 0) {\n                    (**(*extraout_ECX + 0xb4))(0);\n                }\n            }\n            iVar2 = fcn.00425e5e();\n            if (iVar2 == 0) {\n                (**(*extraout_ECX + 0xa4))();\n            }\n            if ((*(unaff_EBP + -0x18) != 0) && ((*(extraout_ECX + 9) & 0x10) == 0)) {\n                (*_sym.imp.USER32.dll_DestroyWindow)(*(unaff_EBP + -0x18));\n                *(unaff_EBP + -0x18) = 0;\n            }\n            if (*(unaff_EBP + -0x14) != 0) {\n                (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*(unaff_EBP + -0x14));\n                (*_sym.imp.KERNEL32.dll_GlobalFree)(*(unaff_EBP + -0x14));\n            }\n            if ((*(unaff_EBP + -0x18) != 0) || ((*(extraout_ECX + 9) & 0x10) == 0)) {\n                uVar3 = 1;\n                goto code_r0x0042946b;\n            }\n        }\n    }\n    else {\n        iVar2 = (**(*extraout_ECX + 0xb4))(unaff_EBP + -0x34);\n        if (iVar2 != 0) {\n            uVar3 = (**(*piVar1 + 0x10))(unaff_EBP + -0x34, *(unaff_EBP + 8));\n            *(unaff_EBP + 8) = uVar3;\n            goto code_r0x004292cc;\n        }\n    }\n    uVar3 = 0;\ncode_r0x0042946b:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 1722
    },
    "0042bbf1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint fcn.0042bbf1(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar2 = 0;\n    iVar1 = *(extraout_ECX + 0xc);\n    *(unaff_EBP + -0x10) = &var_14h;\n    if (iVar1 != 0) {\n        *(unaff_EBP + -0x14) = 0;\n        *(unaff_EBP + -4) = 0;\n        uVar2 = (**(extraout_ECX + 0xc))();\n        *(unaff_EBP + -0x14) = uVar2;\n        uVar2 = *(unaff_EBP + -0x14);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 274
    },
    "0042dad3": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpPathName\n\nuint __cdecl fcn.0042dad3(uint arg_8h, uint lpFilePart, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpPathName;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar1 = *0x45c084;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x10) = uVar1;\n    *(unaff_EBP + -4) = 1;\n    (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, unaff_EBP + -0x118, unaff_EBP + 0xc);\n    **(unaff_EBP + 0xc) = 0;\n    uVar1 = fcn.0042a714(0x105);\n    (*_sym.imp.KERNEL32.dll_GetTempFileNameA)(unaff_EBP + -0x118, 0x44a528, 0, uVar1);\n    fcn.0042a763(0xffffffff);\n    if (*(unaff_EBP + 0x10) == 0) {\n        fcn.0042b166(*(unaff_EBP + -0x10));\n    }\n    fcn.0042a0cd(unaff_EBP + -0x10);\n    *(unaff_EBP + -0x14) = 1;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    uVar1 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 433
    },
    "0042f4c0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042f4c0(uint hWnd, uint lpString2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint lpString1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpString2);\n    if (((uVar1 < 0x101) && (uVar2 = (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString1, 0x100),  uVar2 == uVar1))\n       && (iVar3 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(&lpString1, lpString2),  iVar3 == 0)) {\n        return;\n    }\n    (*_sym.imp.USER32.dll_SetWindowTextA)(hWnd, lpString2);\n    return;\n}\n",
        "token_count": 187
    },
    "00430220": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430220(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_ECX;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    *(in_ECX + 0x40) = 0xffffffff;\n    *(in_ECX + 0x44) = arg_8h;\n    *(in_ECX + 0x48) = arg_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        uVar1 = fcn.00428783();\n        if ((uVar1 & 0x300000) != 0) {\n            fcn.0042712b(0, 0, 1);\n            fcn.0042712b(1, 0, 1);\n            fcn.004271e6(3, 0);\n        }\n    }\n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *(in_ECX + 0x4c) = var_8h - lpRect;\n    *(in_ECX + 0x50) = var_4h - var_ch;\n    if (*(in_ECX + 0x1c) != 0) {\n        fcn.00430700();\n        (*_sym.imp.USER32.dll_InvalidateRect)(*(in_ECX + 0x1c), 0, 1);\n    }\n    return;\n}\n",
        "token_count": 346
    },
    "0043063b": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0043063b(int32_t arg_8h, int32_t arg_ch, uint32_t *arg_10h, int32_t *arg_14h, int32_t *arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_8h = in_ECX;\n    var_4h = in_ECX;\n    fcn.0043056c(&var_8h);\n    piVar2 = arg_14h;\n    iVar1 = *(in_ECX + 0x50);\n    *arg_14h = *(in_ECX + 0x4c) - arg_8h;\n    arg_14h[1] = iVar1 - arg_ch;\n    piVar3 = fcn.004303dd(&arg_8h);\n    *arg_18h = *piVar3;\n    arg_18h[1] = piVar3[1];\n    arg_14h = 0 < *piVar2;\n    if (arg_14h == NULL) {\n        *arg_18h = 0;\n    }\n    else if (arg_1ch != 0) {\n        piVar2[1] = piVar2[1] + var_4h;\n    }\n    uVar4 = 0 < piVar2[1];\n    if (uVar4 == 0) {\n        arg_18h[1] = 0;\n    }\n    else {\n        if (arg_1ch != 0) {\n            *piVar2 = *piVar2 + var_8h;\n        }\n        if ((arg_14h == NULL) && (0 < *piVar2)) {\n            arg_14h = 0x1;\n            piVar2[1] = piVar2[1] + var_4h;\n        }\n    }\n    iVar1 = *piVar2;\n    if ((0 < iVar1) && (iVar1 <= *arg_18h)) {\n        *arg_18h = iVar1;\n    }\n    iVar1 = piVar2[1];\n    if ((0 < iVar1) && (iVar1 <= arg_18h[1])) {\n        arg_18h[1] = iVar1;\n    }\n    *arg_10h = arg_14h;\n    arg_10h[1] = uVar4;\n    return;\n}\n",
        "token_count": 576
    },
    "00430700": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00430700(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    int32_t var_5ch;\n    int32_t var_58h;\n    uint lpRect;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t lParam;\n    int32_t var_38h;\n    int32_t var_34h;\n    int32_t var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    if (*(param_1 + 0x68) != 0) {\n        return;\n    }\n    *(param_1 + 0x68) = 1;\n    var_4h = 1;\n    uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n    iVar2 = fcn.00425960(uVar1);\n    if ((iVar2 == 0) || (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x368, 0, &lParam),  iVar2 == 0))\n    {\n        iVar2 = fcn.004305c6(&var_ch, &var_1ch);\n        if (iVar2 == 0) {\n            (*_sym.imp.USER32.dll_GetClientRect)(*(param_1 + 0x1c), &lpRect);\n            if ((0 < var_44h) && (0 < var_40h)) {\n                fcn.004271e6(3, 0);\n            }\n            goto code_r0x0043086d;\n        }\n    }\n    else {\n        var_4h = 0;\n        fcn.0043056c();\n        var_ch = var_34h - lParam;\n        var_8h = var_30h - var_38h;\n    }\n    fcn.0043063b(var_ch, var_8h, &var_14h, &var_2ch, &var_24h, var_4h);\n    if (var_14h != 0) {\n        var_8h = var_8h - var_18h;\n    }\n    if (var_10h != 0) {\n        var_ch = var_ch - var_1ch;\n    }\n    fcn.00430456(var_24h, var_20h);\n    var_64h = 3;\n    var_60h = 0;\n    fcn.004271e6(0, var_14h);\n    if (var_14h != 0) {\n        var_58h = var_ch;\n        var_5ch = *(param_1 + 0x4c) + -1;\n        iVar2 = fcn.00427229(0, &var_68h, 1);\n        if (iVar2 == 0) {\n            fcn.00427183(0, 0, var_2ch, 1);\n        }\n    }\n    fcn.004271e6(1, var_10h);\n    if (var_10h != 0) {\n        var_58h = var_8h;\n        var_5ch = *(param_1 + 0x50) + -1;\n        iVar2 = fcn.00427229(1, &var_68h, 1);\n        if (iVar2 == 0) {\n            fcn.00427183(1, 0, var_28h, 1);\n        }\n    }\ncode_r0x0043086d:\n    *(param_1 + 0x68) = 0;\n    return;\n}\n",
        "token_count": 903
    },
    "004316ee": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004316ee(uint arg_8h, uint arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    bool bVar5;\n    uint var_18h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_4h;\n    \n    iVar4 = 0;\n    if (arg_14h == 0) {\n        arg_14h = arg_10h;\n        var_4h = fcn.00431614(arg_8h, arg_ch, arg_10h);\n        iVar1 = fcn.00431614(arg_8h, arg_ch, 0);\n        if ((iVar1 != var_4h) && (0 < arg_10h)) {\n            do {\n                iVar1 = (arg_14h + iVar4) / 2;\n                iVar2 = fcn.00431614(arg_8h, arg_ch, iVar1);\n                if ((iVar2 != var_4h) && (bVar5 = iVar4 == iVar1,  iVar4 = iVar1,  iVar1 = arg_14h,  bVar5)) {\n                    fcn.00431614(arg_8h, arg_ch, arg_14h);\n                    break;\n                }\n                arg_14h = iVar1;\n            } while (iVar4 < arg_14h);\n        }\n        piVar3 = fcn.004314f2(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        var_ch = piVar3[1];\ncode_r0x00431837:\n        fcn.00431614(arg_8h, arg_ch, iVar4);\n    }\n    else {\n        fcn.00431614(arg_8h, arg_ch, 0);\n        piVar3 = fcn.004314f2(&var_10h, arg_8h, arg_ch);\n        iVar1 = *piVar3;\n        var_4h = piVar3[1];\n        fcn.00431614(arg_8h, arg_ch, 0x7fff);\n        piVar3 = fcn.004314f2(&var_10h, arg_8h, arg_ch);\n        iVar4 = *piVar3;\n        while( true ) {\n            var_ch = piVar3[1];\n            while( true ) {\n                if (iVar4 <= iVar1) {\n                    return;\n                }\n                fcn.00431614(arg_8h, arg_ch, (iVar1 + iVar4) / 2);\n                piVar3 = fcn.004314f2(&var_18h, arg_8h, arg_ch);\n                var_10h = *piVar3;\n                if (piVar3[1] <= arg_10h) break;\n                if ((iVar1 == *piVar3) && (var_4h == piVar3[1])) goto code_r0x00431837;\n                iVar1 = *piVar3;\n                var_4h = piVar3[1];\n            }\n            if (arg_10h <= piVar3[1]) break;\n            iVar4 = *piVar3;\n        }\n    }\n    return;\n}\n",
        "token_count": 740
    },
    "00431cf1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00431cf1(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0043418a(&var_10h, (*(in_ECX + 100) & 0xa000) != 0);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    if (*0x45bed4 < 0x40047) {\n        arg_ch[1] = arg_ch[1] + -2;\n    }\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 222
    },
    "00432be1": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432be1(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t in_ECX;\n    uint var_18h;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar6 = *(in_ECX + 0x90);\n    puVar1 = in_ECX + 0x94;\n    uVar2 = *puVar1;\n    uVar3 = *(in_ECX + 0x98);\n    uVar4 = *(in_ECX + 0x9c);\n    uVar5 = *(in_ECX + 0xa0);\n    *(in_ECX + 0x90) = *arg_ch == 0;\n    (*_sym.imp.USER32.dll_CopyRect)(puVar1, arg_ch + 1);\n    fcn.00433da5(arg_8h, arg_ch);\n    *puVar1 = uVar2;\n    *(in_ECX + 0x98) = uVar3;\n    *(in_ECX + 0x9c) = uVar4;\n    *(in_ECX + 0xa0) = uVar5;\n    *(in_ECX + 0x90) = uVar6;\n    return;\n}\n",
        "token_count": 312
    },
    "00432d78": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.00432d78(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint noname_3, uint noname_4, int32_t arg_1ch, \n            int32_t arg_20h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint32_t uVar4;\n    bool bVar5;\n    bool bVar6;\n    int32_t lpRect;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_8h = 0;\n    uVar4 = *(in_ECX + 100) & 0xa000;\n    var_10h = 0;\n    var_4h = 0;\n    if (0 < *(in_ECX + 0x84)) {\n        do {\n            iVar3 = var_4h;\n            piVar1 = fcn.00432d5c();\n            if ((piVar1 == NULL) || (iVar2 = (**(*piVar1 + 200))(),  iVar2 == 0)) {\n                iVar3 = var_8h - *0x460344;\n                var_8h = 0;\n                var_10h = var_10h + iVar3;\n                iVar3 = arg_20h;\n                if (uVar4 == 0) {\n                    iVar3 = arg_1ch;\n                }\n                if (iVar3 < var_10h) {\n                    if (var_4h == 0) {\n                        fcn.00424e1d(var_ch + 1, 0, 1);\n                    }\n                    iVar3 = var_ch + 1;\n                    goto code_r0x00432e80;\n                }\ncode_r0x00432e4a:\n                var_ch = var_4h;\n            }\n            else {\n                (*_sym.imp.USER32.dll_GetWindowRect)(piVar1[7], &lpRect, iVar3);\n                fcn.0042ee9c(&lpRect);\n                if (uVar4 == 0) {\n                    iVar3 = (var_18h - lpRect) + -1;\n                }\n                else {\n                    iVar3 = var_14h - var_1ch;\n                }\n                if (var_8h <= iVar3) {\n                    if (uVar4 == 0) {\n                        var_8h = (var_18h - lpRect) + -1;\n                    }\n                    else {\n                        var_8h = var_14h - var_1ch;\n                    }\n                }\n                if (uVar4 == 0) {\n                    bVar6 = SBORROW4(arg_10h, var_1ch);\n                    iVar3 = arg_10h - var_1ch;\n                    bVar5 = arg_10h == var_1ch;\n                }\n                else {\n                    bVar6 = SBORROW4(arg_ch, lpRect);\n                    iVar3 = arg_ch - lpRect;\n                    bVar5 = arg_ch == lpRect;\n                }\n                if (!bVar5 && bVar6 == iVar3 < 0) goto code_r0x00432e4a;\n            }\n            var_4h = var_4h + 1;\n        } while (var_4h < *(in_ECX + 0x84));\n    }\n    iVar3 = var_ch + 1;\n    fcn.00424e1d(iVar3, 0, 1);\ncode_r0x00432e80:\n    fcn.00424e1d(iVar3, arg_8h, 1);\n    return iVar3;\n}\n",
        "token_count": 860
    },
    "004366eb": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004366eb(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint32_t var_20h;\n    char *var_18h;\n    int32_t lpRect;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    in_ECX[0x19] = arg_10h & 0x40ffff;\n    fcn.0040ffd0(&var_40h, 0, 0x30);\n    var_20h = arg_10h | 0x40000000;\n    var_18h = \"AfxControlBar42s\";\n    var_38h = arg_14h;\n    iVar1 = fcn.0043d8de();\n    var_3ch = *(iVar1 + 8);\n    if (arg_8h == 0) {\n        var_34h = 0;\n    }\n    else {\n        var_34h = *(arg_8h + 0x1c);\n    }\n    iVar1 = (**(*in_ECX + 0x5c))(&var_40h);\n    if (iVar1 != 0) {\n        in_ECX[0x21] = arg_ch;\n        fcn.00428380(0x10);\n        fcn.00428380(0x3c000);\n        iVar1 = fcn.0042920b(arg_ch, arg_8h);\n        in_ECX[0x21] = 0;\n        if (iVar1 != 0) {\n            fcn.0042888a(arg_14h);\n            (*_sym.imp.USER32.dll_GetWindowRect)(in_ECX[7], &lpRect);\n            in_ECX[0x1e] = var_8h - lpRect;\n            in_ECX[0x1f] = var_4h - var_ch;\n            fcn.004287b7(0, 0x4000000, 0);\n            iVar1 = fcn.00427ee7(arg_ch);\n            if (iVar1 != 0) {\n                fcn.004288f4(0, 0, 0, 0, 0, 0x54);\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 567
    },
    "00438181": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00438181(uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar1 = fcn.0042bbf1();\n    if (piVar1 != NULL) {\n        var_14h = 0;\n        var_10h = 0;\n        var_ch = 0;\n        var_8h = 0;\n        iVar2 = (**(*piVar1 + 0x54))(0, 0, 0x50800000, &var_14h, var_4h, arg_ch, arg_8h);\n        if (iVar2 != 0) {\n            if (*0x46038c == 0) {\n                return piVar1;\n            }\n            uVar3 = fcn.0042879d();\n            if ((uVar3 & 0x200) == 0) {\n                return piVar1;\n            }\n            fcn.004287e8(0x200, 0, 0x20);\n            return piVar1;\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 291
    },
    "00438955": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00438955(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint32_t uVar5;\n    uint var_108h;\n    uint32_t var_4h;\n    \n    uVar3 = (*_sym.imp.USER32.dll_SetActiveWindow)(*(in_ECX + 0x1c));\n    fcn.00425960(uVar3);\n    pcVar2 = _sym.imp.SHELL32.dll_DragQueryFileA;\n    uVar5 = 0;\n    var_4h = (*_sym.imp.SHELL32.dll_DragQueryFileA)(arg_8h, 0xffffffff, 0, 0);\n    iVar4 = fcn.0043d8de();\n    piVar1 = *(iVar4 + 4);\n    if (var_4h != 0) {\n        do {\n            (*pcVar2)(arg_8h, uVar5, &var_108h, 0x104);\n            (**(*piVar1 + 0x7c))(&var_108h);\n            uVar5 = uVar5 + 1;\n        } while (uVar5 < var_4h);\n    }\n    (*_sym.imp.SHELL32.dll_DragFinish)(arg_8h);\n    return;\n}\n",
        "token_count": 312
    },
    "004397d4": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004397d4(int32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t *in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (in_ECX[0x2c] == 0) {\n        in_ECX[0x2c] = 1;\n        if ((in_ECX[0x2e] & 4U) != 0) {\n            arg_8h = 1;\n        }\n        in_ECX[0x2e] = in_ECX[0x2e] & 0xfffffff3;\n        if ((arg_8h != 0) && (in_ECX[0x1a] != NULL)) {\n            (**(*in_ECX[0x1a] + 0x50))();\n        }\n        uVar1 = fcn.00428783();\n        if ((uVar1 & 0x2000) == 0) {\n            fcn.004273b0(0, 0xffff, 0xe900, 2, in_ECX + 0x16, 0, 1);\n        }\n        else {\n            var_8h = 0x7fff;\n            var_4h = 0x7fff;\n            var_10h = 0;\n            var_ch = 0;\n            fcn.004273b0(0, 0xffff, 0xe900, 1, &var_10h, &var_10h, 0);\n            fcn.004273b0(0, 0xffff, 0xe900, 2, in_ECX + 0x16, &var_10h, 1);\n            (**(*in_ECX + 0x60))(&var_10h, 0);\n            fcn.004288f4(0, 0, 0, var_8h - var_10h, var_4h - var_ch, 0x16);\n        }\n        in_ECX[0x2c] = 0;\n    }\n    return;\n}\n",
        "token_count": 485
    },
    "00439f01": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lptm\n// WARNING: Variable defined which should be unmapped: var_a4h\n\nvoid fcn.00439f01(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    bool bVar4;\n    char *lptm;\n    uint var_a4h;\n    uint lpvObject;\n    uint var_74h;\n    uint var_70h;\n    uint var_60h;\n    uint var_50h;\n    uint var_49h;\n    uint lpString1;\n    uint var_24h;\n    uint var_20h;\n    uint hdc;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    if (*0x460394 != 0) goto code_r0x0043a060;\n    fcn.0043e309(10);\n    if (*0x4605ec == 0) {\n        iVar2 = fcn.0043d8de();\n        *0x4605ec = (*_sym.imp.USER32.dll_LoadBitmapA)(*(iVar2 + 0xc), 0x7912);\n        iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(*0x4605ec, 0x18, unaff_EBP + -0x78);\n        if (iVar2 != 0) {\n            *0x4605e0 = *(unaff_EBP + -0x74);\n            *0x4605e4 = *(unaff_EBP + -0x70);\n        }\n    }\n    if (*0x4605e8 == 0) {\n        fcn.0040ffd0(unaff_EBP + -0x60, 0, 0x3c);\n        *(unaff_EBP + -0x49) = 1;\n        *(unaff_EBP + -0x50) = 400;\n        *(unaff_EBP + -0x60) = 1 - *0x4605e4;\n        iVar2 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0x2a);\n        if (iVar2 == 0) {\n            lptm = \"Small Fonts\";\n        }\n        else {\n            lptm = \"Terminal\";\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(unaff_EBP + -0x44, lptm);\n        iVar2 = fcn.0042f35e(0xf233, unaff_EBP + -0x60);\n        if (iVar2 == 0) {\n            *(unaff_EBP + -0x45) = 0x20;\n        }\n        *0x4605e8 = (*_sym.imp.GDI32.dll_CreateFontIndirectA)(unaff_EBP + -0x60);\n        if (*0x4605e8 != 0) goto code_r0x00439fe2;\n    }\n    else {\ncode_r0x00439fe2:\n        fcn.0042efe6(0);\n        iVar2 = *0x4605e8;\n        pcVar1 = _sym.imp.GDI32.dll_SelectObject;\n        bVar4 = *0x4605e8 == 0;\n        *(unaff_EBP + -4) = 0;\n        if (bVar4) {\n            iVar2 = 0;\n        }\n        else {\n            iVar2 = (*pcVar1)(*(unaff_EBP + -0x20), iVar2);\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetTextMetricsA)(*(unaff_EBP + -0x1c), unaff_EBP + -0xb0);\n        *(unaff_EBP + -0x10) = uVar3;\n        if (iVar2 != 0) {\n            (*pcVar1)(*(unaff_EBP + -0x20), iVar2);\n        }\n        if ((*(unaff_EBP + -0x10) == 0) || (*0x4605e4 < *(unaff_EBP + -0xb0) - *(unaff_EBP + -0xa4))) {\n            fcn.0042f518(0x4605e8);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0042f058();\n    }\n    fcn.0043e379(10);\ncode_r0x0043a060:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1018
    },
    "0043b25e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: nLeftRect\n// WARNING: Variable defined which should be unmapped: nBottomRect\n// WARNING: Variable defined which should be unmapped: nRightRect\n// WARNING: Variable defined which should be unmapped: nTopRect\n\nvoid __cdecl\nfcn.0043b25e(uint lprcSrc2, uint dx, uint dy, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, uint arg_24h)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint nLeftRect;\n    uint nTopRect;\n    uint nRightRect;\n    uint nBottomRect;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint hrgnDest;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hrgnSrc1;\n    uint var_14h;\n    uint hrgnSrc2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    fcn.00408dcd();\n    *(unaff_EBP + -0x2c) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.00408dcd();\n    *(unaff_EBP + -0x1c) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 1;\n    fcn.00408dcd();\n    *(unaff_EBP + -0x14) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 2;\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(*(unaff_EBP + 8));\n    fcn.0042f28e(uVar2);\n    (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, *(unaff_EBP + 8));\n    (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0xc), -*(unaff_EBP + 0x10));\n    (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, *(unaff_EBP + 8));\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(unaff_EBP + -0x44);\n    fcn.0042f28e(uVar2);\n    uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n    fcn.0042f28e(uVar2);\n    (*_sym.imp.GDI32.dll_CombineRgn)\n              (*(unaff_EBP + -0x28), -(unaff_EBP != 0x1c) & *(unaff_EBP + -0x18), \n               -(unaff_EBP != 0x14) & *(unaff_EBP + -0x10), 3);\n    if (*(unaff_EBP + 0x20) == 0) {\n        uVar2 = fcn.0043b1eb();\n        *(unaff_EBP + 0x20) = uVar2;\n    }\n    if (*(unaff_EBP + 0x24) == 0) {\n        *(unaff_EBP + 0x24) = *(unaff_EBP + 0x20);\n    }\n    fcn.00408dcd();\n    *(unaff_EBP + -0x24) = vtable.CRgn.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.00408dcd();\n    *(unaff_EBP + -0x34) = vtable.CRgn.0;\n    puVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 4;\n    if (puVar1 != NULL) {\n        uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n        fcn.0042f28e(uVar2);\n        (*_sym.imp.GDI32.dll_SetRectRgn)(*(unaff_EBP + -0x18), *puVar1, puVar1[1], puVar1[2], puVar1[3]);\n        (*_sym.imp.USER32.dll_CopyRect)(unaff_EBP + -0x44, puVar1);\n        (*_sym.imp.USER32.dll_InflateRect)(unaff_EBP + -0x44, -*(unaff_EBP + 0x18), -*(unaff_EBP + 0x1c));\n        (*_sym.imp.USER32.dll_IntersectRect)(unaff_EBP + -0x44, unaff_EBP + -0x44, puVar1);\n        (*_sym.imp.GDI32.dll_SetRectRgn)\n                  (*(unaff_EBP + -0x10), *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c), \n                   *(unaff_EBP + -0x38));\n        (*_sym.imp.GDI32.dll_CombineRgn)\n                  (*(unaff_EBP + -0x20), -(unaff_EBP != 0x1c) & *(unaff_EBP + -0x18), \n                   -(unaff_EBP != 0x14) & *(unaff_EBP + -0x10), 3);\n        if (*(*(unaff_EBP + 0x20) + 4) == *(*(unaff_EBP + 0x24) + 4)) {\n            uVar2 = (*_sym.imp.GDI32.dll_CreateRectRgn)(0, 0, 0, 0);\n            fcn.0042f28e(uVar2);\n            (*_sym.imp.GDI32.dll_CombineRgn)\n                      (*(unaff_EBP + -0x30), -(unaff_EBP != 0x24) & *(unaff_EBP + -0x20), \n                       -(unaff_EBP != 0x2c) & *(unaff_EBP + -0x28), 3);\n        }\n    }\n    if ((*(*(unaff_EBP + 0x20) + 4) != *(*(unaff_EBP + 0x24) + 4)) && (puVar1 != NULL)) {\n        fcn.0042eca6(unaff_EBP + -0x24);\n        (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n        uVar2 = fcn.0042e8e0(*(unaff_EBP + 0x24));\n        (*_sym.imp.GDI32.dll_PatBlt)\n                  (extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), \n                   *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44), *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n        fcn.0042e8e0(uVar2);\n    }\n    iVar3 = unaff_EBP + -0x34;\n    if (*(unaff_EBP + -0x30) == 0) {\n        iVar3 = unaff_EBP + -0x2c;\n    }\n    fcn.0042eca6(iVar3);\n    (**(*extraout_ECX + 0x50))(unaff_EBP + -0x44);\n    iVar3 = fcn.0042e8e0(*(unaff_EBP + 0x20));\n    (*_sym.imp.GDI32.dll_PatBlt)\n              (extraout_ECX[1], *(unaff_EBP + -0x44), *(unaff_EBP + -0x40), *(unaff_EBP + -0x3c) - *(unaff_EBP + -0x44)\n               , *(unaff_EBP + -0x38) - *(unaff_EBP + -0x40), 0x5a0049);\n    if (iVar3 != 0) {\n        fcn.0042e8e0(iVar3);\n    }\n    fcn.0042eca6(0);\n    *(unaff_EBP + -0x34) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 5;\n    fcn.0042f2e5();\n    *(unaff_EBP + -0x24) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 6;\n    fcn.0042f2e5();\n    *(unaff_EBP + -0x14) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 7;\n    fcn.0042f2e5();\n    *(unaff_EBP + -0x1c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 8;\n    fcn.0042f2e5();\n    *(unaff_EBP + -0x2c) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 9;\n    fcn.0042f2e5();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 2176
    },
    "0043c266": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0043c266(int32_t hgdiobj)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint lpvObject;\n    int32_t var_30h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_GetObjectA)(hgdiobj, 0x18, &lpvObject);\n    if (in_ECX[0x20] == 0) {\n        var_8h = 0;\n        var_4h = hgdiobj;\n        iVar1 = (**(*in_ECX + 0xa0))(0x413, var_30h / in_ECX[0x22], &var_8h);\n        uVar2 = iVar1 == 0;\n    }\n    else {\n        var_ch = var_30h / in_ECX[0x22];\n        var_1ch = 0;\n        var_14h = 0;\n        var_10h = hgdiobj;\n        var_18h = in_ECX[0x20];\n        uVar2 = (**(*in_ECX + 0xa0))(0x42e, 0, &var_1ch);\n    }\n    if (uVar2 != 0) {\n        fcn.0042f518(in_ECX + 0x20);\n        in_ECX[0x20] = hgdiobj;\n    }\n    return uVar2;\n}\n",
        "token_count": 374
    },
    "0043e243": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nbool fcn.0043e243(void)\n\n{\n    uint uVar1;\n    uint32_t var_14h;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)(&var_14h);\n    (*_sym.imp.KERNEL32.dll_GetCPInfo)(uVar1);\n    return 1 < var_14h;\n}\n",
        "token_count": 80
    },
    "00441f3e": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00441f3e(int32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint *puVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    int32_t iVar5;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    \n    pcVar3 = _sym.imp.USER32.dll_ShowScrollBar;\n    if (*(in_ECX + 0xec) == 0) {\n        *(in_ECX + 0xf8) = *(in_ECX + 0xe8);\n        (*pcVar3)(*(in_ECX + 0x1c), 0, 0);\n        iVar4 = *(**(in_ECX + 0x114) + 0x5c);\n        uVar2 = *(iVar4 + 0x1e);\n        if ((0x7fff < uVar2) || (arg_8h = 1,  0x7fff < uVar2 - *(iVar4 + 0x1c))) {\n            arg_8h = 0;\n        }\n        (*pcVar3)(*(in_ECX + 0x1c), 1, arg_8h);\n        if (arg_8h != 0) {\n            var_18h = 3;\n            var_14h = *(*(**(in_ECX + 0x114) + 0x5c) + 0x1c);\n            var_10h = *(*(**(in_ECX + 0x114) + 0x5c) + 0x1e);\n            var_ch = 1;\n            iVar4 = fcn.00427229(1, &var_1ch, 0);\n            if (iVar4 == 0) {\n                fcn.00427183(1, var_14h, var_10h, 0);\n            }\n        }\n        fcn.004420ad(*(in_ECX + 0xf4), 1);\n    }\n    else {\n        iVar4 = *(in_ECX + 0x90);\n        *(in_ECX + 0xf8) = 1;\n        iVar5 = arg_8h * 0x28;\n        *(iVar4 + 0x20) = *(iVar4 + 0x20 + iVar5);\n        *(iVar4 + 0x24) = *(iVar4 + 0x24 + iVar5);\n        iVar4 = *(in_ECX + 0x90);\n        *(iVar4 + 0x10) = *(iVar4 + 0x10 + iVar5);\n        *(iVar4 + 0x14) = *(iVar4 + 0x14 + iVar5);\n        fcn.004420ad(*(in_ECX + 0xf4) + arg_8h, 0);\n        fcn.00441668(0);\n        pcVar3 = _sym.imp.KERNEL32.dll_MulDiv;\n        puVar1 = iVar5 + 0x18 + *(in_ECX + 0x90);\n        iVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(arg_ch, *puVar1, *(iVar5 + 0x1c + *(in_ECX + 0x90)));\n        iVar5 = (*pcVar3)(arg_10h, *puVar1, puVar1[1]);\n        fcn.004304d0(iVar4 + **(in_ECX + 0x90), iVar5 + (*(in_ECX + 0x90))[1]);\n    }\n    return;\n}\n",
        "token_count": 818
    },
    "00443556": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00443556(int32_t arg_8h, uint32_t arg_ch, int32_t *arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0;\n    arg_8h = arg_8h - arg_14h;\n    if (arg_ch != 0) {\n        do {\n            if (*arg_10h != arg_8h && arg_8h <= *arg_10h) {\n                arg_18h = *arg_10h;\n                goto code_r0x0044357f;\n            }\n            uVar1 = uVar1 + 1;\n            arg_10h = arg_10h + 1;\n        } while (uVar1 < arg_ch);\n    }\n    arg_18h = (arg_8h / arg_18h + 1) * arg_18h;\ncode_r0x0044357f:\n    return arg_18h + arg_14h;\n}\n",
        "token_count": 235
    },
    "0040962d": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_94h\n\nvoid __cdecl fcn.0040962d(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint32_t var_94h;\n    uint uStack148;\n    uint uStack144;\n    int32_t lpvObject;\n    uint var_78h;\n    uint var_71h;\n    uint lpMultiByteStr;\n    uint lpFontDesc;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint hdc;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -0x14) = 0;\n    *(unaff_EBP + -0x18) = 0x44bd14;\n    iVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    if ((iVar2 == 0) || (*(iVar2 + 4) == 0)) {\n        lpvObject = 0x11;\n        uStack144 = 0x409667;\n        iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)();\n        *(unaff_EBP + -0x14) = iVar2;\n        if (iVar2 == 0) {\n            lpvObject = 0xd;\n            uStack144 = 0x409672;\n            iVar2 = (*pcVar1)();\n            *(unaff_EBP + -0x14) = iVar2;\n            if (iVar2 == 0) {\n                *(extraout_ECX + 0x44) = 0;\n                *(unaff_EBP + -0x18) = vtable.CGdiObject.0;\n                *(unaff_EBP + -4) = 1;\n                goto code_r0x00409787;\n            }\n        }\n        iVar2 = unaff_EBP + -0x18;\n    }\n    lpvObject = unaff_EBP + -0x88;\n    uStack144 = 0x3c;\n    uStack148 = *(iVar2 + 4);\n    var_94h = 0x4096a4;\n    (*_sym.imp.GDI32.dll_GetObjectA)();\n    *(unaff_EBP + -0x4c) = 0x20;\n    if (unaff_EBP == 0x6c) {\n        *0x24 = 0;\n        iVar2 = extraout_ECX;\n    }\n    else {\n        var_94h = unaff_EBP - 0x6c;\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n        fcn.00410700();\n        var_94h = var_94h & 0xffff0000;\n        (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                  (0, 0, unaff_EBP + -0x6c, 0xffffffff, &fcn.0040962d::var_94h, iVar2 + 1);\n        iVar2 = *(unaff_EBP + -0x10);\n        *(unaff_EBP + -0x48) = &fcn.0040962d::var_94h;\n    }\n    *(unaff_EBP + -0x3c) = *(unaff_EBP + -0x78);\n    *(unaff_EBP + -0x3a) = *(unaff_EBP + -0x71);\n    *(unaff_EBP + -0x38) = *(unaff_EBP + -0x74);\n    *(unaff_EBP + -0x34) = *(unaff_EBP + -0x73);\n    *(unaff_EBP + -0x30) = *(unaff_EBP + -0x72);\n    iVar3 = *(unaff_EBP + -0x88);\n    if (iVar3 < 0) {\n        iVar3 = -iVar3;\n    }\n    var_94h = *(iVar2 + 0x1c);\n    fcn.0042f09a(var_94h);\n    *(unaff_EBP + -4) = 2;\n    iVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(unaff_EBP + -0x24), 0x5a);\n    puVar5 = iVar2 + 0x44;\n    *(unaff_EBP + -0x40) = 0;\n    *(unaff_EBP + -0x44) = (iVar3 * 720000) / iVar4;\n    fcn.0043f13b(puVar5);\n    iVar2 = (*_sym.imp.OLEPRO32.DLL_OleCreateFontIndirect)(unaff_EBP + -0x4c, 0x44d768, puVar5);\n    if (iVar2 < 0) {\n        *puVar5 = 0;\n    }\n    *(unaff_EBP + -4) = 0;\n    lpvObject = 0x409779;\n    fcn.0042f10c();\n    *(unaff_EBP + -0x18) = vtable.CGdiObject.0;\n    *(unaff_EBP + -4) = 3;\ncode_r0x00409787:\n    lpvObject = 0x40978f;\n    fcn.0042f2e5();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 1332
    },
    "0042408f": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042408f(uint16_t *arg_8h, uint arg_ch)\n\n{\n    uint16_t **in_ECX;\n    \n    if (*arg_8h < 0x76c) {\n        *in_ECX = NULL;\n    }\n    else {\n        fcn.00424043(*arg_8h, arg_8h[1], arg_8h[3], arg_8h[4], arg_8h[5], arg_8h[6], arg_ch);\n        *in_ECX = arg_8h;\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "0042b263": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042b263(uint arg_8h, uint *arg_ch)\n\n{\n    uint var_104h;\n    uint var_4h;\n    \n    var_4h = 0;\n    (*_sym.imp.USER32.dll_wsprintfA)\n              (&var_104h, \"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\", *arg_ch, *(arg_ch + 1), *(arg_ch + 6), \n               *(arg_ch + 2), *(arg_ch + 9), *(arg_ch + 10), *(arg_ch + 0xb), *(arg_ch + 3), *(arg_ch + 0xd), \n               *(arg_ch + 0xe), *(arg_ch + 0xf));\n    fcn.0042a3c6(&var_104h);\n    return arg_8h;\n}\n",
        "token_count": 207
    },
    "0042f8b4": {
        "rules": [
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042f8b4(int32_t param_1)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint uVar5;\n    \n    if (*(*(param_1 + 0x60) + -8) == 0) {\n        fcn.0042bdd1(*(param_1 + 0x3c));\n    }\n    pcVar2 = _sym.imp.USER32.dll_LoadAcceleratorsA;\n    pcVar1 = _sym.imp.USER32.dll_LoadMenuA;\n    if ((*(param_1 + 0x44) != 0) && (*(param_1 + 0x2c) == 0)) {\n        iVar3 = fcn.0043d8de();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x2c) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x44));\n        *(param_1 + 0x30) = uVar5;\n    }\n    if ((*(param_1 + 0x40) != 0) && (*(param_1 + 0x34) == 0)) {\n        iVar3 = fcn.0043d8de();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x34) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x40));\n        *(param_1 + 0x38) = uVar5;\n    }\n    if ((*(param_1 + 0x48) != 0) && (*(param_1 + 0x24) == 0)) {\n        iVar3 = fcn.0043d8de();\n        uVar5 = *(iVar3 + 0xc);\n        uVar4 = (*pcVar1)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x24) = uVar4;\n        uVar5 = (*pcVar2)(uVar5, *(param_1 + 0x48));\n        *(param_1 + 0x28) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 558
    },
    "0040120a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/c6eee0698c4b4bd09944ca66a2e4c269"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040120a(uchar *param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0x500) = 0x100;\n    fcn.004011db();\n    iVar1 = 3;\n    do {\n        *param_1 = 0;\n        param_1[0xff] = 0xff;\n        param_1 = param_1 + 0x100;\n        iVar1 = iVar1 + -1;\n    } while (iVar1 != 0);\n    fcn.004010d8();\n    return;\n}\n",
        "token_count": 131
    },
    "004015ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004015ba(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    iVar1 = 0;\n    piVar2 = param_1 + 4;\n    iVar3 = 6;\n    do {\n        iVar1 = iVar1 + (*piVar2 != 0);\n        piVar2 = piVar2 + 1;\n        iVar3 = iVar3 + -1;\n    } while (iVar3 != 0);\n    return iVar1;\n}\n",
        "token_count": 126
    },
    "004015d4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nchar __fastcall fcn.004015d4(int32_t param_1)\n\n{\n    return (*(param_1 + 0x24) != 0) + (*(param_1 + 0x20) != 0) + (*(param_1 + 0x1c) != 0);\n}\n",
        "token_count": 67
    },
    "004015f1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ch\n\nvoid fcn.004015f1(void)\n\n{\n    uint uVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    fcn.004079dd(*(extraout_ECX + 4), *(extraout_ECX + 8));\n    uVar1 = *(extraout_ECX + 0xc);\n    *(unaff_EBP + -4) = 0;\n    fcn.004079dd(*(extraout_ECX + 4), uVar1);\n    *(unaff_EBP + -4) = 1;\n    fcn.00407a7c(unaff_EBP + -0x2c);\n    fcn.00407a39(unaff_EBP + -0x1c);\n    fcn.00407abe();\n    *(unaff_EBP + -4) = 0;\n    fcn.00407990();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00407990();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 296
    },
    "00401b95": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401b95(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.USER32.dll_LoadStringW)(0, arg_8h, &var_4h, 0);\n    if (iVar1 != 0) {\n        iVar1 = iVar1 + 1;\n        uVar2 = fcn.004253fd(iVar1);\n        fcn.0040ffd0(uVar2, 0, iVar1);\n        (*_sym.imp.USER32.dll_LoadStringA)(0, arg_8h, uVar2, iVar1);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 163
    },
    "0043ca19": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043ca19(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    code *pcVar4;\n    uint32_t uVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWinApp.0;\n    piVar1 = extraout_ECX[0x20];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(1);\n    }\n    if (extraout_ECX[0x2a] != NULL) {\n        (**(*extraout_ECX[0x2a] + 0x14))(1);\n    }\n    iVar3 = fcn.0043d8de();\n    if (*(iVar3 + 0x14) == '\\0') {\n        if (*0x45ff8c != NULL) {\n            (**(**0x45ff8c + 4))(1);\n            *0x45ff8c = NULL;\n        }\n        if (*0x45ff88 != NULL) {\n            (**(**0x45ff88 + 4))(1);\n            *0x45ff88 = NULL;\n        }\n    }\n    if (extraout_ECX[0x25] != NULL) {\n        fcn.0042f5a8(extraout_ECX[0x25]);\n    }\n    pcVar4 = extraout_ECX[0x26];\n    if (pcVar4 != NULL) {\n        pcVar4 = fcn.0042f5a8(pcVar4);\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_GlobalDeleteAtom;\n    uVar5 = pcVar4 & 0xffff0000 | *(extraout_ECX + 0x2c);\n    if (*(extraout_ECX + 0x2c) != 0) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_GlobalDeleteAtom)(uVar5);\n    }\n    if (*(extraout_ECX + 0xb2) != 0) {\n        (*pcVar2)(uVar5 & 0xffff0000 | *(extraout_ECX + 0xb2));\n    }\n    if (extraout_ECX[0x2b] != NULL) {\n        (**(*extraout_ECX[0x2b] + 4))(1);\n    }\n    iVar3 = fcn.0043d8de();\n    if (*(iVar3 + 0x10) == extraout_ECX[0x1e]) {\n        *(iVar3 + 0x10) = 0;\n    }\n    if (*(iVar3 + 4) == extraout_ECX) {\n        *(iVar3 + 4) = 0;\n    }\n    fcn.00410f3f(extraout_ECX[0x1e]);\n    fcn.00410f3f(extraout_ECX[0x1f]);\n    fcn.00410f3f(extraout_ECX[0x22]);\n    fcn.00410f3f(extraout_ECX[0x23]);\n    fcn.00410f3f(extraout_ECX[0x24]);\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[10] = NULL;\n    fcn.00443dd6();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 865
    },
    "004038e4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004038e4(int32_t param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(param_1 + 0x30)) {\n        piVar1 = *(param_1 + 0x2c);\n        do {\n            if (*piVar1 == param_2) {\n                return 1;\n            }\n            iVar2 = iVar2 + 1;\n            piVar1 = piVar1 + 1;\n        } while (iVar2 < *(param_1 + 0x30));\n    }\n    return 0;\n}\n",
        "token_count": 152
    },
    "0040417a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040417a(uint arg_8h)\n\n{\n    float fVar1;\n    uchar uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    uchar *puVar6;\n    int32_t extraout_ECX;\n    int32_t *piVar7;\n    int32_t iVar8;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar3 = *(extraout_ECX + 8);\n    uVar4 = fcn.004253fd(iVar3 << 3);\n    *(unaff_EBP + -0x2c) = *0x447cd8;\n    *(unaff_EBP + -0x24) = uVar4;\n    *(unaff_EBP + -0x20) = 0;\n    if (0 < iVar3) {\n        piVar7 = *(extraout_ECX + 4);\n        iVar8 = iVar3;\n        do {\n            fVar1 = *(*piVar7 + 8);\n            if (fVar1 < *(unaff_EBP + -0x2c)) {\n                *(unaff_EBP + -0x2c) = fVar1;\n            }\n            if (*(unaff_EBP + -0x20) < fVar1) {\n                *(unaff_EBP + -0x20) = fVar1;\n            }\n            piVar7 = piVar7 + 1;\n            iVar8 = iVar8 + -1;\n        } while (iVar8 != 0);\n    }\n    iVar8 = 0;\n    *(unaff_EBP + -0x34) = *(unaff_EBP + -0x20) - *(unaff_EBP + -0x2c);\n    if (0 < iVar3) {\n        do {\n            uVar5 = fcn.0040fc64();\n            if (0xff < uVar5) {\n                uVar5 = 0xff;\n            }\n            puVar6 = (uVar5 & 0xff) + *(unaff_EBP + 8);\n            *(unaff_EBP + -0x10) = puVar6[0x200];\n            uVar2 = *puVar6;\n            *(unaff_EBP + -0x14) = puVar6[0x100];\n            *(unaff_EBP + -0x18) = uVar2;\n            fcn.00401093(*(unaff_EBP + -0x18), *(unaff_EBP + -0x14), *(unaff_EBP + -0x10));\n            *(unaff_EBP + -4) = 0;\n            fcn.004010ae();\n            *(unaff_EBP + -4) = 0xffffffff;\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < iVar3);\n    }\n    fcn.00425426(*(unaff_EBP + -0x24));\n    *(extraout_ECX + 0xbc) = 1;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 736
    },
    "0040427f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n\nuint fcn.0040427f(void)\n\n{\n    float fVar1;\n    double dVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    char *pcVar8;\n    uint var_30h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar7 = *0x45c084;\n    *(unaff_EBP + -0x10) = &stack0xffffffd0;\n    *(unaff_EBP + -0x14) = uVar7;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a900();\n    uVar7 = *(extraout_ECX + 0x18);\n    uVar3 = *(extraout_ECX + 8);\n    *(unaff_EBP + -4) = 2;\n    fcn.0042373f(unaff_EBP + -0x14, \"# Mesh : %d vertices, %d faces\\n\", uVar3, uVar7);\n    piVar4 = *(unaff_EBP + 8);\n    (**(*piVar4 + 0x54))(*(unaff_EBP + -0x14));\n    (**(*piVar4 + 0x54))(\"DEF Mesh-ROOT Transform {\\n\");\n    fVar1 = *(extraout_ECX + 0x50);\n    *(unaff_EBP + 8) = *(extraout_ECX + 0x4c);\n    *(unaff_EBP + -0x18) = *(extraout_ECX + 0x48);\n    fcn.0042373f(unaff_EBP + -0x14, \"  translation %g %g %g\\n\", SUB84(*(unaff_EBP + -0x18), 0), \n                 *(unaff_EBP + -0x18) >> 0x20, SUB84(*(unaff_EBP + 8), 0), *(unaff_EBP + 8) >> 0x20, SUB84(fVar1, 0), \n                 fVar1 >> 0x20);\n    (**(*piVar4 + 0x54))(*(unaff_EBP + -0x14));\n    fVar1 = *(extraout_ECX + 0x54) * *0x447d14;\n    *(unaff_EBP + 8) = *(extraout_ECX + 0x40);\n    dVar2 = fVar1;\n    *(unaff_EBP + -0x18) = *(extraout_ECX + 0x3c);\n    *(unaff_EBP + -0x1c) = *(extraout_ECX + 0x38);\n    fcn.0042373f(unaff_EBP + -0x14, \"  rotation %g %g %g %g\\n\", SUB84(*(unaff_EBP + -0x1c), 0), \n                 *(unaff_EBP + -0x1c) >> 0x20, SUB84(*(unaff_EBP + -0x18), 0), *(unaff_EBP + -0x18) >> 0x20, \n                 SUB84(*(unaff_EBP + 8), 0), *(unaff_EBP + 8) >> 0x20, SUB84(dVar2, 0), dVar2 >> 0x20);\n    (**(*piVar4 + 0x54))(*(unaff_EBP + -0x14));\n    fVar1 = *(extraout_ECX + 0x30);\n    *(unaff_EBP + 8) = *(extraout_ECX + 0x2c);\n    *(unaff_EBP + -0x1c) = *(extraout_ECX + 0x28);\n    fcn.0042373f(unaff_EBP + -0x14, \"  scale %g %g %g\\n\", SUB84(*(unaff_EBP + -0x1c), 0), *(unaff_EBP + -0x1c) >> 0x20, \n                 SUB84(*(unaff_EBP + 8), 0), *(unaff_EBP + 8) >> 0x20, SUB84(fVar1, 0), fVar1 >> 0x20);\n    (**(*piVar4 + 0x54))(*(unaff_EBP + -0x14));\n    (**(*piVar4 + 0x54))(\"  children [\\n\");\n    (**(*piVar4 + 0x54))(\"    Shape {\\n\");\n    (**(*piVar4 + 0x54))(\"      appearance Appearance {\\n\");\n    (**(*piVar4 + 0x54))(\"        material Material {\\n\");\n    (**(*piVar4 + 0x54))(\"          diffuseColor 0 0 0\\n\");\n    (**(*piVar4 + 0x54))(\"        }\\n\");\n    (**(*piVar4 + 0x54))(\"      }\\n\");\n    (**(*piVar4 + 0x54))(\"      geometry DEF Mesh-FACES IndexedFaceSet {\\n\");\n    (**(*piVar4 + 0x54))(\"        ccw TRUE\\n\");\n    (**(*piVar4 + 0x54))(\"        solid TRUE\\n\");\n    (**(*piVar4 + 0x54))(\"        coord DEF Mesh-COORD Coordinate { point [\\n\");\n    iVar5 = *(extraout_ECX + 8);\n    *(unaff_EBP + 8) = 0;\n    while (*(unaff_EBP + 8) < iVar5) {\n        iVar6 = *(*(extraout_ECX + 4) + *(unaff_EBP + 8) * 4);\n        uVar7 = *(iVar6 + 4);\n        *(unaff_EBP + -0x1c) = *(iVar6 + 8);\n        *(unaff_EBP + -0x18) = uVar7;\n        fcn.0042373f(unaff_EBP + -0x14, \"          %g %g %g\");\n        (**(*piVar4 + 0x54))();\n        (**(*piVar4 + 0x54))();\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) + 1;\n    }\n    pcVar8 = \"        }\\n\";\n    (**(*piVar4 + 0x54))();\n    (**(*piVar4 + 0x54))(\"        coordIndex [\\n\", pcVar8);\n    uVar7 = *(extraout_ECX + 0x18);\n    *(unaff_EBP + 8) = 0;\n    *(unaff_EBP + -0x18) = uVar7;\n    while (*(unaff_EBP + 8) < *(unaff_EBP + -0x18)) {\n        iVar5 = *(*(extraout_ECX + 0x14) + *(unaff_EBP + 8) * 4);\n        uVar7 = *(iVar5 + 4);\n        *(unaff_EBP + -0x1c) = *(iVar5 + 8);\n        *(unaff_EBP + -0x20) = uVar7;\n        uVar7 = fcn.0040463b();\n        *(unaff_EBP + -0x24) = uVar7;\n        uVar7 = fcn.0040463b();\n        *(unaff_EBP + -0x1c) = uVar7;\n        uVar7 = fcn.0040463b();\n        fcn.0042373f(unaff_EBP + -0x14, \"          %d, %d, %d, -1\", uVar7, *(unaff_EBP + -0x1c));\n        (**(*piVar4 + 0x54))();\n        if (*(unaff_EBP + 8) == *(unaff_EBP + -0x18) + -1) {\n            uVar7 = 0x45b7ac;\n        }\n        else {\n            uVar7 = 0x45b7b0;\n        }\n        (**(*piVar4 + 0x54))(uVar7);\n        *(unaff_EBP + 8) = *(unaff_EBP + 8) + 1;\n    }\n    pcVar8 = \"        }\\n\";\n    (**(*piVar4 + 0x54))();\n    (**(*piVar4 + 0x54))(\"      }\\n\", pcVar8);\n    pcVar8 = \"    ]\\n\";\n    (**(*piVar4 + 0x54))();\n    (**(*piVar4 + 0x54))(\"  }\\n\\n\", pcVar8);\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a93e();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return 1;\n}\n",
        "token_count": 2107
    },
    "0040463b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040463b(int32_t **param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    \n    iVar1 = 0;\n    if (0 < param_1[1]) {\n        piVar2 = *param_1;\n        do {\n            if (*piVar2 == param_2) {\n                return iVar1;\n            }\n            iVar1 = iVar1 + 1;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 < param_1[1]);\n    }\n    return -1;\n}\n",
        "token_count": 141
    },
    "00405aa7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __fastcall fcn.00405aa7(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.004059e6();\n    iVar1 = fcn.00410730(param_1 + 0x10, \"#VRML V2.0\");\n    return iVar1 != 0;\n}\n",
        "token_count": 72
    },
    "00405ae3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00405ae3(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = param_1[2];\n    if (iVar1 < *param_1) {\n        do {\n            fcn.004059e6();\n            fcn.004107b0(param_1 + 4, 0x45b9b4, 3);\n        } while (param_1[2] < *param_1);\n    }\n    param_1[2] = iVar1;\n    return;\n}\n",
        "token_count": 122
    },
    "00405b17": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00405b17(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFileException.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358(extraout_ECX);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 146
    },
    "00405b7f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00405b7f(int32_t *param_1, uint param_2)\n\n{\n    uint arg_10h;\n    int32_t iVar1;\n    \n    if (param_1[2] < *param_1) {\n        do {\n            fcn.004059e6();\n            arg_10h = fcn.004101b0(param_2);\n            iVar1 = fcn.004107b0(param_1 + 4, param_2, arg_10h);\n            if (iVar1 == 0) {\n                iVar1 = fcn.004101b0(param_1 + 4);\n                param_1[2] = param_1[2] + (-1 - iVar1);\n                return 1;\n            }\n        } while (param_1[2] < *param_1);\n    }\n    return 0;\n}\n",
        "token_count": 194
    },
    "00405bd1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00405bd1(int32_t *param_1, uint param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (param_1[2] < *param_1) {\n        piVar1 = param_1 + 4;\n        do {\n            fcn.004059e6();\n            iVar2 = fcn.00410730(piVar1, param_2);\n            iVar3 = fcn.00410730(piVar1, param_2);\n            if (iVar3 != 0) {\n                iVar3 = fcn.004101b0(piVar1);\n                param_1[2] = param_1[2] + ((iVar2 - param_1) - iVar3) + -0x11;\n                return 1;\n            }\n        } while (param_1[2] < *param_1);\n    }\n    return 0;\n}\n",
        "token_count": 215
    },
    "00405c29": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00405c29(int32_t *param_1, uint param_2, uint param_3)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    if (param_1[2] < *param_1) {\n        piVar1 = param_1 + 4;\n        do {\n            fcn.004059e6();\n            iVar2 = fcn.00410730(piVar1, param_2);\n            iVar3 = fcn.00410730(piVar1, param_3);\n            if (iVar3 != 0) {\n                return 0;\n            }\n            iVar3 = fcn.00410730(piVar1, param_2);\n            if (iVar3 != 0) {\n                iVar3 = fcn.004101b0(piVar1);\n                param_1[2] = param_1[2] + ((iVar2 - param_1) - iVar3) + -0x11;\n                return 1;\n            }\n        } while (param_1[2] < *param_1);\n    }\n    return 0;\n}\n",
        "token_count": 255
    },
    "00406a32": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00406a32(void)\n\n{\n    uint uVar1;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = 0x44822c;\n    *(unaff_EBP + -4) = 2;\n    fcn.00406a89();\n    uVar1 = extraout_ECX[9];\n    *(unaff_EBP + -4) = 1;\n    fcn.00425426(uVar1);\n    uVar1 = extraout_ECX[5];\n    *(unaff_EBP + -4) = 0;\n    fcn.00425426(uVar1);\n    uVar1 = extraout_ECX[1];\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00425426(uVar1);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 305
    },
    "00406ac1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00406ac1(uint param_1)\n\n{\n    fcn.00404619(param_1);\n    return;\n}\n",
        "token_count": 30
    },
    "00406dfb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00406dfb(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.0042a0cd(in_ECX + 0x14, 0);\n    return arg_8h;\n}\n",
        "token_count": 79
    },
    "00407191": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nuint __cdecl fcn.00407191(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    fcn.0040716e();\n    uVar2 = *(unaff_EBP + 8);\n    fcn.0042a4e1(uVar2);\n    fcn.0042a3c6(uVar2);\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a806();\n    fcn.00423321(unaff_EBP + -0x14, 4);\n    *(unaff_EBP + -4) = 1;\n    iVar1 = fcn.00410670(*(unaff_EBP + -0x14), \".bmp\");\n    if (iVar1 == 0) {\n        uVar2 = fcn.00407281(uVar2);\n    }\n    else {\n        iVar1 = fcn.00410670(*(unaff_EBP + -0x14), \".raw\");\n        if (iVar1 == 0) {\n            uVar2 = fcn.00407599(uVar2, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14));\n        }\n        else {\n            *(unaff_EBP + -0x18) = *0x45c084;\n            *(unaff_EBP + -4) = 2;\n            fcn.0042373f(unaff_EBP + -0x18, \"CTexture::ReadFile : invalid file redirection : %s\\n\", uVar2);\n            fcn.004344cf(*(unaff_EBP + -0x10), 0, 0);\n            *(unaff_EBP + -4) = 1;\n            fcn.0042a358();\n            uVar2 = 0;\n        }\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 617
    },
    "004077ad": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004077ad(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, *(param_1 + 0xc) * *(param_1 + 0x40) + 0x28);\n    if (iVar1 != 0) {\n        arg_8h = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1);\n        fcn.0040fc90(arg_8h, param_1 + 0x18, 0x28);\n        fcn.0040fc90(arg_8h + 0x28, *(param_1 + 4), *(param_1 + 0xc) * *(param_1 + 0x40));\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(iVar1);\n    }\n    return iVar1;\n}\n",
        "token_count": 208
    },
    "00407b45": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407b45(void)\n\n{\n    fcn.0040465e(0, 0xffffffff);\n    return;\n}\n",
        "token_count": 31
    },
    "00407b72": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00407b72(int32_t param_1, int32_t param_2)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < *(param_1 + 0x40)) {\n        piVar1 = *(param_1 + 0x3c);\n        do {\n            if (*piVar1 == param_2) {\n                return 1;\n            }\n            iVar2 = iVar2 + 1;\n            piVar1 = piVar1 + 1;\n        } while (iVar2 < *(param_1 + 0x40));\n    }\n    return 0;\n}\n",
        "token_count": 152
    },
    "00407b9e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00407b9e(void)\n\n{\n    fcn.0040465e(0, 0xffffffff);\n    return;\n}\n",
        "token_count": 32
    },
    "00407c94": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00407c94(uint arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    fcn.0042a0cd(in_ECX + 0xac, 0);\n    return arg_8h;\n}\n",
        "token_count": 78
    },
    "00407eb9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00407eb9(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint32_t pvParam;\n    uint32_t uStack16;\n    uint32_t uStack12;\n    uint32_t uStack8;\n    \n    iVar2 = fcn.00407d20();\n    if (iVar2 == 0) {\n        if ((((arg_8h == 0x12340042) && (arg_ch != NULL)) && (0x27 < *arg_ch)) &&\n           (iVar2 = (*_sym.imp.USER32.dll_SystemParametersInfoA)(0x30, 0, &pvParam, 0),  iVar2 != 0)) {\n            arg_ch[1] = 0;\n            arg_ch[2] = 0;\n            pcVar1 = _sym.imp.USER32.dll_GetSystemMetrics;\n            uVar4 = (*_sym.imp.USER32.dll_GetSystemMetrics)(0);\n            arg_ch[3] = uVar4;\n            uVar4 = (*pcVar1)(1);\n            arg_ch[5] = pvParam;\n            arg_ch[6] = uStack16;\n            arg_ch[7] = uStack12;\n            arg_ch[8] = uStack8;\n            uVar3 = 1;\n            arg_ch[4] = uVar4;\n            arg_ch[9] = 1;\n            if (0x47 < *arg_ch) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(arg_ch + 10, \"DISPLAY\");\n            }\n        }\n        else {\n            uVar3 = 0;\n        }\n    }\n    else {\n        uVar3 = (**0x45ff78)(arg_8h, arg_ch);\n    }\n    return uVar3;\n}\n",
        "token_count": 414
    },
    "00407ff9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00407ff9(uint32_t *param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    \n    bVar4 = *(param_1 + 2) == -1;\n    uVar3 = *param_1;\n    if (bVar4) {\n        uVar3 = param_1[3];\n        piVar1 = param_1 + 0x1a;\n    }\n    else {\n        piVar1 = param_1 + 0x12;\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    do {\n        iVar2 = *piVar1;\n        piVar1 = piVar1 + 1;\n    } while (iVar2 != 0);\n    if ((uVar3 & 0x40) != 0) {\n        piVar1 = piVar1 + (-bVar4 & 2) + 1;\n        do {\n            iVar2 = *piVar1;\n            piVar1 = piVar1 + 1;\n        } while (iVar2 != 0);\n    }\n    return piVar1 + 3U & 0xfffffffc;\n}\n",
        "token_count": 399
    },
    "00409bcf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.00409bcf(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t **ppiVar2;\n    int32_t unaff_EBP;\n    code *pcVar3;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumUnknown.0;\n    pcVar3 = NULL;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if ((pcVar1 == NULL) && (ppiVar2 = extraout_ECX[9],  extraout_ECX[0xb] != NULL)) {\n        do {\n            (**(**ppiVar2 + 8))(*ppiVar2);\n            pcVar3 = pcVar3 + 1;\n            ppiVar2 = ppiVar2 + 1;\n        } while (pcVar3 < extraout_ECX[0xb]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043f5b2();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 344
    },
    "00409dd0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.00409dd0(uint arg_8h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00428a81();\n    pcVar1 = *(unaff_EBP + 8);\n    extraout_ECX[10] = 0xffffffff;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[7] = pcVar1;\n    extraout_ECX[9] = NULL;\n    extraout_ECX[0x13] = NULL;\n    extraout_ECX[0x14] = NULL;\n    extraout_ECX[0x15] = NULL;\n    fcn.00440514();\n    extraout_ECX[0x18] = NULL;\n    extraout_ECX[0x19] = NULL;\n    extraout_ECX[0x1c] = NULL;\n    extraout_ECX[0x21] = NULL;\n    extraout_ECX[0x22] = NULL;\n    extraout_ECX[0x23] = NULL;\n    extraout_ECX[0x24] = NULL;\n    extraout_ECX[0x25] = NULL;\n    extraout_ECX[0x26] = NULL;\n    extraout_ECX[0x27] = *0x45c084;\n    extraout_ECX[0x28] = NULL;\n    extraout_ECX[0x29] = NULL;\n    extraout_ECX[0x2e] = vtable.COleControlSite::XOleClientSite.0;\n    extraout_ECX[0x2f] = vtable.COleControlSite::XOleIPSite.0;\n    extraout_ECX[0x30] = vtable.COleControlSite::XOleControlSite.0;\n    extraout_ECX[0x31] = vtable.COleControlSite::XAmbientProps.0;\n    extraout_ECX[0x32] = vtable.COleControlSite::XPropertyNotifySink.0;\n    extraout_ECX[0x33] = vtable.COleControlSite::XEventSink.0;\n    extraout_ECX[0x34] = vtable.COleControlSite::XBoundObjectSite.0;\n    extraout_ECX[0x35] = vtable.COleControlSite::XNotifyDBEvents.0;\n    extraout_ECX[0x36] = vtable.COleControlSite::XRowsetNotify.0;\n    *extraout_ECX = vtable.COleControlSite.0;\n    fcn.0040ffd0(extraout_ECX + 0x2a, 0, 0x10);\n    uVar2 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 0x2a) = 0;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 755
    },
    "0040a01f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_28h\n\nbool fcn.0040a01f(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_28h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = *(extraout_ECX + 0x38);\n    iVar2 = *(extraout_ECX + 0x30);\n    *(unaff_EBP + -0x14) = *(extraout_ECX + 0x34) - *(extraout_ECX + 0x2c);\n    *(unaff_EBP + -0x10) = iVar1 - iVar2;\n    fcn.0042efe6(0);\n    *(unaff_EBP + -4) = 0;\n    fcn.0043b0cf(unaff_EBP + -0x14);\n    iVar1 = (**(**(extraout_ECX + 0x4c) + 0x44))(*(extraout_ECX + 0x4c), 1, unaff_EBP + -0x14);\n    if (-1 < iVar1) {\n        iVar2 = (**(**(extraout_ECX + 0x4c) + 0x48))(*(extraout_ECX + 0x4c), 1, unaff_EBP + -0x14);\n        if (-1 < iVar2) {\n            fcn.0043b15d(unaff_EBP + -0x14);\n            *(extraout_ECX + 0x34) = *(unaff_EBP + -0x14) + *(extraout_ECX + 0x2c);\n            *(extraout_ECX + 0x38) = *(extraout_ECX + 0x30) + *(unaff_EBP + -0x10);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042f058();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return -1 < iVar1;\n}\n",
        "token_count": 503
    },
    "0040abb0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040abb0(int32_t param_1)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t *var_4h;\n    \n    puVar1 = param_1 + 0x74;\n    var_4h = param_1;\n    fcn.0040ffd0(puVar1, 0, 0x10);\n    var_4h = NULL;\n    *puVar1 = 0x10;\n    iVar2 = (****(param_1 + 0x4c))(*(param_1 + 0x4c), 0x44d8f8, &var_4h);\n    if (-1 < iVar2) {\n        (**(*var_4h + 0xc))(var_4h, puVar1);\n        (**(*var_4h + 8))(var_4h);\n    }\n    return;\n}\n",
        "token_count": 203
    },
    "0040c716": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040c716(int32_t *param_1)\n\n{\n    uint *puVar1;\n    \n    puVar1 = *param_1;\n    if (puVar1 != NULL) {\n        (***puVar1)(puVar1, 0x45cb18, param_1 + 1);\n    }\n    return;\n}\n",
        "token_count": 79
    },
    "0040c9dc": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl fcn.0040c9dc(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_4h;\n    uint var_14h;\n    uint var_ch;\n    \n    fcn.0040fbf4();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *extraout_ECX = 0;\n    extraout_ECX[1] = iVar1;\n    iVar1 = fcn.004253fd(iVar1 << 3);\n    *extraout_ECX = iVar1;\n    iVar1 = *extraout_ECX;\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return (-(iVar1 != 0) & 0x7ff8fff2) + 0x8007000e;\n}\n",
        "token_count": 320
    },
    "0040d6c7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.0040d6c7(int32_t param_1, uint *param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    uVar2 = fcn.0040cca9(&param_2);\n    if (uVar2 == '\\0') {\n        uVar2 = uVar2 & 0xffffff00;\n    }\n    else {\n        iVar3 = unaff_retaddr * 0x30 + *(param_1 + 0x10);\n        uVar2 = *(iVar3 + 0x10);\n        uVar1 = *(*(iVar3 + 4) + (uVar2 & 3) + *(param_1 + 8) + 4 + uVar2);\n        *param_2 = uVar1;\n        uVar2 = CONCAT31(uVar1 >> 8, 1);\n    }\n    return uVar2;\n}\n",
        "token_count": 221
    },
    "0040d70b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0040d70b(int32_t param_1, int32_t param_2)\n\n{\n    return *(param_2 * 0x30 + 4 + *(param_1 + 0x10)) + *(param_1 + 8);\n}\n",
        "token_count": 65
    },
    "0040e268": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.0040e268(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_10h_2;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    uVar2 = *(extraout_ECX + 0xc);\n    *(extraout_ECX + 8) = *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    *(extraout_ECX + 0x18) = *(unaff_EBP + 0x10);\n    *(extraout_ECX + 0x10) = iVar1;\n    *(extraout_ECX + 0x14) = 0;\n    fcn.00425426(uVar2);\n    *(extraout_ECX + 0xc) = 0;\n    *(unaff_EBP + -4) = 0;\n    uVar2 = fcn.004253fd(iVar1 * 0x34);\n    *(extraout_ECX + 0xc) = uVar2;\n    iVar1 = *(extraout_ECX + 0xc);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return (-(iVar1 != 0) & 0x7ff8fff2) + 0x8007000e;\n}\n",
        "token_count": 446
    },
    "0040e2df": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040e2df(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    int32_t in_ECX;\n    \n    if (arg_1ch == 0) {\n        arg_1ch = 0;\n    }\n    else {\n        arg_1ch = arg_1ch - *(in_ECX + 8);\n    }\n    if (arg_18h == 0) {\n        arg_18h = 0;\n    }\n    else {\n        arg_18h = arg_18h - *(in_ECX + 8);\n    }\n    fcn.0040ca82(*(in_ECX + 0x14) * 0x34 + *(in_ECX + 0xc), arg_8h, arg_ch, arg_10h, 0, 0, 0, arg_14h - *(in_ECX + 8), \n                 arg_18h, arg_1ch, 0);\n    *(in_ECX + 0x14) = *(in_ECX + 0x14) + 1;\n    return;\n}\n",
        "token_count": 269
    },
    "0040e76a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040e76a(uint32_t arg_8h, uint32_t arg_ch, uint *arg_10h, uint arg_14h)\n\n{\n    uint32_t uVar1;\n    uint var_24h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (((arg_8h & 3) == 0) || (uVar1 = 0,  arg_ch == 0)) {\n        return 0;\n    }\ncode_r0x0040e788:\n    // switch table (31 cases) at 0x40e7ef\n    switch(*arg_10h) {\n    case 1:\n        var_4h = 3;\n        break;\n    case 2:\n    case 0x14:\n        var_4h = 5;\n        break;\n    case 3:\n    case 9:\n    case 10:\n    case 0x17:\n        var_4h = 6;\n        break;\n    default:\n        goto code_r0x0040e79e;\n    case 6:\n    case 7:\n    case 8:\n    case 0xb:\n    case 0xc:\n    case 0xf:\n    case 0x10:\n    case 0x13:\n    case 0x15:\n        var_4h = 7;\n        break;\n    case 0x18:\n        var_4h = 2;\n        break;\n    case 0x19:\n        var_4h = 1;\n        break;\n    case 0x1f:\n        var_4h = 4;\n    }\n    fcn.0040eadb(3);\n    var_8h = arg_14h;\n    fcn.0040adaa(&var_24h);\n    return var_ch;\ncode_r0x0040e79e:\n    uVar1 = uVar1 + 1;\n    arg_10h = arg_10h + 9;\n    if (arg_ch <= uVar1) {\n        return 0;\n    }\n    goto code_r0x0040e788;\n}\n",
        "token_count": 469
    },
    "0040eef5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040eef5(int32_t param_1, uint param_2)\n\n{\n    uint8_t uVar1;\n    int32_t unaff_retaddr;\n    \n    if (*(param_1 + 0x38) != 0) {\n        fcn.0040a920(param_2);\n        return;\n    }\n    uVar1 = fcn.0040eafe(param_1, 0);\n    if (((-(unaff_retaddr != 0) & 0x10U) + 0x10 & uVar1) != 0) {\n        (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0xf4, unaff_retaddr != 0, 1);\n    }\n    return;\n}\n",
        "token_count": 173
    },
    "0040f509": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid __cdecl fcn.0040f509(uint32_t lpMultiByteStr, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    ushort *in_ECX;\n    uint32_t uStack20;\n    uint var_ch;\n    \n    *(in_ECX + 4) = 0;\n    *in_ECX = 8;\n    if (lpMultiByteStr != 0) {\n        uStack20 = lpMultiByteStr;\n        if (arg_ch == 0xe) {\n            uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n            iVar2 = (*_sym.imp.OLEAUT32.dll_DllRegisterServer)(lpMultiByteStr, uVar1);\n        }\n        else {\n            iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n            fcn.00410700();\n            uStack20 = uStack20 & 0xffff0000;\n            (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &uStack20, iVar2 + 1);\n            iVar2 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(&uStack20);\n        }\n        *(in_ECX + 4) = iVar2;\n        if (iVar2 == 0) {\n            fcn.00423259();\n        }\n    }\n    return;\n}\n",
        "token_count": 321
    },
    "0040f641": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0040f641(uint param_1)\n\n{\n    fcn.0040ffd0(param_1, 0, 0x10);\n    return;\n}\n",
        "token_count": 39
    },
    "0041015a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0041015a(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1 <= *0x45d284) {\n        fcn.004142d0(9);\n        iVar1 = fcn.004146da(param_1);\n        fcn.00414331(9);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n    }\n    if (param_1 == 0) {\n        param_1 = 1;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x461ffc, 0, param_1 + 0xf & 0xfffffff0);\n    return iVar1;\n}\n",
        "token_count": 161
    },
    "00410f3f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00410f3f(int32_t param_1)\n\n{\n    int32_t argv;\n    \n    if (param_1 != 0) {\n        fcn.004142d0(9);\n        argv = fcn.00414384(param_1);\n        if (argv != 0) {\n            main(argv, param_1);\n            fcn.00414331(9);\n            return;\n        }\n        fcn.00414331(9);\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x461ffc, 0, param_1);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "0041186d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041186d(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    \n    puVar1 = fcn.004118e9();\n    iVar3 = 0;\n    *puVar1 = param_1;\n    puVar1 = 0x45ce80;\n    do {\n        if (param_1 == *puVar1) {\n            puVar2 = fcn.004118e0();\n            *puVar2 = *(iVar3 * 8 + 0x45ce84);\n            return;\n        }\n        puVar1 = puVar1 + 2;\n        iVar3 = iVar3 + 1;\n    } while (puVar1 < 0x45cfe8);\n    if ((0x12 < param_1) && (param_1 < 0x25)) {\n        puVar2 = fcn.004118e0();\n        *puVar2 = 0xd;\n        return;\n    }\n    if ((0xbb < param_1) && (param_1 < 0xcb)) {\n        puVar2 = fcn.004118e0();\n        *puVar2 = 8;\n        return;\n    }\n    puVar2 = fcn.004118e0();\n    *puVar2 = 0x16;\n    return;\n}\n",
        "token_count": 302
    },
    "00411dae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00411dae(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    fcn.004182a3(arg_14h);\n    uVar1 = fcn.00411ddd(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.004182f5(arg_14h);\n    return uVar1;\n}\n",
        "token_count": 102
    },
    "00411ec5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00411ec5(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    \n    fcn.004182a3(arg_14h);\n    uVar1 = fcn.00411ef4(arg_8h, arg_ch, arg_10h, arg_14h);\n    fcn.004182f5(arg_14h);\n    return uVar1;\n}\n",
        "token_count": 104
    },
    "004172f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.004172f0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x0041733f;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00417351;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00417351;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00417351;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x0041733f:\n    puVar5 = puVar3 + -1;\ncode_r0x00417351:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x004173c8;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x004173c8:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 748
    },
    "004172e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.004172e0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x004173c8;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x004173c8:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 439
    },
    "00419c0f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00419c0f(uint param_1, uint param_2)\n\n{\n    fcn.00419aa3(param_1, param_2, 0x45dc58);\n    return;\n}\n",
        "token_count": 48
    },
    "00419c25": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00419c25(uint param_1, uint param_2)\n\n{\n    fcn.00419aa3(param_1, param_2, 0x45dc70);\n    return;\n}\n",
        "token_count": 47
    },
    "00419c3b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419c3b(uint arg_8h, uint arg_ch)\n\n{\n    uint var_ch;\n    \n    fcn.0041b71e(&var_ch, &arg_ch, arg_ch, 0, 0, 0, 0);\n    fcn.00419c0f(&var_ch, arg_8h);\n    return;\n}\n",
        "token_count": 83
    },
    "00419c68": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00419c68(uint arg_8h, uint arg_ch)\n\n{\n    uint var_ch;\n    \n    fcn.0041b71e(&var_ch, &arg_ch, arg_ch, 0, 0, 0, 0);\n    fcn.00419c25(&var_ch, arg_8h);\n    return;\n}\n",
        "token_count": 81
    },
    "0041cefa": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041cefa(code **param_1)\n\n{\n    uint *puVar1;\n    \n    *param_1 = vtable.std::basic_streambuf_char__struct_std::char_traits_char__.0;\n    if (param_1[0xd] != NULL) {\n        puVar1 = fcn.0041cec1();\n        if (puVar1 != NULL) {\n            (***puVar1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 104
    },
    "0041ddfd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0041ddfd(code **param_1)\n\n{\n    uint *puVar1;\n    \n    *param_1 = vtable.std::basic_streambuf_unsigned_short_int__struct_std::char_traits_unsigned_short_int__.0;\n    if (param_1[0xd] != NULL) {\n        puVar1 = fcn.0041cec1();\n        if (puVar1 != NULL) {\n            (***puVar1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 108
    },
    "0041e6c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0041e6c6(uint arg_8h)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00422d2b(iVar2);\n    uVar1 = *(iVar2 + 0xc);\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 3) = uVar1;\n    fcn.00402f1c(0);\n    fcn.00402e4e(iVar2 + 0xc, 0, *0x447b64);\n    uVar3 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::logic_error.0;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 314
    },
    "0041eb02": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0041eb02(uint arg_8h)\n\n{\n    uchar uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar2 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00422d2b(iVar2);\n    uVar1 = *(iVar2 + 0xc);\n    *(unaff_EBP + -4) = 0;\n    *(extraout_ECX + 3) = uVar1;\n    fcn.00402f1c(0);\n    fcn.00402e4e(iVar2 + 0xc, 0, *0x447b64);\n    uVar3 = *(unaff_EBP + -0xc);\n    *extraout_ECX = vtable.std::runtime_error.0;\n    *in_FS_OFFSET = uVar3;\n    return extraout_ECX;\n}\n",
        "token_count": 312
    },
    "0041f480": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041f480(void)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = 0x4622c4;\n    do {\n        fcn.0041f460(uVar1);\n        uVar1 = uVar1 + 4;\n    } while (uVar1 < 0x4622d0);\n    fcn.0041f460(0x4622d0);\n    return;\n}\n",
        "token_count": 97
    },
    "0041f620": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041f620(uint param_1, int32_t *param_2, uint16_t param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iStack16;\n    int32_t iStack12;\n    uint32_t uStack8;\n    uint32_t uStack4;\n    \n    iStack16 = *param_2;\n    iStack12 = param_2[1];\n    uStack8 = param_2[2];\n    uStack4 = param_2[3];\n    uVar1 = uStack8 & 0xffff0000;\n    fcn.0041f4e0(param_1, &iStack16, 7, 1, uStack4 & 0xffff0000 | param_3 & 0xffff000f);\n    iStack16 = iStack16 + -1;\n    iStack12 = iStack12 + -1;\n    uStack8 = uStack8 + 1;\n    uStack4 = uStack4 + 1;\n    fcn.0041f4e0(param_1, &iStack16, 2, 0, uVar1 | param_3);\n    return;\n}\n",
        "token_count": 259
    },
    "0041f690": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0041f690(uint param_1)\n\n{\n    uint unaff_retaddr;\n    uint *puVar1;\n    uint uStack16;\n    uint uStack12;\n    \n    puVar1 = &uStack16;\n    (*_sym.imp.USER32.dll_GetClientRect)(param_1, &uStack16);\n    (*_sym.imp.GDI32.dll_IntersectClipRect)(unaff_retaddr, param_1, puVar1, uStack16, uStack12);\n    return;\n}\n",
        "token_count": 111
    },
    "0041fa00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0041fa00(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n    iVar3 = 0;\n    if (0 < *0x4622dc) {\n        piVar2 = 0x4622e4;\n        do {\n            if (*piVar2 == iVar1) {\n                return 1;\n            }\n            piVar2 = piVar2 + 5;\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *0x4622dc);\n    }\n    return 0;\n}\n",
        "token_count": 150
    },
    "004209e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.004209e0(uint param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.0041f1b0(param_1);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (0x35e < *0x4622a0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1, 0xfffffff0);\n        if ((uVar2 & 4) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 139
    },
    "00420f60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00420f60(uint param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uchar *puStack64;\n    uint uStack60;\n    uchar *puStack56;\n    uint uStack52;\n    uint uStack48;\n    uint uStack44;\n    uchar *puStack40;\n    uint uStack36;\n    uint uStack32;\n    \n    uStack32 = 0xfffffff0;\n    uStack36 = param_1;\n    puStack40 = 0x420f73;\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)();\n    puStack40 = &stack0xffffffe8;\n    uStack44 = param_1;\n    uStack48 = 0x420f81;\n    (*_sym.imp.USER32.dll_GetWindowRect)();\n    puStack56 = &stack0xffffffe0;\n    uStack48 = 1;\n    uStack52 = 1;\n    uStack60 = 0x420f90;\n    (*_sym.imp.USER32.dll_InflateRect)();\n    uStack60 = param_1;\n    puStack64 = 0x420f97;\n    uVar3 = (*_sym.imp.USER32.dll_GetParent)();\n    pcVar1 = _sym.imp.USER32.dll_ScreenToClient;\n    puStack64 = &stack0xffffffd0;\n    (*_sym.imp.USER32.dll_ScreenToClient)(uVar3);\n    (*pcVar1)(uVar3, &stack0xffffffd0);\n    if ((uVar2 & 0x200000) != 0) {\n        puStack56 = puStack56 + 1;\n    }\n    (*_sym.imp.USER32.dll_ValidateRect)(uVar3, &stack0xffffffc0);\n    return;\n}\n",
        "token_count": 397
    },
    "0042390f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042390f(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x5c) + 0xc);\n    if (iVar1 == 0) {\n        fcn.0042a0cd(0x45c084);\n    }\n    else {\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        fcn.0042a3c6(*puVar2 + puVar2);\n    }\n    return arg_8h;\n}\n",
        "token_count": 169
    },
    "0042394c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042394c(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x5c) + 0xc);\n    if (iVar1 == 0) {\n        fcn.0042a0cd(0x45c084);\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        fcn.0042a3c6(*(iVar1 + 2) + iVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 161
    },
    "0042398a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042398a(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(*(in_ECX + 0x5c) + 0xc);\n    if (iVar1 == 0) {\n        fcn.0042a0cd(0x45c084);\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GlobalLock)(iVar1, 0);\n        fcn.0042a3c6(*(iVar1 + 4) + iVar1);\n    }\n    return arg_8h;\n}\n",
        "token_count": 161
    },
    "00423a3f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.00423a3f(uint arg_8h, uint arg_ch, uint lpString2, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code **ppcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uchar *puVar5;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00429489(0, *(unaff_EBP + 0x1c));\n    pcVar2 = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[0x2b] = pcVar2;\n    *(unaff_EBP + -4) = 1;\n    *extraout_ECX = vtable.CFileDialog.0;\n    fcn.0040ffd0(extraout_ECX + 0x17, 0, 0x4c);\n    pcVar2 = *(unaff_EBP + 8);\n    extraout_ECX[0x2a] = pcVar2;\n    ppcVar1 = extraout_ECX + 0x3c;\n    *ppcVar1 = 0;\n    extraout_ECX[0xf] = 0x7005 - (pcVar2 != NULL);\n    extraout_ECX[0x26] = *(unaff_EBP + 0xc);\n    uVar3 = *(unaff_EBP + 0x14);\n    *(extraout_ECX + 0x2c) = 0;\n    extraout_ECX[0x24] = extraout_ECX[0x24] | uVar3 | 0x800020;\n    extraout_ECX[0x7d] = NULL;\n    extraout_ECX[0x17] = 0x4c;\n    extraout_ECX[0x1e] = ppcVar1;\n    extraout_ECX[0x1f] = 0x104;\n    extraout_ECX[0x20] = extraout_ECX + 0x2c;\n    extraout_ECX[0x21] = 0x40;\n    if (*0x46038c == 0) {\n        iVar4 = fcn.0042976e();\n        if (iVar4 != 0) {\n            extraout_ECX[0x24] = extraout_ECX[0x24] | 0x10;\n        }\n        if (*0x46038c == 0) goto code_r0x00423b19;\n    }\n    *(extraout_ECX + 0x92) = *(extraout_ECX + 0x92) | 8;\n    iVar4 = fcn.0043d8de();\n    extraout_ECX[0x19] = *(iVar4 + 0xc);\ncode_r0x00423b19:\n    iVar4 = *(unaff_EBP + 0x10);\n    extraout_ECX[0x28] = fcn.00423e95;\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(ppcVar1, *(unaff_EBP + 0x10), 0x104);\n    }\n    if (*(unaff_EBP + 0x18) != 0) {\n        fcn.0042a4e1(*(unaff_EBP + 0x18));\n        puVar5 = fcn.0042a714(0);\n        while( true ) {\n            puVar5 = fcn.00410f87(puVar5, 0x7c);\n            if (puVar5 == NULL) break;\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        extraout_ECX[0x1a] = extraout_ECX[0x2b];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 992
    },
    "00424043": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.00424043(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint uVar1;\n    uint *in_ECX;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    uVar1 = fcn.004130e1(&var_24h);\n    *in_ECX = uVar1;\n    return;\n}\n",
        "token_count": 238
    },
    "00424e1d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424e1d(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_4h;\n    \n    iVar1 = *(in_ECX + 8);\n    if (arg_8h < iVar1) {\n        fcn.00424cdd(iVar1 + arg_10h, 0xffffffff);\n        fcn.00410230(*(in_ECX + 4) + (arg_8h + arg_10h) * 4, *(in_ECX + 4) + arg_8h * 4, \n                     (arg_8h * 0x3fffffff + iVar1) * 4);\n        fcn.0040ffd0(*(in_ECX + 4) + arg_8h * 4, 0, arg_10h << 2);\n    }\n    else {\n        fcn.00424cdd(arg_8h + arg_10h, 0xffffffff);\n    }\n    if (arg_10h != 0) {\n        arg_8h = arg_8h << 2;\n        do {\n            *(*(in_ECX + 4) + arg_8h) = arg_ch;\n            arg_8h = arg_8h + 4;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return;\n}\n",
        "token_count": 330
    },
    "00424eaf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00424eaf(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*(param_1 + 8) - param_2) - param_3;\n    if (iVar1 != 0) {\n        fcn.00410230(*(param_1 + 4) + param_2 * 4, *(param_1 + 4) + (param_2 + param_3) * 4, iVar1 * 4);\n    }\n    *(param_1 + 8) = *(param_1 + 8) - param_3;\n    return;\n}\n",
        "token_count": 154
    },
    "00424ee6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00424ee6(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint *puVar1;\n    \n    puVar1 = fcn.004253fd(param_2 * param_3 + 4);\n    *puVar1 = *param_1;\n    *param_1 = puVar1;\n    return;\n}\n",
        "token_count": 85
    },
    "0042507e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.0042507e(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    puVar2 = fcn.00425019(arg_8h, &arg_8h);\n    if (puVar2 == NULL) {\n        if (*(in_ECX + 4) == 0) {\n            fcn.004251c5(*(in_ECX + 8), 1);\n        }\n        puVar2 = fcn.00424fb3();\n        puVar2[1] = iVar1;\n        *puVar2 = *(*(in_ECX + 4) + arg_8h * 4);\n        *(*(in_ECX + 4) + arg_8h * 4) = puVar2;\n    }\n    return puVar2 + 2;\n}\n",
        "token_count": 205
    },
    "0042553f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.0042553f(code **param_1)\n\n{\n    fcn.00428a81();\n    *param_1 = vtable.CWnd.0;\n    fcn.0040ffd0(param_1 + 7, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 71
    },
    "0042557d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0042557d(code **param_1, code *param_2)\n\n{\n    fcn.00428a81();\n    *param_1 = vtable.CWnd.0;\n    fcn.0040ffd0(param_1 + 7, 0, 0x20);\n    param_1[7] = param_2;\n    return param_1;\n}\n",
        "token_count": 90
    },
    "00425987": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.00425987(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.004258ee(0);\n    uVar2 = 0;\n    if (iVar1 != 0) {\n        uVar2 = fcn.0042504b(unaff_retaddr);\n    }\n    return uVar2;\n}\n",
        "token_count": 89
    },
    "00426584": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n\nint32_t __cdecl fcn.00426584(uint arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_1;\n    uint *noname_3;\n    uint lpWndClass;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    int32_t var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    iVar1 = fcn.0043d6a7();\n    iVar1 = iVar1 + 0x58;\n    iVar2 = fcn.0043d8de();\n    var_18h = *(iVar2 + 8);\n    if (((arg_ch == 0) && (arg_10h == 0)) && (arg_14h == 0)) {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar1, \"Afx:%x:%x\", var_18h, arg_8h);\n    }\n    else {\n        (*_sym.imp.USER32.dll_wsprintfA)(iVar1, \"Afx:%x:%x:%x:%x:%x\", var_18h, arg_8h, arg_ch, arg_10h, arg_14h);\n    }\n    noname_3 = &lpWndClass;\n    noname_1 = var_18h;\n    iVar2 = iVar1;\n    iVar3 = (*_sym.imp.USER32.dll_GetClassInfoA)();\n    if (iVar3 == 0) {\n        lpWndClass = arg_8h;\n        var_24h = _sym.imp.USER32.dll_DefWindowProcA;\n        var_1ch = 0;\n        var_20h = 0;\n        var_8h = 0;\n        var_14h = arg_14h;\n        var_10h = arg_ch;\n        var_ch = arg_10h;\n        var_4h = iVar1;\n        iVar2 = fcn.004264e3(&lpWndClass, noname_1, iVar2, noname_3, unaff_EDI, unaff_ESI, unaff_EBX, arg_8h, \n                             _sym.imp.USER32.dll_DefWindowProcA, 0, 0, var_18h, arg_14h, arg_ch, arg_10h, 0);\n        if (iVar2 == 0) {\n            fcn.0042f345();\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 754
    },
    "00428a9b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00428a9b(void)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    iVar1 = *(extraout_ECX + 0x10);\n    *(unaff_EBP + -4) = 0;\n    if (iVar1 != 0) {\n        (**(iVar1 + 0x1c))(extraout_ECX);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 171
    },
    "004290f2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __fastcall fcn.004290f2(code **param_1)\n\n{\n    fcn.0042553f();\n    *param_1 = vtable.CDialog.0;\n    fcn.0040ffd0(param_1 + 0xf, 0, 0x20);\n    return param_1;\n}\n",
        "token_count": 72
    },
    "00429489": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.00429489(code **param_1, code *param_2, code *param_3)\n\n{\n    fcn.0042553f();\n    *param_1 = vtable.CDialog.0;\n    fcn.0040ffd0(param_1 + 0xf, 0, 0x20);\n    param_1[0x14] = param_3;\n    param_1[0xf] = param_2;\n    param_1[0x10] = param_2 & 0xffff;\n    return param_1;\n}\n",
        "token_count": 129
    },
    "00429c7d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.00429c7d(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBX;\n    int32_t arg_8h;\n    \n    if (param_2 < 1) {\n        iVar3 = *(param_1 + 0x1c);\n        if ((iVar3 != 0) && (*(iVar3 + 0x1c) != 0)) {\n            iVar1 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar3 + 0x1c));\n            if (iVar1 != 0) {\n                fcn.0042579f(iVar3, *(iVar3 + 0x1c), 0x363, 1, 0);\n                fcn.004270a9(*(iVar3 + 0x1c), 0x363, 1, 0, 1, 1);\n            }\n        }\n        fcn.0043d8de();\n        arg_8h = 0x43b6c9;\n        iVar1 = fcn.0043e01d(0x43b6c9);\n        for (iVar1 = *(iVar1 + 8); iVar1 != 0; iVar1 = *(iVar1 + 0x54)) {\n            if ((*(iVar1 + 0x1c) != 0) && (iVar1 != iVar3)) {\n                if (*(iVar1 + 0x88) == 0) {\n                    fcn.00428943(0, arg_8h);\n                }\n                iVar2 = (*_sym.imp.USER32.dll_IsWindowVisible)(*(iVar1 + 0x1c));\n                if ((iVar2 != 0) || (-1 < *(iVar1 + 0x88))) {\n                    fcn.0042579f(iVar1, *(iVar1 + 0x1c), 0x363, 1, 0);\n                    arg_8h = *(iVar1 + 0x1c);\n                    fcn.004270a9(arg_8h, 0x363, 1, 0, 1, 1);\n                }\n                iVar2 = *(iVar1 + 0x88);\n                if (0 < iVar2) {\n                    fcn.00428943();\n                    arg_8h = iVar2;\n                }\n                *(iVar1 + 0x88) = 0xffffffff;\n            }\n        }\n    }\n    else {\n        fcn.0043d8de();\n        iVar3 = fcn.0043e01d(0x43b6c9);\n        if (*(iVar3 + 0x10) == 0) {\n            fcn.0042bef4();\n            fcn.0042befd(1);\n        }\n    }\n    return unaff_EBX < 0;\n}\n",
        "token_count": 639
    },
    "0042a1c5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a1c5(uint *param_1, int32_t param_2)\n\n{\n    uint *puVar1;\n    uint uVar2;\n    \n    if (param_2 == 0) {\n        *param_1 = *0x45c084;\n    }\n    else {\n        uVar2 = 0x40;\n        if ((((param_2 < 0x41) || (uVar2 = 0x80,  param_2 < 0x81)) || (uVar2 = 0x100,  param_2 < 0x101)) ||\n           (uVar2 = 0x200,  param_2 < 0x201)) {\n            puVar1 = fcn.00408d12();\n            puVar1[2] = uVar2;\n        }\n        else {\n            puVar1 = fcn.004253fd(param_2 + 0xd);\n            puVar1[2] = param_2;\n        }\n        *puVar1 = 1;\n        *(puVar1 + param_2 + 0xc) = 0;\n        puVar1[1] = param_2;\n        *param_1 = puVar1 + 3;\n    }\n    return;\n}\n",
        "token_count": 279
    },
    "0042a28f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a28f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*param_1 + -0xc != *0x45c088) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n        if (iVar1 < 1) {\n            fcn.0042a247();\n        }\n        *param_1 = *0x45c084;\n    }\n    return;\n}\n",
        "token_count": 113
    },
    "0042a358": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042a358(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (*param_1 + -0xc != *0x45c088) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(*param_1 + -0xc);\n        if (iVar1 < 1) {\n            fcn.0042a247();\n        }\n    }\n    return;\n}\n",
        "token_count": 99
    },
    "0042a382": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042a382(uint *arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t *in_ECX;\n    \n    if (arg_14h + arg_ch == 0) {\n        *arg_8h = *0x45c084;\n    }\n    else {\n        fcn.0042a1c5(arg_14h + arg_ch);\n        fcn.0040fc90(*arg_8h, *in_ECX + arg_10h, arg_ch);\n    }\n    return;\n}\n",
        "token_count": 136
    },
    "0042a418": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042a418(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    *param_1 = *0x45c084;\n    if (param_2 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00411393(param_2);\n    }\n    if (iVar1 != 0) {\n        fcn.0042a1c5(iVar1 * 2);\n        fcn.0042a818(*param_1, param_2, iVar1 * 2 + 1);\n        fcn.0042a763(0xffffffff);\n    }\n    return param_1;\n}\n",
        "token_count": 161
    },
    "0042a464": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a464(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.0042a32f(param_2);\n    fcn.0040fc90(*param_1, param_2, param_2);\n    *(*param_1 + -8) = param_2;\n    *(*param_1 + param_2) = 0;\n    return;\n}\n",
        "token_count": 94
    },
    "0042a508": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.0042a508(uint *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    \n    if (param_2 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.00411393(param_2);\n    }\n    fcn.0042a32f(iVar1 * 2);\n    fcn.0042a818(*param_1, param_2, iVar1 * 2 + 1);\n    fcn.0042a763(0xffffffff);\n    return param_1;\n}\n",
        "token_count": 135
    },
    "0042a549": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042a549(int32_t *param_1, int32_t param_2, uint param_3, int32_t param_4)\n\n{\n    if (param_2 + param_4 != 0) {\n        fcn.0042a1c5(param_2 + param_4);\n        fcn.0040fc90(*param_1, param_2, param_2);\n        fcn.0040fc90(*param_1 + param_2, param_4, param_4);\n    }\n    return;\n}\n",
        "token_count": 125
    },
    "0042a7b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0042a7b9(int32_t *param_1, uint8_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    if ((param_3 < *(*param_1 + -8)) && (iVar1 = fcn.00410f87(*param_1 + param_3, param_2),  iVar1 != 0)) {\n        return iVar1 - *param_1;\n    }\n    return -1;\n}\n",
        "token_count": 113
    },
    "0042aa88": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042aa88(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (0x10b < param_1) {\n        if (param_1 == 0x3e3) {\n            return 10;\n        }\n        if (param_1 == 0x3e4) {\n            return 10;\n        }\n        if (param_1 == 0x3e5) {\n            return 10;\n        }\n        if (param_1 == 999) {\n            return 5;\n        }\n        return 1;\n    }\n    if (param_1 == 0x10b) {\n        return 3;\n    }\n    if (param_1 < 0x3f) {\n        if (param_1 == 0x3e) {\n            return 8;\n        }\n        if (param_1 < 0x1a) {\n    // switch table (25 cases) at 0x42ac7e\n            switch(param_1) {\n            case 0:\n                return 0;\n            case 1:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 0xd:\n            case 0xe:\n                goto code_r0x0042ab8a;\n            case 2:\n            case 6:\n            case 0x12:\n                goto code_r0x0042ab8a;\n            case 3:\n            case 0xf:\n            case 0x11:\n                goto code_r0x0042ab8a;\n            case 4:\n                return 4;\n            case 5:\n            case 0xc:\n            case 0x13:\ncode_r0x0042ab8a:\n                return 5;\n            case 0xb:\ncode_r0x0042ab8a:\n                return 6;\n            case 0x10:\n                return 7;\n            case 0x14:\n            case 0x15:\n            case 0x16:\n            case 0x17:\ncode_r0x0042ab8a:\n                return 10;\n            default:\n                goto code_r0x0042ab8a;\n            }\n        }\n        if (0x27 < param_1) {\n    // switch table (9 cases) at 0x42ace2\n            switch(param_1) {\n            case 0x34:\n            case 0x35:\n            case 0x37:\n                goto code_r0x0042ab8a;\n            case 0x36:\n            case 0x3a:\n                goto code_r0x0042ab8a;\n            default:\n                return 1;\n            case 0x39:\n            case 0x3b:\n                goto code_r0x0042ab8a;\n            case 0x3c:\n                goto code_r0x0042ab8a;\n            }\n        }\n        if (param_1 == 0x27) {\n            return 0xd;\n        }\n        if (0x20 < param_1) {\n            if (param_1 == 0x21) {\n                return 0xc;\n            }\n            if (param_1 == 0x22) {\n                return 3;\n            }\n            if (param_1 == 0x24) {\n                return 4;\n            }\n            if (param_1 == 0x26) {\n                return 0xe;\n            }\n            return 1;\n        }\n        if (param_1 == 0x20) {\n            return 0xb;\n        }\n        if (param_1 == 0x1a) {\n            return 6;\n        }\n        if (param_1 == 0x1b) {\n            return 9;\n        }\n        iVar1 = param_1 - 0x1d;\n        if (iVar1 == 0) {\n            return 5;\n        }\ncode_r0x0042ab00:\n        if (iVar1 == 1) {\ncode_r0x0042ab8a:\n            return 9;\n        }\n    }\n    else {\n        if (param_1 < 0x6c) {\n            if (param_1 == 0x6b) {\ncode_r0x0042ab8a:\n                return 2;\n            }\n            if (0x47 < param_1) {\n                if (param_1 == 0x50) {\n                    return 5;\n                }\n                if (param_1 == 0x52) {\n                    return 5;\n                }\n                if (param_1 == 0x55) {\n                    return 3;\n                }\n                if (param_1 != 0x56) {\n                    if (param_1 == 0x58) {\n                        return 10;\n                    }\n                    return 1;\n                }\n                return 5;\n            }\n            if (param_1 == 0x47) {\n                return 5;\n            }\n            if (param_1 == 0x40) {\n                return 5;\n            }\n            if (param_1 == 0x41) {\n                return 5;\n            }\n            if (param_1 == 0x42) {\n                return 6;\n            }\n            if (param_1 == 0x43) {\n                return 3;\n            }\n            iVar1 = param_1 - 0x44;\n            if (iVar1 == 0) {\n                return 4;\n            }\n        }\n        else {\n            if (param_1 < 0x91) {\n                if (param_1 == 0x90) {\n                    return 3;\n                }\n                if (param_1 < 0x76) {\n                    if (param_1 == 0x75) {\n                        return 10;\n                    }\n                    if (param_1 == 0x6c) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0x6f) {\n                        return 3;\n                    }\n                    if (param_1 == 0x70) {\n                        return 0xd;\n                    }\n                    if (param_1 == 0x71) {\n                        return 4;\n                    }\n                    if (param_1 != 0x72) {\n                        return 1;\n                    }\n                    return 6;\n                }\n                if (param_1 == 0x7b) {\n                    return 3;\n                }\n                if (param_1 == 0x7c) {\n                    return 3;\n                }\n                if (param_1 == 0x7d) {\n                    return 3;\n                }\n                iVar1 = param_1 - 0x83;\n                if (iVar1 == 0) {\n                    return 9;\n                }\n                goto code_r0x0042ab00;\n            }\n            if (param_1 < 0xb7) {\n                if (param_1 == 0xb6) {\n                    return 6;\n                }\n                if (param_1 == 0x91) {\n                    return 7;\n                }\n                if (param_1 == 0x9a) {\n                    return 3;\n                }\n                if (param_1 != 0xa1) {\n                    if (param_1 == 0xa7) {\n                        return 0xc;\n                    }\n                    if (param_1 == 0xaa) {\n                        return 5;\n                    }\n                    return 1;\n                }\n                return 3;\n            }\n            if (param_1 == 0xb7) {\n                return 5;\n            }\n            if (param_1 == 0xbf) {\n                return 6;\n            }\n            if (param_1 == 0xc1) {\n                return 6;\n            }\n            iVar1 = param_1 - 0xce;\n            if (iVar1 == 0) {\n                return 3;\n            }\n        }\n        if (iVar1 == 2) {\ncode_r0x0042ab8a:\n            return 3;\n        }\n    }\ncode_r0x0042ab8a:\n    return 1;\n}\n",
        "token_count": 1748
    },
    "0042b570": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0042b570(void)\n\n{\n    char *pcVar1;\n    char *pcVar2;\n    char cVar3;\n    uint unaff_retaddr;\n    \n    pcVar1 = fcn.0042a714(0x104);\n    fcn.0040ffd0(pcVar1, 0, 0x104);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(pcVar1, unaff_retaddr, 0x104);\n    cVar3 = *pcVar1;\n    pcVar2 = pcVar1;\n    while ((cVar3 != '\\0' && (((cVar3 != '\\\\' && (cVar3 != '/')) || ((pcVar2[1] != '\\\\' && (pcVar2[1] != '/'))))))) {\n        pcVar2 = fcn.004114cf(pcVar2);\n        cVar3 = *pcVar2;\n    }\n    if (*pcVar2 == '\\0') {\n        cVar3 = *pcVar1;\n        while (((cVar3 != '\\0' && (cVar3 != '\\\\')) && (cVar3 != '/'))) {\n            pcVar1 = fcn.004114cf(pcVar1);\n            cVar3 = *pcVar1;\n        }\n    }\n    else {\n        for (pcVar1 = pcVar2 + 2; ((cVar3 = *pcVar1,  cVar3 != '\\0' && (cVar3 != '\\\\')) && (cVar3 != '/'));\n            pcVar1 = fcn.004114cf(pcVar1)) {\n        }\n        if (*pcVar1 == '\\0') goto code_r0x0042b5f1;\n        do {\n            pcVar1 = fcn.004114cf(pcVar1);\ncode_r0x0042b5f1:\n            cVar3 = *pcVar1;\n        } while (((cVar3 != '\\0') && (cVar3 != '\\\\')) && (cVar3 != '/'));\n    }\n    if (*pcVar1 != '\\0') {\n        pcVar1[1] = '\\0';\n    }\n    fcn.0042a763(0xffffffff);\n    return;\n}\n",
        "token_count": 477
    },
    "0042bcd7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.0042bcd7(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0042bc50(0);\n    uVar2 = 0;\n    if (iVar1 != 0) {\n        uVar2 = fcn.0042504b(unaff_retaddr);\n    }\n    return uVar2;\n}\n",
        "token_count": 91
    },
    "0042be7c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042be7c(uint arg_8h, int32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (arg_ch == 0) {\ncode_r0x0042bed0:\n        uVar2 = 0;\n    }\n    else {\n        if (arg_10h != 0) {\n            do {\n                arg_10h = arg_10h + -1;\n                arg_ch = fcn.00410f87(arg_ch, arg_14h);\n                if (arg_ch == 0) {\n                    fcn.0042a2e3();\n                    goto code_r0x0042bed0;\n                }\n                arg_ch = arg_ch + 1;\n            } while (arg_10h != 0);\n        }\n        iVar1 = fcn.00410f87(arg_ch, arg_14h);\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_ch);\n        }\n        else {\n            iVar1 = iVar1 - arg_ch;\n        }\n        uVar2 = fcn.0042a78b(iVar1, arg_ch, iVar1);\n        fcn.0040fc90(uVar2, iVar1, arg_ch);\n        uVar2 = 1;\n    }\n    return uVar2;\n}\n",
        "token_count": 314
    },
    "0042c223": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0042c223(int32_t param_1)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    \n    if (*(param_1 + 2) == -1) {\n        piVar1 = param_1 + 0x1a;\n    }\n    else {\n        piVar1 = param_1 + 0x12;\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    iVar2 = *piVar1;\n    if (iVar2 == -1) {\n        piVar1 = piVar1 + 2;\n    }\n    else {\n        while (piVar1 = piVar1 + 1,  iVar2 != 0) {\n            iVar2 = *piVar1;\n        }\n    }\n    do {\n        iVar2 = *piVar1;\n        piVar1 = piVar1 + 1;\n    } while (iVar2 != 0);\n    return;\n}\n",
        "token_count": 265
    },
    "0042c61c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\ncode ** __cdecl fcn.0042c61c(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    code **ppcVar3;\n    code *pcVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    pcVar1 = *0x45c084;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[3] = pcVar1;\n    pcVar1 = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[4] = pcVar1;\n    extraout_ECX[7] = *0x45c084;\n    pcVar1 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -4) = 2;\n    *extraout_ECX = vtable.CRecentFileList.0;\n    ppcVar3 = fcn.004253fd(pcVar1 * 4 + 4);\n    *(unaff_EBP + -0x14) = ppcVar3;\n    *(unaff_EBP + -4) = 3;\n    if (ppcVar3 == NULL) {\n        pcVar4 = NULL;\n    }\n    else {\n        *ppcVar3 = pcVar1;\n        *(unaff_EBP + 0x14) = ppcVar3 + 1;\n        fcn.00410cbe(ppcVar3 + 1, 4, pcVar1, 0x408e1f);\n        pcVar4 = *(unaff_EBP + 0x14);\n    }\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[2] = pcVar4;\n    pcVar4 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    extraout_ECX[1] = pcVar1;\n    extraout_ECX[5] = pcVar4;\n    fcn.0042a4e1(uVar2);\n    fcn.0042a4e1(*(unaff_EBP + 0x10));\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[6] = *(unaff_EBP + 0x18);\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 649
    },
    "0042cf66": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0042cf66(uint arg_8h, uint lpFileTime)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    ushort *puVar3;\n    uint uVar4;\n    uint lpSystemTime;\n    uint var_12h;\n    ushort var_eh;\n    ushort var_ch;\n    uint var_ah;\n    \n    iVar2 = fcn.00424127(0);\n    lpSystemTime._0_2_ = *(iVar2 + 0x14) + 0x76c;\n    iVar2 = fcn.00424127(0);\n    lpSystemTime._2_2_ = *(iVar2 + 0x10) + 1;\n    iVar2 = fcn.00424127(0);\n    var_12h._0_2_ = *(iVar2 + 0xc);\n    iVar2 = fcn.00424127(0);\n    var_12h._2_2_ = *(iVar2 + 8);\n    iVar2 = fcn.00424127(0);\n    var_eh = *(iVar2 + 4);\n    puVar3 = fcn.00424127(0);\n    var_ch = *puVar3;\n    var_ah._0_2_ = 0;\n    iVar2 = (*_sym.imp.KERNEL32.dll_SystemTimeToFileTime)(&lpSystemTime, &var_ah + 2);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar2 == 0) {\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0042a95c(uVar4);\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LocalFileTimeToFileTime)(&var_ah + 2, lpFileTime);\n    if (iVar2 == 0) {\n        uVar4 = (*pcVar1)(0);\n        fcn.0042a95c(uVar4);\n    }\n    return;\n}\n",
        "token_count": 449
    },
    "0042f35e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0042f35e(uint param_1, uint *param_2)\n\n{\n    int32_t iVar1;\n    uchar *puVar2;\n    uint uVar3;\n    uint var_8h;\n    uint *var_4h;\n    uint lpString2;\n    \n    iVar1 = fcn.0042be55(var_8h, &lpString2, 0x100);\n    if (iVar1 != 0) {\n        puVar2 = fcn.00410f87(&lpString2, 10);\n        if (puVar2 != NULL) {\n            uVar3 = fcn.004117c8(puVar2 + 1);\n            *var_4h = uVar3;\n            uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(uVar3, *0x46034c, 0x48);\n            *var_4h = uVar3;\n            *puVar2 = 0;\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(var_4h + 7, &lpString2, 0x20);\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 266
    },
    "004305c6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004305c6(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint uVar2;\n    int32_t in_ECX;\n    uint lpRect;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetClientRect)(*(in_ECX + 0x1c), &lpRect);\n    *arg_8h = var_8h;\n    arg_8h[1] = var_4h;\n    uVar1 = fcn.00428783();\n    fcn.0043056c(arg_ch);\n    if ((*arg_ch != 0) && ((uVar1 & 0x200000) != 0)) {\n        *arg_8h = *arg_8h + *arg_ch;\n    }\n    if ((arg_ch[1] != 0) && ((uVar1 & 0x100000) != 0)) {\n        arg_8h[1] = arg_8h[1] + arg_ch[1];\n    }\n    if ((*arg_ch < *arg_8h) && (arg_ch[1] < arg_8h[1])) {\n        uVar2 = 1;\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 305
    },
    "00430cb3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00430cb3(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar1 = *(param_1 + 0x58);\n    if (0 < iVar1) {\n        piVar3 = *(param_1 + 0x5c);\n        iVar2 = 0;\n        if (0 < iVar1) {\n            do {\n                if (*piVar3 == param_2) {\n                    return iVar2;\n                }\n                iVar2 = iVar2 + 1;\n                piVar3 = piVar3 + 5;\n            } while (iVar2 < iVar1);\n        }\n    }\n    return -1;\n}\n",
        "token_count": 172
    },
    "00430ed8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430ed8(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0043418a(&var_10h, 1);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch + -2;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 168
    },
    "004312f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004312f0(uint arg_8h, int32_t *arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t *in_ECX;\n    uint *puVar3;\n    int32_t var_24h;\n    uint8_t var_1bh;\n    uint var_1ah;\n    uint var_10h;\n    \n    (**(*in_ECX + 0xa0))(0x417, arg_8h, &var_24h);\n    var_1ah._0_1_ = 0;\n    var_1ah._1_1_ = 0;\n    *(arg_ch + 2) = *(arg_ch + 2) ^ 4;\n    *(arg_ch + 10) = 0;\n    *(arg_ch + 0xb) = 0;\n    iVar1 = fcn.00411060(arg_ch, &var_24h, 0x14);\n    if (iVar1 != 0) {\n        uVar2 = fcn.00428783();\n        fcn.004287b7(0x10000000, 0, 0);\n        (**(*in_ECX + 0xa0))(0x416, arg_8h, 0);\n        (**(*in_ECX + 0xa0))(0x415, arg_8h, arg_ch);\n        fcn.004287b7(0, uVar2 & 0x10000000, 0);\n        if ((((*(arg_ch + 9) ^ var_1bh) & 1) == 0) && (((*(arg_ch + 9) & 1) == 0 || (*arg_ch == var_24h)))) {\n            iVar1 = (**(*in_ECX + 0xa0))(0x41d, arg_8h, &var_10h);\n            if (iVar1 == 0) {\n                return;\n            }\n            puVar3 = &var_10h;\n        }\n        else {\n            puVar3 = NULL;\n        }\n        (*_sym.imp.USER32.dll_InvalidateRect)(in_ECX[7], puVar3, 1);\n    }\n    return;\n}\n",
        "token_count": 492
    },
    "00432c47": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00432c47(uint noname_0, int32_t *arg_ch)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_SetRectEmpty)(&var_10h);\n    fcn.0043418a(&var_10h, *(in_ECX + 100) & 0xa000);\n    *arg_ch = *arg_ch + var_10h;\n    arg_ch[1] = arg_ch[1] + var_ch;\n    arg_ch[2] = arg_ch[2] + var_8h;\n    arg_ch[3] = arg_ch[3] + var_4h;\n    return;\n}\n",
        "token_count": 184
    },
    "00434111": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00434111(int32_t param_1, uint param_2, int32_t *param_3)\n\n{\n    int32_t iVar1;\n    int32_t arg_ch;\n    int32_t arg_14h;\n    int32_t arg_10h;\n    \n    if ((*(param_1 + 100) & 0x400001) == 0x400000) {\n        iVar1 = *(param_1 + 0x48);\n        if ((*(param_1 + 100) & 0xa000) == 0) {\n            arg_10h = ((param_3[2] - *(param_1 + 0x4c)) - *param_3) - iVar1;\n            arg_14h = 3;\n            arg_ch = param_3[1] + 2;\n            iVar1 = *param_3 + iVar1;\n        }\n        else {\n            arg_14h = ((param_3[3] - *(param_1 + 0x4c)) - param_3[1]) - iVar1;\n            arg_ch = param_3[1] + iVar1;\n            arg_10h = 3;\n            iVar1 = *param_3 + 2;\n        }\n        fcn.0043b5ae(iVar1, arg_ch, arg_10h, arg_14h, *0x460360, *0x46035c);\n    }\n    return;\n}\n",
        "token_count": 320
    },
    "0043513d": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043513d(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uchar *puStack64;\n    uint uStack60;\n    uint uStack56;\n    uint uStack52;\n    uint uStack48;\n    uchar auStack28 [28];\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        puStack64 = auStack28;\n        uStack52 = 0xf;\n        uStack56 = 0xf;\n        uStack48 = 0;\n        uStack60 = 0;\n        iVar2 = (*pcVar1)();\n        if (iVar2 == 0) {\n            *(param_1 + 0x70) = *(*(param_1 + 0x68) + 0x68);\n            *(param_1 + 0x78) = *(*(param_1 + 0x68) + 100) & 0xf000;\n            (*_sym.imp.USER32.dll_SetRectEmpty)(param_1 + 0xc);\n            *(param_1 + 0x20) = 0;\n            *(param_1 + 0x1c) = 0;\n            *(param_1 + 0x24) = 0;\n            *(param_1 + 0x7c) = 0;\n            *(param_1 + 0x80) = 0;\n            uVar3 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            iVar2 = fcn.00425960(uVar3);\n            iVar4 = (*_sym.imp.USER32.dll_LockWindowUpdate)(*(iVar2 + 0x1c));\n            if (iVar4 == 0) {\n                uVar3 = 3;\n            }\n            else {\n                uVar3 = 0x403;\n            }\n            uVar3 = (*_sym.imp.USER32.dll_GetDCEx)(*(iVar2 + 0x1c), 0, uVar3);\n            uVar3 = fcn.0042e764(uVar3);\n            *(param_1 + 0x84) = uVar3;\n            return;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&uStack48, 0, 0xf, 0xf);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&puStack64);\n    }\n    return;\n}\n",
        "token_count": 557
    },
    "004351fe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004351fe(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    fcn.00435247(1);\n    (*_sym.imp.USER32.dll_ReleaseCapture)();\n    uVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n    iVar2 = fcn.00425960(uVar1);\n    (*_sym.imp.USER32.dll_LockWindowUpdate)(0);\n    if (*(param_1 + 0x84) != 0) {\n        (*_sym.imp.USER32.dll_ReleaseDC)(*(iVar2 + 0x1c), *(*(param_1 + 0x84) + 4));\n        *(param_1 + 0x84) = 0;\n    }\n    return;\n}\n",
        "token_count": 172
    },
    "00437a36": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00437a36(uint param_1)\n\n{\n    fcn.0043d8de();\n    fcn.0043e01d(0x43b6c9);\n    fcn.0043db92(param_1);\n    return;\n}\n",
        "token_count": 61
    },
    "00437a5a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00437a5a(uint param_1)\n\n{\n    fcn.0043d8de();\n    fcn.0043e01d(0x43b6c9);\n    fcn.0043dba5(param_1);\n    return;\n}\n",
        "token_count": 62
    },
    "00439bc3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439bc3(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        iVar2 = 0;\n        puVar1 = 0x449930;\n        do {\n            if (((*puVar1 ^ *(arg_8h + 100)) & 0xf000) == 0) {\n                fcn.004391e9(*(iVar2 * 8 + 0x44992c));\n                break;\n            }\n            puVar1 = puVar1 + 2;\n            iVar2 = iVar2 + 1;\n        } while (puVar1 < 0x449950);\n    }\n    fcn.004321cd(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 201
    },
    "00439c18": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00439c18(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    \n    if (arg_ch == 0) {\n        puVar3 = 0x44992c;\n        do {\n            uVar2 = *puVar3;\n            iVar1 = fcn.004391e9();\n            if (iVar1 != 0) {\n                uVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(arg_8h + 0x1c), 0xffffffff);\n                uVar2 = uVar2 & 0xffff;\n                iVar1 = fcn.00432ced(uVar2);\n                if (0 < iVar1) break;\n            }\n            if (((puVar3[1] ^ *(arg_8h + 100)) & 0xf000) == 0) {\n                fcn.004391e9(*puVar3, uVar2);\n            }\n            puVar3 = puVar3 + 2;\n        } while (puVar3 < 0x44994c);\n    }\n    fcn.004323f8(arg_8h, arg_10h);\n    return;\n}\n",
        "token_count": 286
    },
    "0043a7ad": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043a7ad(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_CopyRect;\n    (*_sym.imp.USER32.dll_CopyRect)(&var_10h, arg_ch);\n    pcVar1 = _sym.imp.USER32.dll_FillRect;\n    var_8h = var_10h + arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*_sym.imp.USER32.dll_FillRect)(*(arg_8h + 4), &var_10h, iVar3);\n    var_8h = *(arg_ch + 8);\n    var_10h = var_8h - arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, iVar3);\n    (*pcVar2)(&var_10h, arg_ch);\n    var_4h = var_ch + arg_14h;\n    var_10h = var_10h + arg_10h;\n    var_8h = var_8h - arg_10h;\n    iVar3 = arg_18h;\n    if (arg_18h != 0) {\n        iVar3 = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, iVar3);\n    var_4h = *(arg_ch + 0xc);\n    var_ch = var_4h - arg_14h;\n    if (arg_18h != 0) {\n        arg_18h = *(arg_18h + 4);\n    }\n    (*pcVar1)(*(arg_8h + 4), &var_10h, arg_18h);\n    return;\n}\n",
        "token_count": 535
    },
    "0043b562": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b562(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t Y, uint crColor)\n\n{\n    int32_t in_ECX;\n    int32_t var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    (*_sym.imp.GDI32.dll_SetBkColor)(*(in_ECX + 4), crColor);\n    var_10h = arg_8h;\n    var_8h = arg_8h + arg_10h;\n    var_ch = arg_ch;\n    var_4h = arg_ch + Y;\n    (*_sym.imp.GDI32.dll_ExtTextOutA)(*(in_ECX + 4), 0, 0, 2, &var_10h, 0, 0, 0);\n    return;\n}\n",
        "token_count": 207
    },
    "0043b5ae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b5ae(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint var_4h;\n    \n    fcn.0043b562(arg_8h, arg_ch, arg_10h + -1, 1, arg_18h);\n    fcn.0043b562(arg_8h, arg_ch, 1, arg_14h + -1, arg_18h);\n    fcn.0043b562(arg_8h + arg_10h, arg_ch, 0xffffffff, arg_14h, arg_1ch);\n    fcn.0043b562(arg_8h, arg_ch + arg_14h, arg_10h, 0xffffffff, arg_1ch);\n    return;\n}\n",
        "token_count": 201
    },
    "0043bbda": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0043bbda(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x58)) {\n        do {\n            fcn.0042a358();\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x58));\n    }\n    iVar1 = fcn.0043c585(param_2, param_3);\n    if (iVar1 != 0) {\n        iVar1 = 0;\n        if (0 < *(param_1 + 0x58)) {\n            arg_8h = *(param_1 + 0x5c) + 0x10;\n            do {\n                fcn.0040fc90(arg_8h, 0x45c084, 4);\n                arg_8h = arg_8h + 0x14;\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < *(param_1 + 0x58));\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 274
    },
    "0043c30a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0043c30a(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    int32_t *piVar4;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_10h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar4 = arg_8h;\n    for (iVar1 = (**(*in_ECX + 0xa0))(0x418, 0, 0); iVar1 != 0; iVar1 = iVar1 + -1) {\n        (**(*in_ECX + 0xa0))(0x416, 0, 0);\n    }\n    fcn.0040ffd0(&var_18h, 0, 0x14);\n    var_8h = 0xffffffff;\n    if (arg_8h == NULL) {\n        iVar1 = 0;\n        var_10h._0_1_ = 4;\n        if (0 < arg_ch) {\n            do {\n                iVar3 = (**(*in_ECX + 0xa0))(0x414, 1, &var_18h);\n                if (iVar3 == 0) {\n                    return 0;\n                }\n                iVar1 = iVar1 + 1;\n            } while (iVar1 < arg_ch);\n        }\n    }\n    else {\n        arg_8h = NULL;\n        var_4h = 0;\n        if (0 < arg_ch) {\n            do {\n                var_14h = *piVar4;\n                piVar4 = piVar4 + 1;\n                var_10h._0_1_ = 4;\n                if (var_14h == 0) {\n                    var_10h._1_1_ = 1;\n                    uVar2 = fcn.00428783();\n                    if (((uVar2 & 0x800) == 0) && (*0x45bed4 != 0x40047)) {\n                        var_18h = 8;\n                    }\n                    else {\n                        var_18h = 6;\n                    }\n                }\n                else {\n                    var_10h._1_1_ = 0;\n                    var_18h = arg_8h;\n                    arg_8h = arg_8h + 1;\n                }\n                iVar1 = (**(*in_ECX + 0xa0))(0x414, 1, &var_18h);\n                if (iVar1 == 0) {\n                    return 0;\n                }\n                var_4h = var_4h + 1;\n            } while (var_4h < arg_ch);\n        }\n    }\n    iVar1 = (**(*in_ECX + 0xa0))(0x418, 0, 0);\n    in_ECX[0x16] = iVar1;\n    in_ECX[0x21] = 1;\n    return 1;\n}\n",
        "token_count": 683
    },
    "0043d000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043d000(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    fcn.00410f3f(*(param_1 + 0x7c));\n    uVar1 = fcn.00411248(param_2);\n    *(param_1 + 0x7c) = uVar1;\n    fcn.00410f3f(*(param_1 + 0x90));\n    uVar1 = fcn.00411248(*(param_1 + 0x78));\n    *(param_1 + 0x90) = uVar1;\n    return;\n}\n",
        "token_count": 144
    },
    "0043d904": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.0043d904(void)\n\n{\n    fcn.0043d8de();\n    fcn.0043e01d(0x43b6c9);\n    return;\n}\n",
        "token_count": 44
    },
    "0043e3ed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "delete registry key",
            "query or enumerate registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043e3ed(uint phkResult)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uchar *puVar2;\n    uint lpName;\n    \n    arg_8h = fcn.00411248(phkResult);\n    iVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(arg_8h);\n    puVar2 = iVar1 + arg_8h;\n    while (puVar2 != NULL) {\n        *puVar2 = 0;\n        fcn.0041297d(arg_8h, puVar2);\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, arg_8h, &phkResult);\n        if (iVar1 != 0) break;\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegEnumKeyA)(phkResult, 0, &lpName, 0x105);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(phkResult);\n        if (iVar1 == 0) break;\n        (*_sym.imp.ADVAPI32.dll_RegDeleteKeyA)(0x80000000, arg_8h);\n        puVar2 = fcn.004114e6(arg_8h, 0x5c);\n    }\n    fcn.00410f3f(arg_8h);\n    return 1;\n}\n",
        "token_count": 312
    },
    "0043f157": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043f157(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *(param_1 + 8);\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 4))(piVar1);\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(param_1 + 4);\n    return;\n}\n",
        "token_count": 95
    },
    "0043f2bb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.0043f2bb(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.0043f1ad(param_1);\n    *param_1 = iVar1;\n    if (iVar1 == 0) {\n        iVar1 = fcn.0043f25b(unaff_retaddr);\n        *param_1 = iVar1;\n        iVar1 = (-(iVar1 != 0) & 0x7fffbffe) + 0x80004002;\n    }\n    else {\n        fcn.0043f157();\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 155
    },
    "0043f600": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __thiscall fcn.0043f600(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    \n    uVar1 = *(param_1 + 0x28);\n    bVar2 = uVar1 < *(param_1 + 0x2c);\n    if (bVar2) {\n        fcn.0040fc90(param_2, *(param_1 + 0x1c) * uVar1 + *(param_1 + 0x24), *(param_1 + 0x1c));\n        *(param_1 + 0x28) = *(param_1 + 0x28) + 1;\n    }\n    return bVar2;\n}\n",
        "token_count": 167
    },
    "0043fc57": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0043fc57(uint8_t *param_1, uint16_t param_2)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar3 = *(param_2 * 4 + 0x44c748) + 4;\n    uVar2 = *param_1;\n    while (uVar2 != 0) {\n        if (uVar2 != 0xff) {\n            iVar4 = 0x44c784;\n            if ((uVar2 & 0x40) == 0) {\n                iVar4 = 0x44c7c0;\n            }\n            iVar3 = iVar3 + *(iVar4 + (uVar2 & 0xffffffbf) * 4);\n        }\n        puVar1 = param_1 + 1;\n        param_1 = param_1 + 1;\n        uVar2 = *puVar1;\n    }\n    return iVar3;\n}\n",
        "token_count": 227
    },
    "00440228": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_11ch\n\nvoid __cdecl fcn.00440228(ushort *arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uchar *puVar6;\n    uchar *puStack316;\n    uint *puStack312;\n    uint uStack308;\n    uint *puStack304;\n    ushort *puStack300;\n    uchar *puStack296;\n    uint uStack292;\n    uint var_11ch;\n    uint var_110h;\n    uint32_t var_10h;\n    uint *var_ch;\n    uchar *var_8h;\n    int32_t var_4h;\n    \n    uStack292 = 0x20;\n    puStack296 = NULL;\n    puStack300 = arg_8h;\n    puStack304 = 0x440241;\n    fcn.0040ffd0();\n    var_ch = &fcn.00440228::var_110h;\n    uStack292 = 0x44c718;\n    puStack296 = 0x44025a;\n    iVar4 = fcn.0042bbbf();\n    pcVar3 = _sym.imp.KERNEL32.dll_MultiByteToWideChar;\n    pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n    if (iVar4 == 0) {\n        puStack296 = 0x44a408;\n        puStack300 = 0x440339;\n        iVar4 = fcn.0042bbbf();\n        puStack304 = &fcn.00440228::var_110h;\n        puStack300 = 0x100;\n        if (iVar4 == 0) {\n            uStack308 = 0xf108;\n            puStack312 = 0x440367;\n            fcn.0042be55();\n            *arg_8h = 0xf108;\n        }\n        else {\n            uStack308 = 0xf10a;\n            puStack312 = 0x440353;\n            fcn.0042be55();\n            *arg_8h = 0xf10a;\n        }\n    }\n    else {\n        var_ch = *(arg_ch + 0xc);\n        *arg_8h = *(arg_ch + 8);\n        *(arg_8h + 8) = *(arg_ch + 0x10);\n        *(arg_8h + 0xe) = *(arg_ch + 0x1c);\n        var_10h = *(arg_ch + 0x14);\n        if (*(var_10h - 8) != 0) {\n            if (var_10h == 0) {\n                puStack296 = NULL;\n            }\n            else {\n                puStack300 = 0x4402a3;\n                var_8h = &stack0xfffffed8;\n                puStack296 = var_10h;\n                var_4h = (*pcVar2)();\n                var_4h = var_4h + 1;\n                puStack300 = 0x4402b3;\n                fcn.00410700();\n                puStack300 = var_4h;\n                uStack308 = 0xffffffff;\n                puStack312 = var_10h;\n                puStack296 = puStack296 & 0xffff0000;\n                puStack316 = NULL;\n                puStack304 = &stack0xfffffed8;\n                (*pcVar3)(0);\n                puStack296 = var_8h;\n            }\n            puStack300 = 0x4402d2;\n            uVar5 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n            *(arg_8h + 6) = uVar5;\n        }\n        uVar1 = *(arg_ch + 0x18);\n        if (*(uVar1 - 8) != 0) {\n            if (uVar1 == 0) {\n                puStack312 = NULL;\n            }\n            else {\n                puStack316 = 0x4402f5;\n                puStack312 = uVar1;\n                var_4h = (*pcVar2)();\n                var_4h = var_4h + 1;\n                puStack316 = 0x440305;\n                fcn.00410700();\n                puStack316 = var_4h;\n                puStack312 = puStack312 & 0xffff0000;\n                var_8h = &stack0xfffffec8;\n                (*pcVar3)(0, 0, uVar1, 0xffffffff, &stack0xfffffec8);\n                puStack312 = var_8h;\n            }\n            puStack316 = 0x440324;\n            uVar5 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n            *(arg_8h + 2) = uVar5;\n        }\n    }\n    if (var_ch == NULL) {\n        puVar6 = NULL;\n    }\n    else {\n        puStack312 = var_ch;\n        puStack316 = 0x44037d;\n        puVar6 = &stack0xfffffec8;\n        var_4h = (*pcVar2)();\n        var_4h = var_4h + 1;\n        puStack316 = 0x44038d;\n        fcn.00410700();\n        puStack316 = var_4h;\n        puStack312 = puStack312 & 0xffff0000;\n        (*pcVar3)(0, 0, var_ch, 0xffffffff, &stack0xfffffec8);\n    }\n    puStack316 = 0x4403ac;\n    puStack312 = puVar6;\n    uVar5 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n    *(arg_8h + 4) = uVar5;\n    if (*(arg_8h + 2) == 0) {\n        puStack316 = 0x4403bc;\n        iVar4 = fcn.0043d8de();\n        uVar1 = *(iVar4 + 0x10);\n        if (uVar1 == 0) {\n            puStack316 = NULL;\n        }\n        else {\n            puStack316 = uVar1;\n            var_4h = (*pcVar2)();\n            var_4h = var_4h + 1;\n            fcn.00410700();\n            puStack316 = puStack316 & 0xffff0000;\n            var_8h = &stack0xfffffec4;\n            (*pcVar3)(0, 0, uVar1, 0xffffffff, &stack0xfffffec4, var_4h);\n            puStack316 = var_8h;\n        }\n        uVar5 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n        *(arg_8h + 2) = uVar5;\n    }\n    if ((*(arg_8h + 6) == 0) && (*(arg_8h + 8) != 0)) {\n        puStack316 = 0x440411;\n        iVar4 = fcn.0043d8de();\n        uVar1 = *(*(iVar4 + 4) + 0x8c);\n        puStack316 = NULL;\n        if (uVar1 != 0) {\n            puStack316 = uVar1;\n            iVar4 = (*pcVar2)();\n            fcn.00410700();\n            puStack316 = puStack316 & 0xffff0000;\n            var_8h = &stack0xfffffec4;\n            (*pcVar3)(0, 0, uVar1, 0xffffffff, &stack0xfffffec4, iVar4 + 1);\n            puStack316 = var_8h;\n        }\n        uVar5 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)();\n        *(arg_8h + 6) = uVar5;\n    }\n    return;\n}\n",
        "token_count": 1739
    },
    "00440a7b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00440a7b(code *param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint unaff_retaddr;\n    \n    *(param_2 + param_3) = unaff_retaddr;\n    *((param_2 + param_3) - param_3) = 0x440a8b;\n    (*param_1)();\n    return;\n}\n",
        "token_count": 89
    },
    "00441034": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\ncode ** fcn.00441034(void)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    fcn.004300f3();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042e6c2();\n    *(unaff_EBP + -4) = 1;\n    *(unaff_EBP + -0x10) = extraout_ECX + 0x25;\n    *(unaff_EBP + -0x14) = 2;\n    do {\n        fcn.004410f3();\n        *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + 0x28;\n        piVar1 = unaff_EBP + -0x14;\n        *piVar1 = *piVar1 + -1;\n    } while (*piVar1 != 0);\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[0x1c] = NULL;\n    extraout_ECX[0x1b] = NULL;\n    extraout_ECX[0x45] = NULL;\n    extraout_ECX[0x1d] = NULL;\n    extraout_ECX[0x22] = NULL;\n    extraout_ECX[0x40] = NULL;\n    extraout_ECX[0x39] = NULL;\n    extraout_ECX[0x3b] = NULL;\n    extraout_ECX[0x19] = 0x1;\n    extraout_ECX[0x10] = 0x1;\n    *extraout_ECX = vtable.CPreviewView.0;\n    extraout_ECX[0x24] = extraout_ECX + 0x25;\n    extraout_ECX[0x3c] = 0x2;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 554
    },
    "004420ad": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004420ad(int32_t param_1, uint32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t unaff_ESI;\n    \n    *(param_1 + 0xf4) = param_2;\n    uVar1 = *(*(**(param_1 + 0x114) + 0x5c) + 0x1e);\n    if (uVar1 < param_2) {\n        *(param_1 + 0xf4) = uVar1;\n    }\n    uVar1 = *(*(**(param_1 + 0x114) + 0x5c) + 0x1c);\n    if (*(param_1 + 0xf4) < uVar1) {\n        *(param_1 + 0xf4) = uVar1;\n    }\n    if (*(param_1 + 0xec) == 0) {\n        fcn.0042712b(1, *(param_1 + 0xf4), 1);\n    }\n    if (unaff_ESI != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 0xf0) != 0) {\n            iVar2 = 0;\n            do {\n                uVar1 = uVar1 + 1;\n                *(*(param_1 + 0x90) + 0x18 + iVar2) = 0;\n                iVar2 = iVar2 + 0x28;\n            } while (uVar1 < *(param_1 + 0xf0));\n        }\n    }\n    (*_sym.imp.USER32.dll_InvalidateRect)(*(param_1 + 0x1c), 0, 1);\n    return;\n}\n",
        "token_count": 388
    },
    "004423bb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool fcn.004423bb(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar1 = fcn.0043e0b2(0x43b811);\n    while ((*(iVar1 + 0xc) == 0 &&\n           (iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(&stack0xffffffe0, 0, 0, 0, 0),  iVar2 != 0))) {\n        piVar3 = fcn.00429b18();\n        iVar2 = (**(*piVar3 + 0x5c))();\n        if (iVar2 == 0) {\n            return false;\n        }\n    }\n    return *(iVar1 + 0xc) == 0;\n}\n",
        "token_count": 178
    },
    "00442d43": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00442d43(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar8 = arg_ch * arg_10h;\n    iVar4 = iVar8 >> 0x20;\n    iVar1 = iVar8;\n    iVar9 = arg_14h * arg_18h;\n    iVar5 = iVar9 >> 0x20;\n    iVar7 = iVar8;\n    if ((iVar4 == 0 || iVar8 < 0) && (iVar8 < 0)) {\n        iVar7 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    iVar6 = 0;\n    while (iVar7 != 0) {\n        iVar7 = fcn.00412f60();\n        iVar6 = iVar6 + 1;\n    }\n    iVar2 = arg_8h;\n    if (arg_8h < 0) {\n        iVar2 = -arg_8h;\n    }\n    arg_ch = 0;\n    iVar7 = iVar2;\n    while (iVar7 != 0) {\n        iVar7 = fcn.00412f60();\n        arg_ch = arg_ch + 1;\n    }\n    iVar6 = iVar6 + arg_ch;\n    if ((iVar5 == 0 || iVar9 < 0) && (iVar9 < 0)) {\n        iVar9 = CONCAT44(-(iVar5 + (iVar9 != 0)), -iVar9);\n        iVar8 = CONCAT44(-(iVar4 + (iVar1 != 0)), -iVar1);\n    }\n    while (0x1f < iVar6) {\n        iVar8 = fcn.00412f60();\n        iVar9 = fcn.00412f60();\n        iVar1 = iVar6 + -2;\n        if (iVar6 + -1 < 0x20) break;\n        iVar8 = fcn.00412f60();\n        iVar9 = fcn.00412f60();\n        iVar6 = iVar6 + -3;\n        if (iVar1 < 0x20) break;\n        arg_8h = arg_8h >> 1;\n        iVar9 = fcn.00412f60();\n    }\n    iVar8 = fcn.00412f20(arg_8h, arg_8h >> 0x1f, iVar8);\n    if (iVar9 == 0) {\n        if ((iVar8 < 0x100000000) && (iVar8 < 0)) {\n            uVar3 = 0x80000000;\n        }\n        else {\n            uVar3 = 0x7fffffff;\n        }\n    }\n    else {\n        iVar7 = fcn.00412e70(iVar9, 2, 0);\n        uVar3 = fcn.00412e70(iVar7 + iVar8, iVar9);\n    }\n    return uVar3;\n}\n",
        "token_count": 724
    },
    "00443cab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00443cab(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t nRightRect;\n    int32_t nBottomRect;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n    nRightRect = param_1;\n    nBottomRect = param_1;\n    iVar2 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(*(param_1 + 8), 10);\n    nRightRect = (*pcVar1)(*(param_1 + 8), 8);\n    nBottomRect = iVar2;\n    fcn.00443d2d(&nRightRect);\n    (*_sym.imp.GDI32.dll_SetMapMode)(*(param_1 + 4), 1);\n    (*_sym.imp.GDI32.dll_SetWindowOrgEx)(*(param_1 + 4), 0, 0, 0);\n    (*_sym.imp.GDI32.dll_SetViewportOrgEx)(*(param_1 + 4), *(param_1 + 0x20), *(param_1 + 0x24), 0);\n    (*_sym.imp.GDI32.dll_IntersectClipRect)(*(param_1 + 4), 0xffffffff, 0xffffffff, nRightRect + 2, nBottomRect + 2);\n    fcn.00443b26(0);\n    return;\n}\n",
        "token_count": 312
    },
    "00443d86": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00443d86(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable._AFX_WIN_STATE.0;\n    *(unaff_EBP + -4) = 0;\n    fcn.0042f518(extraout_ECX + 1, extraout_ECX);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 171
    },
    "00443f37": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop",
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.00443f37(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    char *arg_8h;\n    \n    iVar2 = fcn.0043d8de();\n    fcn.0043e309(1);\n    arg_8h = iVar2 + 0x34;\n    while (*arg_8h != '\\0') {\n        puVar3 = fcn.00410f87(arg_8h, 10);\n        *puVar3 = 0;\n        iVar4 = fcn.0043d8de();\n        (*_sym.imp.USER32.dll_UnregisterClassA)(arg_8h, *(iVar4 + 8));\n        arg_8h = puVar3 + 1;\n    }\n    *(iVar2 + 0x34) = '\\0';\n    fcn.0043e379(1);\n    iVar2 = fcn.0043d8de();\n    if ((*(iVar2 + 4) != 0) && (pcVar1 = *(*(iVar2 + 4) + 0x54),  pcVar1 != NULL)) {\n        (*pcVar1)(1, 0);\n    }\n    iVar2 = fcn.0043d6a7();\n    if (*(iVar2 + 0xcc) != NULL) {\n        iVar4 = (**(**(iVar2 + 0xcc) + 0xb8))();\n        if (iVar4 != 0) {\n            *(iVar2 + 0xcc) = 0;\n        }\n    }\n    iVar4 = fcn.0043d8de();\n    pcVar1 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (*(iVar4 + 0x14) == '\\0') {\n        if (*(iVar2 + 0x30) != 0) {\n            (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar2 + 0x30));\n            *(iVar2 + 0x30) = 0;\n        }\n        if (*(iVar2 + 0x2c) != 0) {\n            (*pcVar1)(*(iVar2 + 0x2c));\n            *(iVar2 + 0x2c) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 507
    },
    "004014f0": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004014f0(uint *param_1)\n\n{\n    param_1[4] = 0x447940;\n    param_1[7] = 0;\n    param_1[6] = 0;\n    param_1[5] = 0;\n    *(param_1 + 0x23) = 0;\n    *(param_1 + 0x22) = 0;\n    *(param_1 + 0x21) = 0;\n    *(param_1 + 8) = 0;\n    param_1[0xb] = 0;\n    param_1[0xc] = 0;\n    param_1[0xd] = 0;\n    param_1[0xe] = 0;\n    param_1[0xf] = 0;\n    param_1[0x10] = 0;\n    param_1[0x11] = 0;\n    param_1[0x12] = 0;\n    param_1[1] = 0;\n    *param_1 = 0x447950;\n    *(param_1 + 9) = 0;\n    param_1[2] = 0;\n    param_1[3] = 0;\n    return;\n}\n",
        "token_count": 284
    },
    "004019fc": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004019fc(int32_t param_1, uint param_2, uint param_3, uint param_4, uint param_5)\n\n{\n    *(param_1 + 0x10) = param_2;\n    *(param_1 + 0x14) = param_3;\n    *(param_1 + 0x18) = param_4;\n    *(param_1 + 0x1c) = param_5;\n    return;\n}\n",
        "token_count": 108
    },
    "00401a63": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\nvoid fcn.00401a63(uint *param_1)\n\n{\n    fcn.00401a1b(param_1[8], param_1[9], param_1[10], param_1[0xb]);\n    fcn.004019de(*param_1, param_1[1], param_1[2], param_1[3]);\n    fcn.004019fc(param_1[4], param_1[5], param_1[6], param_1[7]);\n    fcn.00401a3a(param_1[0xd], param_1[0xe], param_1[0xf], param_1[0x10]);\n    fcn.00401a59(param_1[0xc]);\n    return;\n}\n",
        "token_count": 168
    },
    "0040327d": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * fcn.0040327d(void)\n\n{\n    uint uVar1;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = 0x447914;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[1] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[4] = 0;\n    extraout_ECX[5] = 0;\n    extraout_ECX[6] = 0;\n    extraout_ECX[7] = 0;\n    extraout_ECX[8] = 0;\n    *(unaff_EBP + -4) = 2;\n    fcn.00407804();\n    extraout_ECX[0x16] = *0x45c084;\n    *(unaff_EBP + -4) = 4;\n    fcn.00401944();\n    *(unaff_EBP + -4) = 5;\n    *extraout_ECX = 0x447ce0;\n    extraout_ECX[0x2e] = 0;\n    extraout_ECX[0x2f] = 1;\n    extraout_ECX[0x28] = 0;\n    extraout_ECX[0x29] = 0;\n    fcn.0042a4e1(0x45b720);\n    extraout_ECX[0x2a] = 0xffffffff;\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[0x2b] = 0;\n    extraout_ECX[0x2c] = 0;\n    extraout_ECX[0x30] = 1;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 518
    },
    "0040411b": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040411b(uint *param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    param_1[4] = 0x447940;\n    param_1[7] = 0;\n    param_1[6] = 0;\n    param_1[5] = 0;\n    *(param_1 + 0x23) = 0;\n    *(param_1 + 0x22) = 0;\n    *(param_1 + 0x21) = 0;\n    *(param_1 + 8) = 0;\n    param_1[0xb] = 0;\n    param_1[0xc] = 0;\n    param_1[0xd] = 0;\n    param_1[0xe] = 0;\n    param_1[0xf] = 0;\n    param_1[0x10] = 0;\n    param_1[0x11] = 0;\n    param_1[0x12] = 0;\n    param_1[1] = param_2;\n    param_1[2] = param_3;\n    *param_1 = 0x447950;\n    param_1[3] = param_4;\n    *(param_1 + 9) = 0;\n    return;\n}\n",
        "token_count": 303
    },
    "004069fd": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004069fd(uint *param_1)\n\n{\n    param_1[1] = 0;\n    param_1[2] = 0;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[7] = 0;\n    param_1[8] = 0;\n    param_1[9] = 0;\n    param_1[10] = 0;\n    param_1[0xb] = 0;\n    param_1[0xc] = 0;\n    *param_1 = 0x44822c;\n    param_1[0xd] = 0;\n    param_1[0xe] = 0;\n    return;\n}\n",
        "token_count": 192
    },
    "00407061": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint * fcn.00407061(void)\n\n{\n    uint uVar1;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    uVar1 = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[5] = uVar1;\n    *(unaff_EBP + -4) = 1;\n    *extraout_ECX = 0x448230;\n    extraout_ECX[1] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[0x10] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[4] = 0;\n    fcn.0042a4e1(0x45e614);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return extraout_ECX;\n}\n",
        "token_count": 275
    },
    "00407804": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "PEB access",
            "access PEB ldr_data"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n\nuint * fcn.00407804(void)\n\n{\n    uint uVar1;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_20h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    extraout_ECX[3] = 0;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = 0x447940;\n    extraout_ECX[2] = 0;\n    extraout_ECX[1] = 0;\n    *(unaff_EBP + -4) = 0;\n    extraout_ECX[4] = 0x447940;\n    extraout_ECX[7] = 0;\n    extraout_ECX[6] = 0;\n    extraout_ECX[5] = 0;\n    extraout_ECX[8] = 0x447940;\n    extraout_ECX[0xb] = 0;\n    extraout_ECX[10] = 0;\n    extraout_ECX[9] = 0;\n    *(unaff_EBP + -4) = 2;\n    uVar1 = fcn.00407997(0x3f800000, 0x3f800000, 0x3f800000);\n    *(unaff_EBP + -4) = 3;\n    fcn.00407a11(uVar1);\n    *(unaff_EBP + -4) = 2;\n    fcn.00407990();\n    uVar1 = fcn.00407997(0, 0, 0);\n    *(unaff_EBP + -4) = 4;\n    fcn.00407a11(uVar1);\n    *(unaff_EBP + -4) = 2;\n    fcn.00407990();\n    uVar1 = *(unaff_EBP + -0xc);\n    extraout_ECX[0xc] = 0;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 490
    },
    "0040bd3e": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "parse PE header/27dc37a2d08e4034aa7bcaa8b888b251"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0040bd3e(code **param_1, code *param_2)\n\n{\n    param_1[1] = param_2;\n    param_1[2] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    fcn.00424add(10);\n    param_1[0xd] = NULL;\n    param_1[0xe] = NULL;\n    param_1[0xf] = NULL;\n    param_1[0x10] = NULL;\n    param_1[0x11] = NULL;\n    param_1[0x12] = NULL;\n    param_1[0x13] = NULL;\n    param_1[0x14] = NULL;\n    param_1[0x15] = NULL;\n    param_1[0x16] = NULL;\n    *param_1 = vtable.CDataSourceControl.0;\n    return param_1;\n}\n",
        "token_count": 227
    },
    "0040ca82": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.0040ca82(uint *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h, int32_t arg_28h, int32_t arg_2ch, uint arg_30h)\n\n{\n    if ((arg_10h & 0x4000) == 0) {\n        arg_8h[8] = 0;\n    }\n    else {\n        arg_8h[8] = 1;\n    }\n    *(arg_8h + 0xc) = arg_10h;\n    arg_8h[5] = arg_30h;\n    *(arg_8h + 0x32) = arg_18h;\n    arg_8h[9] = arg_20h;\n    *(arg_8h + 0x33) = arg_1ch;\n    *arg_8h = arg_ch;\n    arg_8h[1] = arg_24h;\n    arg_8h[10] = arg_14h;\n    arg_8h[7] = 1;\n    arg_8h[0xb] = 0;\n    arg_8h[2] = 0;\n    arg_8h[3] = 0;\n    arg_8h[4] = 0;\n    arg_8h[6] = 0;\n    if (arg_28h != 0) {\n        arg_8h[7] = 3;\n        arg_8h[2] = arg_28h;\n    }\n    if (arg_2ch != 0) {\n        arg_8h[7] = arg_8h[7] | 4;\n        arg_8h[3] = arg_2ch;\n    }\n    return;\n}\n",
        "token_count": 417
    },
    "004231ed": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004231ed(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *(param_1 + 0xc) = 1;\n    iVar1 = fcn.0042be55(*(param_1 + 0x94), param_1 + 0x14, 0x80);\n    *(param_1 + 0x10) = iVar1 != 0;\n    return;\n}\n",
        "token_count": 97
    },
    "00424add": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00424add(code **param_1, code *param_2)\n\n{\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CPtrList.0;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 104
    },
    "00424b1c": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424b1c(int32_t param_1)\n\n{\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 8) = 0;\n    *(param_1 + 4) = 0;\n    fcn.00424f06();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 103
    },
    "00424f1c": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00424f1c(code **param_1, code *param_2)\n\n{\n    param_1[1] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CMapPtrToPtr.0;\n    param_1[2] = 0x11;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 111
    },
    "00424f5f": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424f5f(int32_t param_1)\n\n{\n    if (*(param_1 + 4) != 0) {\n        fcn.00425426(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00424f06();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 122
    },
    "00425182": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00425182(code **param_1, code *param_2)\n\n{\n    param_1[1] = NULL;\n    param_1[3] = NULL;\n    param_1[4] = NULL;\n    param_1[5] = NULL;\n    *param_1 = vtable.CMapStringToPtr.0;\n    param_1[2] = 0x11;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 109
    },
    "0042520a": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042520a(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint *puVar2;\n    \n    if (*(param_1 + 4) != 0) {\n        uVar1 = 0;\n        if (*(param_1 + 8) != 0) {\n            do {\n                for (puVar2 = *(*(param_1 + 4) + uVar1 * 4); puVar2 != NULL; puVar2 = *puVar2) {\n                    fcn.0042a358();\n                }\n                uVar1 = uVar1 + 1;\n            } while (uVar1 < *(param_1 + 8));\n        }\n        fcn.00425426(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    fcn.00424f06();\n    *(param_1 + 0x14) = 0;\n    return;\n}\n",
        "token_count": 244
    },
    "00428a81": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428a81(int32_t param_1)\n\n{\n    *(param_1 + 4) = 1;\n    *(param_1 + 8) = 0;\n    *(param_1 + 0xc) = 0;\n    *(param_1 + 0x10) = 0;\n    *(param_1 + 0x14) = 1;\n    *(param_1 + 0x18) = 0;\n    return;\n}\n",
        "token_count": 108
    },
    "00428d6e": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00428d6e(code **param_1)\n\n{\n    *param_1 = vtable.CCmdUI.0;\n    param_1[8] = NULL;\n    param_1[2] = NULL;\n    param_1[1] = NULL;\n    param_1[9] = NULL;\n    param_1[4] = NULL;\n    param_1[3] = NULL;\n    param_1[5] = NULL;\n    param_1[7] = NULL;\n    param_1[6] = NULL;\n    return;\n}\n",
        "token_count": 127
    },
    "0043621e": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0043621e(code **param_1, code *param_2, code *param_3, code *param_4)\n\n{\n    fcn.0042ad06();\n    param_1[5] = NULL;\n    param_1[4] = param_4;\n    param_1[9] = NULL;\n    *param_1 = vtable.CMemFile.0;\n    param_1[7] = ~-(param_4 != NULL) & param_3;\n    param_1[8] = param_2;\n    param_1[6] = param_3;\n    return param_1;\n}\n",
        "token_count": 145
    },
    "0043f557": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\ncode ** __thiscall fcn.0043f557(code **param_1, code *param_2, code *param_3, code *param_4, code *param_5)\n\n{\n    fcn.00428a81();\n    param_1[0xd] = vtable.CEnumArray::XEnumVOID.0;\n    param_1[7] = param_2;\n    param_1[8] = NULL;\n    param_1[10] = NULL;\n    param_1[0xb] = param_4;\n    param_1[9] = param_3;\n    param_1[0xc] = param_5;\n    *param_1 = vtable.CEnumArray.0;\n    return param_1;\n}\n",
        "token_count": 165
    },
    "00442c60": {
        "rules": [
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t * fcn.00442c60(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    iVar2 = *0x45c084;\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    extraout_ECX[7] = iVar2;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = fcn.004253fd(0xa4);\n    *(unaff_EBP + -0x14) = iVar2;\n    *(unaff_EBP + -4) = 1;\n    if (iVar2 == 0) {\n        iVar2 = 0;\n    }\n    else {\n        iVar2 = fcn.00423758(0, 0x40004, 0);\n    }\n    *extraout_ECX = iVar2;\n    uVar1 = *(unaff_EBP + -0xc);\n    *(*(iVar2 + 0x5c) + 0x1c) = 1;\n    *(*(*extraout_ECX + 0x5c) + 0x1e) = 0xffff;\n    extraout_ECX[8] = 0;\n    extraout_ECX[2] = 0;\n    extraout_ECX[3] = 0;\n    extraout_ECX[1] = 0;\n    extraout_ECX[0xe] = 0;\n    extraout_ECX[0xd] = 0;\n    extraout_ECX[5] = 1;\n    extraout_ECX[4] = 1;\n    *in_FS_OFFSET = uVar1;\n    return extraout_ECX;\n}\n",
        "token_count": 473
    },
    "0040e3cb": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0040e3cb(uint *param_1, uint param_2, uint param_3, ushort param_4)\n\n{\n    *param_1 = 0;\n    *(param_1 + 1) = param_4;\n    param_1[3] = 0;\n    param_1[5] = 0;\n    param_1[2] = param_3;\n    param_1[6] = param_2;\n    return;\n}\n",
        "token_count": 108
    },
    "00430456": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid fcn.00430456(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint unaff_EDI;\n    int32_t unaff_retaddr;\n    int32_t iVar3;\n    \n    iVar1 = fcn.0042715b(0);\n    iVar3 = 0;\n    fcn.0042712b(0, unaff_retaddr, 1);\n    iVar2 = fcn.0042715b(1);\n    fcn.0042712b(1, unaff_EDI, 1);\n    fcn.0042730a(iVar1 - iVar3, iVar2 - unaff_retaddr, 0, 0);\n    return;\n}\n",
        "token_count": 155
    },
    "0043625a": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043625a(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CMemFile.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.00436441();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    extraout_ECX[4] = NULL;\n    extraout_ECX[5] = NULL;\n    extraout_ECX[6] = NULL;\n    extraout_ECX[7] = NULL;\n    fcn.0042ad5b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 257
    },
    "00436441": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00436441(int32_t *param_1)\n\n{\n    param_1[4] = 0;\n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[7] = 0;\n    if ((param_1[8] != 0) && (param_1[9] != 0)) {\n        (**(*param_1 + 0x60))(param_1[8]);\n    }\n    param_1[8] = 0;\n    return;\n}\n",
        "token_count": 124
    },
    "0043c85c": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043c85c(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CCommandLineInfo.0;\n    *(unaff_EBP + -4) = 3;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 2;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 1;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 228
    },
    "0043d6d8": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043d6d8(code **param_1, uchar param_2)\n\n{\n    param_1[7] = NULL;\n    param_1[8] = NULL;\n    param_1[9] = NULL;\n    param_1[10] = NULL;\n    param_1[0x40f] = NULL;\n    param_1[0x410] = NULL;\n    param_1[0x413] = 0xffffffff;\n    param_1[0x414] = NULL;\n    param_1[0x419] = NULL;\n    param_1[0x41a] = NULL;\n    *param_1 = vtable.AFX_MODULE_STATE.0;\n    param_1[10] = 0x1c;\n    param_1[8] = 0x14;\n    param_1[6] = NULL;\n    *(param_1 + 5) = param_2;\n    param_1[0xc] = 0x1;\n    param_1[0x410] = 0x18;\n    return;\n}\n",
        "token_count": 241
    },
    "004401c1": {
        "rules": [
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004401c1(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.COleDispatchException.0;\n    *(unaff_EBP + -4) = 2;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 1;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 205
    },
    "00401b5b": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\nuint fcn.00401b5b(void)\n\n{\n    int32_t in_FS_OFFSET;\n    uint var_4h;\n    \n    return *(in_FS_OFFSET + 0x30);\n}\n",
        "token_count": 42
    },
    "004078d5": {
        "rules": [
            "PEB access"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_2ch\n\nvoid fcn.004078d5(void)\n\n{\n    uint uVar1;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_2ch;\n    uint var_1ch;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    uVar1 = fcn.00407997(0x3f800000, 0x3f800000, 0x3f800000);\n    *(unaff_EBP + -4) = 0;\n    fcn.00407a11(uVar1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00407990();\n    uVar1 = fcn.00407997(0, 0, 0);\n    *(unaff_EBP + -4) = 1;\n    fcn.00407a11(uVar1);\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00407990();\n    uVar1 = *(unaff_EBP + -0xc);\n    *(extraout_ECX + 0x30) = 0;\n    *in_FS_OFFSET = uVar1;\n    return;\n}\n",
        "token_count": 294
    },
    "00409ef3": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nvoid fcn.00409ef3(void)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.COleControlSite.0;\n    pcVar1 = extraout_ECX[0x22];\n    *(unaff_EBP + -4) = 2;\n    if (pcVar1 != NULL) {\n        fcn.0040bd8c();\n        fcn.00425426(pcVar1);\n    }\n    fcn.0040ad5c();\n    fcn.0040a9d8(extraout_ECX + 0xf, extraout_ECX[0x18]);\n    fcn.0040a9d8(0x44d868, extraout_ECX[0x19]);\n    fcn.0040a9d8(0x44d818, extraout_ECX[0x21]);\n    piVar2 = extraout_ECX[0x14];\n    if (piVar2 != NULL) {\n        (**(*piVar2 + 0x14))(piVar2);\n        (**(*extraout_ECX[0x14] + 8))(extraout_ECX[0x14]);\n        extraout_ECX[0x14] = NULL;\n    }\n    piVar2 = extraout_ECX[0x15];\n    if (piVar2 != NULL) {\n        (**(*piVar2 + 8))(piVar2);\n        extraout_ECX[0x15] = NULL;\n    }\n    piVar2 = extraout_ECX[0x13];\n    if (piVar2 != NULL) {\n        (**(*piVar2 + 0xc))(piVar2, 0);\n        (**(*extraout_ECX[0x13] + 0x18))(extraout_ECX[0x13], 1);\n        (**(*extraout_ECX[0x13] + 8))(extraout_ECX[0x13]);\n        extraout_ECX[0x13] = NULL;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(extraout_ECX + 0x2a);\n    fcn.0040b5e3(0xffffffff, 0);\n    if (((extraout_ECX[0x25] != NULL) && (extraout_ECX[0x24] != NULL)) &&\n       (piVar2 = *(extraout_ECX[0x24] + 0x88),  piVar2 != NULL)) {\n        (**(*piVar2 + 8))(extraout_ECX, 0);\n    }\n    *(unaff_EBP + -4) = 1;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0;\n    fcn.0044053a();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00428a9b();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 771
    },
    "0042712b": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042712b(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x68))(arg_8h);\n    if (iVar1 == 0) {\n        iVar1 = in_ECX[7];\n    }\n    else {\n        arg_8h = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_SetScrollPos)(iVar1, arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 147
    },
    "0042715b": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042715b(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = (**(*param_1 + 0x68))(param_2);\n    if (iVar1 == 0) {\n        iVar1 = param_1[7];\n    }\n    else {\n        unaff_retaddr = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_GetScrollPos)(iVar1, unaff_retaddr);\n    return;\n}\n",
        "token_count": 134
    },
    "00427183": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427183(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x68))(arg_8h);\n    if (iVar1 == 0) {\n        iVar1 = in_ECX[7];\n    }\n    else {\n        arg_8h = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_SetScrollRange)(iVar1, arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 157
    },
    "004271b6": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004271b6(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    \n    iVar1 = (**(*in_ECX + 0x68))(arg_8h);\n    if (iVar1 == 0) {\n        iVar1 = in_ECX[7];\n    }\n    else {\n        arg_8h = 2;\n        iVar1 = *(iVar1 + 0x1c);\n    }\n    (*_sym.imp.USER32.dll_GetScrollRange)(iVar1, arg_8h, arg_ch, arg_10h);\n    return;\n}\n",
        "token_count": 147
    },
    "00429ba1": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00429ba1(int32_t *param_1)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iStack4;\n    \n    bVar1 = true;\n    iStack4 = 0;\n    do {\n        if (bVar1) {\n            do {\n                iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(param_1 + 0xc, 0, 0, 0, 0);\n                if (iVar2 != 0) break;\n                iVar2 = iStack4 + 1;\n                iVar3 = (**(*param_1 + 0x60))(iStack4);\n                if (iVar3 == 0) {\n                    bVar1 = false;\n                }\n                iStack4 = iVar2;\n            } while (bVar1);\n        }\n        do {\n            iVar2 = (**(*param_1 + 0x5c))();\n            if (iVar2 == 0) {\n                (**(*param_1 + 0x68))();\n                return;\n            }\n            iVar2 = (**(*param_1 + 100))(param_1 + 0xc);\n            if (iVar2 != 0) {\n                bVar1 = true;\n            }\n            iVar2 = (*_sym.imp.USER32.dll_PeekMessageA)(param_1 + 0xc, 0, 0, 0, 0);\n        } while (iVar2 != 0);\n    } while( true );\n}\n",
        "token_count": 335
    },
    "0042d019": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nuint fcn.0042d019(uint param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uVar4;\n    \n    uVar4 = 0xffffffff;\n    piVar2 = fcn.00429b18();\n    iVar3 = fcn.0043d8de();\n    piVar1 = *(iVar3 + 4);\n    iVar3 = fcn.0043ec1c(param_1, param_2, param_3, param_4);\n    if ((iVar3 != 0) && ((piVar1 == NULL || (iVar3 = (**(*piVar1 + 0x84))(),  iVar3 != 0)))) {\n        iVar3 = (**(*piVar2 + 0x50))();\n        if (iVar3 == 0) {\n            if (piVar2[7] != NULL) {\n                (**(*piVar2[7] + 0x58))();\n            }\n            uVar4 = (**(*piVar2 + 0x68))();\n        }\n        else {\n            uVar4 = (**(*piVar2 + 0x54))();\n        }\n    }\n    fcn.00443f37();\n    return uVar4;\n}\n",
        "token_count": 294
    },
    "0042e080": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042e080(int32_t *param_1, int32_t param_2)\n\n{\n    fcn.00424bd6(param_2);\n    *(param_2 + 0x3c) = param_1;\n    (**(*param_1 + 0x68))();\n    return;\n}\n",
        "token_count": 74
    },
    "0042e0a0": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042e0a0(int32_t *param_1, int32_t param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = fcn.00424c5a(param_2, 0);\n    fcn.00424c23(uVar1);\n    *(param_2 + 0x3c) = 0;\n    (**(*param_1 + 0x68))();\n    return;\n}\n",
        "token_count": 102
    },
    "0043056c": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043056c(int32_t *param_1, int32_t *param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    param_2[1] = 0;\n    *param_2 = 0;\n    uVar1 = fcn.00428783();\n    iVar2 = (**(*param_1 + 0x68))(1);\n    if ((iVar2 == 0) && (*param_2 = *0x460330,  (uVar1 & 0x800000) != 0)) {\n        *param_2 = *param_2 + -1;\n    }\n    iVar2 = (**(*param_1 + 0x68))(0);\n    if ((iVar2 == 0) && (param_2[1] = *0x460334,  (uVar1 & 0x800000) != 0)) {\n        param_2[1] = param_2[1] + -1;\n    }\n    return;\n}\n",
        "token_count": 230
    },
    "00435021": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00435021(int32_t param_1)\n\n{\n    int32_t iStack8;\n    int32_t iStack4;\n    \n    iStack8 = param_1;\n    iStack4 = param_1;\n    fcn.004351fe();\n    (**(**(param_1 + 0x68) + 0xbc))(&iStack8, *(param_1 + 0x40) - *(param_1 + 0x38), 0x42);\n    fcn.00439c9d(*(param_1 + 0x68), *(param_1 + 0x48), *(param_1 + 0x4c), *(param_1 + 0x70) & 0x40 | 0x2004);\n    return;\n}\n",
        "token_count": 176
    },
    "0042b112": {
        "rules": [
            "inject DLL reflectively/5c249d14806d4a4ea88afb4f94553771"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042b112(int32_t *param_1)\n\n{\n    uint uVar1;\n    uint uVar2;\n    \n    uVar1 = (**(*param_1 + 0x28))(0, 1);\n    uVar2 = (**(*param_1 + 0x28))(0, 2);\n    (**(*param_1 + 0x28))(uVar1, 0);\n    return uVar2;\n}\n",
        "token_count": 101
    },
    "0042b2d2": {
        "rules": [
            "create or open registry key",
            "query or enumerate registry value"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042b2d2(uint hKey, uint arg_ch)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    bool bVar5;\n    uint lpType;\n    uint lpcbData;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.ADVAPI32.dll_RegOpenKeyA;\n    bVar5 = false;\n    var_8h = 0;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyA)(0x80000000, \"CLSID\", &var_8h);\n    if (iVar3 == 0) {\n        var_4h = 0;\n        iVar3 = (*pcVar1)(var_8h, hKey, &var_4h);\n        pcVar2 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n        if (iVar3 == 0) {\n            hKey = 0;\n            iVar3 = (*pcVar1)(var_4h, \"InProcServer32\", &hKey);\n            if (iVar3 == 0) {\n                uVar4 = fcn.0042a714(0x104);\n                lpcbData = 0x104;\n                iVar3 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0x45e614, 0, &lpType, uVar4, &lpcbData);\n                fcn.0042a763(0xffffffff);\n                bVar5 = iVar3 == 0;\n                (*pcVar2)(hKey);\n            }\n            (*pcVar2)(var_4h);\n        }\n        (*pcVar2)(var_8h);\n    }\n    return bVar5;\n}\n",
        "token_count": 398
    },
    "0043d03b": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043d03b(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    var_ch = 0;\n    var_4h = 0;\n    var_8h = 0;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(0x80000001, \"software\", 0, 0x2001f, &var_4h);\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCreateKeyExA;\n    if (iVar2 == 0) {\n        iVar2 = (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)\n                          (var_4h, *(param_1 + 0x7c), 0, 0, 0, 0x2001f, 0, &var_8h, &var_10h);\n        if (iVar2 == 0) {\n            (*pcVar1)(var_8h, *(param_1 + 0x90), 0, 0, 0, 0x2001f, 0, &var_ch, &var_10h);\n        }\n    }\n    pcVar1 = _sym.imp.ADVAPI32.dll_RegCloseKey;\n    if (var_4h != 0) {\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n    }\n    if (var_8h != 0) {\n        (*pcVar1)(var_8h);\n    }\n    return var_ch;\n}\n",
        "token_count": 383
    },
    "0043d0cf": {
        "rules": [
            "create or open registry key"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043d0cf(uint lpSubKey)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.0043d03b();\n    if (iVar1 == 0) {\n        var_4h = 0;\n    }\n    else {\n        (*_sym.imp.ADVAPI32.dll_RegCreateKeyExA)(iVar1, lpSubKey, 0, 0, 0, 0x2001f, 0, &var_4h, &var_8h);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n    }\n    return var_4h;\n}\n",
        "token_count": 167
    },
    "004011db": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.004011db(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = param_1 + 0x500;\n    iVar2 = 0;\n    if (0 < *piVar1) {\n        do {\n            *(param_1 + 0x300 + iVar2) = 0;\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *piVar1);\n    }\n    *(param_1 + 0x300) = 1;\n    *(param_1 + 0x2ff + *piVar1) = 1;\n    *(param_1 + 0x300) = 1;\n    *(*(param_1 + 0x500) + 0x2ff + param_1) = 1;\n    iVar2 = 0;\n    *(param_1 + 0x504) = 0;\n    if (0 < *(param_1 + 0x500)) {\n        do {\n            if (*(param_1 + 0x300 + iVar2) == '\\x01') {\n                *(param_1 + 0x400 + *(param_1 + 0x504)) = iVar2;\n                *(param_1 + 0x504) = *(param_1 + 0x504) + 1;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < *(param_1 + 0x500));\n    }\n    return 1;\n}\n",
        "token_count": 340
    },
    "00401b6d": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.00401b6d(char *param_1, char *param_2)\n\n{\n    char cVar1;\n    \n    while( true ) {\n        cVar1 = *param_1;\n        if ((cVar1 == '\\0') && (*param_2 == '\\0')) {\n            return 0;\n        }\n        if ((*param_2 < cVar1) || (cVar1 < *param_2)) break;\n        param_1 = param_1 + 1;\n        param_2 = param_2 + 1;\n    }\n    return 1;\n}\n",
        "token_count": 129
    },
    "004039bf": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004039bf(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = 0;\n    iVar1 = *(param_1 + 0x18);\n    if (0 < iVar1) {\n        do {\n            iVar2 = fcn.00401431();\n            if (iVar2 != 0) {\n                fcn.004015f1();\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < iVar1);\n    }\n    *(param_1 + 0xbc) = 1;\n    return;\n}\n",
        "token_count": 145
    },
    "004045e5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004045e5(int32_t *param_1)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < param_1[1]) {\n        do {\n            puVar1 = *(*param_1 + iVar2 * 4);\n            if (puVar1 != NULL) {\n                (***puVar1)(1);\n                *(*param_1 + iVar2 * 4) = 0;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < param_1[1]);\n    }\n    fcn.0040465e(0, 0xffffffff);\n    return;\n}\n",
        "token_count": 154
    },
    "0040584e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.0040584e(uint param_1)\n\n{\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    fcn.00405837();\n    iVar1 = fcn.004058a9(param_1);\n    if ((iVar1 != 0) && (iVar1 = fcn.00405aa7(),  iVar1 != 0)) {\n        fcn.00405ae3();\n        fcn.00405b43();\n        while (iVar1 = fcn.00405b7f(0x45b9b4),  iVar1 != 0) {\n            fcn.00405d0c(unaff_retaddr);\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 161
    },
    "00405b43": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00405b43(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = 0;\n    iVar1 = param_1[2];\n    if (iVar1 < *param_1) {\n        do {\n            fcn.004059e6();\n            iVar2 = fcn.00410730(param_1 + 4, \"IndexedFaceSet\");\n            if (iVar2 != 0) {\n                iVar3 = iVar3 + 1;\n            }\n        } while (param_1[2] < *param_1);\n    }\n    param_1[2] = iVar1;\n    return iVar3;\n}\n",
        "token_count": 164
    },
    "00406c7c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00406c7c(uint *param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    \n    uVar4 = 0;\n    if (param_1[0xe] == 0) {\n        (***param_1)();\n    }\n    uVar1 = param_1[2];\n    if (uVar1 != 0) {\n        do {\n            piVar2 = *(param_1[1] + uVar4 * 4);\n            iVar3 = (**(*piVar2 + 4))();\n            if (iVar3 == param_2) {\n                (**(*piVar2 + 0xc))();\n            }\n            uVar4 = uVar4 + 1;\n        } while (uVar4 < uVar1);\n    }\n    return;\n}\n",
        "token_count": 206
    },
    "00406da9": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00406da9(uint arg_8h, int32_t *arg_ch)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (0 < *(in_ECX + 0x18)) {\n        do {\n            puVar1 = fcn.00406dfb(&var_4h);\n            iVar2 = fcn.00410670(*puVar1, arg_8h);\n            fcn.0042a358();\n            if (iVar2 == 0) {\n                *arg_ch = iVar3;\n                return 1;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(in_ECX + 0x18));\n    }\n    return 0;\n}\n",
        "token_count": 195
    },
    "0040702c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0040702c(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    iVar2 = 0;\n    if (0 < param_1[1]) {\n        do {\n            piVar1 = *(*param_1 + iVar2 * 4);\n            if (piVar1 != NULL) {\n                (**(*piVar1 + 4))(1);\n                *(*param_1 + iVar2 * 4) = 0;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < param_1[1]);\n    }\n    fcn.0040465e(0, 0xffffffff);\n    return;\n}\n",
        "token_count": 159
    },
    "0040bf6c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n\nuint __cdecl fcn.0040bf6c(uint arg_8h)\n\n{\n    code **ppcVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t iVar4;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint32_t uVar5;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x14) = 0;\n    if (extraout_ECX[1] != 0) {\n        *(unaff_EBP + -0x10) = 0;\n        ppcVar1 = **(unaff_EBP + 8);\n        *(unaff_EBP + -4) = 0;\n        iVar4 = (**ppcVar1)(*(unaff_EBP + 8), 0x44d808, unaff_EBP + -0x10);\n        *(unaff_EBP + -0x14) = iVar4;\n        if ((-1 < iVar4) && (uVar5 = 0,  extraout_ECX[1] != 0)) {\n            do {\n                (**(**(unaff_EBP + -0x10) + 0x18))(*(unaff_EBP + -0x10), *(*extraout_ECX + uVar5 * 8), 0);\n                uVar5 = uVar5 + 1;\n            } while (uVar5 < extraout_ECX[1]);\n        }\n        extraout_ECX[1] = 0;\n        fcn.00425426(*extraout_ECX);\n        piVar2 = *(unaff_EBP + -0x10);\n        *(unaff_EBP + -4) = 0xffffffff;\n        *extraout_ECX = 0;\n        if (piVar2 != NULL) {\n            (**(*piVar2 + 8))(piVar2);\n        }\n    }\n    uVar3 = *(unaff_EBP + -0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 538
    },
    "0040e1fa": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0040e1fa(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    iVar2 = 0;\n    uVar3 = 0;\n    uVar1 = *(*(param_1 + 8) + 4);\n    if (uVar1 != 0) {\n        do {\n            iVar2 = fcn.0040e222();\n            if (iVar2 < 0) {\n                return iVar2;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < uVar1);\n    }\n    return iVar2;\n}\n",
        "token_count": 154
    },
    "0040eb5a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0040eb5a(uint param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBX;\n    int32_t iVar4;\n    int32_t iVar5;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar4 = 0;\n    if (param_2 != 0) {\n        while ((iVar5 = param_2,  uVar2 = (*pcVar1)(*(iVar5 + 0x1c), 0xfffffff0),  (uVar2 & 0xc0000000) == 0x40000000 &&\n               (iVar5 != unaff_EBX))) {\n            uVar3 = (*_sym.imp.USER32.dll_GetParent)(*(iVar5 + 0x1c));\n            param_2 = fcn.00425960(uVar3);\n            uVar2 = (*pcVar1)(*(param_2 + 0x1c), 0xffffffec);\n            if ((uVar2 & 0x10000) != 0) {\n                return iVar5;\n            }\n            iVar4 = iVar5;\n            if (param_2 == 0) {\n                return iVar5;\n            }\n        }\n    }\n    return iVar4;\n}\n",
        "token_count": 298
    },
    "0040ecae": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040ecae(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint noname_5;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    int32_t noname_6;\n    \n    iVar3 = 0;\n    noname_6 = arg_ch;\n    iVar1 = fcn.0040eb5a(arg_8h);\n    while( true ) {\n        if (iVar1 != 0) {\n            iVar1 = *(iVar1 + 0x1c);\n        }\n        noname_5 = (*_sym.imp.USER32.dll_GetNextDlgGroupItem)(*(arg_8h + 0x1c), iVar1, 0);\n        iVar1 = fcn.00425960();\n        if (((iVar1 == 0) || (iVar3 = iVar3 + 1,  iVar1 == arg_ch)) || (0x3c < iVar3)) break;\n        iVar2 = fcn.0040ec8f(iVar1, arg_10h);\n        if (iVar2 != 0) {\n            return iVar1;\n        }\n    }\n    iVar3 = fcn.0040eb5a(arg_8h);\n    iVar1 = iVar3;\n    do {\n        iVar1 = fcn.0040ebb3(arg_8h, iVar1, 3, arg_8h, arg_ch, noname_5, noname_6, unaff_EDI, unaff_ESI);\n        iVar2 = fcn.0040ec8f(iVar1, arg_10h);\n        if (iVar2 != 0) {\n            return iVar1;\n        }\n    } while (iVar1 != iVar3);\n    return 0;\n}\n",
        "token_count": 409
    },
    "0040ed59": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040ed59(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t var_4h;\n    \n    iVar3 = 0;\n    var_4h = 0;\n    do {\n        arg_ch = fcn.0040ecae(arg_8h, arg_ch, arg_10h);\n        if (arg_ch == 0) {\n            return 0;\n        }\n        iVar1 = fcn.0040ed33(arg_ch);\n        if (iVar1 != 0) {\n            uVar2 = (*_sym.imp.USER32.dll_GetNextDlgTabItem)(*(arg_8h + 0x1c), *(arg_ch + 0x1c), 0);\n            arg_ch = fcn.00425960(uVar2);\n            if (arg_ch == 0) {\n                return 0;\n            }\n        }\n        iVar1 = fcn.0042896a();\n        if (iVar1 != 0) {\n            return arg_ch;\n        }\n        if (arg_ch == iVar3) {\n            return 0;\n        }\n        if (iVar3 == 0) {\n            iVar3 = arg_ch;\n        }\n        var_4h = var_4h + 1;\n    } while (var_4h < 0x200);\n    return 0;\n}\n",
        "token_count": 323
    },
    "0040edce": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040edce(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if (param_1 != 0) {\n        piVar4 = NULL;\n        iVar3 = param_1;\n        do {\n            iVar1 = *(iVar3 + 0x34);\n            if ((iVar1 != 0) || (piVar4 = *(iVar3 + 0x38),  piVar4 != NULL)) break;\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar3 + 0x1c));\n            iVar3 = fcn.00425960(uVar2);\n        } while (iVar3 != 0);\n        if ((iVar3 != 0) && (iVar1 == 0)) {\n            (**(*piVar4 + 0xac))();\n            uVar2 = (*_sym.imp.USER32.dll_GetFocus)();\n            iVar3 = fcn.00425960(uVar2);\n            if (iVar3 != param_1) {\n                fcn.004289ac();\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 259
    },
    "0040ee2b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040ee2b(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_retaddr;\n    \n    if ((param_1 != 0) &&\n       (iVar3 = (*_sym.imp.USER32.dll_IsWindow)(*(param_1 + 0x1c)),  pcVar2 = _sym.imp.USER32.dll_GetParent,  iVar3 != 0\n       )) {\n        uVar4 = *(param_1 + 0x1c);\n        while( true ) {\n            uVar4 = (*pcVar2)(uVar4);\n            iVar3 = fcn.00425960(uVar4);\n            if (iVar3 == 0) break;\n            piVar1 = *(iVar3 + 0x34);\n            if (piVar1 != NULL) {\n                if (piVar1[0x12] == 0) {\n                    return;\n                }\n                iVar3 = fcn.00425960(*(piVar1[0x12] + 0x20));\n                if (iVar3 == 0) {\n                    return;\n                }\n                if (unaff_retaddr == iVar3) {\n                    return;\n                }\n                if ((unaff_retaddr != 0) &&\n                   (iVar3 = (*_sym.imp.USER32.dll_IsChild)(*(iVar3 + 0x1c), *(unaff_retaddr + 0x1c)),  iVar3 != 0)) {\n                    return;\n                }\n                (**(*piVar1 + 0x5c))(0);\n                return;\n            }\n            uVar4 = *(iVar3 + 0x1c);\n        }\n    }\n    return;\n}\n",
        "token_count": 386
    },
    "0040ee9e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.0040ee9e(int32_t param_1, uint param_2)\n\n{\n    int32_t noname_4;\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t noname_1;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint noname_5;\n    \n    noname_4 = fcn.004286f7();\n    if (noname_4 == 0) {\n        noname_5 = 1;\n        iVar1 = fcn.0040ebb3(param_1, 0, 1, param_2, unaff_EDI, unaff_ESI, unaff_EBX, unaff_retaddr, param_1);\n        noname_1 = iVar1;\n        if (iVar1 != param_1) {\n            do {\n                iVar2 = fcn.0042886f();\n                if (iVar2 == unaff_ESI) {\n                    return noname_1;\n                }\n                noname_1 = fcn.0040ebb3(param_1, noname_1, 1, param_1, noname_4, noname_5, param_2, unaff_EDI, unaff_ESI\n                                       );\n            } while ((noname_1 != 0) && (noname_1 != iVar1));\n        }\n        noname_4 = 0;\n    }\n    return noname_4;\n}\n",
        "token_count": 333
    },
    "0040ef63": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040ef63(uint param_1, int32_t param_2, uint param_3)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t noname_1;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint noname_4;\n    int32_t noname_5;\n    \n    if (param_2 != 0) {\n        noname_4 = *(param_2 + 0x1c);\n        uVar1 = (*_sym.imp.USER32.dll_GetWindowLongA)(noname_4, 0xffffffec);\n        if ((uVar1 & 0x10000) == 0) {\n            iVar2 = fcn.0040eb5a();\n            noname_5 = param_2;\n            goto code_r0x0040ef98;\n        }\n    }\n    noname_5 = 3;\n    noname_4 = 0;\n    iVar2 = fcn.0040ebb3(param_1, 0, 3, unaff_EDI, unaff_ESI, unaff_retaddr, param_1, param_2, param_3);\ncode_r0x0040ef98:\n    noname_1 = iVar2;\n    if (iVar2 != 0) {\n        do {\n            fcn.0040eef5(noname_1, 0);\n            noname_1 = fcn.0040ebb3(unaff_EDI, noname_1, 0, unaff_EDI, noname_4, noname_5, unaff_EDI, unaff_ESI, \n                                    unaff_retaddr);\n            if (noname_1 == 0) {\n                return;\n            }\n        } while (noname_1 != iVar2);\n    }\n    return;\n}\n",
        "token_count": 407
    },
    "0040f7df": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.0040f7df(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    iVar2 = fcn.0043d8de();\n    fcn.0043e309(0xb);\n    while (puVar1 = *(iVar2 + 0x103c),  puVar1 != NULL) {\n        fcn.0043dba5();\n        if (puVar1 != NULL) {\n            (***puVar1)(1);\n        }\n    }\n    fcn.0043e379(0xb);\n    return;\n}\n",
        "token_count": 126
    },
    "00410584": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nulong fcn.00410584(int32_t param_1, uint param_2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uchar in_ZF;\n    uint16_t in_FPUControlWord;\n    uint16_t in_FPUStatusWord;\n    unkbyte10 extraout_ST0;\n    float10 fVar4;\n    uint64_t uVar5;\n    uint unaff_retaddr;\n    uint32_t arg_8h;\n    \n    uVar5 = fcn.004150a5();\n    arg_8h = uVar5 >> 0x20 & 0xffff0000 | in_FPUControlWord;\n    if (in_ZF) {\n        if (((uVar5 & 0xfffff) == 0) && (param_1 == 0)) {\n            uVar1 = 1;\n        }\n        else {\n            uVar1 = fcn.0041508c();\n        }\n        if (*0x46066c == 0) {\n            uVar3 = fcn.00415207(arg_8h, unaff_retaddr, param_1, param_2);\n            return CONCAT44(arg_8h, uVar3);\n        }\n    }\n    else {\n        fVar4 = fcos(extraout_ST0);\n        uVar1 = uVar5 & 0xffff0000 | in_FPUStatusWord;\n        if ((in_FPUStatusWord & 0x400) != 0) {\n            do {\n                fVar4 = fVar4 - (fVar4 / *0x44d1ca) * *0x44d1ca;\n                uVar1 = uVar1 & 0xffff0000 | in_FPUStatusWord;\n            } while ((in_FPUStatusWord & 0x400) != 0);\n            fcos(fVar4);\n        }\n        if (*0x46066c == 0) {\n            uVar2 = uVar1 & 0xffff0000 | in_FPUControlWord;\n            if (in_FPUControlWord != 0x27f) {\n                if (((in_FPUControlWord & 0x20) != 0) &&\n                   (uVar2 = uVar1 & 0xffff0000 | in_FPUStatusWord,  (in_FPUStatusWord & 0x20) != 0)) {\n                    uVar3 = fcn.00415207(arg_8h, unaff_retaddr, param_1, param_2);\n                    return CONCAT44(arg_8h, uVar3);\n                }\n                uVar2 = uVar2 & 0xffff0020;\n            }\n            return CONCAT44(arg_8h, uVar2);\n        }\n    }\n    return CONCAT44(arg_8h, uVar1);\n}\n",
        "token_count": 610
    },
    "00424c5a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00424c5a(int32_t param_1, int32_t param_2, uint *param_3)\n\n{\n    if (param_3 != NULL) goto code_r0x00424c67;\n    param_3 = *(param_1 + 4);\n    while( true ) {\n        if (param_3 == NULL) {\n            return NULL;\n        }\n        if (param_3[2] == param_2) break;\ncode_r0x00424c67:\n        param_3 = *param_3;\n    }\n    return param_3;\n}\n",
        "token_count": 133
    },
    "00424f06": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00424f06(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1 != NULL) {\n        do {\n            piVar1 = *param_1;\n            fcn.00425426(param_1);\n            param_1 = piVar1;\n        } while (piVar1 != NULL);\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00425019": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint * __thiscall fcn.00425019(int32_t param_1, uint32_t param_2, uint32_t *param_3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    \n    uVar2 = (param_2 >> 4) % *(param_1 + 8);\n    *param_3 = uVar2;\n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + uVar2 * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1;\n            }\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 170
    },
    "0042504b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042504b(int32_t param_1, uint32_t param_2)\n\n{\n    uint *puVar1;\n    \n    if (*(param_1 + 4) != 0) {\n        for (puVar1 = *(*(param_1 + 4) + ((param_2 >> 4) % *(param_1 + 8)) * 4); puVar1 != NULL; puVar1 = *puVar1) {\n            if (puVar1[1] == param_2) {\n                return puVar1[2];\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 139
    },
    "004250ce": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.004250ce(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    \n    iVar1 = *(param_1 + 4);\n    if (iVar1 != 0) {\n        uVar4 = (param_2 >> 4) % *(param_1 + 8);\n        puVar2 = *(iVar1 + uVar4 * 4);\n        puVar5 = iVar1 + uVar4 * 4;\n        while (puVar3 = puVar2,  puVar3 != NULL) {\n            if (puVar3[1] == param_2) {\n                *puVar5 = *puVar3;\n                fcn.00425000(puVar3);\n                return 1;\n            }\n            puVar5 = puVar3;\n            puVar2 = *puVar3;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 231
    },
    "004253fd": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.004253fd(uint param_1)\n\n{\n    int32_t iVar1;\n    \n    while( true ) {\n        iVar1 = fcn.0041011c(param_1);\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*0x45bd94 == NULL) break;\n        iVar1 = (**0x45bd94)(param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "00426408": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00426408(int32_t param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    iVar1 = (*_sym.imp.USER32.dll_GetMenuItemCount)(*(param_1 + 4));\n    iVar4 = 0;\n    if (0 < iVar1) {\n        do {\n            uVar2 = (*_sym.imp.USER32.dll_GetSubMenu)(*(param_1 + 4), iVar4);\n            iVar3 = fcn.0042bcc2(uVar2);\n            if (iVar3 == 0) {\n                iVar3 = (*_sym.imp.USER32.dll_GetMenuItemID)(*(param_1 + 4), iVar4);\n                if (iVar3 == param_1) {\n                    iVar1 = fcn.0042bcd7(*(param_1 + 4));\n                    return iVar1;\n                }\n            }\n            else {\n                iVar3 = fcn.00426408(iVar3, param_3);\n                if (iVar3 != 0) {\n                    return iVar3;\n                }\n            }\n            iVar4 = iVar4 + 1;\n        } while (iVar4 < iVar1);\n    }\n    return 0;\n}\n",
        "token_count": 282
    },
    "00426e8f": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00426e8f(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetParent;\n    if ((param_1 != 0) && (iVar4 = *(param_1 + 0x1c),  iVar4 != 0)) {\n        while( true ) {\n            uVar2 = (*pcVar1)(iVar4);\n            piVar3 = fcn.00425960(uVar2);\n            if (piVar3 == NULL) break;\n            iVar4 = (**(*piVar3 + 0xb0))();\n            if (iVar4 != 0) {\n                return piVar3;\n            }\n            iVar4 = piVar3[7];\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 199
    },
    "00426f12": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00426f12(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    if ((param_1 != 0) && (iVar1 = *(param_1 + 0x1c),  *(param_1 + 0x1c) != 0)) {\n        do {\n            iVar3 = iVar1;\n            iVar1 = fcn.00426ecd(iVar3);\n        } while (iVar1 != 0);\n        uVar2 = fcn.00425960(iVar3);\n        return uVar2;\n    }\n    return 0;\n}\n",
        "token_count": 146
    },
    "00426f3a": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00426f3a(int32_t param_1)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t iVar5;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    if ((param_1 == 0) || (iVar5 = *(param_1 + 0x1c),  iVar5 == 0)) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar5, 0xfffffff0);\n    while ((uVar2 & 0x40000000) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetParent)(iVar5);\n        if (iVar3 == 0) break;\n        uVar2 = (*pcVar1)(iVar3, 0xfffffff0);\n        iVar5 = iVar3;\n    }\n    uVar4 = fcn.00425960(iVar5);\n    return uVar4;\n}\n",
        "token_count": 236
    },
    "00427030": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00427030(uint hDlg, uint nIDDlgItem, int32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.USER32.dll_GetDlgItem)(hDlg, nIDDlgItem);\n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    if (iVar2 != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_GetTopWindow)(iVar2);\n        if ((iVar3 != 0) && (iVar3 = fcn.00427030(iVar2, nIDDlgItem, arg_10h),  iVar3 != 0)) {\n            return iVar3;\n        }\n        if (arg_10h == 0) {\n            iVar2 = fcn.00425960();\n            return iVar2;\n        }\n        iVar2 = fcn.00425987(iVar2);\n        if (iVar2 != 0) {\n            return iVar2;\n        }\n    }\n    iVar2 = (*pcVar1)(hDlg);\n    while( true ) {\n        if (iVar2 == 0) {\n            return 0;\n        }\n        iVar3 = fcn.00427030(iVar2, nIDDlgItem, arg_10h);\n        if (iVar3 != 0) break;\n        iVar2 = (*_sym.imp.USER32.dll_GetWindow)(iVar2, 2);\n    }\n    return iVar3;\n}\n",
        "token_count": 328
    },
    "00427b29": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00427b29(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint lpMsg;\n    \n    pcVar1 = _sym.imp.USER32.dll_PeekMessageA;\n    while( true ) {\n        iVar2 = (*pcVar1)(&lpMsg, 0, 0x121, 0x121, 1);\n        if (iVar2 == 0) break;\n        (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n    }\n    fcn.004258c7();\n    return;\n}\n",
        "token_count": 127
    },
    "0042bc37": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042bc37(int32_t param_1, int32_t param_2)\n\n{\n    while( true ) {\n        if (param_1 == 0) {\n            return 0;\n        }\n        if (param_1 == param_2) break;\n        param_1 = *(param_1 + 0x10);\n    }\n    return 1;\n}\n",
        "token_count": 87
    },
    "0042f44b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042f44b(int32_t hWnd, uint lpPoint, uint arg_10h)\n\n{\n    code *pcVar1;\n    int16_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint lpRect;\n    \n    (*_sym.imp.USER32.dll_ClientToScreen)(hWnd, &lpPoint);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    uVar5 = 5;\n    do {\n        hWnd = (*pcVar1)(hWnd, uVar5);\n        if (hWnd == 0) {\n            return 0;\n        }\n        iVar2 = (*_sym.imp.USER32.dll_GetDlgCtrlID)(hWnd);\n        if ((iVar2 != -1) &&\n           (uVar3 = (*_sym.imp.USER32.dll_GetWindowLongA)(hWnd, 0xfffffff0),  (uVar3 & 0x10000000) != 0)) {\n            (*_sym.imp.USER32.dll_GetWindowRect)(hWnd, &lpRect);\n            iVar4 = (*_sym.imp.USER32.dll_PtInRect)(&lpRect, lpPoint, arg_10h);\n            if (iVar4 != 0) {\n                return hWnd;\n            }\n        }\n        uVar5 = 2;\n    } while( true );\n}\n",
        "token_count": 301
    },
    "004320ae": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004320ae(void)\n\n{\n    int32_t iVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDockBar.0;\n    iVar2 = 0;\n    *(unaff_EBP + -4) = 1;\n    if (0 < extraout_ECX[0x21]) {\n        do {\n            iVar1 = fcn.00432d5c();\n            if ((iVar1 != 0) && (*(iVar1 + 0x70) == extraout_ECX)) {\n                *(iVar1 + 0x70) = 0;\n            }\n            iVar2 = iVar2 + 1;\n        } while (iVar2 < extraout_ECX[0x21]);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00424cb0();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00433280();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 316
    },
    "00432165": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00432165(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = 0;\n    iVar3 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            iVar1 = fcn.00432d5c();\n            if (iVar1 != 0) {\n                iVar2 = iVar2 + 1;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < *(param_1 + 0x84));\n    }\n    return iVar2;\n}\n",
        "token_count": 145
    },
    "00432ced": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00432ced(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            if ((iVar1 != param_3) && (*(*(param_1 + 0x80) + iVar1 * 4) == param_2)) {\n                return iVar1;\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x84));\n    }\n    return -1;\n}\n",
        "token_count": 146
    },
    "00432d1b": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00432d1b(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    int32_t iVar1;\n    uint unaff_retaddr;\n    \n    iVar1 = 0;\n    if (0 < *(param_1 + 0x84)) {\n        do {\n            arg_8h = fcn.00432d5c(iVar1);\n            if (arg_8h != 0) {\n                fcn.00439a92();\n                fcn.00438c29(arg_8h, unaff_retaddr, 1);\n            }\n            iVar1 = iVar1 + 1;\n        } while (iVar1 < *(param_1 + 0x84));\n    }\n    return;\n}\n",
        "token_count": 165
    },
    "00434560": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint32_t fcn.00434560(int32_t param_1, int32_t *param_2)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    \n    pcVar2 = _sym.imp.USER32.dll_GetParent;\n    iVar3 = param_1;\n    if (param_1 != 0) goto code_r0x004345d9;\n    iVar3 = fcn.004345fc();\n    if ((iVar3 == 0) && (iVar3 = fcn.00407d0c(),  iVar3 == 0)) {\n        iVar3 = 0;\n        iVar4 = iVar3;\n        iVar5 = iVar3;\n    }\n    else {\n        for (iVar3 = *(iVar3 + 0x1c); iVar4 = iVar3,  iVar5 = iVar3,  iVar3 != 0; iVar3 = (*pcVar2)(iVar3)) {\ncode_r0x004345d9:\n            uVar6 = (*_sym.imp.USER32.dll_GetWindowLongA)(iVar3, 0xfffffff0);\n            iVar4 = iVar3;\n            iVar5 = iVar3;\n            if ((uVar6 & 0x40000000) == 0) break;\n        }\n    }\n    while (iVar1 = iVar4,  iVar1 != 0) {\n        iVar4 = (*pcVar2)(iVar1);\n        iVar3 = iVar1;\n    }\n    if ((param_1 == 0) && (iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetLastActivePopup)(iVar5);\n    }\n    if (param_2 != NULL) {\n        if (((iVar3 == 0) || (iVar4 = (*_sym.imp.USER32.dll_IsWindowEnabled)(iVar3),  iVar4 == 0)) || (iVar3 == iVar5))\n        {\n            *param_2 = 0;\n        }\n        else {\n            *param_2 = iVar3;\n            (*_sym.imp.USER32.dll_EnableWindow)(iVar3, 0);\n        }\n    }\n    return iVar5;\n}\n",
        "token_count": 484
    },
    "0043550e": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043550e(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint lpMsg;\n    int32_t var_18h;\n    int32_t var_14h;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetCapture;\n    iVar2 = (*_sym.imp.USER32.dll_GetCapture)();\n    if (iVar2 == 0) {\n        uVar3 = (*_sym.imp.USER32.dll_SetCapture)(*(*(param_1 + 0x68) + 0x1c));\n        fcn.00425960(uVar3);\n        uVar3 = (*pcVar1)();\n        iVar2 = fcn.00425960(uVar3);\n        if (iVar2 == *(param_1 + 0x68)) {\n            do {\n                uVar4 = 0;\n                uVar3 = 0;\n                iVar2 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n                if (iVar2 == 0) {\n                    fcn.00443db3(uVar4, var_14h);\n                    break;\n                }\n                if (var_18h == 0x100) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.00434c2d(uVar3, 1, var_14h);\n                    }\n                    if (var_14h == 0x1b) break;\n                }\n                else if (var_18h == 0x101) {\n                    if (*(param_1 + 0x88) != 0) {\n                        fcn.00434c2d(uVar3, 0, var_14h);\n                    }\n                }\n                else if (var_18h == 0x200) {\n                    if (*(param_1 + 0x88) == 0) {\n                        fcn.00434eb9(var_8h, var_4h);\n                    }\n                    else {\n                        fcn.00434bb1(var_8h, var_4h);\n                    }\n                }\n                else {\n                    if (var_18h == 0x202) {\n                        if (*(param_1 + 0x88) == 0) {\n                            fcn.00435021();\n                        }\n                        else {\n                            fcn.00434c61();\n                        }\n                        return 1;\n                    }\n                    if (var_18h == 0x204) break;\n                    (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n                }\n                uVar3 = (*pcVar1)();\n                iVar2 = fcn.00425960(uVar3);\n            } while (iVar2 == *(param_1 + 0x68));\n        }\n        fcn.004351fe();\n    }\n    return 0;\n}\n",
        "token_count": 648
    },
    "00437d02": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint fcn.00437d02(int32_t param_1, int32_t param_2)\n\n{\n    do {\n        if (param_1 == param_2) {\n            return 1;\n        }\n        param_2 = fcn.00426ecd();\n    } while (param_2 != 0);\n    return 0;\n}\n",
        "token_count": 75
    },
    "00437ffb": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00437ffb(int32_t param_1, uint32_t param_2)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint uVar7;\n    \n    uVar3 = fcn.00428783();\n    iVar4 = param_1;\n    if ((uVar3 & 0x40000000) == 0) {\n        iVar4 = fcn.00426fef();\n    }\n    pcVar2 = _sym.imp.USER32.dll_SendMessageA;\n    if ((param_2 & 0xc) != 0) {\n        iVar5 = fcn.0042896a();\n        if ((((~param_2 & 8) == 0) || (iVar5 == 0)) || (iVar4 == param_1)) {\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 0, 0);\n        }\n        else {\n            *(param_1 + 0x25) = *(param_1 + 0x25) | 2;\n            (*pcVar2)(*(iVar4 + 0x1c), 0x86, 1, 0);\n            *(param_1 + 0x25) = *(param_1 + 0x25) & 0xfd;\n        }\n    }\n    uVar7 = 5;\n    iVar5 = (*_sym.imp.USER32.dll_GetDesktopWindow)(5);\n    pcVar1 = _sym.imp.USER32.dll_GetWindow;\n    while (iVar5 = (*pcVar1)(iVar5, uVar7),  iVar5 != 0) {\n        iVar6 = fcn.00437d02(*(iVar4 + 0x1c), iVar5);\n        if (iVar6 != 0) {\n            (*pcVar2)(iVar5, 0x36d, param_2, 0);\n        }\n        uVar7 = 2;\n    }\n    return;\n}\n",
        "token_count": 457
    },
    "0043dba5": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0043dba5(int32_t *param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *param_1;\n    if (iVar3 == 0) {\n        return 0;\n    }\n    if (iVar3 == param_2) {\n        *param_1 = *(param_1[1] + param_2);\n    }\n    else {\n        if (iVar3 == 0) {\n            return 0;\n        }\n        iVar1 = param_1[1];\n        do {\n            iVar2 = *(iVar1 + iVar3);\n            if (iVar2 == param_2) break;\n            iVar3 = iVar2;\n        } while (iVar2 != 0);\n        if (iVar3 == 0) {\n            return 0;\n        }\n        *(iVar1 + iVar3) = *(iVar1 + param_2);\n    }\n    return 1;\n}\n",
        "token_count": 222
    },
    "0043ddc8": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043ddc8(int32_t arg_8h)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t in_ECX;\n    uint lpCriticalSection;\n    \n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 0x1c);\n    for (iVar2 = *(in_ECX + 0x14); iVar2 != 0; iVar2 = *(iVar2 + 4)) {\n        if (arg_8h < *(iVar2 + 8)) {\n            puVar3 = *(*(iVar2 + 0xc) + arg_8h * 4);\n            if (puVar3 != NULL) {\n                (***puVar3)(1);\n            }\n            *(*(iVar2 + 0xc) + arg_8h * 4) = 0;\n        }\n    }\n    puVar1 = *(in_ECX + 0x10) + arg_8h * 8;\n    *puVar1 = *puVar1 & 0xfffffffe;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 0x1c);\n    return;\n}\n",
        "token_count": 267
    },
    "00443f0c": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nvoid fcn.00443f0c(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.0043d8de();\n    fcn.0043e309(0);\n    for (iVar1 = *(iVar1 + 0x24); iVar1 != 0; iVar1 = *(iVar1 + 0x1c)) {\n        fcn.00443eeb();\n    }\n    fcn.0043e379(0);\n    return;\n}\n",
        "token_count": 106
    },
    "00401cd4": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00401cd4(uint *arg_8h, int32_t *arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    uint32_t in_EAX;\n    uint uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    \n    if (arg_10h != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryW)(L\"CRYPT32.DLL\", 0x458160);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1);\n        in_EAX = (*pcVar2)(arg_10h, arg_14h, 1, 0, arg_ch, 0, 0);\n        if (in_EAX != 0) {\n            uVar1 = fcn.0041011c(*arg_ch + 1);\n            *arg_8h = uVar1;\n            uVar3 = (*pcVar2)(arg_10h, arg_14h, 1, uVar1, arg_ch, 0, 0);\n            return uVar3 & 0xffffff00 | uVar3 != 0;\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 280
    },
    "00407d20": {
        "rules": [
            "link function at runtime on Windows",
            "link many functions at runtime"
        ],
        "decompiled_code": "\nbool fcn.00407d20(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    bool bVar3;\n    \n    if (*0x45ff80 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"USER32\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((((iVar2 != 0) && (*0x45ff68 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x449110),  *0x45ff68 != 0))\n            && (*0x45ff6c = (*pcVar1)(iVar2, \"MonitorFromWindow\"),  *0x45ff6c != 0)) &&\n           (((*0x45ff70 = (*pcVar1)(iVar2, \"MonitorFromRect\"),  *0x45ff70 != 0 &&\n             (*0x45ff74 = (*pcVar1)(iVar2, \"MonitorFromPoint\"),  *0x45ff74 != 0)) &&\n            ((*0x45ff7c = (*pcVar1)(iVar2, \"EnumDisplayMonitors\"),  *0x45ff7c != 0 &&\n             (*0x45ff78 = (*pcVar1)(iVar2, \"GetMonitorInfoA\"),  *0x45ff78 != 0)))))) {\n            *0x45ff80 = 1;\n            return true;\n        }\n        *0x45ff68 = 0;\n        *0x45ff6c = 0;\n        *0x45ff70 = 0;\n        *0x45ff74 = 0;\n        *0x45ff78 = 0;\n        *0x45ff7c = 0;\n        *0x45ff80 = 1;\n        bVar3 = false;\n    }\n    else {\n        bVar3 = *0x45ff78 != 0;\n    }\n    return bVar3;\n}\n",
        "token_count": 433
    },
    "00428309": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint32_t fcn.00428309(void)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint32_t unaff_ESI;\n    uint unaff_EDI;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"COMCTL32.DLL\");\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"COMCTL32.DLL\");\n    uVar5 = uVar2;\n    if (uVar2 != 0) {\n        pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, \"InitCommonControlsEx\");\n        uVar5 = 0;\n        if (pcVar3 == NULL) {\n            if ((unaff_ESI & 0x3fc0) == unaff_ESI) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = 0x3fc0;\n            }\n        }\n        else {\n            iVar4 = (*pcVar3)(unaff_EDI);\n            if ((iVar4 != 0) && (uVar5 = unaff_ESI,  iVar1 == 0)) {\n                (*_sym.imp.COMCTL32.dll_InitCommonControls)();\n                uVar5 = unaff_ESI | 0x3fc0;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_FreeLibrary)(uVar2);\n    }\n    return uVar5;\n}\n",
        "token_count": 332
    },
    "0042b1c6": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0042b1c6(uint arg_8h, uint arg_ch, uint lpLibFileName)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t unaff_EBP;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    puVar1 = *(unaff_EBP + 0x10);\n    uVar4 = *(unaff_EBP + 8);\n    *puVar1 = 0;\n    fcn.0042b263(unaff_EBP + -0x10, uVar4);\n    uVar4 = *0x45c084;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + 0x10) = uVar4;\n    *(unaff_EBP + -4) = 1;\n    iVar2 = fcn.0042b2d2(*(unaff_EBP + -0x10), unaff_EBP + 0x10);\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(*(unaff_EBP + 0x10));\n        if (iVar2 != 0) {\n            pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"DllGetClassObject\");\n            if (pcVar3 == NULL) {\n                uVar4 = 0x800401f9;\n            }\n            else {\n                uVar4 = (*pcVar3)(*(unaff_EBP + 8), *(unaff_EBP + 0xc), puVar1);\n            }\n            goto code_r0x0042b23a;\n        }\n    }\n    uVar4 = 0x80040154;\ncode_r0x0042b23a:\n    *(unaff_EBP + -4) = 0;\n    fcn.0042a358();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0042a358();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar4;\n}\n",
        "token_count": 543
    },
    "0042ee20": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042ee20(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"GetLayout\");\n    if (pcVar2 == NULL) {\n        uVar1 = 0xffffffff;\n        (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n    }\n    else {\n        uVar1 = (*pcVar2)(*(param_1 + 4));\n    }\n    return uVar1;\n}\n",
        "token_count": 148
    },
    "0042ee56": {
        "rules": [
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042ee56(int32_t param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t unaff_EDI;\n    uint uVar3;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"GDI32.DLL\");\n    uVar3 = 0;\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar1, \"SetLayout\");\n    if (pcVar2 == NULL) {\n        if (unaff_EDI != 0) {\n            uVar3 = 0xffffffff;\n            (*_sym.imp.KERNEL32.dll_SetLastError)(0x78);\n        }\n    }\n    else {\n        uVar3 = (*pcVar2)(*(param_1 + 4), unaff_EDI);\n    }\n    return uVar3;\n}\n",
        "token_count": 190
    },
    "0041f3c0": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\nvoid fcn.0041f3c0(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    *0x460e94 = param_2;\n    *0x460e8c = param_1;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n    *0x460e90 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(4, 0x41f310, *0x46229c, uVar1);\n    return;\n}\n",
        "token_count": 116
    },
    "0043d633": {
        "rules": [
            "set application hook"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0043d633(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable._AFX_THREAD_STATE.0;\n    piVar1 = extraout_ECX[0x33];\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 != NULL) {\n        (**(*piVar1 + 0x58))();\n        if (extraout_ECX[0x33] != NULL) {\n            (**(*extraout_ECX[0x33] + 4))(1);\n        }\n    }\n    pcVar2 = _sym.imp.USER32.dll_UnhookWindowsHookEx;\n    if (extraout_ECX[0xc] != NULL) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(extraout_ECX[0xc]);\n    }\n    if (extraout_ECX[0xb] != NULL) {\n        (*pcVar2)(extraout_ECX[0xb]);\n    }\n    if (extraout_ECX[3] != NULL) {\n        fcn.00410f3f(extraout_ECX[3]);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 374
    },
    "0042630e": {
        "rules": [
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0042630e(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x38) == NULL) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(param_1 + 0x1c));\n        uVar2 = fcn.0042a78b(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), uVar2);\n        fcn.0042a763(0xffffffff);\n    }\n    else {\n        (**(**(param_1 + 0x38) + 0x88))(param_2);\n    }\n    return;\n}\n",
        "token_count": 178
    },
    "00428840": {
        "rules": [
            "get graphical window text"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00428840(int32_t param_1, uint param_2, uint param_3)\n\n{\n    if (*(param_1 + 0x38) == NULL) {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), param_2, param_3);\n    }\n    else {\n        (**(**(param_1 + 0x38) + 0x84))(param_2, param_3);\n    }\n    return;\n}\n",
        "token_count": 114
    },
    "00427ee7": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nuint fcn.00427ee7(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    \n    uVar3 = 0;\n    if (param_1 != 0) {\n        iVar2 = fcn.0043d8de();\n        uVar1 = *(iVar2 + 0xc);\n        iVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar1, param_1, 0xf0);\n        if (iVar2 != 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar1, iVar2);\n            if (iVar2 == 0) {\n                return 0;\n            }\n            uVar3 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar2);\n        }\n    }\n    uVar3 = fcn.00427f37(uVar3);\n    return uVar3;\n}\n",
        "token_count": 207
    },
    "004291bd": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid fcn.004291bd(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_LockResource)(param_1);\n    fcn.004291e0(uVar1, param_1, 0, param_2);\n    return;\n}\n",
        "token_count": 74
    },
    "0042920b": {
        "rules": [
            "extract resource via kernel32 functions"
        ],
        "decompiled_code": "\nvoid fcn.0042920b(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7)\n\n{\n    uint noname_2;\n    int32_t iVar1;\n    uint noname_4;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_0;\n    uint unaff_retaddr;\n    uint noname_3;\n    uint noname_5;\n    uint noname_6;\n    uint noname_7;\n    \n    noname_0 = 0;\n    iVar1 = fcn.0043d8de();\n    noname_2 = *(iVar1 + 0xc);\n    noname_7 = 5;\n    noname_5 = noname_2;\n    noname_6 = param_1;\n    noname_4 = (*_sym.imp.KERNEL32.dll_FindResourceA)();\n    noname_3 = noname_2;\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)();\n    if (iVar1 != 0) {\n        noname_0 = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n    }\n    fcn.0042924f(noname_0, unaff_EDI, noname_2, noname_3, noname_4, noname_5, noname_6, noname_7, unaff_EDI, unaff_ESI, \n                 unaff_EBX, unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7);\n    return;\n}\n",
        "token_count": 375
    },
    "0042b144": {
        "rules": [
            "move file"
        ],
        "decompiled_code": "\nvoid fcn.0042b144(uint param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_MoveFileA)(param_1, param_2);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0042a95c(uVar2);\n    }\n    return;\n}\n",
        "token_count": 105
    },
    "0042b166": {
        "rules": [
            "delete file"
        ],
        "decompiled_code": "\nvoid fcn.0042b166(uint param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileA)(param_1);\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(0);\n        fcn.0042a95c(uVar2);\n    }\n    return;\n}\n",
        "token_count": 96
    },
    "0043d181": {
        "rules": [
            "query or enumerate registry value",
            "read .ini file"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: hKey\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0043d181(uint arg_8h, uint lpAppName, uint lpKeyName, uint lpDefault)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpReturnedString;\n    uint var_18h;\n    uint var_14h;\n    uint hKey;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.0040fbf4();\n    fcn.00410700();\n    iVar2 = *(extraout_ECX + 0x7c);\n    *(unaff_EBP + -0x14) = 0;\n    if (iVar2 == 0) {\n        if (*(unaff_EBP + 0x14) == 0) {\n            *(unaff_EBP + 0x14) = 0x460038;\n        }\n        (*_sym.imp.KERNEL32.dll_GetPrivateProfileStringA)\n                  (*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), *(unaff_EBP + 0x14), unaff_EBP + -0x1018, 0x1000, \n                   *(extraout_ECX + 0x90));\n        iVar2 = unaff_EBP + -0x1018;\n    }\n    else {\n        iVar2 = fcn.0043d0cf(*(unaff_EBP + 0xc));\n        *(unaff_EBP + -0x10) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + 0xc) = *0x45c084;\n            pcVar1 = _sym.imp.ADVAPI32.dll_RegQueryValueExA;\n            *(unaff_EBP + -4) = 0;\n            iVar2 = (*pcVar1)(iVar2, *(unaff_EBP + 0x10), 0, unaff_EBP + -0x14, 0, unaff_EBP + -0x18);\n            if (iVar2 == 0) {\n                uVar3 = fcn.0042a714(*(unaff_EBP + -0x18), unaff_EBP + -0x18);\n                iVar2 = (*pcVar1)(*(unaff_EBP + -0x10), *(unaff_EBP + 0x10), 0, unaff_EBP + -0x14, uVar3);\n                fcn.0042a763(0xffffffff);\n            }\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(*(unaff_EBP + -0x10));\n            if (iVar2 == 0) {\n                fcn.0042a0cd(unaff_EBP + 0xc);\n            }\n            else {\n                fcn.0042a3c6(*(unaff_EBP + 0x14));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0042a358();\n            goto code_r0x0043d280;\n        }\n        iVar2 = *(unaff_EBP + 0x14);\n    }\n    fcn.0042a3c6(iVar2);\ncode_r0x0043d280:\n    uVar3 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 835
    }
}