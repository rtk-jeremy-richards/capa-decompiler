{
    "00401000": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00401000(void)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 16384 named .text\n    iVar1 = fcn.00403310(0x4104e4);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 92
    },
    "00401c30": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401c30(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar2 = (**0x41fa1c)(2, 0);\n    if (iVar2 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar4 = &var_128h;\n    for (iVar3 = 0x49; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    iVar3 = (**0x41fa20)(iVar2, &var_12ch);\n    pcVar1 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        if (iVar3 == 0) {\ncode_r0x00401cf4:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n            return var_4h;\n        }\n        iVar3 = (*pcVar1)(&var_108h, arg_8h);\n        if (iVar3 == 0) {\n            var_4h = var_124h;\n            goto code_r0x00401cf4;\n        }\n        iVar3 = (**0x41fa24)(iVar2, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 363
    },
    "00402d50": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nbool fcn.00402d50(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00402e70(0x80000002, 0x410954, 0x410994, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 == 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n    return iVar1 != -1;\n}\n",
        "token_count": 150
    },
    "00403120": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403297) overlaps instruction at (ram,0x00403295)\n// \n// WARNING: Removing unreachable block (ram,0x004031d2)\n// WARNING: Removing unreachable block (ram,0x0040324d)\n// WARNING: Removing unreachable block (ram,0x00403269)\n// WARNING: Removing unreachable block (ram,0x00403270)\n// WARNING: Removing unreachable block (ram,0x0040328f)\n// WARNING: Removing unreachable block (ram,0x004032a2)\n// WARNING: Removing unreachable block (ram,0x004032a4)\n// WARNING: Removing unreachable block (ram,0x004032cd)\n// WARNING: Removing unreachable block (ram,0x004032e9)\n// WARNING: Removing unreachable block (ram,0x004032f2)\n// WARNING: Removing unreachable block (ram,0x004032f9)\n// WARNING: Removing unreachable block (ram,0x004032db)\n// WARNING: Removing unreachable block (ram,0x004032dd)\n// WARNING: Removing unreachable block (ram,0x00403297)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403120(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    char unaff_BL;\n    uint var_4h;\n    \n    iVar1 = fcn.00401c30(0x410550);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)(0x40, 0, iVar1);\n    if (iVar1 != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n        iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n        if (iVar3 != 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            *0x403247 = *0x403247 + unaff_BL;\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 520
    },
    "00403200": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403297) overlaps instruction at (ram,0x00403295)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403200(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint8_t *puVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint var_4h;\n    \n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    iVar3 = arg_8h_00;\n    iVar2 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    if (iVar2 != 0) {\n        if (*0x41f9f4 != 0) {\n            iVar3 = fcn.00403120(arg_8h_00, iVar3, arg_ch);\n            *0x41f9f4 = iVar3 == 0;\n        }\n        while( true ) {\n            uVar4 = fcn.00403be0();\n            if ((0xfffffff7 < &stack0xffffffb4 || *0x10 == 0x46) || (0xfffffff7 >= &stack0xffffffb4 && *0x10 != 0x46))\n            break;\n            if (!SCARRY4(&stack0xffffffb4, 8)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            puVar1 = (uVar4 & 0xffffff00 | uVar4 - 9) - 0x5d;\n            *puVar1 = *puVar1 << 4 | *puVar1 >> 4;\n            *(arg_8h_00 + 0x50) = *(arg_8h_00 + 0x50) + ((uVar4 & 0xffffff00) >> 8);\n        }\n        if (*0x41f9f4 == 0) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)();\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 510
    },
    "004038c0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403970) overlaps instruction at (ram,0x0040396e)\n// \n\nuint32_t fcn.004038c0(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uchar *arg_10h;\n    int32_t extraout_ECX;\n    uchar *unaff_EBX;\n    uint *puVar5;\n    uchar *puVar6;\n    uint16_t unaff_DI;\n    uint *puVar7;\n    bool bVar8;\n    char cVar9;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar10;\n    char cVar11;\n    ulong uVar12;\n    unkbyte6 Var13;\n    uint uStack184;\n    uint uStack180;\n    uint uStack176;\n    uint uStack172;\n    uint uStack168;\n    uint uStack164;\n    uint uStack160;\n    uint uStack156;\n    uchar uStack132;\n    uint uStack131;\n    uint auStack111 [2];\n    uchar uStack100;\n    uint auStack99 [7];\n    uchar uStack68;\n    uint auStack67 [7];\n    uchar uStack36;\n    uint auStack35 [6];\n    uint uStack8;\n    \n    bVar10 = false;\n    puVar7 = &stack0xfffffffc;\n    puVar6 = &stack0xfffffffc;\n    bVar8 = (POPCOUNT(&stack0xffffff7c & 0xff) & 1U) != 0;\n    if ((bVar8) && (!bVar8)) {\n        puVar5 = &stack0xffffff74;\n        cVar9 = '\\x1e';\n        do {\n            puVar7 = puVar7 + -1;\n            puVar5 = puVar5 + -1;\n            *puVar5 = *puVar7;\n            cVar9 = cVar9 + -1;\n        } while ('\\0' < cVar9);\n        uVar3 = in(0x78);\n        return uVar3;\n    }\n    Var13 = fcn.004010e0();\n    if (Var13 == 0) {\n        fcn.00403a60();\n        return 0;\n    }\n    bVar8 = (unaff_DI & ((Var13 >> 0x20) - Var13) + 0x1abU) == 0;\n    fcn.00403450();\n    if ((!bVar8) && (bVar8)) {\n        uVar3 = (in_IF & 1) * 0x200;\n        bVar10 = (uVar3 & 0x400) != 0;\n        in_IF = ((uVar3 | (in_TF & 1) * 0x100) & 0x200) != 0;\n    }\n    iVar4 = fcn.00401c30(0x410548);\n    cVar11 = SBORROW4(iVar4, -1);\n    cVar9 = iVar4 + 1 < 0;\n    if (iVar4 != -1) {\n        iVar4 = fcn.00401c30(0x41053c);\n        if (iVar4 == -1) {\n            fcn.00403a60();\n        }\n        return 0;\n    }\n    fcn.00402520();\n    if ((cVar11 == cVar9) && (cVar11 != cVar9)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar4 = fcn.00401000();\n    bVar8 = iVar4 == 0;\n    if (!bVar8) {\n        return 0;\n    }\n    if ((!bVar8) && (bVar8)) {\n        bVar10 = ((bVar10 * 0x400 | (in_IF & 1) * 0x200) & 0x400) != 0;\n    }\n    uStack36 = 0;\n    uStack132 = 0;\n    puVar7 = &stack0xffffffdd;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + bVar10 * -2 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + bVar10 * -4 + 2) = 0;\n    uStack100 = 0;\n    puVar7 = &stack0xffffff7d;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + bVar10 * -2 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + bVar10 * -4 + 2) = 0;\n    uStack68 = 0;\n    puVar7 = &stack0xffffff9d;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + bVar10 * -2 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + bVar10 * -4 + 2) = 0;\n    puVar7 = &stack0xffffffbd;\n    for (iVar4 = 7; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + bVar10 * -2 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + bVar10 * -4 + 2) = 0;\n    uStack156 = 0x4039eb;\n    iVar4 = fcn.00403760(&stack0xffffff7c, &stack0xffffff9c, &stack0xffffffdc, &stack0xffffffbc);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    uVar12 = fcn.00403d50();\n    arg_10h = uVar12 >> 0x20;\n    iVar4 = uVar12;\n    if (iVar4 == 0) {\n        return 0;\n    }\n    if ((iVar4 < 0) || (iVar4 >= 0)) {\n        unaff_EBX = &stack0xffffffbc;\n        arg_10h = &stack0xffffffdc;\n    }\n    else {\n        puVar6 = &stack0xfffffffd;\n        if (extraout_ECX != 1 && puVar6 != NULL) {\n            puVar7 = &stack0xffffff91;\n            for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + bVar10 * -2 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + bVar10 * -4 + 2) = 0;\n            fcn.00402910();\n            fcn.00402f30(&stack0xffffff80, 5);\n            pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n            (*_sym.imp.MSVCRT.dll_sprintf)();\n            (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n            pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n            uStack156 = 1;\n            uStack160 = 0x41f9f8;\n            uStack164 = 0x41083c;\n            uStack168 = 0x80000000;\n            uStack172 = 0x403af7;\n            (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n            uStack172 = 0x4b;\n            uStack176 = 0x410870;\n            uStack180 = 1;\n            uStack184 = 0x41f9f8;\n            (*pcVar2)(0x80000000, &stack0xffffff70);\n            (*pcVar1)(&stack0xffffff58, 0x4108bc, &stack0xffffff48);\n            uVar3 = (*pcVar2)(0x80000000, &stack0xffffff58, 0x4108f8, 1, 0x410900, 0x14);\n            return uVar3;\n        }\n    }\n    uStack156 = 0x403a43;\n    iVar4 = fcn.00404160(puVar6 + -0x80, puVar6 + -0x60, arg_10h, unaff_EBX);\n    return iVar4 != 0;\n}\n",
        "token_count": 1954
    },
    "00403be0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403cdc) overlaps instruction at (ram,0x00403cdb)\n// \n// WARNING: Removing unreachable block (ram,0x00403cce)\n// WARNING: Removing unreachable block (ram,0x00403cd8)\n// WARNING: Removing unreachable block (ram,0x00403cdc)\n\nuint fcn.00403be0(uint param_1, char *param_2)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    uchar *puVar3;\n    char cVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint *puVar9;\n    uint *puVar10;\n    char *pcVar11;\n    bool bVar12;\n    char *pcStack580;\n    uint uStack576;\n    char cStack560;\n    uint uStack559;\n    uchar uStack300;\n    uint uStack299;\n    uchar auStack40 [4];\n    uchar auStack36 [8];\n    uchar auStack28 [8];\n    uchar auStack20 [16];\n    \n    cStack560 = '\\0';\n    uStack300 = '\\0';\n    puVar9 = &uStack559;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    puVar9 = &uStack300 + 1;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    pcStack580 = &cStack560;\n    uStack576 = 0x104;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar7 = 0xffffffff;\n    pcVar5 = &cStack560;\n    do {\n        pcVar11 = pcVar5;\n        if (uVar7 == 0) break;\n        uVar7 = uVar7 - 1;\n        pcVar11 = pcVar5 + 1;\n        cVar2 = *pcVar5;\n        pcVar5 = pcVar11;\n    } while (cVar2 != '\\0');\n    uVar7 = ~uVar7;\n    puVar9 = pcVar11 + -uVar7;\n    puVar10 = &uStack300;\n    for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *puVar10 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    uVar8 = uVar7 & 3;\n    bVar12 = uVar8 == 0;\n    for (; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *puVar10 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    if ((bVar12) || (!bVar12)) {\n        puVar10 = 0x41051c;\n        uVar8 = 0xffffffff;\n        uVar7 = 0;\n    }\n    cVar2 = *param_2;\n    puVar1 = puVar10 + -0x41;\n    puVar3 = *puVar1;\n    *puVar1 = *puVar1 - &pcStack580;\n    cVar4 = (uVar7 + -5) - (puVar3 < &pcStack580);\n    uVar7 = (uVar8 & 0xffff0000 | CONCAT11((uVar8 >> 8) - cVar2, uVar8)) + 1;\n    param_2[-0x3fcc0037] = param_2[-0x3fcc0037] + cVar4;\n    do {\n        puVar9 = puVar10;\n        if (uVar7 == 0) break;\n        uVar7 = uVar7 - 1;\n        puVar9 = puVar10 + 1;\n        cVar2 = *puVar10;\n        puVar10 = puVar9;\n    } while (cVar4 != cVar2);\n    uVar7 = ~uVar7;\n    iVar6 = -1;\n    pcVar5 = &uStack300;\n    do {\n        pcVar11 = pcVar5;\n        if (iVar6 == 0) break;\n        iVar6 = iVar6 + -1;\n        pcVar11 = pcVar5 + 1;\n        cVar2 = *pcVar5;\n        pcVar5 = pcVar11;\n    } while (cVar4 != cVar2);\n    puVar9 = puVar9 - uVar7;\n    puVar10 = pcVar11 + -1;\n    for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *puVar10 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar10 = *puVar9;\n        puVar9 = puVar9 + 1;\n        puVar10 = puVar10 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&uStack300, 0, auStack40);\n    pcVar5 = param_2;\n    if ((param_2 == 0xffffffff) && (pcVar5 = fcn.00403310(param_1),  pcVar5 == 0xffffffff)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(pcVar5, auStack36, auStack28, auStack20);\n    if (param_2 == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(pcVar5);\n    }\n    return 1;\n}\n",
        "token_count": 1430
    },
    "00404160": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004043fc) overlaps instruction at (ram,0x004043f3)\n// \n\nuchar * __cdecl fcn.00404160(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint8_t **ppuVar1;\n    uint *puVar2;\n    uint uVar3;\n    uchar *puVar4;\n    uchar *puVar5;\n    uchar *puVar6;\n    int32_t iVar7;\n    uint extraout_ECX;\n    int32_t extraout_EDX;\n    uint8_t *unaff_EBX;\n    uint *puVar8;\n    uchar uVar9;\n    uint8_t in_AF;\n    uchar uVar10;\n    bool bVar11;\n    ulong uVar12;\n    unkuint3 Var13;\n    uint32_t noname_2;\n    uint arg_14h_00;\n    uchar lpBuffer;\n    uint var_213h;\n    uchar s;\n    uint var_10fh;\n    uchar *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    puVar8 = &var_213h;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    s = 0;\n    puVar8 = &var_10fh;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    var_ch = 0x1;\n    puVar2 = puVar8 + 3;\n    *(puVar8 + 2) = 0;\n    uVar9 = 0;\n    uVar10 = (puVar2 | 0x2fff) - unaff_EBX == 0x7174;\n    Var13 = &lpBuffer;\n    arg_14h_00 = CONCAT31(0x104, &lpBuffer >> 0x18);\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    puVar5 = (*_sym.imp.MSVCRT.dll_sprintf)();\n    iVar7 = arg_8h;\n    if ((!uVar10) && (uVar10)) {\n        unaff_EBX = unaff_EBX + 1;\n        if (uVar9 || unaff_EBX == NULL) {\n            return puVar5;\n        }\n        in_AF = 9 < (puVar5 & 0xf) | in_AF;\n        ppuVar1 = (puVar5 & 0xffff0000 | CONCAT11((puVar5 >> 8) + in_AF, puVar5 + in_AF * '\\x06') & 0xff0f) + 0x2a;\n        uVar9 = *ppuVar1 < unaff_EBX;\n        *ppuVar1 = *ppuVar1 + -unaff_EBX;\n        iVar7 = arg_8h + 1;\n    }\n    fcn.00402c00(&var_4h, &var_8h);\n    if ((!uVar9) && (uVar9)) {\n        unaff_EBX = unaff_EBX + uVar9 + *(unaff_EBX + extraout_EDX * 4 + 0x69);\n    }\n    iVar7 = fcn.00401d10(iVar7, arg_ch, arg_10h, arg_14h, var_4h, var_8h);\n    if (iVar7 == 0) {\n        return NULL;\n    }\n    bVar11 = puVar2 == 1;\n    noname_2 = Var13 << 8;\n    uVar12 = fcn.00402d50();\n    iVar7 = uVar12;\n    *0x41f9f4 = iVar7;\n    if ((!bVar11) && (noname_2 = noname_2 & 0xffffff00 | puVar2 >> 0x18,  bVar11)) {\n        uVar3 = in(uVar12 >> 0x20);\n        *puVar2 = uVar3;\n        if (&stack0xfffffdd4 < 1) goto code_r0x004042f7;\n        unaff_EBX[0x558bf84d] = unaff_EBX[0x558bf84d] ^ extraout_ECX;\n        var_8h = extraout_ECX;\n        var_4h = uVar12 >> 0x20;\n    }\n    iVar7 = fcn.00403200(&s, var_4h, var_8h);\n    if (iVar7 == 0) {\n        return NULL;\n    }\n    fcn.00404450();\n    iVar7 = fcn.00401c30(0x41053c);\ncode_r0x004042f7:\n    if ((iVar7 != -1) || (iVar7 = fcn.00401c30(0x410530),  iVar7 != -1)) {\n        iVar7 = fcn.00401530();\n        if (iVar7 != 0) {\n            fcn.00401180();\n            fcn.00402e60();\n            return 0x1;\n        }\n        if (*0x41f9f4 == 0) {\n            return NULL;\n        }\n    }\n    puVar6 = fcn.00401b10(arg_8h, &s, noname_2, arg_14h_00);\n    puVar5 = var_ch;\n    if (puVar6 == NULL) {\n        puVar5 = NULL;\n    }\n    if ((puVar5 != NULL) && (puVar6 = fcn.00402e00(arg_8h),  puVar6 == NULL)) {\n        puVar5 = puVar6;\n        var_ch = puVar6;\n    }\n    bVar11 = false;\n    if (puVar5 == NULL) {\n        puVar6 = fcn.00402f90(arg_8h, 0);\n        bVar11 = 0xfffffff7 < &stack0xfffffdcb;\n        puVar5 = puVar6;\n        var_ch = puVar6;\n    }\n    if ((!bVar11) && (bVar11)) {\n        *(puVar5 + 0x43d1773a) = *(puVar5 + 0x43d1773a) ^ 0x8527e95e;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    puVar4 = puVar5;\n    if (puVar5 != NULL) {\n        puVar6 = fcn.00402e60();\n        puVar4 = &stack0xfffffdd3;\n    }\n    if ((puVar4 < 0) || (puVar4 >= 0)) {\n        (*_sym.imp.KERNEL32.dll_Sleep)();\n    }\n    else {\n        puVar5 = puVar6 + -0x1bf31dd6;\n        *unaff_EBX = *unaff_EBX & 0xc3;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)();\n    return puVar5;\n}\n",
        "token_count": 1655
    },
    "004044f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404550) overlaps instruction at (ram,0x0040454f)\n// \n// WARNING: Removing unreachable block (ram,0x004045bb)\n\nuint __cdecl fcn.004044f0(uint arg_8h)\n\n{\n    uchar uVar1;\n    uchar *unaff_EDI;\n    bool bVar2;\n    unkbyte6 Var3;\n    \n    Var3 = (*_sym.imp.MSVCRT.dll__access)(arg_8h);\n    bVar2 = SBORROW4(Var3, -1);\n    if (Var3 != -1) {\n        if ((bVar2) || (!bVar2)) {\n            return 0;\n        }\n        uVar1 = in(Var3 >> 0x20);\n        *unaff_EDI = uVar1;\n    }\n    return 1;\n}\n",
        "token_count": 192
    },
    "00401050": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401050(uint filename, uint mode, uint ptr, uint nitems)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(filename, mode);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.MSVCRT.dll_fwrite)(ptr, 1, nitems, iVar1);\n    (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n    (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n    return 1;\n}\n",
        "token_count": 146
    },
    "004010e0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nint64_t fcn.004010e0(void)\n\n{\n    uint32_t extraout_EDX;\n    bool bVar1;\n    uint var_94h;\n    int32_t var_90h;\n    int32_t var_8ch;\n    uint uStack140;\n    \n    bVar1 = SBORROW4(&stack0xfffffffc, 0x94);\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (!bVar1) {\n        if (bVar1) {\n            return CONCAT44(var_90h, uStack140);\n        }\n    }\n    if (var_90h == 5) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return CONCAT44(extraout_EDX, 1);\n    }\n    return extraout_EDX << 0x20;\n}\n",
        "token_count": 203
    },
    "004016b0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.004016b0(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00402e70(0x80000002, 0x4106d8, 0x410724, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 134
    },
    "00401e70": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040241c) overlaps instruction at (ram,0x00402418)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid __fastcall fcn.00401e70(uchar *param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t *piVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint32_t uVar6;\n    uint16_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint8_t extraout_CL;\n    ushort extraout_CX;\n    uint extraout_ECX;\n    uint32_t extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint extraout_ECX_03;\n    uint extraout_ECX_04;\n    uint extraout_ECX_05;\n    uint extraout_ECX_06;\n    int32_t extraout_ECX_07;\n    char extraout_CH;\n    uint extraout_ECX_08;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    int32_t extraout_EDX;\n    char *pcVar10;\n    uint32_t unaff_EBX;\n    uint *puVar11;\n    uint *unaff_ESI;\n    uint *puVar12;\n    uint *unaff_EDI;\n    ushort in_ES;\n    ushort in_CS;\n    bool in_CF;\n    uint8_t uVar13;\n    bool bVar14;\n    uint8_t in_AF;\n    bool in_ZF;\n    uchar uVar15;\n    char cVar16;\n    uint8_t uVar17;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    bool bVar18;\n    bool in_OF;\n    char cVar19;\n    uint8_t uVar20;\n    uint8_t uVar21;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    float10 in_ST0;\n    ulong uVar22;\n    uint *puVar23;\n    uint in_stack_ffffffd4;\n    uint *puVar24;\n    uchar in_stack_ffffffd8;\n    ushort in_stack_ffffffd9;\n    ushort uVar25;\n    uchar in_stack_ffffffdb;\n    uchar uVar26;\n    uint uVar27;\n    unkbyte3 Var28;\n    uint uVar29;\n    uchar in_stack_ffffffe8;\n    uchar in_stack_ffffffe9;\n    ushort in_stack_ffffffea;\n    uint in_stack_ffffffec;\n    uchar uVar30;\n    \n    bVar18 = false;\n    if ((in_OF) || (!in_OF)) {\n        in_stack_ffffffec = 0x4104f8;\n        in_stack_ffffffe8 = 0xd;\n        in_stack_ffffffe9 = 0;\n        in_stack_ffffffea = 0;\ncode_r0x00401e8c:\n        uVar8 = CONCAT11(*param_1, unaff_EBX);\n        unaff_EBX = unaff_EBX & 0xffff0000 | uVar8;\n        pcVar10 = param_2 + 0xd;\n        *pcVar10 = *pcVar10 + (param_1 >> 8);\n        bVar14 = (POPCOUNT(*pcVar10) & 1U) == 0;\n        fcn.00403350(0x406010, 0x56, CONCAT22(in_stack_ffffffea, CONCAT11(in_stack_ffffffe9, in_stack_ffffffe8)), \n                     in_stack_ffffffec);\n        if ((bVar14) || (puVar23 = unaff_EDI,  !bVar14)) {\n            puVar23 = 0x12;\n            in_stack_ffffffd8 = 4;\n            in_stack_ffffffd9 = 0x4105;\n            in_stack_ffffffdb = 0;\n            in_stack_ffffffd4 = 0xd;\n        }\n        unaff_ESI = 0x34a96cf4;\n        fcn.00403350(0x406010, in_stack_ffffffd4, \n                     CONCAT13(in_stack_ffffffdb, CONCAT21(in_stack_ffffffd9, in_stack_ffffffd8)), puVar23);\n        bVar14 = (uVar8 >> 8) + '0' < '\\0';\n        in_ST0 = fcn.00403350(0x406010, 0xd, 0x410518, 4);\n        if ((!bVar14) && (bVar14)) goto code_r0x00401f02;\n    }\n    else {\n        puVar23 = unaff_EDI + 1;\n        uVar15 = in(param_2);\n        *unaff_EDI = uVar15;\n        unaff_EBX = CONCAT31(unaff_EBX >> 8, 0xbc);\n        unaff_EDI = puVar23;\n        if (in_CF || in_ZF) goto code_r0x00401e8c;\ncode_r0x00401f02:\n        *(unaff_EDI + 7) = in_ST0;\n        unaff_EDI = unaff_EDI + 5;\n        unaff_ESI = unaff_ESI + 5;\n    }\n    fcn.00403350(0x406010, 0xd, 0x41051c, 0xc);\n    fcn.00403350(0x406010, 0xd, 0x410528, 7);\n    uVar8 = fcn.00403350(0x406010, 0xd, 0x410530, 0xb);\n    cVar19 = '\\0';\n    cVar16 = (unaff_EDI & uVar8) < 0;\n    bVar14 = (unaff_EDI & uVar8) == 0;\n    uVar15 = 0x3c;\n    uVar26 = 5;\n    uVar25 = 0x41;\n    uVar29 = 0xd;\n    uVar27 = 0x406010;\n    puVar23 = unaff_EDI;\n    puVar24 = unaff_ESI;\n    iVar9 = fcn.00403350(0x406010, 0xd, 0x41053c, 0xc);\n    if ((bVar14 || cVar19 != cVar16) || (!bVar14 && cVar19 == cVar16)) {\n        puVar24 = 0xd;\n    }\n    *(iVar9 + 0x6a39da56) = *(iVar9 + 0x6a39da56) ^ extraout_CX;\n    *(iVar9 + 0x48) = *(iVar9 + 0x48) | extraout_CX >> 8;\n    bVar14 = SCARRY4(iVar9, 0xd6a0041);\n    fcn.00403350(0x406010, uVar27, uVar29, CONCAT22(uVar25, CONCAT11(uVar26, uVar15)));\n    if (!bVar14) {\n        uVar15 = extraout_ECX;\n        uVar25 = extraout_ECX >> 8;\n        uVar26 = extraout_ECX >> 0x18;\n        if (bVar14) goto code_r0x00401fd1;\n    }\n    uVar15 = 0xd;\n    uVar25 = 0;\n    uVar26 = 0;\n    puVar24 = 0x410550;\n    puVar23 = 0xd;\ncode_r0x00401fd1:\n    puVar12 = unaff_ESI + 1;\n    *unaff_EDI = *unaff_ESI;\n    fcn.00403350(0x406010, puVar23, puVar24, CONCAT13(uVar26, CONCAT21(uVar25, uVar15)));\n    fcn.00403350(0x406010, 0xd, 0x410560, 0x18);\n    fcn.00403350(0x406010, 0xd, 0x410578, 0x25);\n    fcn.00403350(0x406010, 0xd, 0x4105a0, 10);\n    fcn.00403350(0x406010, 0xd, 0x4105ac, 0xc);\n    fcn.00403350(0x406010, 0xd, 0x4105b8, 0xd);\n    fcn.00403350(0x406010, 0xd, 0x4105c8, 6);\n    fcn.00403350(0x406010, 0xd, 0x4105d0, 5);\n    fcn.00403350(0x406010, 0xd, 0x4105d8, 0xd);\n    fcn.00403350(0x406010, 0xd, 0x4105e8, 0x19);\n    uVar13 = extraout_CL < extraout_DL;\n    uVar20 = SBORROW1(extraout_CL, '\\x01');\n    uVar17 = extraout_CL - 1 < '\\0';\n    uVar15 = extraout_CL == 1;\n    uVar25 = 0xf;\n    uVar26 = 0;\n    uVar30 = 0;\n    while( true ) {\n        fcn.00403350(0x406010, 0xd, 0x410604, CONCAT13(uVar30, CONCAT12(uVar26, uVar25)));\n        if ((!uVar15) && (uVar15)) {\n            uVar8 = (uVar20 & 1) * 0x800 | bVar18 * 0x400;\n            uVar3 = uVar8 | (in_IF & 1) * 0x200;\n            uVar4 = uVar3 | (in_TF & 1) * 0x100;\n            uVar5 = uVar4 | (uVar17 & 1) * 0x80;\n            uVar6 = (uVar15 & 1) * 0x40;\n            in_NT = ((in_NT & 1) * 0x4000 & 0x4000) != 0;\n            uVar20 = (uVar8 & 0x800) != 0;\n            bVar18 = (uVar3 & 0x400) != 0;\n            in_IF = (uVar4 & 0x200) != 0;\n            in_TF = (uVar5 & 0x100) != 0;\n            uVar17 = ((uVar5 | uVar6) & 0x80) != 0;\n            uVar15 = (uVar6 & 0x40) != 0;\n            in_AF = ((in_AF & 1) * '\\x10' & 0x10) != 0;\n            uVar13 = (uVar13 & 1) != 0;\n            in_ID = (((in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000) & 0x200000) != 0;\n            in_AC = ((in_AC & 1) * 0x40000 & 0x40000) != 0;\n            in_VIP = 0;\n            in_VIF = 0;\n        }\n        uVar25 = 0x6010;\n        uVar26 = 0x40;\n        uVar30 = 0;\n        fcn.00403350(0x406010, 0xd, 0x410614, 0xe);\n        if ((uVar13 || uVar15) ||\n           (puVar12 = puVar12 & 0xffff0000 | puVar12 & 0xff | (puVar12 >> 8) << 8,  !uVar13 && !uVar15)) break;\n        if (!uVar20) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.00403350(0x406010, 0xd, 0x410624, 0xd);\n    fcn.00403350(0x406010, 0xd, 0x410634, 0xc);\n    fcn.00403350(0x406010, 0xd, 0x410640, 0xf);\n    Var28 = SUB43(puVar12, 0);\n    uVar15 = puVar12 >> 0x18;\n    bVar14 = false;\n    fcn.00403350(0x406010, 0xd, 0x410650, 0xb);\n    uVar8 = extraout_ECX_00;\n    if ((bVar14) || (uVar8 = extraout_ECX_00 & 0xffff,  !bVar14)) {\n        Var28 = 0xd;\n        uVar15 = 0;\n    }\n    puVar23 = CONCAT13(uVar15, Var28);\n    *puVar23 = in_ES;\n    *(extraout_EDX + 0xd) = *(extraout_EDX + 0xd) + (uVar8 + 1 >> 8);\n    puVar23[-1] = 0x406010;\n    puVar23[-2] = 0x40223d;\n    uVar22 = fcn.00403350(puVar23[-1], *puVar23, puVar23[1], puVar23[2]);\n    puVar23[6] = uVar22;\n    puVar23[5] = uVar22 >> 0x20;\n    puVar23[4] = unaff_EDI + 1 & 0xff000000 | unaff_EDI + 1;\n    iVar9 = puVar23[4];\n    puVar23[6] = 0xb;\n    puVar23[5] = 0x410668;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x40225b;\n    fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    puVar23[6] = unaff_EBX + 1;\n    uVar29 = puVar23[6];\n    puVar23[6] = 10;\n    puVar23[5] = 0x410674;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x402287;\n    uVar27 = fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    puVar23[6] = uVar27;\n    puVar23[6] = 0xc;\n    puVar23[5] = 0x410680;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x4022b5;\n    fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    puVar23[6] = extraout_ECX_01;\n    puVar23[6] = 0xe;\n    puVar23[5] = 0x41068c;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x4022d8;\n    uVar27 = fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    puVar23[6] = uVar27;\n    puVar23[5] = extraout_ECX_02;\n    bVar14 = false;\n    puVar23[6] = 0x11;\n    puVar23[5] = 0x41069c;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x402308;\n    fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    if (!bVar14) {\n        puVar23[2] = puVar12;\n        puVar12 = puVar23[2];\n        if (bVar14) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    puVar23[2] = 0x13;\n    puVar23[1] = 0x4106b0;\n    *puVar23 = 0xd;\n    puVar23[-1] = 0x406010;\n    puVar23[-2] = 0x402333;\n    fcn.00403350(puVar23[-1], *puVar23, puVar23[1], puVar23[2]);\n    puVar23[6] = extraout_ECX_03;\n    *(puVar23 + 0x16) = extraout_DX;\n    puVar23[6] = 0x14;\n    puVar23[5] = 0x4106c4;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x40235d;\n    uVar27 = fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    puVar23[6] = uVar27;\n    cVar19 = '\\0';\n    uVar7 = uVar27 ^ uVar29;\n    cVar16 = uVar7 < 0;\n    bVar14 = uVar7 == 0;\n    puVar23[6] = 0x33;\n    puVar23[5] = 0x4106d8;\n    puVar23[4] = 0xd;\n    puVar23[3] = 0x406010;\n    puVar23[2] = 0x402378;\n    fcn.00403350(puVar23[3], puVar23[4], puVar23[5], puVar23[6]);\n    puVar24 = puVar23 + 3;\n    if (!bVar14 && cVar19 == cVar16) {\n        *(puVar23 + 10) = puVar12;\n        puVar12 = puVar12 & 0xffff0000 | *(puVar23 + 10);\n        puVar24 = puVar23 + 3;\n    }\n    do {\n        puVar24[-1] = 10;\n        puVar24[-2] = 0x41070c;\n        puVar24[-3] = 0xd;\n        puVar24[-4] = 0x406010;\n        puVar24[-5] = 0x40239b;\n        fcn.00403350(puVar24[-4], puVar24[-3], puVar24[-2], puVar24[-1]);\n        puVar24[3] = extraout_ECX_04;\n        puVar24[3] = 4;\n        puVar24[2] = 0x410718;\n        puVar24[1] = 0xd;\n        *puVar24 = 0x406010;\n        puVar24[-1] = 0x4023bc;\n        fcn.00403350(*puVar24, puVar24[1], puVar24[2], puVar24[3]);\n        puVar24[3] = extraout_ECX_05;\n        *(puVar24 + 10) = extraout_DX_00;\n        puVar24[3] = 5;\n        puVar24[2] = 0x41071c;\n        puVar24[1] = 0xd;\n        *puVar24 = 0x406010;\n        puVar24[-1] = 0x4023e6;\n        fcn.00403350(*puVar24, puVar24[1], puVar24[2], puVar24[3]);\n        puVar24[3] = extraout_ECX_06;\n        puVar24[3] = 6;\n        puVar24[2] = 0x410724;\n        puVar24[1] = 0xd;\n        *puVar24 = 0x406010;\n        puVar24[-1] = 0x402407;\n        fcn.00403350(*puVar24, puVar24[1], puVar24[2], puVar24[3]);\n        puVar24[3] = uVar29;\n        uVar13 = 0;\n        bVar14 = (POPCOUNT(uVar29 & 0x4d) & 1U) == 0;\n        uVar29 = puVar24[3];\n        puVar24[3] = 0xc;\n        puVar24[2] = 0x41072c;\n        puVar24[1] = 0xd;\n        *puVar24 = 0x406010;\n        puVar24[-1] = 0x402422;\n        uVar22 = fcn.00403350(*puVar24, puVar24[1], puVar24[2], puVar24[3]);\n        pcVar10 = uVar22 >> 0x20;\n        uVar27 = uVar22;\n        if (bVar14) {\ncode_r0x00402439:\n            puVar24[-1] = 0xc;\n            puVar24[-2] = 0x410738;\n            puVar11 = puVar24 + -3;\n            puVar24[-3] = 0xd;\n        }\n        else {\n            *(puVar24 + -2) = puVar12;\n            puVar23 = puVar12 & 0xffff0000 | *(puVar24 + -2);\n            puVar12 = puVar23;\n            if (!bVar14) goto code_r0x00402439;\n            puVar12 = puVar23 + bVar18 * -2 + 1;\n            out(*puVar23, uVar22 >> 0x20);\n            uVar13 = in_AF;\n            do {\n                cVar16 = uVar27 >> 8;\n                uVar13 = 9 < (uVar27 & 0xf) | uVar13;\n                puVar11 = *puVar24 + 4;\n                puVar24 = *puVar24 + 4;\n                uVar27 = CONCAT31(CONCAT21(uVar27 >> 0x10, cVar16 - uVar13), -uVar13);\n                in_AF = uVar13;\n            } while (uVar13 || cVar16 == *pcVar10);\n        }\n        piVar2 = iVar9 + pcVar10 * 2;\n        *piVar2 = (*piVar2 + 0x7b) - uVar13;\n        *(extraout_ECX_07 + 0x6a) = uVar27;\n        puVar1 = pcVar10 + 0xd;\n        uVar13 = extraout_ECX_07 + 1 >> 8;\n        uVar17 = CARRY1(*puVar1, uVar13);\n        uVar21 = SCARRY1(*puVar1, uVar13);\n        *puVar1 = *puVar1 + uVar13;\n        uVar20 = *puVar1 < '\\0';\n        bVar14 = *puVar1 == 0;\n        uVar13 = (POPCOUNT(*puVar1) & 1U) == 0;\n        puVar24 = puVar11 + -1;\n        puVar11[-1] = 0x406010;\n        puVar11[-2] = 0x40244c;\n        uVar8 = fcn.00403350(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n        if (uVar17 || bVar14) {\ncode_r0x0040246e:\n            puVar11[-2] = 0x2a;\n            puVar11[-3] = 0x410770;\n            puVar11[-4] = 0xd;\n            puVar11[-5] = 0x406010;\n            puVar11[-6] = 0x402481;\n            fcn.00403350(puVar11[-5], puVar11[-4], puVar11[-3], puVar11[-2]);\n            if ((!bVar14) && (puVar11[-6] = extraout_ECX_08,  bVar14)) {\n                puVar11[-6] = (in_NT & 1) * 0x4000 | (uVar21 & 1) * 0x800 | bVar18 * 0x400 | (in_IF & 1) * 0x200 |\n                              (in_TF & 1) * 0x100 | (uVar20 & 1) * 0x80 | (bVar14 & 1) * 0x40 | (in_AF & 1) * 0x10 |\n                              (uVar13 & 1) * 4 | uVar17 & 1 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 |\n                              (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n            }\n            puVar11[-6] = 0xb;\n            puVar11[-7] = 0x41079c;\n            puVar11[-8] = 0xd;\n            puVar11[-9] = 0x406010;\n            puVar11[-10] = 0x4024a0;\n            fcn.00403350(puVar11[-9], puVar11[-8], puVar11[-7], puVar11[-6]);\n            puVar11[6] = 0x41;\n            puVar11[5] = 0x4107f8;\n            puVar11[4] = 0xd;\n            puVar11[3] = 0x406010;\n            puVar11[2] = 0x4024b6;\n            fcn.00403350(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n            puVar11[2] = 0x33;\n            puVar11[1] = 0x41083c;\n            *puVar11 = 0xd;\n            puVar11[-1] = 0x406010;\n            puVar11[-2] = 0x4024c9;\n            fcn.00403350(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n            puVar11[-2] = 0x4b;\n            puVar11[-3] = 0x410870;\n            puVar11[-4] = 0xd;\n            puVar11[-5] = 0x406010;\n            puVar11[-6] = 0x4024dc;\n            fcn.00403350(puVar11[-5], puVar11[-4], puVar11[-3], puVar11[-2]);\n            puVar11[-6] = 0x39;\n            puVar11[-7] = 0x4108bc;\n            puVar11[-8] = 0xd;\n            puVar11[-9] = 0x406010;\n            puVar11[-10] = 0x4024ef;\n            fcn.00403350(puVar11[-9], puVar11[-8], puVar11[-7], puVar11[-6]);\n            puVar11[6] = 8;\n            puVar11[5] = 0x4108f8;\n            puVar11[4] = 0xd;\n            puVar11[3] = 0x406010;\n            puVar11[2] = 0x402505;\n            fcn.00403350(puVar11[3], puVar11[4], puVar11[5], puVar11[6]);\n            puVar11[2] = 0x14;\n            puVar11[1] = 0x410900;\n            *puVar11 = 0xd;\n            puVar11[-1] = 0x406010;\n            puVar11[-2] = 0x402518;\n            fcn.00403350(puVar11[-1], *puVar11, puVar11[1], puVar11[2]);\n            return;\n        }\n        *(puVar11 + -6) = puVar12;\n        puVar12 = puVar12 & 0xffff0000 | *(puVar11 + -6);\n        if (!uVar17 && !bVar14) goto code_r0x0040246e;\n        if (!uVar21) {\n            *(puVar11 + -2) = in_CS;\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        uVar27 = LocalDescriptorTableRegister();\n        *(uVar8 & 0xffffff00 | uVar8 + extraout_CH) = uVar27;\n    } while( true );\n}\n",
        "token_count": 6621
    },
    "00402f90": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402f90(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    float10 fVar8;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    var_264h = 0;\n    puVar5 = &var_263h;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_160h = '\\0';\n    puVar5 = &var_15fh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x560, arg_8h);\n    fVar8 = (*pcVar2)(&var_264h, 0x578, arg_8h);\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar4 = 0xffffffff;\n    pcVar6 = &var_160h;\n    do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar4 - 1;\n    uVar4 = 0xffffffff;\n    pcVar6 = arg_8h;\n    do {\n        pcVar7 = pcVar6;\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        pcVar7 = pcVar6 + 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar7;\n    } while (cVar1 != '\\0');\n    var_44h = ~uVar4 - 1;\n    var_34h = 0x4105a0;\n    var_30h = 0x4105ac;\n    var_2ch = 0x4105b8;\n    var_28h = 0x4105c8;\n    var_24h = 0x4105d0;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((-1 < var_44h) && (-1 >= var_44h)) {\n        *(pcVar7 + 0x1c) = fVar8;\n    }\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    if ((arg_ch != 0) < 5) {\n        uVar4 = (arg_ch != 0) * 4;\n        do {\n            iVar3 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar4), *(&var_5ch + uVar4), *(&var_20h + uVar4), \n                              *(&var_48h + uVar4));\n            if (iVar3 != 0) {\n                return 0;\n            }\n            uVar4 = uVar4 + 4;\n        } while (uVar4 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1168
    },
    "00404080": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040409c) overlaps instruction at (ram,0x0040409a)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t __cdecl fcn.00404080(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint32_t unaff_EDI;\n    char in_SF;\n    char in_OF;\n    uint var_4h;\n    \n    if ((in_OF == in_SF) && (in_OF != in_SF)) {\n        arg_8h = unaff_EDI;\n    }\n    if (arg_10h != 0) {\n        do {\n            arg_8h = arg_8h + *arg_ch;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 274
    },
    "00403e80": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040406a) overlaps instruction at (ram,0x00404061)\n// \n\nuint __fastcall fcn.00403e80(int32_t *param_1, int32_t param_2, int16_t *param_3)\n\n{\n    uchar uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    ushort uVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint32_t unaff_EBX;\n    uchar *unaff_EBP;\n    uchar *puVar9;\n    int32_t *piVar10;\n    uint *unaff_EDI;\n    uint *puVar11;\n    bool bVar12;\n    bool bVar13;\n    bool bVar14;\n    \n    puVar9 = &stack0xfffffffc;\n    if (*param_3 != 0x5a4d) {\n        return 0;\n    }\n    piVar6 = *(param_3 + 0x1e) + param_3;\n    bVar13 = *piVar6 + -0x4550 < 0;\n    if (*piVar6 != 0x4550) {\n        return 0;\n    }\n    if ((bVar13) || (!bVar13)) {\n        param_1 = piVar6[0x16];\n        bVar13 = false;\n        bVar14 = false;\n        piVar10 = param_1;\n    }\n    else {\n        bVar13 = 0x7aa7b774 < piVar6;\n        bVar14 = SCARRY4(piVar6, -0x7aa7b775);\n        piVar6 = piVar6 + -0x7aa7b775;\n        puVar9 = unaff_EBP;\n        piVar10 = piVar6;\n    }\n    bVar12 = piVar10 == NULL;\n    if (!bVar12) {\n        return 0;\n    }\n    *(puVar9 + -4) = 0x40;\n    uVar4 = param_2;\n    if ((bVar14) || (!bVar14)) {\n        uVar8 = unaff_EBX;\n        puVar11 = unaff_EDI;\n        if (!bVar14) goto code_r0x00403f43;\ncode_r0x00403f61:\n        if (*(param_3 + 0x1e) < 0x81) {\n            return 0;\n        }\n        uVar3 = *(param_3 + 0x1e);\n        bVar13 = uVar3 == 0xc0;\n        if (uVar3 < 0xc0) {\n            bVar13 = uVar3 - 0x80 == 0;\n            *(puVar9 + -4) = uVar3 - 0x80;\n        }\n        if (!bVar13) {\ncode_r0x00403fb3:\n            if (bVar13) {\n                uVar2 = in(uVar4);\n                *puVar11 = uVar2;\n                if (*0x10 < 1) {\n                    *(uVar8 + 0xcf8bf845) = *(uVar8 + 0xcf8bf845) | param_1;\n                    goto code_r0x0040403b;\n                }\n                *(uVar8 + 0xe850fc45) = *(uVar8 + 0xe850fc45) ^ param_1;\n                puVar9 = puVar9 + 1;\n            }\n        }\n    }\n    else {\n        puVar11 = unaff_EDI + 1;\n        uVar1 = in(uVar4);\n        *unaff_EDI = uVar1;\n        uVar8 = CONCAT31(unaff_EBX >> 8, 0xbc);\n        if (!bVar13 && !bVar12) {\n            *(piVar6 + 0xffc7589) = 0x84;\n            *piVar6 = (*piVar6 - piVar6) - bVar13;\n            *piVar6 = *piVar6 + piVar6;\n            bVar13 = *piVar6 == '\\0';\n            goto code_r0x00403fb3;\n        }\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(*param_1, 0xbc);\n        piVar6 = 0x1e800f;\n        bVar13 = 0xf0 < *0x1e800f;\n        bVar14 = SCARRY1(*0x1e800f, '\\x0f');\n        *0x1e800f = *0x1e800f + 0xf;\n        bVar12 = *0x1e800f == 0;\n        unaff_EDI = puVar11;\ncode_r0x00403f43:\n        uVar8 = unaff_EBX;\n        puVar11 = unaff_EDI;\n        if (!bVar14) goto code_r0x00403f61;\n        uVar1 = in(uVar4);\n        *unaff_EDI = uVar1;\n        if (bVar13 || bVar12) {\n            *0x803c7e81 = *0x803c7e81 + -0x7f;\n            *(unaff_EDI + 10) = *(unaff_EDI + 10) + (param_2 >> 8);\n            return 0;\n        }\n        puVar9 = puVar9 + 1;\n    }\n    iVar7 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    pcVar5 = _sym.imp.MSVCRT.dll_rand;\n    *(puVar9 + -8) = iVar7;\n    if (iVar7 == 0) {\n        return 0;\n    }\n    param_1 = *(puVar9 + -4);\n    piVar6 = NULL;\n    if (param_1 != NULL) {\n        do {\n            iVar7 = (*pcVar5)();\n            piVar10 = piVar6 + 1;\n            *(piVar6 + *(puVar9 + -8)) = iVar7 % 0xff;\n            piVar6 = piVar10;\n        } while (piVar10 < param_1);\n    }\n    param_2 = *(puVar9 + 8);\n    piVar6 = *(puVar9 + -8);\ncode_r0x0040403b:\n    piVar10 = param_2 + 0x80;\n    for (uVar8 = param_1 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *piVar10 = *piVar6;\n        piVar6 = piVar6 + 1;\n        piVar10 = piVar10 + 1;\n    }\n    for (uVar8 = param_1 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {\n        *piVar10 = *piVar6;\n        piVar6 = piVar6 + 1;\n        piVar10 = piVar10 + 1;\n    }\n    *(piVar6 + 0x43d1773a) = *(piVar6 + 0x43d1773a) ^ 0x5027e95e;\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n    return 1;\n}\n",
        "token_count": 1625
    },
    "004011b0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.004011b0(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.00402f30(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x410918, acStack1304, &uStack2112);\n    uStack2088 = 0x4109d0;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x4109e8;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.00401050(auStack1564, 0x410914, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1848
    },
    "00401570": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401570(uint StringSid)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    unkbyte6 Var3;\n    uint var_31ch;\n    uint lpBuffer;\n    uint Sid;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    Var3 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)();\n    bVar2 = Var3 == 0;\n    if (bVar2) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    if ((!bVar2) && (bVar2)) {\n        out(*0x104, Var3 >> 0x20);\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&Sid, StringSid);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 284
    },
    "00402a00": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402b3d) overlaps instruction at (ram,0x00402b39)\n// \n// WARNING: Removing unreachable block (ram,0x00402b9e)\n// WARNING: Removing unreachable block (ram,0x00402a6b)\n// WARNING: Removing unreachable block (ram,0x00402b89)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00402a00(uchar *arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    char cVar2;\n    uchar *in_EAX;\n    uchar *puVar3;\n    uint32_t uVar4;\n    uint16_t uVar5;\n    char cVar6;\n    uint in_ECX;\n    int32_t unaff_EBX;\n    uchar *puVar7;\n    uint32_t unaff_EDI;\n    uint8_t in_AF;\n    bool bVar8;\n    bool bVar9;\n    bool bVar10;\n    bool bVar11;\n    char *unaff_retaddr;\n    uint32_t in_stack_0000000c;\n    \n    *arg_8h = 0x4c;\n    arg_8h[1] = 0xf4;\n    arg_8h[2] = 0xf5;\n    arg_8h[3] = 0xf1;\n    arg_8h[4] = 0x35;\n    bVar9 = (in_ECX >> 8 ^ arg_8h) << 8 < 0;\n    arg_8h[5] = 0x31;\n    if ((bVar9) || (!bVar9)) {\n        arg_8h[6] = 0x90;\n        puVar3 = in_EAX;\n        puVar7 = arg_8h;\n    }\n    else {\n        puVar3 = arg_8h;\n        puVar7 = in_EAX + 1;\n    }\n    puVar7[7] = 0x6d;\n    puVar7[8] = 0x1a;\n    arg_8h[9] = 0xb8;\n    arg_8h[10] = 0xa3;\n    if (('\\0' < in_ECX) && (in_ECX < '\\x01')) {\n        *(unaff_EDI | &stack0xfffffffc) = puVar3;\n        arg_8h = arg_8h & 0xffffff00;\n    }\n    arg_8h[0xb] = 0x82;\n    iVar1 = *(unaff_EBX + 8);\n    *(iVar1 + 0xc) = 0x33;\n    uVar5 = arg_ch + 1;\n    bVar10 = false;\n    bVar8 = ((uVar5 & 0xff | (uVar5 >> 8 & in_stack_0000000c + 2U) << 8) & 0x7bc9) == 0;\n    bVar9 = (POPCOUNT(uVar5 & 0xc9) & 1U) == 0;\n    *(iVar1 + 0xd) = 0xa9;\n    uVar4 = in_stack_0000000c;\n    if (bVar8) goto code_r0x00402b7a;\n    do {\n        uVar4 = in_stack_0000000c;\n        if (bVar8) {\n            uVar4 = in_stack_0000000c & 0xe2f4cc58;\n            bVar10 = uVar4 < 0;\n            bVar8 = uVar4 == 0;\n            bVar9 = (POPCOUNT(in_stack_0000000c & 0x58) & 1U) == 0;\n        }\ncode_r0x00402b7a:\n        *(iVar1 + 0xe) = 0x5a;\n        *(iVar1 + 0xf) = 0xfb;\n        if ((bVar8 || bVar10 != false) || (!bVar8 && bVar10 == false)) {\n            bVar11 = false;\n            *(iVar1 + 0x10) = 0x2b;\n        }\n        else {\n            cVar6 = (arg_ch << 0x10) >> 0x18;\n            cVar2 = *unaff_retaddr + cVar6;\n            bVar11 = SCARRY1(*unaff_retaddr, cVar6) != SCARRY1(cVar2, '\\0');\n            *unaff_retaddr = cVar2;\n            bVar10 = *unaff_retaddr < '\\0';\n            bVar8 = *unaff_retaddr == '\\0';\n            bVar9 = (POPCOUNT(*unaff_retaddr) & 1U) == 0;\n        }\n        if ((bVar8 || bVar11 != bVar10) || (!bVar8 && bVar11 == bVar10)) {\n            *(iVar1 + 0x11) = 0xd6;\n            uVar5 = arg_ch | 0x31fd;\n            uVar4 = *(unaff_EBX + 8);\n            *(uVar4 + 0x12) = 0xd4;\n            if ((uVar5 < 1) || (0 < uVar5)) {\n                **(unaff_EBX + 0xc) = 0x13;\n                return;\n            }\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            uVar4 = uVar4 & 0xffff0000 | CONCAT11((uVar4 >> 8) + in_AF, uVar4 + in_AF * '\\x06') & 0xff0f;\n            if (arg_ch != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n        }\n        else {\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            uVar4 = uVar4 & 0xffff0000 | CONCAT11((uVar4 >> 8) + in_AF, uVar4 + in_AF * '\\x06') & 0xff0f;\n            if (arg_ch != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            if (!bVar9) {\n                return;\n            }\n        }\n        in_stack_0000000c = uVar4 | 0x660c76a9;\n        bVar10 = in_stack_0000000c < 0;\n        bVar8 = in_stack_0000000c == 0;\n        bVar9 = (POPCOUNT(in_stack_0000000c & 0xff) & 1U) == 0;\n    } while( true );\n}\n",
        "token_count": 1515
    },
    "00401700": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36",
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004017dd) overlaps instruction at (ram,0x004017db)\n// \n// WARNING: Variable defined which should be unmapped: var_10bh\n\nvoid __cdecl\nfcn.00401700(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, int32_t arg_20h)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_EBX;\n    uint *puVar3;\n    bool bVar4;\n    bool bVar5;\n    bool bVar6;\n    unkbyte10 extraout_ST0;\n    ulong uVar7;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    while( true ) {\n        bVar4 = false;\n        bVar6 = false;\n        bVar5 = ((unaff_EBX & 0xff00 | unaff_EBX | in_EAX >> 8) & 0x94f) == 0;\n        in_EAX = fcn.004018b0(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n        if (bVar4 || bVar5) break;\n        if (!bVar4 && !bVar5) break;\n        unaff_EBX = arg_18h;\n        if (!bVar6) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.004018b0(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    fcn.004018b0(arg_18h, arg_1ch, arg_10h, 0x20, arg_20h + 0xa0);\n    fcn.004018b0(arg_18h, arg_1ch, arg_14h, 0x20, arg_20h + 0xe0);\n    if ((-1 < &stack0xfffffee4) && (-1 >= &stack0xfffffee4)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar1 = fcn.004016b0();\n    if (iVar1 == -1) {\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x120) = iVar1 % 5;\n    }\n    else {\n        *(arg_20h + 0x120) = iVar1;\n    }\n    var_10ch = 0;\n    puVar3 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_4h = 0x104;\n    *(puVar3 + 2) = 0;\n    uVar7 = fcn.00402e70(0x80000001, 0x410770, 0x41079c, &var_8h, &var_10ch, &var_4h);\n    piVar2 = uVar7 >> 0x20;\n    iVar1 = uVar7;\n    if (iVar1 != 0) {\n        if ((-1 < iVar1) && (-1 >= iVar1)) {\n            *(iVar1 + -0x7ce92414) = extraout_ST0;\n            *piVar2 = *piVar2 + -0x6a72207c;\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, 0x4107ec);\n        if (iVar1 == 0) {\n            *(arg_20h + 0x120) = *(arg_20h + 0x120) | 0x80;\n        }\n    }\n    return;\n}\n",
        "token_count": 953
    },
    "00403450": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuint fcn.00403450(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    \n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x4105d8);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 == 0) {\n        return 0;\n    }\n    *0x41fa1c = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x4105e8);\n    *0x41fa20 = (*pcVar1)(iVar2, 4);\n    *0x41fa24 = (*pcVar1)(iVar2, 0x14);\n    if (((*0x41fa1c != 0) && (*0x41fa20 != 0)) && (*0x41fa24 != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 202
    },
    "00403d50": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403e1e) overlaps instruction at (ram,0x00403e15)\n// \n\nuint fcn.00403d50(uint param_1)\n\n{\n    int32_t iVar1;\n    uint extraout_ECX;\n    uchar *puVar2;\n    int32_t unaff_ESI;\n    uint *puVar3;\n    bool bVar4;\n    uchar uStack532;\n    uint uStack531;\n    uchar uStack272;\n    uint uStack271;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack532 = 0;\n    uStack272 = 0;\n    puVar3 = &uStack531;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    puVar3 = &uStack271;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&uStack532, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&uStack272, 0x4104f8, &uStack532, param_1);\n    fcn.004036d0(&uStack8, &uStack12);\n    bVar4 = false;\n    fcn.00403e80(uStack8);\n    puVar2 = &stack0xfffffffc;\n    if ((!bVar4) && (puVar2 = &stack0xfffffffc,  bVar4)) {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8b27e95e;\n        uStack12 = extraout_ECX;\n        puVar2 = &uStack8 + 3;\n    }\n    iVar1 = fcn.00401050(puVar2 + -0x10c, 0x410518, *(puVar2 + -4), uStack12);\n    if (iVar1 != 0) {\n        fcn.00403be0(puVar2 + -0x10c, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 591
    },
    "004019e0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401afc) overlaps instruction at (ram,0x00401af7)\n// \n// WARNING: Removing unreachable block (ram,0x00401a4f)\n\nint32_t fcn.004019e0(int32_t param_1, int32_t param_2, uint32_t *param_3, uint32_t *param_4)\n\n{\n    uint32_t *puVar1;\n    uint *puVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    char *pcVar5;\n    char cVar7;\n    uint32_t uVar6;\n    ushort uVar8;\n    uint32_t extraout_ECX;\n    uint32_t uVar9;\n    int32_t iVar10;\n    int32_t unaff_EBX;\n    uint16_t uVar11;\n    uint *puVar12;\n    int32_t iVar13;\n    ushort in_SS;\n    bool bVar14;\n    uint8_t in_AF;\n    bool bVar15;\n    ulong uVar16;\n    \n    uVar4 = fcn.00404080(0, param_1, param_2 + 1U >> 1);\n    uVar4 = uVar4 & 0xffff;\n    pcVar5 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(param_1);\n    uVar6 = *(pcVar5 + 0x58);\n    uVar8 = 0;\n    uVar3 = uVar6;\n    uVar11 = uVar4;\n    if (uVar3 <= uVar11) {\n        uVar9 = uVar6 & 0xffff;\n        puVar12 = uVar4 - uVar9;\n        goto code_r0x00401a87;\n    }\n    uVar9 = extraout_ECX;\n    if (uVar11 == uVar3) {\ncode_r0x00401a7e:\n        uVar4 = uVar4 - uVar6;\n    }\n    else {\n        uVar8 = extraout_ECX;\n        uVar9 = (extraout_ECX >> 8 & 0xffff00) << 8 | extraout_ECX & 0xffff;\n        if (uVar11 != uVar3) goto code_r0x00401a7e;\n    }\n    param_1 = CONCAT22(uVar8, in_SS);\n    puVar12 = (uVar4 & 0xffff) - 1;\ncode_r0x00401a87:\n    bVar14 = (POPCOUNT(puVar12 & 0xff) & 1U) == 0;\n    if ((bVar14) || (!bVar14)) {\n        uVar4 = uVar6 >> 0x10;\n        in_AF = puVar12 < uVar6 >> 0x10;\n    }\n    else {\n        puVar2 = puVar12 + 1;\n        out(*puVar12, pcVar5);\n        uVar4 = uVar6;\n        do {\n            cVar7 = uVar4 >> 8;\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            uVar4 = CONCAT31(CONCAT21(uVar4 >> 0x10, cVar7 - in_AF), -in_AF);\n            puVar12 = puVar2;\n        } while (in_AF || cVar7 == *pcVar5);\n    }\n    puVar1 = param_1 + pcVar5 * 2;\n    bVar14 = *puVar1 < 0xffffff85 || *puVar1 + 0x7b < in_AF;\n    *puVar1 = (*puVar1 + 0x7b) - in_AF;\n    bVar15 = *puVar1 == 0;\n    *(uVar9 - 0x3f) = uVar4;\n    uVar16 = func_0xf07b80b4();\n    iVar10 = uVar16 >> 0x20;\n    uVar6 = uVar16;\n    if (bVar14) {\n        if ((!bVar14 && !bVar15) && (bVar14 || bVar15)) {\n            uVar6 = uVar6 & 0xe2f4cc58;\n        }\n        iVar13 = (puVar12 - uVar6 & 0xffff) - 1;\n    }\n    else {\n        iVar13 = puVar12 - (uVar6 & 0xffff);\n    }\n    bVar14 = (POPCOUNT(iVar13 + param_2 & 0xff) & 1U) == 0;\n    *param_4 = iVar13 + param_2;\n    if ((bVar14) || (!bVar14)) {\n        param_2 = *(iVar10 + 0x58);\n        param_4 = param_3;\n    }\n    *(unaff_EBX + 0x5e5f5842) = *(unaff_EBX + 0x5e5f5842) + param_4;\n    *param_4 = iVar10 + 1;\n    return param_2;\n}\n",
        "token_count": 1126
    },
    "004033f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.004033f0(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004013b0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x406020;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "00403760": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403810) overlaps instruction at (ram,0x0040380f)\n// \n// WARNING: Removing unreachable block (ram,0x0040378d)\n// WARNING: Removing unreachable block (ram,0x00403799)\n// WARNING: Removing unreachable block (ram,0x0040379d)\n// WARNING: Removing unreachable block (ram,0x0040380f)\n\nbool __cdecl fcn.00403760(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint arg_8h_00;\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    uint arg_ch_00;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uint var_314h;\n    uint var_210h;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    var_8h = 0;\n    puVar6 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    fcn.00402910();\n    uVar5 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(uVar5 - 0x10c, 0x104);\n    *(uVar5 - 4) = 0;\n    do {\n        uVar2 = fcn.00402ca0();\n        uVar3 = fcn.00402ca0();\n        arg_ch_00 = fcn.00402ca0();\n        arg_8h_00 = *(uVar5 + 0x10);\n        fcn.00402f30(arg_8h_00, uVar2);\n        uVar2 = *(uVar5 + 8);\n        fcn.00402f30(uVar2, uVar3);\n        uVar3 = *(uVar5 + 0xc);\n        fcn.00402f30(uVar3, arg_ch_00);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(uVar5 - 0x314, 0x4104f8, uVar5 - 0x10c, arg_8h_00);\n        iVar4 = fcn.004044f0(uVar5 - 0x314);\n        if (iVar4 != 0) {\n            (*pcVar1)(uVar5 - 0x210, 0x410504, uVar5 - 0x10c, uVar2);\n            iVar4 = fcn.004044f0(uVar5 - 0x210);\n            if (iVar4 != 0) {\n                (*pcVar1)(uVar5 - 0x210, 0x410504, uVar5 - 0x10c, uVar3);\n                iVar4 = fcn.004044f0(uVar5 - 0x210);\n                if (iVar4 != 0) {\n                    iVar4 = 1;\n                    goto code_r0x0040389f;\n                }\n            }\n        }\n        iVar4 = *(uVar5 - 4) + 1;\n        *(uVar5 - 4) = iVar4;\n    } while (iVar4 < 3);\n    iVar4 = *(uVar5 - 8);\ncode_r0x0040389f:\n    fcn.00402f30(*(uVar5 + 0x14), 4);\n    return iVar4 != 0;\n}\n",
        "token_count": 862
    },
    "004013b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004013da) overlaps instruction at (ram,0x004013d8)\n// \n\nvoid __cdecl fcn.004013b0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t extraout_ECX;\n    int32_t iVar2;\n    int32_t extraout_ECX_00;\n    bool bVar3;\n    \n    if (arg_ch == 1) {\n        bVar3 = false;\n        iVar1 = fcn.00401e70();\n        if ((bVar3) || (iVar2 = extraout_ECX,  !bVar3)) {\n            fcn.004038c0();\n            iVar1 = *0x41f9f4;\n            iVar2 = extraout_ECX_00;\n        }\n        *(iVar2 + 0x41f9f4) = *(iVar2 + 0x41f9f4) + (iVar1 + 0x24e1e8 >> 8);\n        if (iVar1 + 0x24e1e8 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.004011b0();\n        }\n    }\n    (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    return;\n}\n",
        "token_count": 320
    },
    "00401490": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004014a1) overlaps instruction at (ram,0x0040149f)\n// \n\nuint __fastcall fcn.00401490(int32_t param_1, int32_t param_2, int32_t param_3, char param_4)\n\n{\n    code *pcVar1;\n    char in_AL;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *unaff_EDI;\n    char in_SF;\n    char in_OF;\n    \n    if (in_OF == in_SF) {\n        if (in_OF != in_SF) goto code_r0x0040149e;\n    }\n    param_1 = param_3;\n    in_AL = param_4;\ncode_r0x0040149e:\n    *(param_2 + -1) = *(param_2 + -1) | param_1 >> 8;\n    *unaff_EDI = *unaff_EDI + param_1;\n    *(param_2 + 0x51) = *(param_2 + 0x51) + in_AL;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 424
    },
    "00401530": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040154d) overlaps instruction at (ram,0x00401549)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nbool __fastcall fcn.00401530(uint param_1, int32_t param_2, uint *param_3)\n\n{\n    uint *in_EAX;\n    int32_t iVar1;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    bool in_CF;\n    bool in_ZF;\n    uint uStack8;\n    \n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        uStack8 = 1;\n        in_EAX = param_3;\n    }\n    *unaff_EDI = *unaff_ESI;\n    *(param_2 + 1) = *(param_2 + 1) | param_1 >> 8;\n    in_EAX[-1] = &stack0xfffffff8;\n    in_EAX[-2] = 0x401558;\n    iVar1 = fcn.00402f90(in_EAX[-1], *in_EAX);\n    return iVar1 != 0;\n}\n",
        "token_count": 257
    },
    "004018b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint32_t __cdecl fcn.004018b0(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h, int32_t arg_18h)\n\n{\n    uint8_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    uint32_t unaff_EDI;\n    bool bVar6;\n    uint auStack40 [2];\n    uint var_10h;\n    int32_t var_ch;\n    uint32_t var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    uint *puVar5;\n    \n    puVar4 = &var_1h + 1;\n    puVar5 = &var_1h + 1;\n    var_10h._0_1_ = arg_14h * '\\x02';\n    var_8h = 0;\n    uVar3 = arg_14h;\n    if (0 < arg_14h) {\n        var_ch = 1;\n        do {\n            var_1h._0_1_ = *(var_8h + arg_10h);\n            bVar6 = (POPCOUNT(unaff_EDI & var_8h & 0xff) & 1U) != 0;\n            uVar1 = *(var_ch % arg_ch + arg_8h);\n            if ((bVar6) && (!bVar6)) {\n                puVar5 = auStack40 + 1;\n                cVar2 = '\\x1e';\n                do {\n                    puVar4 = puVar4 + -1;\n                    puVar5 = puVar5 + -1;\n                    *puVar5 = *puVar4;\n                    cVar2 = cVar2 + -1;\n                } while ('\\0' < cVar2);\n                uVar3 = in(0x78);\n                return uVar3;\n            }\n            bVar6 = (POPCOUNT(uVar1 - 5 & 0x44) & 1U) != 0;\n            if ((bVar6) && (!bVar6)) {\n                puVar4 = auStack40 + 1;\n                cVar2 = '\\x1e';\n                do {\n                    puVar5 = puVar5 + -1;\n                    puVar4 = puVar4 + -1;\n                    *puVar4 = *puVar5;\n                    cVar2 = cVar2 + -1;\n                } while ('\\0' < cVar2);\n                uVar3 = in(0x78);\n                return uVar3;\n            }\n            *(arg_18h + -1 + var_ch) = var_10h ^ *(var_8h + arg_10h) ^ *((var_ch + -1) % arg_ch + arg_8h);\n            unaff_EDI = unaff_EDI & 0xffff;\n            *(var_ch + arg_18h) = var_10h ^ uVar1;\n            uVar3 = var_8h + 1;\n            var_ch = var_ch + 2;\n            var_8h = uVar3;\n        } while (uVar3 < arg_14h);\n    }\n    return uVar3;\n}\n",
        "token_count": 749
    },
    "null": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00401b10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401afc) overlaps instruction at (ram,0x00401af7)\n// \n\nint32_t __cdecl fcn.00401b10(uint arg_8h, int32_t arg_ch, uint32_t *noname_2, uint32_t *arg_14h)\n\n{\n    int32_t **ppiVar1;\n    int32_t iVar2;\n    uint8_t in_CL;\n    int32_t unaff_EBX;\n    uchar *puVar3;\n    uchar *puVar4;\n    int32_t unaff_ESI;\n    uint unaff_EDI;\n    ushort in_SS;\n    bool in_CF;\n    bool bVar5;\n    bool in_PF;\n    bool in_ZF;\n    uchar in_stack_ffffffd8;\n    uchar in_stack_ffffffd9;\n    ushort in_stack_ffffffda;\n    uchar in_stack_ffffffdc;\n    uchar in_stack_ffffffdd;\n    ushort in_stack_ffffffde;\n    uint var_4h;\n    \n    puVar3 = &stack0xfffffffc;\n    puVar4 = &stack0xfffffffc;\n    if ((in_PF) || (!in_PF)) {\ncode_r0x00401b3b:\n        (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n        puVar3 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n        unaff_EDI = *(puVar3 + 8);\n        unaff_ESI = *(puVar3 + -4);\n    }\n    else {\n        ppiVar1 = segment(in_SS, *0x10 + -0x14);\n        if (!in_CF) {\n            if (in_PF) {\n                **ppiVar1 = **ppiVar1 + 1;\n                *(unaff_ESI + 0x66) = *(unaff_ESI + 0x66) + in_CL;\n                bVar5 = (POPCOUNT(unaff_ESI + arg_ch & 0xff) & 1U) == 0;\n                *arg_14h = unaff_ESI + arg_ch;\n                if ((bVar5) || (!bVar5)) {\n                    arg_ch = *0xb7bc9efd;\n                    arg_14h = noname_2;\n                }\n                *(unaff_EBX + 0x5e5f5842) = *(unaff_EBX + 0x5e5f5842) + arg_14h;\n                *arg_14h = 0xb7bc9ea6;\n                return arg_ch;\n            }\n            goto code_r0x00401b3b;\n        }\n        if (!in_ZF) {\n            *(unaff_EBX + 0x5657fc75) = *(unaff_EBX + 0x5657fc75) | in_CL;\n            goto code_r0x00401b60;\n        }\n    }\n    in_stack_ffffffdc = unaff_EDI;\n    in_stack_ffffffdd = unaff_EDI >> 8;\n    in_stack_ffffffde = unaff_EDI >> 0x10;\n    in_stack_ffffffd8 = unaff_ESI;\n    in_stack_ffffffd9 = unaff_ESI >> 8;\n    in_stack_ffffffda = unaff_ESI >> 0x10;\n    puVar4 = puVar3;\ncode_r0x00401b60:\n    fcn.00402ce0(CONCAT22(in_stack_ffffffda, CONCAT11(in_stack_ffffffd9, in_stack_ffffffd8)), \n                 CONCAT22(in_stack_ffffffde, CONCAT11(in_stack_ffffffdd, in_stack_ffffffdc)));\n    iVar2 = fcn.00404560(unaff_ESI, unaff_EDI, *(puVar4 + 0xc));\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(unaff_ESI);\n    return iVar2;\n}\n",
        "token_count": 861
    },
    "00401ba0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401ba0(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    bool bVar2;\n    \n    uVar1 = 0;\n    bVar2 = false;\n    if (arg_14h != 0) {\n        do {\n            if ((!bVar2) && (bVar2)) {\n                out(0xbd, arg_14h);\n                return;\n            }\n            *(uVar1 + arg_10h) = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            uVar1 = uVar1 + 1;\n            bVar2 = uVar1 < arg_14h;\n        } while (bVar2);\n    }\n    return;\n}\n",
        "token_count": 193
    },
    "00401d10": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401dcb) overlaps instruction at (ram,0x00401dc8)\n// \n\nuint __cdecl fcn.00401d10(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    char cVar5;\n    int32_t iVar2;\n    uint in_EAX;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t in_ECX;\n    char *in_EDX;\n    code *unaff_EBX;\n    uint *unaff_ESI;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t unaff_EDI;\n    uint *puVar8;\n    uint8_t uVar9;\n    bool bVar10;\n    uint8_t in_AF;\n    uint uStackY296;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    uVar9 = &stack0xfffffffc < 0x24;\n    bVar10 = (POPCOUNT(&var_24h & 0xff) & 1U) != 0;\n    if ((*0x10 == 0x28 || &stack0xfffffffc < 0x24) ||\n       (*0x10 != 0x28 && SBORROW4(&stack0xfffffffc, 0x24) == &var_24h < 0)) {\n        if ((bVar10) && (!bVar10)) {\n            out(*unaff_ESI, in_EDX);\n            uVar9 = in_AF;\n            do {\n                cVar5 = in_EAX >> 8;\n                uVar9 = 9 < (in_EAX & 0xf) | uVar9;\n                in_EAX = CONCAT31(CONCAT21(in_EAX >> 0x10, cVar5 - uVar9), -uVar9);\n            } while (uVar9 || cVar5 == *in_EDX);\n        }\n        piVar3 = unaff_EDI + in_EDX * 2;\n        *piVar3 = (*piVar3 + 0x7b) - uVar9;\n        *(in_ECX + 0x51) = in_EAX;\n        var_4h = fcn.00403b50(arg_18h, arg_1ch, 0x410528, 7);\n        pcVar1 = _sym.imp.MSVCRT.dll_rand;\n        if (var_4h != NULL) {\n            piVar3 = NULL;\n            var_24h = 0;\n            puVar7 = &var_23h;\n            for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            *(puVar7 + 2) = 0;\n            bVar10 = false;\n            uVar6 = 0;\n            do {\n                if ((!bVar10) && (bVar10)) {\n                    *piVar3 = *piVar3 + 1;\n                    *(piVar3 + 0xd480779) = *(piVar3 + 0xd480779) + piVar3;\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n                uVar4 = (*pcVar1)();\n                piVar3 = uVar4 & 0x800000ff;\n                if (piVar3 < 0) {\n                    piVar3 = (piVar3 - 1U | 0xffffff00) + 1;\n                }\n                (&var_24h)[uVar6] = piVar3;\n                uVar6 = uVar6 + 1;\n                bVar10 = uVar6 < 0x20;\n            } while (bVar10);\n            puVar7 = &var_24h;\n            puVar8 = var_4h;\n            for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar8 = *puVar7;\n                puVar7 = puVar7 + 1;\n                puVar8 = puVar8 + 1;\n            }\n            fcn.00401700(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n            fcn.00401410();\n            return 1;\n        }\n        return 0;\n    }\n    if (in_ECX != 0) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    do {\n        iVar2 = (*unaff_EBX)();\n        if (iVar2 == 0) {\n            var_4h = uStackY296;\n            break;\n        }\n        iVar2 = (**0x41fa24)();\n    } while (iVar2 != 0);\n    (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    return var_4h;\n}\n",
        "token_count": 1146
    },
    "00402520": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004027a8) overlaps instruction at (ram,0x0040279f)\n// \n\nuint fcn.00402520(void)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint16_t extraout_CX;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    uint32_t *extraout_ECX_01;\n    ushort extraout_DX;\n    uint8_t extraout_DH;\n    int32_t extraout_EDX;\n    uint extraout_EDX_00;\n    uint *puVar5;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    bool bVar6;\n    uchar uVar7;\n    uint in_stack_ffffbec9;\n    uint uVar8;\n    uint in_stack_ffffbed9;\n    uint in_stack_ffffbedd;\n    uint *puVar9;\n    uint uVar10;\n    uchar auStack16647 [16603];\n    \n    fcn.00403350(0x406010, 0xd, 0x4104e4, 0x11);\n    fcn.00403350(0x406010, 0xd, 0x410744, 0xf);\n    fcn.00403350(0x406010, 0xd, 0x410754, 0x1a);\n    fcn.00403350(0x406010, 0xd, 0x4107a8, 10);\n    fcn.00403350(0x406010, 0xd, 0x4107b4, 0xb);\n    uVar7 = 0;\n    bVar6 = (POPCOUNT(extraout_DH & 0x12) & 1U) == 0;\n    fcn.00403350(0x406010, 0xd, 0x4107c0, 8);\n    if ((!bVar6) && (bVar6)) {\n        piVar1 = extraout_EDX + 9;\n        uVar7 = SBORROW4(*piVar1, 0x68);\n        *piVar1 = *piVar1 + -0x68;\n    }\n    uVar8 = 0x406010;\n    fcn.00403350(0x406010, 0xd, in_stack_ffffbed9, in_stack_ffffbedd);\n    if ((uVar7) || (iVar4 = extraout_ECX,  !uVar7)) {\n        iVar4 = 9;\n        in_stack_ffffbec9 = 0x4107d4;\n    }\n    *unaff_EDI = *unaff_ESI;\n    *0xd4680977 = *0xd4680977 + (extraout_ECX + 1 >> 8);\n    fcn.00403350(0x406010, in_stack_ffffbec9, iVar4, uVar8);\n    bVar6 = (POPCOUNT(unaff_ESI + 4U & extraout_CX & 0xff) & 1U) == 0;\n    uVar10 = 0x406010;\n    iVar4 = fcn.00403350(0x406010, 0xd, 0x4107e0, 9);\n    if ((bVar6) || (puVar9 = unaff_EDI + 1,  !bVar6)) {\n        puVar9 = 0xc;\n        in_stack_ffffbedd = 0x4107ec;\n    }\n    puVar5 = *0x6a17b43a;\n    in(iVar4);\n    *(iVar4 + 0xd) = *(iVar4 + 0xd) + (extraout_ECX_00 + 1 >> 8);\n    fcn.00403350(0x406010, in_stack_ffffbedd, puVar9, uVar10);\n    fcn.00403350(0x406010, 0xd, 0x410914, 3);\n    iVar4 = 0x34a96cf4;\n    fcn.00403350(0x406010, 0xd, 0x410918, 10);\n    iVar3 = fcn.00403350(0x406010, 0xd, 0x410924, 0x1b);\n    uVar7 = 0;\n    bVar6 = ((unaff_EDI + 1 | 0x74e3) - iVar3 & 0x1a8) == 0;\n    fcn.00403350(0x406010, 0xd, 0x410940, 0x12);\n    if ((!bVar6) && (bVar6)) {\n        iVar4 = 0x34a96cf5;\n        out(*0x34a96cf4, extraout_DX);\n    }\n    fcn.00403350(0x406010, 0xd, 0x410954, 0x40);\n    if ((uVar7) || (!uVar7)) {\n        uVar10 = 0xc;\n        uVar8 = 0x410994;\n    }\n    else {\n        *(iVar4 + 0x43d1773a) = *(iVar4 + 0x43d1773a) ^ 0x6a27e95e;\n        *extraout_ECX_01 = *extraout_ECX_01 | &stack0xffffbed9;\n        uVar10 = extraout_EDX_00;\n    }\n    fcn.00403350(0x406010, 0xd, uVar8, uVar10);\n    fcn.00403350(0x406010, 0xd, 0x4109a0, 0xb);\n    bVar6 = (POPCOUNT(auStack16647 & 0xff) & 1U) != 0;\n    if ((bVar6) && (!bVar6)) {\n        puVar9 = &stack0xffffbef5;\n        cVar2 = '\\x1e';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar9 = puVar9 + -1;\n            *puVar9 = *puVar5;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n        uVar8 = in(0x78);\n        return uVar8;\n    }\n    fcn.00403350(0x406010, 0xd, 0x4109ac, 4);\n    fcn.00403350(0x406010, 0xd, 0x4109b0, 4);\n    fcn.00403350(0x406010, 0xd, 0x4109b4, 0xc);\n    fcn.00403350(0x406010, 0xd, 0x4109c0, 4);\n    fcn.00403350(0x406010, 0xd, 0x4109c4, 9);\n    fcn.00403350(0x406010, 0xd, 0x4109d0, 0x16);\n    uVar8 = fcn.00403350(0x406010, 0xd, 0x4109e8, 7);\n    return uVar8;\n}\n",
        "token_count": 1641
    },
    "00402910": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00402910(uint param_1, ushort param_2)\n\n{\n    uint uVar1;\n    uchar *unaff_ESI;\n    bool bVar2;\n    \n    bVar2 = *0x41f9fc == 0;\n    if (bVar2) {\n        if ((!bVar2) && (bVar2)) {\n            out(*unaff_ESI, param_2);\n        }\n        uVar1 = (*_sym.imp.MSVCRT.dll_time)(0);\n        (*_sym.imp.MSVCRT.dll_srand)(uVar1);\n        *0x41f9fc = 1;\n    }\n    return;\n}\n",
        "token_count": 147
    },
    "00402c00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00402c2f)\n\nvoid __cdecl fcn.00402c00(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00402a00(&var_68h, &var_4h);\n    fcn.00401ba0(&var_68h, var_4h, 0x406024, 0xa4c0);\n    *arg_8h = 0x406024;\n    *arg_ch = 0xa4c0;\n    return;\n}\n",
        "token_count": 259
    },
    "00402ca0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00402ca0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00402e00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402e00(uint arg_8h)\n\n{\n    uint uVar1;\n    uint uVar2;\n    \n    uVar1 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0x3f);\n    uVar2 = fcn.00401490(uVar1, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n    return uVar2;\n}\n",
        "token_count": 106
    },
    "00402f30": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402f30(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00403350": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.00403350(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    bool bVar2;\n    uint var_1h;\n    \n    iVar1 = 0;\n    bVar2 = false;\n    if (0 < arg_14h) {\n        do {\n            if (!bVar2) {\n                if (bVar2) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            *(iVar1 + arg_10h) = arg_14h ^ *(iVar1 + arg_10h) ^ *(iVar1 % arg_ch + arg_8h);\n            iVar1 = iVar1 + 1;\n            bVar2 = SBORROW4(iVar1, arg_14h);\n        } while (iVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 239
    },
    "00403500": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004035f9) overlaps instruction at (ram,0x004035f8)\n// \n// WARNING: Removing unreachable block (ram,0x0040360a)\n// WARNING: Removing unreachable block (ram,0x00403532)\n\nulong __fastcall fcn.00403500(uint param_1, uint32_t param_2)\n\n{\n    uint8_t *puVar1;\n    uchar *puVar2;\n    int32_t iVar3;\n    char **ppcVar4;\n    char *in_EAX;\n    uint uVar5;\n    char cVar6;\n    uint8_t uVar7;\n    uint32_t unaff_EBX;\n    uint *puVar8;\n    uint *puVar9;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    ushort in_ES;\n    ushort in_SS;\n    bool bVar10;\n    bool bVar11;\n    bool bVar12;\n    uint uStack20;\n    ushort uStack16;\n    \n    puVar9 = &stack0xfffffffc;\n    uStack16 = SUB42(unaff_EDI, 0);\n    do {\n        puVar2 = puVar9[2];\n        *puVar2 = 0x4f;\n        puVar2[1] = 0x2c;\n        uVar7 = unaff_EBX >> 8 ^ 0x16 | in_EAX >> 8;\n        cVar6 = param_2 >> 8;\n        bVar12 = SBORROW1(uVar7, cVar6);\n        cVar6 = uVar7 - cVar6;\n        bVar11 = cVar6 < '\\0';\n        bVar10 = (POPCOUNT(cVar6) & 1U) == 0;\n        unaff_EBX = unaff_EBX & 0xffff;\n        in_EAX = in_EAX & 0xffff;\n        puVar2[2] = 0xf6;\n        if (bVar10) goto code_r0x0040358a;\n        if (!bVar10) goto code_r0x0040358a;\n        while( true ) {\n            iVar3 = *unaff_EDI;\n            *unaff_EDI = unaff_ESI;\n            puVar9 = puVar9 - *(puVar9 + 0x5f9dff63);\n            unaff_ESI = iVar3;\n            if (puVar9 < 0) break;\n            bVar12 = false;\n            bVar11 = iVar3 < 0;\n            if (!bVar11) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\ncode_r0x0040358a:\n            puVar2[3] = 0xa6;\n            if ((bVar12 == bVar11) && (bVar12 != bVar11)) {\n                unaff_ESI = unaff_ESI + -1;\n                *(unaff_EDI | puVar9) = in_EAX;\n                param_2 = param_2 & 0xffffff00;\n                in_SS = uStack16;\n                uStack16 = in_ES;\n            }\n            puVar2[4] = 0xdf;\n            puVar2[5] = 9;\n            bVar10 = (POPCOUNT(param_2 >> 8 & 0x12) & 1U) == 0;\n            unaff_EDI = puVar9[2];\n            *(unaff_EDI + 6) = 0xff;\n            if ((bVar10) || (!bVar10)) {\ncode_r0x004035e9:\n                *(unaff_EDI + 7) = 0xed;\n                if ((bVar10) || (!bVar10)) {\n                    *(unaff_EDI + 2) = 0x1e;\n                }\n                else {\n                    *(unaff_ESI + 0x47) = *(unaff_ESI + 0x47) | unaff_EBX;\n                }\n                bVar10 = (POPCOUNT(uStack16 + -1) & 1U) != 0;\n                *(unaff_EDI + 9) = 0x4b;\n                if ((bVar10) && (!bVar10)) {\n                    puVar8 = &uStack16;\n                    cVar6 = '\\x1e';\n                    do {\n                        puVar9 = puVar9 + -1;\n                        puVar8 = puVar8 + -1;\n                        *puVar8 = *puVar9;\n                        cVar6 = cVar6 + -1;\n                    } while ('\\0' < cVar6);\n                    uVar5 = in(0x78);\n                    return CONCAT44(param_2, uVar5);\n                }\n                *(unaff_EDI + 10) = 0x77;\n                *(unaff_EDI + 0xb) = 7;\n                *(unaff_EDI + 3) = 0x90;\n                *(unaff_EDI + 0xd) = 0xf9;\n                *(unaff_EDI + 0xe) = 0xa0;\n                *(unaff_EDI + 0xf) = 0x39;\n                puVar9 = puVar9[3];\n                *puVar9 = 0x10;\n                return CONCAT44(param_2, puVar9);\n            }\n            ppcVar4 = segment(in_SS, *0x10 + -0xc);\n            in_EAX = *ppcVar4;\n            param_2 = 0xb7bc9ea5;\n            if (!bVar10) {\n                bVar10 = (POPCOUNT(&stack0xfffffff8 & 0xff) & 1U) == 0;\n                uStack16 = SUB42(in_EAX, 0);\n                goto code_r0x004035e9;\n            }\n            puVar1 = in_EAX + -0x74f06f70;\n            uVar7 = *puVar1;\n            *puVar1 = *puVar1 + 0xa5;\n            *in_EAX = *in_EAX + in_EAX + (0x5a < uVar7);\n            *in_EAX = *in_EAX + in_EAX;\n        }\n    } while( true );\n}\n",
        "token_count": 1385
    },
    "004036d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004036d0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403500(&var_68h, &var_4h);\n    fcn.00401ba0(&var_68h, var_4h, 0x4109f0, 0xf000);\n    *arg_8h = 0x4109f0;\n    *arg_ch = 0xf000;\n    return;\n}\n",
        "token_count": 241
    },
    "00403a60": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value",
            "delete registry key"
        ],
        "decompiled_code": "\nvoid fcn.00403a60(void)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint uStack332;\n    uint uStack328;\n    uint uStack324;\n    uint uStack320;\n    uint uStack316;\n    uint uStack312;\n    uint uStack308;\n    uint uStack304;\n    uchar *puStack300;\n    uchar *puStack296;\n    uchar uStack276;\n    uint uStack275;\n    uint uStack271;\n    uint uStack267;\n    ushort uStack263;\n    uchar uStack261;\n    uchar uStack260;\n    uint uStack259;\n    \n    uStack275 = 0;\n    uStack271 = 0;\n    uStack267 = 0;\n    uStack276 = 0;\n    uStack263 = 0;\n    uStack260 = 0;\n    uStack261 = 0;\n    puVar4 = &uStack259;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    *(puVar4 + 2) = 0;\n    fcn.00402910();\n    puStack296 = 0x403aaa;\n    fcn.00402f30(&uStack276, 5);\n    pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n    puStack296 = &uStack260;\n    puStack300 = 0x403ac4;\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    puStack296 = 0x403ad7;\n    (*_sym.imp.SHLWAPI.dll_SHDeleteKeyA)();\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    puStack300 = &stack0xfffffee4;\n    puStack296 = 0x10;\n    uStack304 = 1;\n    uStack308 = 0x41f9f8;\n    uStack312 = 0x41083c;\n    uStack316 = 0x80000000;\n    uStack320 = 0x403af7;\n    (*_sym.imp.SHLWAPI.dll_SHSetValueA)();\n    uStack320 = 0x4b;\n    uStack324 = 0x410870;\n    uStack328 = 1;\n    uStack332 = 0x41f9f8;\n    (*pcVar2)(0x80000000, &stack0xfffffedc);\n    (*pcVar1)(&uStack316, 0x4108bc, &uStack332);\n    (*pcVar2)(0x80000000, &uStack316, 0x4108f8, 1, 0x410900, 0x14);\n    return;\n}\n",
        "token_count": 642
    },
    "00403b50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\nchar * __cdecl fcn.00403b50(char *arg_8h, int32_t arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *pcVar4;\n    bool bVar5;\n    \n    pcVar2 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h != 0) {\n        if (arg_8h <= pcVar2) {\n            do {\n                if (*arg_8h == *arg_10h) {\n                    bVar5 = true;\n                    iVar1 = arg_14h;\n                    pcVar3 = arg_8h;\n                    pcVar4 = arg_10h;\n                    do {\n                        pcVar4 = pcVar4 + 1;\n                        pcVar3 = pcVar3 + 1;\n                        iVar1 = iVar1 + -1;\n                        if (iVar1 == 0) break;\n                        bVar5 = *pcVar3 == *pcVar4;\n                    } while (bVar5);\n                    if (bVar5) {\n                        return arg_8h;\n                    }\n                }\n                arg_8h = arg_8h + 1;\n            } while (arg_8h <= pcVar2);\n        }\n        arg_8h = NULL;\n    }\n    return arg_8h;\n}\n",
        "token_count": 311
    },
    "00404450": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool fcn.00404450(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *pvData;\n    \n    pvData = NULL;\n    iVar2 = fcn.00401570(&pvData);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (pvData == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = pvData;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4106d8, 0x410718, 1, pvData, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 249
    },
    "00402e70": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402f17) overlaps instruction at (ram,0x00402f13)\n// \n// WARNING: Removing unreachable block (ram,0x00402f03)\n// WARNING: Removing unreachable block (ram,0x00402f0d)\n\nbool __cdecl fcn.00402e70(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(arg_8h, arg_ch, 0, 0xf003f, &var_4h);\n    if (iVar1 == 0) {\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(var_4h, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(var_4h);\n        return iVar1 == 0;\n    }\n    return false;\n}\n",
        "token_count": 257
    },
    "00403310": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403310(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "00401650": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401650(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x406020, 0x41f9f8, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 140
    },
    "00401180": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401180(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4106d8, 0x41071c, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 80
    },
    "00402ce0": {
        "rules": [
            "get service handle",
            "delete service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402ce0(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar1);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 128
    },
    "00404560": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404560(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)(arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, arg_10h, 0, 0, 0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 138
    }
}