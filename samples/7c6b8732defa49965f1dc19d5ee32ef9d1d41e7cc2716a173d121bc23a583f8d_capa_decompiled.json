{
    "00401190": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00401190(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uchar uVar1;\n    uint32_t var_1c44h;\n    int32_t var_1c40h;\n    uint var_1c3ch;\n    uint var_1c38h;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    var_4h = 0x40119d;\n    fcn.004316c0();\n    var_8h = *0x45c1a8;\n    if (arg_14h != 0) {\n        for (var_4h = 0; var_4h < 0x1c2e; var_4h = var_4h + 1) {\n            *(&fcn.00401190::var_1c38h + var_4h) = var_4h;\n        }\n        var_1c44h = 0;\n        for (var_4h = 0; var_4h < 0x1c2e; var_4h = var_4h + 1) {\n            var_1c44h = (*(&fcn.00401190::var_1c38h + var_4h) + var_1c44h + *(arg_8h + (var_4h % arg_ch) * 2)) % 0x1c2e;\n            uVar1 = *(&fcn.00401190::var_1c38h + var_4h);\n            *(&fcn.00401190::var_1c38h + var_4h) = *(&fcn.00401190::var_1c38h + var_1c44h);\n            *(&fcn.00401190::var_1c38h + var_1c44h) = uVar1;\n        }\n        var_1c40h = 0;\n        var_1c44h = 0;\n        var_4h = 0;\n        while (arg_14h != 0) {\n            var_4h = (var_4h + 1) % 0x1c2e;\n            var_1c44h = (*(&fcn.00401190::var_1c38h + var_4h) + var_1c44h) % 0x1c2e;\n            uVar1 = *(&fcn.00401190::var_1c38h + var_4h);\n            *(&fcn.00401190::var_1c38h + var_4h) = *(&fcn.00401190::var_1c38h + var_1c44h);\n            *(&fcn.00401190::var_1c38h + var_1c44h) = uVar1;\n            *(arg_10h + var_1c40h) =\n                 *(arg_10h + var_1c40h) ^\n                 *(&fcn.00401190::var_1c38h +\n                  (*(&fcn.00401190::var_1c38h + var_4h) + *(&fcn.00401190::var_1c38h + var_1c44h)) % 0x1c2e);\n            var_1c40h = var_1c40h + 1;\n            arg_14h = arg_14h + -1;\n        }\n    }\n    var_4h = 0x40138a;\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 812
    },
    "00421170": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00421170(void)\n\n{\n    code *var_a4h;\n    uint var_a0h;\n    uint32_t var_9ch;\n    int32_t var_90h;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    var_a0h = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&var_a0h);\n    if ((var_90h == 2) && (4 < var_9ch)) {\n        var_a4h = fcn.004212a0;\n    }\n    else {\n        var_a4h = fcn.00421210;\n    }\n    fcn.004211f0(0x45b0bc, var_a4h);\n    (**0x45b0bc)();\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 196
    },
    "00421210": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00421210(void)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = *0x45c1a8;\n    var_4h = 0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetThreadLocale)();\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(uVar1, 0x1004, &var_10h, 7);\n    if (iVar2 != 0) {\n        for (var_18h = &var_10h; *var_18h != '\\0'; var_18h = var_18h + 1) {\n            var_4h = var_4h * 10 + -0x30 + *var_18h;\n        }\n    }\n    if (var_4h == 0) {\n        var_4h = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 260
    },
    "00421e40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n\nuint __cdecl fcn.00421e40(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint uVar3;\n    uint uVar4;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x44c74a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_4h = 0;\n    uVar4 = 0x2e;\n    iVar1 = fcn.00426400(0x2e);\n    if (iVar1 < 0) {\n        uVar3 = 0x44e78e;\n        fcn.00427020(0x44e78e);\n        var_4h = 0xffffffff;\n        fcn.004210d0(uVar3, uVar4, 1);\n    }\n    else {\n        iVar2 = fcn.00427100();\n        fcn.00426520(arg_8h, iVar2 - iVar1);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 311
    },
    "00421f30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n\nuint __fastcall fcn.00421f30(uint param_1)\n\n{\n    uint uVar1;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.00426ef0(param_1);\n    if (var_4h == 0) {\n        uVar1 = 0xffffffff;\n    }\n    else {\n        uVar1 = fcn.00426f40(&var_4h);\n    }\n    return uVar1;\n}\n",
        "token_count": 126
    },
    "00421f70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00421f70(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_eh;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    uStack12 = 0x44c764;\n    unique0x00005080 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_eh + 2;\n    var_4h = 1;\n    fcn.00427090(arg_8h);\n    fcn.00427090(&arg_ch);\n    fcn.00427090(&arg_10h);\n    iVar1 = (**(*(in_ECX + 0xf4) + 0x140))();\n    if (iVar1 == 1) {\n        fcn.00427090(in_ECX + 0x16c);\n        var_eh._0_1_ = 1;\n        var_4h = var_4h & 0xffffff00;\n        fcn.004210d0();\n        var_4h = 0xffffffff;\n        uVar2 = fcn.004210d0();\n        uVar2 = uVar2 & 0xffffff00 | var_eh;\n    }\n    else {\n        var_eh._1_1_ = 0;\n        var_4h = var_4h & 0xffffff00;\n        fcn.004210d0();\n        var_4h = 0xffffffff;\n        uVar2 = fcn.004210d0();\n        uVar2 = uVar2 & 0xffffff00 | var_eh._1_1_;\n    }\n    *in_FS_OFFSET = stack0xfffffff0;\n    return uVar2;\n}\n",
        "token_count": 420
    },
    "00422050": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00422050(uint arg_8h, int32_t arg_ch)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44c776;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00426fe0();\n    var_4h = 0;\n    if (arg_ch == 0) {\n        fcn.00427020(0x44e78f);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        fcn.004270b0(0x44e790);\n        if (arg_ch < 0xd8) {\n            if (arg_ch == 0xd7) {\n                fcn.004270b0(\"Cannot write to file (client)\");\n            }\n            else if (arg_ch - 2U < 0xd5) {\n    // switch table (213 cases) at 0x422406\n                switch(*(*(arg_ch + 0x422454) * 4 + 0x422406)) {\n                case 0x42212e:\n                    fcn.004270b0(\"Illegal operation\");\n                    break;\n                case 0x422140:\n                    fcn.004270b0(\"Not connected\");\n                    break;\n                case 0x422152:\n                    fcn.004270b0(\"Wrong CRC\");\n                    break;\n                case 0x422164:\n                    fcn.004270b0(\"Broken connection\");\n                    break;\n                case 0x422176:\n                    fcn.004270b0(\"User break (client)\");\n                    break;\n                case 0x422188:\n                    fcn.004270b0(\"Invalid handle (client)\");\n                    break;\n                case 0x42219a:\n                    fcn.004270b0(\"Client is not signed in\");\n                    break;\n                case 0x4221ac:\n                    fcn.004270b0(\"There is no assigned event handler (client)\");\n                    break;\n                case 0x4221be:\n                    fcn.004270b0(\"There is an error in the event handler (client)\");\n                    break;\n                case 0x4221d0:\n                    fcn.004270b0(\"Operation is already in progress (client)\");\n                    break;\n                case 0x4221e2:\n                    fcn.004270b0(\"Cannot get file information (client)\");\n                    break;\n                case 0x4221f4:\n                    fcn.004270b0(\"Cannot create folder (client)\");\n                    break;\n                case 0x422206:\n                    fcn.004270b0(\"Cannot delete folder (client)\");\n                    break;\n                case 0x422218:\n                    fcn.004270b0(\"Cannot delete file (client)\");\n                    break;\n                case 0x42222a:\n                    fcn.004270b0(\"Cannot rename folder (client)\");\n                    break;\n                case 0x42223c:\n                    fcn.004270b0(\"Cannot rename file (client)\");\n                    break;\n                case 0x42224e:\n                    fcn.004270b0(\"Cannot open file (client)\");\n                    break;\n                case 0x422260:\n                    fcn.004270b0(\"Cannot create file (client)\");\n                    break;\n                case 0x422272:\n                    fcn.004270b0(\"Cannot read from file (client)\");\n                }\n            }\n        }\n        else if (arg_ch - 0xd8U < 0x67) {\n    // switch table (103 cases) at 0x42252b\n            switch(*(*(arg_ch + 0x4224a3) * 4 + 0x42252b)) {\n            case 0x422296:\n                fcn.004270b0(\"Cannot rename temporary file (client)\");\n                break;\n            case 0x4222a8:\n                fcn.004270b0(\"Cannot start server\");\n                break;\n            case 0x4222ba:\n                fcn.004270b0(\"Access denied\");\n                break;\n            case 0x4222cc:\n                fcn.004270b0(\"User break (server)\");\n                break;\n            case 0x4222de:\n                fcn.004270b0(\"Invalid handle (server)\");\n                break;\n            case 0x4222f0:\n                fcn.004270b0(\"There is no assigned event handler (server)\");\n                break;\n            case 0x422302:\n                fcn.004270b0(\"There is an error in the event handler (server)\");\n                break;\n            case 0x422314:\n                fcn.004270b0(\"Operation is already in progress (server)\");\n                break;\n            case 0x422326:\n                fcn.004270b0(\"Cannot get file information (server)\");\n                break;\n            case 0x422338:\n                fcn.004270b0(\"Cannot create folder (server)\");\n                break;\n            case 0x42234a:\n                fcn.004270b0(\"Cannot delete folder (server)\");\n                break;\n            case 0x422359:\n                fcn.004270b0(\"Cannot delete file (server)\");\n                break;\n            case 0x422368:\n                fcn.004270b0(\"Cannot rename folder (server)\");\n                break;\n            case 0x422377:\n                fcn.004270b0(\"Cannot rename file (server)\");\n                break;\n            case 0x422386:\n                fcn.004270b0(\"Cannot open file (server)\");\n                break;\n            case 0x422395:\n                fcn.004270b0(\"Cannot create file (server)\");\n                break;\n            case 0x4223a4:\n                fcn.004270b0(\"Cannot read from file (server)\");\n                break;\n            case 0x4223b3:\n                fcn.004270b0(\"Cannot write to file (server)\");\n                break;\n            case 0x4223c2:\n                fcn.004270b0(\"Cannot rename temporary file (server)\");\n            }\n        }\n        fcn.00427000(&var_10h);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_ch;\n    return arg_8h;\n}\n",
        "token_count": 1436
    },
    "004225f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.004225f0(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint *in_FS_OFFSET;\n    uint *arg_8h_00;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44c788;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_8h != 0) {\n        arg_8h_00 = &var_10h;\n        uVar1 = fcn.00422050(arg_8h_00, arg_8h);\n        var_4h = 0;\n        uVar1 = fcn.004270d0(0, 0, arg_8h_00, arg_8h, uVar1);\n        fcn.00447450(uVar1);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 284
    },
    "00422e30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00422e30(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint arg_8h;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44c80a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00426fe0();\n    var_4h = 0;\n    iVar2 = (**(*(param_1 + 0x74) + 0x140))();\n    if (iVar2 == 1) {\n        cVar1 = fcn.00426890(param_1 + 0xec, 0x44eca2);\n        if (cVar1 == '\\0') {\n            fcn.00425d10(0);\n        }\n        else {\n            fcn.00425d10(2);\n            uVar3 = fcn.004270d0();\n            fcn.00425d40(uVar3);\n        }\n        fcn.00425d70(*(param_1 + 0xf0));\n        uVar3 = *(param_1 + 0xe8);\n        arg_8h = fcn.004270d0();\n        iVar2 = fcn.00425ca0(arg_8h, uVar3);\n        if (iVar2 == 0) {\n            uVar3 = fcn.00425ce0();\n            fcn.00426620(&var_10h, \"Error Code: %d\", uVar3);\n            uVar3 = fcn.004270d0(0, 0);\n            fcn.00447450(uVar3);\n        }\n        fcn.00422670();\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 479
    },
    "00423040": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423040(uint noname_0, uint *arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    *arg_ch = 0;\n    iVar1 = fcn.00421f30();\n    if (-1 < iVar1) {\n        iVar1 = fcn.00421ef0(iVar1);\n        if (iVar1 == 0) {\n            fcn.004234d0();\n        }\n        else {\n            fcn.00424750();\n        }\n    }\n    return;\n}\n",
        "token_count": 128
    },
    "00423320": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00423320(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint noname_3, uint arg_18h, uint arg_1ch)\n\n{\n    uint uVar1;\n    uint *in_FS_OFFSET;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    int32_t var_30h;\n    uint var_28h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44c850;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00426fe0();\n    var_4h = 0;\n    fcn.00426fe0();\n    var_4h = CONCAT31(var_4h._1_3_, 1);\n    var_40h = fcn.00426e30();\n    var_44h = 3;\n    var_3ch = 0;\n    var_18h = var_40h;\n    if (arg_ch == 0) {\n        var_28h = 1;\n        fcn.00426620(&var_48h, 0x44ecdc, arg_10h);\n    }\n    else {\n        var_28h = 0;\n        fcn.004270b0(0x44ecdb);\n    }\n    var_30h = arg_8h;\n    fcn.00426e90(&var_44h);\n    if (arg_8h == 0x44ece0) {\n        fcn.004270b0(0x44ece3);\n    }\n    else {\n        var_14h = arg_18h;\n        var_10h = arg_1ch;\n        fcn.00425f10(&var_14h, 0xffffffff);\n        uVar1 = fcn.004262d0(&var_54h, \"%m/%d/%Y %H:%M:%S\");\n        var_4h._0_1_ = 2;\n        fcn.00427090(uVar1);\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        fcn.004210d0();\n    }\n    uVar1 = fcn.004270d0();\n    fcn.0043e954(var_18h, 1, uVar1);\n    uVar1 = fcn.004270d0();\n    fcn.0043e954(var_18h, 2, uVar1);\n    var_4h = var_4h & 0xffffff00;\n    fcn.004210d0();\n    var_4h = 0xffffffff;\n    fcn.004210d0();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 717
    },
    "004234d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.004234d0(void)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_4h;\n    uint var_2ch;\n    uint var_18h;\n    uint *arg_8h;\n    uint uVar1;\n    uchar auStack88 [4];\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint uStack56;\n    uint uStack52;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch_2;\n    uint var_20h;\n    uchar *puStack32;\n    uchar *puStack28;\n    uint var_1ch;\n    int32_t var_10h_2;\n    uint var_14h;\n    uint var_10h;\n    int32_t var_4h_2;\n    \n    var_4h_2 = 0xffffffff;\n    var_10h = 0x44c87a;\n    var_14h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_14h;\n    puStack28 = auStack88;\n    uVar1 = 0x44ecf6;\n    uStack52 = fcn.00427020(0x44ecf6);\n    uStack56 = fcn.00421b50(&var_1ch, uVar1);\n    var_4h_2 = 0;\n    var_10h_2 = fcn.00421f30();\n    if (var_10h_2 < 0) {\n        var_4h_2 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        fcn.00442b06();\n        puStack32 = &stack0xffffffa0;\n        arg_8h = &var_1ch;\n        var_38h = fcn.00427000(arg_8h);\n        var_40h = fcn.00421b50(&var_20h, arg_8h);\n        var_4h_2._0_1_ = 1;\n        var_3ch = var_40h;\n        fcn.00427090(var_40h);\n        var_4h_2._0_1_ = 0;\n        fcn.004210d0();\n        var_48h = fcn.0043ebae(&var_2ch_2, var_10h_2, 0);\n        var_4h_2._0_1_ = 2;\n        var_44h = var_48h;\n        var_50h = fcn.00426650(&var_30h, &var_1ch, var_48h);\n        var_4h_2._0_1_ = 3;\n        var_4ch = var_50h;\n        fcn.00427090(var_50h);\n        var_4h_2._0_1_ = 2;\n        fcn.004210d0();\n        var_4h_2 = var_4h_2._1_3_ << 8;\n        fcn.004210d0();\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        fcn.00423210();\n        var_4h_2 = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_14h;\n    return;\n}\n",
        "token_count": 792
    },
    "00423640": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h_2\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00423640(void)\n\n{\n    char cVar1;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_4h_2;\n    uint var_34h;\n    uint var_18h;\n    uint var_14h;\n    uint var_4h;\n    uint *puVar3;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_44h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_30h;\n    uchar *var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_1dh;\n    uchar *var_2ch;\n    uint var_28h;\n    int32_t var_10h_2;\n    uint var_ch;\n    uint var_1ch;\n    int32_t var_4h_3;\n    uint var_14h_2;\n    \n    var_4h_3 = 0xffffffff;\n    var_1ch = 0x44c8a4;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00426fe0();\n    var_4h_3 = 0;\n    fcn.00442b06();\n    var_2ch = &stack0xffffff9c;\n    puVar3 = &var_28h;\n    fcn.00427000(puVar3);\n    uVar2 = fcn.00421c20(&var_1dh + 1, puVar3);\n    var_4h_3._0_1_ = 1;\n    fcn.00427090(uVar2);\n    var_4h_3 = var_4h_3._1_3_ << 8;\n    fcn.004210d0();\n    cVar1 = fcn.00426850(&var_28h, 0x44ecf7);\n    if (cVar1 == '\\0') {\n        for (var_10h_2 = fcn.00427100(); -1 < var_10h_2; var_10h_2 = var_10h_2 + -1) {\n            uVar2 = fcn.00426450(&var_38h, var_10h_2, 1);\n            var_1dh._0_1_ = fcn.00426850(uVar2, 0x44ecf8);\n            fcn.004210d0();\n            if (var_1dh != '\\0') break;\n        }\n        uVar2 = fcn.004265a0(&var_3ch, var_10h_2 + -1);\n        var_4h_3._0_1_ = 2;\n        fcn.00427090(uVar2);\n        var_4h_3._0_1_ = 0;\n        fcn.004210d0();\n        var_40h = &stack0xffffff88;\n        puVar3 = &var_28h;\n        fcn.00427000(puVar3);\n        uVar2 = fcn.00421cf0(&var_30h, puVar3);\n        var_4h_3._0_1_ = 3;\n        fcn.00427090(uVar2);\n        var_4h_3 = var_4h_3._1_3_ << 8;\n        fcn.004210d0();\n        uVar2 = fcn.004270d0();\n        fcn.004440c5(uVar2);\n        fcn.00423210();\n        var_4h_3 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        var_4h_3 = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 893
    },
    "004239e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004239e0(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    *(in_ECX + 0x2cd) = 0;\n    fcn.004225f0(arg_8h);\n    fcn.004228e0();\n    if (arg_8h < 1) {\n        fcn.00423210();\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "00423a20": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00423a20(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint extraout_ECX_02;\n    uint *in_FS_OFFSET;\n    uint var_14h_3;\n    uint var_20h;\n    uint var_14h_2;\n    uint var_4h_3;\n    uint var_4h_2;\n    uint var_68h;\n    uint var_40h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uchar *puVar6;\n    char *pcVar7;\n    uint uStack244;\n    uint var_e8h;\n    uint var_e4h;\n    uint var_e0h;\n    uint var_dch;\n    uint var_d8h;\n    uint var_d4h;\n    uint var_d0h;\n    uint var_cch;\n    uint var_c8h;\n    uint var_c4h;\n    uint var_c0h;\n    uint var_bch;\n    uint var_a0h;\n    uint var_9ch;\n    uint var_98h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_68h_4;\n    uint var_64h;\n    uint var_60h;\n    uchar *puStack96;\n    uint var_58h;\n    int32_t var_54h;\n    uint var_68h_3;\n    uint var_74h;\n    uchar *puStack76;\n    uchar *var_5ch;\n    uchar *var_68h_2;\n    uint var_6ch;\n    uint var_50h;\n    uchar *var_4ch;\n    uint var_30h;\n    int32_t var_2ch;\n    uchar auStack44 [4];\n    uchar auStack40 [4];\n    uchar *var_48h;\n    uchar *var_34h;\n    uchar *var_18h;\n    uint var_44h;\n    uint var_10h_2;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h_4;\n    \n    var_4h_4 = 0xffffffff;\n    uStack12 = 0x44c950;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.00423a20::var_ch;\n    fcn.00426fe0();\n    var_4h_4 = 0;\n    fcn.00426fe0();\n    var_4h_4._0_1_ = 1;\n    iVar2 = fcn.00426f80();\n    if (iVar2 == 0) {\n        var_4h_4 = var_4h_4._1_3_ << 8;\n        fcn.004210d0();\n        var_4h_4 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar3 = fcn.00421f30();\n        uStack244 = 0x423a9f;\n        iVar2 = fcn.00421ef0(uVar3);\n        if (iVar2 == 0) {\n            var_18h = &stack0xffffff0c;\n            fcn.00427020(0x44ed1c);\n            var_4h_4._0_1_ = 2;\n            var_34h = &stack0xffffff04;\n            pcVar7 = \"Rename folder\";\n            uVar3 = extraout_ECX;\n            fcn.00427020(\"Rename folder\");\n            var_4h_4._0_1_ = 1;\n            cVar1 = fcn.00421f70(&fcn.00423a20::var_44h, pcVar7, uVar3);\n            if (cVar1 == '\\0') {\n                var_4h_4 = var_4h_4._1_3_ << 8;\n                fcn.004210d0();\n                var_4h_4 = 0xffffffff;\n                fcn.004210d0();\n                goto code_r0x00423ede;\n            }\n            var_48h = &stack0xfffffef4;\n            puVar6 = &stack0xfffffef4;\n            uVar3 = extraout_ECX_00;\n            fcn.00422d90(&stack0xfffffef4);\n            uVar4 = fcn.00421b50(&stack0xffffffd8, puVar6);\n            var_4h_4._0_1_ = 3;\n            uVar3 = fcn.00426650(&stack0xffffffd4, uVar4, uVar3);\n            var_4h_4._0_1_ = 4;\n            fcn.00427090(uVar3);\n            var_4h_4._0_1_ = 3;\n            fcn.004210d0();\n            var_4h_4._0_1_ = 1;\n            fcn.004210d0();\n            fcn.004270d0();\n            uVar4 = 0;\n            uVar3 = fcn.00421f30();\n            uVar4 = fcn.0043ebae(&fcn.00423a20::var_30h, uVar3, uVar4);\n            var_4h_4._0_1_ = 5;\n            var_4ch = &stack0xfffffedc;\n            puVar6 = &stack0xfffffedc;\n            uVar3 = uVar4;\n            fcn.00422d90(&stack0xfffffedc);\n            uVar5 = fcn.00421b50(&fcn.00423a20::var_50h, puVar6);\n            var_4h_4._0_1_ = 6;\n            fcn.00426650(&fcn.00423a20::var_6ch, uVar5, uVar4);\n            var_4h_4._0_1_ = 7;\n            uVar4 = fcn.004270d0();\n            var_2ch = fcn.00425ed0(uVar4, uVar3);\n            var_4h_4._0_1_ = 6;\n            fcn.004210d0();\n            var_4h_4._0_1_ = 5;\n            fcn.004210d0();\n            var_4h_4 = CONCAT31(var_4h_4._1_3_, 1);\n            fcn.004210d0();\n            if (var_2ch == 0) {\n                uVar3 = fcn.00425ce0();\n                fcn.004225f0(uVar3);\n            }\n            else {\n                *(param_1 + 0x2d0) = 1;\n            }\n        }\n        else {\n            var_68h_2 = &stack0xffffff0c;\n            fcn.00427020(\"New name:\");\n            var_4h_4._0_1_ = 8;\n            var_5ch = &stack0xffffff04;\n            pcVar7 = \"Rename file\";\n            uVar3 = extraout_ECX_01;\n            fcn.00427020(\"Rename file\");\n            var_4h_4._0_1_ = 1;\n            cVar1 = fcn.00421f70(&fcn.00423a20::var_44h, pcVar7, uVar3);\n            if (cVar1 == '\\0') {\n                var_4h_4 = var_4h_4._1_3_ << 8;\n                fcn.004210d0();\n                var_4h_4 = 0xffffffff;\n                fcn.004210d0();\n                goto code_r0x00423ede;\n            }\n            puStack76 = &stack0xfffffef4;\n            puVar6 = &stack0xfffffef4;\n            uVar3 = extraout_ECX_02;\n            fcn.00422d90(&stack0xfffffef4);\n            uVar4 = fcn.00421b50(&fcn.00423a20::var_74h, puVar6);\n            var_4h_4._0_1_ = 9;\n            uVar3 = fcn.00426650(&fcn.00423a20::var_68h_3, uVar4, uVar3);\n            var_4h_4._0_1_ = 10;\n            fcn.00427090(uVar3);\n            var_4h_4._0_1_ = 9;\n            fcn.004210d0();\n            var_4h_4._0_1_ = 1;\n            fcn.004210d0();\n            fcn.004270d0();\n            uVar4 = 0;\n            uVar3 = fcn.00421f30();\n            uVar4 = fcn.0043ebae(&fcn.00423a20::var_58h, uVar3, uVar4);\n            var_4h_4._0_1_ = 0xb;\n            puStack96 = &stack0xfffffedc;\n            puVar6 = &stack0xfffffedc;\n            uVar3 = uVar4;\n            fcn.00422d90(&stack0xfffffedc);\n            uVar5 = fcn.00421b50(&fcn.00423a20::var_60h, puVar6);\n            var_4h_4._0_1_ = 0xc;\n            fcn.00426650(&fcn.00423a20::var_64h, uVar5, uVar4);\n            var_4h_4._0_1_ = 0xd;\n            uVar4 = fcn.004270d0();\n            var_54h = fcn.00425e90(uVar4, uVar3);\n            var_4h_4._0_1_ = 0xc;\n            fcn.004210d0();\n            var_4h_4._0_1_ = 0xb;\n            fcn.004210d0();\n            var_4h_4 = CONCAT31(var_4h_4._1_3_, 1);\n            fcn.004210d0();\n            if (var_54h == 0) {\n                uVar3 = fcn.00425ce0();\n                fcn.004225f0(uVar3);\n            }\n            else {\n                *(param_1 + 0x2d2) = 1;\n            }\n        }\n        fcn.004228e0();\n        var_4h_4 = var_4h_4 & 0xffffff00;\n        fcn.004210d0();\n        var_4h_4 = 0xffffffff;\n        fcn.004210d0();\n    }\ncode_r0x00423ede:\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 2485
    },
    "00423ef0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423ef0(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    *(in_ECX + 0x2d0) = 0;\n    fcn.004225f0(arg_8h);\n    fcn.004228e0();\n    if (arg_8h < 1) {\n        fcn.00423210();\n    }\n    return;\n}\n",
        "token_count": 101
    },
    "00423f30": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00423f30(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    *(in_ECX + 0x2d2) = 0;\n    fcn.004225f0(arg_8h);\n    fcn.004228e0();\n    if (arg_8h < 1) {\n        fcn.00423210();\n    }\n    return;\n}\n",
        "token_count": 101
    },
    "00423f70": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00423f70(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint extraout_ECX;\n    uint *in_FS_OFFSET;\n    uint var_64h;\n    uint var_60h;\n    uint var_40h;\n    uint var_34h;\n    uint var_30h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uchar *puVar3;\n    uint uVar4;\n    uint var_78h;\n    uint var_74h;\n    uint var_70h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch;\n    uint var_38h;\n    uchar *puStack56;\n    uint var_30h_2;\n    int32_t var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uchar *var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h_2;\n    uint var_10h_2;\n    uint var_ch;\n    uint uStack12;\n    uint32_t var_4h_2;\n    \n    var_4h_2 = 0xffffffff;\n    uStack12 = 0x44c99a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    fcn.00426fe0();\n    var_4h_2 = 0;\n    fcn.00426fe0();\n    var_4h_2._0_1_ = 1;\n    iVar1 = fcn.00426f80();\n    if (iVar1 == 0) {\n        var_4h_2 = var_4h_2._1_3_ << 8;\n        fcn.004210d0();\n        var_4h_2 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar2 = fcn.00421f30();\n        iVar1 = fcn.00421ef0(uVar2);\n        if (iVar1 == 0) {\n            uVar4 = 0;\n            uVar2 = fcn.00421f30();\n            uVar2 = fcn.0043ebae(&var_1ch, uVar2, uVar4);\n            var_4h_2._0_1_ = 2;\n            var_20h = &stack0xffffff6c;\n            puVar3 = &stack0xffffff6c;\n            fcn.00422d90(&stack0xffffff6c);\n            uVar4 = fcn.00421b50(&var_24h, puVar3);\n            var_4h_2._0_1_ = 3;\n            fcn.00426650(&var_28h, uVar4, uVar2);\n            var_4h_2._0_1_ = 4;\n            uVar2 = fcn.004270d0();\n            var_18h = fcn.00426140(uVar2);\n            var_4h_2._0_1_ = 3;\n            fcn.004210d0();\n            var_4h_2._0_1_ = 2;\n            fcn.004210d0();\n            var_4h_2 = CONCAT31(var_4h_2._1_3_, 1);\n            fcn.004210d0();\n            if (var_18h == 0) {\n                uVar2 = fcn.00425ce0();\n                fcn.004225f0(uVar2);\n            }\n            else {\n                *(param_1 + 0x2d1) = 1;\n            }\n        }\n        else {\n            uVar4 = 0;\n            uVar2 = fcn.00421f30();\n            fcn.0043ebae(&var_30h_2, uVar2, uVar4);\n            var_4h_2._0_1_ = 5;\n            puStack56 = &stack0xffffff6c;\n            puVar3 = &stack0xffffff6c;\n            uVar2 = extraout_ECX;\n            fcn.00422d90(&stack0xffffff6c);\n            uVar4 = fcn.00421b50(&var_38h, puVar3);\n            var_4h_2._0_1_ = 6;\n            fcn.00426650(&var_3ch, uVar4, uVar2);\n            var_4h_2._0_1_ = 7;\n            uVar2 = fcn.004270d0();\n            var_2ch = fcn.00426100(uVar2);\n            var_4h_2._0_1_ = 6;\n            fcn.004210d0();\n            var_4h_2._0_1_ = 5;\n            fcn.004210d0();\n            var_4h_2 = CONCAT31(var_4h_2._1_3_, 1);\n            fcn.004210d0();\n            if (var_2ch == 0) {\n                uVar2 = fcn.00425ce0();\n                fcn.004225f0(uVar2);\n            }\n            else {\n                *(param_1 + 0x2d3) = 1;\n            }\n        }\n        fcn.004228e0();\n        var_4h_2 = var_4h_2 & 0xffffff00;\n        fcn.004210d0();\n        var_4h_2 = 0xffffffff;\n        fcn.004210d0();\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 1333
    },
    "004241f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004241f0(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    *(in_ECX + 0x2d1) = 0;\n    fcn.004225f0(arg_8h);\n    fcn.004228e0();\n    if (arg_8h < 1) {\n        fcn.00423210();\n    }\n    return;\n}\n",
        "token_count": 101
    },
    "00424230": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00424230(int32_t arg_8h)\n\n{\n    int32_t in_ECX;\n    uint var_4h;\n    \n    *(in_ECX + 0x2d3) = 0;\n    fcn.004225f0(arg_8h);\n    fcn.004228e0();\n    if (arg_8h < 1) {\n        fcn.00423210();\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "00424270": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00424270(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint arg_8h;\n    uint *in_FS_OFFSET;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_214h;\n    uint var_210h;\n    uint var_20ch;\n    uint var_208h;\n    uint var_204h;\n    uint var_200h;\n    uint var_1fch;\n    uint var_1f8h;\n    uint var_1f4h;\n    uint var_1f0h;\n    uint var_1ech;\n    uint var_1e8h;\n    int32_t var_1e4h;\n    uint var_1e0h;\n    uint var_1dch;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44c9e6;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    var_10h = *0x45c1a8;\n    fcn.0043e367(1, 0x44ed50, 0, 0, 0, 0, 0);\n    var_4h = 0;\n    iVar1 = fcn.0043e139();\n    if (iVar1 == 1) {\n        uVar2 = fcn.0043e61e(&var_1e0h);\n        var_4h._0_1_ = 1;\n        fcn.00427090(uVar2);\n        var_4h._0_1_ = 0;\n        fcn.004210d0();\n        fcn.00422d90(&var_1e8h);\n        var_4h._0_1_ = 2;\n        fcn.0043e507(&var_1ech);\n        var_4h._0_1_ = 3;\n        uVar2 = fcn.004270d0();\n        arg_8h = fcn.004270d0();\n        var_1e4h = fcn.00426180(arg_8h, uVar2);\n        var_4h._0_1_ = 2;\n        fcn.004210d0();\n        var_4h._0_1_ = 0;\n        fcn.004210d0();\n        if (var_1e4h == 0) {\n            uVar2 = fcn.00425ce0();\n            fcn.004225f0(uVar2);\n        }\n        else {\n            *(param_1 + 0x2cf) = 1;\n            uVar2 = fcn.00422d90(&var_1f0h);\n            var_4h._0_1_ = 4;\n            fcn.00427090(uVar2);\n            var_4h._0_1_ = 0;\n            fcn.004210d0();\n            fcn.004266f0(&var_1f4h, param_1 + 0x2b4, 0x44ed54);\n            var_4h._0_1_ = 5;\n            uVar2 = fcn.004270d0();\n            fcn.004440c5(uVar2);\n            var_4h._0_1_ = 0;\n            fcn.004210d0();\n        }\n        fcn.00422670();\n        var_4h = 0xffffffff;\n        fcn.0043e326();\n    }\n    else {\n        var_4h = 0xffffffff;\n        fcn.0043e326();\n    }\n    *in_FS_OFFSET = var_ch;\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 869
    },
    "004245c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004245c0(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint arg_ch;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char var_1dh;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44ca22;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_8h == 0) {\n        fcn.004266f0(&var_10h, in_ECX + 0x2b4, 0x44ed70);\n        var_4h = 0;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar1 = fcn.00422050(&var_14h, arg_8h);\n        var_4h = 1;\n        arg_ch = fcn.004266f0(&var_18h, in_ECX + 0x2b4, 0x44ed7c);\n        var_4h._0_1_ = 2;\n        fcn.00426650(&var_1ch, arg_ch, uVar1);\n        var_4h._0_1_ = 3;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h._0_1_ = 2;\n        fcn.004210d0();\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        fcn.004210d0();\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *(in_ECX + 0x2cf) = 0;\n    fcn.004228e0();\n    uVar1 = fcn.00422d90(&var_24h);\n    var_1dh = fcn.00426830(in_ECX + 0x2b8, uVar1);\n    fcn.004210d0();\n    if (var_1dh != '\\0') {\n        fcn.00423210();\n    }\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 657
    },
    "00424750": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00424750(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint *in_FS_OFFSET;\n    uint var_4h_2;\n    uint var_210h;\n    uint var_20ch;\n    uint var_208h;\n    uint var_1f0h;\n    uint var_1e8h;\n    uint var_1e4h;\n    uint var_1e0h;\n    uint var_1dch;\n    uint var_10h;\n    uint var_4h;\n    uchar *puVar3;\n    uint *arg_10h;\n    uint *arg_ch;\n    uint uStack628;\n    uint arg_18h;\n    uint arg_1ch;\n    uint arg_20h;\n    uint uVar4;\n    uint var_238h;\n    uint var_234h;\n    uint var_230h;\n    uint var_22ch;\n    uint var_228h;\n    uint var_224h;\n    uint var_220h;\n    uint var_21ch;\n    uint var_218h;\n    uint var_214h;\n    uint var_204h;\n    uint var_200h;\n    uint var_1fch;\n    uchar *puStack508;\n    uint var_1f4h_2;\n    uchar *puStack500;\n    int32_t var_1f8h;\n    uint var_1f4h;\n    uint var_1e4h_3;\n    uint var_1e0h_2;\n    uint var_1dch_3;\n    uint var_1e4h_2;\n    uint var_1dch_2;\n    uint var_10h_2;\n    uint var_ch;\n    uint uStack12;\n    int32_t var_4h_3;\n    \n    var_4h_3 = 0xffffffff;\n    uStack12 = 0x44ca84;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.00424750::var_ch;\n    var_10h_2 = *0x45c1a8;\n    fcn.00426fe0();\n    var_4h_3 = 0;\n    fcn.00426fe0();\n    var_4h_3._0_1_ = 1;\n    iVar1 = fcn.00426f80();\n    if (iVar1 == 0) {\n        var_4h_3 = var_4h_3._1_3_ << 8;\n        fcn.004210d0();\n        var_4h_3 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar2 = fcn.00421f30();\n        iVar1 = fcn.00421ef0(uVar2);\n        if (iVar1 == 0) {\n            var_4h_3 = var_4h_3._1_3_ << 8;\n            fcn.004210d0();\n            var_4h_3 = 0xffffffff;\n            fcn.004210d0();\n        }\n        else {\n            uVar4 = 0;\n            uVar2 = fcn.00421f30();\n            uVar2 = fcn.0043ebae(&fcn.00424750::var_1f4h, uVar2, uVar4);\n            var_4h_3._0_1_ = 2;\n            fcn.00427090(uVar2);\n            var_4h_3._0_1_ = 1;\n            fcn.004210d0();\n            arg_20h = 0;\n            arg_1ch = 0;\n            arg_18h = 0;\n            uVar4 = 0;\n            uVar2 = fcn.004270d0();\n            fcn.0043e367(0, 0x44ed89, uVar2, uVar4, arg_18h, arg_1ch, arg_20h);\n            var_4h_3._0_1_ = 3;\n            iVar1 = fcn.0043e139();\n            if (iVar1 == 1) {\n                uStack628 = 0x4248fd;\n                fcn.00427090(&fcn.00424750::var_1e4h_3);\n                puStack500 = &stack0xfffffd8c;\n                puVar3 = &stack0xfffffd8c;\n                fcn.0043e507(&stack0xfffffd8c);\n                fcn.00421dc0(&fcn.00424750::var_1f4h_2, puVar3);\n                var_4h_3._0_1_ = 4;\n                fcn.004270d0();\n                arg_10h = &fcn.00424750::var_1e4h_3;\n                puStack508 = &stack0xfffffd80;\n                puVar3 = &stack0xfffffd80;\n                arg_ch = arg_10h;\n                fcn.00422d90(&stack0xfffffd80);\n                uVar2 = fcn.00421b50(&fcn.00424750::var_1fch, puVar3);\n                var_4h_3._0_1_ = 5;\n                fcn.00426650(&fcn.00424750::var_200h, uVar2, arg_10h);\n                var_4h_3._0_1_ = 6;\n                uVar2 = fcn.004270d0();\n                var_1f8h = fcn.004261f0(uVar2, arg_ch);\n                var_4h_3._0_1_ = 5;\n                fcn.004210d0();\n                var_4h_3._0_1_ = 4;\n                fcn.004210d0();\n                var_4h_3._0_1_ = 3;\n                fcn.004210d0();\n                if (var_1f8h == 0) {\n                    uVar2 = fcn.00425ce0();\n                    fcn.004225f0(uVar2);\n                }\n                else {\n                    *(param_1 + 0x2ce) = 1;\n                    fcn.004266f0(&fcn.00424750::var_204h, param_1 + 0x2b0, 0x44ed8c);\n                    var_4h_3._0_1_ = 7;\n                    uVar2 = fcn.004270d0();\n                    fcn.004440c5(uVar2);\n                    var_4h_3._0_1_ = 3;\n                    fcn.004210d0();\n                }\n                fcn.00422670();\n                var_4h_3._0_1_ = 1;\n                fcn.0043e326();\n                var_4h_3 = var_4h_3._1_3_ << 8;\n                fcn.004210d0();\n                var_4h_3 = 0xffffffff;\n                fcn.004210d0();\n            }\n            else {\n                var_4h_3._0_1_ = 1;\n                fcn.0043e326();\n                var_4h_3 = var_4h_3._1_3_ << 8;\n                fcn.004210d0();\n                var_4h_3 = 0xffffffff;\n                fcn.004210d0();\n            }\n        }\n    }\n    *in_FS_OFFSET = var_ch;\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1696
    },
    "00424b60": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00424b60(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint arg_ch;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint *arg_8h_00;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44caae;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_8h == 0) {\n        fcn.004266f0(&var_10h, in_ECX + 0x2b0, 0x44ed9c);\n        var_4h = 0;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        arg_8h_00 = &var_14h;\n        uVar1 = fcn.00422050(arg_8h_00, arg_8h);\n        var_4h = 1;\n        arg_ch = fcn.004266f0(&var_18h, in_ECX + 0x2b0, 0x44eda8);\n        var_4h._0_1_ = 2;\n        uVar1 = fcn.00426650(&var_1ch, arg_ch, uVar1);\n        var_4h._0_1_ = 3;\n        uVar1 = fcn.004270d0(arg_8h_00, arg_8h, uVar1);\n        fcn.004440c5(uVar1);\n        var_4h._0_1_ = 2;\n        fcn.004210d0();\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        fcn.004210d0();\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *(in_ECX + 0x2ce) = 0;\n    fcn.004228e0();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 620
    },
    "00424d40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h_4\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.00424d40(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint32_t arg_10h;\n    uint32_t extraout_ECX_01;\n    uint *in_FS_OFFSET;\n    uint var_24h;\n    uint var_18h_2;\n    uint var_4h_3;\n    uint var_4h_2;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uchar *arg_ch;\n    uchar *puVar4;\n    uchar *arg_ch_00;\n    char *arg_ch_01;\n    uint uStack220;\n    uint uVar5;\n    uint var_c0h;\n    uint var_bch;\n    uint var_b8h;\n    uint var_b4h;\n    uint var_b0h;\n    uint var_ach;\n    uint var_a8h;\n    uint var_a4h;\n    uint var_a0h;\n    uint var_9ch_2;\n    uint var_9ch;\n    uint var_98h;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_5ch_4;\n    uint var_5ch_3;\n    uchar var_58h [4];\n    uint var_70h;\n    uint var_50h;\n    uchar *var_4ch;\n    uint var_6ch;\n    uint var_68h;\n    uchar *var_5ch_2;\n    int32_t var_44h;\n    uint var_40h;\n    uint var_34h;\n    uchar *var_3ch;\n    uint8_t uStack41;\n    uchar *puStack40;\n    uchar *var_30h;\n    uchar auStack32 [4];\n    uchar var_18h_5 [3];\n    uint var_25h;\n    uint var_14h_3;\n    uint var_2ch;\n    uint var_18h_3;\n    int32_t var_14h_2;\n    uint var_4h_4;\n    \n    var_14h_2 = 0xffffffff;\n    var_18h_3 = 0x44cb2a;\n    var_2ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &fcn.00424d40::var_2ch;\n    fcn.00426fe0();\n    var_14h_2 = 0;\n    fcn.00426fe0();\n    var_14h_2._0_1_ = 1;\n    fcn.00426fe0();\n    var_14h_2._0_1_ = 2;\n    iVar2 = fcn.00426f80();\n    if (iVar2 == 0) {\n        var_14h_2._0_1_ = 1;\n        fcn.004210d0();\n        var_14h_2 = var_14h_2._1_3_ << 8;\n        fcn.004210d0();\n        var_14h_2 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar3 = fcn.00421f30();\n        iVar2 = fcn.00421ef0(uVar3);\n        if (iVar2 == 0) {\n            var_14h_2._0_1_ = 1;\n            fcn.004210d0();\n            var_14h_2 = var_14h_2._1_3_ << 8;\n            fcn.004210d0();\n            var_14h_2 = 0xffffffff;\n            fcn.004210d0();\n        }\n        else {\n            uVar5 = 0;\n            uVar3 = fcn.00421f30();\n            uVar3 = fcn.0043ebae(&stack0xffffffe0, uVar3, uVar5);\n            var_14h_2._0_1_ = 3;\n            uStack220 = 0x424e3d;\n            fcn.00427090(uVar3);\n            var_14h_2._0_1_ = 2;\n            uStack220 = 0x424e49;\n            fcn.004210d0();\n            var_30h = &stack0xffffff24;\n            fcn.00427020(\"Zip file name:\");\n            var_14h_2._0_1_ = 4;\n            puStack40 = &stack0xffffff1c;\n            arg_ch_01 = \"Zipping\";\n            uVar3 = extraout_ECX;\n            fcn.00427020(\"Zipping\");\n            var_14h_2._0_1_ = 2;\n            cVar1 = fcn.00421f70(&stack0xffffffe4, arg_ch_01, uVar3);\n            if (cVar1 == '\\0') {\n                var_14h_2._0_1_ = 1;\n                fcn.004210d0();\n                var_14h_2 = var_14h_2._1_3_ << 8;\n                fcn.004210d0();\n                var_14h_2 = 0xffffffff;\n                fcn.004210d0();\n            }\n            else {\n                var_3ch = &stack0xffffff0c;\n                puVar4 = &stack0xffffffe4;\n                uVar3 = extraout_ECX_00;\n                fcn.00427000(puVar4);\n                uVar5 = fcn.00421e40(&fcn.00424d40::var_34h, puVar4);\n                uStack41 = fcn.00426850(uVar5, uVar3);\n                fcn.004210d0();\n                arg_10h = uStack41;\n                if (arg_10h != 0) {\n                    uVar3 = fcn.004266f0(&fcn.00424d40::var_40h, &stack0xffffffe4, 0x44ede0);\n                    var_14h_2._0_1_ = 5;\n                    fcn.00427090(uVar3);\n                    var_14h_2._0_1_ = 2;\n                    fcn.004210d0();\n                    arg_10h = extraout_ECX_01;\n                }\n                var_5ch_2 = &stack0xffffff04;\n                puVar4 = &stack0xffffff04;\n                fcn.00422d90(&stack0xffffff04);\n                uVar3 = fcn.00421b50(&fcn.00424d40::var_68h, puVar4);\n                var_14h_2._0_1_ = 6;\n                fcn.00426650(&fcn.00424d40::var_6ch, uVar3, arg_10h);\n                var_14h_2._0_1_ = 7;\n                fcn.004270d0();\n                puVar4 = &stack0xffffffe4;\n                var_4ch = &stack0xfffffefc;\n                arg_ch = &stack0xfffffefc;\n                arg_ch_00 = puVar4;\n                fcn.00422d90(&stack0xfffffefc);\n                uVar3 = fcn.00421b50(&fcn.00424d40::var_50h, arg_ch);\n                var_14h_2._0_1_ = 8;\n                fcn.00426650(&fcn.00424d40::var_70h, uVar3, puVar4);\n                var_14h_2._0_1_ = 9;\n                uVar3 = fcn.004270d0();\n                var_44h = fcn.00426260(uVar3, arg_ch_00);\n                var_14h_2._0_1_ = 8;\n                fcn.004210d0();\n                var_14h_2._0_1_ = 7;\n                fcn.004210d0();\n                var_14h_2._0_1_ = 6;\n                fcn.004210d0();\n                var_14h_2._0_1_ = 2;\n                fcn.004210d0();\n                if (var_44h == 0) {\n                    uVar3 = fcn.00425ce0();\n                    fcn.004225f0(uVar3);\n                }\n                else {\n                    *(param_1 + 0x2d4) = 1;\n                    fcn.00427090(&stack0xffffffe4);\n                    uVar3 = fcn.00422d90(&stack0xffffffa8);\n                    var_14h_2._0_1_ = 10;\n                    fcn.00427090(uVar3);\n                    var_14h_2._0_1_ = 2;\n                    fcn.004210d0();\n                    fcn.004266f0(&fcn.00424d40::var_5ch_3, param_1 + 700, 0x44ede8);\n                    var_14h_2._0_1_ = 0xb;\n                    uVar3 = fcn.004270d0();\n                    fcn.004440c5(uVar3);\n                    var_14h_2._0_1_ = 2;\n                    fcn.004210d0();\n                }\n                fcn.00422670();\n                var_14h_2._0_1_ = 1;\n                fcn.004210d0();\n                var_14h_2 = var_14h_2._1_3_ << 8;\n                fcn.004210d0();\n                var_14h_2 = 0xffffffff;\n                fcn.004210d0();\n            }\n        }\n    }\n    *in_FS_OFFSET = var_2ch;\n    return;\n}\n",
        "token_count": 2284
    },
    "00425260": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00425260(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint arg_ch;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char var_1dh;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44cb66;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_8h == 0) {\n        fcn.004266f0(&var_10h, in_ECX + 700, 0x44ee04);\n        var_4h = 0;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar1 = fcn.00422050(&var_14h, arg_8h);\n        var_4h = 1;\n        arg_ch = fcn.004266f0(&var_18h, in_ECX + 700, 0x44ee10);\n        var_4h._0_1_ = 2;\n        fcn.00426650(&var_1ch, arg_ch, uVar1);\n        var_4h._0_1_ = 3;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h._0_1_ = 2;\n        fcn.004210d0();\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        fcn.004210d0();\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *(in_ECX + 0x2d4) = 0;\n    uVar1 = fcn.00422d90(&var_24h);\n    var_1dh = fcn.00426830(in_ECX + 0x2c0, uVar1);\n    fcn.004210d0();\n    if (var_1dh != '\\0') {\n        fcn.00423210();\n    }\n    fcn.004228e0();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 648
    },
    "004253f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1dh\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __fastcall fcn.004253f0(int32_t param_1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    uint extraout_ECX_00;\n    uint extraout_ECX_01;\n    uint *in_FS_OFFSET;\n    uint var_18h_2;\n    uint var_4h_3;\n    uint var_4h_2;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_24h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_4h;\n    uchar *arg_ch;\n    uint *puVar4;\n    char *arg_ch_00;\n    uint uVar5;\n    uint var_94h;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uchar *var_4ch_2;\n    int32_t var_34h;\n    uchar *puStack52;\n    uchar *puStack48;\n    uchar auStack44 [4];\n    uchar *var_38h;\n    char cStack33;\n    uchar auStack32 [4];\n    uint var_18h_4;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack12;\n    uchar var_18h_3 [3];\n    uint var_1dh;\n    \n    _var_18h_3 = 0xffffffff;\n    uStack12 = 0x44cbb8;\n    var_28h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_28h;\n    fcn.00426fe0();\n    _var_18h_3 = 0;\n    fcn.00426fe0();\n    var_18h_3[0] = 1;\n    fcn.00426fe0();\n    var_18h_3[0] = 2;\n    iVar2 = fcn.00426f80();\n    if (iVar2 == 0) {\n        var_18h_3[0] = 1;\n        fcn.004210d0();\n        _var_18h_3 = stack0xfffffff9 << 8;\n        fcn.004210d0();\n        _var_18h_3 = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar3 = fcn.00421f30();\n        iVar2 = fcn.00421ef0(uVar3);\n        if (iVar2 == 0) {\n            var_18h_3[0] = 1;\n            fcn.004210d0();\n            _var_18h_3 = stack0xfffffff9 << 8;\n            fcn.004210d0();\n            _var_18h_3 = 0xffffffff;\n            fcn.004210d0();\n        }\n        else {\n            uVar5 = 0;\n            uVar3 = fcn.00421f30();\n            uVar3 = fcn.0043ebae(auStack32, uVar3, uVar5);\n            var_18h_3[0] = 3;\n            fcn.00427090(uVar3);\n            var_18h_3[0] = 2;\n            fcn.004210d0();\n            var_38h = &stack0xffffff4c;\n            puVar4 = &var_18h_4;\n            uVar3 = extraout_ECX;\n            fcn.00427000(puVar4);\n            uVar5 = fcn.00421e40(auStack44, puVar4);\n            cStack33 = fcn.00426870(uVar5, uVar3);\n            fcn.004210d0();\n            if (cStack33 == '\\0') {\n                puStack48 = &stack0xffffff4c;\n                fcn.00427020(\"Extract to folder (leave blank for current):\");\n                var_18h_3[0] = 4;\n                puStack52 = &stack0xffffff44;\n                arg_ch_00 = \"Unzipping\";\n                uVar3 = extraout_ECX_00;\n                fcn.00427020(\"Unzipping\");\n                var_18h_3[0] = 2;\n                cVar1 = fcn.00421f70(&var_2ch, arg_ch_00, uVar3);\n                if (cVar1 == '\\0') {\n                    var_18h_3[0] = 1;\n                    fcn.004210d0();\n                    _var_18h_3 = stack0xfffffff9 << 8;\n                    fcn.004210d0();\n                    _var_18h_3 = 0xffffffff;\n                    fcn.004210d0();\n                }\n                else {\n                    fcn.004270d0();\n                    puVar4 = &var_18h_4;\n                    var_4ch_2 = &stack0xffffff30;\n                    arg_ch = &stack0xffffff30;\n                    uVar3 = extraout_ECX_01;\n                    fcn.00422d90(&stack0xffffff30);\n                    uVar5 = fcn.00421b50(&var_58h, arg_ch);\n                    var_18h_3[0] = 5;\n                    fcn.00426650(&var_5ch, uVar5, uVar3);\n                    var_18h_3[0] = 6;\n                    uVar3 = fcn.004270d0();\n                    var_34h = fcn.00426390(uVar3, puVar4);\n                    var_18h_3[0] = 5;\n                    fcn.004210d0();\n                    var_18h_3[0] = 2;\n                    fcn.004210d0();\n                    if (var_34h == 0) {\n                        uVar3 = fcn.00425ce0();\n                        fcn.004225f0(uVar3);\n                    }\n                    else {\n                        *(param_1 + 0x2d5) = 1;\n                        fcn.00427090(&var_18h_4);\n                        uVar3 = fcn.00422d90(&var_60h);\n                        var_18h_3[0] = 7;\n                        fcn.00427090(uVar3);\n                        var_18h_3[0] = 2;\n                        fcn.004210d0();\n                        fcn.004266f0(&var_64h, param_1 + 0x2c4, \": handshaking\");\n                        var_18h_3[0] = 8;\n                        uVar3 = fcn.004270d0();\n                        fcn.004440c5(uVar3);\n                        var_18h_3[0] = 2;\n                        fcn.004210d0();\n                    }\n                    fcn.00422670();\n                    var_18h_3[0] = 1;\n                    fcn.004210d0();\n                    _var_18h_3 = stack0xfffffff9 << 8;\n                    fcn.004210d0();\n                    _var_18h_3 = 0xffffffff;\n                    fcn.004210d0();\n                }\n            }\n            else {\n                var_18h_3[0] = 1;\n                fcn.004210d0();\n                _var_18h_3 = stack0xfffffff9 << 8;\n                fcn.004210d0();\n                _var_18h_3 = 0xffffffff;\n                fcn.004210d0();\n            }\n        }\n    }\n    *in_FS_OFFSET = var_28h;\n    return;\n}\n",
        "token_count": 1822
    },
    "00425860": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.00425860(int32_t arg_8h)\n\n{\n    uint uVar1;\n    uint arg_ch;\n    int32_t in_ECX;\n    uint *in_FS_OFFSET;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    char var_1dh;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44cbf4;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    if (arg_8h == 0) {\n        fcn.004266f0(&var_10h, in_ECX + 0x2c4, \" - Done.\");\n        var_4h = 0;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    else {\n        uVar1 = fcn.00422050(&var_14h, arg_8h);\n        var_4h = 1;\n        arg_ch = fcn.004266f0(&var_18h, in_ECX + 0x2c4, \" - Aborted: \");\n        var_4h._0_1_ = 2;\n        fcn.00426650(&var_1ch, arg_ch, uVar1);\n        var_4h._0_1_ = 3;\n        uVar1 = fcn.004270d0();\n        fcn.004440c5(uVar1);\n        var_4h._0_1_ = 2;\n        fcn.004210d0();\n        var_4h = CONCAT31(var_4h._1_3_, 1);\n        fcn.004210d0();\n        var_4h = 0xffffffff;\n        fcn.004210d0();\n    }\n    *(in_ECX + 0x2d5) = 0;\n    uVar1 = fcn.00422d90(&var_24h);\n    var_1dh = fcn.00426830(in_ECX + 0x2c8, uVar1);\n    fcn.004210d0();\n    if (var_1dh != '\\0') {\n        fcn.00423210();\n    }\n    fcn.004228e0();\n    *in_FS_OFFSET = var_ch;\n    return;\n}\n",
        "token_count": 653
    },
    "004262d0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004262d0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint in_ECX;\n    uint var_90h;\n    uint var_8ch;\n    uint var_88h;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_8h = *0x45c1a8;\n    if (arg_ch == 0) {\n        fcn.00427020(0);\n        goto code_r0x00426377;\n    }\n    var_4h = fcn.00432c74(in_ECX);\n    if (var_4h == 0) {\ncode_r0x0042634f:\n        var_88h._0_1_ = 0;\n    }\n    else {\n        iVar1 = fcn.00432c59(&var_88h, 0x80, arg_ch, var_4h);\n        if (iVar1 == 0) goto code_r0x0042634f;\n    }\n    fcn.00427020(&var_88h);\ncode_r0x00426377:\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 274
    },
    "00426400": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00426400(uint32_t arg_8h)\n\n{\n    uint32_t in_EAX;\n    uint32_t arg_ch;\n    uint arg_8h_00;\n    int32_t iVar1;\n    int32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_ch = in_EAX & 0xffffff00 | arg_8h & 0xff;\n    arg_8h_00 = fcn.004270d0();\n    var_ch = fcn.00426a40(arg_8h_00, arg_ch);\n    if (var_ch == 0) {\n        var_ch = -1;\n    }\n    else {\n        iVar1 = fcn.004270d0();\n        var_ch = var_ch - iVar1;\n    }\n    return var_ch;\n}\n",
        "token_count": 185
    },
    "00426450": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00426450(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint arg_10h_00;\n    uint in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    if (arg_10h < 0) {\n        arg_10h = 0;\n    }\n    iVar1 = fcn.00427100();\n    if (iVar1 < arg_ch + arg_10h) {\n        arg_10h = fcn.00427100();\n        arg_10h = arg_10h - arg_ch;\n    }\n    iVar1 = fcn.00427100();\n    if (iVar1 < arg_ch) {\n        arg_10h = 0;\n    }\n    if ((arg_ch == 0) && (iVar1 = fcn.00427100(),  arg_10h == iVar1)) {\n        fcn.00427000(in_ECX);\n        return arg_8h;\n    }\n    arg_10h_00 = fcn.004269b0();\n    iVar1 = fcn.004270d0();\n    fcn.004268d0(iVar1 + arg_ch, arg_10h, arg_10h_00);\n    return arg_8h;\n}\n",
        "token_count": 311
    },
    "00426520": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00426520(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_10h;\n    int32_t iVar2;\n    uint in_ECX;\n    int32_t arg_ch_00;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    iVar1 = fcn.00427100();\n    if (arg_ch < iVar1) {\n        arg_10h = fcn.004269b0();\n        arg_ch_00 = arg_ch;\n        iVar2 = fcn.004270d0();\n        fcn.004268d0((iVar2 + iVar1) - arg_ch, arg_ch_00, arg_10h);\n    }\n    else {\n        fcn.00427000(in_ECX);\n    }\n    return arg_8h;\n}\n",
        "token_count": 209
    },
    "004265a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004265a0(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    uint arg_10h;\n    uint arg_8h_00;\n    uint in_ECX;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_ch < 0) {\n        arg_ch = 0;\n    }\n    iVar1 = fcn.00427100();\n    if (arg_ch < iVar1) {\n        arg_10h = fcn.004269b0();\n        arg_8h_00 = fcn.004270d0();\n        fcn.004268d0(arg_8h_00, arg_ch, arg_10h);\n    }\n    else {\n        fcn.00427000(in_ECX);\n    }\n    return arg_8h;\n}\n",
        "token_count": 192
    },
    "00426930": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00426930(int32_t arg_8h, uint arg_ch)\n\n{\n    uint arg_8h_00;\n    uint arg_8h_01;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h == 0) {\n        fcn.00425fa0(0x80070057);\n    }\n    arg_8h_00 = fcn.00427890(arg_8h, arg_ch);\n    arg_8h_01 = fcn.004270e0(arg_8h_00);\n    fcn.004278b0(arg_8h_01, arg_8h, arg_ch);\n    fcn.00427560(arg_8h_00);\n    return;\n}\n",
        "token_count": 175
    },
    "00426a60": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00426a60(int32_t arg_8h, int32_t arg_ch, uint *arg_10h)\n\n{\n    int32_t arg_8h_00;\n    uint *in_ECX;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((arg_8h == 0) && (arg_ch != 0)) {\n        fcn.00425fa0(0x80070057);\n    }\n    arg_8h_00 = (***arg_10h)(arg_ch, 1);\n    if (arg_8h_00 == 0) {\n        fcn.00427980();\n    }\n    fcn.004276c0(arg_8h_00);\n    fcn.004274f0(arg_ch);\n    fcn.00427940(*in_ECX, arg_8h, arg_ch);\n    return in_ECX;\n}\n",
        "token_count": 202
    },
    "00426b50": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00426b50(int32_t param_1)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    if (param_1 == 0) {\n        var_8h = 0;\n    }\n    else {\n        var_8h = *(param_1 + 4);\n    }\n    return var_8h;\n}\n",
        "token_count": 83
    },
    "00427120": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.00427120(uint32_t arg_8h)\n\n{\n    uint32_t in_EAX;\n    uint var_ch;\n    uint var_8h;\n    uint var_1h;\n    \n    var_1h._0_1_ = 0;\n    if ((arg_8h != 0) && (in_EAX = arg_8h >> 0x10,  in_EAX == 0)) {\n        in_EAX = fcn.00427170(arg_8h & 0xffff);\n        var_1h._0_1_ = 1;\n    }\n    return in_EAX & 0xffffff00 | var_1h;\n}\n",
        "token_count": 178
    },
    "00427170": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427170(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    uint uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = fcn.00427540(arg_8h);\n    if (arg_8h_00 == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = fcn.004271b0(arg_8h_00, arg_8h);\n    }\n    return uVar1;\n}\n",
        "token_count": 128
    },
    "004271b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004271b0(uint arg_8h, uint arg_ch)\n\n{\n    uint16_t *puVar1;\n    uint arg_8h_00;\n    uint arg_8h_01;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    puVar1 = fcn.00427240(arg_8h, arg_ch);\n    if (puVar1 != NULL) {\n        arg_8h_00 = fcn.004278d0(puVar1 + 1, *puVar1);\n        arg_8h_01 = fcn.004270e0(arg_8h_00);\n        fcn.00427910(arg_8h_01, arg_8h_00, puVar1 + 1, *puVar1);\n        fcn.00427560(arg_8h_00);\n    }\n    return puVar1 != NULL;\n}\n",
        "token_count": 213
    },
    "00427240": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427240(uint hModule, uint32_t arg_ch)\n\n{\n    int32_t hResInfo;\n    uint uVar1;\n    uint var_4h;\n    \n    hResInfo = (*_sym.imp.KERNEL32.dll_FindResourceA)(hModule, (arg_ch >> 4) + 1 & 0xffff, 6);\n    if (hResInfo == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = fcn.00427290(hModule, hResInfo, arg_ch);\n    }\n    return uVar1;\n}\n",
        "token_count": 135
    },
    "00427290": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint16_t * __cdecl fcn.00427290(uint hModule, uint hResInfo, uint32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint16_t *puVar2;\n    uint hResData;\n    uint32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint16_t *var_4h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_LoadResource)(hModule, hResInfo);\n    if (iVar1 == 0) {\n        var_4h = NULL;\n    }\n    else {\n        var_4h = (*_sym.imp.KERNEL32.dll_LockResource)(iVar1);\n        if (var_4h == NULL) {\n            var_4h = NULL;\n        }\n        else {\n            iVar1 = (*_sym.imp.KERNEL32.dll_SizeofResource)(hModule, hResInfo);\n            puVar2 = var_4h + iVar1;\n            var_10h = arg_10h & 0xf;\n            for (; (var_10h != 0 && (var_4h < puVar2)); var_4h = var_4h + *var_4h + 1) {\n                var_10h = var_10h - 1;\n            }\n            if (var_4h < puVar2) {\n                if (*var_4h == 0) {\n                    var_4h = NULL;\n                }\n            }\n            else {\n                var_4h = NULL;\n            }\n        }\n    }\n    return var_4h;\n}\n",
        "token_count": 346
    },
    "00427440": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.00427440(uint32_t param_1)\n\n{\n    uint var_4h;\n    \n    return param_1 & 0xffffff00 | *(param_1 + 0xc) < 0;\n}\n",
        "token_count": 53
    },
    "00427480": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427480(int32_t arg_8h)\n\n{\n    uint uVar1;\n    \n    if (arg_8h == 0) {\n        uVar1 = 0;\n    }\n    else {\n        uVar1 = fcn.00431a40(arg_8h);\n    }\n    return uVar1;\n}\n",
        "token_count": 77
    },
    "004274f0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004274f0(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    if (-1 < arg_8h) {\n        iVar1 = fcn.00421150();\n        if (arg_8h <= *(iVar1 + 8)) goto code_r0x00427517;\n    }\n    fcn.00425fa0(0x80070057);\ncode_r0x00427517:\n    iVar1 = fcn.00421150();\n    *(iVar1 + 4) = arg_8h;\n    *(*in_ECX + arg_8h) = 0;\n    return;\n}\n",
        "token_count": 159
    },
    "004275b0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004275b0(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int32_t arg_8h_00;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        fcn.00427650();\n    }\n    else {\n        if (arg_8h == 0) {\n            fcn.00425fa0(0x80070057);\n        }\n        uVar1 = fcn.00427100();\n        iVar2 = fcn.004270d0();\n        arg_8h_00 = fcn.004270e0(arg_ch);\n        if (uVar1 < arg_8h - iVar2) {\n            fcn.00427940(arg_8h_00, arg_8h, arg_ch);\n        }\n        else {\n            fcn.00427960(arg_8h_00, arg_8h_00 + (arg_8h - iVar2), arg_ch);\n        }\n        fcn.00427560(arg_ch);\n    }\n    return;\n}\n",
        "token_count": 267
    },
    "00427650": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __fastcall fcn.00427650(uint param_1)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    int32_t **ppiVar3;\n    uint arg_8h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    ppiVar3 = fcn.00421150(param_1);\n    piVar1 = *ppiVar3;\n    if (ppiVar3[1] != NULL) {\n        cVar2 = fcn.00427440();\n        if (cVar2 == '\\0') {\n            fcn.00421110();\n            arg_8h = (**(*piVar1 + 0xc))();\n            fcn.004276c0(arg_8h);\n        }\n        else {\n            fcn.004274f0(0);\n        }\n    }\n    return;\n}\n",
        "token_count": 214
    },
    "004277a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __fastcall fcn.004277a0(uint32_t param_1)\n\n{\n    uint var_4h;\n    \n    return param_1 & 0xffffff00 | 1 < *(param_1 + 0xc);\n}\n",
        "token_count": 53
    },
    "004277c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t ** __cdecl fcn.004277c0(int32_t **arg_8h)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    uint arg_ch;\n    uint arg_8h_00;\n    int32_t arg_10h;\n    uint var_8h;\n    int32_t **var_4h;\n    \n    piVar2 = (**(**arg_8h + 0x10))();\n    cVar1 = fcn.00427440(piVar2, 0);\n    if ((cVar1 == '\\0') && (piVar2 == *arg_8h)) {\n        var_4h = arg_8h;\n        fcn.00427870();\n    }\n    else {\n        var_4h = (***piVar2)(arg_8h[1], 1);\n        if (var_4h == NULL) {\n            fcn.00427980();\n        }\n        var_4h[1] = arg_8h[1];\n        arg_10h = arg_8h[1] + 1;\n        arg_ch = fcn.004276e0();\n        arg_8h_00 = fcn.004276e0();\n        fcn.00427940(arg_8h_00, arg_ch, arg_10h);\n    }\n    return var_4h;\n}\n",
        "token_count": 331
    },
    "00427990": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427990(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    uint *puVar3;\n    int32_t arg_8h_00;\n    int32_t arg_10h;\n    uint arg_ch;\n    uint arg_8h_01;\n    int32_t *var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    ppiVar2 = fcn.00421150();\n    piVar1 = ppiVar2[1];\n    puVar3 = (**(**ppiVar2 + 0x10))();\n    arg_8h_00 = (***puVar3)(arg_8h, 1);\n    if (arg_8h_00 == 0) {\n        fcn.00427980();\n    }\n    var_1ch = piVar1;\n    if (arg_8h <= piVar1) {\n        var_1ch = arg_8h;\n    }\n    arg_10h = var_1ch + 1;\n    arg_ch = fcn.004276e0();\n    arg_8h_01 = fcn.004276e0();\n    fcn.00427940(arg_8h_01, arg_ch, arg_10h);\n    *(arg_8h_00 + 4) = piVar1;\n    fcn.00421110();\n    fcn.004276c0(arg_8h_00);\n    return;\n}\n",
        "token_count": 362
    },
    "00427a40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427a40(uint arg_8h)\n\n{\n    int32_t **ppiVar1;\n    int32_t arg_8h_00;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    ppiVar1 = fcn.00421150();\n    arg_8h_00 = (**(**ppiVar1 + 8))(ppiVar1, arg_8h, 1);\n    if (arg_8h_00 == 0) {\n        fcn.00427980();\n    }\n    fcn.004276c0(arg_8h_00);\n    return;\n}\n",
        "token_count": 150
    },
    "00427aa0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00427aa0(void)\n\n{\n    int32_t iVar1;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = 0xffffffff;\n    uStack12 = 0x44cc4a;\n    var_ch = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_ch;\n    iVar1 = fcn.00427b20(0x50);\n    var_4h = 0;\n    if (iVar1 == 0) {\n        var_18h = 0;\n    }\n    else {\n        var_18h = fcn.00425a20();\n    }\n    *in_FS_OFFSET = var_ch;\n    return var_18h;\n}\n",
        "token_count": 190
    },
    "00427f90": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nushort * __cdecl fcn.00427f90(ushort *arg_8h, int32_t arg_ch, uint arg_10h, uint CodePage)\n\n{\n    int32_t iVar1;\n    uint var_4h;\n    \n    if ((arg_8h == NULL) || (arg_ch == 0)) {\n        arg_8h = NULL;\n    }\n    else {\n        *arg_8h = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(CodePage, 0, arg_ch, 0xffffffff, arg_8h, arg_10h);\n        if (iVar1 == 0) {\n            arg_8h = NULL;\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 166
    },
    "0042816f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t fcn.0042816f(int32_t param_1, int32_t param_2)\n\n{\n    uint16_t *puVar1;\n    uint16_t uVar2;\n    \n    if (param_2 == 0) {\n        puVar1 = param_1 + 0x12;\n    }\n    else {\n        puVar1 = param_1 + 0x18;\n    }\n    if (*puVar1 == 0xffff) {\n        puVar1 = puVar1 + 2;\n    }\n    else {\n        do {\n            uVar2 = *puVar1;\n            puVar1 = puVar1 + 1;\n        } while (uVar2 != 0);\n    }\n    if (*puVar1 == 0xffff) {\n        puVar1 = puVar1 + 2;\n    }\n    else {\n        do {\n            uVar2 = *puVar1;\n            puVar1 = puVar1 + 1;\n        } while (uVar2 != 0);\n    }\n    uVar2 = *puVar1;\n    if ((uVar2 != 0) && (param_2 == 0)) {\n        uVar2 = uVar2 - 2;\n    }\n    return puVar1 + uVar2 + 5 & 0xfffffffc;\n}\n",
        "token_count": 287
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl method.COccManager.virtual_16(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int16_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint16_t *puVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    int32_t *in_ECX;\n    int32_t iVar8;\n    uint *puVar9;\n    uint uVar10;\n    uint32_t uVar11;\n    uint8_t uVar12;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar2 = arg_8h;\n    puVar5 = arg_ch + 0x10;\n    if (*(arg_ch + 2) != -1) {\n        puVar5 = arg_ch + 8;\n    }\n    iVar3 = fcn.004335fc(*puVar5 * 4 + 4);\n    arg_8h[1] = iVar3;\n    if (iVar3 != 0) {\n        iVar3 = (**(*in_ECX + 0x18))(arg_ch, iVar3);\n        *arg_8h = iVar3;\n        puVar4 = fcn.004280ea(arg_ch);\n        iVar1 = *(arg_ch + 2);\n        puVar5 = arg_ch + 0x10;\n        if (iVar1 != -1) {\n            puVar5 = arg_ch + 8;\n        }\n        uVar11 = *puVar5;\n        iVar6 = fcn.0043f71e(uVar11 << 3);\n        iVar8 = uVar11 << 3;\n        arg_8h[3] = iVar6;\n        fcn.00433ba0(iVar6, 0, iVar8);\n        arg_8h = NULL;\n        piVar2[2] = uVar11;\n        if (uVar11 != 0) {\n            do {\n                puVar7 = fcn.0042816f(iVar8, iVar1 == -1, puVar4);\n                iVar6 = arg_8h * 8;\n                if (iVar1 == -1) {\n                    *(iVar6 + piVar2[3]) = puVar4[5];\n                    puVar9 = puVar4 + 6;\n                    uVar12 = puVar4[2];\n                }\n                else {\n                    *(iVar6 + piVar2[3]) = *(puVar4 + 4);\n                    puVar9 = puVar4 + 0x12;\n                    uVar12 = *puVar4;\n                }\n                if (((*puVar9 == -1) && (*(puVar9 + 2) == 0x80)) && ((uVar12 & 0xf) == 9)) {\n                    uVar10 = 1;\n                }\n                else {\n                    uVar10 = 0;\n                }\n                arg_8h = arg_8h + 1;\n                *(piVar2[3] + 4 + iVar6) = uVar10;\n                puVar4 = puVar7;\n            } while (arg_8h < uVar11);\n        }\n        if (iVar3 == 0) {\n            iVar3 = arg_ch;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 725
    },
    "00428646": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00428646(int32_t arg_8h)\n\n{\n    int16_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    \n    iVar3 = arg_8h;\n    if (*(arg_8h + 0x48) != 0) {\n        arg_8h = *(*(arg_8h + 0x48) + 0x40);\n        while (arg_8h != 0) {\n            piVar4 = fcn.0042964f(&arg_8h);\n            iVar2 = *piVar4;\n            if (*(iVar2 + 4) != 0) {\n                iVar5 = *(*(iVar2 + 4) + 0x90);\n                while (iVar5 != 0) {\n                    fcn.0042c3bc(*(iVar2 + 4));\n                    if (*(iVar5 + 4) != 0) {\n                        iVar5 = fcn.00443fc2(*(iVar5 + 4));\n                        fcn.0042ddaf(*(iVar5 + 0x4c));\n                    }\n                    iVar5 = fcn.0042c3c5();\n                }\n                iVar1 = *(*(iVar2 + 4) + 0x94);\n                if (iVar1 != 0) {\n                    iVar5 = fcn.00443fc2(iVar1);\n                    (**(**(iVar5 + 0x4c) + 0xb4))();\n                    *(*(iVar2 + 4) + 0x94) = *(iVar5 + 0x4c);\n                    (**(**(*(iVar5 + 0x4c) + 0x8c) + 8))(*(iVar2 + 4), 1);\n                }\n            }\n        }\n        arg_8h = *(*(iVar3 + 0x48) + 0x40);\n        while (arg_8h != 0) {\n            piVar4 = fcn.0042964f(&arg_8h);\n            iVar3 = *(*piVar4 + 4);\n            if ((iVar3 != 0) && (*(iVar3 + 0x8c) != 0)) {\n                (**(**(iVar3 + 0x8c) + 0xc))();\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 520
    },
    "00428c3a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.00428c3a(void)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint lpVersionInformation;\n    uint var_94h;\n    uint var_88h;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    puVar2 = &var_94h;\n    for (iVar1 = 0x24; iVar1 != 0; iVar1 = iVar1 + -1) {\n        *puVar2 = 0;\n        puVar2 = puVar2 + 1;\n    }\n    lpVersionInformation = 0x94;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&lpVersionInformation);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 173
    },
    "00428ecd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_48h\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl\nfcn.00428ecd(int32_t *arg_8h, int32_t arg_ch, uint noname_2, uint noname_3, uint32_t arg_18h, uint32_t *arg_1ch, \n            uint *arg_20h, uint noname_7, int32_t *arg_28h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint16_t *puVar4;\n    code *pcVar5;\n    int32_t *piVar6;\n    uint32_t *puVar7;\n    uint *puVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t *piVar11;\n    uint var_48h;\n    uint *var_44h;\n    uint *var_40h;\n    uint *var_34h;\n    uint var_30h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    \n    puVar7 = arg_1ch;\n    piVar6 = arg_8h;\n    iVar10 = 0;\n    var_30h._0_2_ = 0;\n    if (arg_8h == NULL) {\n        return -0x7ff8ffa9;\n    }\n    if (arg_1ch == NULL) {\n        return -0x7ffdfff8;\n    }\n    uVar2 = arg_1ch[2];\n    if (5 < uVar2) {\n        return -0x7ffdfff2;\n    }\n    arg_8h = NULL;\n    if (arg_1ch[3] != 0) {\n        arg_1ch = arg_1ch[1];\n        do {\n            uVar3 = *arg_1ch;\n            if (uVar2 <= uVar3) {\n                return -0x7ffdfff2;\n            }\n            arg_1ch = arg_1ch + 1;\n            arg_8h = arg_8h + 1;\n            (&var_44h)[uVar3] = *puVar7 + iVar10;\n            iVar10 = iVar10 + 0x10;\n        } while (arg_8h < puVar7[3]);\n    }\n    if (arg_8h < uVar2) {\n        iVar10 = arg_8h * 0x10 + *puVar7;\n        iVar9 = uVar2 - arg_8h;\n        piVar11 = &var_48h + (uVar2 - arg_8h);\n        do {\n            *piVar11 = iVar10;\n            iVar10 = iVar10 + 0x10;\n            piVar11 = piVar11 + -1;\n            iVar9 = iVar9 + -1;\n        } while (iVar9 != 0);\n    }\n    iVar10 = -0x7ffdfffd;\n    if (arg_28h == NULL) {\n        arg_28h = &arg_18h;\n    }\n    if (arg_20h == NULL) {\n        arg_20h = &var_30h;\n    }\n    (*_sym.imp.OLEAUT32.dll_VariantClear)(&var_10h);\n    pcVar5 = _sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime;\n    if (0x12 < arg_ch + 0x139aU) goto code_r0x00429455;\n    // switch table (19 cases) at 0x429468\n    switch(*((arg_ch + 0x139aU) * 4 + 0x429468)) {\n    case 0x428fb2:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 100))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3]);\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x428fdb:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x00429001;\n                var_44h = &var_10h;\n            }\n            arg_18h = var_44h[2];\n            if (*var_40h != 3) {\n                iVar10 = (*pcVar5)(&var_10h, var_40h, 0, 3);\n                if (iVar10 < 0) {\ncode_r0x0042902f:\n                    *arg_28h = 1;\n                    goto code_r0x00429455;\n                }\n                var_40h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x60))(piVar6, arg_18h, var_40h[2], arg_20h);\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x429052:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x00429001;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x5c))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h);\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x42909b:\n        if (puVar7[2] == 5) {\n            iVar10 = 0;\n            do {\n                puVar4 = (&var_44h)[iVar10];\n                uVar1 = *puVar4;\n                if (((uVar1 & 0x4000) == 0) || ((uVar1 & 0xf) == 0)) {\n                    *arg_28h = iVar10;\n                    break;\n                }\n                if ((uVar1 & 0xc) == 0) {\n                    iVar9 = *(puVar4 + 4);\n                }\n                else {\n                    (*_sym.imp.OLEAUT32.dll_VariantCopy)(*(puVar4 + 4));\n                    puVar4 = (&var_44h)[iVar10];\n                    **(puVar4 + 4) = 3;\n                    iVar9 = *(puVar4 + 4) + 8;\n                }\n                (&var_20h)[iVar10] = iVar9;\n                iVar10 = iVar10 + 1;\n            } while (iVar10 < 4);\n            iVar10 = (**(*piVar6 + 0x58))\n                               (piVar6, var_20h, var_1ch, var_18h, var_14h, *var_34h, var_34h[1], var_34h[2], var_34h[3]\n                               );\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x429111:\n        if (puVar7[2] == 2) {\n            if (*var_44h != 3) {\n                iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_44h, 0, 3);\n                if (iVar10 < 0) goto code_r0x00429001;\n                var_44h = &var_10h;\n            }\n            iVar10 = (**(*piVar6 + 0x54))(piVar6, var_44h[2], *var_40h, var_40h[1], var_40h[2], var_40h[3]);\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x42915b:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x50))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\ncode_r0x0042917e:\n            if (-1 < iVar10) {\n                *arg_20h = 8;\n            }\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x429195:\n        iVar10 = (**(*piVar6 + 0x4c))(piVar6, arg_20h);\n        goto code_r0x00429455;\n    case 0x4291a3:\n        iVar10 = (**(*piVar6 + 0x48))(piVar6, arg_20h);\n        goto code_r0x00429455;\n    case 0x4291b1:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x44))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0042917e;\n        }\n        break;\n    case 0x4291d6:\n        if (puVar7[2] == 2) {\n            uVar1 = *var_44h;\n            if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {\n                iVar10 = -0x7ffdfffb;\ncode_r0x00429001:\n                *arg_28h = 0;\n                goto code_r0x00429455;\n            }\n            if (uVar1 == 0x400c) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h[2]);\n                *var_44h[2] = 8;\n                puVar8 = var_44h[2] + 8;\n            }\n            else if (uVar1 == 0x4008) {\n                puVar8 = var_44h[2];\n            }\n            else {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(var_44h);\n                puVar8 = var_44h + 2;\n                *var_44h = 8;\n            }\n            iVar10 = (**(*piVar6 + 0x40))(piVar6, puVar8, *var_40h, var_40h[1], var_40h[2], var_40h[3], arg_20h + 2);\n            goto code_r0x0042924c;\n        }\n        break;\n    case 0x429263:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x3c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0042917e;\n        }\n        break;\n    case 0x42928b:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x38))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x4292af:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x34))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h);\n            goto code_r0x00429455;\n        }\n        break;\n    case 0x4292d3:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x30))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0042917e;\n        }\n        break;\n    case 0x4292fb:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x0042937f;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x0042902f;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x6c))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x00429455;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x2c))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0042917e;\n        }\n        break;\n    case 0x42937f:\ncode_r0x0042937f:\n        if ((arg_18h & 2) == 0) {\n            if ((arg_18h & 4) == 0) goto code_r0x00429403;\n            if (puVar7[2] == 2) {\n                var_20h = *var_44h;\n                var_1ch = var_44h[1];\n                var_18h = var_44h[2];\n                var_14h = var_44h[3];\n                if (*var_40h != 8) {\n                    iVar10 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(&var_10h, var_40h, 0, 3);\n                    if (iVar10 < 0) goto code_r0x0042902f;\n                    var_40h = &var_10h;\n                }\n                iVar10 = (**(*piVar6 + 0x68))(piVar6, var_20h, var_1ch, var_18h, var_14h, var_40h[2]);\n                goto code_r0x00429455;\n            }\n        }\n        else if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x28))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x0042917e;\n        }\n        break;\n    case 0x429403:\ncode_r0x00429403:\n        if (puVar7[2] == 1) {\n            iVar10 = (**(*piVar6 + 0x24))(piVar6, *var_44h, var_44h[1], var_44h[2], var_44h[3], arg_20h + 2);\n            goto code_r0x00429447;\n        }\n        break;\n    case 0x429428:\n        iVar10 = (**(*piVar6 + 0x20))(piVar6, arg_20h + 2);\ncode_r0x0042924c:\n        if (-1 < iVar10) {\n            *arg_20h = 3;\n        }\n        goto code_r0x00429455;\n    case 0x42943a:\n        iVar10 = (**(*piVar6 + 0x1c))(piVar6, arg_20h + 2);\ncode_r0x00429447:\n        if (-1 < iVar10) {\n            *arg_20h = 9;\n        }\n        goto code_r0x00429455;\n    }\n    iVar10 = -0x7ffdfff2;\ncode_r0x00429455:\n    (*_sym.imp.OLEAUT32.dll_VariantCopy)(&var_10h);\n    return iVar10;\n}\n",
        "token_count": 3833
    },
    "004294b4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n\nuint __cdecl fcn.004294b4(uint noname_0, int32_t arg_ch, uint32_t arg_10h, uint noname_3, int32_t arg_18h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_1h;\n    \n    uVar3 = 0;\n    if (arg_10h != 0) {\n        do {\n            bVar1 = false;\n            uVar4 = 0;\n            do {\n                iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpW)(*(arg_ch + uVar3 * 4), *(uVar4 + 0x45b3a8));\n                if (iVar2 == 0) {\n                    bVar1 = true;\n                    *(arg_18h + uVar3 * 4) = *(uVar4 + 0x45b358);\n                }\n                uVar4 = uVar4 + 4;\n            } while (uVar4 < 0x4c);\n            if (!bVar1) {\n                return 0x80020006;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < arg_10h);\n    }\n    return 0;\n}\n",
        "token_count": 305
    },
    "00429537": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00429537(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    uVar1 = (**(**(param_1 + 0xc) + 0xc))(*(param_1 + 0xc), 0);\n    return uVar1;\n}\n",
        "token_count": 88
    },
    "0042954c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042954c(int32_t arg_8h, int32_t **arg_ch, int32_t *arg_10h, int32_t **arg_14h)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    \n    if ((arg_8h == 0) || (arg_ch == NULL)) {\n        iVar3 = -0x7ff8ffa9;\n    }\n    else if (arg_14h == NULL) {\n        iVar3 = -0x7fffbffd;\n    }\n    else {\n        *arg_14h = NULL;\n        if ((((*arg_10h == 0) && (arg_10h[1] == 0)) && (arg_10h[2] == 0xc0)) && (arg_10h[3] == 0x46000000)) {\ncode_r0x004295fc:\n            piVar4 = arg_ch[1] + arg_8h;\n            (**(*piVar4 + 4))(piVar4);\n            *arg_14h = piVar4;\n            iVar3 = 0;\n        }\n        else {\n            piVar4 = arg_ch[2];\n            while (piVar4 != NULL) {\n                piVar2 = *arg_ch;\n                if ((piVar2 == NULL) ||\n                   (((*piVar2 == *arg_10h && (piVar2[1] == arg_10h[1])) &&\n                    ((piVar2[2] == arg_10h[2] && (piVar2[3] == arg_10h[3])))))) {\n                    if (piVar4 == 0x1) goto code_r0x004295fc;\n                    iVar3 = (*piVar4)(arg_8h, arg_10h, arg_14h, arg_ch[1]);\n                    if (iVar3 == 0) {\n                        return 0;\n                    }\n                    if ((piVar2 != NULL) && (iVar3 < 0)) {\n                        return iVar3;\n                    }\n                }\n                ppiVar1 = arg_ch + 5;\n                arg_ch = arg_ch + 3;\n                piVar4 = *ppiVar1;\n            }\n            iVar3 = -0x7fffbffe;\n        }\n    }\n    return iVar3;\n}\n",
        "token_count": 525
    },
    "00446820": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00446820(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 4) == 0) {\n        return 0;\n    }\n    uVar1 = fcn.004467f6();\n    uVar1 = (*_sym.imp.GDI32.dll_DeleteObject)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 87
    },
    "004299db": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_14h\n\nbool fcn.004299db(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t *piVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    piVar3 = extraout_ECX + 0x12;\n    iVar1 = *piVar3;\n    *(unaff_EBP + -0x10) = &var_14h;\n    *(unaff_EBP + -0x14) = extraout_ECX;\n    if (((iVar1 == 0) && (iVar1 = (**(*extraout_ECX + 0x124))(piVar3),  iVar1 != 0)) && (*piVar3 == 0)) {\n        *(unaff_EBP + -4) = 0;\n        iVar1 = fcn.004499e7();\n        iVar1 = (**(**(iVar1 + 0x1038) + 8))(extraout_ECX);\n        *piVar3 = iVar1;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    piVar3 = extraout_ECX;\n    if (extraout_ECX[0x12] != 0) {\n        while ((piVar3[0xe] & 0x100U) == 0) {\n            piVar3[0xe] = piVar3[0xe] | 0x100;\n            uVar2 = (*_sym.imp.USER32.dll_GetParent)(piVar3[7]);\n            piVar3 = fcn.00442089(uVar2);\n            piVar4 = piVar3;\n            if (piVar3 != NULL) {\n                piVar4 = piVar3[7];\n            }\n            uVar5 = (*_sym.imp.USER32.dll_GetWindowLongA)(piVar4, 0xfffffff0);\n            if (((uVar5 & 0x40000000) == 0) || (piVar3 == NULL)) break;\n        }\n    }\n    iVar1 = extraout_ECX[0x12];\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1 != 0;\n}\n",
        "token_count": 562
    },
    "00429a9b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_14h\n\nvoid fcn.00429a9b(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x18) = extraout_ECX;\n    *extraout_ECX = vtable.COleControlContainer.0;\n    pcVar1 = extraout_ECX[0x10];\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x10) = pcVar1;\n    while (pcVar1 != NULL) {\n        *(unaff_EBP + -0x14) = pcVar1;\n        piVar3 = fcn.0042964f();\n        iVar4 = *piVar3;\n        iVar2 = *(iVar4 + 4);\n        if ((iVar2 != 0) && (*(iVar2 + 0x8c) == 0)) {\n            fcn.0043ee7f();\n            fcn.00429674();\n            fcn.0043f749(iVar4);\n        }\n        pcVar1 = *(unaff_EBP + -0x10);\n    }\n    pcVar1 = extraout_ECX[0x12];\n    while (pcVar1 != NULL) {\n        iVar4 = fcn.0043ee5b();\n        if (iVar4 != 0) {\n            fcn.00429674();\n            fcn.0043f749(iVar4);\n        }\n        pcVar1 = extraout_ECX[0x12];\n    }\n    fcn.0043f266();\n    fcn.0044a882(extraout_ECX + 0x18);\n    *(unaff_EBP + -4) = 1;\n    fcn.0043ef01();\n    *(unaff_EBP + -4) = 0;\n    fcn.0043f404();\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043fd45();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 587
    },
    "00429eae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00429eae(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    var_4h = *(in_ECX + 0x40);\n    while (var_4h != 0) {\n        piVar1 = fcn.0042964f(&var_4h);\n        if (*(*piVar1 + 4) != 0) {\n            fcn.0042b88f(arg_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 129
    },
    "0042b088": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.0042b088(int32_t param_1, uint32_t *param_2)\n\n{\n    int32_t iVar1;\n    uint32_t in_EAX;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    \n    if (*(param_1 + 0x1c) == '\\0') {\n        iVar1 = *(*(param_1 + 0x14) + 8);\n        in_EAX = *param_2;\n        if (in_EAX <= *(param_1 + 0xc) + -1 + iVar1) {\n            in_EAX = in_EAX - iVar1;\n            *param_2 = in_EAX;\ncode_r0x0042b0d4:\n            return CONCAT31(in_EAX >> 8, 1);\n        }\n    }\n    else {\n        uVar3 = 0;\n        if (*(param_1 + 0xc) != 0) {\n            in_EAX = *param_2;\n            puVar2 = *(param_1 + 0x14) + 8;\n            do {\n                if (*puVar2 == in_EAX) {\n                    *param_2 = uVar3;\n                    goto code_r0x0042b0d4;\n                }\n                uVar3 = uVar3 + 1;\n                puVar2 = puVar2 + 0xc;\n            } while (uVar3 < *(param_1 + 0xc));\n        }\n    }\n    return in_EAX & 0xffffff00;\n}\n",
        "token_count": 339
    },
    "0042b519": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042b519(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    if ((*(in_ECX + 0x4c) != 0) && (iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x453dcc, &var_8h),  -1 < iVar1)) {\n        var_4h = NULL;\n        var_ch = 0;\n        iVar1 = (**(*var_8h + 0x10))(var_8h, arg_8h, &var_4h);\n        if (-1 < iVar1) {\n            (**(*var_4h + 0x14))(var_4h, arg_ch, &var_ch);\n            (**(*var_4h + 8))(var_4h);\n        }\n        (**(*var_8h + 8))(var_8h);\n        return var_ch;\n    }\n    return 0;\n}\n",
        "token_count": 258
    },
    "0042b583": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b583(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    if ((arg_ch != 0) && (in_ECX[0x13] != 0)) {\n        var_8h = in_ECX;\n        iVar1 = (***in_ECX[0x13])(in_ECX[0x13], 0x453dcc, &var_8h);\n        if (-1 < iVar1) {\n            var_4h = NULL;\n            iVar1 = (**(*var_8h + 0x10))(var_8h, arg_8h, &var_4h);\n            if (-1 < iVar1) {\n                (**(*var_4h + 0x18))(var_4h, arg_ch);\n                (**(*var_4h + 8))(var_4h);\n            }\n            (**(*var_8h + 8))(var_8h);\n        }\n    }\n    return;\n}\n",
        "token_count": 250
    },
    "0042b5e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nbool __cdecl fcn.0042b5e3(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint32_t uVar2;\n    uint var_20h;\n    uint var_1ch;\n    uint *var_18h;\n    int32_t *var_14h;\n    int32_t var_10h;\n    int32_t *var_ch;\n    int32_t *var_8h;\n    int32_t *var_4h;\n    \n    *arg_8h = *0x453e3c;\n    arg_8h[1] = *0x453e40;\n    arg_8h[2] = *0x453e44;\n    arg_8h[3] = *0x453e48;\n    var_ch = NULL;\n    iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x453d9c, &var_ch);\n    if (-1 < iVar1) {\n        (**(*var_ch + 0x10))(var_ch, 1, arg_8h);\n        (**(*var_ch + 8))(var_ch);\n    }\n    var_14h = NULL;\n    iVar1 = fcn.0042807b(arg_8h, 0x453e3c);\n    if ((iVar1 != 0) && (iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x453dac, &var_14h),  -1 < iVar1)) {\n        var_4h = NULL;\n        iVar1 = (**(*var_14h + 0xc))(var_14h, &var_4h);\n        if (-1 < iVar1) {\n            iVar1 = (**(*var_4h + 0xc))(var_4h, &var_10h);\n            if (-1 < iVar1) {\n                uVar2 = 0;\n                if (*(var_10h + 0x30) != 0) {\n                    do {\n                        iVar1 = (**(*var_4h + 0x24))(var_4h, uVar2, &var_1ch);\n                        if ((-1 < iVar1) && ((var_1ch & 7) == 3)) {\n                            var_8h = NULL;\n                            iVar1 = (**(*var_4h + 0x20))(var_4h, uVar2, &var_20h);\n                            if ((-1 < iVar1) && (iVar1 = (**(*var_4h + 0x38))(var_4h, var_20h, &var_8h),  -1 < iVar1)) {\n                                iVar1 = (**(*var_8h + 0xc))(var_8h, &var_18h);\n                                if (-1 < iVar1) {\n                                    *arg_8h = *var_18h;\n                                    arg_8h[1] = var_18h[1];\n                                    arg_8h[2] = var_18h[2];\n                                    arg_8h[3] = var_18h[3];\n                                    (**(*var_8h + 0x4c))(var_8h, var_18h);\n                                }\n                                (**(*var_8h + 8))(var_8h);\n                            }\n                            break;\n                        }\n                        uVar2 = uVar2 + 1;\n                    } while (uVar2 < *(var_10h + 0x30));\n                }\n                (**(*var_4h + 0x4c))(var_4h, var_10h);\n            }\n            (**(*var_4h + 8))(var_4h);\n        }\n        (**(*var_14h + 8))(var_14h);\n    }\n    iVar1 = fcn.0042807b(arg_8h, 0x453e3c);\n    return iVar1 == 0;\n}\n",
        "token_count": 882
    },
    "0042b902": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042b902(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = *(param_1 + 0x24);\n    *(param_1 + 0x20) = 0;\n    if (piVar1 != NULL) {\n        if (piVar1[7] != 0) {\n            piVar1 = (**(*piVar1 + 0xf0))();\n            iVar2 = (*_sym.imp.USER32.dll_IsWindow)(*(*(param_1 + 0x24) + 0x1c));\n            if ((iVar2 != 0) && (*piVar1 != 0)) {\n                fcn.004425ae();\n            }\n            fcn.00442103();\n        }\n        *(*(param_1 + 0x24) + 0x4c) = 0;\n    }\n    return;\n}\n",
        "token_count": 206
    },
    "0042b950": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __thiscall fcn.0042b950(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if ((*(param_1 + 0x24) != 0) &&\n       (iVar1 = (**(**(param_1 + 0x24) + 0xc))(*(param_1 + 0x28), 0xfffffffe, param_2, 0),  iVar1 != 0)) {\n        return 1;\n    }\n    uVar2 = (**(**(*(param_1 + 0x1c) + 0x1c) + 0xc))(*(param_1 + 0x28), 0xfffffffe, param_2, 0);\n    return uVar2;\n}\n",
        "token_count": 175
    },
    "0042c3c9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0042c3c9(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0xc) == 0) {\n        return 0;\n    }\n    (**(**(param_1 + 0xc) + 0xb4))();\n    (**(**(*(param_1 + 0xc) + 0x8c) + 4))(param_1, 1);\n    // WARNING: Could not recover jumptable at 0x0042c3fe. Too many branches\n    // WARNING: Treating indirect jump as call\n    uVar1 = (****(*(param_1 + 0xc) + 0x8c))();\n    return uVar1;\n}\n",
        "token_count": 166
    },
    "0042d570": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042d570(int32_t **param_1)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t **var_4h;\n    \n    if ((param_1[2] != 0x80010001) && (*param_1 != NULL)) {\n        puVar1 = (*param_1)[0x13];\n        var_4h = param_1;\n        iVar2 = (***puVar1)(puVar1, 0x453dec, &var_4h);\n        if (iVar2 < 0) {\n            iVar2 = fcn.0042c3c9();\n            if (iVar2 != 0) {\n                uVar3 = 0xd;\n                if (param_1[3][0x23] != 0) {\n                    uVar3 = 0x800d;\n                }\n                (**(**param_1 + 0x70))(*param_1, param_1[2], uVar3, iVar2);\n            }\n        }\n        else {\n            (*(*var_4h)[3])(var_4h, param_1[2], param_1[3] != NULL, param_1 + 4);\n            (*(*var_4h)[2])(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 298
    },
    "0042d6c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0042d6c7(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    uVar1 = *(*(param_1 + 8) + 4);\n    iVar2 = 0;\n    uVar3 = 0;\n    if (uVar1 != 0) {\n        do {\n            if ((*(**(param_1 + 8) + 4 + uVar3 * 8) != '\\0') && (iVar2 = fcn.0042c53e(uVar3),  iVar2 < 0)) {\n                return iVar2;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < uVar1);\n    }\n    return iVar2;\n}\n",
        "token_count": 185
    },
    "0042da65": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.0042da65(uint *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *in_ECX;\n    uint unaff_ESI;\n    uint noname_2;\n    uint *noname_3;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    fcn.0042d6fb();\n    noname_3 = &var_4h;\n    noname_2 = 0x451ac4;\n    iVar1 = (***arg_8h)();\n    if (-1 < iVar1) {\n        if (*in_ECX == 0) {\n            iVar1 = fcn.0042ae7c(1, arg_8h, noname_2, noname_3, unaff_ESI, var_4h);\n            if (iVar1 < 0) goto code_r0x0042dab7;\n            *(*in_ECX + 4) = 1;\n        }\n        iVar1 = fcn.0042aee0(in_ECX[3], in_ECX[4], *in_ECX, in_ECX[6], var_4h);\n    }\ncode_r0x0042dab7:\n    fcn.0042c788();\n    return iVar1;\n}\n",
        "token_count": 304
    },
    "0042e27f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "log keystrokes via raw input data/18af53aa16f24c3fa3538f182ae5df5a"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042e27f(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    int16_t iVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    int32_t arg_ch;\n    int32_t iVar4;\n    uint32_t var_4h;\n    \n    iVar4 = 0;\n    var_4h = 0;\n    if (*(in_ECX + 0xc) != 0) {\n        do {\n            if ((*(in_ECX + 0x10) == 0) || (*(*(in_ECX + 0x10) + var_4h) != '\\x01')) {\n                iVar2 = *(iVar4 + 0x14 + *(in_ECX + 0x14));\n                if ((iVar2 == 0xd) || (iVar2 == 9)) {\n                    iVar3 = *(in_ECX + 0x14) + iVar4;\n                    if (*((*(iVar3 + 0x10) + 3 + *(iVar3 + 4) & 0xfffffffcU) + 4 + *(in_ECX + 8)) != 0)\n                    goto code_r0x0042e34c;\n                    iVar3 = *(in_ECX + 0x14) + iVar4;\n                    arg_ch = *(iVar3 + 4) + *(in_ECX + 8);\n                }\n                else {\n                    iVar3 = *(in_ECX + 0x14) + iVar4;\n                    arg_ch = *(iVar3 + 4) + *(in_ECX + 8);\n                }\n                fcn.0042e1da(*(iVar3 + 0x14), arg_ch, arg_8h);\n            }\n            else {\n                iVar3 = *(in_ECX + 0x14) + iVar4;\n                if (((*((*(iVar3 + 0x10) + 3 + *(iVar3 + 4) & 0xfffffffcU) + 4 + *(in_ECX + 8)) != 3) &&\n                    (piVar1 = *(iVar4 + 4 + *(in_ECX + 0x14)) + *(in_ECX + 8),  piVar1 != NULL)) && (*piVar1 != 0)) {\n                    (*_sym.imp.ole32.dll_CoTaskMemFree)(*piVar1);\n                    *piVar1 = 0;\n                }\n            }\ncode_r0x0042e34c:\n            var_4h = var_4h + 1;\n            iVar4 = iVar4 + 0x30;\n        } while (var_4h < *(in_ECX + 0xc));\n    }\n    return;\n}\n",
        "token_count": 589
    },
    "0042ebc8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042ebc8(int32_t *arg_8h, uint arg_ch, uint *arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t *var_24h;\n    int32_t var_20h;\n    uint var_1ch;\n    uint32_t var_18h;\n    uint var_14h;\n    uint uStack20;\n    uint uStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    fcn.0042d6fb();\n    var_20h = (***arg_8h)(arg_8h, 0x451ab4, &var_24h);\n    uVar1 = arg_14h;\n    uVar2 = arg_14h;\n    puVar5 = arg_10h;\n    if (arg_14h != 0) {\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar5 = 0;\n            puVar5 = puVar5 + 1;\n        }\n    }\n    if (-1 < var_20h) {\n        arg_14h = 0;\n        fcn.0042e17e();\n        var_1ch = arg_ch;\n        var_18h = uVar1;\n        var_14h = *0x454430;\n        uStack20 = *0x454434;\n        uStack16 = *0x454438;\n        uStack12 = *0x45443c;\n        var_20h = (**(*var_24h + 0xc))(var_24h, 1, &var_1ch, &arg_14h, &arg_8h);\n        if (-1 < var_20h) {\n            uVar2 = 0;\n            iVar4 = 0;\n            while( true ) {\n                uVar3 = arg_8h[1];\n                if (uVar1 <= arg_8h[1]) {\n                    uVar3 = uVar1;\n                }\n                if (uVar3 <= uVar2) break;\n                arg_10h[uVar2] = *(*arg_8h + 0x2c + iVar4);\n                uVar2 = uVar2 + 1;\n                iVar4 = iVar4 + 0x34;\n            }\n            if (*arg_8h != 0) {\n                (*_sym.imp.ole32.dll_CoTaskMemFree)(*arg_8h);\n            }\n        }\n        fcn.0042e365();\n    }\n    fcn.0042c788();\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 633
    },
    "0042eca0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_5ch\n// WARNING: Variable defined which should be unmapped: var_58h\n\nvoid fcn.0042eca0(void)\n\n{\n    uint8_t uVar1;\n    code **ppcVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t *extraout_ECX;\n    int32_t arg_2ch;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint32_t arg_24h;\n    uint *puVar7;\n    uint unaff_EDI;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_3ch;\n    uint var_24h;\n    uint var_14h;\n    uint var_10h;\n    uint uVar11;\n    uint var_5ch;\n    uint var_58h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_3dh;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h_2;\n    uint var_14h_2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    uVar11 = *0x45c1a8;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x24) = *0x451c1c;\n    *(unaff_EBP + -0x20) = *0x451c20;\n    *(unaff_EBP + -0x1c) = *0x451c24;\n    *(unaff_EBP + -0x14) = uVar11;\n    *(unaff_EBP + -0x10) = &var_5ch;\n    *(unaff_EBP + -0x48) = extraout_ECX;\n    *(unaff_EBP + -0x18) = *0x451c28;\n    *(unaff_EBP + -0x3d) = 0;\n    ppcVar2 = **(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    iVar10 = unaff_EBP + -0x3c;\n    uVar11 = 0x451ac4;\n    var_5ch = unaff_EDI;\n    var_58h = unaff_ESI;\n    iVar4 = (**ppcVar2)(*(unaff_EBP + 8));\n    if (-1 < iVar4) {\n        iVar4 = extraout_ECX[5];\n        *(unaff_EBP + -0x2c) = 0;\n        if (iVar4 == 0) {\n            *(unaff_EBP + -0x28) = 0;\n            ppcVar2 = **(unaff_EBP + 8);\n            *(unaff_EBP + -4) = 1;\n            iVar4 = (**ppcVar2)(*(unaff_EBP + 8), 0x451aa4, unaff_EBP + -0x28);\n            *(unaff_EBP + -0x38) = iVar4;\n            piVar6 = *(unaff_EBP + -0x28);\n            if (iVar4 < 0) {\n                *(unaff_EBP + -4) = 0;\n                if (piVar6 != NULL) {\n                    (**(*piVar6 + 8))(piVar6);\n                }\n                piVar6 = *(unaff_EBP + -0x3c);\n                *(unaff_EBP + -4) = 0xffffffff;\n                goto code_r0x0042f175;\n            }\n            iVar4 = (**(*piVar6 + 0xc))(piVar6, extraout_ECX + 3, extraout_ECX + 5, extraout_ECX + 6);\n            piVar6 = *(unaff_EBP + -0x28);\n            *(unaff_EBP + -4) = 0;\n            if (iVar4 < 0) {\n                if (piVar6 != NULL) {\n                    (**(*piVar6 + 8))(piVar6);\n                }\n                goto code_r0x0042f244;\n            }\n            *(extraout_ECX + 7) = 0;\n            if (piVar6 != NULL) {\n                (**(*piVar6 + 8))(piVar6);\n            }\n        }\n        else {\n            *(extraout_ECX + 7) = 1;\n        }\n        iVar4 = extraout_ECX[3];\n        *(unaff_EBP + -0x34) = 0;\n        *(unaff_EBP + -4) = 2;\n        uVar5 = fcn.0043f71e(iVar4 * 0x34);\n        *(unaff_EBP + -0x34) = uVar5;\n        *(unaff_EBP + -4) = 0;\n        if (*(unaff_EBP + -0x34) != 0) {\n            iVar4 = extraout_ECX[3];\n            *(unaff_EBP + -4) = 4;\n            iVar4 = fcn.0043f71e(iVar4);\n            extraout_ECX[4] = iVar4;\n            uVar8 = 0;\n            iVar4 = extraout_ECX[4];\n            *(unaff_EBP + -4) = 0;\n            if (iVar4 != 0) {\n                *(unaff_EBP + -0x30) = *(unaff_EBP + -0x34);\n                *(unaff_EBP + -0x38) = 0;\ncode_r0x0042ee0f:\n                if (extraout_ECX[3] <= uVar8) goto code_r0x0042f123;\n                *(uVar8 + extraout_ECX[4]) = 0;\n                iVar9 = uVar8 * 0x30;\n                iVar4 = extraout_ECX[5] + iVar9;\n                if ((extraout_ECX[9] <= *(iVar4 + 0x10) && *(iVar4 + 0x10) != extraout_ECX[9]) &&\n                   (*(iVar4 + 0x14) != 0xd)) {\n                    if (extraout_ECX[8] == 2) {\n                        uVar8 = *(unaff_EBP + -0x2c) + 3U & 0xfffffffc;\n                        *(unaff_EBP + -0x28) = uVar8 + 4;\n                        *(unaff_EBP + -0x2c) = uVar8 + 8;\n                        arg_24h = 0;\n                        fcn.0042b00a(*(unaff_EBP + -0x30), *(iVar4 + 8), *(iVar4 + 0x14), *(iVar4 + 0x10), \n                                     *(iVar4 + 0x16), *(iVar4 + 0x17), 0, 0, uVar8, *(unaff_EBP + -0x28), 0, 0, 1);\n                    }\n                    else {\n                        if (extraout_ECX[8] != 1) {\n                            if (*(unaff_EBP + -0x3d) == '\\0') {\n                                *(unaff_EBP + -0x5c) = 0x89;\n                                *(unaff_EBP + -0x58) = 0x8b;\n                                *(unaff_EBP + -0x50) = 0;\n                                *(unaff_EBP + -0x4c) = 0;\n                                fcn.0042ebc8(*(unaff_EBP + 8), unaff_EBP + -0x5c, unaff_EBP + -0x50, 2);\n                                if (*(unaff_EBP + -0x50) == 0) {\n                                    if (*(unaff_EBP + -0x4c) != 0) {\n                                        puVar7 = 0x451c0c;\n                                        goto code_r0x0042ef6e;\n                                    }\n                                }\n                                else {\n                                    puVar7 = 0x451c1c;\ncode_r0x0042ef6e:\n                                    *(unaff_EBP + -0x24) = *puVar7;\n                                    *(unaff_EBP + -0x20) = puVar7[1];\n                                    *(unaff_EBP + -0x1c) = puVar7[2];\n                                    *(unaff_EBP + -0x18) = puVar7[3];\n                                }\n                                *(unaff_EBP + -0x3d) = 1;\n                            }\n                            *(unaff_EBP + -0x44) = 0;\n                            *(unaff_EBP + -4) = 6;\n                            uVar5 = fcn.0043f71e(0x14);\n                            *(unaff_EBP + -0x44) = uVar5;\n                            *(unaff_EBP + -4) = 0;\n                            if (*(unaff_EBP + -0x44) != 0) {\n                                puVar7 = unaff_EBP + -0x24;\n                                goto code_r0x0042f044;\n                            }\n                            iVar10 = *(unaff_EBP + -0x38);\n                            if (iVar10 != 0) {\n                                puVar7 = *(unaff_EBP + -0x34) + 0x14;\n                                do {\n                                    fcn.0043f749(*puVar7);\n                                    puVar7 = puVar7 + 0xd;\n                                    iVar10 = iVar10 + -1;\n                                } while (iVar10 != 0);\n                            }\n                            goto code_r0x0042f024;\n                        }\n                        *(iVar4 + 0x15) = *(iVar4 + 0x15) | 0x40;\n                        iVar4 = *(unaff_EBP + -0x38);\n                        *(extraout_ECX[5] + 0x10 + iVar9) = 4;\n                        *(iVar4 + extraout_ECX[4]) = 1;\n                        iVar4 = extraout_ECX[5];\n                        *(unaff_EBP + -0x28) = iVar4 + iVar9;\n                        iVar4 = fcn.0042b0db(*(iVar4 + iVar9 + 0x14));\n                        arg_24h = iVar4 + -1 + *(unaff_EBP + -0x2c) & ~(iVar4 - 1U);\n                        iVar4 = *(unaff_EBP + -0x28);\n                        uVar8 = *(iVar4 + 0x10) + 3 + arg_24h & 0xfffffffc;\n                        *(unaff_EBP + -0x28) = uVar8 + 4;\n                        *(unaff_EBP + -0x2c) = uVar8 + 8;\n                        fcn.0042b00a(*(unaff_EBP + -0x30), *(iVar4 + 8), *(iVar4 + 0x14), *(iVar4 + 0x10), \n                                     *(iVar4 + 0x16), *(iVar4 + 0x17), 0, arg_24h, uVar8, *(unaff_EBP + -0x28), 0, 0, 0)\n                        ;\n                    }\n                    goto code_r0x0042f10d;\n                }\n                if (*(iVar4 + 0x14) == 0xd) {\n                    *(unaff_EBP + -0x44) = 0;\n                    *(unaff_EBP + -4) = 8;\n                    uVar5 = fcn.0043f71e(0x14);\n                    *(unaff_EBP + -0x44) = uVar5;\n                    *(unaff_EBP + -4) = 0;\n                    if (*(unaff_EBP + -0x44) == 0) {\n                        iVar10 = *(unaff_EBP + -0x38);\n                        if (iVar10 != 0) {\n                            puVar7 = *(unaff_EBP + -0x34) + 0x14;\n                            do {\n                                fcn.0043f749(*puVar7);\n                                puVar7 = puVar7 + 0xd;\n                                iVar10 = iVar10 + -1;\n                            } while (iVar10 != 0);\n                        }\ncode_r0x0042f024:\n                        fcn.0043f749(*(unaff_EBP + -0x34));\n                        fcn.0043f749(extraout_ECX[4]);\n                        extraout_ECX[4] = 0;\n                        goto code_r0x0042edbe;\n                    }\n                    puVar7 = 0x451bfc;\ncode_r0x0042f044:\n                    puVar3 = *(unaff_EBP + -0x44);\n                    *puVar3 = 0;\n                    puVar3[1] = *puVar7;\n                    puVar3[2] = puVar7[1];\n                    puVar3[3] = puVar7[2];\n                    puVar3[4] = puVar7[3];\n                    iVar9 = *(unaff_EBP + -0x38) * 0x30;\n                    *(extraout_ECX[5] + 0x14 + iVar9) = 0xd;\n                    *(extraout_ECX[5] + 0x10 + iVar9) = 4;\n                    iVar4 = extraout_ECX[5];\n                    *(unaff_EBP + -0x28) = iVar4 + iVar9;\n                    iVar4 = fcn.0042b0db(*(iVar4 + iVar9 + 0x14));\n                    uVar5 = *(unaff_EBP + -0x44);\n                }\n                else {\n                    if (*(iVar4 + 0x14) == 0x81) {\n                        *(iVar4 + 0x10) = *(iVar4 + 0x10) + 1;\n                    }\n                    iVar4 = extraout_ECX[5] + iVar9;\n                    if (*(iVar4 + 0x14) == 0x82) {\n                        *(iVar4 + 0x10) = *(iVar4 + 0x10) * 2 + 2;\n                    }\n                    iVar4 = extraout_ECX[5];\n                    *(unaff_EBP + -0x28) = iVar4 + iVar9;\n                    iVar4 = fcn.0042b0db(*(iVar4 + iVar9 + 0x14));\n                    uVar5 = 0;\n                }\n                arg_24h = iVar4 + -1 + *(unaff_EBP + -0x2c) & ~(iVar4 - 1U);\n                iVar4 = *(unaff_EBP + -0x28);\n                uVar8 = *(iVar4 + 0x10) + 3 + arg_24h & 0xfffffffc;\n                arg_2ch = uVar8 + 4;\n                uVar1 = *(iVar4 + 0x17);\n                *(unaff_EBP + -0x2c) = arg_2ch;\n                *(unaff_EBP + -0x2c) = *(unaff_EBP + -0x2c) + 4;\n                *(unaff_EBP + -0x28) = arg_2ch;\n                fcn.0042af2a(*(unaff_EBP + -0x30), *(iVar4 + 8), *(iVar4 + 0x14), *(iVar4 + 0x10), *(iVar4 + 0x16), \n                             uVar1, 0, arg_24h, uVar8, arg_2ch, uVar5);\ncode_r0x0042f10d:\n                *(unaff_EBP + -0x30) = *(unaff_EBP + -0x30) + 0x34;\n                iVar4 = extraout_ECX[5];\n                *(unaff_EBP + -0x38) = *(unaff_EBP + -0x38) + 1;\n                *(iVar4 + 4 + iVar9) = arg_24h;\n                uVar8 = *(unaff_EBP + -0x38);\n                goto code_r0x0042ee0f;\n            }\n            fcn.0043f749(*(unaff_EBP + -0x34));\n            goto code_r0x0042f1f0;\n        }\ncode_r0x0042edbe:\n        piVar6 = *(unaff_EBP + -0x3c);\n        *(unaff_EBP + -4) = 0xffffffff;\n        goto code_r0x0042f1fa;\n    }\n    piVar6 = *(unaff_EBP + -0x3c);\n    *(unaff_EBP + -4) = 0xffffffff;\n    goto code_r0x0042f24d;\ncode_r0x0042f123:\n    if (*extraout_ECX == 0) {\n        iVar10 = fcn.0042ae7c(1, 1, uVar11, iVar10, var_5ch, var_58h);\n        *(unaff_EBP + -0x38) = iVar10;\n        if (iVar10 < 0) {\n            uVar8 = 0;\n            if (extraout_ECX[3] != 0) {\n                puVar7 = *(unaff_EBP + -0x34) + 0x14;\n                do {\n                    fcn.0043f749(*puVar7);\n                    uVar8 = uVar8 + 1;\n                    puVar7 = puVar7 + 0xd;\n                } while (uVar8 < extraout_ECX[3]);\n            }\n            fcn.0043f749(*(unaff_EBP + -0x34));\n            fcn.0043f749(extraout_ECX[4]);\n            piVar6 = *(unaff_EBP + -0x3c);\n            extraout_ECX[4] = 0;\n            *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x0042f175:\n            if (piVar6 != NULL) {\n                (**(*piVar6 + 8))(piVar6);\n            }\n            goto code_r0x0042f257;\n        }\n        *(*extraout_ECX + 4) = 1;\n    }\n    uVar11 = *(unaff_EBP + -0x2c);\n    extraout_ECX[2] = 0;\n    *(unaff_EBP + -4) = 10;\n    iVar10 = fcn.0043f71e(uVar11);\n    extraout_ECX[2] = iVar10;\n    iVar10 = extraout_ECX[2];\n    uVar8 = 0;\n    *(unaff_EBP + -4) = 0;\n    if (iVar10 == 0) {\n        if (extraout_ECX[3] != 0) {\n            puVar7 = *(unaff_EBP + -0x34) + 0x14;\n            do {\n                fcn.0043f749(*puVar7);\n                uVar8 = uVar8 + 1;\n                puVar7 = puVar7 + 0xd;\n            } while (uVar8 < extraout_ECX[3]);\n        }\n        fcn.0043f749(*(unaff_EBP + -0x34));\n        fcn.0043f749(extraout_ECX[4]);\n        extraout_ECX[4] = 0;\ncode_r0x0042f1f0:\n        piVar6 = *(unaff_EBP + -0x3c);\n        *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x0042f1fa:\n        if (piVar6 != NULL) {\n            (**(*piVar6 + 8))(piVar6);\n        }\n        goto code_r0x0042f257;\n    }\n    fcn.00433ba0(iVar10, 0, *(unaff_EBP + -0x2c));\n    iVar10 = fcn.0042aee0(*(unaff_EBP + -0x34), extraout_ECX[3], *extraout_ECX, *(unaff_EBP + -0x2c), \n                          *(unaff_EBP + -0x3c));\n    if (iVar10 < 0) {\n        fcn.0043f749(extraout_ECX[4]);\n        extraout_ECX[4] = 0;\n    }\n    fcn.0043f749(*(unaff_EBP + -0x34));\ncode_r0x0042f244:\n    piVar6 = *(unaff_EBP + -0x3c);\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x0042f24d:\n    if (piVar6 != NULL) {\n        (**(*piVar6 + 8))(piVar6);\n    }\ncode_r0x0042f257:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 4710
    },
    "0042f651": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0042f651(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    if (param_1[4] != NULL) {\n        if (*param_1 != NULL) {\n            fcn.0042ebad(*param_1);\n        }\n        piVar1 = param_1[4];\n        if (piVar1 != NULL) {\n            fcn.0042e1d5();\n            fcn.0043f749(piVar1);\n        }\n        param_1[4] = NULL;\n    }\n    if (*param_1 != NULL) {\n        fcn.0042c51e();\n        piVar1 = *param_1;\n        if (piVar1 != NULL) {\n            *param_1 = NULL;\n            (**(*piVar1 + 8))(piVar1);\n        }\n        piVar1 = param_1[1];\n        if (piVar1 != NULL) {\n            param_1[1] = NULL;\n            (**(*piVar1 + 8))(piVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 243
    },
    "0042fe09": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_13ch\n// WARNING: Variable defined which should be unmapped: var_130h\n\nvoid __cdecl fcn.0042fe09(uint arg_8h, uint arg_ch)\n\n{\n    char *pcVar1;\n    uchar uVar2;\n    uint16_t uVar3;\n    uint uVar4;\n    double dVar5;\n    code *pcVar6;\n    char cVar7;\n    ulong *puVar8;\n    uint *puVar9;\n    uint uVar10;\n    int16_t *piVar11;\n    uchar *puVar12;\n    int32_t iVar13;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_13ch;\n    uint var_130h;\n    uint var_120h;\n    uint var_110h;\n    uint var_100h;\n    uint var_f0h;\n    uint var_e0h;\n    uint var_d0h;\n    uint var_c0h;\n    uint var_b0h;\n    uint var_a0h;\n    uint var_90h;\n    uint var_80h;\n    uint var_70h;\n    uint var_60h;\n    uint var_58h;\n    uint var_50h;\n    uint var_48h;\n    uint var_44h;\n    uint pvargDest;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_18h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = *0x45c1a8;\n    *(unaff_EBP + -0x30) = 0;\n    fcn.0043139e(unaff_EBP + -0x40);\n    *(unaff_EBP + -4) = 0;\n    fcn.0042da0c(*(unaff_EBP + 0xc), unaff_EBP + -0x28);\n    if ((*(unaff_EBP + -0x28) == 3) ||\n       (cVar7 = fcn.0042c6fe(*(unaff_EBP + 0xc), unaff_EBP + -0x26),  pcVar6 = _sym.imp.OLEAUT32.dll_VariantCopy, \n       cVar7 == '\\0')) {\n        fcn.004313b1(unaff_EBP + -0x40);\n        (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x40);\n        goto code_r0x00430315;\n    }\n    uVar3 = *(unaff_EBP + -0x26);\n    if (uVar3 < 0x82) {\n        if (uVar3 != 0x81) {\n            if (uVar3 < 9) {\n                if (uVar3 == 8) goto code_r0x004302b8;\n                if (uVar3 == 2) {\ncode_r0x00430007:\n                    piVar11 = fcn.0042c732(*(unaff_EBP + 0xc));\n                    uVar10 = fcn.004312cd(*piVar11, 2);\n                    *(unaff_EBP + -4) = 7;\n                    fcn.00431384(uVar10);\n                    iVar13 = unaff_EBP + -0x110;\n                }\n                else if (uVar3 == 3) {\ncode_r0x0042ffd6:\n                    puVar9 = fcn.0042c732(*(unaff_EBP + 0xc));\n                    uVar10 = fcn.004312f4(*puVar9, 3);\n                    *(unaff_EBP + -4) = 8;\n                    fcn.00431384(uVar10);\n                    iVar13 = unaff_EBP + -0xe0;\n                }\n                else if (uVar3 == 4) {\n                    puVar9 = fcn.0042c732(*(unaff_EBP + 0xc));\n                    *(unaff_EBP + -0xb8) = *puVar9;\n                    *(unaff_EBP + -0xc0) = 4;\n                    *(unaff_EBP + -4) = 9;\n                    fcn.00431384(unaff_EBP + -0xc0);\n                    iVar13 = unaff_EBP + -0xc0;\n                }\n                else if (uVar3 == 5) {\n                    puVar8 = fcn.0042c732(*(unaff_EBP + 0xc));\n                    *(unaff_EBP + -0x88) = *puVar8;\n                    *(unaff_EBP + -0x90) = 5;\n                    *(unaff_EBP + -4) = 10;\n                    fcn.00431384(unaff_EBP + -0x90);\n                    iVar13 = unaff_EBP + -0x90;\n                }\n                else if (uVar3 == 6) {\n                    puVar9 = fcn.0042c732(*(unaff_EBP + 0xc));\n                    uVar10 = *puVar9;\n                    uVar4 = puVar9[1];\n                    *(unaff_EBP + -0x50) = 6;\n                    *(unaff_EBP + -0x48) = uVar10;\n                    *(unaff_EBP + -0x44) = uVar4;\n                    *(unaff_EBP + -4) = 0xd;\n                    fcn.00431384(unaff_EBP + -0x50);\n                    iVar13 = unaff_EBP + -0x50;\n                }\n                else {\n                    if (uVar3 != 7) goto code_r0x00430303;\n                    puVar8 = fcn.0042c732(*(unaff_EBP + 0xc));\n                    *(unaff_EBP + -200) = *puVar8;\n                    *(unaff_EBP + -0xd0) = 7;\n                    *(unaff_EBP + -4) = 0xc;\n                    fcn.00431384(unaff_EBP + -0xd0);\n                    iVar13 = unaff_EBP + -0xd0;\n                }\n            }\n            else if (uVar3 == 0xb) {\n                piVar11 = fcn.0042c732(*(unaff_EBP + 0xc));\n                uVar10 = fcn.004312cd(*piVar11, 0xb);\n                *(unaff_EBP + -4) = 0xb;\n                fcn.00431384(uVar10);\n                iVar13 = unaff_EBP + -0x100;\n            }\n            else {\n                if (uVar3 != 0xc) {\n                    if (0xf < uVar3) {\n                        if (uVar3 < 0x12) {\n                            puVar12 = fcn.0042c732(*(unaff_EBP + 0xc));\n                            uVar2 = *puVar12;\n                            *(unaff_EBP + -0x60) = 0x11;\n                            *(unaff_EBP + -0x58) = uVar2;\n                            *(unaff_EBP + -4) = 6;\n                            fcn.00431384(unaff_EBP + -0x60);\n                            iVar13 = unaff_EBP + -0x60;\n                            goto code_r0x0043019a;\n                        }\n                        if (uVar3 == 0x12) goto code_r0x00430007;\n                        if (uVar3 == 0x13) goto code_r0x0042ffd6;\n                    }\n                    goto code_r0x00430303;\n                }\n                uVar10 = fcn.0042c732(*(unaff_EBP + 0xc));\n                uVar10 = fcn.004313b1(uVar10);\n                *(unaff_EBP + -4) = 1;\n                fcn.00431384(uVar10);\n                iVar13 = unaff_EBP + -0xf0;\n            }\n            goto code_r0x0043019a;\n        }\n        uVar10 = fcn.0042c732(*(unaff_EBP + 0xc));\n        puVar9 = fcn.00427020(uVar10);\n        uVar10 = *puVar9;\n        *(unaff_EBP + -4) = 2;\n        uVar10 = fcn.004313d1(uVar10, 8);\n        *(unaff_EBP + -4) = 3;\n        fcn.00431384(uVar10);\n        (*pcVar6)(unaff_EBP + -0x120);\ncode_r0x004302f8:\n        *(unaff_EBP + -4) = 0;\n        fcn.00421110();\n    }\n    else {\n        if (uVar3 == 0x82) {\ncode_r0x004302b8:\n            uVar10 = fcn.0042c732(*(unaff_EBP + 0xc));\n            puVar9 = fcn.0042f875(uVar10);\n            uVar10 = *puVar9;\n            *(unaff_EBP + -4) = 4;\n            uVar10 = fcn.004313d1(uVar10, 8);\n            *(unaff_EBP + -4) = 5;\n            fcn.00431384(uVar10);\n            (*pcVar6)(unaff_EBP + -0x130);\n            goto code_r0x004302f8;\n        }\n        if (uVar3 == 0x83) {\n            cVar7 = fcn.0042d78a(*(unaff_EBP + 0xc), unaff_EBP + -0x24);\n            if (cVar7 != '\\0') {\n                dVar5 = *(unaff_EBP + -0x21);\n                cVar7 = *(unaff_EBP + -0x23);\n                while (cVar7 != '\\0') {\n                    pcVar1 = unaff_EBP + -0x23;\n                    *pcVar1 = *pcVar1 + -1;\n                    dVar5 = dVar5 * *0x451d78;\n                    cVar7 = *pcVar1;\n                }\n                if (*(unaff_EBP + -0x22) == '\\0') {\n                    dVar5 = -dVar5;\n                }\n                *(unaff_EBP + -0x78) = dVar5;\n                *(unaff_EBP + -0x80) = 5;\n                *(unaff_EBP + -4) = 0xe;\n                fcn.00431384(unaff_EBP + -0x80);\n                iVar13 = unaff_EBP + -0x80;\n                goto code_r0x0043019a;\n            }\n        }\n        else if (uVar3 == 0x85) {\n            cVar7 = fcn.0042d7b4(*(unaff_EBP + 0xc), unaff_EBP + -0x30);\n            if (cVar7 != '\\0') {\n                *(unaff_EBP + -0x20) = 0;\n                *(unaff_EBP + -0x18) = 0;\n                fcn.0042c642(*(unaff_EBP + -0x30), *(unaff_EBP + -0x2e), *(unaff_EBP + -0x2c), 0, 0, 0);\n                *(unaff_EBP + -0x70) = 7;\n                *(unaff_EBP + -0x68) = *(unaff_EBP + -0x20);\n                *(unaff_EBP + -4) = 0xf;\n                fcn.00431384(unaff_EBP + -0x70);\n                iVar13 = unaff_EBP + -0x70;\n                goto code_r0x0043019a;\n            }\n        }\n        else if (uVar3 == 0x86) {\n            cVar7 = fcn.0042d7b4(*(unaff_EBP + 0xc), unaff_EBP + -0x30);\n            if (cVar7 != '\\0') {\n                *(unaff_EBP + -0x20) = 0;\n                *(unaff_EBP + -0x18) = 0;\n                fcn.0042c6a3(*(unaff_EBP + -0x30), *(unaff_EBP + -0x2e), *(unaff_EBP + -0x2c));\n                *(unaff_EBP + -0xb0) = 7;\n                *(unaff_EBP + -0xa8) = *(unaff_EBP + -0x20);\n                *(unaff_EBP + -4) = 0x10;\n                fcn.00431384(unaff_EBP + -0xb0);\n                iVar13 = unaff_EBP + -0xb0;\n                goto code_r0x0043019a;\n            }\n        }\n        else if ((uVar3 == 0x87) && (cVar7 = fcn.0042d7de(*(unaff_EBP + 0xc), unaff_EBP + -0x24),  cVar7 != '\\0')) {\n            puVar8 = fcn.0042d974(*(unaff_EBP + -0x24), *(unaff_EBP + -0x22), *(unaff_EBP + -0x20), *(unaff_EBP + -0x1e)\n                                  , *(unaff_EBP + -0x1c), *(unaff_EBP + -0x1a));\n            *(unaff_EBP + -0xa0) = 7;\n            *(unaff_EBP + -0x98) = *puVar8;\n            *(unaff_EBP + -4) = 0x11;\n            fcn.00431384(unaff_EBP + -0xa0);\n            iVar13 = unaff_EBP + -0xa0;\ncode_r0x0043019a:\n            *(unaff_EBP + -4) = 0;\n            (*pcVar6)(iVar13);\n        }\n    }\ncode_r0x00430303:\n    fcn.004313b1(unaff_EBP + -0x40);\n    (*pcVar6)(unaff_EBP + -0x40);\ncode_r0x00430315:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 3196
    },
    "004306ec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004306ec(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (*param_1 == 0) {\n        if ((param_1[1] != 0) && (uVar2 = (**(*param_1[1] + 0x78))(),  (uVar2 & 0x8000000) != 0)) {\n            return 0;\n        }\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*param_1);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    if ((param_1[1] != 0) && ((*(param_1[1] + 0x6d) & 0x20) != 0)) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 199
    },
    "004308e5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004308e5(uint arg_8h, int32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    \n    piVar2 = fcn.004416b0();\n    if (piVar2 != NULL) {\n        iVar1 = piVar2[0x10];\n        do {\n            if (iVar1 == 0) {\n                return NULL;\n            }\n            ppiVar3 = fcn.0042964f();\n            piVar2 = *ppiVar3;\n        } while (*piVar2 != *(arg_ch + 0x1c));\n    }\n    return piVar2;\n}\n",
        "token_count": 158
    },
    "00430926": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00430926(uint arg_8h, int32_t *arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    int32_t **ppiVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t *piVar7;\n    \n    piVar7 = arg_ch;\n    arg_ch = NULL;\n    piVar3 = piVar7;\n    if ((piVar7 != NULL) && (*piVar7 != 0)) {\n        uVar1 = fcn.00442089(*piVar7);\n        iVar2 = fcn.004307b6(arg_8h, uVar1);\n        if (iVar2 != 0) {\n            piVar3 = fcn.004308e5(arg_8h, iVar2);\n        }\n    }\n    while (((piVar3 = fcn.004444e0(piVar3),  piVar3 != NULL && (arg_ch = arg_ch + 1,  piVar3 != piVar7)) &&\n           (arg_ch < 0x3d))) {\n        iVar2 = fcn.004306cd(piVar3, arg_10h);\n        if (iVar2 != 0) {\n            return piVar3;\n        }\n    }\n    iVar2 = fcn.004416b0();\n    if (iVar2 != 0) {\n        arg_ch = *(iVar2 + 0x40);\n        if (piVar7 == NULL) {\n            ppiVar4 = fcn.0042964f(&arg_ch);\n            piVar3 = *ppiVar4;\n            piVar7 = piVar3;\n        }\n        else {\n            piVar3 = NULL;\n            if (arg_ch == NULL) {\n                return NULL;\n            }\n            do {\n                if (piVar3 == piVar7) break;\n                ppiVar4 = fcn.0042964f();\n                piVar3 = *ppiVar4;\n            } while (arg_ch != NULL);\n        }\n        if (((arg_ch != NULL) && (piVar3 != NULL)) && (piVar7 != NULL)) {\n            do {\n                if (arg_ch == NULL) {\n                    arg_ch = *(iVar2 + 0x40);\n                }\n                ppiVar4 = fcn.0042964f(&arg_ch);\n                piVar3 = *ppiVar4;\n                iVar5 = fcn.004306cd(piVar3, arg_10h);\n                if (iVar5 != 0) {\n                    if (*piVar3 == 0) {\n                        uVar6 = (**(*piVar3[1] + 0x78))();\n                        if ((uVar6 & 0x8000000) == 0) {\n                            return piVar3;\n                        }\n                    }\n                    else {\n                        iVar5 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*piVar3);\n                        if (iVar5 != 0) {\n                            return piVar3;\n                        }\n                    }\n                }\n            } while (piVar3 != piVar7);\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 689
    },
    "00430a43": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00430a43(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    int32_t *arg_ch_00;\n    int32_t iVar5;\n    uint32_t uVar6;\n    int32_t *var_4h;\n    \n    var_4h = NULL;\n    piVar1 = fcn.004308e5(arg_8h, arg_ch);\n    arg_ch_00 = piVar1;\n    if ((piVar1 == NULL) && (iVar2 = fcn.004416b0(),  iVar2 != 0)) {\n        iVar5 = *(iVar2 + 0x40);\n        while (arg_ch_00 = piVar1,  iVar5 != 0) {\n            ppiVar3 = fcn.0042964f();\n            arg_ch_00 = *ppiVar3;\n            if (((*arg_ch_00 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *arg_ch_00 == iVar4)) ||\n               ((arg_ch_00[1] != 0 && (arg_ch_00[1] == *(iVar2 + 0x6c))))) break;\n        }\n    }\n    iVar2 = 0;\n    do {\n        arg_ch_00 = fcn.00430926(arg_8h, arg_ch_00, arg_10h);\n        if (arg_ch_00 == NULL) {\n            return NULL;\n        }\n        iVar5 = fcn.004306ec(arg_ch_00);\n        if ((iVar5 != 0) && (arg_ch_00 = fcn.00444308(arg_ch_00, 0),  arg_ch_00 == NULL)) {\n            return NULL;\n        }\n        if (*arg_ch_00 == 0) {\n            uVar6 = (**(*arg_ch_00[1] + 0x78))();\n            uVar6 = uVar6 & 0x8000000;\n        }\n        else {\n            uVar6 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*arg_ch_00);\n        }\n        if (uVar6 == 0) {\n            return arg_ch_00;\n        }\n        if (arg_ch_00 == var_4h) {\n            return NULL;\n        }\n        if (var_4h == NULL) {\n            var_4h = arg_ch_00;\n        }\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 0x200);\n    return NULL;\n}\n",
        "token_count": 585
    },
    "0044419c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044419c(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_SetFocus)(*(param_1 + 0x1c));\n        fcn.00442089(uVar1);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004441b7. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xb0))();\n    return;\n}\n",
        "token_count": 145
    },
    "00430d39": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00430d39(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    iVar1 = fcn.00430770(arg_10h);\n    if (iVar1 == 0) {\n        return;\n    }\n    if (arg_10h != 0) {\n        uVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(*(arg_10h + 0x1c), 0xffffffec);\n        if ((uVar2 & 0x10000) != 0) {\n            return;\n        }\n        var_4h = fcn.0043072d(arg_10h);\n    }\n    if (arg_ch == arg_10h) {\n        if ((var_4h & 0x20) == 0) {\n            return;\n        }\n        if (arg_ch == 0) goto code_r0x00430e0b;\n        iVar1 = arg_8h;\n        uVar3 = fcn.00430d0c(arg_8h);\n        iVar4 = fcn.00430c06(arg_8h, uVar3);\n        if (((iVar4 == 0) || (iVar4 == arg_10h)) || (uVar2 = fcn.0043072d(iVar4),  (uVar2 & 0x10) == 0))\n        goto code_r0x00430e0b;\ncode_r0x00430dd2:\n        fcn.00430caa(arg_8h, iVar1);\n    }\n    else {\n        iVar1 = arg_10h;\n        if (((arg_ch != 0) && (iVar4 = fcn.0043072d(arg_ch),  iVar4 != 0)) || ((arg_10h != 0 && (var_4h != 0))))\n        goto code_r0x00430dd2;\n    }\n    if ((var_4h & 0x30) == 0) {\n        uVar3 = fcn.00430d0c(arg_8h);\n        arg_10h = fcn.00430c06(arg_8h, uVar3);\n        uVar2 = fcn.0043072d(arg_10h);\n        if ((uVar2 & 0x20) == 0) {\n            return;\n        }\n        iVar1 = fcn.00444160();\n        if (iVar1 == 0) {\n            return;\n        }\n    }\ncode_r0x00430e0b:\n    fcn.00430c5d(arg_10h);\n    return;\n}\n",
        "token_count": 619
    },
    "00431289": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00431289(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CMenu.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.0044588b();\n    uVar1 = (*_sym.imp.USER32.dll_DestroyMenu)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 96
    },
    "004315be": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004315be(uint32_t *param_1, uint32_t param_2, uint32_t param_3)\n\n{\n    if (param_2 < 4) {\n        param_2 = 4;\n    }\n    if (param_3 < 2) {\n        param_3 = 0x40;\n    }\n    param_1[3] = 0;\n    param_1[2] = 0;\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    return;\n}\n",
        "token_count": 126
    },
    "00431602": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00431602(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    \n    if (param_1[3] == 0) {\n        iVar1 = fcn.0043f00e(param_1 + 2, param_1[1], *param_1);\n        iVar3 = param_1[1];\n        piVar2 = iVar1 + 4 + *param_1 * (iVar3 + -1);\n        if (-1 < iVar3 + -1) {\n            do {\n                *piVar2 = param_1[3];\n                param_1[3] = piVar2;\n                piVar2 = piVar2 - *param_1;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    param_1[3] = *param_1[3];\n    return;\n}\n",
        "token_count": 216
    },
    "00431acb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.00431acb(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar1 = fcn.004350c1();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x45c584) {\n        iVar1 = fcn.00435060();\n    }\n    while( true ) {\n        if (*(iVar1 + 0x28) < 2) {\n            uVar2 = *(*(iVar1 + 0x48) + *param_1 * 2) & 8;\n        }\n        else {\n            uVar2 = fcn.00434e58(iVar1, *param_1, 8);\n        }\n        if (uVar2 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 438
    },
    "00431cba": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00431cba(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint arg_8h, uint arg_ch, uint noname_16, uint noname_17, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    int32_t *in_FS_OFFSET;\n    uint *var_8h_3;\n    uint *var_ch_2;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    uint var_34h;\n    uint *var_30h;\n    uint var_2ch;\n    uint *var_28h_2;\n    code *pcStack40;\n    uint uStack36;\n    uint uStack32;\n    uint *puStack28;\n    uint uStack24;\n    uint uStack20;\n    uchar *puStack16;\n    uchar *var_8h_2;\n    int32_t var_4h_2;\n    \n    var_8h_2 = &stack0xfffffffc;\n    puStack16 = &stack0xffffffc4;\n    if (var_8h_3 == 0x123) {\n        *var_ch_2 = 0x431d55;\n        var_34h = 1;\n    }\n    else {\n        pcStack40 = fcn.00431d81;\n        uStack36 = *0x45c1a8;\n        uStack32 = var_20h;\n        puStack28 = var_ch_2;\n        uStack24 = var_1ch;\n        uStack20 = var_18h;\n        var_4h_2 = 0;\n        var_28h_2 = *in_FS_OFFSET;\n        *in_FS_OFFSET = &fcn.00431cba::var_28h_2;\n        var_30h = var_8h_3;\n        var_2ch = var_28h;\n        iVar1 = fcn.004350c1(*var_8h_3, &fcn.00431cba::var_30h);\n        (**(iVar1 + 0x74))();\n        var_34h = 0;\n        if (var_4h_2 == 0) {\n            *in_FS_OFFSET = var_28h_2;\n        }\n        else {\n            *var_28h_2 = **in_FS_OFFSET;\n            *in_FS_OFFSET = var_28h_2;\n        }\n    }\n    return var_34h;\n}\n",
        "token_count": 668
    },
    "00431d81": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00431d81(int32_t param_1, int32_t param_2, uint param_3, uint param_4, uint param_5, uint param_6, uint param_7\n                 , uint param_8)\n\n{\n    uint uVar1;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    int32_t arg_20h;\n    int32_t noname_8;\n    code *extraout_var;\n    code *UNRECOVERED_JUMPTABLE;\n    \n    if (*(param_2 + 8) == *0x45c1a8) {\n        if ((*(param_1 + 4) & 0x66) == 0) {\n            noname_8 = 1;\n            arg_20h = *(param_2 + 0x18);\n            fcn.00435be0(param_1, *(param_2 + 0x10), param_3, 0, *(param_2 + 0xc), *(param_2 + 0x14), arg_20h, 1);\n            UNRECOVERED_JUMPTABLE = extraout_var;\n            if (*(param_2 + 0x24) == 0) {\n                arg_20h = param_2;\n                noname_8 = param_1;\n                fcn.00431bf7(param_2, param_1);\n            }\n            fcn.00431cba(0x123, &stack0xfffffff8, 0, 0, 0, 0, 0, arg_20h, noname_8, unaff_EBX, UNRECOVERED_JUMPTABLE, \n                         unaff_EBP, unaff_retaddr, param_1, param_2, param_3, param_4, param_5, param_6, param_7, \n                         param_8);\n    // WARNING: Could not recover jumptable at 0x00431e2b. Too many branches\n    // WARNING: Treating indirect jump as call\n            uVar1 = (*UNRECOVERED_JUMPTABLE)();\n            return uVar1;\n        }\n        *(param_2 + 0x24) = 1;\n    }\n    else {\n        *(param_1 + 4) = *(param_1 + 4) | 8;\n    }\n    return 1;\n}\n",
        "token_count": 526
    },
    "00431e33": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00431e33(uint32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t *arg_14h, uint32_t *arg_18h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t var_4h;\n    \n    iVar3 = arg_8h;\n    var_4h = *(arg_8h + 0xc);\n    iVar2 = *(arg_8h + 0x10);\n    uVar4 = var_4h;\n    arg_8h = var_4h;\n    if (-1 < arg_ch) {\n        do {\n            if (uVar4 == 0xffffffff) {\n                fcn.00435cb7();\n            }\n            uVar4 = uVar4 - 1;\n            iVar1 = iVar2 + uVar4 * 0x14;\n            if (((*(iVar1 + 4) < arg_10h) && (arg_10h <= *(iVar1 + 8))) || (uVar4 == 0xffffffff)) {\n                arg_ch = arg_ch + -1;\n                var_4h = arg_8h;\n                arg_8h = uVar4;\n            }\n        } while (-1 < arg_ch);\n    }\n    uVar4 = uVar4 + 1;\n    *arg_14h = uVar4;\n    *arg_18h = var_4h;\n    if ((*(iVar3 + 0xc) <= var_4h && var_4h != *(iVar3 + 0xc)) || (var_4h < uVar4)) {\n        fcn.00435cb7();\n    }\n    return iVar2 + uVar4 * 0x14;\n}\n",
        "token_count": 405
    },
    "00431ef6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00431ef6(int32_t param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    \n    iVar2 = fcn.004350c1();\n    if (param_1 == *(iVar2 + 0x88)) {\n        iVar2 = fcn.004350c1();\n        *(iVar2 + 0x88) = *(param_1 + 4);\n        return;\n    }\n    iVar2 = fcn.004350c1();\n    iVar2 = *(iVar2 + 0x88);\n    do {\n        iVar3 = iVar2;\n        if (*(iVar3 + 4) == 0) {\n            fcn.00434920(0x453038, 8);\n            pcVar1 = *0x45c6c4;\n            if (*0x45c6c4 != NULL) {\n                *(unaff_EBP + -4) = 0;\n                (*pcVar1)();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.00434920(0x453028, 8);\n            iVar2 = fcn.004350c1();\n            if (*(iVar2 + 0x6c) != 0) {\n                *(unaff_EBP + -4) = 0;\n                iVar2 = fcn.004350c1();\n                (**(iVar2 + 0x6c))();\n                *(unaff_EBP + -4) = 0xffffffff;\n            }\n            fcn.0043819f(10);\n            fcn.0043bf6a(0x16);\n            fcn.00433adf(3);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        iVar2 = *(iVar3 + 4);\n    } while (param_1 != *(iVar3 + 4));\n    *(iVar3 + 4) = *(param_1 + 4);\n    return;\n}\n",
        "token_count": 447
    },
    "00435c82": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00435c82(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00434920(0x453028, 8);\n    iVar2 = fcn.004350c1();\n    if (*(iVar2 + 0x6c) != 0) {\n        *(unaff_EBP + -4) = 0;\n        iVar2 = fcn.004350c1();\n        (**(iVar2 + 0x6c))();\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.0043819f(10);\n    fcn.0043bf6a(0x16);\n    fcn.00433adf(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 215
    },
    "0043217c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint64_t __cdecl fcn.0043217c(int32_t arg_8h)\n\n{\n    uint64_t uVar1;\n    int32_t *in_EAX;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    bool bVar6;\n    int64_t iVar7;\n    ulong uVar8;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    uint32_t var_ch;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    var_ch = in_EAX[5];\n    var_8h = var_ch >> 0x1f;\n    if ((var_8h < 0) ||\n       ((((-1 < var_ch || var_8h < 0 && (var_ch < 0x45)) || (0 < var_8h)) || ((-1 < var_8h && (0x44c < var_ch)))))) {\ncode_r0x004323c2:\n        _var_ch = -1;\n    }\n    else {\n        iVar4 = in_EAX[4];\n        if ((iVar4 < 0) || (0xb < iVar4)) {\n            uVar2 = iVar4 / 0xc;\n            iVar4 = iVar4 % 0xc;\n            bVar6 = CARRY4(var_ch, uVar2);\n            var_ch = var_ch + uVar2;\n            in_EAX[4] = iVar4;\n            var_8h = var_8h + (uVar2 >> 0x1f) + bVar6;\n            if (iVar4 < 0) {\n                bVar6 = var_ch != 0;\n                var_ch = var_ch - 1;\n                in_EAX[4] = iVar4 + 0xc;\n                var_8h = var_8h + -1 + bVar6;\n            }\n            if ((((var_8h < 0) || ((var_8h < 1 && (var_ch < 0x45)))) || (0 < var_8h)) ||\n               ((-1 < var_8h && (0x44c < var_ch)))) goto code_r0x004323c2;\n        }\n        iVar4 = in_EAX[4];\n        var_14h = *(iVar4 * 4 + 0x45c7b4);\n        var_10h = var_14h >> 0x1f;\n        iVar7 = fcn.004365e0(var_ch, var_8h, 4, 0);\n        if ((iVar7 == 0) && (uVar2 = var_ch,  iVar7 = fcn.004365e0(var_ch, var_8h, 100, 0),  iVar7 != 0)) {\ncode_r0x00432271:\n            if (1 < iVar4) {\n                bVar6 = 0xfffffffe < var_14h;\n                var_14h = var_14h + 1;\n                var_10h = var_10h + bVar6;\n            }\n        }\n        else {\n            uVar2 = var_ch + 0x76c;\n            iVar7 = fcn.004365e0();\n            if (iVar7 == 0) goto code_r0x00432271;\n        }\n        iVar5 = var_ch - 1;\n        iVar4 = var_8h - (var_ch == 0);\n        iVar7 = fcn.00434ac0(var_ch + 299, var_8h + (0xfffffed4 < var_ch), 400, 0, uVar2);\n        uVar2 = iVar7 + in_EAX[3];\n        var_4h = iVar7 + in_EAX[3] >> 0x20;\n        uVar8 = fcn.00434ac0(iVar5, iVar4, 100, 0);\n        var_4h = (var_4h - (uVar8 >> 0x20)) - (uVar2 < uVar8);\n        iVar7 = fcn.00434ac0(iVar5, iVar4, 4, 0);\n        uVar1 = iVar7 + CONCAT44(var_4h, uVar2 - uVar8);\n        var_4h = uVar1 >> 0x20;\n        iVar7 = fcn.00434a80(var_ch, var_8h, 0x16d, 0);\n        iVar7 = iVar7 + (uVar1 & 0xffffffff | var_4h << 0x20) + CONCAT44(var_10h, var_14h);\n        uVar2 = iVar7;\n        var_4h = uVar2 - 0x63df;\n        iVar7 = fcn.00434a80(var_4h, (iVar7 >> 0x20) - (uVar2 < 0x63df), 0x18, 0);\n        iVar7 = fcn.00434a80(iVar7 + in_EAX[2], 0x3c, 0);\n        _var_ch = fcn.00434a80(iVar7 + in_EAX[1], 0x3c, 0);\n        _var_ch = _var_ch + *in_EAX;\n        if (arg_8h == 0) {\n            piVar3 = fcn.00435d3c(&var_ch);\ncode_r0x004323ae:\n            if (piVar3 == NULL) goto code_r0x004323c2;\n        }\n        else {\n            fcn.00436548();\n            _var_ch = _var_ch + *0x45c6d0;\n            piVar3 = fcn.00432c74(&var_ch);\n            if (piVar3 == NULL) goto code_r0x004323c2;\n            if ((0 < in_EAX[8]) || ((in_EAX[8] < 0 && (0 < piVar3[8])))) {\n                _var_ch = _var_ch + *0x45c6d8;\n                piVar3 = fcn.00432c74(&var_ch);\n                goto code_r0x004323ae;\n            }\n        }\n        for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *in_EAX = *piVar3;\n            piVar3 = piVar3 + 1;\n            in_EAX = in_EAX + 1;\n        }\n    }\n    return _var_ch;\n}\n",
        "token_count": 1459
    },
    "00432472": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00432472(uint arg_8h, uint arg_ch, uint arg_10h, int32_t arg_14h)\n\n{\n    char in_AL;\n    int32_t iVar1;\n    int32_t *in_ECX;\n    int32_t *unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint unaff_retaddr;\n    uint noname_1;\n    \n    if (in_AL < '[') {\n        if (in_AL == 'Z') {\ncode_r0x00432663:\n            fcn.00436548();\ncode_r0x004326c8:\n            fcn.004323d9();\n            return 1;\n        }\n        if (in_AL < 'N') {\n            if (in_AL != 'M') {\n                if (in_AL == '%') {\n                    **in_ECX = 0x25;\n                    *in_ECX = *in_ECX + 1;\n                    *unaff_EBX = *unaff_EBX + -1;\n                    return 1;\n                }\n                if ((in_AL == 'A') || (in_AL == 'B')) goto code_r0x004326c8;\n                if ((in_AL != 'H') && (in_AL != 'I')) {\n                    return 1;\n                }\n            }\ncode_r0x0043253a:\n            fcn.004323f9(arg_14h);\n            return 1;\n        }\n        if (((in_AL == 'S') || (in_AL == 'U')) || (in_AL == 'W')) goto code_r0x0043253a;\n        if (in_AL != 'X') {\n            if (in_AL != 'Y') {\n                return 1;\n            }\n            goto code_r0x0043253a;\n        }\n    }\n    else {\n        if ('m' < in_AL) {\n            if (in_AL == 'p') goto code_r0x004326c8;\n            if (in_AL == 'w') goto code_r0x0043253a;\n            if (in_AL == 'x') {\n                if (arg_14h == 0) {\n                    noname_1 = 0;\n                }\n                else {\n                    noname_1 = 1;\n                }\n                goto code_r0x0043254f;\n            }\n            if (in_AL == 'y') goto code_r0x0043253a;\n            if (in_AL != 'z') {\n                return 1;\n            }\n            goto code_r0x00432663;\n        }\n        if (in_AL == 'm') goto code_r0x0043253a;\n        if ((in_AL == 'a') || (in_AL == 'b')) goto code_r0x004326c8;\n        if (in_AL != 'c') {\n            if ((in_AL != 'd') && (in_AL != 'j')) {\n                return 1;\n            }\n            goto code_r0x0043253a;\n        }\n        iVar1 = fcn.004326d8(arg_8h, arg_14h != 0, arg_ch, in_ECX, unaff_EBX, arg_10h, unaff_EDI, unaff_ESI, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h);\n        if (iVar1 == 0) {\n            return 0;\n        }\n        if (*unaff_EBX == 0) {\n            return 0;\n        }\n        **in_ECX = 0x20;\n        *in_ECX = *in_ECX + 1;\n        *unaff_EBX = *unaff_EBX + -1;\n    }\n    noname_1 = 2;\ncode_r0x0043254f:\n    iVar1 = fcn.004326d8(arg_8h, noname_1, arg_ch, in_ECX, unaff_EBX, arg_10h, unaff_EDI, unaff_ESI, unaff_EBP, \n                         unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h);\n    if (iVar1 != 0) {\n        return 1;\n    }\n    return 0;\n}\n",
        "token_count": 931
    },
    "004326d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: var_42h\n\nvoid __cdecl\nfcn.004326d8(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    uint8_t uVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    uint32_t *puVar4;\n    uint8_t **ppuVar5;\n    uint uVar6;\n    code *pcVar7;\n    int32_t iVar8;\n    uint *arg_8h_00;\n    char *pcVar9;\n    int32_t iVar10;\n    char cVar11;\n    uint8_t *puVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    ushort *puVar15;\n    int32_t unaff_EBP;\n    uint var_19h;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_54h_2;\n    uint var_48h_2;\n    uint var_42h_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h_2;\n    uint var_2ch_2;\n    uint var_48h;\n    uint var_42h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    var_20h = 0x38;\n    var_24h = 0x452b08;\n    fcn.00434920();\n    if (*(unaff_EBP + 0xc) == 0) {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa0);\n    }\n    else if (*(unaff_EBP + 0xc) == 1) {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa4);\n    }\n    else {\n        uVar6 = *(*(unaff_EBP + 0x1c) + 0xa8);\n    }\n    *(unaff_EBP + -0x20) = uVar6;\n    if (*(*(unaff_EBP + 0x1c) + 0xb0) == 1) {\n        puVar15 = *(unaff_EBP + 0x10);\n    }\n    else {\n        pcVar7 = _sym.imp.KERNEL32.dll_GetDateFormatA;\n        if (*(unaff_EBP + 0xc) == 2) {\n            pcVar7 = _sym.imp.KERNEL32.dll_GetTimeFormatA;\n        }\n        *(unaff_EBP + -0x30) = pcVar7;\n        puVar15 = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x48) = puVar15[10] + 0x76c;\n        *(unaff_EBP + -0x46) = puVar15[8] + 1;\n        *(unaff_EBP + -0x42) = puVar15[6];\n        *(unaff_EBP + -0x40) = puVar15[4];\n        *(unaff_EBP + -0x3e) = puVar15[2];\n        *(unaff_EBP + -0x3c) = *puVar15;\n        *(unaff_EBP + -0x3a) = 0;\n        arg_8h_00 = &fcn.004326d8::var_24h;\n        iVar8 = (*pcVar7)(*(*(unaff_EBP + 0x1c) + 0xac), 0, unaff_EBP + -0x48, *(unaff_EBP + -0x20), 0, 0);\n        *(unaff_EBP + -0x2c) = iVar8;\n        if (iVar8 != 0) {\n            *(unaff_EBP + -0x34) = 0;\n            *(unaff_EBP + -4) = 0;\n            fcn.004316c0();\n            *(unaff_EBP + -0x18) = &fcn.004326d8::var_24h;\n            *(unaff_EBP + -0x38) = &fcn.004326d8::var_24h;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x8) {\n                arg_8h_00 = fcn.004335fc(*(unaff_EBP + -0x2c));\n                if (arg_8h_00 == NULL) goto code_r0x00432838;\n                *(unaff_EBP + -0x34) = 1;\n            }\n            *(unaff_EBP + -0x24) = arg_8h_00;\n            iVar8 = (**(unaff_EBP + -0x30))\n                              (*(*(unaff_EBP + 0x1c) + 0xac), 0, unaff_EBP + -0x48, *(unaff_EBP + -0x20), arg_8h_00, \n                               *(unaff_EBP + -0x2c));\n            iVar8 = iVar8 + -1;\n            if (0 < iVar8) {\n                piVar2 = *(unaff_EBP + 0x18);\n                piVar3 = *(unaff_EBP + 0x14);\n                do {\n                    if (*piVar2 == 0) break;\n                    **piVar3 = **(unaff_EBP + -0x24);\n                    *piVar3 = *piVar3 + 1;\n                    *(unaff_EBP + -0x24) = *(unaff_EBP + -0x24) + 1;\n                    *piVar2 = *piVar2 + -1;\n                    iVar8 = iVar8 + -1;\n                } while (0 < iVar8);\n            }\n            if (*(unaff_EBP + -0x34) != 0) {\n                fcn.0043360e(arg_8h_00);\n            }\n            goto code_r0x0043282c;\n        }\n    }\ncode_r0x00432838:\n    cVar11 = **(unaff_EBP + -0x20);\n    if (cVar11 != '\\0') {\n        puVar4 = *(unaff_EBP + 0x18);\n        ppuVar5 = *(unaff_EBP + 0x14);\n        while (*puVar4 != 0) {\n            *(unaff_EBP + -0x19) = 0;\n            *(unaff_EBP + -0x28) = 0;\n            pcVar9 = *(unaff_EBP + -0x20);\n            uVar14 = 0;\n            do {\n                uVar13 = uVar14;\n                pcVar9 = pcVar9 + 1;\n                uVar14 = uVar13 + 1;\n            } while (*pcVar9 == cVar11);\n            *(unaff_EBP + -0x24) = pcVar9;\n            if (cVar11 < 'e') {\n                if (cVar11 == 'd') {\n                    if (uVar13 == 0) {\n                        *(unaff_EBP + -0x28) = 1;\n                    }\n                    else if (uVar13 != 1) {\n                        if (uVar13 == 2) {\n                            *(unaff_EBP + -0x19) = 0x61;\n                        }\n                        else if (uVar13 == 3) {\n                            *(unaff_EBP + -0x19) = 0x41;\n                        }\n                        goto code_r0x00432af0;\n                    }\n                    *(unaff_EBP + -0x19) = 100;\n                    goto code_r0x00432af0;\n                }\n                if (cVar11 != '\\'') {\n                    if (cVar11 != 'A') {\n                        if (cVar11 == 'H') {\n                            if (uVar13 == 0) {\n                                *(unaff_EBP + -0x28) = 1;\n                            }\n                            else if (uVar14 != 2) goto code_r0x00432af0;\n                            *(unaff_EBP + -0x19) = 0x48;\n                        }\n                        else if (cVar11 == 'M') {\n                            if (uVar13 == 0) {\n                                *(unaff_EBP + -0x28) = 1;\n                            }\n                            else if (uVar13 != 1) {\n                                if (uVar13 == 2) {\n                                    *(unaff_EBP + -0x19) = 0x62;\n                                }\n                                else if (uVar13 == 3) {\n                                    *(unaff_EBP + -0x19) = 0x42;\n                                }\n                                goto code_r0x00432af0;\n                            }\n                            *(unaff_EBP + -0x19) = 0x6d;\n                        }\n                        else if (cVar11 == 'a') goto code_r0x00432899;\n                        goto code_r0x00432af0;\n                    }\ncode_r0x00432899:\n                    iVar8 = *(unaff_EBP + -0x20);\n                    iVar10 = fcn.004367a0(iVar8, \"am/pm\");\n                    if (iVar10 == 0) {\n                        iVar8 = iVar8 + 5;\ncode_r0x00432917:\n                        *(unaff_EBP + -0x24) = iVar8;\n                    }\n                    else {\n                        iVar10 = fcn.004367a0(iVar8, 0x452af8);\n                        if (iVar10 == 0) {\n                            iVar8 = iVar8 + 3;\n                            goto code_r0x00432917;\n                        }\n                    }\n                    *(unaff_EBP + -0x19) = 0x70;\n                    goto code_r0x00432af0;\n                }\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + uVar14;\n                if ((uVar14 & 1) != 0) {\n                    puVar12 = *(unaff_EBP + -0x20);\n                    while( true ) {\n                        uVar1 = *puVar12;\n                        if ((uVar1 == 0) || (*puVar4 == 0)) goto code_r0x00432b50;\n                        if (uVar1 == 0x27) break;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) == 0) || (*puVar4 < 2)) {\n                            puVar12 = *(unaff_EBP + -0x20);\n                        }\n                        else {\n                            puVar12 = *(unaff_EBP + -0x20) + 1;\n                            if (*puVar12 == 0) goto code_r0x0043282c;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        puVar12 = puVar12 + 1;\n                        *(unaff_EBP + -0x20) = puVar12;\n                        *puVar4 = *puVar4 - 1;\n                    }\n                    *(unaff_EBP + -0x20) = *(unaff_EBP + -0x20) + 1;\n                }\n            }\n            else {\n                if (cVar11 == 'h') {\n                    if (uVar13 == 0) {\n                        *(unaff_EBP + -0x28) = 1;\n                    }\n                    else if (uVar14 != 2) goto code_r0x00432af0;\n                    *(unaff_EBP + -0x19) = 0x49;\ncode_r0x00432af0:\n                    if (*(unaff_EBP + -0x19) == '\\0') {\n                        puVar12 = *(unaff_EBP + -0x20);\n                        uVar1 = *puVar12;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                            puVar12 = puVar12 + 1;\n                            if (*puVar12 == 0) break;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        *(unaff_EBP + -0x20) = puVar12 + 1;\n                        *puVar4 = *puVar4 - 1;\n                        goto code_r0x00432b50;\n                    }\n                    iVar8 = fcn.00432472(*(unaff_EBP + 8), *(unaff_EBP + 0x10), *(unaff_EBP + 0x1c), \n                                         *(unaff_EBP + -0x28));\n                    if (iVar8 == 0) break;\n                }\n                else {\n                    if (cVar11 == 'm') {\n                        if (uVar13 == 0) {\n                            *(unaff_EBP + -0x28) = 1;\n                        }\n                        else if (uVar14 != 2) goto code_r0x00432af0;\n                        *(unaff_EBP + -0x19) = 0x4d;\n                        goto code_r0x00432af0;\n                    }\n                    if (cVar11 == 's') {\n                        if (uVar13 == 0) {\n                            *(unaff_EBP + -0x28) = 1;\n                        }\n                        else if (uVar14 != 2) goto code_r0x00432af0;\n                        *(unaff_EBP + -0x19) = 0x53;\n                        goto code_r0x00432af0;\n                    }\n                    if (cVar11 != 't') {\n                        if (cVar11 == 'y') {\n                            if (uVar13 == 1) {\n                                *(unaff_EBP + -0x19) = 0x79;\n                            }\n                            else if (uVar13 == 3) {\n                                *(unaff_EBP + -0x19) = 0x59;\n                            }\n                        }\n                        goto code_r0x00432af0;\n                    }\n                    if (*(puVar15 + 4) < 0xc) {\n                        puVar12 = *(*(unaff_EBP + 0x1c) + 0x98);\n                    }\n                    else {\n                        puVar12 = *(*(unaff_EBP + 0x1c) + 0x9c);\n                    }\n                    if ((uVar14 == 1) && (*puVar4 != 0)) {\n                        uVar1 = *puVar12;\n                        if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                            puVar12 = puVar12 + 1;\n                            if (*puVar12 == 0) break;\n                            **ppuVar5 = uVar1;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                        **ppuVar5 = *puVar12;\n                        *ppuVar5 = *ppuVar5 + 1;\n                        *puVar4 = *puVar4 - 1;\n                    }\n                    else {\n                        while( true ) {\n                            uVar1 = *puVar12;\n                            if ((uVar1 == 0) || (*puVar4 == 0)) break;\n                            if (((*(*(*(unaff_EBP + 8) + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < *puVar4)) {\n                                puVar12 = puVar12 + 1;\n                                if (*puVar12 == 0) goto code_r0x0043282c;\n                                **ppuVar5 = uVar1;\n                                *ppuVar5 = *ppuVar5 + 1;\n                                *puVar4 = *puVar4 - 1;\n                            }\n                            **ppuVar5 = *puVar12;\n                            *ppuVar5 = *ppuVar5 + 1;\n                            puVar12 = puVar12 + 1;\n                            *puVar4 = *puVar4 - 1;\n                        }\n                    }\n                }\n                *(unaff_EBP + -0x20) = *(unaff_EBP + -0x24);\n            }\ncode_r0x00432b50:\n            cVar11 = **(unaff_EBP + -0x20);\n            if (cVar11 == '\\0') break;\n            puVar15 = *(unaff_EBP + 0x10);\n        }\n    }\ncode_r0x0043282c:\n    *(unaff_EBP + -0x58) = 0x432834;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 4026
    },
    "00432b62": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl\nfcn.00432b62(int32_t arg_8h, uint8_t *arg_ch, uint32_t arg_10h, uint8_t *arg_14h, uint arg_18h, uint32_t arg_1ch)\n\n{\n    uint8_t uVar1;\n    int32_t arg_10h_00;\n    int32_t iVar2;\n    uint8_t *puVar3;\n    bool bVar4;\n    uint var_4h;\n    \n    arg_10h_00 = arg_1ch;\n    if (arg_1ch == 0) {\n        arg_10h_00 = *(arg_8h + 0x4c);\n    }\n    if (arg_10h != 0) {\n        arg_1ch = arg_10h;\n        if (arg_10h == 0) {\ncode_r0x00432c11:\n            bVar4 = arg_1ch == 0;\n        }\n        else {\n            do {\n                uVar1 = *arg_14h;\n                if (uVar1 == 0) break;\n                if (uVar1 == 0x25) {\n                    puVar3 = arg_14h + 1;\n                    uVar1 = *puVar3;\n                    if (uVar1 == 0x23) {\n                        puVar3 = arg_14h + 2;\n                    }\n                    iVar2 = fcn.00432472(arg_8h, arg_18h, arg_10h_00, uVar1 == 0x23);\n                    if (iVar2 == 0) goto code_r0x00432c11;\n                }\n                else {\n                    if (((*(*(arg_8h + 0x48) + 1 + uVar1 * 2) & 0x80) != 0) && (1 < arg_1ch)) {\n                        arg_14h = arg_14h + 1;\n                        if (*arg_14h == 0) goto code_r0x00432c11;\n                        *arg_ch = uVar1;\n                        arg_ch = arg_ch + 1;\n                        arg_1ch = arg_1ch - 1;\n                    }\n                    *arg_ch = *arg_14h;\n                    arg_ch = arg_ch + 1;\n                    arg_1ch = arg_1ch - 1;\n                    puVar3 = arg_14h;\n                }\n                arg_14h = puVar3 + 1;\n            } while (arg_1ch != 0);\n            bVar4 = arg_1ch == 0;\n            if (!bVar4) {\n                *arg_ch = 0;\n                return arg_10h - arg_1ch;\n            }\n        }\n        if (bVar4) {\n            arg_ch = arg_ch + -1;\n        }\n        *arg_ch = 0;\n        arg_10h = 0;\n    }\n    return arg_10h;\n}\n",
        "token_count": 648
    },
    "00432eed": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00432eed(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint *puVar3;\n    uint8_t uVar4;\n    uint16_t uVar5;\n    int32_t iVar6;\n    uint16_t uVar7;\n    uint8_t *puVar8;\n    bool bVar9;\n    \n    iVar6 = fcn.004350c1();\n    iVar6 = *(iVar6 + 0x60);\n    if (iVar6 != *0x460768) {\n        iVar6 = fcn.00434493();\n    }\n    if (*(iVar6 + 8) != 0) {\n        while( true ) {\n            uVar4 = *arg_8h;\n            uVar5 = uVar4;\n            puVar3 = arg_8h + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                if (*puVar3 == 0) {\n                    uVar5 = 0;\n                }\n                else {\n                    uVar5 = CONCAT11(uVar4, *puVar3);\n                    puVar3 = arg_8h + 2;\n                }\n            }\n            arg_8h = puVar3;\n            uVar4 = *arg_ch;\n            uVar7 = uVar4;\n            puVar8 = arg_ch + 1;\n            if ((*(uVar4 + 0x1d + iVar6) & 4) != 0) {\n                uVar1 = *puVar8;\n                if (uVar1 == 0) {\n                    uVar7 = 0;\n                }\n                else {\n                    puVar8 = arg_ch + 2;\n                    uVar7 = CONCAT11(uVar4, uVar1);\n                }\n            }\n            if (uVar7 != uVar5) break;\n            arg_ch = puVar8;\n            if (uVar5 == 0) {\n                return 0;\n            }\n        }\n        return (-(uVar7 < uVar5) & 2) - 1;\n    }\n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar4 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar9 = uVar4 < *arg_ch;\n            if (uVar4 != *arg_ch) goto code_r0x00436864;\n            arg_ch = arg_ch + 1;\n            if (uVar4 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x00436830;\n        }\n        uVar5 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar4 = uVar5;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) goto code_r0x00436864;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar5 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) goto code_r0x00436864;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x00436830:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar4 = uVar2;\n        bVar9 = uVar4 < *arg_ch;\n        if (uVar4 != *arg_ch) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 8;\n        bVar9 = uVar4 < arg_ch[1];\n        if (uVar4 != arg_ch[1]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x10;\n        bVar9 = uVar4 < arg_ch[2];\n        if (uVar4 != arg_ch[2]) break;\n        if (uVar4 == 0) {\n            return 0;\n        }\n        uVar4 = uVar2 >> 0x18;\n        bVar9 = uVar4 < arg_ch[3];\n        if (uVar4 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar4 == 0) {\n            return 0;\n        }\n    }\ncode_r0x00436864:\n    return bVar9 * -2 + 1;\n}\n",
        "token_count": 1083
    },
    "0043334d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0043334d(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_58h;\n    uint lpSystemInfo;\n    int32_t var_48h;\n    uint32_t lpBuffer;\n    int32_t var_24h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint var_13h;\n    uint lpflOldProtect;\n    int32_t dwSize;\n    uint32_t lpAddress;\n    \n    fcn.004316c0();\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(&var_58h, &lpBuffer, 0x1c);\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n        uVar4 = (~(var_48h - 1U) & &var_58h) - var_48h;\n        uVar3 = ((-(*0x45f0f0 != 1) & 0xfffffff1) + 0x11) * var_48h + var_24h;\n        dwSize = var_48h;\n        if (uVar3 <= uVar4) {\n            lpAddress = uVar4;\n            if (*0x45f0f0 != 1) {\n                lpAddress = var_24h;\n                do {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, &lpBuffer, 0x1c);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    lpAddress = lpAddress + var_1ch;\n                } while ((var_18h & 0x1000) == 0);\n                lpAddress = lpBuffer;\n                if ((var_13h & 1) != 0) {\n                    return 1;\n                }\n                if (uVar4 < lpBuffer) {\n                    return 0;\n                }\n                if (lpBuffer < uVar3) {\n                    lpAddress = uVar3;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualAlloc)(lpAddress, dwSize, 0x1000, 4);\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                              (lpAddress, dwSize, (-(*0x45f0f0 != 1) & 0x103) + 1, &lpflOldProtect);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 594
    },
    "00433555": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00433555(uint arg_8h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t arg_8h_00;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452b18, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if ((*0x460760 == 3) && (arg_8h_00 <= *0x46074c)) {\n        fcn.004375c5(4);\n        *(unaff_EBP + -4) = 0;\n        uVar1 = fcn.00437e88(arg_8h_00);\n        *(unaff_EBP + -0x1c) = uVar1;\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.004335c7();\n        if (*(unaff_EBP + -0x1c) != 0) goto code_r0x004335be;\n    }\n    if (arg_8h_00 == 0) {\n        arg_8h_00 = 1;\n    }\n    if (*0x460760 != 1) {\n        arg_8h_00 = arg_8h_00 + 0xf & 0xfffffff0;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x46075c, 0, arg_8h_00);\ncode_r0x004335be:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 368
    },
    "0043360e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043360e(uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_1ch;\n    int32_t arg_ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452b28, 0xc);\n    arg_ch = *(unaff_EBP + 8);\n    if (arg_ch != 0) {\n        if (*0x460760 == 3) {\n            fcn.004375c5(4);\n            *(unaff_EBP + -4) = 0;\n            arg_8h_00 = fcn.004376a9(arg_ch);\n            *(unaff_EBP + -0x1c) = arg_8h_00;\n            if (arg_8h_00 != 0) {\n                fcn.004376d4(arg_8h_00, arg_ch);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.00433661();\n            if (*(unaff_EBP + -0x1c) != 0) goto code_r0x00433679;\n            arg_ch = *(unaff_EBP + 8);\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x46075c, 0, arg_ch);\n    }\ncode_r0x00433679:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 340
    },
    "00433cf2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00433cf2(uint8_t *arg_8h, uint8_t **arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint16_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint *puVar5;\n    uint32_t uVar6;\n    uint8_t uVar7;\n    uint8_t *puVar8;\n    uint32_t var_4h;\n    \n    iVar3 = fcn.004350c1();\n    iVar3 = *(iVar3 + 100);\n    if (iVar3 != *0x45c584) {\n        iVar3 = fcn.00435060();\n    }\n    var_4h = 0;\n    uVar7 = *arg_8h;\n    puVar2 = arg_8h;\n    while( true ) {\n        puVar8 = puVar2 + 1;\n        if (*(iVar3 + 0x28) < 2) {\n            uVar4 = *(*(iVar3 + 0x48) + uVar7 * 2) & 8;\n        }\n        else {\n            uVar4 = fcn.00434e58(iVar3, uVar7, 8);\n        }\n        if (uVar4 == 0) break;\n        uVar7 = *puVar8;\n        puVar2 = puVar8;\n    }\n    if (uVar7 == 0x2d) {\n        arg_14h = arg_14h | 2;\ncode_r0x00433d59:\n        uVar7 = *puVar8;\n        puVar8 = puVar2 + 2;\n    }\n    else if (uVar7 == 0x2b) goto code_r0x00433d59;\n    if (((arg_10h < 0) || (arg_10h == 1)) || (0x24 < arg_10h)) {\n        if (arg_ch != NULL) {\n            *arg_ch = arg_8h;\n        }\n        return 0;\n    }\n    if (arg_10h == 0) {\n        if (uVar7 != 0x30) {\n            arg_10h = 10;\n            goto code_r0x00433dbc;\n        }\n        if ((*puVar8 != 0x78) && (*puVar8 != 0x58)) {\n            arg_10h = 8;\n            goto code_r0x00433dbc;\n        }\n        arg_10h = 0x10;\n    }\n    if (((arg_10h == 0x10) && (uVar7 == 0x30)) && ((*puVar8 == 0x78 || (*puVar8 == 0x58)))) {\n        uVar7 = puVar8[1];\n        puVar8 = puVar8 + 2;\n    }\ncode_r0x00433dbc:\n    uVar4 = 0xffffffff / arg_10h;\n    do {\n        uVar1 = *(*0x45ca64 + uVar7 * 2);\n        if ((uVar1 & 4) == 0) {\n            if ((uVar1 & 0x103) == 0) {\ncode_r0x00433e28:\n                puVar8 = puVar8 + -1;\n                if ((arg_14h & 8) == 0) {\n                    if (arg_ch != NULL) {\n                        puVar8 = arg_8h;\n                    }\n                    var_4h = 0;\n                }\n                else if (((arg_14h & 4) != 0) ||\n                        (((arg_14h & 1) == 0 &&\n                         ((((arg_14h & 2) != 0 && (0x80000000 < var_4h)) ||\n                          (((arg_14h & 2) == 0 && (0x7fffffff < var_4h)))))))) {\n                    puVar5 = fcn.00434b6a();\n                    *puVar5 = 0x22;\n                    if ((arg_14h & 1) == 0) {\n                        var_4h = ((arg_14h & 2) != 0) + 0x7fffffff;\n                    }\n                    else {\n                        var_4h = 0xffffffff;\n                    }\n                }\n                if (arg_ch != NULL) {\n                    *arg_ch = puVar8;\n                }\n                if ((arg_14h & 2) == 0) {\n                    return var_4h;\n                }\n                return -var_4h;\n            }\n            if ((uVar7 < 'a') || ('z' < uVar7)) {\n                iVar3 = uVar7;\n            }\n            else {\n                iVar3 = uVar7 + -0x20;\n            }\n            uVar6 = iVar3 - 0x37;\n        }\n        else {\n            uVar6 = uVar7 - 0x30;\n        }\n        if (arg_10h <= uVar6) goto code_r0x00433e28;\n        if ((var_4h < uVar4) || ((var_4h == uVar4 && (uVar6 <= 0xffffffff % arg_10h)))) {\n            var_4h = var_4h * arg_10h + uVar6;\n            arg_14h = arg_14h | 8;\n        }\n        else {\n            arg_14h = arg_14h | 0xc;\n        }\n        uVar7 = *puVar8;\n        puVar8 = puVar8 + 1;\n    } while( true );\n}\n",
        "token_count": 1243
    },
    "00433edf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00433edf(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint32_t var_4h;\n    \n    uVar1 = arg_8h;\n    if (arg_8h < 0x100) {\n        uVar3 = fcn.0043998d(arg_8h);\n    }\n    else {\n        var_4h = 0;\n        iVar2 = fcn.004350c1();\n        iVar2 = *(iVar2 + 0x60);\n        if (iVar2 != *0x460768) {\n            iVar2 = fcn.00434493();\n        }\n        arg_8h = CONCAT13(uVar1, CONCAT12(uVar1 >> 8, arg_8h));\n        if ((((*(iVar2 + 8) != 0) &&\n             (iVar2 = fcn.00439a40(1, &arg_8h + 2, 2, &var_4h, *(iVar2 + 4), *(iVar2 + 0xc), 1, unaff_EBX, var_4h, \n                                   unaff_EBP, unaff_retaddr, arg_8h, in_stack_00000008, in_stack_0000000c, \n                                   in_stack_00000010),  iVar2 != 0)) && (var_4h._2_2_ == 0)) && ((var_4h & 4) != 0)) {\n            return 1;\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 426
    },
    "00433f63": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00433f63(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint32_t var_4h;\n    \n    uVar1 = arg_8h;\n    if (arg_8h < 0x100) {\n        uVar3 = fcn.00439a06(arg_8h);\n    }\n    else {\n        var_4h = 0;\n        iVar2 = fcn.004350c1();\n        iVar2 = *(iVar2 + 0x60);\n        if (iVar2 != *0x460768) {\n            iVar2 = fcn.00434493();\n        }\n        arg_8h = CONCAT13(uVar1, CONCAT12(uVar1 >> 8, arg_8h));\n        if ((((*(iVar2 + 8) != 0) &&\n             (iVar2 = fcn.00439a40(1, &arg_8h + 2, 2, &var_4h, *(iVar2 + 4), *(iVar2 + 0xc), 1, unaff_EBX, var_4h, \n                                   unaff_EBP, unaff_retaddr, arg_8h, in_stack_00000008, in_stack_0000000c, \n                                   in_stack_00000010),  iVar2 != 0)) && (var_4h._2_2_ == 0)) && ((var_4h & 8) != 0)) {\n            return 1;\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 426
    },
    "00433fe7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00433fe7(char *param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint64_t uVar1;\n    char *pcVar2;\n    uint32_t in_EAX;\n    char *pcVar3;\n    char cVar4;\n    \n    pcVar2 = param_1;\n    if (param_3 != 0) {\n        *param_1 = '-';\n        param_1 = param_1 + 1;\n        in_EAX = -in_EAX;\n        pcVar2 = param_1;\n    }\n    do {\n        pcVar3 = pcVar2;\n        uVar1 = in_EAX;\n        in_EAX = in_EAX / param_2;\n        cVar4 = uVar1 % param_2;\n        if (uVar1 % param_2 < 10) {\n            cVar4 = cVar4 + '0';\n        }\n        else {\n            cVar4 = cVar4 + 'W';\n        }\n        *pcVar3 = cVar4;\n        pcVar2 = pcVar3 + 1;\n    } while (in_EAX != 0);\n    pcVar3[1] = '\\0';\n    do {\n        cVar4 = *pcVar3;\n        *pcVar3 = *param_1;\n        pcVar3 = pcVar3 + -1;\n        *param_1 = cVar4;\n        param_1 = param_1 + 1;\n    } while (param_1 < pcVar3);\n    return;\n}\n",
        "token_count": 341
    },
    "00434071": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.00434071(uint32_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    \n    iVar3 = fcn.004350c1();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x460768) {\n        iVar3 = fcn.00434493();\n    }\n    if (*(iVar3 + 8) == 0) {\n        uVar7 = arg_8h & 3;\n        while (uVar7 != 0) {\n            if (*arg_8h == arg_ch) {\n                return arg_8h;\n            }\n            if (*arg_8h == 0) {\n                return NULL;\n            }\n            uVar7 = arg_8h + 1 & 3;\n            arg_8h = arg_8h + 1;\n        }\n        while( true ) {\n            while( true ) {\n                uVar7 = *arg_8h;\n                uVar6 = uVar7 ^ CONCAT22(CONCAT11(arg_ch, arg_ch), CONCAT11(arg_ch, arg_ch));\n                uVar4 = uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff;\n                puVar5 = arg_8h + 1;\n                if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;\n                arg_8h = puVar5;\n                if ((uVar4 & 0x81010100) != 0) {\n                    if ((uVar4 & 0x1010100) != 0) {\n                        return NULL;\n                    }\n                    if ((uVar7 + 0x7efefeff & 0x80000000) == 0) {\n                        return NULL;\n                    }\n                }\n            }\n            uVar7 = *arg_8h;\n            if (uVar7 == arg_ch) {\n                return arg_8h;\n            }\n            if (uVar7 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 8;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 1;\n            }\n            if (uVar2 == 0) break;\n            uVar2 = uVar7 >> 0x10;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 2;\n            }\n            if (uVar2 == 0) {\n                return NULL;\n            }\n            uVar2 = uVar7 >> 0x18;\n            if (uVar2 == arg_ch) {\n                return arg_8h + 3;\n            }\n            arg_8h = puVar5;\n            if (uVar2 == 0) {\n                return NULL;\n            }\n        }\n        return NULL;\n    }\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar7 = uVar2;\n        if (uVar2 == 0) break;\n        if ((*(uVar7 + 0x1d + iVar3) & 4) == 0) {\n            puVar5 = arg_8h;\n            if (arg_ch == uVar7) break;\n        }\n        else {\n            uVar1 = *(arg_8h + 1);\n            if (uVar1 == 0) {\n                return NULL;\n            }\n            puVar5 = arg_8h + 1;\n            if (arg_ch == CONCAT11(uVar2, uVar1)) {\n                return arg_8h;\n            }\n        }\n        arg_8h = puVar5 + 1;\n    }\n    return ~-(arg_ch != uVar7) & arg_8h;\n}\n",
        "token_count": 880
    },
    "004340ec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_1ch\n\nvoid __cdecl fcn.004340ec(uint arg_8h, uint arg_ch)\n\n{\n    int32_t arg_ch_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452ba8, 0x14);\n    arg_ch_00 = *(unaff_EBP + 8);\n    if (arg_ch_00 == 0) {\n        fcn.004335fc(*(unaff_EBP + 0xc));\n    }\n    else {\n        arg_10h = *(unaff_EBP + 0xc);\n        if (arg_10h == 0) {\n            fcn.0043360e(arg_ch_00);\n        }\n        else if (*0x460760 == 3) {\n            do {\n                *(unaff_EBP + -0x1c) = 0;\n                if (arg_10h < 0xffffffe1) {\n                    fcn.004375c5(4);\n                    *(unaff_EBP + -4) = 0;\n                    iVar1 = fcn.004376a9(arg_ch_00);\n                    *(unaff_EBP + -0x20) = iVar1;\n                    if (iVar1 != 0) {\n                        if (arg_10h <= *0x46074c) {\n                            iVar1 = fcn.00437ba9(iVar1, arg_ch_00, arg_10h);\n                            if (iVar1 == 0) {\n                                iVar1 = fcn.00437e88(arg_10h);\n                                *(unaff_EBP + -0x1c) = iVar1;\n                                if (iVar1 != 0) {\n                                    uVar2 = *(arg_ch_00 + -4) - 1;\n                                    *(unaff_EBP + -0x24) = uVar2;\n                                    if (arg_10h <= uVar2) {\n                                        uVar2 = arg_10h;\n                                    }\n                                    fcn.00431700(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                    uVar3 = fcn.004376a9(arg_ch_00);\n                                    *(unaff_EBP + -0x20) = uVar3;\n                                    fcn.004376d4(uVar3, arg_ch_00);\n                                }\n                            }\n                            else {\n                                *(unaff_EBP + -0x1c) = arg_ch_00;\n                            }\n                        }\n                        if (*(unaff_EBP + -0x1c) == 0) {\n                            if (arg_10h == 0) {\n                                arg_10h = 1;\n                                *(unaff_EBP + 0xc) = 1;\n                            }\n                            arg_10h = arg_10h + 0xf & 0xfffffff0;\n                            *(unaff_EBP + 0xc) = arg_10h;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x46075c, 0, arg_10h);\n                            *(unaff_EBP + -0x1c) = iVar1;\n                            if (iVar1 != 0) {\n                                uVar2 = *(arg_ch_00 + -4) - 1;\n                                *(unaff_EBP + -0x24) = uVar2;\n                                if (arg_10h <= uVar2) {\n                                    uVar2 = arg_10h;\n                                }\n                                fcn.00431700(*(unaff_EBP + -0x1c), arg_ch_00, uVar2);\n                                fcn.004376d4(*(unaff_EBP + -0x20), arg_ch_00);\n                            }\n                        }\n                    }\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    fcn.00434254();\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        if (arg_10h == 0) {\n                            arg_10h = 1;\n                        }\n                        arg_10h = arg_10h + 0xf & 0xfffffff0;\n                        *(unaff_EBP + 0xc) = arg_10h;\n                        uVar3 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x46075c, 0, arg_ch_00, arg_10h);\n                        *(unaff_EBP + -0x1c) = uVar3;\n                    }\n                }\n            } while (((*(unaff_EBP + -0x1c) == 0) && (*0x45f3e4 != 0)) && (iVar1 = fcn.00438184(arg_10h),  iVar1 != 0));\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (arg_10h < 0xffffffe1) {\n                    if (arg_10h == 0) {\n                        arg_10h = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x46075c, 0, arg_ch_00, arg_10h);\n                }\n            } while (((iVar1 == 0) && (*0x45f3e4 != 0)) && (iVar1 = fcn.00438184(arg_10h),  iVar1 != 0));\n        }\n    }\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 1260
    },
    "00434307": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_518h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00434307(void)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    uint unaff_ESI;\n    uint *puVar9;\n    uint noname_8;\n    uint noname_9;\n    uint *noname_2;\n    uint noname_11;\n    uint *noname_4;\n    uint noname_13;\n    uint noname_14;\n    uint noname_15;\n    uint noname_8_00;\n    uint *noname_1;\n    uint noname_10;\n    uint noname_12;\n    uint noname_13_00;\n    uint noname_14_00;\n    uint noname_7;\n    uint *arg_8h;\n    uint var_518h;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffaf8;\n    uint in_stack_fffffafc;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint var_318h;\n    uint var_218h;\n    uint var_118h;\n    uint lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    arg_8h = &lpCPInfo;\n    noname_7 = *0x460884;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    if (iVar2 == 1) {\n        uVar3 = 0;\n        do {\n            *(&var_118h + uVar3) = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n        var_118h._0_1_ = 0x20;\n        if (var_12h != 0) {\n            puVar8 = &var_12h + 1;\n            do {\n                uVar3 = var_12h;\n                if (uVar3 <= *puVar8) {\n                    uVar6 = (*puVar8 - uVar3) + 1;\n                    puVar9 = &var_118h + uVar3;\n                    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                        *puVar9 = 0x20202020;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar9 = 0x20;\n                        puVar9 = puVar9 + 1;\n                    }\n                }\n                var_12h._0_1_ = puVar8[1];\n                puVar8 = puVar8 + 2;\n            } while (var_12h != 0);\n        }\n        noname_14_00 = 0;\n        puVar9 = &var_518h;\n        noname_10 = 0x100;\n        noname_1 = &var_118h;\n        noname_8_00 = 1;\n        noname_12 = *0x460884;\n        noname_13_00 = *0x460764;\n        fcn.00439a40(1, noname_1, 0x100, puVar9, *0x460884, *0x460764, 0, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4);\n        noname_15 = 0;\n        noname_4 = &var_218h;\n        noname_13 = 0x100;\n        noname_11 = 0x100;\n        noname_2 = &var_118h;\n        noname_9 = 0x100;\n        noname_8 = *0x460764;\n        noname_14 = *0x460884;\n        fcn.00439d6e(*0x460764, 0x100, noname_2, 0x100, noname_4, 0x100, *0x460884, 0, noname_8_00, noname_1, noname_10\n                     , puVar9, noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, in_stack_fffffaf8, \n                     in_stack_fffffafc, in_stack_fffffb00, in_stack_fffffb04);\n        fcn.00439d6e(*0x460764, 0x200, &var_118h, 0x100, &var_318h, 0x100, *0x460884, 0, noname_8, noname_9, noname_2, \n                     noname_11, noname_4, noname_13, noname_14, noname_15, noname_8_00, noname_1, noname_10, puVar9, \n                     noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h);\n        uVar3 = 0;\n        do {\n            uVar1 = *(&var_518h + uVar3 * 2);\n            if ((uVar1 & 1) == 0) {\n                if ((uVar1 & 2) != 0) {\n                    *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | 0x20;\n                    uVar4 = *(&var_318h + uVar3);\n                    goto code_r0x00434419;\n                }\n                *(uVar3 + 0x4608a0) = 0;\n            }\n            else {\n                *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | 0x10;\n                uVar4 = *(&var_218h + uVar3);\ncode_r0x00434419:\n                *(uVar3 + 0x4608a0) = uVar4;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    else {\n        uVar3 = 0;\n        do {\n            if ((uVar3 < 0x41) || (0x5a < uVar3)) {\n                if ((0x60 < uVar3) && (uVar3 < 0x7b)) {\n                    *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | 0x20;\n                    cVar5 = uVar3 + -0x20;\n                    goto code_r0x0043445c;\n                }\n                *(uVar3 + 0x4608a0) = 0;\n            }\n            else {\n                *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | 0x10;\n                cVar5 = uVar3 + ' ';\ncode_r0x0043445c:\n                *(uVar3 + 0x4608a0) = cVar5;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1822
    },
    "00434502": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00434502(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t extraout_ECX;\n    uint extraout_ECX_00;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    uint8_t *puVar7;\n    uint *puVar8;\n    uint32_t var_1ch;\n    uint32_t lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    if (arg_8h != 0) {\n        iVar5 = 0;\n        uVar3 = 0;\ncode_r0x00434524:\n        if (*(uVar3 + 0x45c2b0) != arg_8h) goto code_r0x0043452c;\n        puVar8 = 0x460780;\n        for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {\n            *puVar8 = 0;\n            puVar8 = puVar8 + 1;\n        }\n        var_1ch = 0;\n        *puVar8 = 0;\n        puVar6 = iVar5 * 0x30 + 0x45c2c0;\n        do {\n            uVar2 = *puVar6;\n            puVar7 = puVar6;\n            while ((uVar2 != 0 && (uVar1 = puVar7[1],  uVar1 != 0))) {\n                uVar3 = uVar2;\n                if (uVar3 <= uVar1) {\n                    uVar2 = *(var_1ch + 0x45c2a8);\n                    do {\n                        *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | uVar2;\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar1);\n                }\n                puVar7 = puVar7 + 2;\n                uVar2 = *puVar7;\n            }\n            var_1ch = var_1ch + 1;\n            puVar6 = puVar6 + 8;\n        } while (var_1ch < 4);\n        *0x460884 = arg_8h;\n        *0x46076c = 1;\n        *0x460764 = fcn.004342af();\n        *0x460890 = *(extraout_ECX + 0x45c2b4);\n        *0x460894 = *(extraout_ECX + 0x45c2b8);\n        *0x460898 = *(extraout_ECX + 0x45c2bc);\n        goto code_r0x00434679;\n    }\ncode_r0x00434674:\n    fcn.004342de();\ncode_r0x00434679:\n    fcn.00434307();\ncode_r0x00434685:\n    fcn.004316b0();\n    return;\ncode_r0x0043452c:\n    uVar3 = uVar3 + 0x30;\n    iVar5 = iVar5 + 1;\n    if (0xef < uVar3) goto code_r0x00434537;\n    goto code_r0x00434524;\ncode_r0x00434537:\n    iVar5 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(arg_8h, &lpCPInfo);\n    if (iVar5 != 1) {\n        if (*0x45f138 == 0) goto code_r0x00434685;\n        goto code_r0x00434674;\n    }\n    puVar8 = 0x460780;\n    for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n    }\n    *puVar8 = 0;\n    *0x460884 = arg_8h;\n    *0x460764 = 0;\n    if (lpCPInfo < 2) {\n        *0x46076c = 0;\n    }\n    else {\n        if (var_12h != '\\0') {\n            puVar6 = &var_12h + 1;\n            do {\n                uVar2 = *puVar6;\n                if (uVar2 == 0) break;\n                for (uVar3 = puVar6[-1]; uVar3 <= uVar2; uVar3 = uVar3 + 1) {\n                    *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | 4;\n                }\n                puVar7 = puVar6 + 1;\n                puVar6 = puVar6 + 2;\n            } while (*puVar7 != 0);\n        }\n        uVar3 = 1;\n        do {\n            *(uVar3 + 0x460781) = *(uVar3 + 0x460781) | 8;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0xff);\n        *0x460764 = fcn.004342af();\n        *0x46076c = extraout_ECX_00;\n    }\n    *0x460890 = 0;\n    *0x460894 = 0;\n    *0x460898 = 0;\n    goto code_r0x00434679;\n}\n",
        "token_count": 1238
    },
    "00434800": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00434800(uint lpMem, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t unaff_EBP;\n    uint32_t arg_10h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452bd8, 0x10);\n    arg_10h = *(unaff_EBP + 0xc);\n    if (arg_10h < 0xffffffe1) {\n        if (*0x460760 == 3) {\n            fcn.004375c5(4);\n            *(unaff_EBP + -4) = 0;\n            uVar2 = *(unaff_EBP + 8);\n            iVar1 = fcn.004376a9(uVar2);\n            *(unaff_EBP + -0x20) = iVar1;\n            if (((iVar1 != 0) && (*(unaff_EBP + -0x1c) = 0,  arg_10h <= *0x46074c)) &&\n               (iVar1 = fcn.00437ba9(iVar1, uVar2, arg_10h),  iVar1 != 0)) {\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043487e();\n            if (*(unaff_EBP + -0x20) != 0) goto code_r0x004348a4;\n            if (arg_10h == 0) {\n                arg_10h = 1;\n            }\n            arg_10h = arg_10h + 0xf & 0xfffffff0;\n        }\n        else if (arg_10h == 0) {\n            arg_10h = 1;\n        }\n        uVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x46075c, 0x10, *(unaff_EBP + 8), arg_10h);\n        *(unaff_EBP + -0x1c) = uVar2;\n    }\ncode_r0x004348a4:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 519
    },
    "004348aa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.004348aa(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452be8, 0x10);\n    if (*0x460760 == 3) {\n        fcn.004375c5(4);\n        *(unaff_EBP + -4) = 0;\n        iVar1 = *(unaff_EBP + 8);\n        iVar2 = fcn.004376a9(iVar1);\n        *(unaff_EBP + -0x20) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -0x1c) = *(iVar1 + -4) + -9;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00434917();\n        if (*(unaff_EBP + -0x20) != 0) goto code_r0x0043490c;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapSize)(*0x46075c, 0, *(unaff_EBP + 8));\ncode_r0x0043490c:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 320
    },
    "00434bef": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00434bef(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452bf8, 0x10);\n    uVar2 = *(unaff_EBP + 8) * *(unaff_EBP + 0xc);\n    *(unaff_EBP + -0x20) = uVar2;\n    if (uVar2 == 0) {\n        uVar2 = 1;\n    }\n    do {\n        iVar3 = 0;\n        *(unaff_EBP + -0x1c) = 0;\n        if (uVar2 < 0xffffffe1) {\n            if (*0x460760 == 3) {\n                uVar2 = uVar2 + 0xf & 0xfffffff0;\n                *(unaff_EBP + 0xc) = uVar2;\n                arg_8h_00 = *(unaff_EBP + -0x20);\n                if (*0x46074c < arg_8h_00) goto code_r0x00434c64;\n                fcn.004375c5(4);\n                *(unaff_EBP + -4) = 0;\n                uVar1 = fcn.00437e88(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar1;\n                *(unaff_EBP + -4) = 0xffffffff;\n                fcn.00434c99();\n                iVar3 = *(unaff_EBP + -0x1c);\n                if (iVar3 != 0) {\n                    fcn.00433ba0(iVar3, 0, *(unaff_EBP + -0x20));\n                    goto code_r0x00434c64;\n                }\n            }\n            else {\ncode_r0x00434c64:\n                if (iVar3 != 0) {\ncode_r0x00434ca4:\n                    fcn.0043495b();\n                    return;\n                }\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x46075c, 8, uVar2);\n        }\n        if (((iVar3 != 0) || (*0x45f3e4 == 0)) || (iVar3 = fcn.00438184(uVar2),  iVar3 == 0)) goto code_r0x00434ca4;\n    } while( true );\n}\n",
        "token_count": 607
    },
    "004350a4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004350a4(void)\n\n{\n    int32_t arg_8h;\n    code *pcVar1;\n    int32_t *piVar2;\n    \n    if (*0x45c6bc != -1) {\n        (**0x45f160)(*0x45c6bc);\n        *0x45c6bc = -1;\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_DeleteCriticalSection;\n    piVar2 = 0x45c7f8;\n    do {\n        arg_8h = *piVar2;\n        if ((arg_8h != 0) && (piVar2[1] != 1)) {\n            (*pcVar1)(arg_8h);\n            fcn.0043360e(arg_8h);\n            *piVar2 = 0;\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x45c918);\n    piVar2 = 0x45c7f8;\n    do {\n        if ((*piVar2 != 0) && (piVar2[1] == 1)) {\n            (*pcVar1)(*piVar2);\n        }\n        piVar2 = piVar2 + 2;\n    } while (piVar2 < 0x45c918);\n    return;\n}\n",
        "token_count": 293
    },
    "00435279": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00435279(void)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint uVar4;\n    \n    iVar2 = fcn.00437472();\n    if (iVar2 == 0) {\n        fcn.004350a4();\n        return 0;\n    }\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n    if (iVar2 != 0) {\n        *0x45f154 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"FlsAlloc\");\n        *0x45f158 = (*pcVar1)(iVar2, \"FlsGetValue\");\n        *0x45f15c = (*pcVar1)(iVar2, \"FlsSetValue\");\n        *0x45f160 = (*pcVar1)(iVar2, \"FlsFree\");\n        if (*0x45f158 == 0) {\n            *0x45f158 = _sym.imp.KERNEL32.dll_TlsGetValue;\n            *0x45f15c = _sym.imp.KERNEL32.dll_TlsSetValue;\n            *0x45f154 = 0x43509b;\n            *0x45f160 = _sym.imp.KERNEL32.dll_TlsFree;\n        }\n    }\n    *0x45c6bc = (**0x45f154)(0x435132);\n    if (((*0x45c6bc != -1) && (puVar3 = fcn.00434bef(1, 0x8c),  puVar3 != NULL)) &&\n       (iVar2 = (**0x45f15c)(*0x45c6bc, puVar3),  iVar2 != 0)) {\n        puVar3[0x15] = 0x45c9b8;\n        puVar3[5] = 1;\n        uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        puVar3[1] = 0xffffffff;\n        *puVar3 = uVar4;\n        return 1;\n    }\n    fcn.004350a4();\n    return 0;\n}\n",
        "token_count": 490
    },
    "004353d8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.004353d8(uint32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint8_t *unaff_ESI;\n    uint8_t *unaff_EDI;\n    \n    iVar1 = *(unaff_ESI + 4);\n    if ((iVar1 != 0) && (*(iVar1 + 8) != '\\0')) {\n        if ((iVar1 != *(unaff_EDI + 4)) && (iVar1 = fcn.00436820(iVar1 + 8, *(unaff_EDI + 4) + 8),  iVar1 != 0)) {\n            return 0;\n        }\n        if (((((*unaff_EDI & 2) != 0) && ((*unaff_ESI & 8) == 0)) || (((*param_1 & 1) != 0 && ((*unaff_ESI & 1) == 0))))\n           || (((*param_1 & 2) != 0 && ((*unaff_ESI & 2) == 0)))) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 243
    },
    "00435445": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00435445(uint arg_8h, uint noname_1, uint arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452fd8, 0x10);\n    iVar1 = *(unaff_EBP + 8);\n    iVar5 = *(iVar1 + 8);\n    *(unaff_EBP + -0x1c) = iVar5;\n    iVar2 = fcn.004350c1();\n    *(iVar2 + 0x84) = *(iVar2 + 0x84) + 1;\n    *(unaff_EBP + -4) = 0;\n    iVar2 = *(unaff_EBP + 0x10);\n    while (iVar5 != *(unaff_EBP + 0x14)) {\n        if ((iVar5 < 0) || (*(iVar2 + 4) <= iVar5)) {\n            fcn.00435cb7();\n        }\n        iVar3 = iVar5 * 8;\n        piVar4 = *(iVar2 + 8) + iVar3;\n        iVar5 = *piVar4;\n        *(unaff_EBP + -0x20) = iVar5;\n        *(unaff_EBP + -4) = 1;\n        if (piVar4[1] != 0) {\n            *(iVar1 + 8) = iVar5;\n            fcn.00435cf0(*(*(iVar2 + 8) + 4 + iVar3), iVar1, 0x103);\n        }\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x1c) = iVar5;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004354f8();\n    if (iVar5 != *(unaff_EBP + 0x14)) {\n        fcn.00435cb7();\n    }\n    *(iVar1 + 8) = iVar5;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 530
    },
    "004354f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004354f8(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004350c1();\n    if (0 < *(iVar1 + 0x84)) {\n        iVar1 = fcn.004350c1();\n        *(iVar1 + 0x84) = *(iVar1 + 0x84) + -1;\n    }\n    return;\n}\n",
        "token_count": 89
    },
    "00435558": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00435558(int32_t *param_1)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = *param_1 + in_EAX;\n    if (-1 < param_1[1]) {\n        iVar1 = iVar1 + *(*(param_1[1] + in_EAX) + param_1[2]) + param_1[1];\n    }\n    return iVar1;\n}\n",
        "token_count": 104
    },
    "004356cc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.004356cc(void)\n\n{\n    int32_t iVar1;\n    int32_t unaff_EBP;\n    int32_t *unaff_ESI;\n    int32_t unaff_EDI;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_20h;\n    \n    *(unaff_EDI + -4) = *(unaff_EBP + -0x38);\n    fcn.00431ef6(*(unaff_EBP + -0x3c));\n    iVar1 = fcn.004350c1();\n    *(iVar1 + 0x7c) = *(unaff_EBP + -0x40);\n    iVar1 = fcn.004350c1();\n    *(iVar1 + 0x80) = *(unaff_EBP + -0x44);\n    if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&\n        ((unaff_ESI[5] == 0x19930520 || (unaff_ESI[5] == 0x19930521)))) &&\n       ((*(unaff_EBP + -0x48) == 0 && (*(unaff_EBP + -0x20) != 0)))) {\n        iVar1 = fcn.00431ed5(unaff_ESI[6]);\n        if (iVar1 != 0) {\n            fcn.00432046();\n            fcn.00435513(unaff_ESI);\n        }\n    }\n    return;\n}\n",
        "token_count": 356
    },
    "0043573b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043573b(uint arg_8h, uint arg_ch)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint arg_ch_00;\n    uint uVar5;\n    uint8_t *extraout_ECX;\n    int32_t *extraout_EDX;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    uint var_4h;\n    \n    fcn.00434920(0x453018, 8);\n    puVar1 = *(unaff_EBP + 0xc);\n    iVar4 = *(unaff_EBP + 8);\n    if (((puVar1[1] == 0) || (*(puVar1[1] + 8) == '\\0')) || ((puVar1[2] == 0 && ((*(puVar1 + 3) & 0x80) == 0))))\n    goto code_r0x004358a5;\n    uVar2 = *puVar1;\n    arg_8h_00 = extraout_EDX;\n    if (-1 < uVar2) {\n        arg_8h_00 = puVar1[2] + 0xc + extraout_EDX;\n    }\n    *(unaff_EBP + -4) = 0;\n    uVar5 = *(iVar4 + 0x18);\n    if ((uVar2 & 8) == 0) {\n        if ((*extraout_ECX & 1) == 0) {\n            if (*(extraout_ECX + 0x18) == 0) {\n                iVar4 = fcn.0043abac(uVar5, 1);\n                if ((iVar4 == 0) || (iVar4 = fcn.0043abc8(arg_8h_00, 1),  iVar4 == 0)) {\ncode_r0x0043589c:\n                    fcn.00435cb7();\n                }\n                else {\n                    uVar5 = *(extraout_ECX + 0x14);\n                    arg_ch_00 = fcn.00435558();\n                    fcn.00433010(arg_8h_00, arg_ch_00, uVar5);\n                }\n            }\n            else {\n                iVar4 = fcn.0043abac(uVar5, 1);\n                if (((iVar4 == 0) || (iVar4 = fcn.0043abc8(arg_8h_00, 1),  iVar4 == 0)) ||\n                   (iVar4 = fcn.0043abe4(*(extraout_ECX + 0x18)),  iVar4 == 0)) goto code_r0x0043589c;\n                if ((*extraout_ECX & 4) == 0) {\n                    uVar5 = fcn.00435558();\n                    fcn.00431bf0(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n                else {\n                    uVar5 = fcn.00435558(1);\n                    fcn.00431bf0(arg_8h_00, *(extraout_ECX + 0x18), uVar5);\n                }\n            }\n        }\n        else {\n            iVar3 = fcn.0043abac(uVar5, 1);\n            if ((iVar3 == 0) || (iVar3 = fcn.0043abc8(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x0043589c;\n            fcn.00433010(arg_8h_00, *(iVar4 + 0x18), *(extraout_ECX + 0x14));\n            if ((*(extraout_ECX + 0x14) == 4) && (*arg_8h_00 != 0)) goto code_r0x004357b4;\n        }\n    }\n    else {\n        iVar3 = fcn.0043abac(uVar5, 1);\n        if ((iVar3 == 0) || (iVar3 = fcn.0043abc8(arg_8h_00, 1),  iVar3 == 0)) goto code_r0x0043589c;\n        *arg_8h_00 = *(iVar4 + 0x18);\ncode_r0x004357b4:\n        iVar4 = fcn.00435558();\n        *arg_8h_00 = iVar4;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\ncode_r0x004358a5:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 1036
    },
    "004358b7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004358b7(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t unaff_ESI;\n    uint *unaff_EDI;\n    \n    if (in_ECX != 0) {\n        fcn.0043573b(arg_8h, unaff_EBX);\n    }\n    if (arg_1ch == 0) {\n        arg_1ch = unaff_ESI;\n    }\n    fcn.00431bf7(arg_1ch, arg_8h);\n    fcn.00435445(unaff_ESI, arg_10h, arg_14h, *unaff_EDI);\n    *(unaff_ESI + 8) = unaff_EDI[1] + 1;\n    iVar1 = fcn.00435577(arg_8h, unaff_ESI, arg_ch, arg_14h, arg_18h, 0x100);\n    if (iVar1 != 0) {\n        fcn.00431bc0(iVar1);\n    }\n    return;\n}\n",
        "token_count": 278
    },
    "0043591e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl\nfcn.0043591e(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, int32_t arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_retaddr;\n    uint in_stack_00000024;\n    uint32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((*arg_8h != -0x7ffffffd) &&\n       (((iVar1 = fcn.004350c1(),  *(iVar1 + 0x74) == 0 ||\n         (iVar1 = fcn.00431cba(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h, unaff_ESI, var_8h, var_4h, \n                               unaff_EBP, unaff_retaddr, arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, \n                               arg_24h, in_stack_00000024),  iVar1 == 0)) &&\n        (piVar2 = fcn.00431e33(arg_18h, arg_20h, arg_1ch, &var_4h, &var_8h),  var_4h < var_8h)))) {\n        do {\n            if (((*piVar2 <= arg_1ch) && (arg_1ch <= piVar2[1])) &&\n               ((iVar1 = *(piVar2[3] * 0x10 + piVar2[4] + -0xc),  iVar1 == 0 || (*(iVar1 + 8) == '\\0')))) {\n                fcn.004358b7(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n            }\n            var_4h = var_4h + 1;\n            piVar2 = piVar2 + 5;\n        } while (var_4h < var_8h);\n    }\n    return;\n}\n",
        "token_count": 548
    },
    "004359dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_1h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.004359dc(int32_t *arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, int32_t arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    uint var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    int32_t var_14h;\n    int32_t *var_10h;\n    uint32_t var_ch;\n    int32_t *var_8h;\n    uchar auStack8 [3];\n    uint var_1h;\n    \n    var_1ch = *(arg_ch + 8);\n    _auStack8 = auStack8;\n    if ((var_1ch < -1) || (*(arg_18h + 4) <= var_1ch)) {\n        fcn.00435cb7();\n    }\n    if (*arg_8h == -0x1f928c9d) {\n        if ((arg_8h[4] == 3) && (((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)) && (arg_8h[7] == 0)))) {\n            iVar2 = fcn.004350c1();\n            if (*(iVar2 + 0x7c) == 0) {\n                return;\n            }\n            iVar2 = fcn.004350c1();\n            arg_8h = *(iVar2 + 0x7c);\n            iVar2 = fcn.004350c1();\n            arg_10h = *(iVar2 + 0x80);\n            _auStack8 = CONCAT13(1, auStack8);\n            iVar2 = fcn.0043abac(arg_8h, 1);\n            if (iVar2 == 0) {\n                fcn.00435cb7();\n            }\n            if (*arg_8h != -0x1f928c9d) goto code_r0x00435bb5;\n            if (((arg_8h[4] == 3) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521)))) && (arg_8h[7] == 0)) {\n                fcn.00435cb7();\n            }\n        }\n        iVar2 = var_1ch;\n        if (((*arg_8h == -0x1f928c9d) && (arg_8h[4] == 3)) && ((arg_8h[5] == 0x19930520 || (arg_8h[5] == 0x19930521))))\n        {\n            piVar3 = fcn.00431e33(arg_18h, arg_20h, var_1ch, &var_ch, &var_20h);\n            var_8h = piVar3;\n            if (var_ch < var_20h) {\n                do {\n                    if ((*piVar3 == iVar2 || *piVar3 < iVar2) && (iVar2 <= piVar3[1])) {\n                        var_8h = piVar3;\n                        for (var_18h = piVar3[3]; 0 < var_18h; var_18h = var_18h + -1) {\n                            var_10h = *(arg_8h[7] + 0xc);\n                            for (var_14h = *var_10h; var_10h = var_10h + 1,  0 < var_14h; var_14h = var_14h + -1) {\n                                iVar2 = fcn.004353d8(arg_8h[7]);\n                                piVar3 = var_8h;\n                                if (iVar2 != 0) {\n                                    fcn.004358b7(arg_8h, arg_10h, arg_14h, arg_18h, arg_20h, arg_24h);\n                                    goto code_r0x00435b88;\n                                }\n                            }\n                        }\n                    }\ncode_r0x00435b88:\n                    var_ch = var_ch + 1;\n                    piVar3 = piVar3 + 5;\n                    iVar2 = var_1ch;\n                    var_8h = piVar3;\n                } while (var_ch < var_20h);\n            }\n            if (arg_1ch == '\\0') {\n                return;\n            }\n            fcn.00435513(arg_8h);\n            return;\n        }\n    }\ncode_r0x00435bb5:\n    if (arg_1ch == '\\0') {\n        fcn.0043591e(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, var_1ch, arg_20h, arg_24h);\n        return;\n    }\n    fcn.00434920(0x453028, 8);\n    iVar2 = fcn.004350c1();\n    if (*(iVar2 + 0x6c) != 0) {\n        _auStack8 = 0;\n        iVar2 = fcn.004350c1();\n        (**(iVar2 + 0x6c))();\n        _auStack8 = 0xffffffff;\n    }\n    fcn.0043819f(10);\n    fcn.0043bf6a(0x16);\n    fcn.00433adf(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 1285
    },
    "00435be0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl\nfcn.00435be0(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint32_t *arg_18h, int32_t arg_1ch, uint arg_20h\n            , uint32_t arg_24h)\n\n{\n    uint uVar1;\n    \n    if ((*arg_18h & 0x1fffffff) != 0x19930520) {\n        fcn.00435cb7();\n    }\n    if ((*(arg_8h + 1) & 0x66) == 0) {\n        if (arg_18h[3] != 0) {\n            if (((*arg_8h == -0x1f928c9d) && (0x19930520 < arg_8h[5])) && (*(arg_8h[7] + 8) != NULL)) {\n                uVar1 = (**(arg_8h[7] + 8))(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, arg_20h, arg_24h & 0xff)\n                ;\n                return uVar1;\n            }\n            fcn.004359dc(arg_8h, arg_ch, arg_10h, arg_14h, arg_18h, arg_24h, arg_1ch, arg_20h);\n        }\n    }\n    else if ((arg_18h[1] != 0) && (arg_1ch == 0)) {\n        fcn.00435445(arg_ch, arg_14h, arg_18h, 0xffffffff);\n    }\n    return 1;\n}\n",
        "token_count": 377
    },
    "00435d3c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00435d3c(int64_t *arg_8h)\n\n{\n    bool bVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t *piVar6;\n    int64_t iVar7;\n    int64_t iVar8;\n    int64_t iVar9;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    bVar1 = false;\n    iVar5 = *(arg_8h + 4);\n    iVar4 = *arg_8h;\n    iVar8 = *arg_8h;\n    iVar2 = fcn.004350c1();\n    if (((iVar5 < 0) || (0x1000 < iVar5)) || ((0xfff < iVar5 && (iVar4 != 0)))) {\n        return NULL;\n    }\n    if (*(iVar2 + 0x44) == 0) {\n        iVar3 = fcn.004335fc(0x24);\n        *(iVar2 + 0x44) = iVar3;\n        if (iVar3 != 0) goto code_r0x00435da2;\n        piVar6 = 0x45f164;\n    }\n    else {\ncode_r0x00435da2:\n        piVar6 = *(iVar2 + 0x44);\n    }\n    iVar4 = fcn.00434ac0(iVar4, iVar5, 0x1e13380, 0);\n    var_4h = iVar4 + 0x46;\n    iVar5 = iVar4 + 0x45;\n    iVar7 = fcn.00434a80(iVar4, iVar4 >> 0x1f, 0xfffffe93, 0xffffffff);\n    iVar7 = fcn.00434a80(iVar7 - (((iVar4 + 0x171) / 400 - iVar5 / 100) + -0x11 + iVar5 / 4), 0x15180, 0);\n    iVar7 = iVar7 + iVar8;\n    iVar2 = iVar7;\n    if ((iVar7 < 0x100000000) && (iVar7 < 0)) {\n        iVar7 = iVar7 + 0x1e13380;\n        var_4h = iVar5;\n        if (((iVar5 % 4 != 0) || (iVar5 % 100 == 0)) && ((iVar4 + 0x7b1) % 400 != 0)) goto code_r0x00435e9e;\n        iVar7 = CONCAT44((iVar7 >> 0x20) + (0xfffeae7f < iVar7), iVar2 + 0x1e28500);\n    }\n    else if (((var_4h % 4 != 0) || (var_4h % 100 == 0)) && ((iVar4 + 0x7b2) % 400 != 0)) goto code_r0x00435e9e;\n    bVar1 = true;\ncode_r0x00435e9e:\n    piVar6[5] = var_4h;\n    iVar5 = fcn.00434ac0(iVar7, 0x15180, 0);\n    piVar6[7] = iVar5;\n    iVar8 = fcn.00434a80(iVar5, iVar5 >> 0x1f, 0xfffeae80, 0xffffffff);\n    iVar5 = 0x45c780;\n    if (!bVar1) {\n        iVar5 = 0x45c7b4;\n    }\n    iVar2 = 1;\n    iVar4 = *(iVar5 + 4);\n    while (iVar4 < piVar6[7]) {\n        iVar2 = iVar2 + 1;\n        iVar4 = *(iVar5 + iVar2 * 4);\n    }\n    piVar6[4] = iVar2 + -1;\n    piVar6[3] = piVar6[7] - *(iVar5 + (iVar2 + -1) * 4);\n    iVar5 = fcn.00434ac0(*arg_8h, *(arg_8h + 4), 0x15180, 0);\n    piVar6[6] = (iVar5 + 4) % 7;\n    iVar5 = fcn.00434ac0(iVar8 + iVar7, 0xe10, 0);\n    piVar6[2] = iVar5;\n    iVar9 = fcn.00434a80(iVar5, iVar5 >> 0x1f, 0xfffff1f0, 0xffffffff);\n    iVar9 = iVar8 + iVar7 + iVar9;\n    iVar5 = fcn.00434ac0(iVar9, 0x3c, 0);\n    piVar6[1] = iVar5;\n    *piVar6 = iVar9 + iVar5 * -0x3c;\n    piVar6[8] = 0;\n    return piVar6;\n}\n",
        "token_count": 1128
    },
    "00435f61": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid fcn.00435f61(void)\n\n{\n    char cVar1;\n    code *pcVar2;\n    uint uVar3;\n    char *arg_8h;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    char *pcVar5;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00434920(0x453088, 0x18);\n    *(unaff_EBP + -0x20) = 0;\n    fcn.004375c5(7);\n    *(unaff_EBP + -4) = 0;\n    uVar3 = *0x45f51c;\n    *(unaff_EBP + -0x28) = *0x45f51c;\n    *0x45f234 = 0;\n    *0x45c774 = 0xffffffff;\n    *0x45c768 = 0xffffffff;\n    arg_8h = fcn.0043ac14(0x453084);\n    *(unaff_EBP + -0x24) = arg_8h;\n    if ((arg_8h == NULL) || (*arg_8h == '\\0')) {\n        if (*0x45f238 != 0) {\n            fcn.0043360e(*0x45f238);\n            *0x45f238 = 0;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_GetTimeZoneInformation)(0x45f188);\n        pcVar2 = _sym.imp.KERNEL32.dll_WideCharToMultiByte;\n        if (iVar4 != -1) {\n            *0x45f234 = 1;\n            *0x45c6d0 = *0x45f188 * 0x3c;\n            if (*0x45f1ce != 0) {\n                *0x45c6d0 = *0x45c6d0 + *0x45f1dc * 0x3c;\n            }\n            if ((*0x45f222 == 0) || (*0x45f230 == 0)) {\n                *0x45c6d4 = 0;\n                *0x45c6d8 = 0;\n            }\n            else {\n                *0x45c6d4 = 1;\n                *0x45c6d8 = (*0x45f230 - *0x45f1dc) * 0x3c;\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                              (uVar3, 0, 0x45f18c, 0xffffffff, *0x45c760, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar4 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x45c760 = 0;\n            }\n            else {\n                (*0x45c760)[0x3f] = 0;\n            }\n            iVar4 = (*pcVar2)(uVar3, 0, 0x45f1e0, 0xffffffff, *0x45c764, 0x3f, 0, unaff_EBP + -0x1c);\n            if ((iVar4 == 0) || (*(unaff_EBP + -0x1c) != 0)) {\n                **0x45c764 = 0;\n            }\n            else {\n                (*0x45c764)[0x3f] = 0;\n            }\n        }\n    }\n    else {\n        if (*0x45f238 != 0) {\n            iVar4 = fcn.00436820(arg_8h, *0x45f238);\n            if (iVar4 == 0) goto code_r0x00436165;\n            if (*0x45f238 != 0) {\n                fcn.0043360e(*0x45f238);\n            }\n        }\n        iVar4 = fcn.00431a40(arg_8h);\n        *0x45f238 = fcn.004335fc(iVar4 + 1);\n        if (*0x45f238 != 0) {\n            fcn.004366a0(*0x45f238, arg_8h);\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043617c();\n            fcn.0043a7c0(*0x45c760, arg_8h, 3);\n            (*0x45c760)[3] = 0;\n            pcVar5 = arg_8h + 3;\n            if (*pcVar5 == '-') {\n                *(unaff_EBP + -0x20) = 1;\n                pcVar5 = arg_8h + 4;\n            }\n            *0x45c6d0 = fcn.00431acb(pcVar5);\n            *0x45c6d0 = *0x45c6d0 * 0xe10;\n            for (; (cVar1 = *pcVar5,  cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':')))); pcVar5 = pcVar5 + 1) {\n            }\n            if (*pcVar5 == ':') {\n                pcVar5 = pcVar5 + 1;\n                iVar4 = fcn.00431acb(pcVar5);\n                *0x45c6d0 = *0x45c6d0 + iVar4 * 0x3c;\n                for (; ('/' < *pcVar5 && (*pcVar5 < ':')); pcVar5 = pcVar5 + 1) {\n                }\n                if (*pcVar5 == ':') {\n                    pcVar5 = pcVar5 + 1;\n                    iVar4 = fcn.00431acb(pcVar5);\n                    *0x45c6d0 = *0x45c6d0 + iVar4;\n                    for (; ('/' < *pcVar5 && (*pcVar5 < ':')); pcVar5 = pcVar5 + 1) {\n                    }\n                }\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                *0x45c6d0 = -*0x45c6d0;\n            }\n            *0x45c6d4 = *pcVar5;\n            if (*0x45c6d4 == 0) {\n                **0x45c764 = 0;\n            }\n            else {\n                fcn.0043a7c0(*0x45c764, pcVar5, 3);\n                (*0x45c764)[3] = 0;\n            }\n            goto code_r0x00436203;\n        }\n    }\ncode_r0x00436165:\n    fcn.00431fde(unaff_EBP + -0x10, 0xffffffff);\ncode_r0x00436203:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 1663
    },
    "00436209": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.00436209(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, \n            int32_t arg_20h, int32_t arg_24h, int32_t arg_28h)\n\n{\n    int32_t in_EAX;\n    int32_t iVar1;\n    int32_t in_ECX;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = arg_10h % 4;\n    if (arg_ch == 1) {\n        if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n            iVar4 = *(in_EAX * 4 + 0x45c77c);\n        }\n        else {\n            iVar4 = *(in_EAX * 4 + 0x45c7b0);\n        }\n        iVar5 = iVar4 + 1;\n        iVar3 = (arg_10h * 0x16d + -0x63db + (arg_10h + -1) / 4 + iVar5 + ((arg_10h + 299) / 400 - (arg_10h + -1) / 100)\n                ) % 7;\n        iVar1 = (arg_14h * 7 - iVar3) + arg_18h;\n        if (iVar3 <= arg_18h) {\n            iVar5 = iVar4 + -6;\n        }\n        iVar5 = iVar5 + iVar1;\n        if (arg_14h == 5) {\n            if (((iVar2 == 0) && (arg_10h % 100 != 0)) || ((arg_10h + 0x76c) % 400 == 0)) {\n                iVar1 = *(in_EAX * 4 + 0x45c780);\n            }\n            else {\n                iVar1 = *(in_EAX * 4 + 0x45c7b4);\n            }\n            if (iVar1 < iVar5) {\n                iVar5 = iVar5 + -7;\n            }\n        }\n    }\n    else {\n        if (((iVar2 == 0) && (iVar1 = arg_10h / 100,  arg_10h % 100 != 0)) ||\n           (iVar1 = (arg_10h + 0x76c) / 400,  (arg_10h + 0x76c) % 400 == 0)) {\n            iVar5 = *(in_EAX * 4 + 0x45c77c);\n        }\n        else {\n            iVar5 = *(in_EAX * 4 + 0x45c7b0);\n        }\n        iVar5 = iVar5 + arg_1ch;\n    }\n    iVar2 = (in_ECX * 0x3c + arg_20h) * 0x3c;\n    if (arg_8h == 1) {\n        *0x45c770 = (iVar2 + arg_24h) * 1000 + arg_28h;\n        *0x45c768 = arg_10h;\n        *0x45c76c = iVar5;\n    }\n    else {\n        *0x45c77c = (iVar2 + *0x45c6d8 + arg_24h) * 1000 + arg_28h;\n        if (*0x45c77c < 0) {\n            *0x45c77c = *0x45c77c + 86400000;\n            *0x45c778 = iVar5 + -1;\n        }\n        else {\n            iVar1 = 86400000;\n            *0x45c778 = iVar5;\n            if (86399999 < *0x45c77c) {\n                *0x45c77c = *0x45c77c + -86400000;\n                *0x45c778 = iVar5 + 1;\n            }\n        }\n        *0x45c774 = arg_10h;\n    }\n    return iVar1;\n}\n",
        "token_count": 955
    },
    "00436a18": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00436a18(int32_t param_1)\n\n{\n    int32_t *in_EAX;\n    int32_t unaff_EDI;\n    \n    if (((*(unaff_EDI + 0xc) & 0x40) == 0) || (*(unaff_EDI + 8) != 0)) {\n        do {\n            if (param_1 < 1) {\n                return;\n            }\n            param_1 = param_1 + -1;\n            fcn.004369c1();\n        } while (*in_EAX != -1);\n    }\n    else {\n        *in_EAX = *in_EAX + param_1;\n    }\n    return;\n}\n",
        "token_count": 151
    },
    "00436a4f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Type propagation algorithm not settling\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00436a4f(uint param_1, uint8_t *param_2, int32_t **param_3)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t **ppiVar3;\n    int32_t *piVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    int32_t *piVar8;\n    int32_t extraout_ECX;\n    int32_t iVar9;\n    uint8_t uVar10;\n    char *arg_ch;\n    bool bVar11;\n    int64_t iVar12;\n    int32_t *piStack600;\n    int32_t *piStack596;\n    int32_t iStack588;\n    int32_t iStack584;\n    uint uStack580;\n    int32_t iStack576;\n    int32_t iStack572;\n    int32_t *piStack568;\n    int32_t iStack564;\n    int32_t *piStack560;\n    int32_t iStack556;\n    uchar uStack552;\n    char cStack551;\n    int32_t iStack548;\n    int32_t iStack544;\n    int32_t *piStack540;\n    int32_t *piStack536;\n    uint32_t uStack532;\n    int32_t aiStack528 [127];\n    uint uStack17;\n    uint uStack8;\n    \n    uStack8 = *0x45c1a8;\n    iStack544 = 0;\n    iStack548 = 0;\n    piStack568 = NULL;\n    uVar10 = *param_2;\n    iVar7 = 0;\n    puVar2 = param_2;\n    ppiVar3 = param_3;\n    do {\n        if ((uVar10 == 0) || (param_2 = puVar2 + 1,  iStack548 < 0)) {\n            fcn.004316b0();\n            return;\n        }\n        if ((uVar10 < ' ') || ('x' < uVar10)) {\n            uVar5 = 0;\n        }\n        else {\n            uVar5 = *(uVar10 + 0x453098) & 0xf;\n        }\n        iStack584 = *(iVar7 + 0x4530b8 + uVar5 * 8) >> 4;\n        param_3 = ppiVar3;\n    // switch table (8 cases) at 0x437229\n        switch(iStack584) {\n        case 0:\ncode_r0x00436c6b:\n            iStack564 = 0;\n            if ((*(*0x45ca64 + 1 + uVar10 * 2) & 0x80) != 0) {\n                fcn.004369c1();\n                param_2 = puVar2 + 2;\n            }\n            fcn.004369c1();\n            break;\n        case 1:\n            piStack536 = 0xffffffff;\n            uStack580 = 0;\n            iStack572 = 0;\n            piStack560 = NULL;\n            iStack556 = 0;\n            uStack532 = 0;\n            iStack564 = 0;\n            break;\n        case 2:\n            if (uVar10 == 0x20) {\n                uStack532 = uStack532 | 2;\n            }\n            else if (uVar10 == 0x23) {\n                uStack532 = uStack532 | 0x80;\n            }\n            else if (uVar10 == 0x2b) {\n                uStack532 = uStack532 | 1;\n            }\n            else if (uVar10 == 0x2d) {\n                uStack532 = uStack532 | 4;\n            }\n            else if (uVar10 == 0x30) {\n                uStack532 = uStack532 | 8;\n            }\n            break;\n        case 3:\n            if (uVar10 == 0x2a) {\n                piStack560 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack560 < 0) {\n                    uStack532 = uStack532 | 4;\n                    piStack560 = -piStack560;\n                }\n            }\n            else {\n                piStack560 = uVar10 + -0x30 + piStack560 * 10;\n            }\n            break;\n        case 4:\n            piStack536 = NULL;\n            break;\n        case 5:\n            if (uVar10 == 0x2a) {\n                piStack536 = *ppiVar3;\n                param_3 = ppiVar3 + 1;\n                if (piStack536 < 0) {\n                    piStack536 = 0xffffffff;\n                }\n            }\n            else {\n                piStack536 = uVar10 + -0x30 + piStack536 * 10;\n            }\n            break;\n        case 6:\n            if (uVar10 == 0x49) {\n                uVar1 = *param_2;\n                if ((uVar1 == 0x36) && (puVar2[2] == 0x34)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 | 0x8000;\n                }\n                else if ((uVar1 == 0x33) && (puVar2[2] == 0x32)) {\n                    param_2 = puVar2 + 3;\n                    uStack532 = uStack532 & 0xffff7fff;\n                }\n                else if (((((uVar1 != 100) && (uVar1 != 0x69)) && (uVar1 != 0x6f)) &&\n                         ((uVar1 != 0x75 && (uVar1 != 0x78)))) && (uVar1 != 0x58)) {\n                    iStack584 = 0;\n                    goto code_r0x00436c6b;\n                }\n            }\n            else if (uVar10 == 0x68) {\n                uStack532 = uStack532 | 0x20;\n            }\n            else if (uVar10 == 0x6c) {\n                uStack532 = uStack532 | 0x10;\n            }\n            else if (uVar10 == 0x77) {\n                uStack532 = uStack532 | 0x800;\n            }\n            break;\n        case 7:\n            if (uVar10 < 'h') {\n                if (uVar10 < 'e') {\n                    if (uVar10 < 'Y') {\n                        if (uVar10 != 0x58) {\n                            if (uVar10 == 0x43) {\n                                if ((uStack532 & 0x830) == 0) {\n                                    uStack532 = uStack532 | 0x800;\n                                }\n                                goto code_r0x00436d74;\n                            }\n                            if ((uVar10 != 0x45) && (uVar10 != 0x47)) {\n                                if (uVar10 == 0x53) {\n                                    if ((uStack532 & 0x830) == 0) {\n                                        uStack532 = uStack532 | 0x800;\n                                    }\n                                    goto code_r0x00436cf7;\n                                }\n                                goto code_r0x004370ec;\n                            }\n                            uStack580 = 1;\n                            uVar10 = uVar10 + 0x20;\n                            goto code_r0x00436d48;\n                        }\ncode_r0x00436f92:\n                        iStack576 = 7;\ncode_r0x00436f95:\n                        iStack544 = 0x10;\n                        if ((uStack532 & 0x80) != 0) {\n                            cStack551 = iStack576 + 'Q';\n                            uStack552 = 0x30;\n                            iStack556 = 2;\n                        }\n                        goto code_r0x00436dc5;\n                    }\n                    if (uVar10 == 0x5a) {\n                        param_3 = ppiVar3 + 1;\n                        piVar8 = *ppiVar3;\n                        piVar6 = *0x45c7f0;\n                        piVar4 = *0x45c7f0;\n                        if ((piVar8 == NULL) || (piStack540 = piVar8[1],  piVar4 = *0x45c7f0,  piStack540 == NULL))\n                        goto code_r0x00436f06;\n                        iStack544 = *piVar8;\n                        if ((uStack532 & 0x800) == 0) {\n                            iStack564 = 0;\n                        }\n                        else {\n                            iStack544 = iStack544 / 2;\n                            iStack564 = 1;\n                        }\n                    }\n                    else if (uVar10 == 99) {\ncode_r0x00436d74:\n                        if ((uStack532 & 0x810) == 0) {\n                            aiStack528[0]._0_1_ = *ppiVar3;\n                            iStack544 = 1;\n                        }\n                        else {\n                            iStack544 = fcn.0043b25c(aiStack528, *ppiVar3);\n                            if (iStack544 < 0) {\n                                iStack572 = 1;\n                            }\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = aiStack528;\n                    }\n                    else if (uVar10 == 100) goto code_r0x00436dba;\n                }\n                else {\ncode_r0x00436d48:\n                    uStack532 = uStack532 | 0x40;\n                    piVar8 = aiStack528;\n                    piVar6 = aiStack528;\n                    if (piStack536 < 0) {\n                        piStack536 = 0x6;\n                    }\n                    else if (piStack536 == NULL) {\n                        if (uVar10 == 0x67) {\n                            piStack536 = 0x1;\n                        }\n                    }\n                    else {\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                        if ((0xa3 < piStack536) &&\n                           (piStack540 = aiStack528,  piStack568 = fcn.004335fc(piStack536 + 0x15d), \n                           piVar8 = piStack568,  piVar6 = piStack568,  piStack568 == NULL)) {\n                            piStack536 = 0xa3;\n                            piVar8 = aiStack528;\n                            piVar6 = piStack540;\n                        }\n                    }\n                    piStack540 = piVar6;\n                    piStack600 = *ppiVar3;\n                    param_3 = ppiVar3 + 2;\n                    piStack596 = ppiVar3[1];\n                    (**0x45ca80)(&piStack600, piVar8, uVar10, piStack536, uStack580);\n                    uVar5 = uStack532 & 0x80;\n                    if ((uVar5 != 0) && (piStack536 == NULL)) {\n                        (**0x45ca8c)(piVar8);\n                    }\n                    if ((uVar10 == 0x67) && (uVar5 == 0)) {\n                        (**0x45ca84)(piVar8);\n                    }\n                    piVar6 = piVar8;\n                    piVar4 = piStack540;\n                    if (*piVar8 == '-') {\n                        uStack532 = uStack532 | 0x100;\n                        piVar6 = piVar8 + 1;\n                        piVar4 = piVar8 + 1;\n                    }\ncode_r0x00436f06:\n                    piStack540 = piVar4;\n                    iStack544 = fcn.00431a40(piVar6);\n                }\ncode_r0x004370ec:\n                uVar5 = uStack532;\n                if (iStack572 == 0) {\n                    if ((uStack532 & 0x40) != 0) {\n                        if ((uStack532 & 0x100) == 0) {\n                            if ((uStack532 & 1) == 0) {\n                                if ((uStack532 & 2) == 0) goto code_r0x00437124;\n                                uStack552 = 0x20;\n                            }\n                            else {\n                                uStack552 = 0x2b;\n                            }\n                        }\n                        else {\n                            uStack552 = 0x2d;\n                        }\n                        iStack556 = 1;\n                    }\ncode_r0x00437124:\n                    arg_ch = piStack560 + (-iStack544 - iStack556);\n                    if ((uStack532 & 0xc) == 0) {\n                        fcn.004369f4(0x20, arg_ch, param_1);\n                    }\n                    fcn.00436a18(iStack556);\n                    if (((uVar5 & 8) != 0) && ((uVar5 & 4) == 0)) {\n                        fcn.004369f4(0x30, arg_ch, param_1);\n                    }\n                    if ((iStack564 == 0) || (iStack544 < 1)) {\n                        fcn.00436a18(iStack544);\n                    }\n                    else {\n                        iStack588 = iStack544;\n                        piVar8 = piStack540;\n                        do {\n                            iStack588 = iStack588 + -1;\n                            iVar7 = fcn.0043b25c(&uStack17 + 1, *piVar8);\n                            piVar8 = piVar8 + 2;\n                            if (iVar7 < 1) break;\n                            fcn.00436a18(iVar7);\n                        } while (iStack588 != 0);\n                    }\n                    if ((uStack532 & 4) != 0) {\n                        fcn.004369f4(0x20, arg_ch, param_1);\n                    }\n                }\n            }\n            else {\n                if (uVar10 == 0x69) {\ncode_r0x00436dba:\n                    uStack532 = uStack532 | 0x40;\ncode_r0x00436dbe:\n                    iStack544 = 10;\ncode_r0x00436dc5:\n                    if ((uStack532 & 0x8000) == 0) {\n                        param_3 = ppiVar3 + 1;\n                        if ((uStack532 & 0x20) == 0) {\n                            piVar8 = *ppiVar3;\n                            if ((uStack532 & 0x40) == 0) {\n                                piVar6 = NULL;\n                                goto code_r0x00437036;\n                            }\n                        }\n                        else if ((uStack532 & 0x40) == 0) {\n                            piVar8 = *ppiVar3;\n                        }\n                        else {\n                            piVar8 = *ppiVar3;\n                        }\n                        piVar6 = piVar8 >> 0x1f;\n                    }\n                    else {\n                        piVar8 = *ppiVar3;\n                        piVar6 = ppiVar3[1];\n                        param_3 = ppiVar3 + 2;\n                    }\ncode_r0x00437036:\n                    if ((((uStack532 & 0x40) != 0) && (piVar6 < 1)) && (piVar6 < 0)) {\n                        bVar11 = piVar8 != NULL;\n                        piVar8 = -piVar8;\n                        piVar6 = -(piVar6 + bVar11);\n                        uStack532 = uStack532 | 0x100;\n                    }\n                    if ((uStack532 & 0x8000) == 0) {\n                        piVar6 = NULL;\n                    }\n                    iVar12 = CONCAT44(piVar6, piVar8);\n                    if (piStack536 < 0) {\n                        piStack536 = 0x1;\n                    }\n                    else {\n                        uStack532 = uStack532 & 0xfffffff7;\n                        if (0x200 < piStack536) {\n                            piStack536 = 0x200;\n                        }\n                    }\n                    if ((piVar8 | piVar6) == 0) {\n                        iStack556 = 0;\n                    }\n                    piVar8 = &uStack17;\n                    while( true ) {\n                        iVar7 = iVar12;\n                        piVar6 = piStack536 + -1;\n                        if ((piStack536 < 1) && (iVar12 == 0)) break;\n                        piStack536 = piVar6;\n                        iVar12 = fcn.00439c00();\n                        iVar9 = extraout_ECX + 0x30;\n                        if (0x39 < iVar9) {\n                            iVar9 = iVar9 + iStack576;\n                        }\n                        *piVar8 = iVar9;\n                        piVar8 = piVar8 + -1;\n                        iStack588 = iVar7;\n                    }\n                    iStack544 = &uStack17 + -piVar8;\n                    piStack540 = piVar8 + 1;\n                    piStack536 = piVar6;\n                    if (((uStack532 & 0x200) != 0) && ((*piStack540 != '0' || (iStack544 == 0)))) {\n                        *piVar8 = '0';\n                        iStack544 = &uStack17 + -piVar8 + 1;\n                        piStack540 = piVar8;\n                    }\n                    goto code_r0x004370ec;\n                }\n                if (uVar10 != 0x6e) {\n                    if (uVar10 == 0x6f) {\n                        iStack544 = 8;\n                        if ((uStack532 & 0x80) != 0) {\n                            uStack532 = uStack532 | 0x200;\n                        }\n                        goto code_r0x00436dc5;\n                    }\n                    if (uVar10 == 0x70) {\n                        piStack536 = 0x8;\n                        goto code_r0x00436f92;\n                    }\n                    if (uVar10 == 0x73) {\ncode_r0x00436cf7:\n                        piVar8 = piStack536;\n                        if (piStack536 == 0xffffffff) {\n                            piVar8 = 0x7fffffff;\n                        }\n                        param_3 = ppiVar3 + 1;\n                        piStack540 = *ppiVar3;\n                        if ((uStack532 & 0x810) == 0) {\n                            piVar6 = piStack540;\n                            if (piStack540 == NULL) {\n                                piVar6 = *0x45c7f0;\n                                piStack540 = *0x45c7f0;\n                            }\n                            for (; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != '\\0')); piVar6 = piVar6 + 1) {\n                            }\n                            iStack544 = piVar6 - piStack540;\n                        }\n                        else {\n                            if (piStack540 == NULL) {\n                                piStack540 = *0x45c7f4;\n                            }\n                            iStack564 = 1;\n                            for (piVar6 = piStack540; (piVar8 != NULL && (piVar8 = piVar8 + -1,  *piVar6 != 0));\n                                piVar6 = piVar6 + 2) {\n                            }\n                            iStack544 = piVar6 - piStack540 >> 1;\n                        }\n                        goto code_r0x004370ec;\n                    }\n                    if (uVar10 != 0x75) {\n                        if (uVar10 != 0x78) goto code_r0x004370ec;\n                        iStack576 = 0x27;\n                        goto code_r0x00436f95;\n                    }\n                    goto code_r0x00436dbe;\n                }\n                param_3 = ppiVar3 + 1;\n                if ((uStack532 & 0x20) == 0) {\n                    **ppiVar3 = iStack548;\n                }\n                else {\n                    **ppiVar3 = iStack548;\n                }\n                iStack572 = 1;\n            }\n            if (piStack568 != NULL) {\n                fcn.0043360e(piStack568);\n                piStack568 = NULL;\n            }\n        }\n        uVar10 = *param_2;\n        iVar7 = iStack584;\n        puVar2 = param_2;\n        ppiVar3 = param_3;\n    } while( true );\n}\n",
        "token_count": 4466
    },
    "00437249": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00437249(uint32_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t in_FS_OFFSET;\n    uint lpBuffer;\n    int16_t *var_1ch;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t *var_4h;\n    \n    puVar4 = arg_8h;\n    pcVar3 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    puVar8 = arg_8h[2];\n    if ((puVar8 & 3) != 0) {\n        return 0;\n    }\n    var_4h = *(*(in_FS_OFFSET + 0x18) + 8);\n    if ((var_4h <= puVar8) && (puVar8 < *(*(in_FS_OFFSET + 0x18) + 4))) {\n        return 0;\n    }\n    puVar1 = arg_8h + 3;\n    if (*puVar1 == 0xffffffff) {\n        return 1;\n    }\n    uVar10 = 0;\n    arg_8h = NULL;\n    puVar5 = puVar8;\n    do {\n        if ((*puVar5 != 0xffffffff) && (uVar10 <= *puVar5)) {\n            return 0;\n        }\n        if (puVar5[1] != 0) {\n            arg_8h = arg_8h + 1;\n        }\n        uVar10 = uVar10 + 1;\n        puVar5 = puVar5 + 3;\n    } while (uVar10 <= *puVar1);\n    if ((arg_8h != NULL) && ((puVar1 = puVar4[-2],  puVar1 < var_4h || (puVar4 <= puVar1)))) {\n        return 0;\n    }\n    uVar10 = puVar8 & 0xfffff000;\n    iVar12 = 0;\n    if (0 < *0x45f240) {\n        do {\n            if (*(iVar12 * 4 + 0x45f248) == uVar10) {\n                if (iVar12 < 1) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x45f288, 1);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                if (*(iVar12 * 4 + 0x45f248) == uVar10) goto code_r0x00437444;\n                iVar12 = *0x45f240 + -1;\n                if (iVar12 < 0) goto code_r0x00437432;\n                goto code_r0x00437422;\n            }\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < *0x45f240);\n    }\n    iVar12 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar8, &lpBuffer, 0x1c);\n    if (iVar12 == 0) {\n        return 0xffffffff;\n    }\n    if (var_8h != 0x1000000) {\n        return 0xffffffff;\n    }\n    if ((var_ch & 0xcc) != 0) {\n        if (((*var_1ch != 0x5a4d) || (piVar6 = *(var_1ch + 0x1e) + var_1ch,  *piVar6 != 0x4550)) ||\n           (*(piVar6 + 6) != 0x10b)) {\n            return 0xffffffff;\n        }\n        uVar9 = *(piVar6 + 5);\n        if (*(piVar6 + 6) == 0) {\n            return 0xffffffff;\n        }\n        uVar2 = *(piVar6 + uVar9 + 0x24);\n        if (((uVar2 <= puVar8 - var_1ch) && (puVar8 - var_1ch < *(piVar6 + uVar9 + 0x20) + uVar2)) &&\n           ((*(piVar6 + uVar9 + 0x3f) & 0x80) != 0)) {\n            return 0;\n        }\n    }\n    iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x45f288, 1);\n    iVar12 = *0x45f240;\n    if (iVar7 != 0) {\n        return 1;\n    }\n    iVar7 = *0x45f240;\n    if (0 < *0x45f240) {\n        puVar8 = *0x45f240 * 4 + 0x45f244;\n        do {\n            if (*puVar8 == uVar10) break;\n            iVar7 = iVar7 + -1;\n            puVar8 = puVar8 + -1;\n        } while (0 < iVar7);\n    }\n    if (iVar7 == 0) {\n        iVar7 = 0xf;\n        if (*0x45f240 < 0x10) {\n            iVar7 = *0x45f240;\n        }\n        iVar11 = 0;\n        if (-1 < iVar7) {\n            do {\n                puVar8 = iVar11 * 4 + 0x45f248;\n                uVar9 = *puVar8;\n                iVar11 = iVar11 + 1;\n                *puVar8 = uVar10;\n                uVar10 = uVar9;\n            } while (iVar11 <= iVar7);\n        }\n        if (iVar12 < 0x10) {\n            *0x45f240 = iVar12 + 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x45f288, 0);\n    return 1;\n    while (iVar12 = iVar12 + -1,  -1 < iVar12) {\ncode_r0x00437422:\n        if (*(iVar12 * 4 + 0x45f248) == uVar10) break;\n    }\n    if (iVar12 < 0) {\ncode_r0x00437432:\n        if (*0x45f240 < 0x10) {\n            *0x45f240 = *0x45f240 + 1;\n        }\n        iVar12 = *0x45f240 + -1;\n    }\n    else if (iVar12 == 0) goto code_r0x0043745c;\ncode_r0x00437444:\n    iVar7 = 0;\n    if (-1 < iVar12) {\n        do {\n            puVar8 = iVar7 * 4 + 0x45f248;\n            uVar9 = *puVar8;\n            iVar7 = iVar7 + 1;\n            *puVar8 = uVar10;\n            uVar10 = uVar9;\n        } while (iVar7 <= iVar12);\n    }\ncode_r0x0043745c:\n    (*pcVar3)(0x45f288, 0);\n    return 1;\n}\n",
        "token_count": 1634
    },
    "004375f6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.004375f6(void)\n\n{\n    if ((*0x45f0f0 == 2) && (4 < *0x45f0fc)) {\n        return 1;\n    }\n    return 3;\n}\n",
        "token_count": 52
    },
    "00437610": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.00437610(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x46075c = (*_sym.imp.KERNEL32.dll_HeapCreate)(param_1 == 0, 0x1000, 0);\n    if (*0x46075c == 0) {\n        return 0;\n    }\n    *0x460760 = fcn.004375f6();\n    if ((*0x460760 == 3) && (iVar1 = fcn.00437661(0x3f8),  iVar1 == 0)) {\n        (*_sym.imp.KERNEL32.dll_HeapDestroy)(*0x46075c);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 164
    },
    "004376d4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004376d4(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    uint32_t uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint32_t *puVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar6 = arg_8h[4];\n    puVar13 = arg_ch + -4;\n    uVar15 = arg_ch - arg_8h[3] >> 0xf;\n    piVar4 = uVar15 * 0x204 + 0x144 + uVar6;\n    var_4h = *puVar13 - 1;\n    if ((var_4h & 1) == 0) {\n        puVar11 = var_4h + puVar13;\n        uVar14 = *puVar11;\n        uVar7 = *(arg_ch + -8);\n        if ((uVar14 & 1) == 0) {\n            uVar10 = (uVar14 >> 4) - 1;\n            if (0x3f < uVar10) {\n                uVar10 = 0x3f;\n            }\n            if (puVar11[1] == puVar11[2]) {\n                if (uVar10 < 0x20) {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 & 0x1f));\n                    puVar12 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        *arg_8h = *arg_8h & uVar10;\n                    }\n                }\n                else {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 - 0x20 & 0x1f));\n                    puVar12 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar10;\n                    }\n                }\n            }\n            var_4h = var_4h + uVar14;\n            *(puVar11[2] + 4) = puVar11[1];\n            *(puVar11[1] + 8) = puVar11[2];\n        }\n        puVar11 = (var_4h >> 4) + -1;\n        if (0x3f < puVar11) {\n            puVar11 = 0x3f;\n        }\n        puVar12 = arg_8h;\n        if ((uVar7 & 1) == 0) {\n            puVar13 = puVar13 - uVar7;\n            puVar12 = (uVar7 >> 4) + -1;\n            if (0x3f < puVar12) {\n                puVar12 = 0x3f;\n            }\n            var_4h = var_4h + uVar7;\n            puVar11 = (var_4h >> 4) + -1;\n            if (0x3f < puVar11) {\n                puVar11 = 0x3f;\n            }\n            if (puVar12 != puVar11) {\n                if (puVar13[1] == puVar13[2]) {\n                    if (puVar12 < 0x20) {\n                        uVar14 = ~(0x80000000U >> (puVar12 & 0x1f));\n                        puVar3 = uVar6 + 0x44 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            *arg_8h = *arg_8h & uVar14;\n                        }\n                    }\n                    else {\n                        uVar14 = ~(0x80000000U >> (puVar12 - 0x20 & 0x1f));\n                        puVar3 = uVar6 + 0xc4 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            arg_8h[1] = arg_8h[1] & uVar14;\n                        }\n                    }\n                }\n                *(puVar13[2] + 4) = puVar13[1];\n                *(puVar13[1] + 8) = puVar13[2];\n            }\n        }\n        if (((uVar7 & 1) != 0) || (puVar12 != puVar11)) {\n            piVar1 = piVar4 + puVar11 * 2;\n            uVar14 = piVar1[1];\n            puVar13[2] = piVar1;\n            puVar13[1] = uVar14;\n            piVar1[1] = puVar13;\n            *(puVar13[1] + 8) = puVar13;\n            if (puVar13[1] == puVar13[2]) {\n                cVar5 = *(puVar11 + uVar6 + 4);\n                *(puVar11 + uVar6 + 4) = cVar5 + '\\x01';\n                uVar9 = puVar11;\n                if (puVar11 < 0x20) {\n                    if (cVar5 == '\\0') {\n                        *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                else {\n                    if (cVar5 == '\\0') {\n                        arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n            }\n        }\n        *puVar13 = var_4h;\n        *((var_4h - 4) + puVar13) = var_4h;\n        *piVar4 = *piVar4 + -1;\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n        if (*piVar4 == 0) {\n            if (*0x460740 != NULL) {\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x460758 * 0x8000 + (*0x460740)[3], 0x8000, 0x4000);\n                (*0x460740)[2] = (*0x460740)[2] | 0x80000000U >> (*0x460758 & 0x1f);\n                *((*0x460740)[4] + 0xc4 + *0x460758 * 4) = 0;\n                *((*0x460740)[4] + 0x43) = *((*0x460740)[4] + 0x43) + -1;\n                if (*((*0x460740)[4] + 0x43) == '\\0') {\n                    (*0x460740)[1] = (*0x460740)[1] & 0xfffffffe;\n                }\n                if ((*0x460740)[2] == 0xffffffff) {\n                    (*pcVar8)((*0x460740)[3], 0, 0x8000);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x46075c, 0, (*0x460740)[4]);\n                    fcn.00433010(*0x460740, *0x460740 + 5, (*0x460744 * 0x14 - *0x460740) + -0x14 + *0x460748);\n                    *0x460744 = *0x460744 + -1;\n                    if (*0x460740 < arg_8h) {\n                        arg_8h = arg_8h + -5;\n                    }\n                    *0x460750 = *0x460748;\n                }\n            }\n            *0x460740 = arg_8h;\n            *0x460758 = uVar15;\n        }\n    }\n    return;\n}\n",
        "token_count": 2131
    },
    "00437e88": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00437e88(uint32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    char cVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uint32_t *puVar14;\n    uint32_t *puVar15;\n    uint32_t uVar16;\n    int32_t iVar17;\n    bool bVar18;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar8 = arg_8h + 0x17U & 0xfffffff0;\n    iVar9 = (arg_8h + 0x17U >> 4) + -1;\n    puVar10 = *0x460748 + *0x460744 * 5;\n    uVar7 = iVar9;\n    if (iVar9 < 0x20) {\n        uVar16 = 0xffffffff >> (uVar7 & 0x1f);\n        var_8h = 0xffffffff;\n    }\n    else {\n        uVar16 = 0;\n        var_8h = 0xffffffff >> (uVar7 - 0x20 & 0x1f);\n    }\n    bVar18 = *0x460750 < puVar10;\n    arg_8h = *0x460750;\n    while ((bVar18 && ((arg_8h[1] & var_8h | *arg_8h & uVar16) == 0))) {\n        arg_8h = arg_8h + 5;\n        bVar18 = arg_8h < puVar10;\n    }\n    puVar14 = *0x460748;\n    if (arg_8h == puVar10) {\n        for (; (puVar14 < *0x460750 && ((puVar14[1] & var_8h | *puVar14 & uVar16) == 0)); puVar14 = puVar14 + 5) {\n        }\n        arg_8h = puVar14;\n        if (puVar14 == *0x460750) {\n            for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {\n            }\n            puVar15 = *0x460748;\n            arg_8h = puVar14;\n            if (puVar14 == puVar10) {\n                for (; (puVar15 < *0x460750 && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {\n                }\n                arg_8h = puVar15;\n                if ((puVar15 == *0x460750) && (arg_8h = fcn.004379ec(),  arg_8h == NULL)) {\n                    return NULL;\n                }\n            }\n            uVar6 = fcn.00437aa3(arg_8h);\n            *arg_8h[4] = uVar6;\n            if (*arg_8h[4] == -1) {\n                return NULL;\n            }\n        }\n    }\n    piVar5 = arg_8h[4];\n    var_4h = *piVar5;\n    if ((var_4h == -1) || ((piVar5[var_4h + 0x31] & var_8h | piVar5[var_4h + 0x11] & uVar16) == 0)) {\n        var_4h = 0;\n        puVar10 = piVar5 + 0x11;\n        uVar12 = piVar5[0x31] & var_8h | *puVar10 & uVar16;\n        while (uVar12 == 0) {\n            puVar14 = puVar10 + 0x21;\n            var_4h = var_4h + 1;\n            puVar10 = puVar10 + 1;\n            uVar12 = *puVar14 & var_8h | *puVar10 & uVar16;\n        }\n    }\n    piVar3 = piVar5 + var_4h * 0x81 + 0x51;\n    iVar9 = 0;\n    uVar16 = piVar5[var_4h + 0x11] & uVar16;\n    if (uVar16 == 0) {\n        uVar16 = piVar5[var_4h + 0x31] & var_8h;\n        iVar9 = 0x20;\n    }\n    for (; -1 < uVar16; uVar16 = uVar16 << 1) {\n        iVar9 = iVar9 + 1;\n    }\n    piVar13 = piVar3[iVar9 * 2 + 1];\n    iVar11 = *piVar13 - uVar8;\n    iVar17 = (iVar11 >> 4) + -1;\n    if (0x3f < iVar17) {\n        iVar17 = 0x3f;\n    }\n    *0x460750 = arg_8h;\n    if (iVar17 != iVar9) {\n        if (piVar13[1] == piVar13[2]) {\n            if (iVar9 < 0x20) {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 & 0x1f));\n                piVar5[var_4h + 0x11] = uVar16 & piVar5[var_4h + 0x11];\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    *arg_8h = *arg_8h & uVar16;\n                }\n            }\n            else {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 - 0x20 & 0x1f));\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] & uVar16;\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar16;\n                }\n            }\n        }\n        *(piVar13[2] + 4) = piVar13[1];\n        *(piVar13[1] + 8) = piVar13[2];\n        if (iVar11 == 0) goto code_r0x00438141;\n        piVar1 = piVar3 + iVar17 * 2;\n        iVar9 = piVar1[1];\n        piVar13[2] = piVar1;\n        piVar13[1] = iVar9;\n        piVar1[1] = piVar13;\n        *(piVar13[1] + 8) = piVar13;\n        if (piVar13[1] == piVar13[2]) {\n            cVar4 = *(iVar17 + 4 + piVar5);\n            *(iVar17 + 4 + piVar5) = cVar4 + '\\x01';\n            uVar7 = iVar17;\n            if (iVar17 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar7 & 0x1f);\n                }\n                piVar5[var_4h + 0x11] = piVar5[var_4h + 0x11] | 0x80000000U >> (uVar7 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n                }\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n            }\n        }\n    }\n    if (iVar11 != 0) {\n        *piVar13 = iVar11;\n        *(iVar11 + -4 + piVar13) = iVar11;\n    }\ncode_r0x00438141:\n    piVar13 = piVar13 + iVar11;\n    *piVar13 = uVar8 + 1;\n    *(piVar13 + (uVar8 - 4)) = uVar8 + 1;\n    iVar9 = *piVar3;\n    *piVar3 = iVar9 + 1;\n    if (((iVar9 == 0) && (arg_8h == *0x460740)) && (var_4h == *0x460758)) {\n        *0x460740 = NULL;\n    }\n    *piVar5 = var_4h;\n    return piVar13 + 1;\n}\n",
        "token_count": 2081
    },
    "0043819f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043819f(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uStack296;\n    uchar *puStack292;\n    uint uStack288;\n    uchar auStack272 [260];\n    uchar uStack12;\n    uint uStack8;\n    \n    uStack8 = *0x45c1a8;\n    uVar1 = 0;\n    do {\n        if (param_1 == *(uVar1 * 8 + 0x45c920)) break;\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 0x13);\n    if (param_1 == *(uVar1 * 8 + 0x45c920)) {\n        if ((*0x45f0e8 == 1) || ((*0x45f0e8 == 0 && (*0x45c284 == 1)))) {\n            uStack288 = 0;\n            puStack292 = &stack0x00000004;\n            uStack296 = *(uVar1 * 8 + 0x45c924);\n            uStack296 = fcn.00431a40();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (param_1 != 0xfc) {\n            uStack288 = 0x104;\n            puStack292 = &stack0xfffffef0;\n            uStack296 = 0;\n            uStack12 = 0;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.004366a0();\n            }\n            iVar2 = fcn.00431a40();\n            if (0x3c < iVar2 + 1U) {\n                fcn.00431a40();\n                fcn.0043a7c0();\n            }\n            fcn.00431a40();\n            fcn.00431a40();\n            fcn.004316c0();\n            fcn.004366a0();\n            fcn.004366b0();\n            fcn.004366b0();\n            fcn.004366b0();\n            fcn.0043a6c0(&stack0xfffffed8, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n        }\n    }\n    uStack288 = 0x43830b;\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 550
    },
    "0043834f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043834f(int32_t arg_8h, uint ExceptionInfo)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint var_4h;\n    \n    iVar4 = fcn.004350c1();\n    piVar1 = *(iVar4 + 0x54);\n    piVar7 = piVar1;\n    do {\n        if (*piVar7 == arg_8h) break;\n        piVar7 = piVar7 + 3;\n    } while (piVar7 < piVar1 + *0x45ca3c * 3);\n    if ((piVar1 + *0x45ca3c * 3 <= piVar7) || (*piVar7 != arg_8h)) {\n        piVar7 = NULL;\n    }\n    if ((piVar7 == NULL) || (pcVar2 = piVar7[2],  pcVar2 == NULL)) {\n        uVar5 = (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(ExceptionInfo);\n    }\n    else if (pcVar2 == 0x5) {\n        piVar7[2] = 0;\n        uVar5 = 1;\n    }\n    else {\n        if (pcVar2 != 0x1) {\n            uVar5 = *(iVar4 + 0x58);\n            *(iVar4 + 0x58) = ExceptionInfo;\n            if (piVar7[1] == 8) {\n                if (*0x45ca30 < *0x45ca34 + *0x45ca30) {\n                    iVar6 = *0x45ca30 * 0xc;\n                    iVar8 = *0x45ca30;\n                    do {\n                        *(iVar6 + 8 + *(iVar4 + 0x54)) = 0;\n                        iVar8 = iVar8 + 1;\n                        iVar6 = iVar6 + 0xc;\n                    } while (iVar8 < *0x45ca34 + *0x45ca30);\n                }\n                iVar8 = *piVar7;\n                uVar3 = *(iVar4 + 0x5c);\n                if (iVar8 == -0x3fffff72) {\n                    *(iVar4 + 0x5c) = 0x83;\n                }\n                else if (iVar8 == -0x3fffff70) {\n                    *(iVar4 + 0x5c) = 0x81;\n                }\n                else if (iVar8 == -0x3fffff6f) {\n                    *(iVar4 + 0x5c) = 0x84;\n                }\n                else if (iVar8 == -0x3fffff6d) {\n                    *(iVar4 + 0x5c) = 0x85;\n                }\n                else if (iVar8 == -0x3fffff73) {\n                    *(iVar4 + 0x5c) = 0x82;\n                }\n                else if (iVar8 == -0x3fffff71) {\n                    *(iVar4 + 0x5c) = 0x86;\n                }\n                else if (iVar8 == -0x3fffff6e) {\n                    *(iVar4 + 0x5c) = 0x8a;\n                }\n                (*pcVar2)(8, *(iVar4 + 0x5c));\n                *(iVar4 + 0x5c) = uVar3;\n            }\n            else {\n                piVar7[2] = 0;\n                (*pcVar2)(piVar7[1]);\n            }\n            *(iVar4 + 0x58) = uVar5;\n        }\n        uVar5 = 0xffffffff;\n    }\n    return uVar5;\n}\n",
        "token_count": 854
    },
    "004385d7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004385d7(uint8_t **arg_8h, int32_t *arg_ch)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint8_t *in_EAX;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t *in_ECX;\n    uint32_t uVar6;\n    int32_t *unaff_ESI;\n    uint var_4h;\n    \n    bVar1 = false;\n    *unaff_ESI = 0;\n    *arg_ch = 1;\n    if (arg_8h != NULL) {\n        *arg_8h = in_ECX;\n        arg_8h = arg_8h + 1;\n    }\n    do {\n        if (*in_EAX == 0x22) {\n            bVar1 = !bVar1;\n            puVar3 = in_EAX + 1;\n            uVar5 = 0x22;\n        }\n        else {\n            *unaff_ESI = *unaff_ESI + 1;\n            if (in_ECX != NULL) {\n                *in_ECX = *in_EAX;\n                in_ECX = in_ECX + 1;\n            }\n            uVar5 = *in_EAX;\n            puVar3 = in_EAX + 1;\n            if ((*(uVar5 + 0x460781) & 4) != 0) {\n                *unaff_ESI = *unaff_ESI + 1;\n                if (in_ECX != NULL) {\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                puVar3 = in_EAX + 2;\n            }\n            if (uVar5 == 0) {\n                puVar3 = puVar3 + -1;\n                goto code_r0x00438650;\n            }\n        }\n        in_EAX = puVar3;\n    } while ((bVar1) || ((uVar5 != 0x20 && (uVar5 != 9))));\n    if (in_ECX != NULL) {\n        in_ECX[-1] = 0;\n    }\ncode_r0x00438650:\n    bVar1 = false;\n    while (*puVar3 != 0) {\n        for (; (*puVar3 == 0x20 || (*puVar3 == 9)); puVar3 = puVar3 + 1) {\n        }\n        if (*puVar3 == 0) break;\n        if (arg_8h != NULL) {\n            *arg_8h = in_ECX;\n            arg_8h = arg_8h + 1;\n        }\n        *arg_ch = *arg_ch + 1;\n        while( true ) {\n            bVar2 = true;\n            uVar6 = 0;\n            for (; *puVar3 == 0x5c; puVar3 = puVar3 + 1) {\n                uVar6 = uVar6 + 1;\n            }\n            if (*puVar3 == 0x22) {\n                puVar4 = puVar3;\n                if ((uVar6 & 1) == 0) {\n                    if ((!bVar1) || (puVar4 = puVar3 + 1,  *puVar4 != 0x22)) {\n                        bVar2 = false;\n                        puVar4 = puVar3;\n                    }\n                    bVar1 = !bVar1;\n                }\n                uVar6 = uVar6 >> 1;\n                puVar3 = puVar4;\n            }\n            for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                if (in_ECX != NULL) {\n                    *in_ECX = 0x5c;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            uVar5 = *puVar3;\n            if ((uVar5 == 0) || ((!bVar1 && ((uVar5 == 0x20 || (uVar5 == 9)))))) break;\n            if (bVar2) {\n                if (in_ECX == NULL) {\n                    if ((*(uVar5 + 0x460781) & 4) != 0) {\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                }\n                else {\n                    if ((*(uVar5 + 0x460781) & 4) != 0) {\n                        *in_ECX = uVar5;\n                        in_ECX = in_ECX + 1;\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            puVar3 = puVar3 + 1;\n        }\n        if (in_ECX != NULL) {\n            *in_ECX = 0;\n            in_ECX = in_ECX + 1;\n        }\n        *unaff_ESI = *unaff_ESI + 1;\n    }\n    if (arg_8h != NULL) {\n        *arg_8h = NULL;\n    }\n    *arg_ch = *arg_ch + 1;\n    return;\n}\n",
        "token_count": 1209
    },
    "00438907": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00438907(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t *piVar9;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.004335fc(0x480);\n    if (puVar3 == NULL) {\n        uVar4 = 0xffffffff;\n    }\n    else {\n        *0x460630 = 0x20;\n        *0x460640 = puVar3;\n        for (; puVar3 < *0x460640 + 0x120; puVar3 = puVar3 + 9) {\n            *puVar3 = 0xffffffff;\n            puVar3[2] = 0;\n            *(puVar3 + 1) = 0;\n            *(puVar3 + 5) = 10;\n        }\n        (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n        if ((iStack22 != 0) && (piStack20 != NULL)) {\n            iVar8 = *piStack20;\n            piStack20 = piStack20 + 1;\n            piVar9 = iVar8 + piStack20;\n            if (0x7ff < iVar8) {\n                iVar8 = 0x800;\n            }\n            iVar6 = iVar8;\n            if (*0x460630 < iVar8) {\n                puVar3 = 0x460644;\n                do {\n                    puVar5 = fcn.004335fc(0x480);\n                    iVar6 = *0x460630;\n                    if (puVar5 == NULL) break;\n                    *0x460630 = *0x460630 + 0x20;\n                    *puVar3 = puVar5;\n                    puVar2 = puVar5;\n                    for (; puVar5 < puVar2 + 0x120; puVar5 = puVar5 + 9) {\n                        *puVar5 = 0xffffffff;\n                        puVar5[2] = 0;\n                        *(puVar5 + 1) = 0;\n                        *(puVar5 + 5) = 10;\n                        puVar2 = *puVar3;\n                    }\n                    puVar3 = puVar3 + 1;\n                    iVar6 = iVar8;\n                } while (*0x460630 < iVar8);\n            }\n            uVar7 = 0;\n            if (0 < iVar6) {\n                do {\n                    if (((*piVar9 != -1) && ((*piStack20 & 1) != 0)) &&\n                       (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar9),  iVar8 != 0)))\n                       ) {\n                        piVar1 = *((uVar7 >> 5) * 4 + 0x460640) + (uVar7 & 0x1f) * 0x24;\n                        *piVar1 = *piVar9;\n                        *(piVar1 + 1) = *piStack20;\n                        iVar8 = fcn.0043b293(piVar1 + 3, 4000);\n                        if (iVar8 == 0) {\n                            return 0xffffffff;\n                        }\n                        piVar1[2] = piVar1[2] + 1;\n                    }\n                    piVar9 = piVar9 + 1;\n                    uVar7 = uVar7 + 1;\n                    piStack20 = piStack20 + 1;\n                } while (uVar7 < iVar6);\n            }\n        }\n        iVar8 = 0;\n        do {\n            piVar9 = *0x460640 + iVar8 * 9;\n            if (*piVar9 == -1) {\n                *(piVar9 + 1) = 0x81;\n                if (iVar8 == 0) {\n                    iVar6 = -10;\n                }\n                else {\n                    iVar6 = -0xb - (iVar8 != 1);\n                }\n                iVar6 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(iVar6);\n                if ((iVar6 == -1) || (uVar7 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6),  uVar7 == 0)) {\n                    *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                }\n                else {\n                    *piVar9 = iVar6;\n                    if ((uVar7 & 0xff) == 2) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 0x40;\n                    }\n                    else if ((uVar7 & 0xff) == 3) {\n                        *(piVar9 + 1) = *(piVar9 + 1) | 8;\n                    }\n                    iVar6 = fcn.0043b293(piVar9 + 3, 4000);\n                    if (iVar6 == 0) {\n                        return 0xffffffff;\n                    }\n                    piVar9[2] = piVar9[2] + 1;\n                }\n            }\n            else {\n                *(piVar9 + 1) = *(piVar9 + 1) | 0x80;\n            }\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 3);\n        (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x460630);\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 1248
    },
    "00438ba3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl fcn.00438ba3(uint arg_8h_2, uint arg_ch_2, uint arg_8h, uint arg_ch)\n\n{\n    int32_t *piVar1;\n    uint32_t *puVar2;\n    uint8_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uchar uVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    uint uVar9;\n    uint uVar10;\n    uint32_t uVar11;\n    uint8_t uVar12;\n    uint8_t uVar13;\n    uint32_t uVar14;\n    uint *puVar15;\n    int32_t unaff_EBP;\n    uint8_t *puVar16;\n    uint8_t *puVar17;\n    char *pcVar18;\n    char *pcVar19;\n    uint *puVar20;\n    uint8_t *puVar21;\n    ulong uVar22;\n    uint var_4h;\n    uint var_1e8h;\n    uint var_1dch;\n    uint var_1d8h;\n    uint var_1d4h;\n    uint var_1d0h;\n    uint var_1cch;\n    uint var_1c8h;\n    uint var_1c4h;\n    uint var_1c0h;\n    uint var_1bch;\n    uint var_1b8h;\n    uint var_1b4h;\n    uint var_1b0h;\n    uint var_1ach;\n    uint var_1a8h;\n    uint var_1a0h;\n    uint var_19ch;\n    uint var_194h;\n    uint var_18ch;\n    uint var_184h;\n    uint var_17dh;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x1cc;\n    var_4h_2 = 0x453520;\n    fcn.00434920();\n    *(unaff_EBP + -0x1c) = *0x45c1a8;\n    *(unaff_EBP + -0x1bc) = 0;\n    *(unaff_EBP + -0x1d8) = 0;\n    *(unaff_EBP + -0x1b0) = 0;\n    *(unaff_EBP + -0x194) = 0;\n    *(unaff_EBP + -0x195) = 0;\n    *(unaff_EBP + -0x184) = 0;\n    *(unaff_EBP + -0x1b8) = 0;\ncode_r0x00438be6:\n    if (**(unaff_EBP + 0xc) == '\\0') {\ncode_r0x004398d8:\n        if (*(unaff_EBP + -0x1d8) == 1) {\n            fcn.0043360e(*(unaff_EBP + -0x1bc));\n        }\n        *(unaff_EBP + -0x1ec) = 0x439919;\n        fcn.004316b0();\n        *(unaff_EBP + -0x1ec) = 0x43991e;\n        fcn.0043495b();\n        return;\n    }\n    iVar7 = fcn.00439a06(**(unaff_EBP + 0xc));\n    if (iVar7 != 0) {\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        do {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.00438b8d();\n            iVar8 = fcn.00439a06(iVar7);\n        } while (iVar8 != 0);\n        if (iVar7 != -1) {\n            fcn.0043b443(iVar7, *(unaff_EBP + 8));\n        }\n        do {\n            *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\n            iVar7 = fcn.00439a06(**(unaff_EBP + 0xc));\n        } while (iVar7 != 0);\n        goto code_r0x00438be6;\n    }\n    puVar21 = *(unaff_EBP + 0xc);\n    if (*puVar21 != 0x25) {\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n        uVar14 = fcn.00438b8d();\n        *(unaff_EBP + -0x194) = uVar14;\n        uVar13 = *puVar21;\n        *(unaff_EBP + 0xc) = puVar21 + 1;\n        if (uVar13 != uVar14) goto code_r0x0043989f;\n        if ((*(*0x45ca64 + 1 + (uVar14 & 0xff) * 2) & 0x80) != 0) {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            uVar11 = fcn.00438b8d();\n            uVar13 = puVar21[1];\n            *(unaff_EBP + 0xc) = puVar21 + 2;\n            if (uVar13 != uVar11) {\n                if (uVar11 != 0xffffffff) {\n                    fcn.0043b443(uVar11, *(unaff_EBP + 8));\n                }\n                goto code_r0x0043989f;\n            }\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        }\n        goto code_r0x004398b9;\n    }\n    iVar7 = 0;\n    *(unaff_EBP + -0x1a0) = 0;\n    *(unaff_EBP + -0x198) = 0;\n    *(unaff_EBP + -0x19c) = 0;\n    *(unaff_EBP + -0x1b4) = 0;\n    *(unaff_EBP + -0x18c) = 0;\n    *(unaff_EBP + -0x1a1) = 0;\n    *(unaff_EBP + -0x197) = 0;\n    *(unaff_EBP + -0x18e) = 0;\n    *(unaff_EBP + -0x17d) = 0;\n    *(unaff_EBP + -0x196) = 0;\n    *(unaff_EBP + -0x185) = 0;\n    *(unaff_EBP + -0x18d) = 1;\n    *(unaff_EBP + -0x1c8) = 0;\n    do {\n        puVar16 = puVar21 + 1;\n        uVar14 = *puVar16;\n        iVar8 = fcn.0043998d(uVar14);\n        puVar17 = puVar16;\n        if (iVar8 == 0) {\n            if (uVar14 < 0x4f) {\n                if (uVar14 != 0x4e) {\n                    if (uVar14 == 0x2a) {\n                        *(unaff_EBP + -0x18e) = *(unaff_EBP + -0x18e) + '\\x01';\n                    }\n                    else if (uVar14 != 0x46) {\n                        if (uVar14 == 0x49) {\n                            uVar13 = puVar21[2];\n                            if ((uVar13 == 0x36) && (puVar21[3] == 0x34)) {\n                                *(unaff_EBP + -0x1c8) = *(unaff_EBP + -0x1c8) + 1;\n                                *(unaff_EBP + -0x1ac) = 0;\n                                *(unaff_EBP + -0x1a8) = 0;\n                                puVar17 = puVar21 + 3;\n                            }\n                            else if (((uVar13 != 0x33) || (puVar17 = puVar21 + 3,  *puVar17 != 0x32)) &&\n                                    ((((puVar17 = puVar16,  uVar13 != 100 && (uVar13 != 0x69)) && (uVar13 != 0x6f)) &&\n                                     ((uVar13 != 0x78 && (uVar13 != 0x58)))))) goto code_r0x00438d6d;\n                        }\n                        else if (uVar14 == 0x4c) {\n                            *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + '\\x01';\n                        }\n                        else {\ncode_r0x00438d6d:\n                            *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                            puVar17 = puVar16;\n                        }\n                    }\n                }\n            }\n            else if (uVar14 == 0x68) {\n                *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + -1;\n                *(unaff_EBP + -0x185) = *(unaff_EBP + -0x185) + -1;\n            }\n            else {\n                if (uVar14 == 0x6c) {\n                    *(unaff_EBP + -0x18d) = *(unaff_EBP + -0x18d) + '\\x01';\n                }\n                else if (uVar14 != 0x77) goto code_r0x00438d6d;\n                *(unaff_EBP + -0x185) = *(unaff_EBP + -0x185) + '\\x01';\n            }\n        }\n        else {\n            *(unaff_EBP + -0x1b4) = *(unaff_EBP + -0x1b4) + 1;\n            iVar7 = (uVar14 - 0x30) + iVar7 * 10;\n        }\n        puVar21 = puVar17;\n    } while (*(unaff_EBP + -0x17d) == '\\0');\n    *(unaff_EBP + -0x18c) = iVar7;\n    *(unaff_EBP + 0xc) = puVar17;\n    if (*(unaff_EBP + -0x18e) == '\\0') {\n        puVar15 = *(unaff_EBP + 0x10);\n        *(unaff_EBP + -0x1dc) = puVar15;\n        *(unaff_EBP + 0x10) = puVar15 + 1;\n        puVar15 = *puVar15;\n        *(unaff_EBP + -0x1b0) = puVar15;\n    }\n    else {\n        puVar15 = *(unaff_EBP + -0x1b0);\n    }\n    *(unaff_EBP + -0x17d) = 0;\n    if ((*(unaff_EBP + -0x185) == '\\0') &&\n       ((uVar13 = *puVar17,  uVar13 == 0x53 || (*(unaff_EBP + -0x185) = 0xff,  uVar13 == 0x43)))) {\n        *(unaff_EBP + -0x185) = 1;\n    }\n    uVar14 = *puVar17 | 0x20;\n    *(unaff_EBP + -0x1c0) = uVar14;\n    if (uVar14 == 0x6e) {\ncode_r0x00438e3a:\n        uVar9 = *(unaff_EBP + 8);\n    }\n    else {\n        if ((uVar14 != 99) && (uVar14 != 0x7b)) {\n            do {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar9 = fcn.00438b8d();\n                iVar7 = fcn.00439a06(uVar9);\n            } while (iVar7 != 0);\n            *(unaff_EBP + -0x194) = uVar9;\n            goto code_r0x00438e3a;\n        }\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n        uVar9 = *(unaff_EBP + 8);\n        uVar10 = fcn.00438b8d();\n        *(unaff_EBP + -0x194) = uVar10;\n    }\n    iVar7 = *(unaff_EBP + -0x1b4);\n    if ((iVar7 != 0) && (*(unaff_EBP + -0x18c) == 0)) {\ncode_r0x0043914a:\n        uVar14 = *(unaff_EBP + -0x194);\ncode_r0x0043989f:\n        if (uVar14 != 0xffffffff) {\n            fcn.0043b443(*(unaff_EBP + -0x194), *(unaff_EBP + 8));\n        }\n        goto code_r0x004398d8;\n    }\n    if (0x6f < uVar14) {\n        if (uVar14 == 0x70) {\n            *(unaff_EBP + -0x18d) = 1;\ncode_r0x00439537:\n            uVar11 = *(unaff_EBP + -0x194);\n            if (uVar11 == 0x2d) {\n                *(unaff_EBP + -0x197) = 1;\n            }\n            else if (uVar11 != 0x2b) goto code_r0x0043957a;\n            piVar1 = unaff_EBP + -0x18c;\n            *piVar1 = *piVar1 + -1;\n            if ((*piVar1 == 0) && (iVar7 != 0)) {\n                *(unaff_EBP + -0x17d) = 1;\n            }\n            else {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar11 = fcn.00438b8d();\ncode_r0x00439574:\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n        }\n        else {\n            if (uVar14 == 0x73) {\ncode_r0x004390fd:\n                if ('\\0' < *(unaff_EBP + -0x185)) {\n                    *(unaff_EBP + -0x196) = 1;\n                }\ncode_r0x004392c7:\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                puVar20 = puVar15;\n                if (*(unaff_EBP + -0x194) != -1) {\n                    fcn.0043b443(*(unaff_EBP + -0x194), *(unaff_EBP + 8));\n                }\n                do {\n                    if ((*(unaff_EBP + -0x1b4) != 0) &&\n                       (iVar7 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar7 == 0)\n                       ) goto code_r0x004394e8;\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.00438b8d();\n                    *(unaff_EBP + -0x194) = uVar11;\n                    if (uVar11 == 0xffffffff) goto code_r0x004394d2;\n                    uVar13 = uVar11;\n                    if ((uVar14 != 99) && (((uVar14 != 0x73 || ((8 < uVar11 && (uVar11 < 0xe)))) || (uVar11 == 0x20))))\n                    {\n                        if ((uVar14 != 0x7b) ||\n                           (((*((uVar11 >> 3) + *(unaff_EBP + -0x1bc)) ^ *(unaff_EBP + -0x1a1)) & 1 << (uVar13 & 7)) ==\n                            0)) goto code_r0x004394d2;\n                        uVar14 = *(unaff_EBP + -0x1c0);\n                    }\n                    if (*(unaff_EBP + -0x18e) == '\\0') {\n                        if (*(unaff_EBP + -0x196) == '\\0') {\n                            *puVar15 = uVar13;\n                            puVar15 = puVar15 + 1;\n                        }\n                        else {\n                            *(unaff_EBP + -0x1c4) = uVar13;\n                            if ((*(*0x45ca64 + 1 + (uVar11 & 0xff) * 2) & 0x80) != 0) {\n                                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                                uVar6 = fcn.00438b8d();\n                                *(unaff_EBP + -0x1c3) = uVar6;\n                            }\n                            fcn.0043b56f(unaff_EBP + -0x1cc, unaff_EBP + -0x1c4, *0x45cad8);\n                            *puVar15 = *(unaff_EBP + -0x1cc);\n                            puVar15 = puVar15 + 2;\n                        }\n                        *(unaff_EBP + -0x1b0) = puVar15;\n                    }\n                    else {\n                        puVar20 = puVar20 + 1;\n                    }\n                } while( true );\n            }\n            if (uVar14 == 0x75) goto code_r0x00439537;\n            if (uVar14 != 0x78) {\n                if (uVar14 == 0x7b) {\n                    if ('\\0' < *(unaff_EBP + -0x185)) {\n                        *(unaff_EBP + -0x196) = 1;\n                    }\n                    iVar7 = *(unaff_EBP + 0xc);\n                    puVar21 = iVar7 + 1;\n                    *(unaff_EBP + 0xc) = puVar21;\n                    *(unaff_EBP + -0x1d0) = puVar21;\n                    if (*puVar21 == 0x5e) {\n                        puVar21 = iVar7 + 2;\n                        *(unaff_EBP + -0x1d0) = puVar21;\n                        *(unaff_EBP + -0x1a1) = 0xff;\n                    }\n                    puVar15 = *(unaff_EBP + -0x1bc);\n                    if (*(unaff_EBP + -0x1bc) == NULL) {\n                        *(unaff_EBP + -4) = 0;\n                        fcn.004316c0();\n                        *(unaff_EBP + -0x18) = &fcn.00438ba3::var_4h_2;\n                        *(unaff_EBP + -0x1bc) = &fcn.00438ba3::var_4h_2;\n                        *(unaff_EBP + -4) = 0xffffffff;\n                        puVar15 = &fcn.00438ba3::var_4h_2;\n                    }\n                    fcn.00433ba0(puVar15, 0, 0x20);\n                    if (*(unaff_EBP + -0x1c0) != 0x7b) goto code_r0x0043929b;\n                    if (*puVar21 != 0x5d) goto code_r0x0043929b;\n                    uVar13 = 0x5d;\n                    puVar21 = puVar21 + 1;\n                    *(puVar15 + 0xb) = 0x20;\n                    while (uVar12 = *puVar21,  uVar12 != 0x5d) {\n                        if (((uVar12 == 0x2d) && (uVar13 != 0)) && (uVar3 = puVar21[1],  uVar3 != 0x5d)) {\n                            puVar21 = puVar21 + 2;\n                            uVar12 = uVar3;\n                            if (uVar13 < uVar3) {\n                                uVar12 = uVar13;\n                                uVar13 = uVar3;\n                            }\n                            if (uVar12 <= uVar13) {\n                                uVar14 = uVar12;\n                                *(unaff_EBP + -0x1d4) = (uVar13 - uVar12) + 1;\n                                do {\n                                    *(puVar15 + (uVar14 >> 3)) = *(puVar15 + (uVar14 >> 3)) | '\\x01' << (uVar14 & 7);\n                                    uVar14 = uVar14 + 1;\n                                    piVar1 = unaff_EBP + -0x1d4;\n                                    *piVar1 = *piVar1 + -1;\n                                } while (*piVar1 != 0);\n                            }\n                            uVar13 = 0;\n                        }\n                        else {\n                            *(unaff_EBP + -0x198) = uVar12;\n                            *(puVar15 + (uVar12 >> 3)) = *(puVar15 + (uVar12 >> 3)) | '\\x01' << (uVar12 & 7);\n                            puVar21 = puVar21 + 1;\ncode_r0x0043929b:\n                            uVar13 = *(unaff_EBP + -0x198);\n                        }\n                    }\n                    puVar15 = *(unaff_EBP + -0x1b0);\n                    if (*(unaff_EBP + -0x1c0) == 0x7b) {\n                        *(unaff_EBP + 0xc) = puVar21;\n                    }\n                    uVar14 = *(unaff_EBP + -0x1c0);\n                    goto code_r0x004392c7;\n                }\n                goto code_r0x0043913c;\n            }\ncode_r0x00438ec4:\n            uVar11 = *(unaff_EBP + -0x194);\n            if (uVar11 == 0x2d) {\n                *(unaff_EBP + -0x197) = 1;\ncode_r0x004393ea:\n                piVar1 = unaff_EBP + -0x18c;\n                *piVar1 = *piVar1 + -1;\n                if ((*piVar1 == 0) && (iVar7 != 0)) {\n                    *(unaff_EBP + -0x17d) = 1;\n                }\n                else {\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.00438b8d();\n                    *(unaff_EBP + -0x194) = uVar11;\n                }\n            }\n            else if (uVar11 == 0x2b) goto code_r0x004393ea;\n            if (uVar11 == 0x30) {\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                uVar11 = fcn.00438b8d();\n                *(unaff_EBP + -0x194) = uVar11;\n                if ((uVar11 == 'x') || (uVar11 == 'X')) {\n                    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                    uVar11 = fcn.00438b8d();\n                    *(unaff_EBP + -0x194) = uVar11;\n                    if ((*(unaff_EBP + -0x1b4) != 0) &&\n                       (*(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -2,  *(unaff_EBP + -0x18c) < 1)) {\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    uVar14 = 0x78;\n                }\n                else {\n                    *(unaff_EBP + -0x19c) = 1;\n                    if (uVar14 == 0x78) {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.0043b443(uVar11, uVar9);\n                        }\n                        uVar11 = 0x30;\n                        goto code_r0x00439574;\n                    }\n                    if (*(unaff_EBP + -0x1b4) != 0) {\n                        piVar1 = unaff_EBP + -0x18c;\n                        *piVar1 = *piVar1 + -1;\n                        if (*piVar1 == 0) {\n                            *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                        }\n                    }\n                    uVar14 = 0x6f;\n                }\n            }\n        }\ncode_r0x0043957a:\n        if (*(unaff_EBP + -0x1c8) == 0) {\n            if (*(unaff_EBP + -0x17d) == '\\0') {\n                do {\n                    if ((uVar14 == 0x78) || (uVar14 == 0x70)) {\n                        iVar7 = fcn.004399c7(uVar11);\n                        if (iVar7 != 0) {\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) << 4;\n                            iVar7 = fcn.0043998d(uVar11);\n                            if (iVar7 == 0) {\n                                uVar11 = (uVar11 & 0xffffffdf) - 7;\n                            }\n                            goto code_r0x00439757;\n                        }\ncode_r0x00439751:\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    else {\n                        iVar7 = fcn.0043998d(uVar11);\n                        if (iVar7 == 0) goto code_r0x00439751;\n                        if (uVar14 == 0x6f) {\n                            if (0x37 < uVar11) goto code_r0x00439751;\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) << 3;\n                        }\n                        else {\n                            *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) * 10;\n                        }\n                    }\ncode_r0x00439757:\n                    if (*(unaff_EBP + -0x17d) == '\\0') {\n                        *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                        *(unaff_EBP + -0x1a0) = *(unaff_EBP + -0x1a0) + -0x30 + uVar11;\n                        if (*(unaff_EBP + -0x1b4) != 0) {\n                            piVar1 = unaff_EBP + -0x18c;\n                            *piVar1 = *piVar1 + -1;\n                            if (*piVar1 == 0) {\n                                *(unaff_EBP + -0x17d) = 1;\n                                goto code_r0x004397b5;\n                            }\n                        }\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                        uVar11 = fcn.00438b8d();\n                    }\n                    else {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.0043b443(uVar11, uVar9);\n                        }\n                    }\ncode_r0x004397b5:\n                } while (*(unaff_EBP + -0x17d) == '\\0');\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n            if (*(unaff_EBP + -0x197) != '\\0') {\n                *(unaff_EBP + -0x1a0) = -*(unaff_EBP + -0x1a0);\n            }\n        }\n        else {\n            if (*(unaff_EBP + -0x17d) == '\\0') {\n                do {\n                    if ((uVar14 == 0x78) || (uVar14 == 0x70)) {\n                        iVar7 = fcn.004399c7(uVar11);\n                        if (iVar7 != 0) {\n                            uVar4 = *(unaff_EBP + -0x1ac);\n                            *(unaff_EBP + -0x1ac) = uVar4 << 4;\n                            *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) << 4 | uVar4 >> 0x1c;\n                            iVar7 = fcn.0043998d(uVar11);\n                            if (iVar7 == 0) {\n                                uVar11 = (uVar11 & 0xffffffdf) - 7;\n                            }\n                            goto code_r0x00439642;\n                        }\ncode_r0x0043963c:\n                        *(unaff_EBP + -0x17d) = *(unaff_EBP + -0x17d) + '\\x01';\n                    }\n                    else {\n                        iVar7 = fcn.0043998d(uVar11);\n                        if (iVar7 == 0) goto code_r0x0043963c;\n                        if (uVar14 == 0x6f) {\n                            if (0x37 < uVar11) goto code_r0x0043963c;\n                            uVar4 = *(unaff_EBP + -0x1ac);\n                            *(unaff_EBP + -0x1ac) = uVar4 << 3;\n                            *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) << 3 | uVar4 >> 0x1d;\n                        }\n                        else {\n                            var_4h_2 = *(unaff_EBP + -0x1ac);\n                            uVar22 = fcn.00434a80();\n                            *(unaff_EBP + -0x1ac) = uVar22;\n                            *(unaff_EBP + -0x1a8) = uVar22 >> 0x20;\n                        }\n                    }\ncode_r0x00439642:\n                    if (*(unaff_EBP + -0x17d) == '\\0') {\n                        *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                        uVar4 = uVar11 - 0x30;\n                        puVar2 = unaff_EBP + -0x1ac;\n                        uVar5 = *puVar2;\n                        *puVar2 = *puVar2 + uVar4;\n                        *(unaff_EBP + -0x1a8) = *(unaff_EBP + -0x1a8) + (uVar4 >> 0x1f) + CARRY4(uVar5, uVar4);\n                        if (*(unaff_EBP + -0x1b4) != 0) {\n                            piVar1 = unaff_EBP + -0x18c;\n                            *piVar1 = *piVar1 + -1;\n                            if (*piVar1 == 0) {\n                                *(unaff_EBP + -0x17d) = 1;\n                                goto code_r0x004396a0;\n                            }\n                        }\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                        uVar11 = fcn.00438b8d();\n                    }\n                    else {\n                        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n                        if (uVar11 != 0xffffffff) {\n                            fcn.0043b443(uVar11, uVar9);\n                        }\n                    }\ncode_r0x004396a0:\n                } while (*(unaff_EBP + -0x17d) == '\\0');\n                *(unaff_EBP + -0x194) = uVar11;\n            }\n            if (*(unaff_EBP + -0x197) != '\\0') {\n                iVar7 = *(unaff_EBP + -0x1ac);\n                *(unaff_EBP + -0x1ac) = -iVar7;\n                *(unaff_EBP + -0x1a8) = -(*(unaff_EBP + -0x1a8) + (iVar7 != 0));\n            }\n        }\n        if (uVar14 == 0x46) {\n            *(unaff_EBP + -0x19c) = 0;\n        }\n        if (*(unaff_EBP + -0x19c) != 0) {\n            if (*(unaff_EBP + -0x18e) == '\\0') {\n                *(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1;\n                puVar15 = *(unaff_EBP + -0x1b0);\n                uVar9 = *(unaff_EBP + -0x1a0);\ncode_r0x0043980b:\n                if (*(unaff_EBP + -0x1c8) == 0) {\n                    if (*(unaff_EBP + -0x18d) == '\\0') {\n                        *puVar15 = uVar9;\n                    }\n                    else {\n                        *puVar15 = uVar9;\n                    }\n                }\n                else {\n                    *puVar15 = *(unaff_EBP + -0x1ac);\n                    puVar15[1] = *(unaff_EBP + -0x1a8);\n                }\n            }\n            goto code_r0x00439837;\n        }\n        goto code_r0x004398d8;\n    }\n    if (uVar14 == 0x6f) goto code_r0x00439537;\n    if (uVar14 == 99) {\n        if (iVar7 == 0) {\n            *(unaff_EBP + -0x1b4) = 1;\n            *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + 1;\n        }\n        goto code_r0x004390fd;\n    }\n    if (uVar14 == 100) goto code_r0x00439537;\n    if (uVar14 < 0x65) {\ncode_r0x0043913c:\n        if (**(unaff_EBP + 0xc) != *(unaff_EBP + -0x194)) goto code_r0x0043914a;\n        *(unaff_EBP + -0x195) = *(unaff_EBP + -0x195) + -1;\n        if (*(unaff_EBP + -0x18e) == '\\0') {\n            *(unaff_EBP + 0x10) = *(unaff_EBP + -0x1dc);\n        }\n    }\n    else {\n        if (0x67 < uVar14) {\n            if (uVar14 == 0x69) {\n                uVar14 = 100;\n                goto code_r0x00438ec4;\n            }\n            if (uVar14 != 0x6e) goto code_r0x0043913c;\n            uVar9 = *(unaff_EBP + -0x184);\n            if (*(unaff_EBP + -0x18e) != '\\0') goto code_r0x00439837;\n            goto code_r0x0043980b;\n        }\n        pcVar18 = unaff_EBP + -0x17c;\n        iVar7 = *(unaff_EBP + -0x194);\n        if (iVar7 == 0x2d) {\n            *(unaff_EBP + -0x17c) = 0x2d;\n            pcVar18 = unaff_EBP + -0x17b;\ncode_r0x00438f03:\n            *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            uVar9 = *(unaff_EBP + 8);\n            iVar7 = fcn.00438b8d();\n            *(unaff_EBP + -0x194) = iVar7;\n        }\n        else {\n            if (iVar7 == 0x2b) goto code_r0x00438f03;\n            uVar9 = *(unaff_EBP + 8);\n        }\n        if ((*(unaff_EBP + -0x1b4) == 0) || (0x15d < *(unaff_EBP + -0x18c))) {\n            *(unaff_EBP + -0x18c) = 0x15d;\n        }\n        while( true ) {\n            iVar8 = fcn.0043998d(iVar7);\n            if ((iVar8 == 0) ||\n               (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 == 0)) break;\n            *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n            *pcVar18 = iVar7;\n            pcVar18 = pcVar18 + 1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.00438b8d();\n            *(unaff_EBP + -0x194) = iVar7;\n        }\n        if ((*0x45cadc == iVar7) &&\n           (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0)) {\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.00438b8d();\n            *pcVar18 = *0x45cadc;\n            while( true ) {\n                pcVar18 = pcVar18 + 1;\n                *(unaff_EBP + -0x194) = iVar7;\n                iVar8 = fcn.0043998d(iVar7);\n                if ((iVar8 == 0) ||\n                   (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 == 0))\n                break;\n                *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                *pcVar18 = iVar7;\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                iVar7 = fcn.00438b8d();\n            }\n        }\n        pcVar19 = pcVar18;\n        if ((*(unaff_EBP + -0x19c) != 0) &&\n           (((iVar7 == 0x65 || (iVar7 == 0x45)) &&\n            (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0)))) {\n            *pcVar18 = 'e';\n            pcVar19 = pcVar18 + 1;\n            *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n            iVar7 = fcn.00438b8d();\n            *(unaff_EBP + -0x194) = iVar7;\n            if (iVar7 == 0x2d) {\n                *pcVar19 = '-';\n                pcVar19 = pcVar18 + 2;\ncode_r0x0043903d:\n                iVar8 = *(unaff_EBP + -0x18c);\n                *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1;\n                if (iVar8 != 0) goto code_r0x0043906e;\n                *(unaff_EBP + -0x18c) = 0;\n            }\n            else if (iVar7 == 0x2b) goto code_r0x0043903d;\n            while ((iVar8 = fcn.0043998d(iVar7),  iVar8 != 0 &&\n                   (iVar8 = *(unaff_EBP + -0x18c),  *(unaff_EBP + -0x18c) = *(unaff_EBP + -0x18c) + -1,  iVar8 != 0))) {\n                *(unaff_EBP + -0x19c) = *(unaff_EBP + -0x19c) + 1;\n                *pcVar19 = iVar7;\n                pcVar19 = pcVar19 + 1;\ncode_r0x0043906e:\n                *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + 1;\n                iVar7 = fcn.00438b8d();\n                *(unaff_EBP + -0x194) = iVar7;\n            }\n        }\n        *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n        if (iVar7 != -1) {\n            fcn.0043b443(iVar7, uVar9);\n        }\n        if (*(unaff_EBP + -0x19c) == 0) goto code_r0x004398d8;\n        if (*(unaff_EBP + -0x18e) == '\\0') {\n            *(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1;\n            *pcVar19 = '\\0';\n            (**0x45ca88)(*(unaff_EBP + -0x18d) + -1, *(unaff_EBP + -0x1b0), unaff_EBP + -0x17c);\n        }\n    }\ncode_r0x00439837:\n    *(unaff_EBP + -0x195) = *(unaff_EBP + -0x195) + '\\x01';\n    *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) + 1;\ncode_r0x004398b9:\n    if ((*(unaff_EBP + -0x194) == -1) && ((**(unaff_EBP + 0xc) != '%' || ((*(unaff_EBP + 0xc))[1] != 'n'))))\n    goto code_r0x004398d8;\n    goto code_r0x00438be6;\ncode_r0x004394d2:\n    *(unaff_EBP + -0x184) = *(unaff_EBP + -0x184) + -1;\n    if (uVar11 != 0xffffffff) {\n        fcn.0043b443(uVar11, *(unaff_EBP + 8));\n    }\ncode_r0x004394e8:\n    if (puVar20 == puVar15) goto code_r0x004398d8;\n    if ((*(unaff_EBP + -0x18e) == '\\0') &&\n       (*(unaff_EBP + -0x1b8) = *(unaff_EBP + -0x1b8) + 1,  *(unaff_EBP + -0x1c0) != 99)) {\n        if (*(unaff_EBP + -0x196) == '\\0') {\n            **(unaff_EBP + -0x1b0) = 0;\n        }\n        else {\n            **(unaff_EBP + -0x1b0) = 0;\n        }\n    }\n    goto code_r0x00439837;\n}\n",
        "token_count": 10110
    },
    "0043998d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0043998d(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.004350c1();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x45c584) {\n        iVar1 = fcn.00435060();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.00434e58(iVar1, param_1, 4);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 4;\n}\n",
        "token_count": 156
    },
    "004399c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.004399c7(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.004350c1();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x45c584) {\n        iVar1 = fcn.00435060();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.00434e58(iVar1, param_1, 0x80);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 0x80;\n}\n",
        "token_count": 160
    },
    "00439a06": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.00439a06(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    iVar1 = fcn.004350c1();\n    iVar1 = *(iVar1 + 100);\n    if (iVar1 != *0x45c584) {\n        iVar1 = fcn.00435060();\n    }\n    if (1 < *(iVar1 + 0x28)) {\n        uVar2 = fcn.00434e58(iVar1, param_1, 8);\n        return uVar2;\n    }\n    return *(*(iVar1 + 0x48) + param_1 * 2) & 8;\n}\n",
        "token_count": 156
    },
    "00439a40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpCharType\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.00439a40(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_20h_2, \n            uint noname_7, uint arg_8h, uint lpMultiByteStr, uint cbMultiByte, uint arg_14h, uint CodePage, uint arg_1ch\n            , uint arg_20h)\n\n{\n    int32_t iVar1;\n    uint *arg_8h_00;\n    uint uVar2;\n    int32_t noname_1_00;\n    int32_t unaff_EBP;\n    int32_t iVar3;\n    int32_t noname_0_00;\n    uint dwInfoType;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h_2;\n    int32_t lpCharType;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    fcn.00434920();\n    iVar3 = 0;\n    if (*0x45f500 == 0) {\n        var_38h = 0x439a6a;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x45f500 = 2;\n            }\n        }\n        else {\n            *0x45f500 = 1;\n        }\n    }\n    if ((*0x45f500 == 2) || (*0x45f500 == 0)) {\n        iVar1 = *(unaff_EBP + 0x1c);\n        if (*(unaff_EBP + 0x1c) == 0) {\n            iVar1 = *0x45f50c;\n        }\n        noname_0_00 = *(unaff_EBP + 0x18);\n        if (*(unaff_EBP + 0x18) == 0) {\n            noname_0_00 = *0x45f51c;\n        }\n        noname_1_00 = fcn.0043b59a(iVar1);\n        if (noname_1_00 != -1) {\n            if (noname_1_00 != noname_0_00) {\n                lpCharType = noname_0_00;\n                var_38h = noname_1_00;\n                iVar3 = fcn.0043b5dd(noname_0_00, noname_1_00, *(unaff_EBP + 0xc), unaff_EBP + 0x10, 0, 0, 0x453a38, \n                                     0x1c);\n                if (iVar3 == 0) goto code_r0x00439bf1;\n                *(unaff_EBP + 0xc) = iVar3;\n            }\n            lpCharType = 0x439be2;\n            var_38h = iVar1;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n            if (iVar3 != 0) {\n                lpCharType = iVar3;\n                fcn.0043360e(iVar3);\n            }\n        }\n    }\n    else if (*0x45f500 == 1) {\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x45f51c;\n        }\n        var_38h = (*(unaff_EBP + 0x20) != 0) * 8 + 1;\n        lpCharType = *(unaff_EBP + 0x18);\n        arg_8h_00 = &fcn.00439a40::lpCharType;\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x28) = iVar3;\n        if (iVar3 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004316c0();\n            *(unaff_EBP + -0x18) = &fcn.00439a40::lpCharType;\n            *(unaff_EBP + -0x2c) = &fcn.00439a40::lpCharType;\n            fcn.00433ba0(&fcn.00439a40::lpCharType, 0, iVar3 * 2);\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                arg_8h_00 = fcn.00434bef(2, iVar3);\n                if (arg_8h_00 == NULL) goto code_r0x00439bf1;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x18), 1, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), arg_8h_00, iVar3);\n            if (iVar3 != 0) {\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(*(unaff_EBP + 8), arg_8h_00, iVar3, *(unaff_EBP + 0x14))\n                ;\n                *(unaff_EBP + -0x24) = uVar2;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.0043360e(arg_8h_00);\n            }\n        }\n    }\ncode_r0x00439bf1:\n    *(unaff_EBP + -0x3c) = 0x439bf9;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 1562
    },
    "00439d6e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_38h_2\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpSrcStr\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.00439d6e(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint CodePage, uint arg_24h, uint arg_8h, \n            uint arg_ch, uint arg_10h, uint cchSrc, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *lpMultiByteStr_00;\n    int32_t unaff_EBP;\n    uchar *arg_8h_00;\n    uint var_2ch;\n    uint var_48h;\n    uint var_24h_2;\n    uint var_40h;\n    uint lpWideCharStr;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_20h_2;\n    uint var_24h_3;\n    uint var_28h;\n    uint var_24h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint var_18h_2;\n    uint var_4h;\n    uint uVar5;\n    uint uVar6;\n    uint var_38h_2;\n    uint var_34h;\n    uint var_30h_2;\n    uint var_20h;\n    uint lpSrcStr;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h;\n    \n    fcn.00434920();\n    if (*0x45f524 == 0) {\n        lpSrcStr = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x45f524 = 2;\n            }\n        }\n        else {\n            *0x45f524 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        pcVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*pcVar2 == '\\0') goto code_r0x00439dd4;\n            pcVar2 = pcVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x00439dd4:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if ((*0x45f524 != 2) && (*0x45f524 != 0)) {\n        if (*0x45f524 != 1) goto code_r0x0043a121;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        if (*(unaff_EBP + 0x20) == 0) {\n            *(unaff_EBP + 0x20) = *0x45f51c;\n        }\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x0043a121;\n        *(unaff_EBP + -4) = 1;\n        fcn.004316c0();\n        *(unaff_EBP + -0x18) = &fcn.00439d6e::lpSrcStr;\n        *(unaff_EBP + -0x1c) = &fcn.00439d6e::lpSrcStr;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) == 0) {\n            iVar3 = fcn.004335fc();\n            *(unaff_EBP + -0x1c) = iVar3;\n            if (iVar3 == 0) goto code_r0x0043a121;\n            *(unaff_EBP + -0x38) = 1;\n        }\n        var_30h_2 = 1;\n        var_34h = *(unaff_EBP + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, 0, 0);\n            *(unaff_EBP + -0x2c) = iVar3;\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    *(unaff_EBP + -4) = 2;\n                    fcn.004316c0();\n                    *(unaff_EBP + -0x18) = &fcn.00439d6e::var_34h;\n                    *(unaff_EBP + -0x20) = &fcn.00439d6e::var_34h;\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        iVar4 = fcn.004335fc(iVar3 * 2);\n                        *(unaff_EBP + -0x20) = iVar4;\n                        if (iVar4 == 0) goto code_r0x00439fa3;\n                        *(unaff_EBP + -0x34) = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                      (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, \n                                       *(unaff_EBP + -0x20), iVar3);\n                    if (iVar1 != 0) {\n                        if (*(unaff_EBP + 0x1c) == 0) {\n                            uVar6 = 0;\n                            uVar5 = 0;\n                        }\n                        else {\n                            uVar6 = *(unaff_EBP + 0x1c);\n                            uVar5 = *(unaff_EBP + 0x18);\n                        }\n                        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x20), 0, *(unaff_EBP + -0x20), iVar3, uVar5, uVar6, 0, 0);\n                    }\n                }\n                else if ((*(unaff_EBP + 0x1c) != 0) && (iVar3 <= *(unaff_EBP + 0x1c))) {\n                    (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, *(unaff_EBP + 0x18), \n                               *(unaff_EBP + 0x1c));\n                }\n            }\n        }\ncode_r0x00439fa3:\n        if (*(unaff_EBP + -0x34) != 0) {\n            fcn.0043360e(*(unaff_EBP + -0x20));\n        }\n        if (*(unaff_EBP + -0x38) != 0) {\n            fcn.0043360e(*(unaff_EBP + -0x1c));\n        }\n        goto code_r0x0043a121;\n    }\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x45f50c;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x45f51c;\n    }\n    iVar1 = fcn.0043b59a(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x40) = iVar1;\n    if (iVar1 == -1) goto code_r0x0043a121;\n    if (iVar1 == *(unaff_EBP + 0x20)) {\n        lpSrcStr = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n    }\n    else {\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = fcn.0043b5dd(lpSrcStr, iVar1, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x453a48, 0x38);\n        *(unaff_EBP + -0x28) = iVar1;\n        if (iVar1 == 0) goto code_r0x0043a121;\n        uVar6 = *(unaff_EBP + 0xc);\n        lpSrcStr = *(unaff_EBP + 8);\n        lpMultiByteStr_00 = &fcn.00439d6e::lpSrcStr;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        *(unaff_EBP + -0x24) = iVar1;\n        arg_8h_00 = NULL;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004316c0();\n            *(unaff_EBP + -0x18) = &fcn.00439d6e::lpSrcStr;\n            *(unaff_EBP + -0x44) = &fcn.00439d6e::lpSrcStr;\n            fcn.00433ba0();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                lpMultiByteStr_00 = fcn.004335fc();\n                arg_8h_00 = lpMultiByteStr_00;\n                if (lpMultiByteStr_00 == NULL) goto code_r0x0043a0e9;\n                fcn.00433ba0();\n                *(unaff_EBP + -0x3c) = 1;\n            }\n            var_30h_2 = *(unaff_EBP + 0xc);\n            var_34h = *(unaff_EBP + 8);\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            *(unaff_EBP + -0x24) = iVar1;\n            arg_8h_00 = lpMultiByteStr_00;\n            if (iVar1 != 0) {\n                var_30h_2 = *(unaff_EBP + 0x20);\n                var_34h = *(unaff_EBP + -0x40);\n                fcn.0043b5dd(var_34h, var_30h_2, lpMultiByteStr_00, unaff_EBP + -0x24, *(unaff_EBP + 0x18), \n                             *(unaff_EBP + 0x1c), lpSrcStr, uVar6);\n            }\n        }\ncode_r0x0043a0e9:\n        if (*(unaff_EBP + -0x3c) != 0) {\n            fcn.0043360e(arg_8h_00);\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.0043360e(*(unaff_EBP + -0x28));\n    }\ncode_r0x0043a121:\n    *(unaff_EBP + -0x58) = 0x43a129;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 3036
    },
    "0043a267": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043a267(int32_t arg_8h, int32_t *arg_ch, uint arg_10h)\n\n{\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (arg_8h != 0) {\n        fcn.0043bbb4(&var_8h, arg_10h);\n        *arg_ch = var_8h;\n        arg_ch[1] = var_4h;\n        return;\n    }\n    fcn.0043bbf1(&arg_8h, arg_10h);\n    *arg_ch = arg_8h;\n    return;\n}\n",
        "token_count": 144
    },
    "0043a2c2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043a2c2(int32_t arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t *in_EAX;\n    uchar *puVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uchar *unaff_EBX;\n    \n    if (arg_10h != '\\0') {\n        fcn.0043a2a5();\n    }\n    if (*in_EAX == 0x2d) {\n        *unaff_EBX = 0x2d;\n        unaff_EBX = unaff_EBX + 1;\n    }\n    puVar1 = unaff_EBX;\n    if (0 < arg_8h) {\n        puVar1 = unaff_EBX + 1;\n        *unaff_EBX = *puVar1;\n        *puVar1 = *0x45cadc;\n    }\n    puVar1 = fcn.004366a0(puVar1 + arg_8h + (arg_10h == '\\0'), \"e+000\");\n    if (arg_ch != 0) {\n        *puVar1 = 0x45;\n    }\n    if (*in_EAX[3] != '0') {\n        iVar2 = in_EAX[1] + -1;\n        if (iVar2 < 0) {\n            iVar2 = -iVar2;\n            puVar1[1] = 0x2d;\n        }\n        if (99 < iVar2) {\n            iVar3 = iVar2 / 100;\n            iVar2 = iVar2 % 100;\n            puVar1[2] = puVar1[2] + iVar3;\n        }\n        if (9 < iVar2) {\n            iVar3 = iVar2 / 10;\n            iVar2 = iVar2 % 10;\n            puVar1[3] = puVar1[3] + iVar3;\n        }\n        puVar1[4] = puVar1[4] + iVar2;\n    }\n    return;\n}\n",
        "token_count": 445
    },
    "0043a3dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuchar * __cdecl fcn.0043a3dc(uchar *arg_8h, int32_t arg_ch, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t *in_EAX;\n    uchar *puVar3;\n    \n    iVar1 = in_EAX[1];\n    if ((arg_10h != '\\0') && (iVar1 + -1 == arg_ch)) {\n        iVar2 = *in_EAX;\n        arg_8h[(iVar2 == 0x2d) + iVar1 + -1] = 0x30;\n        (arg_8h + (iVar2 == 0x2d) + iVar1 + -1)[1] = 0;\n    }\n    puVar3 = arg_8h;\n    if (*in_EAX == 0x2d) {\n        *arg_8h = 0x2d;\n        puVar3 = arg_8h + 1;\n    }\n    if (in_EAX[1] < 1) {\n        fcn.0043a2a5();\n        *puVar3 = 0x30;\n        puVar3 = puVar3 + 1;\n    }\n    else {\n        puVar3 = puVar3 + in_EAX[1];\n    }\n    if (0 < arg_ch) {\n        fcn.0043a2a5();\n        *puVar3 = *0x45cadc;\n        iVar1 = in_EAX[1];\n        if (iVar1 < 0) {\n            if ((arg_10h != '\\0') || (SBORROW4(arg_ch, -iVar1) == arg_ch + iVar1 < 0)) {\n                arg_ch = -iVar1;\n            }\n            fcn.0043a2a5();\n            fcn.00433ba0(puVar3 + 1, 0x30, arg_ch);\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 434
    },
    "0043a6c0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.0043a6c0(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    if (*0x45f528 == NULL) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar2 == 0) || (*0x45f528 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, 0x453b0c),  *0x45f528 == NULL))\n        {\n            return 0;\n        }\n        *0x45f52c = (*pcVar1)(iVar2, 0x453afc);\n        *0x45f530 = (*pcVar1)(iVar2, 0x453ae8);\n        if ((*0x45f0f0 == 2) && (*0x45f538 = (*pcVar1)(iVar2, \"GetUserObjectInformationA\"),  *0x45f538 != NULL)) {\n            *0x45f534 = (*pcVar1)(iVar2, \"GetProcessWindowStation\");\n        }\n    }\n    if ((*0x45f534 == NULL) ||\n       (((iVar2 = (**0x45f534)(),  iVar2 != 0 && (iVar2 = (**0x45f538)(iVar2, 1, &var_10h, 0xc, &var_4h),  iVar2 != 0))\n        && ((var_8h & 1) != 0)))) {\n        if (((*0x45f52c != NULL) && (iVar4 = (**0x45f52c)(),  iVar4 != 0)) && (*0x45f530 != NULL)) {\n            iVar4 = (**0x45f530)(iVar4);\n        }\n    }\n    else if (*0x45f0fc < 4) {\n        arg_10h = arg_10h | 0x40000;\n    }\n    else {\n        arg_10h = arg_10h | 0x200000;\n    }\n    uVar3 = (**0x45f528)(iVar4, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 565
    },
    "0043b293": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043b293(uint arg_8h, uint arg_ch)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t unaff_EBP;\n    uint var_20h;\n    uint var_4h;\n    \n    fcn.00434920(0x453b60, 0x10);\n    if (*0x45f594 == NULL) {\n        if (*0x45f0f0 != 1) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n            if (iVar2 != 0) {\n                *0x45f594 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"InitializeCriticalSectionAndSpinCount\");\n                if (*0x45f594 != NULL) goto code_r0x0043b2df;\n            }\n        }\n        *0x45f594 = 0x43b283;\n    }\ncode_r0x0043b2df:\n    pcVar1 = *0x45f594;\n    *(unaff_EBP + -4) = 0;\n    uVar3 = (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    *(unaff_EBP + -0x20) = uVar3;\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 341
    },
    "0043b31e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043b31e(uint8_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*(param_1 + 0x460781) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = *(*0x45ca64 + param_1 * 2) & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 132
    },
    "0043b443": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint32_t fcn.0043b443(uint32_t param_1, char **param_2)\n\n{\n    char *pcVar1;\n    \n    if (param_1 != 0xffffffff) {\n        pcVar1 = param_2[3];\n        if (((pcVar1 & 1) != 0) || ((pcVar1 < '\\0' && ((pcVar1 & 2) == 0)))) {\n            if (param_2[2] == NULL) {\n                fcn.0043b02d(param_2);\n            }\n            if (*param_2 == param_2[2]) {\n                if (param_2[1] != NULL) {\n                    return 0xffffffff;\n                }\n                *param_2 = *param_2 + 1;\n            }\n            *param_2 = *param_2 + -1;\n            pcVar1 = *param_2;\n            if ((*(param_2 + 3) & 0x40) == 0) {\n                *pcVar1 = param_1;\n            }\n            else if (*pcVar1 != param_1) {\n                *param_2 = pcVar1 + 1;\n                return 0xffffffff;\n            }\n            param_2[1] = param_2[1] + 1;\n            param_2[3] = param_2[3] & 0xffffffef | 1;\n            return param_1 & 0xff;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 326
    },
    "0043b4af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043b4af(int32_t arg_8h, uint16_t *lpWideCharStr, uint8_t *arg_10h, uint32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    if ((arg_10h != NULL) && (arg_14h != 0)) {\n        uVar1 = *arg_10h;\n        if (uVar1 != 0) {\n            if (*(arg_8h + 0x14) == 0) {\n                if (lpWideCharStr != NULL) {\n                    *lpWideCharStr = uVar1;\n                }\n                return 1;\n            }\n            if ((*(*(arg_8h + 0x48) + 1 + uVar1 * 2) & 0x80) == 0) {\n                iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(arg_8h + 4), 9, arg_10h, 1, lpWideCharStr, lpWideCharStr != NULL);\n                if (iVar2 != 0) {\n                    return 1;\n                }\n            }\n            else {\n                iVar2 = *(arg_8h + 0x28);\n                if ((((1 < iVar2) && (iVar2 <= arg_14h)) &&\n                    (iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                       (*(arg_8h + 4), 9, arg_10h, iVar2, lpWideCharStr, lpWideCharStr != NULL), \n                    iVar2 != 0)) || ((*(arg_8h + 0x28) <= arg_14h && (arg_10h[1] != 0)))) {\n                    return *(arg_8h + 0x28);\n                }\n            }\n            puVar3 = fcn.00434b6a();\n            *puVar3 = 0x2a;\n            return 0xffffffff;\n        }\n        if (lpWideCharStr != NULL) {\n            *lpWideCharStr = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 481
    },
    "0043b5dd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n\nvoid __cdecl\nfcn.0043b5dd(uint noname_0, uint noname_1, uint lpMultiByteStr, uint arg_14h_2, uint arg_8h, uint arg_ch, uint noname_6\n            , uint arg_14h)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *arg_ch_00;\n    uint *arg_8h_00;\n    int32_t unaff_EBP;\n    uint CodePage;\n    uint var_4h;\n    uint var_48h_2;\n    uint var_54h;\n    uint cbMultiByte;\n    uint var_3ch_2;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x38;\n    var_4h_2 = 0x453b70;\n    var_18h = 0x43b5e9;\n    fcn.00434920();\n    *(unaff_EBP + -0x1c) = *0x45c1a8;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    puVar1 = **(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x40) = puVar1;\n    *(unaff_EBP + -0x3c) = 0;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCPInfo;\n    if (*(unaff_EBP + 8) == *(unaff_EBP + 0xc)) {\n        arg_8h_00 = *(unaff_EBP + -0x48);\n    }\n    else {\n        var_18h = unaff_EBP + -0x30;\n        var_1ch = *(unaff_EBP + 8);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n        if ((((iVar3 != 0) && (*(unaff_EBP + -0x30) == 1)) &&\n            (iVar3 = (*pcVar2)(*(unaff_EBP + 0xc), unaff_EBP + -0x30),  iVar3 != 0)) && (*(unaff_EBP + -0x30) == 1)) {\n            *(unaff_EBP + -0x3c) = 1;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = *(unaff_EBP + -0x38);\n        }\n        else {\n            arg_ch_00 = puVar1;\n            if (puVar1 == 0xffffffff) {\n                iVar3 = fcn.00431a40(*(unaff_EBP + 0x10));\n                arg_ch_00 = iVar3 + 1;\n            }\n            *(unaff_EBP + -0x38) = arg_ch_00;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            arg_ch_00 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                                  (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), puVar1, 0, 0);\n            *(unaff_EBP + -0x38) = arg_ch_00;\n            if (arg_ch_00 == NULL) goto code_r0x0043b795;\n        }\n        arg_8h_00 = &fcn.0043b5dd::var_1ch;\n        *(unaff_EBP + -4) = 0;\n        fcn.004316c0();\n        *(unaff_EBP + -0x18) = &fcn.0043b5dd::var_1ch;\n        *(unaff_EBP + -0x48) = &fcn.0043b5dd::var_1ch;\n        fcn.00433ba0(&fcn.0043b5dd::var_1ch, 0, arg_ch_00 * 2);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x10) {\n            arg_8h_00 = fcn.00434bef(2, arg_ch_00);\n            if (arg_8h_00 == NULL) goto code_r0x0043b795;\n            *(unaff_EBP + -0x44) = 1;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), *(unaff_EBP + -0x40), arg_8h_00, arg_ch_00);\n        if (iVar3 != 0) {\n            if (*(unaff_EBP + 0x18) == 0) {\n                if (*(unaff_EBP + -0x3c) == 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    arg_ch_00 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                          (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, 0, 0);\n                    if (arg_ch_00 == NULL) goto code_r0x0043b786;\n                }\n                var_1ch = 1;\n                var_18h = arg_ch_00;\n                iVar3 = fcn.00434bef(1, arg_ch_00);\n                *(unaff_EBP + -0x34) = iVar3;\n                if (iVar3 != 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                      (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, iVar3, arg_ch_00);\n                    if (iVar3 == 0) {\n                        var_18h = *(unaff_EBP + -0x34);\n                        var_1ch = 0x43b770;\n                        fcn.0043360e(var_18h);\n                        *(unaff_EBP + -0x34) = 0;\n                    }\n                    else if (*(unaff_EBP + -0x40) != -1) {\n                        **(unaff_EBP + 0x14) = iVar3;\n                    }\n                }\n            }\n            else {\n                var_18h = NULL;\n                var_1ch = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0xc), 0, arg_8h_00, arg_ch_00, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c)\n                                  );\n                if (iVar3 != 0) {\n                    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x18);\n                }\n            }\n        }\n    }\ncode_r0x0043b786:\n    if (*(unaff_EBP + -0x44) != 0) {\n        var_1ch = 0x43b791;\n        var_18h = arg_8h_00;\n        fcn.0043360e(arg_8h_00);\n    }\ncode_r0x0043b795:\n    *(unaff_EBP + -0x58) = 0x43b7a0;\n    fcn.004316b0();\n    *(unaff_EBP + -0x58) = 0x43b7a5;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 1859
    },
    "0043b7a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Could not reconcile some variable overlaps\n\nuint32_t __cdecl fcn.0043b7a6(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint32_t in_ECX;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint noname_3;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint32_t var_4h;\n    \n    uVar2 = arg_ch;\n    uVar1 = arg_8h;\n    if ((*(arg_8h + 0x14) == 0) || ((*(arg_8h + 0x24) != 0 && (arg_ch < 0x80)))) {\n        if ((0x40 < arg_ch) && (arg_ch < 0x5b)) {\n            return arg_ch + 0x20;\n        }\n    }\n    else {\n        noname_3 = 1;\n        var_4h = in_ECX;\n        if (arg_ch < 0x100) {\n            if (*(arg_8h + 0x28) < 2) {\n                uVar3 = *(*(arg_8h + 0x48) + arg_ch * 2) & 1;\n            }\n            else {\n                uVar3 = fcn.00434e58(arg_8h, arg_ch, 1);\n            }\n            if (uVar3 == 0) {\n                return uVar2;\n            }\n        }\n        if ((*(*(uVar1 + 0x48) + 1 + (uVar2 >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            arg_8h = arg_8h & 0xffff0000 | uVar2 & 0xff;\n        }\n        else {\n            arg_8h = arg_8h & 0xff000000 | CONCAT11(uVar2, uVar2 >> 8);\n            noname_3 = 2;\n        }\n        iVar4 = fcn.00439d6e(*(uVar1 + 0x14), 0x100, &arg_8h, noname_3, &var_4h, 3, *(uVar1 + 4), 1, unaff_EDI, \n                             unaff_ESI, unaff_EBX, var_4h, unaff_EBP, unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, \n                             in_stack_00000010, in_stack_00000014, in_stack_00000018, in_stack_0000001c, \n                             in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                             in_stack_00000030, in_stack_00000034);\n        if (iVar4 != 0) {\n            if (iVar4 != 1) {\n                return CONCAT11(var_4h, var_4h._1_1_);\n            }\n            return var_4h & 0xff;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 841
    },
    "0043b890": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043b890(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    iVar2 = param_2 / 0x20;\n    uVar1 = *(param_1 + iVar2 * 4) & ~(-1 << (0x1fU - param_2 % 0x20 & 0x1f));\n    while( true ) {\n        if (uVar1 != 0) {\n            return 0;\n        }\n        iVar2 = iVar2 + 1;\n        if (2 < iVar2) break;\n        uVar1 = *(param_1 + iVar2 * 4);\n    }\n    return 1;\n}\n",
        "token_count": 164
    },
    "0043b9b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043b9b5(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint8_t uVar3;\n    uint *puVar4;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar3 = arg_ch % 0x20;\n    iVar2 = 0;\n    var_4h = 0;\n    do {\n        uVar1 = *(arg_8h + iVar2 * 4);\n        *(arg_8h + iVar2 * 4) = uVar1 >> (uVar3 & 0x1f) | var_4h;\n        var_4h = (uVar1 & ~(-1 << (uVar3 & 0x1f))) << (0x20 - uVar3 & 0x1f);\n        iVar2 = iVar2 + 1;\n    } while (iVar2 < 3);\n    iVar2 = 2;\n    puVar4 = arg_8h + (2 - arg_ch / 0x20) * 4;\n    do {\n        if (iVar2 < arg_ch / 0x20) {\n            *(arg_8h + iVar2 * 4) = 0;\n        }\n        else {\n            *(arg_8h + iVar2 * 4) = *puVar4;\n        }\n        iVar2 = iVar2 + -1;\n        puVar4 = puVar4 + -1;\n    } while (-1 < iVar2);\n    return;\n}\n",
        "token_count": 354
    },
    "0043bf6a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043bf6a(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    code *extraout_ECX;\n    code *arg_8h_00;\n    int32_t unaff_EBP;\n    code **ppcVar4;\n    code *pcVar5;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x453b80, 0x20);\n    *(unaff_EBP + -0x1c) = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == 2) {\n        ppcVar4 = 0x45f5a0;\n        pcVar5 = *0x45f5a0;\ncode_r0x0043bff7:\n        *(unaff_EBP + -0x1c) = 1;\n        iVar1 = *(unaff_EBP + -0x24);\n    }\n    else {\n        if (((iVar1 != 4) && (iVar1 != 8)) && (iVar1 != 0xb)) {\n            if (iVar1 == 0xf) {\n                ppcVar4 = 0x45f5ac;\n                pcVar5 = *0x45f5ac;\n            }\n            else if (iVar1 == 0x15) {\n                ppcVar4 = 0x45f5a4;\n                pcVar5 = *0x45f5a4;\n            }\n            else {\n                if (iVar1 != 0x16) goto code_r0x0043c0dd;\n                ppcVar4 = 0x45f5a8;\n                pcVar5 = *0x45f5a8;\n            }\n            goto code_r0x0043bff7;\n        }\n        iVar1 = fcn.004350c1();\n        *(unaff_EBP + -0x24) = iVar1;\n        iVar2 = fcn.0043bf3c();\n        ppcVar4 = iVar2 + 8;\n        pcVar5 = *ppcVar4;\n    }\n    arg_8h_00 = NULL;\n    *(unaff_EBP + -0x20) = pcVar5;\n    if (pcVar5 == 0x1) goto code_r0x0043c0dd;\n    if (pcVar5 == NULL) {\n        fcn.00433adf(3);\n        arg_8h_00 = extraout_ECX;\n    }\n    if (*(unaff_EBP + -0x1c) != arg_8h_00) {\n        fcn.004375c5(arg_8h_00);\n        arg_8h_00 = NULL;\n    }\n    *(unaff_EBP + -4) = arg_8h_00;\n    iVar2 = *(unaff_EBP + 8);\n    if (((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) {\n        *(unaff_EBP + -0x2c) = *(iVar1 + 0x58);\n        *(iVar1 + 0x58) = arg_8h_00;\n        if (iVar2 == 8) {\n            *(unaff_EBP + -0x30) = *(iVar1 + 0x5c);\n            *(iVar1 + 0x5c) = 0x8c;\n            goto code_r0x0043c056;\n        }\ncode_r0x0043c082:\n        *ppcVar4 = arg_8h_00;\n    }\n    else {\ncode_r0x0043c056:\n        iVar3 = *0x45ca30;\n        if (iVar2 != 8) goto code_r0x0043c082;\n        for (; *(unaff_EBP + -0x28) = iVar3,  iVar3 < *0x45ca34 + *0x45ca30; iVar3 = iVar3 + 1) {\n            *(*(iVar1 + 0x54) + 8 + iVar3 * 0xc) = arg_8h_00;\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043c0a5();\n    if (*(unaff_EBP + 8) == 8) {\n        (*pcVar5)(8, *(iVar1 + 0x5c));\n    }\n    else {\n        (*pcVar5)(*(unaff_EBP + 8));\n    }\n    iVar2 = *(unaff_EBP + 8);\n    if ((((iVar2 == 8) || (iVar2 == 0xb)) || (iVar2 == 4)) && (*(iVar1 + 0x58) = *(unaff_EBP + -0x2c),  iVar2 == 8)) {\n        *(iVar1 + 0x5c) = *(unaff_EBP + -0x30);\n    }\ncode_r0x0043c0dd:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 1173
    },
    "0043c0e3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043c0e3(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint in_stack_00000018;\n    uint in_stack_0000001c;\n    uint in_stack_00000020;\n    uint in_stack_00000024;\n    uint in_stack_00000028;\n    uint in_stack_0000002c;\n    uint in_stack_00000030;\n    uint in_stack_00000034;\n    uint in_stack_00000038;\n    uint in_stack_0000003c;\n    uint in_stack_00000040;\n    uint in_stack_00000044;\n    uint in_stack_00000048;\n    uint in_stack_0000004c;\n    uint in_stack_00000050;\n    \n    iVar1 = fcn.004350c1();\n    iVar1 = *(iVar1 + 0x60);\n    if (iVar1 != *0x460768) {\n        iVar1 = fcn.00434493();\n    }\n    if (arg_10h == 0) {\n        return 0;\n    }\n    iVar1 = fcn.0043d14d(*(iVar1 + 0xc), 1, arg_8h, arg_10h, arg_ch, arg_10h, *(iVar1 + 4), unaff_EBP, unaff_retaddr, \n                         arg_8h, arg_ch, arg_10h, in_stack_00000010, in_stack_00000014, in_stack_00000018, \n                         in_stack_0000001c, in_stack_00000020, in_stack_00000024, in_stack_00000028, in_stack_0000002c, \n                         in_stack_00000030, in_stack_00000034, in_stack_00000038, in_stack_0000003c, in_stack_00000040, \n                         in_stack_00000044, in_stack_00000048, in_stack_0000004c, in_stack_00000050);\n    if (iVar1 == 0) {\n        return 0x7fffffff;\n    }\n    return iVar1 + -2;\n}\n",
        "token_count": 514
    },
    "0043c1c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043c1c1(uint32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint uVar5;\n    \n    if (param_1 < *0x460630) {\n        piVar1 = (param_1 >> 5) * 4 + 0x460640;\n        iVar4 = (param_1 & 0x1f) * 0x24;\n        piVar2 = *piVar1 + iVar4;\n        if (((*(piVar2 + 1) & 1) != 0) && (*piVar2 != -1)) {\n            if (*0x45c284 == 1) {\n                if (param_1 == 0) {\n                    uVar5 = 0xfffffff6;\n                }\n                else if (param_1 == 1) {\n                    uVar5 = 0xfffffff5;\n                }\n                else {\n                    if (param_1 != 2) goto code_r0x0043c21d;\n                    uVar5 = 0xfffffff4;\n                }\n                (*_sym.imp.KERNEL32.dll_SetStdHandle)(uVar5, 0);\n            }\ncode_r0x0043c21d:\n            *(iVar4 + *piVar1) = 0xffffffff;\n            return 0;\n        }\n    }\n    puVar3 = fcn.00434b6a();\n    *puVar3 = 9;\n    puVar3 = fcn.00434b73();\n    *puVar3 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 365
    },
    "0043c461": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.0043c461(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t arg_10h;\n    \n    uVar2 = 0;\n    if (((param_1[3] & 3) == 2) && ((param_1[3] & 0x108U) != 0)) {\n        arg_10h = *param_1 - param_1[2];\n        if (0 < arg_10h) {\n            iVar1 = fcn.0043af82(param_1[4], param_1[2], arg_10h);\n            if (iVar1 == arg_10h) {\n                if (param_1[3] < '\\0') {\n                    param_1[3] = param_1[3] & 0xfffffffd;\n                }\n            }\n            else {\n                param_1[3] = param_1[3] | 0x20;\n                uVar2 = 0xffffffff;\n            }\n        }\n    }\n    param_1[1] = 0;\n    *param_1 = param_1[2];\n    return uVar2;\n}\n",
        "token_count": 260
    },
    "0043c5ca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpBuffer\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t __cdecl fcn.0043c5ca(uint32_t arg_8h, char *arg_ch, char *nNumberOfBytesToRead)\n\n{\n    int32_t *piVar1;\n    uint8_t *puVar2;\n    uint8_t uVar3;\n    char cVar4;\n    char *pcVar5;\n    int32_t iVar6;\n    uint *puVar7;\n    char *pcVar8;\n    int32_t iVar9;\n    int32_t lpNumberOfBytesRead;\n    char *var_8h;\n    uint lpBuffer;\n    \n    var_8h = NULL;\n    if (nNumberOfBytesToRead != NULL) {\n        piVar1 = (arg_8h >> 5) * 4 + 0x460640;\n        iVar9 = (arg_8h & 0x1f) * 0x24;\n        uVar3 = *(*piVar1 + iVar9 + 4);\n        if ((uVar3 & 2) == 0) {\n            pcVar8 = arg_ch;\n            if (((uVar3 & 0x48) != 0) && (*(*piVar1 + iVar9 + 5) != '\\n')) {\n                nNumberOfBytesToRead = nNumberOfBytesToRead + -1;\n                *arg_ch = *(*piVar1 + 5 + iVar9);\n                pcVar8 = arg_ch + 1;\n                var_8h = 0x1;\n                *(*piVar1 + 5 + iVar9) = 10;\n            }\n            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                              (*(*piVar1 + iVar9), pcVar8, nNumberOfBytesToRead, &lpNumberOfBytesRead, 0);\n            if (iVar6 == 0) {\n                iVar9 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                if (iVar9 == 5) {\n                    puVar7 = fcn.00434b6a();\n                    *puVar7 = 9;\n                    puVar7 = fcn.00434b73();\n                    *puVar7 = 5;\n                }\n                else {\n                    if (iVar9 == 0x6d) {\n                        return 0;\n                    }\n                    fcn.00434b7c(iVar9);\n                }\n                return -1;\n            }\n            if ((*(*piVar1 + 4 + iVar9) & 0x80) == 0) {\n                return var_8h + lpNumberOfBytesRead;\n            }\n            if ((lpNumberOfBytesRead == 0) || (*arg_ch != '\\n')) {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 & 0xfb;\n            }\n            else {\n                puVar2 = *piVar1 + 4 + iVar9;\n                *puVar2 = *puVar2 | 4;\n            }\n            var_8h = arg_ch + var_8h + lpNumberOfBytesRead;\n            nNumberOfBytesToRead = arg_ch;\n            pcVar8 = arg_ch;\n            if (arg_ch < var_8h) {\n                do {\n                    cVar4 = *nNumberOfBytesToRead;\n                    if (cVar4 == '\\x1a') {\n                        if ((*(*piVar1 + 4 + iVar9) & 0x40) == 0) {\n                            puVar2 = *piVar1 + 4 + iVar9;\n                            *puVar2 = *puVar2 | 2;\n                        }\n                        break;\n                    }\n                    if (cVar4 == '\\r') {\n                        if (nNumberOfBytesToRead < var_8h + -1) {\n                            if (nNumberOfBytesToRead[1] == '\\n') {\n                                pcVar5 = nNumberOfBytesToRead + 2;\n                                goto code_r0x0043c757;\n                            }\ncode_r0x0043c771:\n                            nNumberOfBytesToRead = nNumberOfBytesToRead + 1;\n                            *pcVar8 = '\\r';\n                        }\n                        else {\n                            pcVar5 = nNumberOfBytesToRead + 1;\n                            iVar6 = (*_sym.imp.KERNEL32.dll_ReadFile)\n                                              (*(*piVar1 + iVar9), &lpBuffer, 1, &lpNumberOfBytesRead, 0);\n                            if (((iVar6 == 0) && (iVar6 = (*_sym.imp.KERNEL32.dll_GetLastError)(),  iVar6 != 0)) ||\n                               (lpNumberOfBytesRead == 0)) goto code_r0x0043c771;\n                            if ((*(*piVar1 + 4 + iVar9) & 0x48) == 0) {\n                                if ((pcVar8 == arg_ch) && (lpBuffer == '\\n')) goto code_r0x0043c757;\n                                fcn.0043ac95(arg_8h, 0xffffffff, 1);\n                                if (lpBuffer == '\\n') goto code_r0x0043c775;\n                                goto code_r0x0043c771;\n                            }\n                            if (lpBuffer == '\\n') {\ncode_r0x0043c757:\n                                nNumberOfBytesToRead = pcVar5;\n                                *pcVar8 = '\\n';\n                            }\n                            else {\n                                *pcVar8 = '\\r';\n                                *(*piVar1 + 5 + iVar9) = lpBuffer;\n                                nNumberOfBytesToRead = pcVar5;\n                            }\n                        }\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead;\n                    }\n                    else {\n                        *pcVar8 = cVar4;\n                        pcVar8 = pcVar8 + 1;\n                        pcVar5 = nNumberOfBytesToRead + 1;\n                    }\ncode_r0x0043c775:\n                    nNumberOfBytesToRead = pcVar5;\n                } while (nNumberOfBytesToRead < var_8h);\n            }\n            return pcVar8 - arg_ch;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 1329
    },
    "0043ca08": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0043ccde)\n// WARNING: Removing unreachable block (ram,0x0043cc58)\n// WARNING: Removing unreachable block (ram,0x0043cdba)\n// WARNING: Removing unreachable block (ram,0x0043cc6a)\n// WARNING: Removing unreachable block (ram,0x0043cc72)\n// WARNING: Removing unreachable block (ram,0x0043cc78)\n// WARNING: Removing unreachable block (ram,0x0043cc7b)\n// WARNING: Removing unreachable block (ram,0x0043cc82)\n// WARNING: Removing unreachable block (ram,0x0043cc8c)\n// WARNING: Removing unreachable block (ram,0x0043cd56)\n// WARNING: Removing unreachable block (ram,0x0043cd50)\n// WARNING: Removing unreachable block (ram,0x0043cd5c)\n// WARNING: Removing unreachable block (ram,0x0043cd79)\n// WARNING: Removing unreachable block (ram,0x0043cd7b)\n// WARNING: Removing unreachable block (ram,0x0043cd83)\n// WARNING: Removing unreachable block (ram,0x0043cd86)\n// WARNING: Removing unreachable block (ram,0x0043cd8b)\n// WARNING: Removing unreachable block (ram,0x0043cd8e)\n// WARNING: Removing unreachable block (ram,0x0043cdc3)\n// WARNING: Removing unreachable block (ram,0x0043cd95)\n// WARNING: Removing unreachable block (ram,0x0043cd9c)\n// WARNING: Removing unreachable block (ram,0x0043cdda)\n// WARNING: Removing unreachable block (ram,0x0043cde1)\n// WARNING: Removing unreachable block (ram,0x0043cde9)\n\nvoid __cdecl\nfcn.0043ca08(uint arg_8h, uint arg_ch, char *arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    char cVar1;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_19h;\n    uint var_14h;\n    uint var_eh;\n    uint var_ah;\n    uint var_4h;\n    \n    for (; (((cVar1 = *arg_10h,  cVar1 == ' ' || (cVar1 == '\\t')) || (cVar1 == '\\n')) || (cVar1 == '\\r'));\n        arg_10h = arg_10h + 1) {\n    }\n    // WARNING: Could not recover jumptable at 0x0043ca6b. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (12 cases) at 0x43ce0c\n    (**0x43ce0c)();\n    return;\n}\n",
        "token_count": 701
    },
    "0043ce3c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl\nfcn.0043ce3c(int32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, int32_t arg_14h, uint32_t arg_18h, int16_t *arg_1ch)\n\n{\n    int16_t *piVar1;\n    char cVar2;\n    uint32_t uVar3;\n    int16_t *piVar4;\n    int16_t *piVar5;\n    int16_t iVar6;\n    int32_t iVar7;\n    char *pcVar8;\n    int16_t *var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint uStack40;\n    uint uStack36;\n    uint var_1ch;\n    uchar var_18h;\n    uchar var_17h;\n    uchar var_16h;\n    uchar var_15h;\n    uchar var_14h;\n    uchar var_13h;\n    uchar var_12h;\n    uchar var_11h;\n    ushort var_10h;\n    uint var_eh;\n    uint32_t var_ah;\n    uchar var_6h;\n    char var_5h;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    uVar3 = arg_10h & 0x7fff;\n    var_1ch._0_1_ = 0xcc;\n    var_1ch._1_1_ = 0xcc;\n    var_1ch._2_1_ = 0xcc;\n    var_1ch._3_1_ = 0xcc;\n    var_18h = 0xcc;\n    var_17h = 0xcc;\n    var_16h = 0xcc;\n    var_15h = 0xcc;\n    var_14h = 0xcc;\n    var_13h = 0xcc;\n    var_12h = 0xfb;\n    var_11h = 0x3f;\n    if ((arg_10h & 0x8000) == 0) {\n        *(arg_1ch + 1) = 0x20;\n    }\n    else {\n        *(arg_1ch + 1) = 0x2d;\n    }\n    if (((uVar3 == 0) && (arg_ch == 0)) && (arg_8h == 0)) {\ncode_r0x0043cfb2:\n        *(arg_1ch + 2) = 0x30;\ncode_r0x0043d0b5:\n        *arg_1ch = 0;\n        *(arg_1ch + 1) = 0x20;\n        *(arg_1ch + 3) = 1;\n        *(arg_1ch + 5) = 0;\n    }\n    else {\n        if (uVar3 == 0x7fff) {\n            *arg_1ch = 1;\n            if (((arg_ch == 0x80000000) && (arg_8h == 0)) || ((arg_ch & 0x40000000) != 0)) {\n                if (((arg_10h & 0x8000) == 0) || (arg_ch != 0xc0000000)) {\n                    if ((arg_ch != 0x80000000) || (arg_8h != 0)) goto code_r0x0043cf28;\n                    pcVar8 = \"1#INF\";\n                }\n                else {\n                    if (arg_8h != 0) {\ncode_r0x0043cf28:\n                        pcVar8 = \"1#QNAN\";\n                        goto code_r0x0043cf2d;\n                    }\n                    pcVar8 = \"1#IND\";\n                }\n                fcn.004366a0(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 5;\n            }\n            else {\n                pcVar8 = \"1#SNAN\";\ncode_r0x0043cf2d:\n                fcn.004366a0(arg_1ch + 2, pcVar8);\n                *(arg_1ch + 3) = 6;\n            }\n            goto code_r0x0043d097;\n        }\n        var_10h = 0;\n        iVar6 = ((uVar3 >> 8) + (arg_ch >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar3 * 0x4d10 >> 0x10;\n        var_6h = uVar3;\n        var_5h = uVar3 >> 8;\n        var_eh = arg_8h;\n        var_ah = arg_ch;\n        fcn.0043dadf(&var_10h, -iVar6, 1);\n        if (0x3ffe < CONCAT11(var_5h, var_6h)) {\n            iVar6 = iVar6 + 1;\n            fcn.0043d8ad(&var_10h, &var_1ch);\n        }\n        *arg_1ch = iVar6;\n        if (((arg_18h & 1) != 0) && (arg_14h = arg_14h + iVar6,  arg_14h < 1)) goto code_r0x0043cfb2;\n        if (0x15 < arg_14h) {\n            arg_14h = 0x15;\n        }\n        iVar7 = CONCAT11(var_5h, var_6h) - 0x3ffe;\n        var_6h = 0;\n        var_5h = '\\0';\n        arg_10h = 8;\n        do {\n            fcn.0043c8cf(&var_10h);\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != 0);\n        if (iVar7 < 0) {\n            for (uVar3 = -iVar7 & 0xff; uVar3 != 0; uVar3 = uVar3 - 1) {\n                fcn.0043c8fd(&var_10h);\n            }\n        }\n        arg_10h = arg_14h + 1;\n        piVar4 = arg_1ch + 2;\n        var_30h = piVar4;\n        if (0 < arg_10h) {\n            do {\n                var_ah._2_2_ = var_ah >> 0x10;\n                var_eh._2_2_ = var_eh >> 0x10;\n                var_28h = CONCAT22(var_eh, var_10h);\n                uStack40 = CONCAT22(var_ah, var_eh._2_2_);\n                uStack36 = CONCAT13(var_5h, CONCAT12(var_6h, var_ah._2_2_));\n                fcn.0043c8cf(&var_10h);\n                fcn.0043c8cf(&var_10h);\n                fcn.0043c871(&var_10h, &var_28h);\n                fcn.0043c8cf(&var_10h);\n                piVar4 = var_30h + 1;\n                arg_10h = arg_10h + -1;\n                *var_30h = var_5h + '0';\n                var_5h = '\\0';\n                var_30h = piVar4;\n            } while (arg_10h != 0);\n        }\n        piVar5 = piVar4 + -1;\n        piVar1 = arg_1ch + 2;\n        if (*(piVar4 + -1) < '5') {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '0')); piVar5 = piVar5 + -1) {\n            }\n            if (piVar5 < piVar1) {\n                *piVar1 = 0x30;\n                goto code_r0x0043d0b5;\n            }\n        }\n        else {\n            for (; (piVar1 <= piVar5 && (*piVar5 == '9')); piVar5 = piVar5 + -1) {\n                *piVar5 = 0x30;\n            }\n            if (piVar5 < piVar1) {\n                piVar5 = piVar5 + 1;\n                *arg_1ch = *arg_1ch + 1;\n            }\n            *piVar5 = *piVar5 + '\\x01';\n        }\n        cVar2 = (piVar5 - arg_1ch) + -3;\n        *(arg_1ch + 3) = cVar2;\n        *(cVar2 + 4 + arg_1ch) = 0;\n    }\ncode_r0x0043d097:\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1955
    },
    "0043d131": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0043d131(int32_t param_1)\n\n{\n    char *in_EAX;\n    int32_t iVar1;\n    \n    iVar1 = param_1;\n    if (param_1 != 0) {\n        do {\n            iVar1 = iVar1 + -1;\n            if (*in_EAX == '\\0') goto code_r0x0043d145;\n            in_EAX = in_EAX + 1;\n        } while (iVar1 != 0);\n    }\n    iVar1 = iVar1 + -1;\ncode_r0x0043d145:\n    return (param_1 - iVar1) + -1;\n}\n",
        "token_count": 144
    },
    "0043d14d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_44h_2\n// WARNING: Variable defined which should be unmapped: var_40h_3\n// WARNING: Variable defined which should be unmapped: var_3ch_3\n// WARNING: Variable defined which should be unmapped: var_4ch\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_5ch\n\nvoid __cdecl\nfcn.0043d14d(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint noname_18, uint noname_19, \n            uint noname_20, uint noname_21, uint arg_8h, uint arg_ch, uint lpMultiByteStr, uint cbMultiByte, \n            uint lpString2, uint cchCount2, uint CodePage)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint8_t *puVar4;\n    uint *arg_8h_00;\n    int32_t iVar5;\n    int32_t unaff_EBP;\n    int32_t iVar6;\n    uint Locale;\n    uint dwCmpFlags;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint lpCPInfo;\n    uint var_4h_2;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_1ch_2;\n    uint var_20h;\n    uint var_4h;\n    uint var_50h;\n    uint var_44h_2;\n    uint var_40h_3;\n    uint var_3ch_3;\n    uint lpString1;\n    uint var_30h_2;\n    uchar auStack48 [2];\n    uint var_2ah;\n    int32_t var_4ch;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_5ch;\n    uint uVar7;\n    \n    uVar7 = 0x40;\n    fcn.00434920();\n    *(unaff_EBP + -0x1c) = *0x45c1a8;\n    iVar6 = 0;\n    if (*0x45f5bc == 0) {\n        var_4ch = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_CompareStringW)();\n        if (iVar2 == 0) {\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 == 0x78) {\n                *0x45f5bc = 2;\n            }\n        }\n        else {\n            *0x45f5bc = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        uVar3 = fcn.0043d131();\n        *(unaff_EBP + 0x14) = uVar3;\n    }\n    iVar2 = *(unaff_EBP + 0x1c);\n    if (0 < iVar2) {\n        iVar2 = fcn.0043d131();\n        *(unaff_EBP + 0x1c) = iVar2;\n    }\n    if ((*0x45f5bc == 2) || (*0x45f5bc == 0)) {\n        *(unaff_EBP + -0x38) = 0;\n        if (*(unaff_EBP + 8) == 0) {\n            *(unaff_EBP + 8) = *0x45f50c;\n        }\n        iVar2 = *(unaff_EBP + 0x20);\n        if (*(unaff_EBP + 0x20) == 0) {\n            iVar2 = *0x45f51c;\n        }\n        iVar5 = fcn.0043b59a(*(unaff_EBP + 8));\n        if (iVar5 == -1) goto code_r0x0043d4c0;\n        if (iVar5 != iVar2) {\n            var_4ch = iVar2;\n            iVar6 = fcn.0043b5dd(iVar2, iVar5, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x453bf8, uVar7);\n            if (iVar6 == 0) goto code_r0x0043d4c0;\n            var_4ch = iVar2;\n            iVar2 = fcn.0043b5dd(iVar2, iVar5, *(unaff_EBP + 0x18), unaff_EBP + 0x1c, 0, 0, 0x453bf8, uVar7);\n            *(unaff_EBP + -0x38) = iVar2;\n            if (iVar2 == 0) {\n                fcn.0043360e(iVar6);\n                goto code_r0x0043d4c0;\n            }\n            *(unaff_EBP + 0x10) = iVar6;\n            *(unaff_EBP + 0x18) = *(unaff_EBP + -0x38);\n        }\n        var_4ch = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_CompareStringA)();\n        if (iVar6 != 0) {\n            fcn.0043360e(iVar6);\n            stack0xffffffd4 = 0x43d4bc;\n            fcn.0043360e(*(unaff_EBP + -0x38));\n        }\n        goto code_r0x0043d4c0;\n    }\n    if (*0x45f5bc != 1) goto code_r0x0043d4c0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    *(unaff_EBP + -0x40) = 0;\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x45f51c;\n    }\n    if ((*(unaff_EBP + 0x14) == 0) || (iVar2 == 0)) {\n        if ((*(unaff_EBP + 0x14) == iVar2) ||\n           (((1 < iVar2 || (1 < *(unaff_EBP + 0x14))) || (iVar6 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(),  iVar6 == 0))))\n        goto code_r0x0043d4c0;\n        if (0 < *(unaff_EBP + 0x14)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x10) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x10)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x0043d4c0;\n        }\n        if (0 < *(unaff_EBP + 0x1c)) {\n            if (1 < *(unaff_EBP + -0x30)) {\n                puVar4 = unaff_EBP + -0x2a;\n                uVar1 = *(unaff_EBP + -0x2a);\n                while (((uVar1 != 0 && (puVar4[1] != 0)) &&\n                       ((**(unaff_EBP + 0x18) < *puVar4 || (puVar4[1] < **(unaff_EBP + 0x18)))))) {\n                    puVar4 = puVar4 + 2;\n                    uVar1 = *puVar4;\n                }\n            }\n            goto code_r0x0043d4c0;\n        }\n    }\n    var_4ch = *(unaff_EBP + 0x20);\n    iVar6 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    *(unaff_EBP + -0x48) = iVar6;\n    if (iVar6 == 0) goto code_r0x0043d4c0;\n    *(unaff_EBP + -4) = 0;\n    fcn.004316c0();\n    *(unaff_EBP + -0x18) = &fcn.0043d14d::var_4ch;\n    *(unaff_EBP + -0x34) = &fcn.0043d14d::var_4ch;\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + -0x34) == 0) {\n        iVar2 = fcn.004335fc();\n        *(unaff_EBP + -0x34) = iVar2;\n        if (iVar2 == 0) goto code_r0x0043d4c0;\n        *(unaff_EBP + -0x3c) = 1;\n    }\n    unique0x00007a00 = *(unaff_EBP + 0x14);\n    _auStack48 = *(unaff_EBP + 0x10);\n    var_30h_2 = 1;\n    lpString1 = *(unaff_EBP + 0x20);\n    iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n    if (iVar2 != 0) {\n        arg_8h_00 = &fcn.0043d14d::lpString1;\n        iVar2 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 0x20), 9, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), 0, 0);\n        *(unaff_EBP + -0x4c) = iVar2;\n        if (iVar2 != 0) {\n            *(unaff_EBP + -4) = 1;\n            fcn.004316c0();\n            *(unaff_EBP + -0x18) = &fcn.0043d14d::lpString1;\n            *(unaff_EBP + -0x50) = &fcn.0043d14d::lpString1;\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x38) {\n                arg_8h_00 = fcn.004335fc(iVar2 * 2);\n                if (arg_8h_00 == NULL) goto code_r0x0043d3fb;\n                *(unaff_EBP + -0x44) = 1;\n            }\n            iVar5 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x20), 1, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c), arg_8h_00, iVar2);\n            if (iVar5 != 0) {\n                uVar7 = (*_sym.imp.KERNEL32.dll_CompareStringW)\n                                  (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x34), iVar6, arg_8h_00, iVar2);\n                *(unaff_EBP + -0x40) = uVar7;\n            }\n            if (*(unaff_EBP + -0x44) != 0) {\n                fcn.0043360e(arg_8h_00);\n            }\n        }\n    }\ncode_r0x0043d3fb:\n    if (*(unaff_EBP + -0x3c) != 0) {\n        fcn.0043360e(*(unaff_EBP + -0x34));\n    }\ncode_r0x0043d4c0:\n    *(unaff_EBP + -0x60) = 0x43d4cb;\n    fcn.004316b0();\n    *(unaff_EBP + -0x60) = 0x43d4d0;\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 2906
    },
    "0043d51e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * fcn.0043d51e(void)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    int32_t *unaff_EDI;\n    uint var_4h;\n    \n    iVar3 = 0;\n    if (unaff_EDI != NULL) {\n        iVar1 = *unaff_EDI;\n        piVar2 = unaff_EDI;\n        while (iVar1 != 0) {\n            piVar2 = piVar2 + 1;\n            iVar3 = iVar3 + 1;\n            iVar1 = *piVar2;\n        }\n        piVar2 = fcn.004335fc(iVar3 * 4 + 4);\n        if (piVar2 == NULL) {\n            fcn.0043367f(9);\n        }\n        iVar3 = *unaff_EDI;\n        piVar4 = piVar2;\n        while (iVar3 != 0) {\n            iVar3 = fcn.00433b70(iVar3);\n            *piVar4 = iVar3;\n            piVar4 = piVar4 + 1;\n            unaff_EDI = unaff_EDI + 1;\n            iVar3 = *unaff_EDI;\n        }\n        *piVar4 = 0;\n        return piVar2;\n    }\n    return unaff_EDI;\n}\n",
        "token_count": 307
    },
    "0043d7f1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043d7f1(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x453c20, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x460630) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x460640;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0043c281(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\ncode_r0x0043d871:\n                puVar3 = fcn.00434b6a();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0043c240(arg_8h_00);\n                iVar4 = (*_sym.imp.KERNEL32.dll_FlushFileBuffers)(uVar2);\n                if (iVar4 == 0) {\n                    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    *(unaff_EBP + -0x1c) = uVar2;\n                }\n                else {\n                    *(unaff_EBP + -0x1c) = 0;\n                }\n                if (*(unaff_EBP + -0x1c) != 0) {\n                    puVar3 = fcn.00434b73();\n                    *puVar3 = *(unaff_EBP + -0x1c);\n                    goto code_r0x0043d871;\n                }\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043d891();\n            goto code_r0x0043d8a7;\n        }\n    }\n    puVar3 = fcn.00434b6a();\n    *puVar3 = 9;\ncode_r0x0043d8a7:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 593
    },
    "0043d8ad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.0043d8ad(int32_t *arg_8h, int32_t *arg_ch)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    int32_t *piVar3;\n    uint16_t uVar4;\n    int32_t iVar5;\n    uint16_t uVar6;\n    uint32_t uVar7;\n    uint16_t uVar8;\n    int32_t var_28h;\n    uint16_t *var_24h;\n    int32_t *var_20h;\n    int32_t var_1ch;\n    int32_t var_18h;\n    uint *var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    piVar3 = arg_ch;\n    var_4h = *0x45c1a8;\n    var_1ch = 0;\n    var_10h._0_1_ = 0;\n    var_10h._1_1_ = 0;\n    var_10h._2_2_ = 0;\n    var_ch._0_2_ = 0;\n    var_ch._2_2_ = 0;\n    var_8h._0_2_ = 0;\n    var_8h._2_1_ = 0;\n    var_8h._3_1_ = 0;\n    uVar6 = *(arg_ch + 10) & 0x7fff;\n    uVar4 = *(arg_8h + 10) & 0x7fff;\n    uVar8 = (*(arg_ch + 10) ^ *(arg_8h + 10)) & 0x8000;\n    uVar2 = uVar6 + uVar4;\n    if (((uVar4 < 0x7fff) && (uVar6 < 0x7fff)) && (uVar2 < 0xbffe)) {\n        if (uVar2 < 0x3fc0) {\ncode_r0x0043d95a:\n            arg_8h[2] = 0;\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            goto code_r0x0043dad2;\n        }\n        if (uVar4 == 0) {\n            uVar2 = uVar2 + 1;\n            arg_8h._0_2_ = 0;\n            if ((((arg_8h[2] & 0x7fffffffU) != 0) || (arg_8h[1] != 0)) || (*arg_8h != 0)) goto code_r0x0043d944;\n        }\n        else {\ncode_r0x0043d944:\n            if (((uVar6 == 0) && (uVar2 = uVar2 + 1,  (arg_ch[2] & 0x7fffffffU) == 0)) &&\n               ((arg_ch[1] == 0 && (*arg_ch == 0)))) goto code_r0x0043d95a;\n            var_18h = 0;\n            var_14h = &var_ch;\n            arg_ch = 0x5;\n            do {\n                if (0 < arg_ch) {\n                    var_24h = var_18h * 2 + arg_8h;\n                    var_20h = piVar3 + 2;\n                    var_28h = arg_ch;\n                    do {\n                        iVar5 = fcn.0043c850(var_14h[-1], *var_20h * *var_24h, var_14h + -1);\n                        if (iVar5 != 0) {\n                            *var_14h = *var_14h + 1;\n                        }\n                        var_24h = var_24h + 1;\n                        var_20h = var_20h + -2;\n                        var_28h = var_28h + -1;\n                    } while (var_28h != 0);\n                }\n                var_14h = var_14h + 2;\n                var_18h = var_18h + 1;\n                arg_ch = arg_ch + -1;\n            } while (0 < arg_ch);\n            arg_8h._0_2_ = uVar2 + 0xc002;\n            if (arg_8h < 1) {\ncode_r0x0043da0e:\n                arg_8h._0_2_ = arg_8h - 1;\n                if (arg_8h < 0) {\n                    uVar7 = -arg_8h;\n                    arg_8h._0_2_ = 0;\n                    do {\n                        if ((var_10h & 1) != 0) {\n                            var_1ch = var_1ch + 1;\n                        }\n                        fcn.0043c8fd(&var_10h);\n                        uVar7 = uVar7 - 1;\n                    } while (uVar7 != 0);\n                    if (var_1ch != 0) {\n                        var_10h._0_1_ = var_10h | 1;\n                    }\n                }\n            }\n            else {\n                do {\n                    if ((var_8h._3_1_ & 0x80) != 0) break;\n                    fcn.0043c8cf(&var_10h);\n                    arg_8h._0_2_ = arg_8h - 1;\n                } while (0 < arg_8h);\n                if (arg_8h < 1) goto code_r0x0043da0e;\n            }\n            if ((0x8000 < CONCAT11(var_10h._1_1_, var_10h)) ||\n               ((CONCAT22(var_10h._2_2_, CONCAT11(var_10h._1_1_, var_10h)) & 0x1ffff) == 0x18000)) {\n                if (CONCAT22(var_ch, var_10h._2_2_) == -1) {\n                    var_10h._2_2_ = 0;\n                    var_ch._0_2_ = 0;\n                    if (CONCAT22(var_8h, var_ch._2_2_) == -1) {\n                        var_ch._2_2_ = 0;\n                        var_8h._0_2_ = 0;\n                        if (CONCAT11(var_8h._3_1_, var_8h._2_1_) == -1) {\n                            arg_8h._0_2_ = arg_8h + 1;\n                            var_8h._2_1_ = 0;\n                            var_8h._3_1_ = 0x80;\n                        }\n                        else {\n                            iVar1 = CONCAT11(var_8h._3_1_, var_8h._2_1_) + 1;\n                            var_8h._2_1_ = iVar1;\n                            var_8h._3_1_ = iVar1 >> 8;\n                        }\n                    }\n                    else {\n                        iVar5 = CONCAT22(var_8h, var_ch._2_2_) + 1;\n                        var_ch._2_2_ = iVar5;\n                        var_8h._0_2_ = iVar5 >> 0x10;\n                    }\n                }\n                else {\n                    iVar5 = CONCAT22(var_ch, var_10h._2_2_) + 1;\n                    var_10h._2_2_ = iVar5;\n                    var_ch._0_2_ = iVar5 >> 0x10;\n                }\n            }\n            if (0x7ffe < arg_8h) goto code_r0x0043dab7;\n            *arg_8h = var_10h._2_2_;\n            *(arg_8h + 2) = CONCAT22(var_ch._2_2_, var_ch);\n            *(arg_8h + 6) = CONCAT13(var_8h._3_1_, CONCAT12(var_8h._2_1_, var_8h));\n            arg_8h._0_2_ = arg_8h | uVar8;\n        }\n        *(arg_8h + 10) = arg_8h;\n    }\n    else {\ncode_r0x0043dab7:\n        arg_8h[1] = 0;\n        *arg_8h = 0;\n        arg_8h[2] = (-(uVar8 != 0) & 0x80000000) + 0x7fff8000;\n    }\ncode_r0x0043dad2:\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1922
    },
    "0043e139": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0043e139(int32_t param_1)\n\n{\n    bool bVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(*(param_1 + 0x70) + 0x1c));\n    bVar1 = false;\n    fcn.00433ba0(*(*(param_1 + 0x70) + 0x1c) + iVar3 + 1, 0, *(*(param_1 + 0x70) + 0x20) - (iVar3 + 1));\n    (*_sym.imp.USER32.dll_GetFocus)();\n    iVar3 = *(param_1 + 0x70);\n    uVar4 = fcn.00440469();\n    *(iVar3 + 4) = uVar4;\n    fcn.00442131();\n    pcVar2 = _sym.imp.USER32.dll_EnableWindow;\n    if (*(*(param_1 + 0x70) + 4) != 0) {\n        iVar3 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(*(param_1 + 0x70) + 4));\n        if (iVar3 != 0) {\n            bVar1 = true;\n            (*pcVar2)(*(*(param_1 + 0x70) + 4), 0);\n        }\n    }\n    iVar3 = fcn.004499d7();\n    if ((*(*(param_1 + 0x70) + 0x36) & 8) == 0) {\n        fcn.004433c1(param_1);\n    }\n    else {\n        *(iVar3 + 0x18) = param_1;\n    }\n    if (*(param_1 + 0x74) == 0) {\n        (*_sym.imp.comdlg32.dll_GetSaveFileNameA)(*(param_1 + 0x70));\n    }\n    else {\n        (*_sym.imp.comdlg32.dll_GetOpenFileNameA)();\n    }\n    *(iVar3 + 0x18) = 0;\n    if (bVar1) {\n        (*pcVar2)(*(*(param_1 + 0x70) + 4), 1);\n    }\n    iVar3 = (*_sym.imp.USER32.dll_IsWindow)(unaff_EBP);\n    if (iVar3 != 0) {\n        (*_sym.imp.USER32.dll_SetFocus)(unaff_ESI);\n    }\n    fcn.004404a3();\n    if (unaff_EBP == 0) {\n        unaff_EBP = 2;\n    }\n    return unaff_EBP;\n}\n",
        "token_count": 602
    },
    "004401f5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004401f5(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CDialog.0;\n    *(unaff_EBP + -4) = 0;\n    if (extraout_ECX[7] != NULL) {\n        fcn.004422df();\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.00442786();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 193
    },
    "0043e367": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_a8h\n// WARNING: Variable defined which should be unmapped: var_a0h\n// WARNING: Variable defined which should be unmapped: lpVersionInformation\n\nvoid __cdecl\nfcn.0043e367(uint arg_8h, uint arg_ch, uint lpString2, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    code **ppcVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    code *pcVar5;\n    int32_t iVar6;\n    uchar *puVar7;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_a8h;\n    uint lpVersionInformation;\n    uint var_a0h;\n    uint var_94h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = *0x45c1a8;\n    *(unaff_EBP + -0xa8) = extraout_ECX;\n    fcn.0044029c(0, *(unaff_EBP + 0x1c));\n    *(unaff_EBP + -4) = 0;\n    *extraout_ECX = vtable.CFileDialog.0;\n    fcn.00426fe0();\n    *(unaff_EBP + -4) = 1;\n    if (*(unaff_EBP + 0x20) == 0) {\n        fcn.00433ba0(unaff_EBP + -0xa4, 0, 0x94);\n        *(unaff_EBP + -0xa4) = 0x94;\n        (*_sym.imp.KERNEL32.dll_GetVersionExA)(unaff_EBP + -0xa4);\n        if ((*(unaff_EBP + -0x94) != 2) || (*(unaff_EBP + 0x20) = 0x58,  *(unaff_EBP + -0xa0) < 5)) {\n            *(unaff_EBP + 0x20) = 0x4c;\n        }\n    }\n    pcVar5 = fcn.004335fc(*(unaff_EBP + 0x20));\n    extraout_ECX[0x1c] = pcVar5;\n    if (pcVar5 == NULL) {\n        pcVar5 = fcn.0043e0e7();\n    }\n    fcn.00433ba0(pcVar5, 0, *(unaff_EBP + 0x20));\n    pcVar5 = *(unaff_EBP + 8);\n    uVar2 = *(unaff_EBP + 0x20);\n    extraout_ECX[0x1d] = pcVar5;\n    extraout_ECX[0x14] = 0x7005 - (pcVar5 != NULL);\n    extraout_ECX[0x70] = NULL;\n    *(extraout_ECX + 0x1f) = 0;\n    ppcVar1 = extraout_ECX + 0x2f;\n    *ppcVar1 = 0;\n    *extraout_ECX[0x1c] = uVar2;\n    uVar2 = *(unaff_EBP + 0xc);\n    *(extraout_ECX[0x1c] + 0x1c) = ppcVar1;\n    *(extraout_ECX[0x1c] + 0x20) = 0x104;\n    *(extraout_ECX[0x1c] + 0x3c) = uVar2;\n    uVar3 = *(unaff_EBP + 0x14);\n    *(extraout_ECX[0x1c] + 0x24) = extraout_ECX + 0x1f;\n    *(extraout_ECX[0x1c] + 0x28) = 0x40;\n    *(extraout_ECX[0x1c] + 0x34) = *(extraout_ECX[0x1c] + 0x34) | uVar3 | 0x80020;\n    if ((*(unaff_EBP + 0x14) & 0x40) != 0) {\n        extraout_ECX[0x1c][0x36] = extraout_ECX[0x1c][0x36] & 0x7f;\n    }\n    iVar6 = fcn.004499e7();\n    iVar4 = *(unaff_EBP + 0x10);\n    *(extraout_ECX[0x1c] + 8) = *(iVar6 + 0xc);\n    *(extraout_ECX[0x1c] + 0x44) = fcn.0043e713;\n    if (iVar4 != 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(ppcVar1, *(unaff_EBP + 0x10), 0x104);\n    }\n    if (*(unaff_EBP + 0x18) != 0) {\n        fcn.00427580(*(unaff_EBP + 0x18));\n        puVar7 = fcn.004274a0(0);\n        while( true ) {\n            puVar7 = fcn.00434071(puVar7, 0x7c);\n            if (puVar7 == NULL) break;\n            *puVar7 = 0;\n            puVar7 = puVar7 + 1;\n        }\n        *(extraout_ECX[0x1c] + 0xc) = extraout_ECX[0x1e];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1306
    },
    "0043e507": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_14h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.0043e507(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    code *pcVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    uint uVar6;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    uVar1 = *(*(extraout_ECX + 0x70) + 0x36);\n    *(unaff_EBP + -0x14) = 0;\n    if (((uVar1 & 8) != 0) && (*(extraout_ECX + 0x1c) != 0)) {\n        piVar3 = fcn.00444854();\n        iVar4 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar4 + 0x10;\n        pcVar2 = _sym.imp.USER32.dll_GetParent;\n        uVar6 = *(extraout_ECX + 0x1c);\n        *(unaff_EBP + -4) = 0;\n        uVar5 = (*pcVar2)(uVar6);\n        uVar5 = fcn.00442089(uVar5);\n        *(unaff_EBP + -0x14) = uVar5;\n        uVar5 = fcn.004274a0(0x104);\n        iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(*(unaff_EBP + -0x14) + 0x1c), 0x464, 0x104, uVar5);\n        if (iVar4 < 0) {\n            fcn.00427650();\n        }\n        else {\n            fcn.00427fef(uVar6, 0xffffffff);\n        }\n        if (*(*(unaff_EBP + -0x10) + -0xc) != 0) {\n            uVar6 = (*pcVar2)(*(extraout_ECX + 0x1c));\n            iVar4 = fcn.00442089(uVar6);\n            uVar6 = fcn.004274a0(0x104);\n            iVar4 = (*_sym.imp.USER32.dll_SendMessageA)(*(iVar4 + 0x1c), 0x465, 0x104, uVar6);\n            if (-1 < iVar4) {\n                fcn.00427fef(0xffffffff);\n                fcn.00427370(unaff_EBP + -0x10);\n                fcn.00421110();\n                goto code_r0x0043e5ea;\n            }\n            fcn.00427650();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.00421110();\n    }\n    fcn.00427020(*(*(extraout_ECX + 0x70) + 0x1c));\ncode_r0x0043e5ea:\n    uVar6 = *(unaff_EBP + 8);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar6;\n}\n",
        "token_count": 764
    },
    "0043ea03": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0043ea03(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    iVar1 = fcn.00449a0d();\n    if ((*(iVar1 + 0x24) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0043f70c(0x446a14);\n        iVar3 = fcn.0043f71e(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0044514f(0x4501b0, 0x448dbb, 0x4495bf, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x24) = uVar4;\n        fcn.0043f70c(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x24);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 367
    },
    "004451d3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n\nint32_t __cdecl\nfcn.004451d3(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_8h)\n\n{\n    int32_t arg_8h_00;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t extraout_ECX;\n    int32_t *piVar3;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    arg_8h_00 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &stack0xffffffec;\n    if (arg_8h_00 == 0) {\n        iVar1 = 0;\n    }\n    else {\n        iVar1 = fcn.0043f2e2(arg_8h_00);\n        if (iVar1 == 0) {\n            iVar1 = fcn.0043f2e2(arg_8h_00);\n            if (iVar1 == 0) {\n                uVar2 = fcn.0043f70c(0x446a14);\n                *(unaff_EBP + -4) = 0;\n                *(unaff_EBP + 8) = uVar2;\n                iVar1 = fcn.00431602();\n                if (iVar1 == 0) {\n                    fcn.0043e0e7();\n                }\n                (**(extraout_ECX + 0x14))(iVar1);\n                piVar3 = fcn.0043f45a(arg_8h_00);\n                uVar2 = *(unaff_EBP + 8);\n                *(unaff_EBP + -4) = 0xffffffff;\n                *piVar3 = iVar1;\n                fcn.0043f70c(uVar2);\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n            else {\n                piVar3 = *(extraout_ECX + 0x58) + iVar1;\n                *piVar3 = arg_8h_00;\n                if (*(extraout_ECX + 0x5c) == 2) {\n                    piVar3[1] = arg_8h_00;\n                }\n            }\n        }\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 619
    },
    "0043eb71": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0043eb71(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CImageList.0;\n    if (param_1[1] == NULL) {\n        return 0;\n    }\n    uVar1 = fcn.0043ea7f();\n    uVar1 = (*_sym.imp.COMCTL32.dll_ImageList_Destroy)(uVar1);\n    return uVar1;\n}\n",
        "token_count": 101
    },
    "0043ef0c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043ef0c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    uint uStack8;\n    \n    if (*(param_1 + 0x10) == 0) {\n        uStack8 = 0xc;\n        iVar1 = fcn.0043f00e(param_1 + 0x14, *(param_1 + 0x18));\n        iVar3 = *(param_1 + 0x18);\n        puVar2 = iVar1 + -8 + iVar3 * 0xc;\n        if (-1 < iVar3 + -1) {\n            do {\n                *puVar2 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar2;\n                puVar2 = puVar2 + -3;\n                iVar3 = iVar3 + -1;\n            } while (iVar3 != 0);\n        }\n    }\n    puVar2 = *(param_1 + 0x10);\n    *(param_1 + 0x10) = *puVar2;\n    puVar2[1] = uStack8;\n    *puVar2 = unaff_ESI;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    puVar2[2] = 0;\n    return;\n}\n",
        "token_count": 321
    },
    "0043f00e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043f00e(uint *param_1, int32_t param_2, int32_t param_3)\n\n{\n    code *pcVar1;\n    uint *puVar2;\n    \n    if ((param_2 != 0) && (param_3 != 0)) {\n        puVar2 = fcn.0043f71e(param_2 * param_3 + 4);\n        *puVar2 = *param_1;\n        *param_1 = puVar2;\n        return;\n    }\n    fcn.0043e11b();\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 146
    },
    "0043f21a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043f21a(int32_t param_1, int32_t param_2, int32_t param_3)\n\n{\n    uint uVar1;\n    \n    if (param_2 == 0) {\n        param_2 = 0x11;\n    }\n    if (*(param_1 + 4) != 0) {\n        fcn.0043f749(*(param_1 + 4));\n        *(param_1 + 4) = 0;\n    }\n    if (param_3 != 0) {\n        uVar1 = fcn.0043f71e(param_2 << 2);\n        *(param_1 + 4) = uVar1;\n        fcn.00433ba0(uVar1, 0, param_2 << 2);\n    }\n    *(param_1 + 8) = param_2;\n    return;\n}\n",
        "token_count": 198
    },
    "0043f40f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0043f40f(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    \n    if (*(param_1 + 0x10) == 0) {\n        iVar2 = fcn.0043f00e(param_1 + 0x14, *(param_1 + 0x18), 0xc);\n        iVar4 = *(param_1 + 0x18);\n        puVar3 = iVar2 + -8 + iVar4 * 0xc;\n        if (-1 < iVar4 + -1) {\n            do {\n                *puVar3 = *(param_1 + 0x10);\n                *(param_1 + 0x10) = puVar3;\n                puVar3 = puVar3 + -3;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n    }\n    puVar3 = *(param_1 + 0x10);\n    uVar1 = *puVar3;\n    *(param_1 + 0xc) = *(param_1 + 0xc) + 1;\n    *(param_1 + 0x10) = uVar1;\n    puVar3[1] = 0;\n    puVar3[2] = 0;\n    return;\n}\n",
        "token_count": 306
    },
    "0043f5ac": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043f5ac(uint lpString2)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t in_ECX;\n    int32_t var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GlobalLock;\n    if (*(in_ECX + 0x70) != 0) {\n        var_4h = in_ECX;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*(in_ECX + 0x70));\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrcmpA)(*(iVar2 + 2) + iVar2, lpString2);\n        if ((iVar2 == 0) && (iVar2 = sub.WINSPOOL.DRV_OpenPrinterA(lpString2, &var_4h, 0),  iVar2 != 0)) {\n            if (*(in_ECX + 0x6c) != 0) {\n                fcn.004469e4(*(in_ECX + 0x6c));\n            }\n            uVar3 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, 0, 0, 0);\n            uVar3 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)(0x42, uVar3);\n            *(in_ECX + 0x6c) = uVar3;\n            uVar3 = (*pcVar1)(uVar3);\n            iVar2 = sub.WINSPOOL.DRV_DocumentPropertiesA(0, var_4h, lpString2, uVar3, 0, 2);\n            if (iVar2 != 1) {\n                fcn.004469e4(*(in_ECX + 0x6c));\n                *(in_ECX + 0x6c) = 0;\n            }\n            sub.WINSPOOL.DRV_ClosePrinter(var_4h);\n        }\n    }\n    return;\n}\n",
        "token_count": 433
    },
    "0043f8d9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0043f8d9(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    \n    iVar1 = fcn.00449a0d();\n    if (((*(iVar1 + 4) != 0) && (*param_1 == 0)) && (iVar1 = fcn.0043f844(param_1),  iVar1 != 0)) {\n        return 1;\n    }\n    piVar2 = fcn.00427fdc();\n    piVar4 = piVar2;\n    if (piVar2 != NULL) {\n        piVar4 = piVar2[7];\n    }\n    iVar1 = fcn.004423f0(piVar4, param_1);\n    if (iVar1 == 0) {\n        if (piVar2 != NULL) {\n            fcn.00442089(*param_1);\n            piVar4 = fcn.00442d90();\n            if (piVar4 != piVar2) {\n                uVar3 = (**(*piVar2 + 0x100))(param_1);\n                return uVar3;\n            }\n        }\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 299
    },
    "0043fbf4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0043fbf4(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.004499e7();\n    if (*(iVar1 + 0x14) == '\\0') {\n        iVar1 = fcn.004499d7();\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n        uVar2 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(0xffffffff, 0x43fa76, 0, uVar2);\n        *(iVar1 + 0x2c) = uVar2;\n    }\n    return;\n}\n",
        "token_count": 141
    },
    "0043fe68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0043fe68(int32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int32_t iVar3;\n    int32_t *in_ECX;\n    uint32_t arg_ch_00;\n    int32_t *piVar4;\n    \n    if (arg_ch == 0xfffffffe) {\n        iVar1 = fcn.004499e7();\n        iVar1 = (**(**(iVar1 + 0x1038) + 4))();\n        return iVar1;\n    }\n    if (arg_ch == 0xfffffffd) {\n        iVar1 = *(arg_10h + 0x30);\n        arg_ch = 0;\n        puVar2 = (**(*in_ECX + 0x2c))();\n        do {\n            if (puVar2 == NULL) {\n                return arg_ch;\n            }\n            if (arg_ch != 0) {\n                return arg_ch;\n            }\n            piVar4 = puVar2[1];\n            while (((piVar4[1] != 0 && (piVar4[2] != 0)) && (arg_ch == 0))) {\n                if (arg_8h == piVar4[1]) {\n                    if (iVar1 == 0) {\n                        if (*piVar4 == 0) {\ncode_r0x0043fef4:\n                            *(arg_10h + 4) = piVar4[2];\n                            arg_ch = 1;\n                        }\n                    }\n                    else if ((*piVar4 != 0) && (iVar3 = fcn.0042807b(iVar1, *piVar4),  iVar3 != 0))\n                    goto code_r0x0043fef4;\n                }\n                piVar4 = piVar4 + 3;\n            }\n            puVar2 = *puVar2;\n        } while( true );\n    }\n    if (arg_ch != 0xffffffff) {\n        arg_ch_00 = arg_ch >> 0x10;\n        arg_ch = arg_ch & 0xffff;\n        if (arg_ch_00 != 0) goto code_r0x0043ff2d;\n    }\n    arg_ch_00 = 0x111;\ncode_r0x0043ff2d:\n    puVar2 = (**(*in_ECX + 0x28))();\n    while( true ) {\n        if (puVar2 == NULL) {\n            return 0;\n        }\n        iVar1 = fcn.00440e69(puVar2[1], arg_ch_00, arg_ch, arg_8h);\n        if (iVar1 != 0) break;\n        puVar2 = *puVar2;\n    }\n    iVar1 = fcn.0043fd52(in_ECX, arg_8h, arg_ch, *(iVar1 + 0x14), arg_10h, *(iVar1 + 0x10), arg_14h);\n    return iVar1;\n}\n",
        "token_count": 665
    },
    "00440929": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: hResData\n// WARNING: Variable defined which should be unmapped: hWnd\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_10h\n\nint32_t fcn.00440929(uint param_1, uint param_2, uint param_3, uint param_4, uint param_5, uint param_6)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t noname_0;\n    uint noname_1;\n    uint32_t uVar3;\n    int32_t *extraout_ECX;\n    uint unaff_EBX;\n    int32_t unaff_EBP;\n    uint unaff_ESI;\n    uint unaff_EDI;\n    uint uVar4;\n    uint *in_FS_OFFSET;\n    uint unaff_retaddr;\n    uint var_10h;\n    int32_t *noname_4;\n    uint var_20h;\n    uint var_1ch;\n    uint hResData;\n    uint hWnd;\n    uint in_stack_ffffffec;\n    uint var_ch;\n    uint in_stack_fffffff4;\n    uint var_4h;\n    uint noname_13;\n    \n    noname_13 = 0x440933;\n    fcn.00433928();\n    iVar1 = extraout_ECX[0x16];\n    noname_0 = extraout_ECX[0x17];\n    *(unaff_EBP + -0x10) = &fcn.00440929::var_20h;\n    *(unaff_EBP + -0x1c) = extraout_ECX;\n    *(unaff_EBP + -0x18) = iVar1;\n    var_20h = unaff_EDI;\n    var_1ch = unaff_ESI;\n    hResData = unaff_EBX;\n    iVar1 = fcn.004499e7();\n    uVar4 = *(iVar1 + 0xc);\n    if (extraout_ECX[0x15] != 0) {\n        iVar1 = fcn.004499e7();\n        uVar4 = *(iVar1 + 0xc);\n        uVar2 = (*_sym.imp.KERNEL32.dll_FindResourceA)(uVar4, extraout_ECX[0x15], 5);\n        uVar2 = (*_sym.imp.KERNEL32.dll_LoadResource)(uVar4, uVar2);\n        *(unaff_EBP + -0x18) = uVar2;\n    }\n    if (*(unaff_EBP + -0x18) != 0) {\n        noname_0 = (*_sym.imp.KERNEL32.dll_LockResource)(*(unaff_EBP + -0x18));\n    }\n    if (noname_0 == 0) {\n        iVar1 = -1;\n    }\n    else {\n        uVar2 = fcn.00440469();\n        *(unaff_EBP + -0x14) = uVar2;\n        fcn.00442131();\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar1 = (*_sym.imp.USER32.dll_GetDesktopWindow)();\n            if (*(unaff_EBP + -0x14) != iVar1) {\n                iVar1 = (*_sym.imp.USER32.dll_IsWindowEnabled)(*(unaff_EBP + -0x14));\n                if (iVar1 != 0) {\n                    (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 0);\n                    *(unaff_EBP + -0x20) = 1;\n                }\n            }\n        }\n        *(unaff_EBP + -4) = 0;\n        noname_4 = extraout_ECX;\n        fcn.004433c1();\n        uVar2 = *(unaff_EBP + -0x14);\n        noname_1 = fcn.00442089();\n        iVar1 = fcn.0044071c(noname_0, noname_1, uVar4, uVar2, noname_4, var_20h, var_1ch, hResData, hWnd, \n                             in_stack_ffffffec, var_ch, in_stack_fffffff4, var_4h, noname_13, unaff_retaddr, param_1, \n                             param_2, param_3, var_10h, param_5, param_6);\n        if (iVar1 != 0) {\n            if ((*(extraout_ECX + 0xe) & 0x10) != 0) {\n                uVar4 = 4;\n                uVar3 = fcn.0044403d();\n                if ((uVar3 & 0x100) != 0) {\n                    uVar4 = 5;\n                }\n                fcn.00441b2d(uVar4);\n            }\n            if (extraout_ECX[7] != 0) {\n                fcn.0044428b(0, 0, 0, 0, 0, 0x97);\n            }\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x20) != 0) {\n            (*_sym.imp.USER32.dll_EnableWindow)(*(unaff_EBP + -0x14), 1);\n        }\n        if (*(unaff_EBP + -0x14) != 0) {\n            iVar1 = (*_sym.imp.USER32.dll_GetActiveWindow)();\n            if (iVar1 == extraout_ECX[7]) {\n                (*_sym.imp.USER32.dll_SetActiveWindow)(*(unaff_EBP + -0x14));\n            }\n        }\n        (**(*extraout_ECX + 0x60))();\n        fcn.004404a3();\n        if (extraout_ECX[0x15] != 0) {\n            (*_sym.imp.KERNEL32.dll_FreeResource)(*(unaff_EBP + -0x18));\n        }\n        iVar1 = extraout_ECX[0x10];\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 1416
    },
    "00440d31": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpWndClass\n\nuint __cdecl\nfcn.00440d31(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint arg_8h)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t iVar6;\n    uint uVar7;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_10h;\n    uint lpWndClass;\n    uint var_18h;\n    uint var_14h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    iVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = &lpWndClass;\n    iVar4 = (*_sym.imp.USER32.dll_GetClassInfoA)(*(iVar1 + 0x10), *(iVar1 + 0x24), unaff_EBP + -0x40);\n    if (iVar4 != 0) {\n        uVar5 = 1;\n        goto code_r0x00440e11;\n    }\n    iVar3 = (*_sym.imp.USER32.dll_RegisterClassA)(iVar1);\n    if (iVar3 == 0) {\ncode_r0x00440db6:\n        uVar5 = 0;\n    }\n    else {\n        *(unaff_EBP + -0x18) = 1;\n        iVar4 = fcn.004499e7();\n        if (*(iVar4 + 0x14) != '\\0') {\n            fcn.0044a107(1);\n            *(unaff_EBP + -4) = 0;\n            iVar4 = fcn.004499e7();\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrlenA;\n            *(unaff_EBP + -0x14) = iVar4 + 0x34;\n            iVar4 = (*pcVar2)(iVar4 + 0x34);\n            iVar6 = (*pcVar2)(*(iVar1 + 0x24));\n            if (0xfff < iVar4 + 2 + iVar6) goto code_r0x00440db6;\n            uVar7 = (*pcVar2)(*(unaff_EBP + -0x14));\n            uVar5 = *(iVar1 + 0x24);\n            *(unaff_EBP + 8) = uVar7;\n            iVar4 = (*pcVar2)(uVar5);\n            pcVar2 = _sym.imp.KERNEL32.dll_lstrcatA;\n            if (*(unaff_EBP + 8) + 2 + iVar4 < 0x1000) {\n                (*_sym.imp.KERNEL32.dll_lstrcatA)(*(unaff_EBP + -0x14), *(iVar1 + 0x24));\n                *(unaff_EBP + 10) = 10;\n                *(unaff_EBP + 0xb) = 0;\n                (*pcVar2)(*(unaff_EBP + -0x14), unaff_EBP + 10);\n            }\n            else {\n                uVar5 = *(iVar1 + 0x10);\n                *(unaff_EBP + -0x18) = 0;\n                (*_sym.imp.USER32.dll_UnregisterClassA)(*(iVar1 + 0x24), uVar5);\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0044a16a(1);\n        }\n        uVar5 = *(unaff_EBP + -0x18);\n    }\ncode_r0x00440e11:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar5;\n}\n",
        "token_count": 926
    },
    "00440e69": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00440e69(int32_t *arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h)\n\n{\n    while( true ) {\n        if (arg_8h[4] == 0) {\n            return NULL;\n        }\n        if ((((arg_ch == *arg_8h) && (arg_10h == arg_8h[1])) && (arg_8h[2] <= arg_14h)) &&\n           (arg_14h < arg_8h[3] || arg_14h == arg_8h[3])) break;\n        arg_8h = arg_8h + 6;\n    }\n    return arg_8h;\n}\n",
        "token_count": 168
    },
    "0044200d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0044200d(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    iVar1 = fcn.00449a0d();\n    if ((*(iVar1 + 0x14) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0043f70c(0x446a14);\n        iVar3 = fcn.0043f71e(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0044514f(0x450694, 0x448e5f, 0x4495bf, 0x1c, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x14) = uVar4;\n        fcn.0043f70c(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x14);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 369
    },
    "00442131": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00442131(void)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar1 = fcn.00449f75(0x448b0c);\n    iVar2 = fcn.004499e7();\n    if ((*(iVar2 + 0x14) != '\\0') && (*(iVar1 + 0x28) != 0)) {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar1 + 0x28));\n        *(iVar1 + 0x28) = 0;\n    }\n    if (*(iVar1 + 0x14) != 0) {\n        *(iVar1 + 0x14) = 0;\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 170
    },
    "004421ce": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004421ce(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t *piVar4;\n    uint var_30h;\n    uint var_2ch;\n    int32_t var_28h;\n    int32_t var_24h;\n    \n    iVar2 = fcn.0043f753();\n    if (iVar2 == 0) goto code_r0x00442219;\n    if (*(iVar2 + 0x1c) == param_1) {\n        iVar3 = fcn.004499e7();\n        if (*(iVar3 + 0x14) == '\\0') {\n            iVar3 = fcn.004499e7();\n            if (iVar2 == *(iVar3 + 4)) {\n                iVar3 = fcn.00447f1f();\n                if (iVar3 == 0) goto code_r0x0044220e;\n            }\n            fcn.0044c0ff(0);\n        }\ncode_r0x0044220e:\n        *(iVar2 + 0x1c) = 0;\n    }\n    if (*(iVar2 + 0x20) == param_1) {\n        *(iVar2 + 0x20) = 0;\n    }\ncode_r0x00442219:\n    if (param_1[0x11] != NULL) {\n        (**(*param_1[0x11] + 0x50))();\n        param_1[0x11] = 0;\n    }\n    if (param_1[0x12] != NULL) {\n        (**(*param_1[0x12] + 4))(1);\n    }\n    param_1[0x12] = 0;\n    if ((*(param_1 + 0xe) & 1) != 0) {\n        iVar2 = fcn.00449a0d();\n        iVar2 = *(iVar2 + 0x3c);\n        if ((iVar2 != 0) && (*(iVar2 + 0x1c) != 0)) {\n            fcn.00433ba0(&var_30h, 0, 0x30);\n            var_28h = param_1[7];\n            var_30h = 0x28;\n            var_2ch = 1;\n            var_24h = var_28h;\n            (*_sym.imp.USER32.dll_SendMessageA)(*(iVar2 + 0x1c), 0x405, 0, &var_30h);\n        }\n    }\n    pcVar1 = _sym.imp.USER32.dll_GetWindowLongA;\n    iVar2 = (*_sym.imp.USER32.dll_GetWindowLongA)(param_1[7], 0xfffffffc);\n    fcn.00441fe6();\n    iVar3 = (*pcVar1)(param_1[7], 0xfffffffc);\n    if (iVar3 == iVar2) {\n        piVar4 = (**(*param_1 + 0xf0))();\n        if (*piVar4 != 0) {\n            (*_sym.imp.USER32.dll_SetWindowLongA)(param_1[7], 0xfffffffc, *piVar4);\n        }\n    }\n    fcn.00442103();\n    (**(*param_1 + 0x114))();\n    return;\n}\n",
        "token_count": 740
    },
    "004424ec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.004424ec(uint arg_8h, uint arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    int32_t *in_ECX;\n    int32_t *var_4h;\n    \n    var_4h = in_ECX;\n    if (*(in_ECX + 8) != '\\0') {\n        var_4h = NULL;\n        iVar1 = (**(*in_ECX + 0xe4))(arg_8h, arg_ch, &var_4h);\n        if (-1 < iVar1) {\n            return var_4h;\n        }\n    }\n    piVar2 = fcn.00441fe6();\n    return piVar2;\n}\n",
        "token_count": 162
    },
    "0044264e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_40h\n\nuint fcn.0044264e(void)\n\n{\n    int32_t *arg_8h;\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint *puVar4;\n    uint *puVar5;\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_ch;\n    uint var_10h_2;\n    uint var_14h;\n    uint var_18h;\n    uint var_10h;\n    uint var_40h;\n    uint var_24h;\n    uint var_14h_2;\n    uint var_ch_2;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = &stack0xffffffc0;\n    iVar1 = fcn.00449f75(0x448b0c);\n    puVar4 = iVar1 + 0x58;\n    puVar5 = unaff_EBP + -0x40;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    iVar3 = *(unaff_EBP + 0x10);\n    arg_8h = *(unaff_EBP + 8);\n    *(iVar1 + 0x58) = *(unaff_EBP + 0xc);\n    *(iVar1 + 0x60) = *(unaff_EBP + 0x14);\n    *(iVar1 + 100) = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -0x14) = iVar1;\n    *(iVar1 + 0x5c) = iVar3;\n    *(unaff_EBP + -4) = 0;\n    if ((iVar3 == 2) && (arg_8h[0x12] != 0)) {\n        (**(*arg_8h[0x12] + 0x60))(0);\n    }\n    *(unaff_EBP + 8) = 0;\n    if (iVar3 == 0x110) {\n        fcn.004416f7(arg_8h, unaff_EBP + -0x24, unaff_EBP + 8);\n    }\n    uVar2 = (**(*arg_8h + 0x108))(iVar3, *(unaff_EBP + 0x14), *(unaff_EBP + 0x18));\n    *(unaff_EBP + 0x18) = uVar2;\n    if (iVar3 == 0x110) {\n        fcn.004425d5(arg_8h, unaff_EBP + -0x24);\n    }\n    uVar2 = *(unaff_EBP + 0x18);\n    puVar4 = unaff_EBP + -0x40;\n    puVar5 = iVar1 + 0x58;\n    for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {\n        *puVar5 = *puVar4;\n        puVar4 = puVar4 + 1;\n        puVar5 = puVar5 + 1;\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 774
    },
    "00442786": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00442786(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CWnd.0;\n    *(unaff_EBP + -4) = 0;\n    if ((((extraout_ECX[7] != NULL) && (extraout_ECX != 0x45e970)) && (extraout_ECX != 0x45e9c0)) &&\n       ((extraout_ECX != 0x45ea10 && (extraout_ECX != 0x45ea60)))) {\n        fcn.004422df();\n    }\n    if (extraout_ECX[0x12] != NULL) {\n        (**(*extraout_ECX[0x12] + 4))(1);\n    }\n    pcVar1 = extraout_ECX[0x13];\n    if ((pcVar1 != NULL) && (*(pcVar1 + 0x24) == extraout_ECX)) {\n        *(pcVar1 + 0x24) = 0;\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043fd45();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 352
    },
    "004428e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.004428e4(int32_t *param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t *piVar3;\n    \n    if ((param_1 != NULL) && (param_1[7] != 0)) {\n        iVar2 = (**(*param_1 + 0x120))();\n        piVar3 = param_1;\n        if (iVar2 == 0) {\n            param_1 = fcn.004428a5();\n            piVar3 = param_1;\n        }\n        while (piVar1 = piVar3,  piVar1 != NULL) {\n            piVar3 = fcn.004428a5();\n            param_1 = piVar1;\n        }\n        return param_1;\n    }\n    return NULL;\n}\n",
        "token_count": 186
    },
    "00442925": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00442925(uint arg_8h, uint Msg, uint wParam, uint lParam, int32_t arg_18h, int32_t arg_1ch)\n\n{\n    code *pcVar1;\n    int32_t arg_8h_00;\n    int32_t iVar2;\n    \n    pcVar1 = _sym.imp.USER32.dll_GetTopWindow;\n    for (arg_8h_00 = (*_sym.imp.USER32.dll_GetTopWindow)(arg_8h); arg_8h_00 != 0;\n        arg_8h_00 = (*_sym.imp.USER32.dll_GetWindow)(arg_8h_00, 2)) {\n        if (arg_1ch == 0) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h_00, Msg, wParam, lParam);\n        }\n        else {\n            iVar2 = fcn.004420b0(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.0044264e(iVar2, *(iVar2 + 0x1c), Msg, wParam, lParam);\n            }\n        }\n        if (arg_18h != 0) {\n            iVar2 = (*pcVar1)(arg_8h_00);\n            if (iVar2 != 0) {\n                fcn.00442925(arg_8h_00, Msg, wParam, lParam, arg_18h, arg_1ch);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 328
    },
    "00442aa8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00442aa8(int32_t *param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = fcn.004420ca(param_2);\n    if (iVar1 != 0) {\n        (**(*param_1 + 0x50))();\n        piVar2 = (**(*param_1 + 0xf0))();\n        iVar1 = (*_sym.imp.USER32.dll_SetWindowLongA)(unaff_retaddr, 0xfffffffc, fcn.0044273b);\n        if (*piVar2 == 0) {\n            *piVar2 = iVar1;\n        }\n        iVar1 = 1;\n    }\n    return iVar1;\n}\n",
        "token_count": 177
    },
    "00442b06": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00442b06(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    if (*(param_1 + 0x4c) == 0) {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(*(param_1 + 0x1c));\n        uVar2 = fcn.00428c19(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(*(param_1 + 0x1c), uVar2);\n        fcn.00427fef(0xffffffff);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00442b45. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x8c))();\n    return;\n}\n",
        "token_count": 203
    },
    "00442e92": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00442e92(int16_t *arg_8h)\n\n{\n    int16_t iVar1;\n    code *pcVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t in_ECX;\n    uint *puVar5;\n    uint *puVar6;\n    uint var_2ch;\n    uint var_28h;\n    uint *var_24h;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    pcVar2 = _sym.imp.USER32.dll_SendDlgItemMessageA;\n    var_4h = 1;\n    if (arg_8h != NULL) {\n        do {\n            iVar1 = *arg_8h;\n            if (iVar1 == 0) break;\n            iVar3 = arg_8h[1];\n            var_8h = *(arg_8h + 2);\n            puVar5 = arg_8h + 4;\n            if (iVar3 == 0x1234) {\ncode_r0x00442ef9:\n                (**0x45b0bc)();\n                var_28h = 0xffffffff;\n                var_2ch = 1;\n                iVar3 = 0x401;\n                puVar6 = &var_2ch;\n                var_24h = puVar5;\ncode_r0x00442f34:\n                iVar4 = (*pcVar2)(*(in_ECX + 0x1c), iVar1, iVar3, 0, puVar6);\n                if (iVar4 == -1) {\n                    var_4h = 0;\n                }\n            }\n            else {\n                puVar6 = puVar5;\n                if (iVar3 == 0x401) {\n                    iVar3 = 0x180;\n                    goto code_r0x00442f34;\n                }\n                if (iVar3 == 0x403) {\n                    iVar3 = 0x143;\n                }\n                if (iVar3 == 0x401) goto code_r0x00442ef9;\n                if ((iVar3 == 0x180) || (iVar3 == 0x143)) goto code_r0x00442f34;\n            }\n            arg_8h = puVar5 + var_8h;\n        } while (var_4h != 0);\n        if (var_4h == 0) {\n            return 0;\n        }\n    }\n    fcn.00442925(*(in_ECX + 0x1c), 0x364, 0, 0, 0, 0);\n    return var_4h;\n}\n",
        "token_count": 572
    },
    "004431a2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004431a2(int32_t arg_8h, uint arg_ch, int32_t *arg_10h)\n\n{\n    char cVar1;\n    int32_t *piVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint32_t uVar6;\n    uint *puVar7;\n    int32_t iVar8;\n    code **ppcVar9;\n    code *pcVar10;\n    uint var_13ch;\n    uint var_10ch;\n    uchar var_dh;\n    uint32_t var_ch;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    iVar4 = fcn.00449f75(0x448b0c);\n    if (arg_8h != 3) {\n        (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), arg_8h, arg_ch, arg_10h);\n        goto code_r0x004433b4;\n    }\n    piVar2 = *(iVar4 + 0x14);\n    iVar8 = *arg_10h;\n    iVar5 = fcn.004499e7();\n    cVar1 = *(iVar5 + 0x14);\n    if ((piVar2 != NULL) || (((*(iVar8 + 0x23) & 0x40) == 0 && (cVar1 == '\\0')))) {\n        if (*0x45f06c == 0) {\ncode_r0x00443265:\n            if (piVar2 == NULL) {\n                if (*0x45eab0 == 0) {\n                    fcn.00433ba0(&var_13ch, 0, 0x30);\n                    var_13ch = 0x30;\n                    *0x45eab0 = (*_sym.imp.USER32.dll_GetClassInfoExA)(0, \"#32768\", &var_13ch);\n                    if (*0x45eab0 != 0) goto code_r0x004432eb;\n                    iVar8 = (*_sym.imp.USER32.dll_GetClassNameA)(arg_ch, &var_10ch, 0x100);\n                    if (iVar8 != 0) {\n                        var_dh = 0;\n                        iVar8 = fcn.00432eed(&var_10ch, \"#32768\");\n                        if (iVar8 == 0) goto code_r0x0044338a;\n                    }\n                }\n                else {\ncode_r0x004432eb:\n                    iVar3 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe0);\n                    if (iVar3 == *0x45eab0) goto code_r0x0044338a;\n                }\n                var_ch = (*_sym.imp.USER32.dll_GetWindowLongA)(arg_ch, 0xfffffffc);\n                pcVar10 = _sym.imp.USER32.dll_GetPropA;\n                if ((var_ch != 0) && (iVar8 = (*_sym.imp.USER32.dll_GetPropA)(arg_ch, \"AfxOldWndProc423\"),  iVar8 == 0))\n                {\n                    (*_sym.imp.USER32.dll_SetPropA)(arg_ch, \"AfxOldWndProc423\", var_ch);\n                    uVar6 = (*pcVar10)(arg_ch, \"AfxOldWndProc423\");\n                    if (uVar6 == var_ch) {\n                        (*_sym.imp.KERNEL32.dll_GlobalAddAtomA)(\"AfxOldWndProc423\");\n                        (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, 0x44304a);\n                    }\n                }\n            }\n            else {\n                fcn.004420ca(arg_ch);\n                (**(*piVar2 + 0x50))();\n                ppcVar9 = (**(*piVar2 + 0xf0))();\n                pcVar10 = (*_sym.imp.USER32.dll_SetWindowLongA)(arg_ch, 0xfffffffc, fcn.0044273b);\n                if (pcVar10 != fcn.0044273b) {\n                    *ppcVar9 = pcVar10;\n                }\n                *(iVar4 + 0x14) = 0;\n            }\n        }\n        else {\n            uVar6 = (*_sym.imp.USER32.dll_GetClassLongA)(arg_ch, 0xffffffe6);\n            if ((uVar6 & 0x10000) == 0) {\n                puVar7 = *(iVar8 + 0x28);\n                if (puVar7 < 0x10000) {\n                    var_ch = var_ch & 0xffffff00;\n                    (*_sym.imp.KERNEL32.dll_GlobalGetAtomNameA)(*(iVar8 + 0x28), &var_ch, 5);\n                    puVar7 = &var_ch;\n                }\n                iVar8 = (*_sym.imp.KERNEL32.dll_lstrcmpiA)(puVar7, 0x450fc4);\n                if (iVar8 != 0) goto code_r0x00443265;\n            }\n        }\n    }\ncode_r0x0044338a:\n    (*_sym.imp.USER32.dll_CallNextHookEx)(*(iVar4 + 0x28), 3, arg_ch, arg_10h);\n    if (cVar1 != '\\0') {\n        (*_sym.imp.USER32.dll_UnhookWindowsHookEx)(*(iVar4 + 0x28));\n        *(iVar4 + 0x28) = 0;\n    }\ncode_r0x004433b4:\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1228
    },
    "004433c1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.004433c1(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    iVar1 = fcn.00449f75(0x448b0c);\n    if (*(iVar1 + 0x14) != unaff_retaddr) {\n        if (*(iVar1 + 0x28) == 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetCurrentThreadId)();\n            iVar3 = (*_sym.imp.USER32.dll_SetWindowsHookExA)(5, fcn.004431a2, 0, uVar2);\n            *(iVar1 + 0x28) = iVar3;\n            if (iVar3 == 0) {\n                fcn.0043e0e7();\n            }\n        }\n        *(iVar1 + 0x14) = unaff_retaddr;\n    }\n    return;\n}\n",
        "token_count": 207
    },
    "00443546": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_74h\n\nuint __cdecl fcn.00443546(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int16_t iVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint32_t uVar7;\n    uint uVar8;\n    int32_t *arg_8h_00;\n    uint *puVar9;\n    uint *puVar10;\n    int32_t unaff_EBP;\n    int16_t iVar11;\n    uint *in_FS_OFFSET;\n    int32_t *in_stack_ffffff70;\n    uint in_stack_ffffff84;\n    uint var_74h;\n    uint var_58h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = 0;\n    uVar7 = *(unaff_EBP + 8);\n    if (uVar7 == 0x111) {\n        iVar4 = (**(*arg_8h_00 + 0xe8))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n        if (iVar4 == 0) goto code_r0x00443731;\ncode_r0x004439e1:\n        *(unaff_EBP + -0x10) = 1;\n        goto code_r0x00443a39;\n    }\n    if (uVar7 == 0x4e) {\n        if (**(unaff_EBP + 0x10) == 0) goto code_r0x00443731;\n        iVar4 = (**(*arg_8h_00 + 0xec))(*(unaff_EBP + 0xc), *(unaff_EBP + 0x10), unaff_EBP + -0x10);\ncode_r0x00443a05:\n        if (iVar4 == 0) goto code_r0x00443731;\n        goto code_r0x00443a39;\n    }\n    puVar9 = *(unaff_EBP + 0x10);\n    if (uVar7 == 6) {\n        in_stack_ffffff84 = fcn.00442089(puVar9);\n        fcn.00442f73(arg_8h_00, *(unaff_EBP + 0xc), in_stack_ffffff84);\n    }\n    iVar11 = puVar9;\n    if ((uVar7 == 0x20) &&\n       (in_stack_ffffff70 = arg_8h_00,  iVar4 = fcn.00442fd4(arg_8h_00, iVar11, puVar9 >> 0x10),  iVar4 != 0))\n    goto code_r0x004439e1;\n    if (((arg_8h_00[0x12] != 0) && (0 < *(arg_8h_00[0x12] + 0x70))) &&\n       ((((0x1ff < uVar7 && (uVar7 < 0x20a)) || ((0xff < uVar7 && (uVar7 < 0x110)))) ||\n        ((0x280 < uVar7 && (uVar7 < 0x292)))))) {\n        in_stack_ffffff70 = *(unaff_EBP + 0xc);\n        iVar4 = (**(*arg_8h_00[0x12] + 0x94))(uVar7, in_stack_ffffff70, puVar9, unaff_EBP + -0x10);\n        if (iVar4 == 0) goto code_r0x00443638;\n        goto code_r0x00443a39;\n    }\ncode_r0x00443638:\n    uVar5 = (**(*arg_8h_00 + 0x28))();\n    *(unaff_EBP + -0x14) = uVar5;\n    uVar7 = *(unaff_EBP + 8);\n    fcn.0044a107(7);\n    iVar4 = ((uVar5 ^ uVar7) & 0x1ff) * 0xc;\n    iVar6 = *(unaff_EBP + -0x14);\n    if ((*(unaff_EBP + 8) != *(iVar4 + 0x45d140)) || (iVar6 != *(iVar4 + 0x45d148))) {\n        *(iVar4 + 0x45d140) = *(unaff_EBP + 8);\n        *(iVar4 + 0x45d148) = iVar6;\n        while (iVar6 != 0) {\n            if (*(unaff_EBP + 8) < 0xc000) {\n                iVar6 = fcn.00440e69(*(*(unaff_EBP + -0x14) + 4), *(unaff_EBP + 8), in_stack_ffffff70, 0);\n                *(unaff_EBP + 0x10) = iVar6;\n                if (iVar6 != 0) {\n                    *(iVar4 + 0x45d144) = iVar6;\n                    fcn.0044a16a(7);\n                    goto code_r0x004436c9;\n                }\n            }\n            else {\n                iVar6 = *(*(unaff_EBP + -0x14) + 4);\n                while( true ) {\n                    iVar6 = fcn.00440e69(iVar6, 0xc000, 0, in_stack_ffffff84);\n                    *(unaff_EBP + 0x10) = iVar6;\n                    if (iVar6 == 0) break;\n                    if (**(*(unaff_EBP + 0x10) + 0x10) == *(unaff_EBP + 8)) {\n                        *(iVar4 + 0x45d144) = *(unaff_EBP + 0x10);\n                        fcn.0044a16a(7);\n                        goto code_r0x00443a28;\n                    }\n                    iVar6 = *(unaff_EBP + 0x10) + 0x18;\n                }\n            }\n            iVar6 = **(unaff_EBP + -0x14);\n            *(unaff_EBP + -0x14) = iVar6;\n        }\n        *(iVar4 + 0x45d144) = 0;\n        fcn.0044a16a(7);\ncode_r0x00443731:\n        uVar8 = 0;\n        goto code_r0x00443733;\n    }\n    iVar4 = *(iVar4 + 0x45d144);\n    *(unaff_EBP + 0x10) = iVar4;\n    fcn.0044a16a(7);\n    if (iVar4 == 0) goto code_r0x00443731;\n    if (0xbfff < *(unaff_EBP + 8)) {\ncode_r0x00443a28:\n        uVar8 = (**(*(unaff_EBP + 0x10) + 0x14))(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x00443a36;\n    }\ncode_r0x004436c9:\n    pcVar1 = *(*(unaff_EBP + 0x10) + 0x14);\n    iVar4 = *(*(unaff_EBP + 0x10) + 0x10);\n    iVar3 = puVar9 >> 0x10;\n    // switch table (65 cases) at 0x443a4d\n    switch(iVar4) {\n    case 1:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.004464d4(puVar9);\n        goto code_r0x00443852;\n    case 2:\n    case 3:\n    case 4:\n    case 0x18:\n    case 0x19:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x00443852;\n    case 5:\n    case 0xc:\n        uVar5 = puVar9 >> 0x10;\n        puVar9 = puVar9 & 0xffff;\n        uVar7 = *(unaff_EBP + 0xc);\n        uVar5 = fcn.00442089(uVar7, puVar9, uVar5);\n        goto code_r0x00443876;\n    case 6:\n        uVar7 = fcn.00442089(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x0044398b;\n    case 7:\n    case 0xd:\ncode_r0x00443852:\n        uVar8 = (*pcVar1)(puVar9);\n        goto code_r0x00443a36;\n    case 8:\n        fcn.0044614a();\n        uVar8 = puVar9[1];\n        *(unaff_EBP + -4) = 0;\n        *(unaff_EBP + -0x20) = uVar8;\n        fcn.004416b4();\n        uVar8 = *puVar9;\n        uVar2 = puVar9[2];\n        *(unaff_EBP + -4) = 1;\n        *(unaff_EBP + -0x58) = uVar8;\n        iVar4 = fcn.004420b0(uVar8);\n        if (iVar4 == 0) {\n            if ((arg_8h_00[0x12] != 0) && (iVar4 = fcn.0043f2e2(*(unaff_EBP + -0x58)),  iVar4 != 0)) {\n                *(unaff_EBP + -0x28) = iVar4;\n            }\n            iVar4 = unaff_EBP + -0x74;\n        }\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, iVar4, uVar2);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x58) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\n        *(unaff_EBP + -4) = 0;\n        fcn.00442786();\n        goto code_r0x00443821;\n    case 9:\n        fcn.0044614a();\n        uVar8 = puVar9[2];\n        *(unaff_EBP + -0x20) = puVar9[1];\n        *(unaff_EBP + -4) = 2;\n        uVar8 = (*pcVar1)(unaff_EBP + -0x24, uVar8);\n        *(unaff_EBP + -0x20) = 0;\n        *(unaff_EBP + -0x10) = uVar8;\ncode_r0x00443821:\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0044654a();\n        break;\n    case 10:\n        uVar7 = fcn.00442089(puVar9, *(unaff_EBP + 0xc) >> 0x10);\n        goto code_r0x00443871;\n    case 0xb:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0044398b;\n    case 0xe:\n    case 0x2c:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x0044398b;\n    case 0xf:\n        puVar9 = fcn.00445863(puVar9);\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\ncode_r0x00443871:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x00443876:\n        uVar8 = (*pcVar1)(uVar5, uVar7, puVar9);\n        goto code_r0x00443a36;\n    case 0x10:\n        (*pcVar1)();\n        break;\n    case 0x11:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x004439ab;\n    case 0x12:\n    case 0x1b:\n    case 0x2a:\n    case 0x2f:\n        goto code_r0x0044399e;\n    case 0x13:\n        puVar9 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x004439a1;\n    case 0x14:\n        puVar9 = iVar3;\n        uVar7 = iVar11;\n        goto code_r0x004439a1;\n    case 0x15:\n    case 0x16:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x004439cf;\n    case 0x17:\n        fcn.00442089(puVar9);\ncode_r0x0044399e:\n        uVar7 = *(unaff_EBP + 0xc);\n        goto code_r0x004439a1;\n    case 0x1a:\n    case 0x25:\n    case 0x2e:\n        uVar8 = (*pcVar1)();\n        goto code_r0x00443a36;\n    case 0x1c:\n        puVar10 = *(unaff_EBP + 0xc);\n        uVar7 = fcn.00442089(puVar10);\n        fcn.00442089(puVar9, uVar7);\n        uVar5 = arg_8h_00[7] == puVar9;\n        goto code_r0x004439d3;\n    case 0x1d:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.004464d4(puVar9);\n        goto code_r0x004439ab;\n    case 0x1e:\n        puVar9 = *(unaff_EBP + 0xc);\n        fcn.00445863(puVar9);\n        goto code_r0x004439ab;\n    case 0x1f:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        uVar5 = fcn.00445863(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x004439d3;\n    case 0x20:\n        puVar9 = *(unaff_EBP + 0xc);\n        goto code_r0x0044390e;\n    case 0x21:\ncode_r0x0044390e:\n        fcn.00442089(puVar9);\n        goto code_r0x004439ab;\n    case 0x22:\n        puVar10 = puVar9 >> 0x10;\n        uVar7 = puVar9 & 0xffff;\n        goto code_r0x0044392a;\n    case 0x23:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x0044392a:\n        uVar5 = fcn.00442089(*(unaff_EBP + 0xc), uVar7, puVar10);\n        goto code_r0x004439d3;\n    case 0x24:\n        uVar7 = fcn.00442089(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x004439a1;\n    case 0x26:\n        puVar10 = *(unaff_EBP + 0xc) >> 0x10;\n        uVar7 = fcn.00442089(puVar9, puVar10);\n        goto code_r0x004439bb;\n    case 0x27:\n    case 0x28:\n        *(unaff_EBP + 8) = *(unaff_EBP + 0xc);\n        *(unaff_EBP + 0xc) = *(unaff_EBP + 0xc) >> 0x10;\n        if (iVar4 == 0x27) {\n            uVar7 = fcn.00442089(puVar9);\n            uVar5 = *(unaff_EBP + 0xc);\n            puVar10 = puVar9;\n            goto code_r0x004439d3;\n        }\n        puVar9 = *(unaff_EBP + 0xc);\n        uVar7 = *(unaff_EBP + 8);\ncode_r0x004439a1:\n        (*pcVar1)(uVar7, puVar9);\n        break;\n    case 0x29:\n    case 0x30:\ncode_r0x004439ab:\n        (*pcVar1)(puVar9);\n        break;\n    case 0x2b:\n    case 0x33:\n        (*pcVar1)(*(unaff_EBP + 0xc), puVar9);\n        goto code_r0x004439e1;\n    case 0x2d:\n        uVar7 = iVar11;\n        puVar9 = iVar3;\ncode_r0x0044398b:\n        uVar8 = (*pcVar1)(uVar7, puVar9);\ncode_r0x00443a36:\n        *(unaff_EBP + -0x10) = uVar8;\n        break;\n    case 0x31:\n        uVar7 = *(unaff_EBP + 0xc) >> 0x10;\n        puVar10 = puVar9;\ncode_r0x004439bb:\n        uVar5 = *(unaff_EBP + 0xc);\n        goto code_r0x004439d3;\n    case 0x32:\n        uVar7 = iVar11;\n        puVar10 = iVar3;\ncode_r0x004439cf:\n        uVar5 = *(unaff_EBP + 0xc);\ncode_r0x004439d3:\n        (*pcVar1)(uVar5, uVar7, puVar10);\n        break;\n    case 0x34:\n        iVar4 = (*pcVar1)(*(unaff_EBP + 0xc), *(unaff_EBP + 0xc) >> 0x10, puVar9 & 0xffff, puVar9 >> 0x10);\n        *(unaff_EBP + -0x10) = iVar4;\n        goto code_r0x00443a05;\n    case 0x41:\n        iVar4 = (*pcVar1)();\n        *(unaff_EBP + -0x10) = iVar4;\n        if (iVar4 != 0) goto code_r0x00443731;\n    }\ncode_r0x00443a39:\n    if (*(unaff_EBP + 0x14) != NULL) {\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x10);\n    }\n    uVar8 = 1;\ncode_r0x00443733:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar8;\n}\n",
        "token_count": 4315
    },
    "00443f99": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00443f99(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) != 0) {\n    // WARNING: Could not recover jumptable at 0x00443fa4. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x48) + 0x98))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 115
    },
    "00443faf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.00443faf(int32_t param_1)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) != 0) {\n    // WARNING: Could not recover jumptable at 0x00443fba. Too many branches\n    // WARNING: Treating indirect jump as call\n        uVar1 = (**(**(param_1 + 0x48) + 0x54))();\n        return uVar1;\n    }\n    return 0;\n}\n",
        "token_count": 114
    },
    "00443fc2": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00443fc2(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    \n    if (*(param_1 + 0x48) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(param_1 + 0x1c), param_2);\n        fcn.00442089(uVar1);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00443fe3. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x74))();\n    return;\n}\n",
        "token_count": 153
    },
    "00443fe6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00443fe6(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    uint *unaff_retaddr;\n    \n    if (*(param_1 + 0x48) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetDlgItem)(*(param_1 + 0x1c), param_2);\n        *unaff_retaddr = uVar1;\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00444007. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x48) + 0x70))();\n    return;\n}\n",
        "token_count": 160
    },
    "0044403d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044403d(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xfffffff0);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00444054. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x78))();\n    return;\n}\n",
        "token_count": 130
    },
    "00444057": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00444057(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetWindowLongA)(*(param_1 + 0x1c), 0xffffffec);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0044406e. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x7c))();\n    return;\n}\n",
        "token_count": 130
    },
    "00444071": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444071(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        fcn.00440c11(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00444095. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x80))();\n    return;\n}\n",
        "token_count": 149
    },
    "0044409b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044409b(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        fcn.00440c2b(*(in_ECX + 0x1c), arg_8h, arg_ch, arg_10h);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004440bf. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x84))();\n    return;\n}\n",
        "token_count": 151
    },
    "004440c5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.004440c5(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_SetWindowTextA)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004440e0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x88))();\n    return;\n}\n",
        "token_count": 134
    },
    "004440e6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004440e6(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_GetDlgCtrlID)(*(param_1 + 0x1c));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004440fb. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0x90))();\n    return;\n}\n",
        "token_count": 124
    },
    "00444101": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00444101(uint X, uint Y, uint nWidth, uint nHeight, uint bRepaint)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_MoveWindow)(*(in_ECX + 0x1c), X, Y, nWidth, nHeight, bRepaint);\n    }\n    else {\n        (**(**(in_ECX + 0x4c) + 0x98))(X, Y, nWidth, nHeight);\n    }\n    return;\n}\n",
        "token_count": 134
    },
    "0044413f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044413f(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_ShowWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x0044415a. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa0))();\n    return;\n}\n",
        "token_count": 133
    },
    "00444160": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00444160(int32_t param_1)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_IsWindowEnabled)(*(param_1 + 0x1c));\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00444175. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa4))();\n    return;\n}\n",
        "token_count": 122
    },
    "0044417b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044417b(int32_t param_1, uint param_2)\n\n{\n    if (*(param_1 + 0x4c) == 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(*(param_1 + 0x1c), param_2);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x00444196. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(param_1 + 0x4c) + 0xa8))();\n    return;\n}\n",
        "token_count": 132
    },
    "004441bd": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl\nfcn.004441bd(int32_t arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    if (*(arg_8h + 0x4c) != 0) {\n        (**(**(arg_8h + 0x4c) + 0x60))(arg_ch, arg_10h, arg_14h, arg_18h, arg_1ch, &arg_20h);\n    }\n    return;\n}\n",
        "token_count": 128
    },
    "00444208": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00444208(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    if ((*(param_1 + 0x4c) == 0) && (*(param_2 + 0x48) != 0)) {\n        (**(**(param_2 + 0x48) + 0x9c))(param_1, param_3);\n    }\n    return;\n}\n",
        "token_count": 99
    },
    "0044422d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044422d(uint *param_1)\n\n{\n    if (param_1[1] != 0) {\n    // WARNING: Could not recover jumptable at 0x00444238. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(*param_1[1] + 0x78))();\n        return;\n    }\n    (*_sym.imp.USER32.dll_GetWindowLongA)(*param_1, 0xfffffff0);\n    return;\n}\n",
        "token_count": 113
    },
    "0044428b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044428b(int32_t arg_8h, uint X, uint Y, uint cx, uint cy, uint uFlags)\n\n{\n    int32_t in_ECX;\n    \n    if (*(in_ECX + 0x4c) == 0) {\n        if (arg_8h != 0) {\n            arg_8h = *(arg_8h + 0x1c);\n        }\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(in_ECX + 0x1c), arg_8h, X, Y, cx, cy, uFlags);\n        return;\n    }\n    // WARNING: Could not recover jumptable at 0x004442c1. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**(**(in_ECX + 0x4c) + 0x9c))();\n    return;\n}\n",
        "token_count": 199
    },
    "004442c7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004442c7(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    if ((param_1 != 0) && (*(param_1 + 0x4c) == 0)) {\n        uVar1 = (*_sym.imp.USER32.dll_GetParent)(*(param_1 + 0x1c));\n        iVar2 = fcn.0043f2e2(uVar1);\n        if ((iVar2 != 0) && (*(iVar2 + 0x48) != 0)) {\n            (**(**(iVar2 + 0x48) + 0x9c))(param_1, 0);\n        }\n    }\n    return;\n}\n",
        "token_count": 161
    },
    "00444308": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00444308(int32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    bool bVar6;\n    code *var_8h;\n    code *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        if (arg_ch == 0) {\n            var_8h = 0x4284ce;\n            var_4h = 0x4280e1;\n        }\n        else {\n            var_8h = 0x444286;\n            var_4h = 0x429631;\n        }\n        arg_ch = (*var_4h)();\njoined_r0x00444350:\n        do {\n            if (arg_ch == 0) {\n                return NULL;\n            }\n            ppiVar3 = (*var_8h)(&arg_ch);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto joined_r0x00444350;\n                bVar6 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar6 = arg_8h == piVar1;\n            }\n        } while (!bVar6);\n        if (piVar1 != NULL) {\n            if (arg_ch == 0) {\n                arg_ch = (*var_4h)();\n            }\n            do {\n                ppiVar3 = (*var_8h)(&arg_ch);\n                piVar2 = *ppiVar3;\n                uVar5 = fcn.0044422d();\n                if (piVar2 == piVar1) {\n                    return piVar2;\n                }\n                if (((uVar5 & 0x10000) != 0) && ((uVar5 & 0x8000000) == 0)) {\n                    return piVar2;\n                }\n            } while (arg_ch != 0);\n        }\n    }\n    return NULL;\n}\n",
        "token_count": 535
    },
    "004443e4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004443e4(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    bool bVar7;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        var_4h = *(*(in_ECX + 0x48) + 0x44);\ncode_r0x00444442:\n        do {\n            piVar2 = var_4h;\n            if (var_4h == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.00429635(&var_4h);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto code_r0x00444442;\n                bVar7 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar7 = arg_8h == piVar1;\n            }\n        } while (!bVar7);\n        if ((var_4h != NULL) && (piVar1 != NULL)) {\n            bVar7 = false;\n            do {\n                puVar5 = fcn.00429635(&var_4h);\n                uVar6 = *puVar5;\n                var_ch = fcn.0044422d();\n                if ((!bVar7) && ((var_ch & 0x20000) != 0)) {\n                    bVar7 = true;\n                    arg_8h = piVar2;\n                    fcn.0042964f(&arg_8h);\n                    while (arg_8h != NULL) {\n                        puVar5 = fcn.0042964f();\n                        uVar6 = *puVar5;\n                        var_ch = fcn.0044422d();\n                        if ((var_ch & 0x20000) != 0) {\n                            return uVar6;\n                        }\n                    }\n                }\n                if ((var_ch & 0x8000000) == 0) {\n                    return uVar6;\n                }\n            } while (var_4h != NULL);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 594
    },
    "004444e0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004444e0(int32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    int32_t *piVar2;\n    int32_t **ppiVar3;\n    int32_t iVar4;\n    uint *puVar5;\n    int32_t in_ECX;\n    uint uVar6;\n    bool bVar7;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    int32_t *var_4h;\n    \n    if (*(in_ECX + 0x48) != 0) {\n        var_4h = *(*(in_ECX + 0x48) + 0x40);\ncode_r0x0044453e:\n        do {\n            piVar2 = var_4h;\n            if (var_4h == NULL) {\n                return 0;\n            }\n            ppiVar3 = fcn.0042964f(&var_4h);\n            piVar1 = *ppiVar3;\n            if (arg_8h == NULL) {\n                if ((*piVar1 != 0) && (iVar4 = (*_sym.imp.USER32.dll_GetFocus)(),  *piVar1 == iVar4)) break;\n                if (piVar1[1] == 0) goto code_r0x0044453e;\n                bVar7 = piVar1[1] == *(*(in_ECX + 0x48) + 0x6c);\n            }\n            else {\n                bVar7 = arg_8h == piVar1;\n            }\n        } while (!bVar7);\n        if ((var_4h != NULL) && (piVar1 != NULL)) {\n            bVar7 = false;\n            do {\n                puVar5 = fcn.0042964f(&var_4h);\n                uVar6 = *puVar5;\n                var_ch = fcn.0044422d();\n                if ((!bVar7) && ((var_ch & 0x20000) != 0)) {\n                    bVar7 = true;\n                    arg_8h = piVar2;\n                    fcn.00429635(&arg_8h);\n                    while (arg_8h != NULL) {\n                        puVar5 = fcn.00429635();\n                        uVar6 = *puVar5;\n                        var_ch = fcn.0044422d();\n                        if ((var_ch & 0x20000) != 0) {\n                            return uVar6;\n                        }\n                    }\n                }\n                if ((var_ch & 0x8000000) == 0) {\n                    return uVar6;\n                }\n            } while (var_4h != NULL);\n        }\n    }\n    return 0;\n}\n",
        "token_count": 596
    },
    "004445dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004445dc(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int32_t in_ECX;\n    uint *puVar6;\n    uint var_8h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.USER32.dll_SendMessageA;\n    if (*(in_ECX + 0x48) == 0) {\n        return;\n    }\n    if (arg_8h == NULL) {\n        return;\n    }\n    if ((arg_8h[2] == 0) ||\n       (iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(*arg_8h, 0xf0, 0, 0),  puVar4 = arg_8h,  iVar2 != 1)) {\n        puVar3 = fcn.0043eebf(arg_8h, 0);\n        puVar6 = &arg_8h;\n        arg_8h = puVar3;\n        fcn.0042964f(puVar6);\n        do {\n            if (arg_8h == NULL) {\ncode_r0x00444681:\n                arg_8h = puVar3;\n                fcn.00429635(&arg_8h, puVar6);\n                while( true ) {\n                    if (arg_8h == NULL) {\n                        return;\n                    }\n                    puVar4 = fcn.00429635(&arg_8h);\n                    puVar4 = *puVar4;\n                    if ((puVar4[2] != 0) && (iVar2 = (*pcVar1)(*puVar4, 0xf0, 0, 0),  iVar2 == 1)) break;\n                    uVar5 = fcn.0044422d();\n                    if ((uVar5 & 0x20000) != 0) {\n                        return;\n                    }\n                }\n                break;\n            }\n            puVar6 = &arg_8h;\n            puVar4 = fcn.0042964f();\n            puVar4 = *puVar4;\n            uVar5 = fcn.0044422d();\n            if ((uVar5 & 0x20000) != 0) goto code_r0x00444681;\n        } while ((puVar4[2] == 0) || (iVar2 = (*pcVar1)(*puVar4, 0xf0, 0, 0),  iVar2 != 1));\n    }\n    (*pcVar1)(*puVar4, 0xf1, 0, 0);\n    return;\n}\n",
        "token_count": 590
    },
    "004446ec": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: lpString2\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004446ec(uint lpString1, uint iMaxLength)\n\n{\n    uint uVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint lpString2;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    if (*(extraout_ECX + 0x4c) == 0) {\n        uVar1 = (*_sym.imp.USER32.dll_GetWindowTextA)(*(extraout_ECX + 0x1c), *(unaff_EBP + 8), *(unaff_EBP + 0xc));\n    }\n    else {\n        piVar2 = fcn.00444854();\n        iVar3 = (**(*piVar2 + 0xc))();\n        *(unaff_EBP + -0x10) = iVar3 + 0x10;\n        iVar3 = **(extraout_ECX + 0x4c);\n        *(unaff_EBP + -4) = 0;\n        (**(iVar3 + 0x8c))(unaff_EBP + -0x10);\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(*(unaff_EBP + 8), *(unaff_EBP + -0x10), *(unaff_EBP + 0xc));\n        uVar1 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + 8));\n        fcn.00421110();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar1;\n}\n",
        "token_count": 415
    },
    "00444912": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "contain loop"
        ],
        "decompiled_code": "\nuint __thiscall fcn.00444912(int32_t param_1, int32_t param_2)\n\n{\n    if (param_2 != 0) {\n        for (; param_1 != 0; param_1 = *(param_1 + 0x10)) {\n            if (param_1 == param_2) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 91
    },
    "00444d5a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00444d5a(void)\n\n{\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CFile.0;\n    *(unaff_EBP + -4) = 0;\n    if ((extraout_ECX[1] != 0xffffffff) && (extraout_ECX[2] != NULL)) {\n        fcn.00444cb9();\n    }\n    fcn.00421110();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 194
    },
    "00445295": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00445295(int32_t param_1)\n\n{\n    uint *puVar1;\n    uint var_ch;\n    int32_t var_8h;\n    int32_t var_4h;\n    \n    if (param_1 != 0) {\n        var_8h = -(*(param_1 + 0x44) != 0);\n        while (var_8h != 0) {\n            fcn.0043f35c(&var_8h, &var_ch, &var_4h);\n            puVar1 = *(param_1 + 0x58) + var_4h;\n            *puVar1 = 0;\n            if (*(param_1 + 0x5c) == 2) {\n                puVar1[1] = 0;\n            }\n            (**(param_1 + 0x18))(var_4h);\n        }\n        fcn.0043f266();\n        fcn.004315e8();\n    }\n    return;\n}\n",
        "token_count": 222
    },
    "004452f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nbool __cdecl fcn.004452f8(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    uint uVar5;\n    \n    iVar1 = fcn.00449a0d();\n    if ((*(iVar1 + 0x10) != 0) && (iVar2 = *(iVar1 + 0x10) + -1,  *(iVar1 + 0x10) = iVar2,  iVar2 == 0)) {\n        if (arg_8h != 0) {\n            if (((arg_8h != -1) && (iVar2 = fcn.0043f753(),  iVar2 != 0)) && (*(iVar2 + 0x38) != NULL)) {\n                (**(iVar2 + 0x38))(0, 0);\n            }\n            fcn.00445295();\n            fcn.00445295();\n            fcn.00445295();\n            fcn.00445295();\n            fcn.00445295();\n        }\n        iVar2 = fcn.004499e7();\n        iVar2 = *(iVar2 + 4);\n        iVar3 = fcn.00449bca();\n        if ((((iVar3 != 0) && (iVar2 != 0)) &&\n            ((*(iVar3 + 0xc) == 0 || (uVar4 = fcn.004348aa(*(iVar3 + 0xc)),  uVar4 < *(iVar2 + 0x94))))) &&\n           (*(iVar2 + 0x94) != 0)) {\n            arg_8h = 0;\n            if (*(iVar3 + 0xc) != 0) {\n                arg_8h = fcn.004348aa(*(iVar3 + 0xc));\n                fcn.0043360e(*(iVar3 + 0xc));\n            }\n            iVar2 = fcn.004335fc(*(iVar2 + 0x94));\n            *(iVar3 + 0xc) = iVar2;\n            if ((iVar2 == 0) && (arg_8h != 0)) {\n                uVar5 = fcn.004335fc(arg_8h);\n                *(iVar3 + 0xc) = uVar5;\n            }\n        }\n    }\n    return *(iVar1 + 0x10) != 0;\n}\n",
        "token_count": 525
    },
    "004454bb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004454bb(int32_t arg_8h)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    uint16_t *puVar4;\n    uint32_t uVar5;\n    bool bVar6;\n    \n    bVar6 = *(arg_8h + 2) == -1;\n    iVar2 = fcn.00445470(arg_8h);\n    iVar3 = fcn.004453f1(arg_8h);\n    if (iVar3 != 0) {\n        iVar2 = iVar2 + (bVar6 * 2 + 1) * 2;\n        iVar3 = fcn.00434299(iVar2);\n        iVar2 = iVar2 + 2 + iVar3 * 2;\n    }\n    if (bVar6) {\n        uVar1 = *(arg_8h + 0x10);\n    }\n    else {\n        uVar1 = *(arg_8h + 8);\n    }\n    if (uVar1 != 0) {\n        uVar5 = uVar1;\n        do {\n            puVar4 = (iVar2 + 3U & 0xfffffffc) + (-bVar6 & 6) + 0x12;\n            if (*puVar4 == 0xffff) {\n                puVar4 = puVar4 + 2;\n            }\n            else {\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                } while (uVar1 != 0);\n            }\n            if (*puVar4 == 0xffff) {\n                puVar4 = puVar4 + 2;\n            }\n            else {\n                do {\n                    uVar1 = *puVar4;\n                    puVar4 = puVar4 + 1;\n                } while (uVar1 != 0);\n            }\n            uVar1 = *puVar4;\n            if ((uVar1 != 0) && (!bVar6)) {\n                uVar1 = uVar1 - 2;\n            }\n            uVar5 = uVar5 - 1;\n            iVar2 = puVar4 + uVar1 + 2;\n        } while (uVar5 != 0);\n    }\n    return iVar2 - arg_8h;\n}\n",
        "token_count": 507
    },
    "0044557e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044557e(uint lpMultiByteStr, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint32_t *puVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    ushort *puVar5;\n    uint32_t arg_ch_00;\n    uint *in_ECX;\n    int32_t iVar6;\n    int16_t iVar7;\n    uint32_t arg_8h;\n    bool bVar8;\n    uint var_54h;\n    uint hMem;\n    uint var_4ch;\n    uint var_48h;\n    uint lpWideCharStr;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    if (in_ECX[1] != 0) {\n        puVar2 = (*_sym.imp.KERNEL32.dll_GlobalLock)(*in_ECX);\n        bVar8 = *(puVar2 + 2) == -1;\n        iVar3 = fcn.004453f1(puVar2);\n        iVar1 = bVar8 * 2 + 1;\n        if (bVar8) {\n            puVar2[3] = puVar2[3] | 0x40;\n        }\n        else {\n            *puVar2 = *puVar2 | 0x40;\n        }\n        iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(lpMultiByteStr);\n        if (iVar4 < 0x20) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0, 0, lpMultiByteStr, 0xffffffff, &lpWideCharStr, 0x20)\n            ;\n            iVar4 = iVar1 * 2 + iVar4 * 2;\n            puVar5 = fcn.00445470(puVar2);\n            iVar6 = 0;\n            if (iVar3 != 0) {\n                iVar3 = fcn.00434299(puVar5 + iVar1);\n                iVar6 = iVar1 * 2 + 2 + iVar3 * 2;\n            }\n            arg_ch_00 = iVar6 + 3 + puVar5 & 0xfffffffc;\n            arg_8h = puVar5 + iVar4 + 3 & 0xfffffffc;\n            if (bVar8) {\n                iVar7 = *(puVar2 + 4);\n            }\n            else {\n                iVar7 = *(puVar2 + 2);\n            }\n            if ((iVar4 != iVar6) && (iVar7 != 0)) {\n                fcn.00433010(arg_8h, arg_ch_00, puVar2 + (in_ECX[1] - arg_ch_00));\n            }\n            *puVar5 = arg_ch;\n            fcn.00433010(puVar5 + iVar1, &lpWideCharStr, iVar4 + iVar1 * -2);\n            in_ECX[1] = in_ECX[1] + (arg_8h - arg_ch_00);\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(*in_ECX);\n            in_ECX[2] = 0;\n        }\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 703
    },
    "004456b6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004456b6(uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    char *lpMultiByteStr;\n    uint var_44h;\n    int32_t lpvObject;\n    uint var_24h;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.GDI32.dll_GetStockObject;\n    uVar4 = 10;\n    var_4h = *0x45c1a8;\n    lpMultiByteStr = \"System\";\n    iVar2 = (*_sym.imp.GDI32.dll_GetStockObject)(0x11);\n    if (iVar2 == 0) {\n        iVar2 = (*pcVar1)(0xd);\n        if (iVar2 == 0) goto code_r0x0044572f;\n    }\n    iVar2 = (*_sym.imp.GDI32.dll_GetObjectA)(iVar2, 0x3c, &lpvObject);\n    if (iVar2 != 0) {\n        lpMultiByteStr = &var_24h;\n        uVar3 = (*_sym.imp.USER32.dll_GetDC)(0);\n        if (lpvObject < 0) {\n            lpvObject = -lpvObject;\n        }\n        uVar4 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(uVar3, 0x5a);\n        uVar4 = (*_sym.imp.KERNEL32.dll_MulDiv)(lpvObject, 0x48, uVar4);\n        (*_sym.imp.USER32.dll_ReleaseDC)(0, uVar3);\n    }\ncode_r0x0044572f:\n    if (arg_8h == 0) {\n        arg_8h = uVar4;\n    }\n    fcn.0044557e(lpMultiByteStr, arg_8h);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 425
    },
    "004457e7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.004457e7(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    iVar1 = fcn.00449a0d();\n    if ((*(iVar1 + 0x18) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0043f70c(0x446a14);\n        iVar3 = fcn.0043f71e(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0044514f(0x451ec4, 0x44a230, 0x4495bf, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x18) = uVar4;\n        fcn.0043f70c(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x18);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 366
    },
    "00445c36": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00445c36(int32_t param_1, uint param_2)\n\n{\n    uint arg_8h;\n    int32_t arg_10h;\n    \n    if (param_1 != 0) {\n        arg_10h = param_1;\n        arg_8h = fcn.004458cb(param_1, param_1, param_2);\n        fcn.00445bf0(arg_8h, param_1, arg_10h);\n    }\n    return;\n}\n",
        "token_count": 112
    },
    "00446458": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.00446458(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    iVar1 = fcn.00449a0d();\n    if ((*(iVar1 + 0x1c) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0043f70c(0x446a14);\n        iVar3 = fcn.0043f71e(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0044514f(0x4512c8, 0x449608, 0x4495bf, 4, 2);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x1c) = uVar4;\n        fcn.0043f70c(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x1c);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 368
    },
    "0044654a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044654a(code **param_1)\n\n{\n    uint uVar1;\n    \n    *param_1 = vtable.CDC.0;\n    if (param_1[1] != NULL) {\n        uVar1 = fcn.00446519();\n        (*_sym.imp.GDI32.dll_DeleteDC)(uVar1);\n    }\n    return;\n}\n",
        "token_count": 85
    },
    "0044673f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint __cdecl fcn.0044673f(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    uint uVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    iVar1 = fcn.00449a0d();\n    if ((*(iVar1 + 0x20) == 0) && (*(unaff_EBP + 8) != 0)) {\n        uVar2 = fcn.0043f70c(0x446a14);\n        iVar3 = fcn.0043f71e(0x60);\n        *(unaff_EBP + 8) = iVar3;\n        *(unaff_EBP + -4) = 0;\n        if (iVar3 == 0) {\n            uVar4 = 0;\n        }\n        else {\n            uVar4 = fcn.0044514f(0x451228, 0x449624, 0x4495bf, 4, 1);\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(iVar1 + 0x20) = uVar4;\n        fcn.0043f70c(uVar2);\n    }\n    uVar2 = *(iVar1 + 0x20);\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar2;\n}\n",
        "token_count": 364
    },
    "00446b15": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00446b15(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t var_8h;\n    uint32_t var_4h;\n    \n    if ((arg_ch == 0) || (arg_8h == 0)) {\n        iVar1 = 0;\n    }\n    else {\n        if ((*(in_ECX + 0x18) & 1) == 0) {\n            fcn.004470d8(4, *(in_ECX + 0x14));\n        }\n        uVar3 = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < uVar3) {\n            uVar3 = arg_ch;\n        }\n        fcn.00431700(arg_8h, *(in_ECX + 0x28), uVar3);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar3;\n        arg_8h = arg_8h + uVar3;\n        uVar3 = arg_ch - uVar3;\n        if (uVar3 != 0) {\n            iVar1 = uVar3 - uVar3 % *(in_ECX + 0x20);\n            var_8h = 0;\n            var_4h = iVar1;\n            do {\n                iVar2 = (**(**(in_ECX + 0x24) + 0x34))(arg_8h, var_4h);\n                arg_8h = arg_8h + iVar2;\n                var_8h = var_8h + iVar2;\n                var_4h = var_4h - iVar2;\n                if (iVar2 == 0) break;\n            } while (var_4h != 0);\n            uVar3 = uVar3 - var_8h;\n            if ((uVar3 != 0) && (var_8h == iVar1)) {\n                uVar4 = 0;\n                if (*(in_ECX + 8) == 0) {\n                    if ((*(in_ECX + 0xc) != 0) || (var_4h = *(in_ECX + 0x20),  *(in_ECX + 0x20) < uVar3)) {\n                        var_4h = uVar3;\n                    }\n                    var_8h = *(in_ECX + 0x30);\n                    do {\n                        iVar1 = (**(**(in_ECX + 0x24) + 0x34))(var_8h, var_4h);\n                        var_8h = var_8h + iVar1;\n                        var_4h = var_4h - iVar1;\n                        uVar4 = uVar4 + iVar1;\n                        if ((iVar1 == 0) || (var_4h == 0)) break;\n                    } while (uVar4 < uVar3);\n                    iVar1 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x2c) = iVar1 + uVar4;\n                }\n                else {\n                    (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                    iVar1 = *(in_ECX + 0x30);\n                }\n                uVar4 = *(in_ECX + 0x2c) - iVar1;\n                *(in_ECX + 0x28) = iVar1;\n                if (uVar3 < uVar4) {\n                    uVar4 = uVar3;\n                }\n                fcn.00431700(arg_8h, iVar1, uVar4);\n                *(in_ECX + 0x28) = *(in_ECX + 0x28) + uVar4;\n                uVar3 = uVar3 - uVar4;\n            }\n        }\n        iVar1 = arg_ch - uVar3;\n    }\n    return iVar1;\n}\n",
        "token_count": 930
    },
    "00446cb9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00446cb9(uint32_t arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    uint32_t arg_8h_00;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint unaff_EBX;\n    int32_t iVar4;\n    uint unaff_ESI;\n    int32_t iVar6;\n    uint var_8h;\n    uint32_t var_4h;\n    uint32_t uVar5;\n    \n    if ((*(in_ECX + 0x18) & 1) != 0) {\n        uVar5 = *(in_ECX + 0x28);\n        piVar1 = in_ECX + 0x2c;\n        var_4h = *piVar1 - uVar5;\n        uVar2 = arg_8h + var_4h;\n        if (*(in_ECX + 8) == 0) {\n            arg_8h_00 = *(in_ECX + 0x30);\n            if (arg_8h_00 < uVar5) {\n                if (0 < var_4h) {\n                    fcn.00433010(arg_8h_00, uVar5, var_4h);\n                    arg_8h_00 = *(in_ECX + 0x30);\n                    *(in_ECX + 0x28) = arg_8h_00;\n                    *piVar1 = arg_8h_00 + var_4h;\n                }\n                uVar5 = arg_8h;\n                if (*(in_ECX + 0xc) == 0) {\n                    uVar5 = *(in_ECX + 0x20);\n                }\n                iVar4 = uVar5 - var_4h;\n                iVar6 = var_4h + arg_8h_00;\n                do {\n                    iVar3 = (**(**(in_ECX + 0x24) + 0x34))(iVar6, iVar4);\n                    var_4h = var_4h + iVar3;\n                    iVar6 = iVar6 + iVar3;\n                    iVar4 = iVar4 - iVar3;\n                    if ((iVar3 == 0) || (iVar4 == 0)) break;\n                } while (var_4h < arg_8h);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n                *(in_ECX + 0x2c) = *(in_ECX + 0x30) + var_4h;\n            }\n        }\n        else {\n            if (var_4h != 0) {\n                (**(**(in_ECX + 0x24) + 0x28))(-var_4h, -var_4h >> 0x1f, 1);\n            }\n            (**(**(in_ECX + 0x24) + 0x50))(0, *(in_ECX + 0x20), in_ECX + 0x30, piVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x30);\n        }\n        if (uVar2 <= *(in_ECX + 0x2c) - *(in_ECX + 0x28)) {\n            return;\n        }\n        unaff_EBX = 0;\n        unaff_ESI = 3;\n    }\n    fcn.004470d8(unaff_ESI, unaff_EBX);\n    return;\n}\n",
        "token_count": 764
    },
    "00446daf": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00446daf(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    int32_t in_ECX;\n    uint32_t arg_10h;\n    int32_t iVar1;\n    \n    if ((arg_ch != 0) && (arg_8h != 0)) {\n        if ((~*(in_ECX + 0x18) & 1) == 0) {\n            fcn.004470d8(2, *(in_ECX + 0x14));\n        }\n        arg_10h = *(in_ECX + 0x2c) - *(in_ECX + 0x28);\n        if (arg_ch < arg_10h) {\n            arg_10h = arg_ch;\n        }\n        fcn.00431700(*(in_ECX + 0x28), arg_8h, arg_10h);\n        *(in_ECX + 0x28) = *(in_ECX + 0x28) + arg_10h;\n        arg_ch = arg_ch - arg_10h;\n        if (arg_ch != 0) {\n            fcn.00446c42();\n            iVar1 = arg_ch - arg_ch % *(in_ECX + 0x20);\n            (**(**(in_ECX + 0x24) + 0x38))(arg_8h + arg_10h, iVar1);\n            if (*(in_ECX + 8) != 0) {\n                (**(**(in_ECX + 0x24) + 0x50))(1, *(in_ECX + 0x20), in_ECX + 0x30, in_ECX + 0x2c);\n                *(in_ECX + 0x28) = *(in_ECX + 0x30);\n            }\n            fcn.00431700(*(in_ECX + 0x28), arg_8h + arg_10h + iVar1, arg_ch - iVar1);\n            *(in_ECX + 0x28) = *(in_ECX + 0x28) + (arg_ch - iVar1);\n        }\n    }\n    return;\n}\n",
        "token_count": 468
    },
    "00446ebb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.00446ebb(void)\n\n{\n    int32_t extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *(unaff_EBP + -4) = 0;\n    if ((*(extraout_ECX + 0x24) != 0) && ((*(extraout_ECX + 0x18) & 2) == 0)) {\n        fcn.00446da1();\n    }\n    fcn.00446ad3();\n    fcn.00421110();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 200
    },
    "00447252": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00447252(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = fcn.00427fdc();\n    if (piVar1 != NULL) {\n        iVar2 = (**(*piVar1 + 0x120))();\n        if ((iVar2 != 0) && (piVar1[0x1f] != 0)) {\n    // WARNING: Could not recover jumptable at 0x00447278. Too many branches\n    // WARNING: Treating indirect jump as call\n            (**(*piVar1[0x1f] + 100))();\n            return;\n        }\n    }\n    return;\n}\n",
        "token_count": 152
    },
    "00447450": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00447383)\n// WARNING: Removing unreachable block (ram,0x004473d4)\n\nvoid fcn.00447450(uint param_1, uint32_t param_2, int32_t param_3)\n\n{\n    int32_t *piVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t iStack276;\n    int32_t iStack272;\n    uchar auStack268 [259];\n    uchar uStack9;\n    uint uStack8;\n    \n    uStack8 = 0x447458;\n    iVar4 = fcn.004499e7();\n    if (*(iVar4 + 4) != NULL) {\n    // WARNING: Could not recover jumptable at 0x00447464. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**(**(iVar4 + 4) + 0x98))();\n        return;\n    }\n    uStack8 = *0x45c1a8;\n    fcn.00447252(0);\n    iVar4 = fcn.0044727f(0, &stack0xfffffef0);\n    if (iVar4 != iStack272) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iVar4, 1);\n    }\n    if ((iVar4 == 0) || (piVar1 = (*_sym.imp.USER32.dll_SendMessageA)(iVar4, 0x376, 0, 0),  piVar1 == NULL)) {\n        piVar1 = NULL;\n    }\n    iStack276 = 0;\n    if ((piVar1 != NULL) && (iStack276 = *piVar1,  param_3 != 0)) {\n        *piVar1 = param_3 + 0x30000;\n    }\n    if (((param_2 & 0xf0) == 0) && ((uVar2 = param_2 & 0xf,  uVar2 < 2 || ((2 < uVar2 && (uVar2 < 5)))))) {\n        param_2 = param_2 | 0x30;\n    }\n    auStack268[0] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, &stack0xfffffef4, 0x104);\n    if (iVar3 == 0x104) {\n        uStack9 = 0;\n    }\n    (*_sym.imp.USER32.dll_MessageBoxA)(iVar4, param_1, &stack0xfffffef4, param_2);\n    if (piVar1 != NULL) {\n        *piVar1 = iStack276;\n    }\n    if (iStack272 != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(iStack272, 1);\n    }\n    fcn.00447252(1);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 646
    },
    "0044750a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044750a(uint lpAppName, uint lpValueName, uint arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    uint lpString;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    if (*(in_ECX + 0x50) == 0) {\n        (*_sym.imp.USER32.dll_wsprintfA)(&lpString, 0x450180, arg_10h);\n        (*_sym.imp.KERNEL32.dll_WritePrivateProfileStringA)(lpAppName, lpValueName, &lpString, *(in_ECX + 100));\n    }\n    else {\n        iVar1 = fcn.00448d4f(lpAppName);\n        if (iVar1 != 0) {\n            (*_sym.imp.ADVAPI32.dll_RegSetValueExA)(iVar1, lpValueName, 0, 4, &arg_10h, 4);\n            (*_sym.imp.ADVAPI32.dll_RegCloseKey)(iVar1);\n        }\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 249
    },
    "0044758c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044758c(int32_t arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    int32_t in_ECX;\n    \n    iVar1 = arg_8h;\n    fcn.00443fe6(arg_8h, &arg_8h);\n    if (arg_8h == 0) {\n        iVar2 = fcn.00443faf(iVar1);\n        if (iVar2 == 0) {\n            fcn.0043e101();\n        }\n    }\n    *(in_ECX + 0xc) = 0;\n    *(in_ECX + 8) = iVar1;\n    return arg_8h;\n}\n",
        "token_count": 157
    },
    "004475cb": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.004475cb(int32_t *param_1)\n\n{\n    int32_t *hWnd;\n    \n    hWnd = param_1;\n    if ((*param_1 != 0) && (param_1[2] != 0)) {\n        fcn.00443fe6(param_1[2], &hWnd);\n        if (hWnd != NULL) {\n            (*_sym.imp.USER32.dll_SetFocus)(hWnd);\n            if (param_1[3] != 0) {\n                (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xb1, 0, 0xffffffff);\n            }\n        }\n    }\n    fcn.00446130();\n    return;\n}\n",
        "token_count": 158
    },
    "0044761a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044761a(int32_t *hWnd, uint arg_ch, int32_t *arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    \n    piVar1 = hWnd;\n    fcn.0044758c(arg_ch);\n    fcn.00443fe6(arg_ch, &hWnd);\n    if (*piVar1 == 0) {\n        if ((*arg_10h < 0) || (2 < *arg_10h)) {\n            *arg_10h = 0;\n        }\n        (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xf1, *arg_10h, 0);\n    }\n    else {\n        iVar2 = (*_sym.imp.USER32.dll_SendMessageA)(hWnd, 0xf0, 0, 0);\n        *arg_10h = iVar2;\n    }\n    return;\n}\n",
        "token_count": 206
    },
    "0044767d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044767d(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    iVar2 = arg_10h;\n    if (*(arg_10h + 0x1c) != 0) {\n        return;\n    }\n    iVar1 = fcn.00443f8d();\n    if (iVar1 != 0) {\n        return;\n    }\n    fcn.0044758c(arg_ch);\n    fcn.00443fe6(arg_ch, &arg_10h);\n    if (arg_10h != 0) {\n        iVar1 = fcn.00442aa8(arg_10h);\n        if (iVar1 == 0) {\n            fcn.0043e101();\n        }\n        if (arg_10h != 0) {\n            iVar1 = *(arg_8h + 4);\n            iVar2 = (*_sym.imp.USER32.dll_GetParent)(*(iVar2 + 0x1c));\n            if (*(iVar1 + 0x1c) == iVar2) {\n                return;\n            }\n            arg_ch = 0;\n            goto code_r0x004476f8;\n        }\n    }\n    iVar2 = fcn.00443faf(arg_ch);\n    if (iVar2 == 0) {\n        return;\n    }\n    iVar1 = *(arg_8h + 4);\ncode_r0x004476f8:\n    fcn.00444208(iVar1, arg_ch);\n    return;\n}\n",
        "token_count": 346
    },
    "0044771d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044771d(int32_t *arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h)\n\n{\n    uint arg_10h_00;\n    uint hWnd;\n    int32_t iVar1;\n    uint lpString;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    hWnd = fcn.00447706(arg_ch);\n    arg_10h_00 = arg_18h;\n    if (*arg_8h == 0) {\n        fcn.00432f81(&lpString, arg_10h, &arg_18h);\n        fcn.00446963(hWnd, &lpString);\n    }\n    else {\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, &lpString, 0x40);\n        iVar1 = fcn.004338f4(&lpString, arg_10h, arg_10h_00);\n        if (iVar1 != 1) {\n            fcn.00447472(arg_14h, 0, 0xffffffff);\n            fcn.004475cb();\n        }\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 274
    },
    "004477a6": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004477a6(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    if (*arg_8h == 0) {\n        arg_10h = *arg_10h;\n    }\n    fcn.0044771d(arg_8h, arg_ch, 0x450180, 0xf110, arg_10h);\n    return;\n}\n",
        "token_count": 94
    },
    "004477d5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004477d5(int32_t *arg_8h, uint arg_ch, uint *arg_10h)\n\n{\n    uint hWnd;\n    int32_t iVar1;\n    uint uVar2;\n    \n    hWnd = fcn.00447706(arg_ch);\n    if (*arg_8h == 0) {\n        fcn.00446963(hWnd, *arg_10h);\n    }\n    else {\n        iVar1 = (*_sym.imp.USER32.dll_GetWindowTextLengthA)(hWnd);\n        uVar2 = fcn.00428c19(iVar1, iVar1 + 1);\n        (*_sym.imp.USER32.dll_GetWindowTextA)(hWnd, uVar2);\n        fcn.00427fef(0xffffffff);\n    }\n    return;\n}\n",
        "token_count": 171
    },
    "00447cca": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447cca(int32_t *arg_8h, uint8_t *arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    iVar4 = 0;\n    uVar1 = *arg_ch;\n    puVar5 = arg_ch;\n    while (uVar1 != 0) {\n        if (*puVar5 == 0x25) {\n            uVar1 = puVar5[1];\n            if ((uVar1 < '1') || ('9' < uVar1)) {\n                if ((uVar1 < 'A') || ('Z' < uVar1)) goto code_r0x00447d23;\n                if (uVar1 < ':') goto code_r0x00447d01;\n                iVar3 = uVar1 + -0x38;\n            }\n            else {\ncode_r0x00447d01:\n                iVar3 = uVar1 + -0x31;\n            }\n            puVar5 = puVar5 + 2;\n            if (arg_14h <= iVar3) goto code_r0x00447d32;\n            iVar3 = *(arg_10h + iVar3 * 4);\n            if (iVar3 != 0) {\n                iVar3 = (*_sym.imp.KERNEL32.dll_lstrlenA)(iVar3);\n                iVar4 = iVar4 + iVar3;\n            }\n        }\n        else {\ncode_r0x00447d23:\n            if ((*(*puVar5 + 0x460781) & 4) != 0) {\n                iVar4 = iVar4 + 1;\n                puVar5 = puVar5 + 1;\n            }\n            puVar5 = puVar5 + 1;\ncode_r0x00447d32:\n            iVar4 = iVar4 + 1;\n        }\n        uVar1 = *puVar5;\n    }\n    puVar5 = fcn.004274a0(iVar4);\n    do {\n        while( true ) {\n            if (*arg_ch == 0) {\n                fcn.00427fef(puVar5 - *arg_8h);\n                return;\n            }\n            uVar1 = *arg_ch;\n            if (uVar1 == 0x25) break;\ncode_r0x00447d9d:\n            if ((*(uVar1 + 0x460781) & 4) != 0) {\n                *puVar5 = uVar1;\n                puVar5 = puVar5 + 1;\n                arg_ch = arg_ch + 1;\n            }\n            *puVar5 = *arg_ch;\n            puVar5 = puVar5 + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar2 = arg_ch[1];\n        if ((uVar2 < '1') || ('9' < uVar2)) {\n            if ((uVar2 < 'A') || ('Z' < uVar2)) goto code_r0x00447d9d;\n            if (uVar2 < ':') goto code_r0x00447d6d;\n            iVar4 = uVar2 + -0x38;\n        }\n        else {\ncode_r0x00447d6d:\n            iVar4 = uVar2 + -0x31;\n        }\n        arg_ch = arg_ch + 2;\n        if (iVar4 < arg_14h) {\n            iVar4 = *(arg_10h + iVar4 * 4);\n            if (iVar4 != 0) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar5, iVar4);\n                iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(puVar5);\n                puVar5 = puVar5 + iVar4;\n            }\n        }\n        else {\n            *puVar5 = 0x3f;\n            puVar5 = puVar5 + 1;\n        }\n    } while( true );\n}\n",
        "token_count": 893
    },
    "00447fbc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00447fbc(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x45f02c;\n    uVar3 = *0x45f028;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.004463ef(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, 0x9ec, uVar3);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], 0x9ec, uVar4);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 354
    },
    "0044804a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044804a(uint *arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    int32_t *in_ECX;\n    uint var_4h;\n    \n    uVar4 = *0x45f02c;\n    uVar3 = *0x45f028;\n    if (in_ECX != NULL) {\n        iVar2 = (*_sym.imp.GDI32.dll_GetMapMode)(in_ECX[2]);\n        pcVar1 = _sym.imp.GDI32.dll_GetDeviceCaps;\n        if ((iVar2 < 7) && (iVar2 != 1)) {\n            (**(*in_ECX + 0x34))(3);\n            fcn.00446386(arg_8h);\n            (**(*in_ECX + 0x34))(iVar2);\n            return;\n        }\n        uVar3 = (*_sym.imp.GDI32.dll_GetDeviceCaps)(in_ECX[2], 0x58);\n        uVar4 = (*pcVar1)(in_ECX[2], 0x5a);\n    }\n    pcVar1 = _sym.imp.KERNEL32.dll_MulDiv;\n    uVar3 = (*_sym.imp.KERNEL32.dll_MulDiv)(*arg_8h, uVar3, 0x9ec);\n    *arg_8h = uVar3;\n    uVar4 = (*pcVar1)(arg_8h[1], uVar4, 0x9ec);\n    arg_8h[1] = uVar4;\n    return;\n}\n",
        "token_count": 354
    },
    "004481c3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid __cdecl fcn.004481c3(uint arg_8h)\n\n{\n    code *pcVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint32_t var_28h;\n    int32_t lpType;\n    uint lpcbData;\n    uint32_t hKey;\n    uint32_t lParam;\n    uint lpData;\n    uint var_4h;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    var_4h = *0x45c1a8;\n    lParam = 0;\n    iVar5 = 0;\n    lpcbData = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"kernel32.dll\");\n    pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(lpcbData, \"GetUserDefaultUILanguage\");\n    if (pcVar2 == NULL) {\n        iVar6 = (*_sym.imp.KERNEL32.dll_GetVersion)();\n        if (iVar6 < 0) {\n            hKey = 0;\n            iVar6 = (*_sym.imp.ADVAPI32.dll_RegOpenKeyExA)\n                              (0x80000001, \"Control Panel\\\\Desktop\\\\ResourceLocale\", 0, 0x20019, &hKey);\n            if (iVar6 == 0) {\n                lpcbData = 0x10;\n                iVar6 = (*_sym.imp.ADVAPI32.dll_RegQueryValueExA)(hKey, 0, 0, &lpType, &lpData, &lpcbData);\n                if (((iVar6 == 0) && (lpType == 1)) &&\n                   (iVar6 = fcn.004338f4(&lpData, 0x44fadc, &var_28h), \n                   pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale,  iVar6 == 1)) {\n                    lParam = var_28h;\n                    var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(var_28h & 0xffff);\n                    var_38h = (*pcVar1)(var_28h & 0x3ff);\n                    iVar5 = 2;\n                }\n                (*_sym.imp.ADVAPI32.dll_RegCloseKey)(hKey);\n            }\n        }\n        else {\n            iVar6 = (*pcVar1)(\"ntdll.dll\");\n            if (iVar6 != 0) {\n                lParam = 0;\n                (*_sym.imp.KERNEL32.dll_EnumResourceLanguagesA)(iVar6, 0x10, 1, 0x4481ad, &lParam);\n                pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n                if (lParam != 0) {\n                    uVar4 = lParam & 0x3ff;\n                    var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(lParam & 0xffff);\n                    var_38h = (*pcVar1)(uVar4);\n                    iVar5 = 2;\n                }\n            }\n        }\n    }\n    else {\n        lParam = (*pcVar2)();\n        pcVar1 = _sym.imp.KERNEL32.dll_ConvertDefaultLocale;\n        hKey = lParam & 0x3ff;\n        var_3ch = (*_sym.imp.KERNEL32.dll_ConvertDefaultLocale)(lParam & 0xffff);\n        var_38h = (*pcVar1)(hKey);\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(lpcbData, \"GetSystemDefaultUILanguage\");\n        lParam = (*pcVar2)();\n        uVar4 = lParam & 0x3ff;\n        var_34h = (*pcVar1)(lParam & 0xffff);\n        var_30h = (*pcVar1)(uVar4);\n        iVar5 = 4;\n    }\n    (&var_3ch)[iVar5] = 0x800;\n    iVar6 = 0;\n    if (iVar5 != -1) {\n        do {\n            iVar3 = fcn.0044812e(arg_8h, (&var_3ch)[iVar6]);\n            if (iVar3 != 0) break;\n            iVar6 = iVar6 + 1;\n        } while (iVar6 < iVar5 + 1);\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 999
    },
    "00448655": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00448655(int32_t param_1)\n\n{\n    if (*(param_1 + 0x84) != NULL) {\n        (**(**(param_1 + 0x84) + 0x14))();\n    }\n    if (*(param_1 + 0x90) != 0) {\n        fcn.0044750a(\"Settings\", \"PreviewPages\", *(param_1 + 0x90));\n    }\n    return;\n}\n",
        "token_count": 104
    },
    "0044945e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044945e(code **param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    \n    *param_1 = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.2.0;\n    param_1[1] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.1.0;\n    param_1[4] = vtable.CMFCComObject_class_ATL::CAccessibleProxy_.0;\n    param_1[5] = 0xc0000001;\n    fcn.00429537();\n    iVar2 = fcn.004499e7();\n    iVar2 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(iVar2 + 0x2c);\n    if (iVar2 != 0) {\n        return;\n    }\n    iVar2 = fcn.004499e7();\n    if (*(iVar2 + 0x30) == 0) {\n        fcn.00447f3f(1);\n        iVar2 = fcn.004499e7();\n        iVar2 = *(iVar2 + 4);\n        if ((iVar2 == 0) || (*(iVar2 + 0x1c) == 0)) {\n            iVar2 = fcn.004499e7();\n            if (*(iVar2 + 0x14) == '\\0') {\n                fcn.0044c0ff(0);\n            }\n        }\n        else {\n            iVar1 = fcn.00444160();\n            if (iVar1 != 0) {\n    // WARNING: Could not recover jumptable at 0x00447f8c. Too many branches\n    // WARNING: Treating indirect jump as call\n                (**(**(iVar2 + 0x1c) + 0x60))();\n                return;\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 413
    },
    "00449810": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00449810(code **param_1)\n\n{\n    uint uVar1;\n    code *pcVar2;\n    \n    *param_1 = vtable.AFX_MODULE_THREAD_STATE.0;\n    if (param_1[0xf] != NULL) {\n        (**(*param_1[0xf] + 0x138))();\n    }\n    if (param_1[5] != NULL) {\n        (***param_1[5])(1);\n    }\n    if (param_1[6] != NULL) {\n        (***param_1[6])(1);\n    }\n    if (param_1[7] != NULL) {\n        (***param_1[7])(1);\n    }\n    if (param_1[8] != NULL) {\n        (***param_1[8])(1);\n    }\n    if (param_1[9] != NULL) {\n        (***param_1[9])(1);\n    }\n    pcVar2 = param_1[0xe];\n    if (pcVar2 != NULL) {\n        while (*(pcVar2 + 0xc) != 0) {\n            uVar1 = fcn.0043ee5b();\n            fcn.0043f749(uVar1);\n            pcVar2 = param_1[0xe];\n        }\n    }\n    if (param_1[0xc] != NULL) {\n        (**(*param_1[0xc] + 4))(1);\n    }\n    if (param_1[0xd] != NULL) {\n        (**(*param_1[0xd] + 4))(1);\n    }\n    if (param_1[0xe] != NULL) {\n        (**(*param_1[0xe] + 4))(1);\n    }\n    return;\n}\n",
        "token_count": 390
    },
    "00449a68": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00449a68(int32_t param_1)\n\n{\n    if (param_1 != 0) {\n    // WARNING: Could not recover jumptable at 0x00449a6f. Too many branches\n    // WARNING: Treating indirect jump as call\n        (*_sym.imp.KERNEL32.dll_LocalFree)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 84
    },
    "00449c40": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00449c40(int32_t *param_1)\n\n{\n    uint var_4h;\n    \n    if (*param_1 != 0) {\n        if (*param_1 != NULL) {\n            (****param_1)(1);\n        }\n    }\n    return;\n}\n",
        "token_count": 66
    },
    "00449e87": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00449e87(uint *arg_8h, int32_t arg_ch)\n\n{\n    uint *puVar1;\n    bool bVar2;\n    uint *in_ECX;\n    int32_t iVar3;\n    uint var_4h;\n    \n    iVar3 = 1;\n    bVar2 = true;\n    if (1 < arg_8h[2]) {\n        do {\n            if ((arg_ch == 0) || (*(in_ECX[4] + 4 + iVar3 * 8) == arg_ch)) {\n                puVar1 = *(arg_8h[3] + iVar3 * 4);\n                if (puVar1 != NULL) {\n                    (***puVar1)(1);\n                }\n                *(arg_8h[3] + iVar3 * 4) = 0;\n            }\n            else if (*(arg_8h[3] + iVar3 * 4) != 0) {\n                bVar2 = false;\n            }\n            iVar3 = iVar3 + 1;\n        } while (iVar3 < arg_8h[2]);\n        if (!bVar2) {\n            return;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(in_ECX + 7);\n    fcn.00449c78(arg_8h);\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(in_ECX + 7);\n    (*_sym.imp.KERNEL32.dll_LocalFree)(arg_8h[3]);\n    (***arg_8h)(1);\n    (*_sym.imp.KERNEL32.dll_TlsSetValue)(*in_ECX, 0);\n    return;\n}\n",
        "token_count": 361
    },
    "0044a00d": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0044a00d(int32_t param_1, uint param_2)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint unaff_retaddr;\n    \n    puVar3 = *0x45edd4;\n    if (*0x45edd4 != NULL) {\n        puVar1 = *0x45edd4 + 7;\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(puVar1);\n        if (param_1 == 0) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_TlsGetValue)(*puVar3);\n            if (iVar4 != 0) {\n                fcn.00449e87(iVar4, unaff_retaddr);\n            }\n        }\n        else {\n            iVar4 = puVar3[5];\n            while (iVar4 != 0) {\n                iVar2 = *(iVar4 + 4);\n                fcn.00449e87(iVar4, param_2);\n                iVar4 = iVar2;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(puVar1);\n        return;\n    }\n    return;\n}\n",
        "token_count": 263
    },
    "00449f75": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nint32_t __cdecl fcn.00449f75(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    if (*extraout_ECX == 0) {\n        if (*0x45edd4 == 0) {\n            *(unaff_EBP + -0x10) = 0x45edd8;\n            *(unaff_EBP + -4) = 0;\n            *0x45edd4 = fcn.00449cbf();\n            *(unaff_EBP + -4) = 0xffffffff;\n        }\n        iVar1 = fcn.00449a78();\n        *extraout_ECX = iVar1;\n    }\n    iVar1 = fcn.00449b84(*extraout_ECX);\n    if (iVar1 == 0) {\n        iVar1 = (**(unaff_EBP + 8))();\n        fcn.00449d64(*extraout_ECX, iVar1);\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return iVar1;\n}\n",
        "token_count": 326
    },
    "0044a09e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0044a09e(void)\n\n{\n    if (*0x45f008 == 0) {\n        *0x45f008 = 1;\n        (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(0x45ee54);\n    }\n    return *0x45f008;\n}\n",
        "token_count": 70
    },
    "0044a107": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0044a107(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    code *pcVar2;\n    \n    if (*0x45f008 == 0) {\n        fcn.0044a09e();\n    }\n    pcVar2 = _sym.imp.KERNEL32.dll_EnterCriticalSection;\n    piVar1 = param_1 * 4 + 0x45ee10;\n    if (*piVar1 == 0) {\n        (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(0x45ee54);\n        if (*piVar1 == 0) {\n            (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)(param_1 * 0x18 + 0x45ee70);\n            *piVar1 = *piVar1 + 1;\n        }\n        (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(0x45ee54);\n    }\n    (*pcVar2)(param_1 * 0x18 + 0x45ee70);\n    return;\n}\n",
        "token_count": 225
    },
    "0044a323": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t fcn.0044a323(int32_t param_1, uint param_2)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    \n    uVar1 = (*_sym.imp.SHLWAPI.dll_PathFindFileNameA)(param_1);\n    if (param_1 == 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)(uVar1);\n        iVar2 = iVar2 + 1;\n    }\n    else {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(param_1, uVar1, param_2);\n        iVar2 = 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 149
    },
    "0044a352": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044a352(int32_t param_1)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uchar *puVar3;\n    uint uVar4;\n    uchar *puVar5;\n    char *pcVar6;\n    uchar auStack784 [256];\n    uchar auStack528 [260];\n    uchar auStack268 [260];\n    uint uStack8;\n    \n    uStack8 = *0x45c1a8;\n    iVar1 = fcn.004499e7();\n    *(iVar1 + 8) = *(param_1 + 0x40);\n    *(iVar1 + 0xc) = *(param_1 + 0x40);\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(*(param_1 + 0x40), auStack528, 0x104);\n    if ((iVar2 == 0) || (iVar2 == 0x104)) {\n        fcn.00446130();\n    }\n    puVar3 = (*_sym.imp.SHLWAPI.dll_PathFindExtensionA)(auStack528);\n    if (puVar3 == NULL) {\n        fcn.00446130();\n    }\n    *puVar3 = 0;\n    iVar2 = fcn.0044a323(auStack528, auStack268, 0x104);\n    if (iVar2 != 0) {\n        fcn.00446130();\n    }\n    if (*(param_1 + 0x5c) == 0) {\n        uVar4 = fcn.00433b70(auStack268);\n        *(param_1 + 0x5c) = uVar4;\n    }\n    if (*(param_1 + 0x4c) == 0) {\n        iVar2 = fcn.004447fe(0xe000, auStack784, 0x100);\n        if (iVar2 == 0) {\n            puVar5 = *(param_1 + 0x5c);\n        }\n        else {\n            puVar5 = auStack784;\n        }\n        uVar4 = fcn.00433b70(puVar5);\n        *(param_1 + 0x4c) = uVar4;\n    }\n    *(iVar1 + 0x10) = *(param_1 + 0x4c);\n    if (*(param_1 + 0x60) == 0) {\n        if (*(param_1 + 0x68) == 1) {\n            pcVar6 = \".CHM\";\n        }\n        else {\n            pcVar6 = \".HLP\";\n        }\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(puVar3, pcVar6);\n        uVar4 = fcn.00433b70(auStack528);\n        *(param_1 + 0x60) = uVar4;\n        *puVar3 = 0;\n    }\n    if (*(param_1 + 100) == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcatA)(auStack268, \".INI\");\n        uVar4 = fcn.00433b70(auStack268);\n        *(param_1 + 100) = uVar4;\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 721
    },
    "0044a4a0": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0044a4a0(uint param_1, uint param_2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint unaff_ESI;\n    \n    pcVar1 = _sym.imp.KERNEL32.dll_SetErrorMode;\n    uVar2 = (*_sym.imp.KERNEL32.dll_SetErrorMode)(0);\n    (*pcVar1)(uVar2 | 0x8001);\n    iVar3 = fcn.004499e7();\n    *(iVar3 + 8) = unaff_ESI;\n    *(iVar3 + 0xc) = unaff_ESI;\n    iVar3 = fcn.004499e7();\n    iVar3 = *(iVar3 + 4);\n    if (iVar3 != 0) {\n        *(iVar3 + 0x44) = param_1;\n        *(iVar3 + 0x48) = param_2;\n        *(iVar3 + 0x40) = unaff_ESI;\n        fcn.0044a352();\n    }\n    iVar3 = fcn.004499e7();\n    if (*(iVar3 + 0x14) == '\\0') {\n        fcn.0043fbf4();\n    }\n    iVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"user32.dll\");\n    if (iVar3 != 0) {\n        *0x45e964 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"NotifyWinEvent\");\n    }\n    return 1;\n}\n",
        "token_count": 340
    },
    "0044a5af": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.0044a5af(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    fcn.0044af3f();\n    fcn.0044c18b();\n    fcn.00431643();\n    if (param_1 == 0) {\n        iVar1 = fcn.0043f753();\n        if (iVar1 != 0) {\n            if (*(iVar1 + 0x3c) != NULL) {\n                (**(**(iVar1 + 0x3c) + 4))(1);\n            }\n            *(iVar1 + 0x3c) = 0;\n        }\n        iVar1 = fcn.004499d7();\n        if (*(iVar1 + 0x100) == 1) {\n            (*_sym.imp.ole32.dll_CoFreeUnusedLibraries)();\n            (*_sym.imp.ole32.dll_OleUninitialize)();\n            *(iVar1 + 0x100) = 0;\n        }\n    }\n    return;\n}\n",
        "token_count": 221
    },
    "0044a89e": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.0044a89e(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    \n    if (param_1[1] == 0) {\n        return 0;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_InterlockedDecrement)(param_1 + 1);\n    if (iVar1 == 0) {\n        (**(*param_1 + 0x10))();\n    }\n    return iVar1;\n}\n",
        "token_count": 107
    },
    "0044a8dc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __thiscall fcn.0044a8dc(int32_t *param_1, int32_t *param_2)\n\n{\n    int32_t *piVar1;\n    int32_t **ppiVar2;\n    int32_t **ppiVar3;\n    \n    piVar1 = (**(*param_1 + 0x44))(param_2);\n    if (piVar1 == NULL) {\n        ppiVar2 = (**(*param_1 + 0x38))();\n        if ((((*0x451bfc == *param_2) && (param_2[1] == *0x451c00)) && (param_2[2] == *0x451c04)) &&\n           (param_2[3] == *0x451c08)) {\n            do {\n                for (piVar1 = ppiVar2[1]; *piVar1 != 0; piVar1 = piVar1 + 2) {\n                    if (*(piVar1[1] + param_1) != 0) {\n                        return piVar1[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        else {\n            do {\n                for (ppiVar3 = ppiVar2[1]; piVar1 = *ppiVar3,  piVar1 != NULL; ppiVar3 = ppiVar3 + 2) {\n                    if (((*piVar1 == *param_2) && (piVar1[1] == param_2[1])) &&\n                       ((piVar1[2] == param_2[2] && ((piVar1[3] == param_2[3] && (*(ppiVar3[1] + param_1) != 0)))))) {\n                        return ppiVar3[1] + param_1;\n                    }\n                }\n                ppiVar2 = *ppiVar2;\n            } while (ppiVar2 != NULL);\n        }\n        piVar1 = NULL;\n    }\n    return piVar1;\n}\n",
        "token_count": 455
    },
    "0044a98a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0044a98a(uint arg_8h)\n\n{\n    uint *puVar1;\n    int32_t *piVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t *in_ECX;\n    uint var_8h;\n    int32_t var_4h;\n    \n    piVar2 = (**(*in_ECX + 0x38))();\n    do {\n        for (piVar3 = piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {\n        }\n        for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {\n            puVar1 = *(in_ECX + *piVar3);\n            if (puVar1 != NULL) {\n                var_4h = 0;\n                iVar4 = (***puVar1)(puVar1, arg_8h, &var_4h);\n                if ((iVar4 == 0) && (var_4h != 0)) {\n                    return var_4h;\n                }\n            }\n        }\n        piVar2 = *piVar2;\n        if (piVar2 == NULL) {\n            return 0;\n        }\n    } while( true );\n}\n",
        "token_count": 294
    },
    "0044a9ea": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044a9ea(int32_t param_1)\n\n{\n    if (*(param_1 + 8) != 0) {\n        (**(**(param_1 + 8) + 4))(*(param_1 + 8));\n        return;\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedIncrement)(param_1 + 4);\n    return;\n}\n",
        "token_count": 87
    },
    "0044aaae": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.0044aaae(int32_t param_1, int32_t param_2)\n\n{\n    *(param_1 + 0x70) = param_2;\n    if (param_2 != 1) {\n        param_2 = ((param_2 != 2) - 1 & 3) - 1;\n    }\n    return param_2;\n}\n",
        "token_count": 89
    },
    "0044ab47": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __fastcall fcn.0044ab47(int32_t param_1)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int32_t hWnd;\n    \n    iVar2 = *(param_1 + 100);\n    if (iVar2 != 0) {\n        iVar2 = *(iVar2 + 0x1c);\n    }\n    hWnd = param_1;\n    uVar1 = fcn.0044727f(iVar2, &hWnd);\n    *(param_1 + 0x7c) = uVar1;\n    fcn.004433c1(param_1);\n    iVar2 = sub.oledlg.dll_OleUIBusyA(param_1 + 0x74);\n    fcn.00442131();\n    fcn.00442103();\n    if (hWnd != 0) {\n        (*_sym.imp.USER32.dll_EnableWindow)(hWnd, 1);\n    }\n    uVar1 = 2;\n    if (iVar2 != 2) {\n        if (iVar2 == 0x75) {\n            *(param_1 + 0xa0) = 1;\n        }\n        else {\n            if (iVar2 != 0x76) {\n                if (iVar2 == 0x77) {\n                    *(param_1 + 0xa0) = 3;\n                    return 1;\n                }\n                uVar1 = fcn.0044aaae(iVar2);\n            }\n            *(param_1 + 0xa0) = uVar1;\n        }\n        return 1;\n    }\n    return 2;\n}\n",
        "token_count": 346
    },
    "0044abf3": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.0044abf3(void)\n\n{\n    code *pcVar1;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    *extraout_ECX = vtable.CEnumArray.0;\n    pcVar1 = extraout_ECX[8];\n    *(unaff_EBP + -4) = 0;\n    if (pcVar1 != NULL) {\n        fcn.0044a89e();\n    }\n    if (extraout_ECX[0xc] != NULL) {\n        fcn.0043f749(extraout_ECX[9]);\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.0043fd45();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 245
    },
    "0044b289": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044b289(int32_t **param_1)\n\n{\n    int32_t *piVar1;\n    \n    piVar1 = *param_1;\n    if (piVar1 != NULL) {\n        if (param_1[1] != NULL) {\n            (**(*piVar1 + 8))(piVar1);\n        }\n        *param_1 = NULL;\n    }\n    return;\n}\n",
        "token_count": 93
    },
    "0044b2bc": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING (jumptable): Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_6ch\n// WARNING: Variable defined which should be unmapped: var_78h\n// WARNING: Variable defined which should be unmapped: var_68h\n// WARNING: Variable defined which should be unmapped: var_64h\n// WARNING: Variable defined which should be unmapped: var_60h\n// WARNING: Variable defined which should be unmapped: var_5ch\n\nvoid __cdecl fcn.0044b2bc(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch)\n\n{\n    char cVar1;\n    uint8_t uVar2;\n    uint16_t uVar3;\n    uint16_t *puVar4;\n    uint *puVar5;\n    code *pcVar6;\n    int16_t iVar7;\n    uint uVar8;\n    int32_t iVar9;\n    uint *puVar10;\n    int32_t iVar11;\n    uint32_t *puVar12;\n    int32_t *extraout_ECX;\n    int32_t *piVar13;\n    int32_t unaff_EBP;\n    ulong *puVar14;\n    char *pcVar15;\n    char *pcVar16;\n    uint *in_FS_OFFSET;\n    uint var_78h;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uchar auStack92 [4];\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint pvargDest;\n    uint pbstr;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint lpString;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    uint uStack4;\n    \n    uStack4 = 0x44b2c6;\n    fcn.00433928();\n    *(unaff_EBP + -0x28) = extraout_ECX;\n    uVar8 = (**0x45b0bc)();\n    iVar9 = *extraout_ECX;\n    *(unaff_EBP + -0x20) = uVar8;\n    if (iVar9 == 0) goto code_r0x0044b71d;\n    fcn.00433ba0(unaff_EBP + -0x4c, 0, 0x10);\n    pcVar16 = *(unaff_EBP + 0x18);\n    if (pcVar16 == NULL) {\n        iVar9 = *(unaff_EBP + -0x44);\n    }\n    else {\n        iVar9 = (*_sym.imp.KERNEL32.dll_lstrlenA)(pcVar16);\n        *(unaff_EBP + -0x44) = iVar9;\n    }\n    *(unaff_EBP + -0x1c) = 0xfffffffd;\n    if ((*(unaff_EBP + 0xc) & 0xc) != 0) {\n        *(unaff_EBP + -0x40) = 1;\n        *(unaff_EBP + -0x48) = unaff_EBP + -0x1c;\n    }\n    if (iVar9 != 0) {\n        iVar9 = fcn.0043f71e(iVar9 << 4);\n        *(unaff_EBP + -0x4c) = iVar9;\n        fcn.00433ba0(iVar9, 0, *(unaff_EBP + -0x44) << 4);\n        cVar1 = *pcVar16;\n        iVar9 = iVar9 + -0x10 + *(unaff_EBP + -0x44) * 0x10;\n        *(unaff_EBP + -0x14) = pcVar16;\n        *(unaff_EBP + -0x10) = iVar9;\n        if (cVar1 != '\\0') {\n            puVar14 = iVar9 + 8;\n            piVar13 = *(unaff_EBP + 0x1c) + -4;\n            *(unaff_EBP + -0x18) = puVar14;\n            *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + -8;\n            do {\n                uVar2 = **(unaff_EBP + -0x14);\n                puVar4 = *(unaff_EBP + -0x10);\n                *puVar4 = uVar2;\n                if ((uVar2 & 0x40) != 0) {\n                    *puVar4 = uVar2 & 0xffbf | 0x4000;\n                }\n                uVar3 = *puVar4;\n                if (0x4002 < uVar3) {\n    // switch table (19 cases) at 0x44b781\n                    switch(uVar3) {\n                    case 0x4003:\n                    case 0x4004:\n                    case 0x4005:\n                    case 0x4006:\n                    case 0x4007:\n                    case 0x4008:\n                    case 0x4009:\n                    case 0x400a:\n                    case 0x400c:\n                    case 0x400d:\n                    case 0x4010:\n                    case 0x4011:\n                    case 0x4012:\n                    case 0x4013:\n                    case 0x4014:\n                    case 0x4015:\n                        goto code_r0x0044b4f6;\n                    case 0x400b:\n                        *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                        puVar12 = piVar13[1];\n                        *puVar12 = -(*puVar12 != 0) & 0xffff;\n                        break;\n                    default:\n                        goto code_r0x0044b4ff;\n                    }\ncode_r0x0044b4fd:\n                    piVar13 = piVar13 + 1;\n                    *puVar14 = puVar12;\n                    goto code_r0x0044b4ff;\n                }\n                if (uVar3 == 0x4002) {\ncode_r0x0044b4f6:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    puVar12 = piVar13[1];\n                    goto code_r0x0044b4fd;\n                }\n    // switch table (20 cases) at 0x44b731\n                switch(uVar3) {\n                case 2:\n                case 0x12:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    iVar7 = *(piVar13 + 1);\n                    goto code_r0x0044b3c4;\n                case 3:\n                case 9:\n                case 10:\n                case 0xd:\n                case 0x13:\n                    goto code_r0x0044b4f6;\n                case 4:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 8;\n                    piVar13 = piVar13 + 2;\n                    *puVar14 = **(unaff_EBP + 0x1c);\n                    break;\n                case 5:\n                case 7:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 8;\n                    piVar13 = piVar13 + 2;\n                    *puVar14 = **(unaff_EBP + 0x1c);\n                    break;\n                case 6:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    piVar13 = piVar13 + 1;\n                    puVar10 = *piVar13;\n                    uVar8 = *puVar10;\n                    goto code_r0x0044b419;\n                case 8:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    piVar13 = piVar13 + 1;\n                    iVar9 = *piVar13;\n                    *(unaff_EBP + -0x18) = iVar9;\n                    iVar11 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(iVar9);\n                    iVar9 = *(unaff_EBP + -0x18);\n                    *puVar14 = iVar11;\n                    if ((iVar9 != 0) && (iVar11 == 0)) {\n                        do {\n                            fcn.0043e0e7();\ncode_r0x0044b450:\n                            *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                            piVar13 = piVar13 + 1;\n                            iVar9 = *piVar13;\n                            *(unaff_EBP + -0x18) = iVar9;\n                            if (iVar9 != 0) {\n                                iVar9 = (*_sym.imp.KERNEL32.dll_lstrlenA)(*(unaff_EBP + -0x18));\n                                *(unaff_EBP + -0x24) = iVar9 + 1;\n                                fcn.004316c0();\n                                iVar9 = fcn.00427f90(&stack0xffffffa4, *(unaff_EBP + -0x18), *(unaff_EBP + -0x24), \n                                                     *(unaff_EBP + -0x20));\n                            }\n                            iVar11 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(iVar9);\n                            iVar9 = *(unaff_EBP + -0x18);\n                            *puVar14 = iVar11;\n                        } while ((iVar9 != 0) && (iVar11 == 0));\n                        **(unaff_EBP + -0x10) = 8;\n                    }\n                    break;\n                case 0xb:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    iVar7 = -(piVar13[1] != 0);\ncode_r0x0044b3c4:\n                    piVar13 = piVar13 + 1;\n                    *puVar14 = iVar7;\n                    break;\n                case 0xc:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    puVar10 = *(unaff_EBP + -0x10);\n                    piVar13 = piVar13 + 1;\n                    puVar5 = *piVar13;\n                    *puVar10 = *puVar5;\n                    puVar10[1] = puVar5[1];\n                    puVar10[2] = puVar5[2];\n                    puVar10[3] = puVar5[3];\n                    puVar14 = *(unaff_EBP + -0x18);\n                    break;\n                case 0xe:\n                    goto code_r0x0044b450;\n                case 0x10:\n                case 0x11:\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + 4;\n                    piVar13 = piVar13 + 1;\n                    *puVar14 = *piVar13;\n                    break;\n                case 0x14:\n                case 0x15:\n                    puVar10 = *(unaff_EBP + 0x1c) + 8;\n                    uVar8 = *puVar10;\n                    *(unaff_EBP + 0x1c) = puVar10;\n                    piVar13 = piVar13 + 2;\ncode_r0x0044b419:\n                    *puVar14 = uVar8;\n                    *(puVar14 + 4) = puVar10[1];\n                }\ncode_r0x0044b4ff:\n                *(unaff_EBP + -0x10) = *(unaff_EBP + -0x10) + -0x10;\n                puVar14 = puVar14 + -2;\n                *(unaff_EBP + -0x14) = *(unaff_EBP + -0x14) + 1;\n                cVar1 = **(unaff_EBP + -0x14);\n                *(unaff_EBP + -0x18) = puVar14;\n            } while (cVar1 != '\\0');\n            pcVar16 = *(unaff_EBP + 0x18);\n        }\n    }\n    pcVar15 = NULL;\n    fcn.0043139e(unaff_EBP + -0x3c);\n    if (*(unaff_EBP + 0x10) != 0) {\n        pcVar15 = unaff_EBP + -0x3c;\n    }\n    fcn.00433ba0(unaff_EBP + -0x6c, 0, 0x20);\n    piVar13 = **(unaff_EBP + -0x28);\n    *(unaff_EBP + -0x2c) = 0xffffffff;\n    uVar8 = (**(*piVar13 + 0x18))\n                      (piVar13, *(unaff_EBP + 8), 0x453e3c, 0, *(unaff_EBP + 0xc), unaff_EBP + -0x4c, pcVar15, \n                       unaff_EBP + -0x6c, unaff_EBP + -0x2c);\n    *(unaff_EBP + 0x18) = uVar8;\n    if (*(unaff_EBP + -0x44) != 0) {\n        iVar9 = *(unaff_EBP + -0x44) * 0x10 + -0x10 + *(unaff_EBP + -0x4c);\n        cVar1 = *pcVar16;\n        pcVar15 = pcVar16;\n        while (cVar1 != '\\0') {\n            if ((*pcVar15 == '\\b') || (*pcVar15 == '\\x0e')) {\n                (*_sym.imp.OLEAUT32.dll_VariantCopy)(iVar9);\n            }\n            iVar9 = iVar9 + -0x10;\n            pcVar15 = pcVar15 + 1;\n            cVar1 = *pcVar15;\n        }\n    }\n    fcn.0043f749(*(unaff_EBP + -0x4c));\n    if (*(unaff_EBP + 0x18) < 0) {\n        (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x3c);\n        if (*(unaff_EBP + 0x18) == -0x7ffdfff7) {\n            if (*(unaff_EBP + -0x54) != 0) {\n                (**(unaff_EBP + -0x54))(unaff_EBP + -0x6c);\n            }\n            iVar9 = fcn.0043f71e(0x20);\n            *(unaff_EBP + 0x14) = iVar9;\n            *(unaff_EBP + -4) = 0;\n            if (iVar9 == 0) {\n                iVar9 = 0;\n            }\n            else {\n                iVar9 = fcn.0044c05c(0, 0, *(unaff_EBP + -0x6c));\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            pcVar6 = _sym.imp.OLEAUT32.dll_SysStringLen;\n            if (*(unaff_EBP + -0x68) != 0) {\n                fcn.0042aa55(*(unaff_EBP + -0x68));\n                (*pcVar6)(*(unaff_EBP + -0x68));\n            }\n            if (*(unaff_EBP + -100) != 0) {\n                fcn.0042aa55(*(unaff_EBP + -100));\n                (*pcVar6)(*(unaff_EBP + -100));\n            }\n            if (*(unaff_EBP + -0x60) != 0) {\n                fcn.0042aa55(*(unaff_EBP + -0x60));\n                (*pcVar6)(*(unaff_EBP + -0x60));\n            }\n            *(iVar9 + 0x10) = *(unaff_EBP + -0x5c);\n            *(iVar9 + 0x1c) = *(unaff_EBP + -0x50);\n            *(unaff_EBP + 0x14) = iVar9;\n            fcn.00433cb8(unaff_EBP + 0x14, unaff_EBP + 0x14);\n            goto code_r0x0044b662;\n        }\n        iVar9 = *(unaff_EBP + 0x18);\ncode_r0x0044b692:\n        fcn.0044a840(iVar9);\n    }\n    else {\ncode_r0x0044b662:\n        pcVar15 = *(unaff_EBP + 0x10);\n        if (pcVar15 == 0) goto code_r0x0044b71d;\n        if ((pcVar15 != 0xc) &&\n           (iVar9 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(unaff_EBP + -0x3c, unaff_EBP + -0x3c, 0, pcVar15)\n           ,  iVar9 < 0)) {\n            (*_sym.imp.OLEAUT32.dll_VariantCopy)(unaff_EBP + -0x3c);\n            goto code_r0x0044b692;\n        }\n    }\n    // switch table (20 cases) at 0x44b7cd\n    switch(pcVar15 & 0xffff) {\n    case 2:\n    case 0x12:\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n        break;\n    case 3:\n    case 9:\n    case 10:\n    case 0xd:\n    case 0x13:\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n        break;\n    case 4:\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n        break;\n    case 5:\n    case 7:\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n        break;\n    case 6:\n    case 0x14:\n    case 0x15:\n        puVar10 = *(unaff_EBP + 0x14);\n        *puVar10 = *(unaff_EBP + -0x34);\n        puVar10[1] = *(unaff_EBP + -0x30);\n        break;\n    case 8:\n        fcn.0044a2d8(*(unaff_EBP + 0x14), *(unaff_EBP + -0x34));\n        (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(unaff_EBP + -0x34));\n        break;\n    case 0xb:\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34) != 0;\n        break;\n    case 0xc:\n        puVar10 = *(unaff_EBP + 0x14);\n        *puVar10 = *(unaff_EBP + -0x3c);\n        puVar10[1] = *(unaff_EBP + -0x38);\n        puVar10[2] = *(unaff_EBP + -0x34);\n        puVar10[3] = *(unaff_EBP + -0x30);\n        break;\n    case 0x10:\n    case 0x11:\n        **(unaff_EBP + 0x14) = *(unaff_EBP + -0x34);\n    }\ncode_r0x0044b71d:\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return;\n}\n",
        "token_count": 4536
    },
    "0044b85f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t __cdecl\nfcn.0044b85f(uint32_t *arg_8h, uint8_t *arg_ch, uint32_t arg_10h, int32_t arg_14h, int32_t *arg_18h, int32_t *arg_1ch, \n            int32_t arg_20h)\n\n{\n    int16_t *piVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    bool bVar4;\n    uint uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int16_t iVar9;\n    uint32_t in_ECX;\n    int16_t *piVar10;\n    ulong *puVar11;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    *arg_8h = in_ECX;\n    puVar11 = arg_8h + 1;\n    if ((arg_14h == 6) || (arg_14h == 0xc)) {\n        *puVar11 = arg_10h;\n        puVar11 = arg_8h + 2;\n    }\n    iVar3 = *arg_18h;\n    bVar4 = false;\n    arg_14h = arg_18h[2];\n    var_4h = arg_18h[3];\n    uVar2 = *arg_ch;\n    do {\n        if (uVar2 == 0) {\ncode_r0x0044ba36:\n            if (arg_14h < 1) {\n                if (*arg_ch == 0) {\n                    iVar8 = 0;\n                }\n                else {\n                    *arg_1ch = arg_18h[2];\n                    iVar8 = -0x7ffdfff1;\n                }\n            }\n            else {\n                iVar8 = -0x7ffdfff2;\ncode_r0x0044ba41:\n                *arg_1ch = arg_14h;\n            }\n            return iVar8;\n        }\n        uVar2 = *arg_ch;\n        arg_8h = in_ECX & 0xffff0000 | uVar2;\n        arg_14h = arg_14h + -1;\n        if ((uVar2 != 0xff) && ((uVar2 & 0x40) != 0)) {\n            arg_8h = uVar2 & 0xffbf | 0x4000;\n        }\n        iVar9 = arg_8h;\n        if (arg_14h < var_4h) {\n            if (iVar9 == 0xff) {\n                arg_14h = arg_18h[3];\n                var_4h = 0;\n                bVar4 = true;\n                goto code_r0x0044ba26;\n            }\n            if ((!bVar4) && (iVar9 == 0xc)) {\n                *0x45f090 = 10;\n                *0x45f098 = 0x80020004;\n                piVar10 = 0x45f090;\n                goto code_r0x0044b9c9;\n            }\n            goto code_r0x0044ba36;\n        }\n        if (iVar9 == 0xff) goto code_r0x0044ba36;\n        piVar1 = arg_14h * 0x10 + iVar3;\n        piVar10 = piVar1;\n        if ((iVar9 != 0xc) && (iVar9 != *piVar1)) {\n            piVar10 = arg_20h + arg_14h * 0x10;\n            arg_10h = 8;\n            if (iVar9 != 0xe) {\n                arg_10h = arg_8h;\n            }\n            if ((*piVar1 != arg_10h) &&\n               (iVar8 = (*_sym.imp.OLEAUT32.dll_VariantTimeToDosDateTime)(piVar10, piVar1, 0, arg_10h),  iVar8 < 0))\n            goto code_r0x0044ba41;\n            if (iVar9 == 0xe) {\n                if (*piVar1 == arg_10h) {\n                    uVar6 = fcn.0044a283();\n                    *(piVar10 + 4) = uVar6;\n                    *piVar10 = 8;\n                }\n                else {\n                    uVar6 = *(piVar10 + 4);\n                    uVar5 = fcn.0044a283(uVar6);\n                    *(piVar10 + 4) = uVar5;\n                    (*_sym.imp.OLEAUT32.dll_SysStringLen)(uVar6);\n                }\n                arg_8h = 0x8;\n            }\n        }\ncode_r0x0044b9c9:\n        if ((arg_8h & 0x4000) != 0) {\ncode_r0x0044ba1e:\n            uVar7 = *(piVar10 + 4);\n            goto code_r0x0044ba21;\n        }\n    // switch table (20 cases) at 0x44ba68\n        switch(arg_8h & 0xffff) {\n        case 2:\n            uVar7 = piVar10[4];\n            break;\n        case 3:\n        case 4:\n        case 8:\n        case 9:\n        case 10:\n        case 0xd:\n        case 0x13:\n            goto code_r0x0044ba1e;\n        case 5:\n        case 7:\n            *puVar11 = *(piVar10 + 4);\n            goto code_r0x0044ba03;\n        case 6:\n        case 0x14:\n        case 0x15:\n            *puVar11 = *(piVar10 + 4);\n            *(puVar11 + 4) = *(piVar10 + 6);\ncode_r0x0044ba03:\n            puVar11 = puVar11 + 1;\n            goto code_r0x0044ba26;\n        case 0xb:\n            uVar7 = piVar10[4] != 0;\n            break;\n        case 0xc:\n            *puVar11 = piVar10;\n            goto code_r0x0044ba23;\n        default:\n            goto code_r0x0044ba26;\n        case 0x10:\n            uVar7 = *(piVar10 + 4);\n            break;\n        case 0x11:\n            uVar7 = *(piVar10 + 4);\n            break;\n        case 0x12:\n            uVar7 = piVar10[4];\n        }\ncode_r0x0044ba21:\n        *puVar11 = uVar7;\ncode_r0x0044ba23:\n        puVar11 = puVar11 + 4;\ncode_r0x0044ba26:\n        arg_ch = arg_ch + 1;\n        uVar2 = *arg_ch;\n        in_ECX = arg_8h;\n    } while( true );\n}\n",
        "token_count": 1524
    },
    "0044c05c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\ncode ** __cdecl fcn.0044c05c(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int16_t iVar1;\n    uint uVar2;\n    int32_t iVar3;\n    code **extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.004447e8();\n    *extraout_ECX = vtable.COleDispatchException.0;\n    fcn.00426fe0();\n    *(unaff_EBP + -4) = 0;\n    fcn.00426fe0();\n    fcn.00426fe0();\n    iVar1 = *(unaff_EBP + 0x10);\n    iVar3 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 2;\n    extraout_ECX[4] = -(*(unaff_EBP + 0xc) != 0) & *(unaff_EBP + 0xc) + 0x60000U;\n    *(extraout_ECX + 2) = iVar1;\n    if (iVar3 != 0) {\n        fcn.00427580(*(unaff_EBP + 8));\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[7] = (-(iVar1 != 0) & 0x7fff0001) + 0x8000ffff;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 426
    },
    "0044c16a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044c16a(int32_t param_1)\n\n{\n    if (*(param_1 + 0x46) != '\\0') {\n        if (*(param_1 + 0x20) != 0) {\n            (*_sym.imp.ole32.dll_CoRevokeClassObject)(*(param_1 + 0x20));\n            *(param_1 + 0x20) = 0;\n        }\n        *(param_1 + 0x46) = 0;\n    }\n    return;\n}\n",
        "token_count": 118
    },
    "0044c1b5": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044c1b5(int32_t param_1)\n\n{\n    if (*(param_1 + 0x1c) != 0) {\n        (*_sym.imp.ole32.dll_CoRegisterMessageFilter)(0, 0);\n        *(param_1 + 0x1c) = 0;\n    }\n    return;\n}\n",
        "token_count": 81
    },
    "004013f0": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/3c11c79f25554a4cae0a51d287295f58"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004013f0(uint8_t *arg_8h)\n\n{\n    uint8_t uVar1;\n    uint32_t var_4h;\n    \n    var_4h = 0;\n    do {\n        var_4h = *arg_8h + (var_4h >> 0xd | var_4h << 0x13);\n        uVar1 = *arg_8h;\n        arg_8h = arg_8h + 1;\n    } while (uVar1 != 0);\n    return var_4h;\n}\n",
        "token_count": 129
    },
    "00420d60": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00420d60(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00420db0();\n    if ((arg_8h & 1) != 0) {\n        fcn.00420d90(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "004259f0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004259f0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00420dd0();\n    if ((arg_8h & 1) != 0) {\n        fcn.00420d90(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "00425a90": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00425a90(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.004210b0();\n    if ((arg_8h & 1) != 0) {\n        fcn.00420d90(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "00427ca0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427ca0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00427be0();\n    if ((arg_8h & 1) != 0) {\n        fcn.00420d90(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "00427ec0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00427ec0(uint32_t arg_8h)\n\n{\n    uint in_ECX;\n    uint var_4h;\n    \n    fcn.00427d80();\n    if ((arg_8h & 1) != 0) {\n        fcn.00420d90(in_ECX);\n    }\n    return in_ECX;\n}\n",
        "token_count": 80
    },
    "0042b4c0": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0042b4c0(int32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t in_ECX;\n    \n    if ((*(in_ECX + 0x6d) & 0x10) != 0) {\n        if ((*(in_ECX + 0x68) & 1) != (arg_8h != NULL)) {\n            arg_8h = NULL;\n            *(in_ECX + 0x68) = *(in_ECX + 0x68) ^ 1;\n            iVar1 = (****(in_ECX + 0x4c))(*(in_ECX + 0x4c), 0x453d8c, &arg_8h);\n            if (-1 < iVar1) {\n                (**(*arg_8h + 0x14))(arg_8h, 0xfffffd37);\n                (**(*arg_8h + 8))(arg_8h);\n            }\n        }\n    }\n    return;\n}\n",
        "token_count": 226
    },
    "0043072d": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\nuint32_t fcn.0043072d(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    \n    if (param_1 == 0) {\n        return param_1;\n    }\n    iVar1 = *(param_1 + 0x4c);\n    if (iVar1 != 0) {\n        if ((*(iVar1 + 0x6d) & 0x10) != 0) {\n            return (-((*(iVar1 + 0x68) & 1) != 0) & 0xfffffff0) + 0x20;\n        }\n        return 0;\n    }\n    uVar2 = fcn.0043069f(param_1, 0);\n    return uVar2 & 0x30;\n}\n",
        "token_count": 177
    },
    "00446f00": {
        "rules": [
            "check for kernel debugger via shared user data structure/13c690ddb28d4ec98b07cd3883582187",
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9",
            "hash data using aphash/5d19edf9cd984ed983ffade7fcae10d0"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint * __cdecl fcn.00446f00(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    int32_t *piVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint *extraout_ECX;\n    int32_t unaff_EBP;\n    int32_t iVar5;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    *(unaff_EBP + -0x10) = extraout_ECX;\n    fcn.00426fe0();\n    piVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 0;\n    if (piVar1 == NULL) {\n        fcn.0043e11b();\n    }\n    uVar2 = (**(*piVar1 + 0x18))(unaff_EBP + 8);\n    *(unaff_EBP + -4) = 1;\n    fcn.004273b0(uVar2);\n    *(unaff_EBP + -4) = 0;\n    fcn.00421110();\n    uVar2 = *(unaff_EBP + 0xc);\n    extraout_ECX[4] = 0xffffffff;\n    extraout_ECX[6] = uVar2;\n    extraout_ECX[1] = 1;\n    extraout_ECX[7] = 1;\n    extraout_ECX[9] = piVar1;\n    extraout_ECX[0x10] = (-((~uVar2 & 1) != 0) & 0xffffffd0) + 0x40;\n    uVar2 = *(unaff_EBP + 0x14);\n    extraout_ECX[0xf] = 0;\n    extraout_ECX[0xe] = 0;\n    *extraout_ECX = 0;\n    extraout_ECX[0x11] = 0x89;\n    extraout_ECX[0xc] = uVar2;\n    extraout_ECX[2] = 0;\n    uVar3 = (**(*piVar1 + 0x50))(3, 0, 0, 0);\n    iVar5 = *(unaff_EBP + 0x10);\n    extraout_ECX[3] = uVar3 & 2;\n    if (iVar5 < 0x80) {\n        extraout_ECX[8] = 0x80;\n        extraout_ECX[0xc] = 0;\n    }\n    else {\n        extraout_ECX[8] = iVar5;\n    }\n    iVar5 = extraout_ECX[8];\n    if (extraout_ECX[0xc] == 0) {\n        uVar3 = (**(*extraout_ECX[9] + 0x50))(3, 0, 0, 0);\n        extraout_ECX[2] = uVar3 & 1;\n        if ((uVar3 & 1) == 0) {\n            uVar2 = fcn.0043f71e(extraout_ECX[8]);\n            extraout_ECX[0xc] = uVar2;\n            extraout_ECX[7] = 0;\n        }\n        else {\n            iVar5 = 0;\n        }\n    }\n    iVar5 = extraout_ECX[0xc] + iVar5;\n    extraout_ECX[0xb] = iVar5;\n    iVar4 = extraout_ECX[0xc];\n    if ((*(extraout_ECX + 6) & 1) != 0) {\n        iVar4 = iVar5;\n    }\n    uVar2 = *(unaff_EBP + -0xc);\n    extraout_ECX[10] = iVar4;\n    *in_FS_OFFSET = uVar2;\n    return extraout_ECX;\n}\n",
        "token_count": 912
    },
    "00431448": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00431448(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    ushort unaff_SI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.004470d8(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 2;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00446c42();\n    }\n    **(param_1 + 0x28) = unaff_SI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 195
    },
    "00431484": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00431484(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    uint unaff_ESI;\n    \n    if ((~*(param_1 + 0x18) & 1) == 0) {\n        fcn.004470d8(2, *(param_1 + 0x14));\n    }\n    uVar1 = *(param_1 + 0x28) + 4;\n    if (*(param_1 + 0x2c) <= uVar1 && uVar1 != *(param_1 + 0x2c)) {\n        fcn.00446c42();\n    }\n    **(param_1 + 0x28) = unaff_ESI;\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 197
    },
    "004314bf": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.004314bf(int32_t param_1)\n\n{\n    ushort *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.004470d8(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 2U) {\n        fcn.00446cb9((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 2);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 2;\n    return param_1;\n}\n",
        "token_count": 192
    },
    "00431502": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00431502(int32_t param_1)\n\n{\n    uint *unaff_ESI;\n    \n    if ((*(param_1 + 0x18) & 1) == 0) {\n        fcn.004470d8(4, *(param_1 + 0x14));\n    }\n    if (*(param_1 + 0x2c) < *(param_1 + 0x28) + 4U) {\n        fcn.00446cb9((*(param_1 + 0x28) - *(param_1 + 0x2c)) + 4);\n    }\n    *unaff_ESI = **(param_1 + 0x28);\n    *(param_1 + 0x28) = *(param_1 + 0x28) + 4;\n    return param_1;\n}\n",
        "token_count": 192
    },
    "00436820": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00436820(uint *arg_8h, uint8_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint uVar2;\n    uint8_t uVar3;\n    bool bVar4;\n    \n    if ((arg_8h & 3) != 0) {\n        if ((arg_8h & 1) != 0) {\n            uVar3 = *arg_8h;\n            arg_8h = arg_8h + 1;\n            bVar4 = uVar3 < *arg_ch;\n            if (uVar3 != *arg_ch) goto code_r0x00436864;\n            arg_ch = arg_ch + 1;\n            if (uVar3 == 0) {\n                return 0;\n            }\n            if ((arg_8h & 2) == 0) goto code_r0x00436830;\n        }\n        uVar1 = *arg_8h;\n        arg_8h = arg_8h + 2;\n        uVar3 = uVar1;\n        bVar4 = uVar3 < *arg_ch;\n        if (uVar3 != *arg_ch) goto code_r0x00436864;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar1 >> 8;\n        bVar4 = uVar3 < arg_ch[1];\n        if (uVar3 != arg_ch[1]) goto code_r0x00436864;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        arg_ch = arg_ch + 2;\n    }\ncode_r0x00436830:\n    while( true ) {\n        uVar2 = *arg_8h;\n        uVar3 = uVar2;\n        bVar4 = uVar3 < *arg_ch;\n        if (uVar3 != *arg_ch) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 8;\n        bVar4 = uVar3 < arg_ch[1];\n        if (uVar3 != arg_ch[1]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x10;\n        bVar4 = uVar3 < arg_ch[2];\n        if (uVar3 != arg_ch[2]) break;\n        if (uVar3 == 0) {\n            return 0;\n        }\n        uVar3 = uVar2 >> 0x18;\n        bVar4 = uVar3 < arg_ch[3];\n        if (uVar3 != arg_ch[3]) break;\n        arg_ch = arg_ch + 4;\n        arg_8h = arg_8h + 1;\n        if (uVar3 == 0) {\n            return 0;\n        }\n    }\ncode_r0x00436864:\n    return bVar4 * -2 + 1;\n}\n",
        "token_count": 665
    },
    "00433c00": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.00433c00(uint32_t *param_1, uint32_t *param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    uint8_t uVar6;\n    uint32_t *puVar7;\n    uint32_t *puVar8;\n    bool bVar9;\n    \n    uVar3 = param_3;\n    if (param_3 != 0) {\n        if (((param_1 | param_2) & 3) == 0) {\n            uVar3 = param_3 & 3;\n            param_3 = param_3 >> 2;\n            bVar9 = param_3 == 0;\n            puVar7 = param_1;\n            puVar8 = param_2;\n            if (!bVar9) {\n                do {\n                    param_1 = puVar7;\n                    param_2 = puVar8;\n                    if (param_3 == 0) break;\n                    param_3 = param_3 - 1;\n                    param_2 = puVar8 + 1;\n                    param_1 = puVar7 + 1;\n                    bVar9 = *puVar7 == *puVar8;\n                    puVar7 = param_1;\n                    puVar8 = param_2;\n                } while (bVar9);\n                if (!bVar9) {\n                    uVar3 = param_1[-1];\n                    uVar1 = param_2[-1];\n                    bVar9 = uVar3 < uVar1;\n                    if (((uVar3 == uVar1) &&\n                        (uVar5 = uVar3 >> 8,  uVar6 = uVar1 >> 8,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) &&\n                       (uVar5 = uVar3 >> 0x10,  uVar6 = uVar1 >> 0x10,  bVar9 = uVar5 < uVar6,  uVar5 == uVar6)) {\n                        bVar9 = uVar3 >> 0x18 < uVar1 >> 0x18;\n                    }\n                    goto code_r0x00433c80;\n                }\n            }\n            if (uVar3 != 0) {\n                uVar1 = *param_1;\n                uVar2 = *param_2;\n                bVar9 = uVar1 < uVar2;\n                if (uVar1 != uVar2) {\ncode_r0x00433c80:\n                    return (1 - bVar9) - (bVar9 != 0);\n                }\n                uVar4 = uVar3 - 1;\n                if (uVar4 != 0) {\n                    uVar5 = uVar2 >> 8;\n                    uVar6 = uVar1 >> 8;\n                    bVar9 = uVar6 < uVar5;\n                    if (uVar6 != uVar5) goto code_r0x00433c80;\n                    uVar4 = uVar3 - 2;\n                    if (uVar4 != 0) {\n                        bVar9 = (uVar1 & 0xff0000) < (uVar2 & 0xff0000);\n                        if ((uVar1 & 0xff0000) != (uVar2 & 0xff0000)) goto code_r0x00433c80;\n                        uVar4 = uVar3 - 3;\n                    }\n                }\n                return uVar4;\n            }\n        }\n        else {\n            if ((param_3 & 1) == 0) goto code_r0x00433c33;\n            bVar9 = *param_1 < *param_2;\n            if (*param_1 != *param_2) goto code_r0x00433c80;\n            param_1 = param_1 + 1;\n            param_2 = param_2 + 1;\n            for (param_3 = param_3 - 1; uVar3 = param_3,  param_3 != 0; param_3 = param_3 - 2) {\ncode_r0x00433c33:\n                bVar9 = *param_1 < *param_2;\n                if ((*param_1 != *param_2) ||\n                   (bVar9 = *(param_1 + 1) < *(param_2 + 1),  *(param_1 + 1) != *(param_2 + 1))) goto code_r0x00433c80;\n                param_2 = param_2 + 2;\n                param_1 = param_1 + 2;\n            }\n        }\n    }\n    return uVar3;\n}\n",
        "token_count": 1048
    },
    "004368a8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004368a8(uint32_t arg_8h, int32_t *arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    \n    piVar2 = arg_ch;\n    uVar1 = arg_ch[3];\n    arg_8h_00 = arg_ch[4];\n    if (((uVar1 & 0x82) == 0) || ((uVar1 & 0x40) != 0)) {\ncode_r0x004369b4:\n        arg_ch[3] = uVar1 | 0x20;\n    }\n    else {\n        if ((uVar1 & 1) != 0) {\n            arg_ch[1] = 0;\n            if ((uVar1 & 0x10) == 0) goto code_r0x004369b4;\n            *arg_ch = arg_ch[2];\n            arg_ch[3] = uVar1 & 0xfffffffe;\n        }\n        uVar1 = arg_ch[3];\n        arg_ch[1] = 0;\n        arg_ch = NULL;\n        piVar2[3] = uVar1 & 0xffffffef | 2;\n        if (((uVar1 & 0x10c) == 0) &&\n           (((piVar2 != 0x45cb08 && (piVar2 != 0x45cb28)) || (iVar3 = fcn.0043b071(arg_8h_00),  iVar3 == 0)))) {\n            fcn.0043b02d(piVar2);\n        }\n        if ((*(piVar2 + 3) & 0x108) == 0) {\n            iVar3 = 1;\n            arg_ch = fcn.0043af82(arg_8h_00, &arg_8h, 1);\n        }\n        else {\n            iVar4 = piVar2[2];\n            iVar3 = *piVar2;\n            *piVar2 = iVar4 + 1;\n            iVar3 = iVar3 - iVar4;\n            piVar2[1] = piVar2[6] + -1;\n            if (iVar3 < 1) {\n                if (arg_8h_00 == 0xffffffff) {\n                    iVar4 = 0x45ca40;\n                }\n                else {\n                    iVar4 = *((arg_8h_00 >> 5) * 4 + 0x460640) + (arg_8h_00 & 0x1f) * 0x24;\n                }\n                if ((*(iVar4 + 4) & 0x20) != 0) {\n                    fcn.0043ad09(arg_8h_00, 0, 2);\n                }\n            }\n            else {\n                arg_ch = fcn.0043af82(arg_8h_00, iVar4, iVar3);\n            }\n            *piVar2[2] = arg_8h;\n        }\n        if (arg_ch == iVar3) {\n            return arg_8h & 0xff;\n        }\n        piVar2[3] = piVar2[3] | 0x20;\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 727
    },
    "0043ad09": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043ad09(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x453b18, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x460630) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x460640;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0043c281(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00434b6a();\n                *puVar3 = 9;\n                puVar3 = fcn.00434b73();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0043ac95(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043ad90();\n            goto code_r0x0043adae;\n        }\n    }\n    puVar3 = fcn.00434b6a();\n    *puVar3 = 9;\n    puVar3 = fcn.00434b73();\n    *puVar3 = 0;\ncode_r0x0043adae:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 519
    },
    "0043af82": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043af82(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x453b28, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x460630) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x460640;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0043c281(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00434b6a();\n                *puVar3 = 9;\n                puVar3 = fcn.00434b73();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0043adb4(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043b009();\n            goto code_r0x0043b027;\n        }\n    }\n    puVar3 = fcn.00434b6a();\n    *puVar3 = 9;\n    puVar3 = fcn.00434b73();\n    *puVar3 = 0;\ncode_r0x0043b027:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 519
    },
    "0043bdd4": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint32_t fcn.0043bdd4(void)\n\n{\n    uint32_t uVar1;\n    uint16_t uVar2;\n    uint16_t unaff_BX;\n    \n    uVar1 = 0;\n    if ((unaff_BX & 1) != 0) {\n        uVar1 = 0x10;\n    }\n    if ((unaff_BX & 4) != 0) {\n        uVar1 = uVar1 | 8;\n    }\n    if ((unaff_BX & 8) != 0) {\n        uVar1 = uVar1 | 4;\n    }\n    if ((unaff_BX & 0x10) != 0) {\n        uVar1 = uVar1 | 2;\n    }\n    if ((unaff_BX & 0x20) != 0) {\n        uVar1 = uVar1 | 1;\n    }\n    if ((unaff_BX & 2) != 0) {\n        uVar1 = uVar1 | 0x80000;\n    }\n    uVar2 = unaff_BX & 0xc00;\n    if ((unaff_BX & 0xc00) != 0) {\n        if (uVar2 == 0x400) {\n            uVar1 = uVar1 | 0x100;\n        }\n        else if (uVar2 == 0x800) {\n            uVar1 = uVar1 | 0x200;\n        }\n        else if (uVar2 == 0xc00) {\n            uVar1 = uVar1 | 0x300;\n        }\n    }\n    if ((unaff_BX & 0x300) == 0) {\n        uVar1 = uVar1 | 0x20000;\n    }\n    else if ((unaff_BX & 0x300) == 0x200) {\n        uVar1 = uVar1 | 0x10000;\n    }\n    if ((unaff_BX & 0x1000) != 0) {\n        uVar1 = uVar1 | 0x40000;\n    }\n    return uVar1;\n}\n",
        "token_count": 473
    },
    "0043c240": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nuint fcn.0043c240(uint32_t param_1)\n\n{\n    uint *puVar1;\n    \n    if ((param_1 < *0x460630) &&\n       (puVar1 = *((param_1 >> 5) * 4 + 0x460640) + (param_1 & 0x1f) * 0x24,  (*(puVar1 + 1) & 1) != 0)) {\n        return *puVar1;\n    }\n    puVar1 = fcn.00434b6a();\n    *puVar1 = 9;\n    puVar1 = fcn.00434b73();\n    *puVar1 = 0;\n    return 0xffffffff;\n}\n",
        "token_count": 160
    },
    "0043c7a5": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043c7a5(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x453bc8, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x460630) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x460640;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0043c281(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00434b6a();\n                *puVar3 = 9;\n                puVar3 = fcn.00434b73();\n                *puVar3 = 0;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0043c5ca(arg_8h_00, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10));\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043c82c();\n            goto code_r0x0043c84a;\n        }\n    }\n    puVar3 = fcn.00434b6a();\n    *puVar3 = 9;\n    puVar3 = fcn.00434b73();\n    *puVar3 = 0;\ncode_r0x0043c84a:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 525
    },
    "0043dbe8": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043dbe8(uint arg_8h)\n\n{\n    int32_t *piVar1;\n    uint32_t arg_8h_00;\n    uint uVar2;\n    uint *puVar3;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x453c30, 0xc);\n    arg_8h_00 = *(unaff_EBP + 8);\n    if (arg_8h_00 < *0x460630) {\n        piVar1 = (arg_8h_00 >> 5) * 4 + 0x460640;\n        iVar4 = (arg_8h_00 & 0x1f) * 0x24;\n        if ((*(*piVar1 + 4 + iVar4) & 1) != 0) {\n            fcn.0043c281(arg_8h_00);\n            *(unaff_EBP + -4) = 0;\n            if ((*(*piVar1 + 4 + iVar4) & 1) == 0) {\n                puVar3 = fcn.00434b6a();\n                *puVar3 = 9;\n                *(unaff_EBP + -0x1c) = 0xffffffff;\n            }\n            else {\n                uVar2 = fcn.0043db65(arg_8h_00);\n                *(unaff_EBP + -0x1c) = uVar2;\n            }\n            *(unaff_EBP + -4) = 0xffffffff;\n            fcn.0043dc5f();\n            goto code_r0x0043dc7d;\n        }\n    }\n    puVar3 = fcn.00434b6a();\n    *puVar3 = 9;\n    puVar3 = fcn.00434b73();\n    *puVar3 = 0;\ncode_r0x0043dc7d:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 469
    },
    "00441b2d": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __thiscall fcn.00441b2d(int32_t *param_1, uint8_t param_2)\n\n{\n    bool bVar1;\n    bool bVar2;\n    code *pcVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t unaff_EBX;\n    uint8_t unaff_retaddr;\n    \n    bVar1 = true;\n    bVar2 = false;\n    if (((param_2 & 4) == 0) || (uVar4 = fcn.0044403d(),  (uVar4 & 0x10000000) != 0)) {\n        bVar1 = false;\n    }\n    iVar5 = (*_sym.imp.USER32.dll_GetParent)(param_1[7]);\n    param_1[0xe] = param_1[0xe] | 0x18;\n    iVar6 = fcn.0043f75c();\n    pcVar3 = _sym.imp.USER32.dll_UpdateWindow;\ncode_r0x00441bec:\n    while ((!bVar2 || (iVar7 = (*_sym.imp.USER32.dll_PeekMessageA)(iVar6, 0, 0, 0, 0),  iVar7 != 0))) {\n        do {\n            iVar7 = fcn.0043fa60();\n            if (iVar7 == 0) {\n                fcn.0044c0ff(0);\n                return -1;\n            }\n            if ((bVar1) && ((*(iVar6 + 4) == 0x118 || (*(iVar6 + 4) == 0x104)))) {\n                fcn.0044413f(1);\n                (*pcVar3)(param_1[7]);\n                bVar1 = false;\n            }\n            iVar7 = (**(*param_1 + 0x80))();\n            if (iVar7 == 0) {\n                param_1[0xe] = param_1[0xe] & 0xffffffe7;\n                return param_1[0x10];\n            }\n            iVar7 = fcn.0043f9cc(iVar6);\n            if (iVar7 != 0) {\n                bVar2 = true;\n                unaff_EBX = 0;\n            }\n            iVar7 = (*_sym.imp.USER32.dll_PeekMessageA)(iVar6, 0, 0, 0, 0);\n        } while (iVar7 != 0);\n    }\n    if (bVar1) {\n        fcn.0044413f(1);\n        (*pcVar3)(param_1[7]);\n        bVar1 = false;\n    }\n    if ((((unaff_retaddr & 1) == 0) && (iVar5 != 0)) && (unaff_EBX == 0)) {\n        (*_sym.imp.USER32.dll_SendMessageA)(iVar5, 0x121, 0, param_1[7]);\n    }\n    if ((unaff_retaddr & 2) == 0) goto code_r0x00441bcd;\n    goto code_r0x00441be8;\ncode_r0x00441bcd:\n    iVar7 = (*_sym.imp.USER32.dll_SendMessageA)(param_1[7], 0x36a, 0, unaff_EBX);\n    unaff_EBX = unaff_EBX + 1;\n    if (iVar7 == 0) {\ncode_r0x00441be8:\n        bVar2 = false;\n    }\n    goto code_r0x00441bec;\n}\n",
        "token_count": 788
    },
    "00441ce2": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_ch\n// WARNING: Variable defined which should be unmapped: var_8h\n// WARNING: Variable defined which should be unmapped: var_4h\n\nbool __cdecl fcn.00441ce2(uint32_t arg_8h)\n\n{\n    uint noname_8;\n    uint noname_11;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBX;\n    uint unaff_EBP;\n    uint unaff_ESI;\n    uint32_t uVar3;\n    uint unaff_EDI;\n    bool bVar4;\n    uint *noname_0;\n    uint32_t var_34h;\n    uint var_30h;\n    uint in_stack_ffffffd0;\n    uint in_stack_ffffffd4;\n    uint var_24h;\n    uint in_stack_ffffffdc;\n    uint var_1ch;\n    uint var_18h;\n    uint in_stack_ffffffe8;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = fcn.004499e7();\n    arg_8h = arg_8h & ~*(var_4h + 0x18);\n    if (arg_8h == 0) {\n        bVar4 = true;\n    }\n    else {\n        uVar3 = 0;\n        fcn.00433ba0(&var_34h, 0, 0x28);\n        var_30h = _sym.imp.USER32.dll_DefWindowProcA;\n        iVar1 = fcn.004499e7();\n        noname_11 = *0x45f050;\n        noname_8 = *(iVar1 + 8);\n        noname_0 = 0x8;\n        var_ch = 8;\n        if ((arg_8h & 1) != 0) {\n            noname_0 = &var_34h;\n            var_34h = 0xb;\n            iVar1 = fcn.00440d31(noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0xb, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, *0x45f050, var_18h, in_stack_ffffffe8, \n                                 \"AfxWnd70s\", 8, var_8h, var_4h, unaff_EBP);\n            if (iVar1 != 0) {\n                uVar3 = 1;\n            }\n        }\n        if ((arg_8h & 0x20) != 0) {\n            var_34h = var_34h | 0x8b;\n            iVar1 = fcn.00440d31(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, var_34h, var_30h, \n                                 in_stack_ffffffd0, in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, var_18h, \n                                 in_stack_ffffffe8, \"AfxOleControl70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 0x20;\n            }\n        }\n        if ((arg_8h & 2) != 0) {\n            var_34h = 0;\n            iVar1 = fcn.00440d31(&var_34h, noname_0, unaff_EDI, unaff_ESI, unaff_EBX, 0, var_30h, in_stack_ffffffd0, \n                                 in_stack_ffffffd4, noname_8, in_stack_ffffffdc, noname_11, 0x10, in_stack_ffffffe8, \n                                 \"AfxControlBar70s\", var_ch, var_8h, var_4h);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 2;\n            }\n        }\n        if ((arg_8h & 4) != 0) {\n            var_34h = 8;\n            iVar1 = fcn.00441ca1(&var_34h, \"AfxMDIFrame70s\", 0x7a01);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 4;\n            }\n        }\n        if ((arg_8h & 8) != 0) {\n            var_34h = 0xb;\n            iVar1 = fcn.00441ca1(&var_34h, \"AfxFrameOrView70s\", 0x7a02);\n            if (iVar1 != 0) {\n                uVar3 = uVar3 | 8;\n            }\n        }\n        if ((arg_8h & 0x10) != 0) {\n            var_8h = 0xff;\n            uVar2 = fcn.004415ff(&var_ch, 0x3fc0);\n            uVar3 = uVar3 | uVar2;\n            arg_8h = arg_8h & 0xffffc03f;\n        }\n        if ((arg_8h & 0x40) != 0) {\n            var_8h = 0x10;\n            uVar2 = fcn.004415ff(&var_ch, 0x40);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x80) != 0) {\n            var_8h = 2;\n            uVar2 = fcn.004415ff(&var_ch, 0x80);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x100) != 0) {\n            var_8h = 8;\n            uVar2 = fcn.004415ff(&var_ch, 0x100);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x200) != 0) {\n            var_8h = 0x20;\n            uVar2 = fcn.004415ff(&var_ch, 0x200);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x400) != 0) {\n            var_8h = 1;\n            uVar2 = fcn.004415ff(&var_ch, 0x400);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x800) != 0) {\n            var_8h = 0x40;\n            uVar2 = fcn.004415ff(&var_ch, 0x800);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x1000) != 0) {\n            var_8h = 4;\n            uVar2 = fcn.004415ff(&var_ch, 0x1000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x2000) != 0) {\n            var_8h = 0x80;\n            uVar2 = fcn.004415ff(&var_ch, 0x2000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x4000) != 0) {\n            var_8h = 0x800;\n            uVar2 = fcn.004415ff(&var_ch, 0x4000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x8000) != 0) {\n            var_8h = 0x400;\n            uVar2 = fcn.004415ff(&var_ch, 0x8000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x10000) != 0) {\n            var_8h = 0x200;\n            uVar2 = fcn.004415ff(&var_ch, 0x10000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x20000) != 0) {\n            var_8h = 0x100;\n            uVar2 = fcn.004415ff(&var_ch, 0x20000);\n            uVar3 = uVar3 | uVar2;\n        }\n        if ((arg_8h & 0x40000) != 0) {\n            var_8h = 0x8000;\n            uVar2 = fcn.004415ff(&var_ch, 0x40000);\n            uVar3 = uVar3 | uVar2;\n        }\n        *(var_4h + 0x18) = *(var_4h + 0x18) | uVar3;\n        if ((*(var_4h + 0x18) & 0x3fc0) == 0x3fc0) {\n            *(var_4h + 0x18) = *(var_4h + 0x18) | 0x10;\n            uVar3 = uVar3 | 0x10;\n        }\n        bVar4 = (uVar3 & arg_8h) == arg_8h;\n    }\n    return bVar4;\n}\n",
        "token_count": 2247
    },
    "0044400a": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0044400a(int32_t param_1, uint param_2)\n\n{\n    int32_t iVar1;\n    \n    if ((*(param_1 + 0x39) & 1) == 0) {\n        (*_sym.imp.USER32.dll_IsDialogMessageA)(*(param_1 + 0x1c), param_2);\n    }\n    else {\n        iVar1 = fcn.004499e7();\n        (**(**(iVar1 + 0x1038) + 0x24))(param_1, param_2);\n    }\n    return;\n}\n",
        "token_count": 133
    },
    "00446c42": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00446c42(int32_t param_1)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    \n    iVar3 = *(param_1 + 0x28);\n    if ((*(param_1 + 0x18) & 1) == 0) {\n        piVar1 = param_1 + 0x30;\n        iVar2 = *piVar1;\n        if (*(param_1 + 8) == 0) {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x38))(iVar2, iVar3 - iVar2);\n            }\n        }\n        else {\n            if (iVar3 != iVar2) {\n                (**(**(param_1 + 0x24) + 0x50))(2, iVar3 - iVar2, 0, 0);\n            }\n            (**(**(param_1 + 0x24) + 0x50))(1, *(param_1 + 0x20), piVar1, param_1 + 0x2c);\n        }\n        iVar3 = *piVar1;\n    }\n    else {\n        if (*(param_1 + 0x2c) != iVar3) {\n            iVar3 = iVar3 - *(param_1 + 0x2c);\n            (**(**(param_1 + 0x24) + 0x28))(iVar3, iVar3 >> 0x1f, 1);\n        }\n        iVar3 = *(param_1 + 0x2c);\n    }\n    *(param_1 + 0x28) = iVar3;\n    return;\n}\n",
        "token_count": 376
    },
    "00449a78": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nint32_t __fastcall fcn.00449a78(int32_t param_1)\n\n{\n    uint32_t *puVar1;\n    int32_t iVar2;\n    code *pcVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    uint8_t *puVar6;\n    int32_t iVar7;\n    uint uStack48;\n    uchar *puStack44;\n    int32_t iStack40;\n    uint uStack36;\n    int32_t iStack32;\n    int32_t iStack28;\n    uint hMem;\n    uint lpCriticalSection;\n    \n    iVar4 = param_1 + 0x1c;\n    iStack32 = 0x449a8f;\n    iStack28 = iVar4;\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)();\n    iVar2 = *(param_1 + 4);\n    iVar7 = *(param_1 + 8);\n    if ((iVar2 <= iVar7) || ((*(*(param_1 + 0x10) + iVar7 * 8) & 1) != 0)) {\n        iVar7 = 1;\n        if (1 < iVar2) {\n            puVar6 = *(param_1 + 0x10);\n            do {\n                puVar6 = puVar6 + 8;\n                if ((*puVar6 & 1) == 0) break;\n                iVar7 = iVar7 + 1;\n            } while (iVar7 < iVar2);\n            if (iVar7 < iVar2) goto code_r0x00449b5a;\n        }\n        iVar2 = iVar2 + 0x20;\n        iStack32 = *(param_1 + 0x10);\n        if (iStack32 == 0) {\n            iStack32 = iVar2 * 8;\n            uStack36 = 2;\n            iStack40 = 0x449ae0;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalAlloc)();\n        }\n        else {\n            uStack36 = 0x449ae9;\n            uStack48 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n            iStack40 = 0x449af3;\n            uStack36 = uStack48;\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)();\n            iStack40 = 0x2002;\n            puStack44 = iVar2 * 8;\n            iStack40 = (*_sym.imp.KERNEL32.dll_GlobalReAlloc)();\n        }\n        if (iStack40 == 0) {\n            iStack40 = *(param_1 + 0x10);\n            if (iStack40 != 0) {\n                puStack44 = 0x449b19;\n                puStack44 = (*_sym.imp.KERNEL32.dll_GlobalHandle)();\n                uStack48 = 0x449b20;\n                (*_sym.imp.KERNEL32.dll_GlobalLock)();\n            }\n            puStack44 = 0x449b29;\n            iStack40 = iVar4;\n            (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n            uStack48 = 0x45ebe8;\n            puStack44 = &stack0xfffffffc;\n            fcn.00433cb8(&stack0xffffffd0, 0x457564);\n            pcVar3 = swi(3);\n            iVar4 = (*pcVar3)();\n            return iVar4;\n        }\n        puStack44 = 0x449b35;\n        iVar5 = (*_sym.imp.KERNEL32.dll_GlobalLock)();\n        iStack32 = (iVar2 - *(param_1 + 4)) * 8;\n        iStack40 = iVar5 + *(param_1 + 4) * 8;\n        uStack36 = 0;\n        puStack44 = 0x449b4e;\n        fcn.00433ba0();\n        *(param_1 + 4) = iVar2;\n        *(param_1 + 0x10) = iVar5;\n    }\ncode_r0x00449b5a:\n    if (*(param_1 + 0xc) <= iVar7) {\n        *(param_1 + 0xc) = iVar7 + 1;\n    }\n    puVar1 = *(param_1 + 0x10) + iVar7 * 8;\n    *puVar1 = *puVar1 | 1;\n    *(param_1 + 8) = iVar7 + 1;\n    uStack36 = 0x449b7d;\n    iStack32 = iVar4;\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)();\n    return iVar7;\n}\n",
        "token_count": 992
    },
    "00434692": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00434692(uint arg_8h)\n\n{\n    int32_t iVar1;\n    int32_t *arg_8h_00;\n    int32_t unaff_EBP;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00434920(0x452bc8, 0x14);\n    *(unaff_EBP + -0x20) = 0xffffffff;\n    fcn.004375c5(0xd);\n    *(unaff_EBP + -4) = 0;\n    *0x45f138 = 0;\n    iVar1 = *(unaff_EBP + 8);\n    if (iVar1 == -2) {\n        *0x45f138 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n    }\n    else if (iVar1 == -3) {\n        *0x45f138 = 1;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    else if (iVar1 == -4) {\n        *0x45f138 = 1;\n        iVar1 = *0x45f51c;\n    }\n    *(unaff_EBP + 8) = iVar1;\n    arg_8h_00 = *0x460768;\n    if (iVar1 == *0x460884) {\n        *(unaff_EBP + -0x20) = 0;\n    }\n    else {\n        *(unaff_EBP + -0x24) = *0x460768;\n        if ((arg_8h_00 == NULL) || (*arg_8h_00 != 0)) {\n            arg_8h_00 = fcn.004335fc(0x220);\n            *(unaff_EBP + -0x24) = arg_8h_00;\n        }\n        if (arg_8h_00 != NULL) {\n            iVar1 = fcn.00434502(*(unaff_EBP + 8));\n            *(unaff_EBP + -0x20) = iVar1;\n            if (iVar1 == 0) {\n                *arg_8h_00 = 0;\n                arg_8h_00[1] = *0x460884;\n                arg_8h_00[2] = *0x46076c;\n                arg_8h_00[3] = *0x460764;\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 5; iVar1 = iVar1 + 1) {\n                    *(arg_8h_00 + iVar1 * 2 + 0x10) = *(iVar1 * 2 + 0x460890);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  iVar1 < 0x101; iVar1 = iVar1 + 1) {\n                    *(iVar1 + 0x1c + arg_8h_00) = *(iVar1 + 0x460780);\n                }\n                for (iVar1 = 0; *(unaff_EBP + -0x1c) = iVar1,  *0x460768 = arg_8h_00,  iVar1 < 0x100; iVar1 = iVar1 + 1)\n                {\n                    *(iVar1 + 0x11d + arg_8h_00) = *(iVar1 + 0x4608a0);\n                }\n            }\n        }\n        if ((*(unaff_EBP + -0x20) == -1) && (arg_8h_00 != *0x460768)) {\n            fcn.0043360e(arg_8h_00);\n        }\n    }\n    *(unaff_EBP + -4) = 0xffffffff;\n    fcn.004347d9();\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 899
    },
    "00426080": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t * __cdecl\nfcn.00426080(int32_t arg_8h, int32_t arg_ch, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    uint32_t *in_ECX;\n    ulong uVar1;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_4h;\n    \n    var_24h = arg_1ch;\n    var_20h = arg_18h;\n    var_1ch = arg_14h;\n    var_18h = arg_10h;\n    var_14h = arg_ch + -1;\n    var_10h = arg_8h + -0x76c;\n    var_4h = arg_20h;\n    uVar1 = fcn.004323cc(&var_24h);\n    *in_ECX = uVar1;\n    in_ECX[1] = uVar1 >> 0x20;\n    if ((*in_ECX & in_ECX[1]) == 0xffffffff) {\n        fcn.00425fa0(0x80070057);\n    }\n    return in_ECX;\n}\n",
        "token_count": 312
    },
    "00427fef": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.00427fef(int32_t *param_1, int32_t param_2)\n\n{\n    if ((param_2 == -1) && (param_2 = *param_1,  param_2 != 0)) {\n        param_2 = fcn.00431a40(param_2);\n    }\n    fcn.004274f0(param_2);\n    return;\n}\n",
        "token_count": 91
    },
    "0042ac08": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0042ac08(int32_t *arg_8h, uint32_t arg_ch, int32_t *arg_10h)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    puVar1 = (**(*arg_8h + 0x3c))();\n    do {\n        if (puVar1 == NULL) {\n            return 0;\n        }\n        iVar2 = puVar1[1];\n        uVar3 = *(iVar2 + 0x18);\n        if (uVar3 != 0xffffffff) {\n            do {\n                if ((*(iVar2 + 4) == arg_10h[1]) && (uVar3 == (*arg_10h != 0))) {\n                    if (*(iVar2 + 0x24) == 0xffffffff) {\n                        if (*(iVar2 + 0x20) == 0xffffffff) {\n                            return iVar2;\n                        }\n                        if (*(iVar2 + 0x20) == arg_ch) {\n                            return iVar2;\n                        }\n                    }\n                    else if ((*(iVar2 + 0x20) < arg_ch || *(iVar2 + 0x20) == arg_ch) && (arg_ch <= *(iVar2 + 0x24))) {\n                        return iVar2;\n                    }\n                }\n                uVar3 = *(iVar2 + 0x40);\n                iVar2 = iVar2 + 0x28;\n            } while (uVar3 != 0xffffffff);\n        }\n        puVar1 = *puVar1;\n    } while( true );\n}\n",
        "token_count": 350
    },
    "00433438": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.00433438(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iStack12;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((*(param_1 + 4) & 6) == 0) {\n        iStack12 = param_1;\n        uStack8 = param_3;\n        *(param_2 + -4) = &iStack12;\n        iVar5 = *(param_2 + 0xc);\n        iVar3 = *(param_2 + 8);\n        iVar2 = fcn.00437249(param_2);\n        if (iVar2 == 0) {\n            *(param_1 + 4) = *(param_1 + 4) | 8;\n        }\n        else {\n            for (; iVar5 != -1; iVar5 = *(iVar3 + iVar5 * 0xc)) {\n                pcVar1 = *(iVar3 + 4 + iVar5 * 0xc);\n                if (pcVar1 != NULL) {\n                    iVar3 = (*pcVar1)();\n                    param_2 = *(puVar4 + 0xc);\n                    if (iVar3 != 0) {\n                        if (iVar3 < 0) {\n                            return 0;\n                        }\n                        iVar3 = *(param_2 + 8);\n                        fcn.00431f9c(param_2);\n                        puVar4 = param_2 + 0x10;\n                        fcn.00431fde(param_2, iVar5);\n                        fcn.00432072(1);\n                        *(param_2 + 0xc) = *(iVar3 + extraout_ECX * 4);\n                        param_2 = 0;\n                        iVar5 = 0;\n                        (**(iVar3 + 8 + extraout_ECX * 4))();\n                    }\n                }\n                iVar3 = *(param_2 + 8);\n            }\n        }\n    }\n    else {\n        fcn.00431fde(param_2, 0xffffffff, &stack0xfffffffc, &stack0xfffffffc);\n    }\n    return 1;\n}\n",
        "token_count": 511
    },
    "0043b362": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint32_t fcn.0043b362(uint8_t **param_1)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    uint8_t *puVar3;\n    int32_t iVar4;\n    \n    puVar3 = param_1[3];\n    if (((puVar3 & 0x83) != 0) && ((puVar3 & 0x40) == 0)) {\n        if ((puVar3 & 2) == 0) {\n            param_1[3] = puVar3 | 1;\n            if ((puVar3 & 0x10c) == 0) {\n                fcn.0043b02d(param_1);\n            }\n            else {\n                *param_1 = param_1[2];\n            }\n            puVar3 = fcn.0043c7a5(param_1[4], param_1[2], param_1[6]);\n            param_1[1] = puVar3;\n            if ((puVar3 != NULL) && (puVar3 != 0xffffffff)) {\n                if ((param_1[3] & 0x82) == 0) {\n                    puVar2 = param_1[4];\n                    if (puVar2 == 0xffffffff) {\n                        iVar4 = 0x45ca40;\n                    }\n                    else {\n                        iVar4 = *((puVar2 >> 5) * 4 + 0x460640) + (puVar2 & 0x1f) * 0x24;\n                    }\n                    if ((*(iVar4 + 4) & 0x82) == 0x82) {\n                        param_1[3] = param_1[3] | 0x2000;\n                    }\n                }\n                if (((param_1[6] == 0x200) && ((param_1[3] & 8) != 0)) && ((param_1[3] & 0x400) == 0)) {\n                    param_1[6] = 0x1000;\n                }\n                param_1[1] = puVar3 + -1;\n                uVar1 = **param_1;\n                *param_1 = *param_1 + 1;\n                return uVar1;\n            }\n            param_1[3] = param_1[3] | (-(puVar3 != NULL) & 0x10) + 0x10;\n            param_1[1] = NULL;\n        }\n        else {\n            param_1[3] = puVar3 | 0x20;\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 581
    },
    "0043e9a3": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043e9a3(uint wParam, uint arg_ch, uint arg_10h, int32_t arg_14h, int32_t arg_18h)\n\n{\n    int32_t in_ECX;\n    uint32_t lParam;\n    uint var_1ch;\n    int32_t var_18h;\n    uint var_14h;\n    int32_t var_ch;\n    \n    var_14h = arg_ch;\n    var_1ch = arg_10h;\n    lParam = 5;\n    if (arg_14h != -1) {\n        lParam = 7;\n        var_18h = arg_14h;\n    }\n    if (arg_18h != -1) {\n        lParam = lParam | 8;\n        var_ch = arg_18h;\n    }\n    (*_sym.imp.USER32.dll_SendMessageA)(*(in_ECX + 0x1c), 0x101b, wParam, &lParam);\n    return;\n}\n",
        "token_count": 215
    },
    "0043f35c": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __thiscall fcn.0043f35c(int32_t param_1, int32_t **param_2, int32_t *param_3, int32_t *param_4)\n\n{\n    int32_t **ppiVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    uint32_t uVar4;\n    int32_t *piVar5;\n    \n    piVar3 = *param_2;\n    if (piVar3 != NULL) {\n        if (piVar3 == 0xffffffff) {\n            uVar4 = 0;\n            if (*(param_1 + 8) != 0) {\n                ppiVar1 = *(param_1 + 4);\n                while (piVar3 = *ppiVar1,  piVar3 == NULL) {\n                    uVar4 = uVar4 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                    if (*(param_1 + 8) <= uVar4) {\n                        *param_2 = NULL;\n                        return;\n                    }\n                }\n            }\n        }\n        piVar5 = *piVar3;\n        if (piVar5 == NULL) {\n            uVar4 = *(param_1 + 8);\n            uVar2 = (piVar3[1] >> 4) % uVar4 + 1;\n            if (uVar2 < uVar4) {\n                ppiVar1 = *(param_1 + 4) + uVar2 * 4;\n                do {\n                    piVar5 = *ppiVar1;\n                    if (piVar5 != NULL) break;\n                    uVar2 = uVar2 + 1;\n                    ppiVar1 = ppiVar1 + 1;\n                } while (uVar2 < uVar4);\n            }\n        }\n        *param_2 = piVar5;\n        *param_3 = piVar3[1];\n        *param_4 = piVar3[2];\n    }\n    return;\n}\n",
        "token_count": 436
    },
    "00444cb9": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.00444cb9(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    bool bVar3;\n    \n    bVar3 = false;\n    if (*(param_1 + 4) != -1) {\n        iVar1 = (*_sym.imp.KERNEL32.dll_CloseHandle)(*(param_1 + 4));\n        bVar3 = iVar1 == 0;\n    }\n    *(param_1 + 4) = 0xffffffff;\n    *(param_1 + 8) = 0;\n    fcn.00427650();\n    if (bVar3) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)(*(param_1 + 0xc));\n        fcn.00445c36(uVar2);\n    }\n    return;\n}\n",
        "token_count": 183
    },
    "00444e72": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_15ch\n// WARNING: Variable defined which should be unmapped: lpFindFileData\n// WARNING: Variable defined which should be unmapped: lpFilePart\n// WARNING: Variable defined which should be unmapped: var_158h\n\nvoid __cdecl fcn.00444e72(uint lpRootPathName, uint lpFileName)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    int32_t *piVar3;\n    int32_t iVar4;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_15ch;\n    uint var_158h;\n    uint lpFilePart;\n    uint lpFindFileData;\n    uint lpString2;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    uVar1 = *(unaff_EBP + 8);\n    *(unaff_EBP + -0x10) = *0x45c1a8;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetFullPathNameA)(*(unaff_EBP + 0xc), 0x104, uVar1, unaff_EBP + -0x154);\n    if (uVar2 == 0) {\n        (*_sym.imp.KERNEL32.dll_lstrcpynA)(uVar1, *(unaff_EBP + 0xc), 0x104);\n    }\n    else if (uVar2 < 0x104) {\n        piVar3 = fcn.00444854();\n        iVar4 = (**(*piVar3 + 0xc))();\n        *(unaff_EBP + 8) = iVar4 + 0x10;\n        *(unaff_EBP + -4) = 0;\n        fcn.00444e30(uVar1, unaff_EBP + 8);\n        iVar4 = (*_sym.imp.SHLWAPI.dll_PathIsUNCA)(*(unaff_EBP + 8));\n        if ((iVar4 == 0) &&\n           (iVar4 = (*_sym.imp.KERNEL32.dll_GetVolumeInformationA)\n                              (*(unaff_EBP + 8), 0, 0, 0, unaff_EBP + -0x15c, unaff_EBP + -0x158, 0, 0),  iVar4 != 0)) {\n            if ((*(unaff_EBP + -0x158) & 2) == 0) {\n                (*_sym.imp.USER32.dll_CharUpperA)(uVar1);\n            }\n            if (((((*(unaff_EBP + -0x158) & 4) == 0) &&\n                 (iVar4 = (*_sym.imp.KERNEL32.dll_FindFirstFileA)(*(unaff_EBP + 0xc), unaff_EBP + -0x150),  iVar4 != -1)\n                 ) && ((*_sym.imp.KERNEL32.dll_FindClose)(iVar4),  *(unaff_EBP + -0x154) != 0)) &&\n               ((uVar1 <= *(unaff_EBP + -0x154) && *(unaff_EBP + -0x154) != uVar1 &&\n                (iVar4 = (*_sym.imp.KERNEL32.dll_lstrlenA)(unaff_EBP + -0x124), \n                (iVar4 - uVar1) + *(unaff_EBP + -0x154) < 0x104)))) {\n                (*_sym.imp.KERNEL32.dll_lstrcpyA)(*(unaff_EBP + -0x154), unaff_EBP + -0x124);\n            }\n        }\n        fcn.00421110();\n    }\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 838
    },
    "00445c57": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00445c57(uint32_t *arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    uint32_t *puVar4;\n    int32_t in_ECX;\n    uint var_20h;\n    uint lpLastWriteTime;\n    uint lpLastAccessTime;\n    uint lpCreationTime;\n    \n    fcn.00433ba0(arg_8h, 0, 0x128);\n    (*_sym.imp.KERNEL32.dll_lstrcpynA)(arg_8h + 0x22, *(in_ECX + 0xc), 0x104);\n    if (*(in_ECX + 4) == *0x451948) {\ncode_r0x00445d5e:\n        uVar3 = 1;\n    }\n    else {\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetFileTime)\n                          (*(in_ECX + 4), &lpCreationTime, &lpLastAccessTime, &lpLastWriteTime);\n        if (iVar1 != 0) {\n            uVar2 = (*_sym.imp.KERNEL32.dll_GetFileSize)(*(in_ECX + 4), 0);\n            arg_8h[6] = uVar2;\n            arg_8h[7] = 0;\n            if (uVar2 != 0xffffffff) {\n                if (*(*(in_ECX + 0xc) + -0xc) == 0) {\n                    *(arg_8h + 8) = 0;\n                }\n                else {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_GetFileAttributesA)(*(in_ECX + 0xc));\n                    *(arg_8h + 8) = (iVar1 == -1) - 1U & iVar1;\n                }\n                puVar4 = fcn.00425f10(&lpCreationTime, 0xffffffff);\n                *arg_8h = *puVar4;\n                arg_8h[1] = puVar4[1];\n                puVar4 = fcn.00425f10(&lpLastAccessTime, 0xffffffff);\n                arg_8h[4] = *puVar4;\n                arg_8h[5] = puVar4[1];\n                puVar4 = fcn.00425f10(&lpLastWriteTime, 0xffffffff);\n                arg_8h[2] = *puVar4;\n                arg_8h[3] = puVar4[1];\n                if ((*arg_8h | arg_8h[1]) == 0) {\n                    *arg_8h = *puVar4;\n                    arg_8h[1] = puVar4[1];\n                }\n                if ((arg_8h[4] | arg_8h[5]) == 0) {\n                    arg_8h[4] = arg_8h[2];\n                    arg_8h[5] = arg_8h[3];\n                }\n                goto code_r0x00445d5e;\n            }\n        }\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 688
    },
    "00447472": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_4h\n// WARNING: Variable defined which should be unmapped: var_ch\n\nuint __cdecl fcn.00447472(uint arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint extraout_ECX;\n    int32_t unaff_EBP;\n    uint *in_FS_OFFSET;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    piVar1 = fcn.00444854(extraout_ECX);\n    iVar2 = (**(*piVar1 + 0xc))();\n    *(unaff_EBP + -0x10) = iVar2 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    fcn.00427170(*(unaff_EBP + 8));\n    iVar2 = *(unaff_EBP + 0x10);\n    if (iVar2 == -1) {\n        iVar2 = *(unaff_EBP + 8);\n    }\n    uVar3 = fcn.00447450(*(unaff_EBP + -0x10), *(unaff_EBP + 0xc), iVar2);\n    fcn.00421110();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    return uVar3;\n}\n",
        "token_count": 334
    },
    "0044812e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0044812e(uint arg_8h, int32_t Locale)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint lpLibFileName;\n    uint var_4h;\n    \n    var_4h = *0x45c1a8;\n    if (Locale == 0x800) {\n        (*_sym.imp.KERNEL32.dll_lstrcpyA)(&Locale, 0x44facc);\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 3, &Locale, 4);\n        if (iVar2 == 0) goto code_r0x004481a3;\n    }\n    uVar1 = fcn.0043389d(&lpLibFileName, 0x112, arg_8h, &Locale);\n    if ((uVar1 != 0xffffffff) && (uVar1 < 0x112)) {\n        (*_sym.imp.KERNEL32.dll_LoadLibraryA)(&lpLibFileName);\n    }\ncode_r0x004481a3:\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 250
    },
    "00449cbf": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t * __fastcall fcn.00449cbf(int32_t *param_1)\n\n{\n    code *pcVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    uint uStack12;\n    \n    param_1[5] = 0;\n    param_1[6] = 0;\n    param_1[6] = 4;\n    param_1[1] = 0;\n    param_1[2] = 1;\n    param_1[3] = 0;\n    param_1[4] = 0;\n    iVar3 = (*_sym.imp.KERNEL32.dll_TlsAlloc)();\n    *param_1 = iVar3;\n    if (iVar3 == -1) {\n        uStack12 = 0x45ebe8;\n        fcn.00433cb8(&stack0xfffffff4, 0x457564);\n        pcVar1 = swi(3);\n        piVar2 = (*pcVar1)();\n        return piVar2;\n    }\n    uStack12 = 0x449cfd;\n    (*_sym.imp.KERNEL32.dll_InitializeCriticalSection)();\n    return param_1;\n}\n",
        "token_count": 259
    },
    "0044a01f": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid __fastcall fcn.0044a01f(int32_t *param_1)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    uint uVar2;\n    \n    arg_8h = param_1[5];\n    while (arg_8h != 0) {\n        iVar1 = *(arg_8h + 4);\n        fcn.00449e87(arg_8h, 0);\n        arg_8h = iVar1;\n    }\n    if (*param_1 != -1) {\n        (*_sym.imp.KERNEL32.dll_TlsFree)(*param_1);\n    }\n    if (param_1[4] != 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GlobalHandle)(param_1[4]);\n        (*_sym.imp.KERNEL32.dll_GlobalUnlock)(uVar2);\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(uVar2);\n    }\n    (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(param_1 + 7);\n    return;\n}\n",
        "token_count": 231
    },
    "00430d0c": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t fcn.00430d0c(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = (*_sym.imp.USER32.dll_SendMessageA)(*(param_1 + 0x1c), 0x400, 0, 0);\n    if (uVar1 >> 0x10 == 0x534b) {\n        uVar1 = uVar1 & 0xffff;\n    }\n    else {\n        uVar1 = 1;\n    }\n    return uVar1;\n}\n",
        "token_count": 121
    },
    "0043c92a": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043c92a(char *arg_8h, int32_t arg_ch, uint32_t *arg_10h)\n\n{\n    int16_t iVar1;\n    uint32_t *puVar2;\n    uint32_t uVar3;\n    uint var_14h;\n    uint32_t var_10h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    puVar2 = arg_10h;\n    var_4h = *0x45c1a8;\n    iVar1 = 0x404e;\n    *arg_10h = 0;\n    arg_10h[1] = 0;\n    arg_10h[2] = 0;\n    if (arg_ch != 0) {\n        arg_10h = arg_ch;\n        do {\n            var_10h = *puVar2;\n            var_ch = puVar2[1];\n            var_8h = puVar2[2];\n            fcn.0043c8cf(puVar2);\n            fcn.0043c8cf(puVar2);\n            fcn.0043c871(puVar2, &var_10h);\n            fcn.0043c8cf(puVar2);\n            var_10h = *arg_8h;\n            var_ch = 0;\n            var_8h = 0;\n            fcn.0043c871(puVar2, &var_10h);\n            arg_8h = arg_8h + 1;\n            arg_10h = arg_10h + -1;\n        } while (arg_10h != NULL);\n    }\n    if (puVar2[2] == 0) {\n        do {\n            iVar1 = iVar1 + -0x10;\n            uVar3 = puVar2[1] >> 0x10;\n            puVar2[1] = *puVar2 >> 0x10 | puVar2[1] << 0x10;\n            *puVar2 = *puVar2 << 0x10;\n        } while (uVar3 == 0);\n        puVar2[2] = uVar3;\n    }\n    while ((puVar2[2] & 0x8000) == 0) {\n        fcn.0043c8cf(puVar2);\n        iVar1 = iVar1 + -1;\n    }\n    *(puVar2 + 10) = iVar1;\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 562
    },
    "0043e713": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043e713(int32_t arg_8h, uint32_t arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    \n    if (arg_8h == 0) {\n        uVar2 = 0;\n    }\n    else {\n        iVar3 = fcn.00449f75(0x448b0c);\n        if ((*(iVar3 + 0x18) != 0) && (iVar4 = fcn.004420b0(arg_8h),  iVar4 == 0)) {\n            fcn.00442aa8(arg_8h);\n            *(iVar3 + 0x18) = 0;\n        }\n        pcVar1 = _sym.imp.USER32.dll_RegisterWindowMessageA;\n        if (arg_ch == 0x110) {\n            *0x45f070 = (*_sym.imp.USER32.dll_RegisterWindowMessageA)(\"commdlg_LBSelChangedNotify\");\n            *0x45f074 = (*pcVar1)(\"commdlg_ShareViolation\");\n            *0x45f078 = (*pcVar1)(\"commdlg_FileNameOK\");\n            *0x45f07c = (*pcVar1)(\"commdlg_ColorOK\");\n            *0x45f080 = (*pcVar1)(\"commdlg_help\");\n            *0x45f084 = (*pcVar1)(\"commdlg_SetRGBColor\");\n            uVar2 = fcn.004401b5(arg_8h, 0x110, arg_10h, arg_14h);\n        }\n        else if ((arg_ch == *0x45f080) || ((arg_ch == 0x111 && (arg_10h == 0x40e)))) {\n            (*_sym.imp.USER32.dll_SendMessageA)(arg_8h, 0x111, 0xe146, 0);\n            uVar2 = 1;\n        }\n        else {\n            if (0xbfff < arg_ch) {\n                piVar5 = fcn.004420b0(arg_8h);\n                iVar3 = fcn.00444934(0x4516c0);\n                if ((iVar3 == 0) || (iVar3 = fcn.0043e135(),  (*(iVar3 + 0x36) & 8) == 0)) {\n                    if (arg_ch == *0x45f074) {\n                        uVar2 = (**(*piVar5 + 0x158))(arg_14h);\n                        return uVar2;\n                    }\n                    if (arg_ch == *0x45f078) {\n                        piVar5[0x70] = arg_14h;\n                        uVar2 = (**(*piVar5 + 0x15c))();\n                        piVar5[0x70] = 0;\n                        return uVar2;\n                    }\n                    if (arg_ch == *0x45f070) {\n                        (**(*piVar5 + 0x160))(arg_10h, arg_14h & 0xffff, arg_14h >> 0x10);\n                    }\n                    else if (arg_ch == *0x45f07c) {\n                        uVar2 = (**(*piVar5 + 0x158))();\n                        return uVar2;\n                    }\n                }\n            }\n            uVar2 = 0;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 774
    },
    "00441fb1": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nint32_t fcn.00441fb1(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    \n    iVar1 = fcn.00449f75(0x448b0c);\n    uVar2 = (*_sym.imp.USER32.dll_GetMessageTime)();\n    *(iVar1 + 0x68) = uVar2;\n    uVar2 = (*_sym.imp.USER32.dll_GetMessagePos)();\n    *(iVar1 + 0x70) = uVar2 >> 0x10;\n    *(iVar1 + 0x6c) = uVar2;\n    return iVar1 + 0x58;\n}\n",
        "token_count": 141
    },
    "00448b99": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nvoid fcn.00448b99(void)\n\n{\n    uint8_t uVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iStack148;\n    int32_t iStack144;\n    uint8_t *puStack140;\n    uchar auStack136 [128];\n    uint uStack8;\n    \n    uStack8 = *0x45c1a8;\n    uVar2 = (*_sym.imp.USER32.dll_GetMenuCheckMarkDimensions)();\n    iVar5 = uVar2;\n    iStack148 = uVar2 >> 0x10;\n    if (0x20 < iVar5) {\n        iVar5 = 0x20;\n    }\n    iVar6 = iVar5 + 0xf >> 4;\n    iVar7 = ((iVar5 + -4) / 2 + iVar6 * 0x10) - iVar5;\n    if (0xc < iVar7) {\n        iVar7 = 0xc;\n    }\n    if (0x20 < iStack148) {\n        iStack148 = 0x20;\n    }\n    fcn.00433ba0(auStack136, 0xff, 0x80);\n    puVar4 = auStack136 + (iStack148 + -6 >> 1) * iVar6 * 2;\n    puStack140 = 0x44fe38;\n    iStack144 = 5;\n    do {\n        uVar1 = *puStack140;\n        uVar3 = puStack140 & 0xffff0000;\n        puStack140 = puStack140 + 1;\n        uVar3 = ~((uVar3 | uVar1) << (iVar7 & 0x1f));\n        *puVar4 = uVar3 >> 8;\n        puVar4[1] = uVar3;\n        puVar4 = puVar4 + iVar6 * 2;\n        iStack144 = iStack144 + -1;\n    } while (iStack144 != 0);\n    *0x45f060 = (*_sym.imp.GDI32.dll_CreateBitmap)(iVar5, iStack148, 1, 1, auStack136);\n    if (*0x45f060 == 0) {\n        *0x45f060 = (*_sym.imp.USER32.dll_LoadBitmapA)(0, 0x7fe3);\n    }\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 553
    },
    "00427700": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00427700(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint var_ch;\n    int32_t var_8h;\n    uint var_4h;\n    \n    iVar2 = fcn.00421150();\n    if (arg_8h < *(iVar2 + 4)) {\n        arg_8h = *(iVar2 + 4);\n    }\n    cVar1 = fcn.004277a0();\n    if (cVar1 == '\\0') {\n        if (*(iVar2 + 8) < arg_8h) {\n            var_8h = *(iVar2 + 8);\n            if (var_8h < 0x401) {\n                var_8h = var_8h << 1;\n            }\n            else {\n                var_8h = var_8h + 0x400;\n            }\n            if (var_8h < arg_8h) {\n                var_8h = arg_8h;\n            }\n            fcn.00427a40(var_8h);\n        }\n    }\n    else {\n        fcn.00427990(arg_8h);\n    }\n    return;\n}\n",
        "token_count": 265
    },
    "0042b7a4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0042b7a4(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t *puVar2;\n    int32_t iVar3;\n    int32_t in_ECX;\n    uint8_t *puVar4;\n    uint var_8h;\n    int32_t var_4h;\n    \n    if ((*(in_ECX + 0x7c) == 0) || (*(in_ECX + 0x78) == 0)) {\n        var_8h = 0;\n    }\n    else {\n        puVar2 = fcn.0043f71e(*(in_ECX + 0x7c) * 6);\n        iVar3 = (*_sym.imp.USER32.dll_CopyAcceleratorTableA)(*(in_ECX + 0x78), puVar2, *(in_ECX + 0x7c));\n        var_8h = 0;\n        var_4h = 0;\n        if (0 < iVar3) {\n            puVar4 = puVar2;\n            do {\n                if (*(arg_8h + 4) == 0x106) {\n                    uVar1 = 0x10;\n                }\n                else {\n                    uVar1 = 0;\n                }\n                if (((*puVar4 & 0xfd) == uVar1) && (*(puVar4 + 2) == *(arg_8h + 8))) {\n                    var_8h = 1;\n                    break;\n                }\n                var_4h = var_4h + 1;\n                puVar4 = puVar4 + 6;\n            } while (var_4h < iVar3);\n        }\n        fcn.0043f749(puVar2);\n    }\n    return var_8h;\n}\n",
        "token_count": 394
    },
    "00437aa3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00437aa3(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x10);\n    iVar7 = 0;\n    for (iVar3 = *(arg_8h + 8); -1 < iVar3; iVar3 = iVar3 << 1) {\n        iVar7 = iVar7 + 1;\n    }\n    iVar3 = iVar7 * 0x204 + 0x144 + iVar2;\n    iVar6 = 0x3f;\n    iVar4 = iVar3;\n    do {\n        *(iVar4 + 8) = iVar4;\n        *(iVar4 + 4) = iVar4;\n        iVar4 = iVar4 + 8;\n        iVar6 = iVar6 + -1;\n    } while (iVar6 != 0);\n    uVar8 = iVar7 * 0x8000 + *(arg_8h + 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(uVar8, 0x8000, 0x1000, 4);\n    if (iVar4 == 0) {\n        iVar7 = -1;\n    }\n    else {\n        if (uVar8 <= uVar8 + 0x7000) {\n            piVar5 = uVar8 + 0x10;\n            iVar4 = ((uVar8 + 0x7000) - uVar8 >> 0xc) + 1;\n            do {\n                piVar5[-2] = -1;\n                piVar5[0x3fb] = -1;\n                *piVar5 = piVar5 + 0x3ff;\n                piVar5[-1] = 0xff0;\n                piVar5[1] = piVar5 + -0x401;\n                piVar5[0x3fa] = 0xff0;\n                piVar5 = piVar5 + 0x400;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n        *(iVar3 + 0x1fc) = uVar8 + 0xc;\n        *(uVar8 + 0x14) = iVar3 + 0x1f8;\n        *(iVar3 + 0x200) = uVar8 + 0x700c;\n        *(uVar8 + 0x7010) = iVar3 + 0x1f8;\n        *(iVar2 + 0x44 + iVar7 * 4) = 0;\n        *(iVar2 + 0xc4 + iVar7 * 4) = 1;\n        cVar1 = *(iVar2 + 0x43);\n        *(iVar2 + 0x43) = cVar1 + '\\x01';\n        if (cVar1 == '\\0') {\n            *(arg_8h + 4) = *(arg_8h + 4) | 1;\n        }\n        *(arg_8h + 8) = *(arg_8h + 8) & ~(0x80000000U >> (iVar7 & 0x1f));\n    }\n    return iVar7;\n}\n",
        "token_count": 764
    },
    "0043bca5": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0043bca5(uint32_t *arg_8h, uint32_t *arg_ch)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint16_t uVar3;\n    uint16_t uVar4;\n    uint32_t var_4h;\n    \n    uVar1 = *(arg_ch + 6);\n    var_4h = 0x80000000;\n    uVar3 = uVar1 >> 4;\n    uVar4 = uVar3 & 0x7ff;\n    uVar2 = *arg_ch;\n    if ((uVar3 & 0x7ff) == 0) {\n        if (((arg_ch[1] & 0xfffff) == 0) && (uVar2 == 0)) {\n            arg_8h[1] = 0;\n            *arg_8h = 0;\n            *(arg_8h + 2) = 0;\n            return;\n        }\n        uVar4 = uVar4 + 0x3c01;\n        var_4h = 0;\n    }\n    else if (uVar4 == 0x7ff) {\n        uVar4 = 0x7fff;\n    }\n    else {\n        uVar4 = uVar4 + 0x3c00;\n    }\n    arg_8h[1] = uVar2 >> 0x15 | (arg_ch[1] & 0xfffff) << 0xb | var_4h;\n    *arg_8h = uVar2 << 0xb;\n    while (var_4h == 0) {\n        uVar2 = arg_8h[1];\n        uVar4 = uVar4 - 1;\n        arg_8h[1] = uVar2 << 1 | *arg_8h >> 0x1f;\n        *arg_8h = *arg_8h * 2;\n        var_4h = uVar2 << 1 & 0x80000000;\n    }\n    *(arg_8h + 2) = uVar1 & 0x8000 | uVar4;\n    return;\n}\n",
        "token_count": 481
    },
    "0043c8cf": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b"
        ],
        "decompiled_code": "\nvoid fcn.0043c8cf(uint32_t *param_1)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    \n    uVar1 = *param_1;\n    uVar2 = param_1[1];\n    *param_1 = uVar1 * 2;\n    param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;\n    param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;\n    return;\n}\n",
        "token_count": 127
    },
    "00427ef0": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_34h\n\nuint32_t fcn.00427ef0(void)\n\n{\n    uint *in_FS_OFFSET;\n    uint var_8h;\n    uint var_18h;\n    uchar auStack256 [200];\n    uint var_34h;\n    uint var_28h;\n    uint var_20h;\n    uint var_19h;\n    uint var_10h;\n    code *pcStack16;\n    uint uStack12;\n    uint var_4h;\n    \n    uStack12 = 0x44fa18;\n    pcStack16 = fcn.00433438;\n    var_10h = *in_FS_OFFSET;\n    *in_FS_OFFSET = &var_10h;\n    var_4h = 0;\n    fcn.004316c0();\n    *in_FS_OFFSET = var_10h;\n    return auStack256 | 1;\n}\n",
        "token_count": 201
    },
    "004280ea": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nuint32_t fcn.004280ea(uint32_t *param_1)\n\n{\n    int16_t iVar1;\n    int16_t *piVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    \n    uVar3 = *param_1;\n    bVar4 = *(param_1 + 2) == -1;\n    if (bVar4) {\n        uVar3 = param_1[3];\n        piVar2 = param_1 + 0x1a;\n    }\n    else {\n        piVar2 = param_1 + 0x12;\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    if (*piVar2 == -1) {\n        piVar2 = piVar2 + 2;\n    }\n    else {\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    do {\n        iVar1 = *piVar2;\n        piVar2 = piVar2 + 1;\n    } while (iVar1 != 0);\n    if ((uVar3 & 0x40) != 0) {\n        piVar2 = piVar2 + bVar4 * 2 + 1;\n        do {\n            iVar1 = *piVar2;\n            piVar2 = piVar2 + 1;\n        } while (iVar1 != 0);\n    }\n    return piVar2 + 3U & 0xfffffffc;\n}\n",
        "token_count": 382
    },
    "0042da0c": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\nuint32_t __thiscall fcn.0042da0c(int32_t param_1, uint *param_2)\n\n{\n    uint uVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_retaddr;\n    \n    uVar2 = fcn.0042b088(&param_2);\n    if (uVar2 == '\\0') {\n        uVar2 = uVar2 & 0xffffff00;\n    }\n    else {\n        iVar3 = unaff_retaddr * 0x30 + *(param_1 + 0x14);\n        uVar1 = *((*(iVar3 + 0x10) + 3 + *(iVar3 + 4) & 0xfffffffcU) + 4 + *(param_1 + 8));\n        *param_2 = uVar1;\n        uVar2 = CONCAT31(uVar1 >> 8, 1);\n    }\n    return uVar2;\n}\n",
        "token_count": 212
    },
    "004313d1": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n\nvoid __cdecl fcn.004313d1(int32_t arg_8h, uint arg_ch)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    ushort *in_ECX;\n    int32_t iStack24;\n    uint var_10h;\n    uint var_4h;\n    \n    iStack24 = 0x4313e0;\n    uVar1 = (**0x45b0bc)();\n    *(in_ECX + 4) = 0;\n    *in_ECX = 8;\n    if (arg_8h != 0) {\n        iStack24 = arg_8h;\n        iVar2 = (*_sym.imp.KERNEL32.dll_lstrlenA)();\n        if (arg_ch == 0xe) {\n            iVar2 = (*_sym.imp.OLEAUT32.dll_DllRegisterServer)(arg_8h, iVar2);\n        }\n        else {\n            fcn.004316c0();\n            uVar1 = fcn.00427f90(&stack0xffffffe8, arg_8h, iVar2 + 1, uVar1);\n            iVar2 = (*_sym.imp.OLEAUT32.dll_SysReAllocString)(uVar1);\n        }\n        *(in_ECX + 4) = iVar2;\n        if (iVar2 == 0) {\n            fcn.0043e0e7();\n        }\n    }\n    return;\n}\n",
        "token_count": 321
    },
    "00434d10": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl fcn.00434d10(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint var_8h;\n    uint var_ch;\n    uint var_128h_2;\n    uint var_124h_2;\n    uint var_128h;\n    uint lpFilename;\n    uint var_18h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint uStack4;\n    \n    uStack4 = 0x118;\n    var_18h = 0x452df0;\n    fcn.00434920();\n    *(unaff_EBP + -0x1c) = *0x45c1a8;\n    pcVar1 = *0x45f144;\n    if (*0x45f144 == NULL) {\n        if (*(unaff_EBP + 8) == 1) {\n            pcVar4 = \"Buffer overrun detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A buffer overrun has been detected which has corrupted the program\\'s\\ninternal state.  The program cannot safely continue execution and must\\nnow be terminated.\\n\"\n            ;\n        }\n        else {\n            pcVar4 = \"Unknown security failure detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A security error of unknown cause has been detected which has\\ncorrupted the program\\'s internal state.  The program cannot safely\\ncontinue execution and must now be terminated.\\n\"\n            ;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, unaff_EBP + -0x124, 0x104);\n        if (iVar2 == 0) {\n            fcn.004366a0(unaff_EBP + -0x124, \"<program name unknown>\");\n        }\n        iVar2 = unaff_EBP + -0x124;\n        iVar3 = fcn.00431a40(iVar2);\n        if (0x3c < iVar3 + 0xbU) {\n            iVar2 = fcn.00431a40(iVar2);\n            iVar2 = iVar2 + unaff_EBP + -0x155;\n            fcn.0043a7c0(iVar2, 0x452c3c, 3);\n        }\n        fcn.00431a40(iVar2);\n        fcn.004316c0();\n        *(unaff_EBP + -0x18) = &var_18h;\n        fcn.004366a0(&var_18h, pcVar4);\n        fcn.004366b0(&var_18h, 0x452c38);\n        fcn.004366b0(&var_18h, \"Program: \");\n        fcn.004366b0(&var_18h, iVar2);\n        fcn.004366b0(&var_18h, 0x452c38);\n        fcn.004366b0(&var_18h, *(unaff_EBP + -0x128));\n        fcn.0043a6c0(&var_18h, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.00433adf(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 912
    },
    "004287b9": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_94h\n\nvoid __cdecl\nfcn.004287b9(uint arg_8h, uint hWndInsertAfter, uint arg_10h, uint arg_14h, uint arg_18h, uint arg_1ch, uint arg_20h, \n            uint arg_24h)\n\n{\n    ushort uVar1;\n    ushort uVar2;\n    int16_t iVar3;\n    int16_t iVar4;\n    int16_t iVar5;\n    uint uVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint *puVar9;\n    int32_t unaff_EBP;\n    int32_t *arg_8h_00;\n    uint *puVar10;\n    uint *in_FS_OFFSET;\n    uint var_94h;\n    uint var_6ch;\n    uint lpRect;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ah;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint pbstr;\n    uint var_24h;\n    uint var_20h;\n    uint var_10h;\n    uint var_ch;\n    uint var_4h;\n    \n    fcn.00433928();\n    puVar10 = *(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x10) = *0x45c1a8;\n    *(unaff_EBP + -0x34) = puVar10 + 0x12;\n    if (*(unaff_EBP + 0x10) != 0) {\n        uVar1 = *(puVar10 + 0x12);\n        *(unaff_EBP + -0x58) = puVar10[2];\n        *(unaff_EBP + -0x54) = puVar10[1];\n        *(unaff_EBP + -0x50) = *(puVar10 + 3);\n        *(unaff_EBP + -0x4e) = *(puVar10 + 0xe);\n        uVar2 = *(puVar10 + 4);\n        *(unaff_EBP + -0x4a) = uVar1;\n        uVar1 = *(puVar10 + 5);\n        puVar9 = puVar10 + 6;\n        *(unaff_EBP + -0x4c) = uVar2;\n        *(unaff_EBP + -0x48) = uVar1;\n        puVar10 = unaff_EBP + -0x58;\n        *(unaff_EBP + -0x34) = puVar9;\n    }\n    iVar3 = *(puVar10 + 10);\n    iVar4 = *(puVar10 + 3);\n    iVar5 = *(puVar10 + 2);\n    *(unaff_EBP + -0x5c) = *(puVar10 + 0xe) + iVar3;\n    uVar6 = *(*(unaff_EBP + 8) + 0x1c);\n    *(unaff_EBP + -0x68) = iVar5;\n    *(unaff_EBP + -100) = iVar3;\n    *(unaff_EBP + -0x60) = iVar4 + iVar5;\n    (*_sym.imp.USER32.dll_MapDialogRect)(uVar6, unaff_EBP + -0x68);\n    arg_8h_00 = *(unaff_EBP + 0x1c);\n    *(unaff_EBP + -0x28) = 0;\n    if (3 < *(unaff_EBP + 0x20)) {\n        iVar8 = *arg_8h_00;\n        *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) + -4;\n        arg_8h_00 = arg_8h_00 + 1;\n        if (iVar8 != 0) {\n            uVar6 = (*_sym.imp.OLEAUT32.dll_SysReAllocStringLen)(arg_8h_00, iVar8);\n            arg_8h_00 = arg_8h_00 + iVar8 * 2;\n            *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) + iVar8 * -2;\n            *(unaff_EBP + -0x28) = uVar6;\n        }\n    }\n    *(unaff_EBP + -0x2c) = 0;\n    piVar7 = fcn.00444854();\n    iVar8 = (**(*piVar7 + 0xc))();\n    *(unaff_EBP + 0x14) = iVar8 + 0x10;\n    *(unaff_EBP + -4) = 0;\n    *(unaff_EBP + -0x38) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    *(unaff_EBP + -0x30) = 0;\n    if ((*(unaff_EBP + 0x18) == 0x37a) || (*(unaff_EBP + 0x18) == 0x37b)) {\n        iVar8 = *arg_8h_00;\n        arg_8h_00 = arg_8h_00 + 3;\n        *(unaff_EBP + -0x40) = iVar8;\n        *(unaff_EBP + 0x1c) = iVar8 + -0xc;\n        piVar7 = arg_8h_00;\n        if (iVar8 + -0xc != 0) {\n            do {\n                iVar8 = *piVar7;\n                *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + -6;\n                uVar1 = *(piVar7 + 1);\n                arg_8h_00 = piVar7 + 6;\n                *(unaff_EBP + -0x44) = iVar8;\n                *(unaff_EBP + 0x10) = uVar1;\n                if (iVar8 == -0x7ffeffff) {\n                    *(unaff_EBP + -0x3c) = *arg_8h_00;\n                    *(unaff_EBP + -0x30) = *(piVar7 + 10);\n                    fcn.00427580(piVar7 + 0x16);\n                    iVar8 = *(*(unaff_EBP + 0x14) + -0xc);\n                    *(unaff_EBP + 0x1c) = *(unaff_EBP + 0x1c) + (-0x11 - iVar8);\n                    arg_8h_00 = piVar7 + iVar8 + 0x17;\n                    *(unaff_EBP + -0x38) = *(unaff_EBP + 0x10);\n                }\n                else {\n                    iVar8 = fcn.0043f71e(0x1c);\n                    *(unaff_EBP + -0x6c) = iVar8;\n                    *(unaff_EBP + -4) = 1;\n                    if (iVar8 == 0) {\n                        uVar6 = 0;\n                    }\n                    else {\n                        uVar6 = fcn.0042c396();\n                    }\n                    *(unaff_EBP + -4) = 0;\n                    *(unaff_EBP + -0x2c) = uVar6;\n                }\n                piVar7 = arg_8h_00;\n            } while (*(unaff_EBP + 0x1c) != 0);\n            iVar8 = *(unaff_EBP + -0x40);\n        }\n        *(unaff_EBP + 0x20) = *(unaff_EBP + 0x20) - iVar8;\n        *(unaff_EBP + 0x18) = *(unaff_EBP + 0x18) + 0xfffc;\n    }\n    if (**(unaff_EBP + -0x34) == 0x7b) {\n        uVar6 = (*_sym.imp.ole32.dll_CLSIDFromString)();\n    }\n    else {\n        uVar6 = (*_sym.imp.ole32.dll_CLSIDFromProgID)(*(unaff_EBP + -0x34), unaff_EBP + -0x20);\n    }\n    *(unaff_EBP + 0x1c) = uVar6;\n    fcn.004478f7(arg_8h_00, *(unaff_EBP + 0x20), 0);\n    iVar3 = *(unaff_EBP + 0x18);\n    *(unaff_EBP + -4) = 2;\n    *(unaff_EBP + -0x24) = 0;\n    if (((-1 < *(unaff_EBP + 0x1c)) && (iVar8 = fcn.004299db(),  iVar8 != 0)) &&\n       (iVar8 = fcn.0042a3ea(0, unaff_EBP + -0x20, 0, *puVar10, unaff_EBP + -0x68, *(puVar10 + 4), \n                             -(iVar3 != 0x378) & unaff_EBP - 0x94U, *(unaff_EBP + 0x18) == 0x377, *(unaff_EBP + -0x28), \n                             unaff_EBP + -0x24),  iVar8 != 0)) {\n        fcn.0042b88f(1);\n        (*_sym.imp.USER32.dll_SetWindowPos)(*(*(unaff_EBP + -0x24) + 0x20), *(unaff_EBP + 0xc), 0, 0, 0, 0, 0x13);\n        *(*(unaff_EBP + -0x24) + 0x90) = *(unaff_EBP + -0x2c);\n        fcn.004273b0(unaff_EBP + 0x14);\n        *(*(unaff_EBP + -0x24) + 0x94) = *(unaff_EBP + -0x38);\n        *(*(unaff_EBP + -0x24) + 0x98) = *(unaff_EBP + -0x3c);\n        *(*(unaff_EBP + -0x24) + 0x9c) = *(unaff_EBP + -0x30);\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        (*_sym.imp.OLEAUT32.dll_SysStringLen)(*(unaff_EBP + -0x28));\n    }\n    if (*(unaff_EBP + -0x24) == 0) {\n        **(unaff_EBP + 0x24) = 0;\n    }\n    else {\n        **(unaff_EBP + 0x24) = *(*(unaff_EBP + -0x24) + 0x20);\n    }\n    *(unaff_EBP + -4) = 0;\n    fcn.00447c62();\n    fcn.00421110();\n    *in_FS_OFFSET = *(unaff_EBP + -0xc);\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 2530
    },
    "00431700": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00431700(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x004318c4;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x4319e8\n            switch(*((arg_10h & 3) * 4 + 0x4319e8)) {\n            case 0x431a00:\ncode_r0x00431a00:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x431a10:\ncode_r0x00431a10:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x431a24:\ncode_r0x00431a24:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x4319e8\n            switch(*(arg_10h * 4 + 0x4319e8)) {\n            case 0x431a00:\n                goto code_r0x00431a00;\n            case 0x431a10:\n                goto code_r0x00431a10;\n            case 0x431a24:\n                goto code_r0x00431a24;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x4318ec)) {\n            case 0x4318fc:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x004318c4:\n    // WARNING: Could not recover jumptable at 0x004318c6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x431998\n                    puVar1 = (**(uVar3 * -4 + 0x431998))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4319e8)) {\n                case 0x431a00:\n                    goto code_r0x00431a00;\n                case 0x431a10:\n                    goto code_r0x00431a10;\n                case 0x431a24:\n                    goto code_r0x00431a24;\n                }\n                break;\n            case 0x431920:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x004318c4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4319e8)) {\n                case 0x431a00:\n                    goto code_r0x00431a00;\n                case 0x431a10:\n                    goto code_r0x00431a10;\n                case 0x431a24:\n                    goto code_r0x00431a24;\n                }\n                break;\n            case 0x431948:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x004318c4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4319e8)) {\n                case 0x431a00:\n                    goto code_r0x00431a00;\n                case 0x431a10:\n                    goto code_r0x00431a10;\n                case 0x431a24:\n                    goto code_r0x00431a24;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0043175c;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x43184c\n        switch(*((arg_10h & 3) * 4 + 0x43184c)) {\n        case 0x431864:\ncode_r0x00431864:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x431870:\ncode_r0x00431870:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x431884:\ncode_r0x00431884:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x43185c)) {\n        case 0x431864:\n            goto code_r0x00431864;\n        case 0x431870:\n            goto code_r0x00431870;\n        case 0x431884:\n            goto code_r0x00431884;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x431760)) {\n        case 0x431770:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0043175c:\n    // WARNING: Could not recover jumptable at 0x0043175c. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x4317e0\n                puVar1 = (**(uVar2 * 4 + 0x4317e0))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x43184c)) {\n            case 0x431864:\n                goto code_r0x00431864;\n            case 0x431870:\n                goto code_r0x00431870;\n            case 0x431884:\n                goto code_r0x00431884;\n            }\n            break;\n        case 0x43179c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0043175c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x43184c)) {\n            case 0x431864:\n                goto code_r0x00431864;\n            case 0x431870:\n                goto code_r0x00431870;\n            case 0x431884:\n                goto code_r0x00431884;\n            }\n            break;\n        case 0x4317c0:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0043175c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x43184c)) {\n            case 0x431864:\n                goto code_r0x00431864;\n            case 0x431870:\n                goto code_r0x00431870;\n            case 0x431884:\n                goto code_r0x00431884;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2662
    },
    "00433010": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00433010(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x004331d4;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x4332f8\n            switch(*((arg_10h & 3) * 4 + 0x4332f8)) {\n            case 0x433310:\ncode_r0x00433310:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x433320:\ncode_r0x00433320:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x433334:\ncode_r0x00433334:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x4332f8\n            switch(*(arg_10h * 4 + 0x4332f8)) {\n            case 0x433310:\n                goto code_r0x00433310;\n            case 0x433320:\n                goto code_r0x00433320;\n            case 0x433334:\n                goto code_r0x00433334;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x4331fc)) {\n            case 0x43320c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x004331d4:\n    // WARNING: Could not recover jumptable at 0x004331d6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x4332a8\n                    puVar1 = (**(uVar3 * -4 + 0x4332a8))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4332f8)) {\n                case 0x433310:\n                    goto code_r0x00433310;\n                case 0x433320:\n                    goto code_r0x00433320;\n                case 0x433334:\n                    goto code_r0x00433334;\n                }\n                break;\n            case 0x433230:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x004331d4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4332f8)) {\n                case 0x433310:\n                    goto code_r0x00433310;\n                case 0x433320:\n                    goto code_r0x00433320;\n                case 0x433334:\n                    goto code_r0x00433334;\n                }\n                break;\n            case 0x433258:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x004331d4;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x4332f8)) {\n                case 0x433310:\n                    goto code_r0x00433310;\n                case 0x433320:\n                    goto code_r0x00433320;\n                case 0x433334:\n                    goto code_r0x00433334;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x0043306c;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x43315c\n        switch(*((arg_10h & 3) * 4 + 0x43315c)) {\n        case 0x433174:\ncode_r0x00433174:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x433180:\ncode_r0x00433180:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x433194:\ncode_r0x00433194:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x43316c)) {\n        case 0x433174:\n            goto code_r0x00433174;\n        case 0x433180:\n            goto code_r0x00433180;\n        case 0x433194:\n            goto code_r0x00433194;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x433070)) {\n        case 0x433080:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x0043306c:\n    // WARNING: Could not recover jumptable at 0x0043306c. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x4330f0\n                puVar1 = (**(uVar2 * 4 + 0x4330f0))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x43315c)) {\n            case 0x433174:\n                goto code_r0x00433174;\n            case 0x433180:\n                goto code_r0x00433180;\n            case 0x433194:\n                goto code_r0x00433194;\n            }\n            break;\n        case 0x4330ac:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x0043306c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x43315c)) {\n            case 0x433174:\n                goto code_r0x00433174;\n            case 0x433180:\n                goto code_r0x00433180;\n            case 0x433194:\n                goto code_r0x00433194;\n            }\n            break;\n        case 0x4330d0:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x0043306c;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x43315c)) {\n            case 0x433174:\n                goto code_r0x00433174;\n            case 0x433180:\n                goto code_r0x00433180;\n            case 0x433194:\n                goto code_r0x00433194;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2636
    },
    "00433a0b": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x00433a9d: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x00433aa2)\n// WARNING: Removing unreachable block (ram,0x00433ac8)\n// WARNING: Removing unreachable block (ram,0x00433aa7)\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.00433a0b(uint uExitCode, uint arg_ch, uint arg_10h)\n\n{\n    uint uVar1;\n    int32_t unaff_EBP;\n    uint var_4h;\n    \n    fcn.00434920(0x452b60, 8);\n    fcn.004375c5(8);\n    *(unaff_EBP + -4) = 0;\n    if (*0x45f130 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(*(unaff_EBP + 8));\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x45f12c = 1;\n    *0x45f128 = *(unaff_EBP + 0x10);\n    if (*(unaff_EBP + 0xc) == 0) {\n        if (*0x4609a8 != NULL) {\n            while( true ) {\n                *0x4609a4 = *0x4609a4 + -1;\n                if (*0x4609a4 < *0x4609a8) break;\n                if (**0x4609a4 != NULL) {\n                    (***0x4609a4)();\n                }\n            }\n        }\n        fcn.00433989(0x45b090);\n    }\n    fcn.00433989(0x45b09c);\n    *(unaff_EBP + -4) = 0xffffffff;\n    if (*(unaff_EBP + 0x10) != 0) {\n        fcn.00437510(8);\n    }\n    return;\n}\n",
        "token_count": 453
    },
    "0043b8c2": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nvoid fcn.0043b8c2(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    \n    puVar3 = param_1 + (param_2 / 0x20) * 4;\n    iVar1 = fcn.0043c850(*puVar3, 1 << (0x1fU - param_2 % 0x20 & 0x1f), puVar3);\n    iVar2 = param_2 / 0x20 + -1;\n    if (-1 < iVar2) {\n        puVar3 = param_1 + iVar2 * 4;\n        do {\n            if (iVar1 == 0) {\n                return;\n            }\n            iVar1 = fcn.0043c850(*puVar3, 1, puVar3);\n            iVar2 = iVar2 + -1;\n            puVar3 = puVar3 + -1;\n        } while (-1 < iVar2);\n    }\n    return;\n}\n",
        "token_count": 234
    },
    "00431c49": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa",
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00431c49(uint arg_8h, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint in_EAX;\n    uint uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.00435be0(arg_8h, arg_ch, arg_10h, arg_14h, in_EAX, 0, 0, 0);\n    return uVar1;\n}\n",
        "token_count": 104
    },
    "0043f75c": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9"
        ],
        "decompiled_code": "\nint32_t fcn.0043f75c(void)\n\n{\n    int32_t iVar1;\n    \n    iVar1 = fcn.004499d7();\n    return iVar1 + 0x30;\n}\n",
        "token_count": 46
    },
    "00432c74": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nuint32_t * __cdecl fcn.00432c74(uint32_t *arg_8h)\n\n{\n    uint32_t *arg_8h_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    bool bVar4;\n    int64_t iVar5;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar3 = arg_8h[1];\n    if (((uVar3 < 0) || (0x1000 < uVar3)) || ((0xfff < uVar3 && (*arg_8h != 0)))) {\n        arg_8h_00 = NULL;\n    }\n    else {\n        fcn.00436548();\n        uVar3 = arg_8h[1];\n        uVar2 = *arg_8h;\n        if ((uVar3 < 0) || ((uVar3 < 1 && (uVar2 < 0x3f481)))) {\n            arg_8h_00 = fcn.00435d3c(arg_8h);\n            if ((*0x45c6d4 == 0) || (iVar1 = fcn.00436594(arg_8h_00),  iVar1 == 0)) {\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - *0x45c6d0;\n                var_4h = ((uVar3 >> 0x1f) - (*0x45c6d0 >> 0x1f)) - (uVar3 < *0x45c6d0);\n            }\n            else {\n                uVar2 = *0x45c6d0 + *0x45c6d8;\n                uVar3 = *arg_8h_00;\n                var_8h = uVar3 - uVar2;\n                var_4h = ((uVar3 >> 0x1f) - (uVar2 >> 0x1f)) - (uVar3 < uVar2);\n                arg_8h_00[8] = 1;\n            }\n            uVar3 = fcn.004365e0(var_8h, var_4h, 0x3c, 0);\n            *arg_8h_00 = uVar3;\n            if (uVar3 < 0) {\n                *arg_8h_00 = uVar3 + 0x3c;\n                bVar4 = 0x3b < var_8h;\n                var_8h = var_8h - 0x3c;\n                var_4h = var_4h + -1 + bVar4;\n            }\n            _var_8h = fcn.00434ac0(var_8h, var_4h, 0x3c, 0);\n            _var_8h = _var_8h + arg_8h_00[1];\n            uVar3 = fcn.004365e0(_var_8h, 0x3c, 0);\n            arg_8h_00[1] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[1] = uVar3 + 0x3c;\n                _var_8h = _var_8h + -0x3c;\n            }\n            iVar5 = fcn.00434ac0(_var_8h, 0x3c, 0);\n            _var_8h = iVar5 + arg_8h_00[2];\n            uVar3 = fcn.004365e0(_var_8h, 0x18, 0);\n            arg_8h_00[2] = uVar3;\n            if (uVar3 < 0) {\n                arg_8h_00[2] = uVar3 + 0x18;\n                _var_8h = _var_8h + -0x18;\n            }\n            iVar5 = fcn.00434ac0(_var_8h, 0x18, 0);\n            iVar1 = iVar5;\n            if ((iVar5 < 0x100000000) && (iVar5 < 0)) {\n                arg_8h_00[6] = (arg_8h_00[6] + 7 + iVar1) % 7;\n                arg_8h_00[3] = arg_8h_00[3] + iVar1;\n                if (arg_8h_00[3] < 1) {\n                    arg_8h_00[5] = arg_8h_00[5] - 1;\n                    arg_8h_00[3] = arg_8h_00[3] + 0x1f;\n                    arg_8h_00[7] = 0x16c;\n                    arg_8h_00[4] = 0xb;\n                }\n                else {\n                    arg_8h_00[7] = arg_8h_00[7] + iVar1;\n                }\n            }\n        }\n        else {\n            var_8h = uVar2 - *0x45c6d0;\n            var_4h = (uVar3 - (*0x45c6d0 >> 0x1f)) - (uVar2 < *0x45c6d0);\n            arg_8h_00 = fcn.00435d3c(&var_8h);\n            if ((*0x45c6d4 != 0) && (iVar1 = fcn.00436594(arg_8h_00),  iVar1 != 0)) {\n                bVar4 = var_8h < *0x45c6d8;\n                var_8h = var_8h - *0x45c6d8;\n                var_4h = (var_4h - (*0x45c6d8 >> 0x1f)) - bVar4;\n                arg_8h_00 = fcn.00435d3c(&var_8h);\n                arg_8h_00[8] = 1;\n            }\n        }\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 1379
    },
    "004312f4": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.004312f4(int32_t arg_8h, uint arg_ch)\n\n{\n    ushort *in_ECX;\n    \n    if (arg_ch == 10) {\n        *in_ECX = 10;\n    }\n    else {\n        if (arg_ch == 0xb) {\n            *in_ECX = 0xb;\n            in_ECX[4] = -(arg_8h != 0);\n            return;\n        }\n        if (arg_ch == 0x16) {\n            *in_ECX = 0x16;\n        }\n        else if (arg_ch == 0x17) {\n            *in_ECX = 0x17;\n        }\n        else if (arg_ch == 0x19) {\n            *in_ECX = 0x19;\n        }\n        else if (arg_ch == 0x13) {\n            *in_ECX = 0x13;\n        }\n        else {\n            *in_ECX = 3;\n        }\n    }\n    *(in_ECX + 4) = arg_8h;\n    return;\n}\n",
        "token_count": 237
    },
    "00434025": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00434025(int32_t arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    \n    uVar1 = 0;\n    if ((arg_10h == 10) && (arg_8h < 0)) {\n        uVar1 = 1;\n    }\n    fcn.00433fe7(arg_10h, uVar1);\n    return arg_ch;\n}\n",
        "token_count": 101
    },
    "0043adb4": {
        "rules": [
            "check OS version/4b1f5bfe83db45b5a81c3c2e0ddf7ce2"
        ],
        "decompiled_code": "\nvoid fcn.0043adb4(uint32_t param_1, char *param_2, uint32_t param_3)\n\n{\n    int32_t *piVar1;\n    char cVar2;\n    char *pcVar3;\n    char *pcVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    uint32_t uVar7;\n    int32_t iVar8;\n    int32_t iStack1060;\n    int32_t iStack1056;\n    int32_t iStack1052;\n    char *pcStack1048;\n    int32_t iStack1044;\n    int32_t iStack1040;\n    char acStack1036 [1028];\n    uint uStack8;\n    \n    uStack8 = *0x45c1a8;\n    iStack1052 = 0;\n    iStack1056 = 0;\n    if (param_3 == 0) goto code_r0x0043af6e;\n    piVar1 = (param_1 >> 5) * 4 + 0x460640;\n    iVar8 = (param_1 & 0x1f) * 0x24;\n    if ((*(*piVar1 + 4 + iVar8) & 0x20) != 0) {\n        fcn.0043c343(param_1, 0, 0, 2);\n    }\n    if ((*(*piVar1 + iVar8 + 1) & 0x80) == 0) {\n        iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)(*(*piVar1 + iVar8), param_2, param_3, &iStack1060, 0);\n        if (iVar5 == 0) {\n            iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        }\n        else {\n            iStack1040 = 0;\n            iStack1052 = iStack1060;\n        }\ncode_r0x0043aed0:\n        if (iStack1052 != 0) goto code_r0x0043af6e;\n        if (iStack1040 != 0) {\n            if (iStack1040 == 5) {\n                puVar6 = fcn.00434b6a();\n                *puVar6 = 9;\n                puVar6 = fcn.00434b73();\n                *puVar6 = 5;\n            }\n            else {\n                fcn.00434b7c(iStack1040);\n            }\n            goto code_r0x0043af6e;\n        }\n    }\n    else {\n        pcStack1048 = param_2;\n        iStack1040 = 0;\n        if (param_3 != 0) {\n            do {\n                uVar7 = pcStack1048 - param_2;\n                pcVar4 = acStack1036;\n                iStack1044 = 0;\n                do {\n                    if (param_3 <= uVar7) break;\n                    pcVar3 = pcStack1048 + 1;\n                    cVar2 = *pcStack1048;\n                    uVar7 = uVar7 + 1;\n                    if (cVar2 == '\\n') {\n                        iStack1056 = iStack1056 + 1;\n                        *pcVar4 = '\\r';\n                        pcVar4 = pcVar4 + 1;\n                        iStack1044 = iStack1044 + 1;\n                    }\n                    *pcVar4 = cVar2;\n                    pcVar4 = pcVar4 + 1;\n                    iStack1044 = iStack1044 + 1;\n                    pcStack1048 = pcVar3;\n                } while (iStack1044 < 0x400);\n                iVar5 = (*_sym.imp.KERNEL32.dll_WriteFile)\n                                  (*(*piVar1 + iVar8), acStack1036, pcVar4 - acStack1036, &iStack1060, 0);\n                if (iVar5 == 0) {\n                    iStack1040 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                    goto code_r0x0043aed0;\n                }\n                iStack1052 = iStack1052 + iStack1060;\n                if ((iStack1060 < pcVar4 - acStack1036) || (param_3 <= pcStack1048 - param_2)) goto code_r0x0043aed0;\n            } while( true );\n        }\n    }\n    if (((*(*piVar1 + 4 + iVar8) & 0x40) == 0) || (*param_2 != '\\x1a')) {\n        puVar6 = fcn.00434b6a();\n        *puVar6 = 0x1c;\n        puVar6 = fcn.00434b73();\n        *puVar6 = 0;\n    }\ncode_r0x0043af6e:\n    fcn.004316b0();\n    return;\n}\n",
        "token_count": 1068
    },
    "00433ba0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t * fcn.00433ba0(uint32_t *param_1, uint8_t param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    if (param_3 == 0) {\n        return param_1;\n    }\n    uVar1 = param_2;\n    puVar4 = param_1;\n    if (3 < param_3) {\n        uVar2 = -param_1 & 3;\n        uVar3 = param_3;\n        if (uVar2 != 0) {\n            uVar3 = param_3 - uVar2;\n            do {\n                *puVar4 = param_2;\n                puVar4 = puVar4 + 1;\n                uVar2 = uVar2 - 1;\n            } while (uVar2 != 0);\n        }\n        uVar1 = uVar1 * 0x1010101;\n        param_3 = uVar3 & 3;\n        uVar3 = uVar3 >> 2;\n        if (uVar3 != 0) {\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = uVar1;\n                puVar4 = puVar4 + 1;\n            }\n            if (param_3 == 0) {\n                return param_1;\n            }\n        }\n    }\n    do {\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    return param_1;\n}\n",
        "token_count": 387
    },
    "00432e82": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint8_t * __cdecl fcn.00432e82(uint8_t *arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    int32_t iVar3;\n    uint8_t uVar4;\n    uint8_t *puVar5;\n    uint8_t *puVar6;\n    bool bVar7;\n    \n    puVar5 = NULL;\n    iVar3 = fcn.004350c1();\n    iVar3 = *(iVar3 + 0x60);\n    if (iVar3 != *0x460768) {\n        iVar3 = fcn.00434493();\n    }\n    if (*(iVar3 + 8) != 0) {\n        do {\n            uVar4 = *arg_8h;\n            if ((*(uVar4 + 0x1d + iVar3) & 4) == 0) {\n                bVar7 = arg_ch == uVar4;\ncode_r0x00432edd:\n                puVar6 = arg_8h;\n                if (bVar7) {\n                    puVar5 = arg_8h;\n                }\n            }\n            else {\n                puVar6 = arg_8h + 1;\n                uVar1 = *puVar6;\n                if (uVar1 == 0) {\n                    bVar7 = puVar5 == NULL;\n                    arg_8h = puVar6;\n                    uVar4 = uVar1;\n                    goto code_r0x00432edd;\n                }\n                uVar2 = CONCAT11(uVar4, uVar1);\n                uVar4 = uVar1;\n                if (arg_ch == uVar2) {\n                    puVar5 = arg_8h;\n                }\n            }\n            arg_8h = puVar6 + 1;\n            if (uVar4 == 0) {\n                return puVar5;\n            }\n        } while( true );\n    }\n    iVar3 = -1;\n    do {\n        puVar5 = arg_8h;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        puVar5 = arg_8h + 1;\n        uVar4 = *arg_8h;\n        arg_8h = puVar5;\n    } while (uVar4 != 0);\n    iVar3 = -(iVar3 + 1);\n    puVar5 = puVar5 + -1;\n    do {\n        puVar6 = puVar5;\n        if (iVar3 == 0) break;\n        iVar3 = iVar3 + -1;\n        puVar6 = puVar5 + -1;\n        uVar4 = *puVar5;\n        puVar5 = puVar6;\n    } while (arg_ch != uVar4);\n    puVar6 = puVar6 + 1;\n    if (*puVar6 != arg_ch) {\n        puVar6 = NULL;\n    }\n    return puVar6;\n}\n",
        "token_count": 641
    },
    "0043ba30": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0043ba30(uint16_t *arg_8h, uint32_t *arg_ch, int32_t *arg_10h)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_18h;\n    uint32_t var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar1 = arg_8h[5];\n    var_ch = *(arg_8h + 3);\n    var_8h = *(arg_8h + 1);\n    var_4h = *arg_8h << 0x10;\n    uVar5 = uVar1 & 0x7fff;\n    iVar6 = uVar5 - 0x3fff;\n    if (iVar6 == -0x3fff) {\n        iVar6 = 0;\n        uVar5 = fcn.0043b99c();\n        uVar2 = uVar5;\n        if (uVar5 != 0) {\ncode_r0x0043bb48:\n            uVar3 = 0;\n            goto code_r0x0043bb4a;\n        }\n    }\n    else {\n        fcn.0043b981(&var_18h, &var_ch);\n        iVar4 = fcn.0043b90f(&var_ch, arg_10h[2]);\n        if (iVar4 != 0) {\n            iVar6 = uVar5 - 0x3ffe;\n        }\n        iVar4 = arg_10h[1];\n        if (iVar6 < iVar4 - arg_10h[2]) {\n            var_ch = 0;\n            var_8h = 0;\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n        else {\n            if (iVar4 < iVar6) {\n                if (*arg_10h <= iVar6) {\n                    var_8h = 0;\n                    var_4h = 0;\n                    var_ch = 0x80000000;\n                    fcn.0043b9b5(&var_ch, arg_10h[3]);\n                    iVar6 = arg_10h[5] + *arg_10h;\n                    uVar3 = 1;\n                    goto code_r0x0043bb4a;\n                }\n                var_ch = var_ch & 0x7fffffff;\n                iVar6 = arg_10h[5] + iVar6;\n                fcn.0043b9b5(&var_ch, arg_10h[3]);\n                goto code_r0x0043bb48;\n            }\n            fcn.0043b981(&var_ch, &var_18h);\n            fcn.0043b9b5(&var_ch, iVar4 - iVar6);\n            fcn.0043b90f(&var_ch, arg_10h[2]);\n            fcn.0043b9b5(&var_ch, arg_10h[3] + 1);\n            uVar5 = var_ch;\n            uVar2 = var_8h;\n        }\n    }\n    var_8h = uVar2;\n    var_ch = uVar5;\n    iVar6 = 0;\n    uVar3 = 2;\ncode_r0x0043bb4a:\n    var_ch = iVar6 << (0x1fU - arg_10h[3] & 0x1f) | -((uVar1 & 0x8000) != 0) & 0x80000000 | var_ch;\n    if (arg_10h[4] == 0x40) {\n        arg_ch[1] = var_ch;\n        *arg_ch = var_8h;\n    }\n    else if (arg_10h[4] == 0x20) {\n        *arg_ch = var_ch;\n    }\n    return uVar3;\n}\n",
        "token_count": 876
    },
    "00434a39": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint * fcn.00434a39(uint *param_1, int16_t *param_2, int32_t param_3)\n\n{\n    int16_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint *puVar4;\n    \n    puVar4 = param_1;\n    if (param_3 != 0) {\n        do {\n            iVar1 = *param_2;\n            *puVar4 = iVar1;\n            puVar4 = puVar4 + 2;\n            param_2 = param_2 + 1;\n            if (iVar1 == 0) break;\n            param_3 = param_3 + -1;\n        } while (param_3 != 0);\n        if ((param_3 != 0) && (uVar2 = param_3 - 1,  uVar2 != 0)) {\n            for (uVar3 = uVar2 >> 1; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 1;\n            }\n            for (uVar2 = (uVar2 & 1) != 0; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar4 = 0;\n                puVar4 = puVar4 + 2;\n            }\n        }\n    }\n    return param_1;\n}\n",
        "token_count": 322
    },
    "0043b071": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nuint8_t fcn.0043b071(uint32_t param_1)\n\n{\n    if (*0x460630 <= param_1) {\n        return 0;\n    }\n    return *(*((param_1 >> 5) * 4 + 0x460640) + 4 + (param_1 & 0x1f) * 0x24) & 0x40;\n}\n",
        "token_count": 88
    },
    "0043c281": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid __cdecl fcn.0043c281(uint arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    uint var_10h;\n    uint var_4h;\n    \n    fcn.00434920(0x453b90, 8);\n    uVar2 = *(unaff_EBP + 8);\n    iVar1 = *((uVar2 >> 5) * 4 + 0x460640) + (uVar2 & 0x1f) * 0x24;\n    if (*(iVar1 + 8) == 0) {\n        fcn.004375c5(10);\n        *(unaff_EBP + -4) = 0;\n        if (*(iVar1 + 8) == 0) {\n            iVar3 = fcn.0043b293(iVar1 + 0xc, 4000);\n            if (iVar3 == 0) {\n                fcn.00431fde(unaff_EBP + -0x10, 0xffffffff);\n                goto code_r0x0043c30f;\n            }\n            *(iVar1 + 8) = *(iVar1 + 8) + 1;\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        fcn.0043c318();\n    }\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*((uVar2 >> 5) * 4 + 0x460640) + 0xc + (uVar2 & 0x1f) * 0x24);\ncode_r0x0043c30f:\n    fcn.0043495b();\n    return;\n}\n",
        "token_count": 396
    },
    "0043c321": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nvoid fcn.0043c321(uint32_t param_1)\n\n{\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*((param_1 >> 5) * 4 + 0x460640) + 0xc + (param_1 & 0x1f) * 0x24);\n    return;\n}\n",
        "token_count": 74
    },
    "0043c343": {
        "rules": [
            "decompress data using LZO/b26d4b886bd545b48ed63f32c6357c17"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0043c343(uint32_t arg_8h, uint arg_ch, uint arg_10h, uint dwMoveMethod)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int32_t iVar4;\n    uint lDistanceToMove;\n    uint lpDistanceToMoveHigh;\n    \n    lpDistanceToMoveHigh = arg_10h;\n    iVar2 = fcn.0043c240(arg_8h);\n    if (iVar2 == -1) {\n        puVar3 = fcn.00434b6a();\n        *puVar3 = 9;\ncode_r0x0043c39d:\n        iVar2 = -1;\n        lpDistanceToMoveHigh = 0xffffffff;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointer)(iVar2, arg_ch, &lpDistanceToMoveHigh, dwMoveMethod);\n        if (iVar2 == -1) {\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar4 != 0) {\n                fcn.00434b7c(iVar4);\n                goto code_r0x0043c39d;\n            }\n        }\n        puVar1 = *((arg_8h >> 5) * 4 + 0x460640) + 4 + (arg_8h & 0x1f) * 0x24;\n        *puVar1 = *puVar1 & 0xfd;\n    }\n    return CONCAT44(lpDistanceToMoveHigh, iVar2);\n}\n",
        "token_count": 349
    },
    "004469e4": {
        "rules": [
            "calculate modulo 256 via x86 assembly"
        ],
        "decompiled_code": "\nvoid fcn.004469e4(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    if (param_1 != 0) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GlobalFlags)(param_1);\n        for (uVar1 = uVar1 & 0xff; uVar1 != 0; uVar1 = uVar1 - 1) {\n            (*_sym.imp.KERNEL32.dll_GlobalUnlock)(param_1);\n        }\n        (*_sym.imp.KERNEL32.dll_GlobalFree)(param_1);\n    }\n    return;\n}\n",
        "token_count": 131
    },
    "00438510": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nuint fcn.00438510(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    if (*0x4609ac == 0) {\n        fcn.004347e2();\n    }\n    iVar4 = 0;\n    pcVar3 = *0x45f0e0;\n    if (*0x45f0e0 != NULL) {\n        for (; *pcVar3 != '\\0'; pcVar3 = pcVar3 + iVar2 + 1) {\n            if (*pcVar3 != '=') {\n                iVar4 = iVar4 + 1;\n            }\n            iVar2 = fcn.00431a40(pcVar3);\n        }\n        piVar1 = fcn.004335fc(iVar4 * 4 + 4);\n        pcVar3 = *0x45f0e0;\n        *0x45f110 = piVar1;\n        if (piVar1 != NULL) {\n            do {\n                if (*pcVar3 == '\\0') {\n                    fcn.0043360e(*0x45f0e0);\n                    *0x45f0e0 = NULL;\n                    *piVar1 = 0;\n                    *0x4609a0 = 1;\n                    return 0;\n                }\n                iVar4 = fcn.00431a40(pcVar3);\n                if (*pcVar3 != '=') {\n                    iVar2 = fcn.004335fc(iVar4 + 1);\n                    *piVar1 = iVar2;\n                    if (iVar2 == 0) {\n                        fcn.0043360e(*0x45f110);\n                        *0x45f110 = NULL;\n                        return 0xffffffff;\n                    }\n                    fcn.004366a0(iVar2, pcVar3);\n                    piVar1 = piVar1 + 1;\n                }\n                pcVar3 = pcVar3 + iVar4 + 1;\n            } while( true );\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 450
    },
    "00401000": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401000(int16_t *arg_8h)\n\n{\n    int32_t var_4h;\n    \n    // [00] -r-x section size 315392 named .text\n    var_4h = 0;\n    for (; *arg_8h != 0; arg_8h = arg_8h + 1) {\n        var_4h = var_4h + 1;\n    }\n    return var_4h;\n}\n",
        "token_count": 108
    },
    "00401040": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "contain loop"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00401040(uint16_t *arg_8h, uint16_t *arg_ch)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint uVar3;\n    uint32_t uVar4;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    iVar1 = fcn.00401000(arg_8h);\n    iVar2 = fcn.00401000(arg_ch);\n    if (iVar1 == iVar2) {\n        for (var_4h = 0; uVar4 = fcn.00401000(arg_8h),  var_4h < uVar4; var_4h = var_4h + 1) {\n            var_8h._0_2_ = *arg_8h;\n            var_ch._0_2_ = *arg_ch;\n            if ((0x40 < var_8h) && (var_8h < 0x5b)) {\n                var_8h._0_2_ = var_8h + 0x20;\n            }\n            if ((0x40 < var_ch) && (var_ch < 0x5b)) {\n                var_ch._0_2_ = var_ch + 0x20;\n            }\n            if (var_8h != var_ch) {\n                return 1;\n            }\n            arg_8h = arg_8h + 1;\n            arg_ch = arg_ch + 1;\n        }\n        uVar3 = 0;\n    }\n    else {\n        uVar3 = 1;\n    }\n    return uVar3;\n}\n",
        "token_count": 370
    },
    "00401140": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00401140(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    for (var_ch = 0; var_ch < arg_10h; var_ch = var_ch + 1) {\n        *(arg_8h + var_ch) = *(arg_ch + var_ch);\n    }\n    return;\n}\n",
        "token_count": 106
    },
    "00401390": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401390(uint arg_8h, uint arg_ch, int32_t arg_10h, uint arg_14h)\n\n{\n    int32_t arg_8h_00;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = fcn.0043f74e(arg_10h + 1);\n    *(arg_8h_00 + arg_10h) = 0;\n    fcn.00431700(arg_8h_00, arg_ch, arg_10h);\n    fcn.00401190(arg_8h, arg_14h, arg_8h_00, arg_10h);\n    return arg_8h_00;\n}\n",
        "token_count": 166
    }
}